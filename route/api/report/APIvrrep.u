/*************************************************************************
 * I/ROUTE
 *
 * File:	api/report/APIvrrep.u
 *
 * Description:
 *	"Generate From To Report" command.
 *
 * Dependencies:
 *
 * Revision History:
 *
 *
 * History:
 * 06/20/96	ah	creation
 * 04/10/98     ah      Corrected Solaris compilation problems
 *************************************************************************/

/* ------------------------------------------------------------------------
 * Instructions for compiling on Solaris
 * 
 * Depending on how your machine is configured, you may experience problems
 * in compiling this file.
 *
 * If /usr/include/stdio is not installed then
 * cp stdio.h /usr/include 
 *
 * If /usr/include/sys/feature_test.h or va_list.h is not installed then
 * mkdir /usr/include/sys
 * cp feature_test.h /usr/include/sys
 * cp va_list.h      /usr/include/sys
 *
 * You should now be able to compile with
 * cci.vds APIvrrep.u
 */

/***************************************************************************

APIvrrep.u demonstrates how to generate a "from to" report for distributive 
systems using a ppl program.  The program can be modified to support a 
variety of reports and data extraction requirements.

The main() routine prompts the user for the type of distributive system
(piping, hvac or raceway) and the report file name.  GetCompLocate is then 
used to prompt the user to identify the initial component.  GetCompLocate 
could be modified to allow selecting multiple networks or to restrict the 
type of locatable components.

BuildCompList is then called to traverse the distributive system network.
BuildCompList assigns each component an unique item number then stores each 
component in a linked list .  If a component has more than one neighbor, 
BuildCompList traverses each branch in turn.  BuildCompList also detects 
"loops" in the system.  A "type" variable in the component list structure
flags the beginning and ending of branches as well as loops.  
BuildCompList also generates a list of any support (hangers) components for 
each component.

GenCompReport walks through the list generated by BuildCompList and generates 
the actual report.  Attributes  are extracted using the component id and 
formatted as required.  GenCompReport can be modified to support various 
formats.

Note that BuildCompList does not work across reference files.

***************************************************************************
Search for "Report Section" to find where the reports are generated.
The report code is at the end of the file.  A variety or printing routines
are provided to assist in producing customized reports.

You will probably want to avoid modifying code outside of the report
section.
***************************************************************************/
#include "ci_easy.h"
#include "exmacros.h"
#include "ACattrib.h"

//#include "sys/stat.h"
//#include "sys/types.h"
//#include "time.h"

extern stat();
extern EX_build_classlist();

#include "VDmem_ppl.h"
#include "vdparmacros.h"
#include "vrdef.h"
#include "vrparameters.h"
#include "vrmacros.h"

// Stores Component Item
typedef struct 
{
  struct COMP_ITEM *pNext;
  int           Type,TypeNum,TypeMax; // Control branch statements
  unsigned int	ItemNum;
  struct GRid	CompId;
} COMP_ITEM;

COMP_ITEM *g_pCompListHead;
COMP_ITEM *g_pCompListTail;

// Component item types
#define START_BRANCH  2
#define BEGIN_BRANCH  3
#define END_BRANCH    4
#define LOOP_DETECTED 6

// Support components
typedef struct
{
  struct COMP_HNGR *pNext;
  struct GRid CompId;
  struct GRid HngrId;
  int ItemNum;
} COMP_HNGR;

COMP_HNGR *g_pHngrListHead;
COMP_HNGR *g_pHngrListTail;

// Each component gets a sequentially generated item number
int g_ItemNum;  // Global item Number Counter
int g_ItemNumLoop;

struct GRmd_env *g_pMdEnv;

// Process Component Stack Elements
typedef struct
{
  struct PROC_COMP *pNext;
  struct GRid  CompId;
  struct GRid  PrevCompId;
  int   i;
  int   TotalCps;
  int   BranchNum;
  int   ItemNum;
  int   NeiNum;
  struct GRid *pNeiId;
} PROC_COMP;

PROC_COMP *g_pPC_Stack;

// For the reports
char g_RepFileName[80];
FILE *g_pFile;

char g_RouteType; // p - pipe, r = raceway, h = hvac

#define DEBUG_MEM 0
#define DEBUG_OBJ 0

// -------------------------------------------
// Returns 1 if id already processed (loop)
int CheckCompLoop(pCompId)
struct GRid *pCompId;
{
  COMP_ITEM *pItem;

  if (pCompId->objid == NULL_OBJID) return 0;

  for(pItem = g_pCompListHead; pItem; pItem = pItem->pNext)
  {
    if ((pCompId->objid == pItem->CompId.objid) &&
        (pCompId->osnum == pItem->CompId.osnum))
    {
      g_ItemNumLoop = pItem->ItemNum;
      return 1;
    }
  }
  return 0;
}

// -------------------------------------------
// Adds Item to List
int AddCompToList(pCompId,a_ItemNum,a_Type,a_TypeNum,a_TypeMax)
struct GRid *pCompId;
int a_ItemNum;
int a_Type,a_TypeNum,a_TypeMax;
{
  COMP_ITEM *pItem;

  // Major error check
  if (pCompId == NULL)
  {
    return 0;
  }

  // Verify have a component by looking for comp_code
  if (GetCompAttrValue(pCompId,g_pMdEnv,VR_N_COMP_CODE_AN) != 1)
  {
#if DEBUG_OBJ
    printf("NOT COMP: %u,%u\n",pCompId->osnum,pCompId->objid);
#endif
    return 0;
  }
#if DEBUG_OBJ
    printf("IS  COMP: %u,%u\n",pCompId->osnum,pCompId->objid);
#endif

  // Add to comp list
  pItem = _CALLOC(1,COMP_ITEM);
  pItem->ItemNum  = a_ItemNum;
  pItem->Type     = a_Type;
  pItem->TypeNum  = a_TypeNum;
  pItem->TypeMax  = a_TypeMax;
  pItem->CompId.objid = pCompId->objid;
  pItem->CompId.osnum = pCompId->osnum;
  pItem->pNext = NULL;
  
  if (g_pCompListHead == NULL) g_pCompListHead = pItem;
  if (g_pCompListTail != NULL) g_pCompListTail->pNext = pItem;
  g_pCompListTail = pItem;

  return 1;
}

// -------------------------------------------
// Process a Component(recursive)
// Tried passing by value but did not seem to work
int ProcComp( pCompId,pPrevCompId)
struct GRid  *pCompId;
struct GRid  *pPrevCompId;
{
  PROC_COMP *pPC;

  // Variables that will not change from a recusrion call
  // Need not be stacked, when in doubt, stack
  int BuffSize;
  int msg;
  int status;

  // Have to implement own stach handler for recursive data
//  pPC = calloc(1,sizeof(PROC_COMP));
  pPC = _CALLOC(1,PROC_COMP);
  pPC->pNext = g_pPC_Stack;
  g_pPC_Stack = pPC;

  // Xfer arguments
  pPC->CompId.objid     = pCompId->objid;
  pPC->CompId.osnum     = pCompId->osnum;
  pPC->PrevCompId.objid = pPrevCompId->objid;
  pPC->PrevCompId.osnum = pPrevCompId->osnum;

  // Start by seeing if this is a loop
  if (CheckCompLoop(&pPC->CompId)) 
  {
    AddCompToList(&pPC->CompId,g_ItemNumLoop,LOOP_DETECTED,0,0);
    goto ProcComp_Ret;
  }

  // Add Item to List
  g_ItemNum = g_ItemNum + 1;
  if (AddCompToList(&pPC->CompId,g_ItemNum,0,0,0) != 1)
  {
    // Not a piping component
    goto ProcComp_Ret;
  }

  // Pull any supports
  GetCompSupport(&pPC->CompId,g_ItemNum);

  // Get Number of connect points
  GetCompNbOfNeighbours(&pPC->CompId,g_pMdEnv,&pPC->NeiNum);

  // Happens with ACpretend
  if (pPC->NeiNum <= 0) goto ProcComp_Ret;

  // Get all the connect points
  pPC->pNeiId = _CALLOC(pPC->NeiNum, struct GRid);

  BuffSize = sizeof( struct GRid ) * pPC->NeiNum;

  status = ci$send( msg	   = message VRGeneric.VRGetTopo(
					       &msg,
					       BuffSize,
					       &pPC->TotalCps,
					       NULL,
					       NULL,
					       pPC->pNeiId,
					       NULL,
					       g_pMdEnv ),
		  targetid = pPC->CompId.objid,
		  targetos = pPC->CompId.osnum ) ;

  if (!(status & msg & 1))
  {
#if DEBUG_OBJ
    printf("GetTopo Error: %x,%x\n",status,msg);
#endif
    _FREE(pPC->pNeiId);
    goto ProcComp_Ret;
  }
#if DEBUG_OBJ
    printf("GetTopo A_OK : %x,%x\n",status,msg);
#endif

#if DEBUG_OBJ
  if (pPC->TotalCps != pPC->NeiNum)
  {
    printf("TotalCps: %u \n",pPC->TotalCps);
  }
#endif

  // Count actual unprocessed neighbours
  pPC->NeiNum = 0;
  for(pPC->i = 0; pPC->i < pPC->TotalCps; pPC->i = pPC->i + 1)
  {
    // See if previous
    if ((pPC->pNeiId[pPC->i].objid == pPC->PrevCompId.objid) &&
        (pPC->pNeiId[pPC->i].osnum == pPC->PrevCompId.osnum))
    {
      pPC->pNeiId[pPC->i].objid = NULL_OBJID;
    }
    // Any left are real
    if (pPC->pNeiId[pPC->i].objid != NULL_OBJID)
    {
      pPC->NeiNum = pPC->NeiNum + 1;
    }
  }

#if DEBUG_OBJ
  printf("NUM NEIG: %u,%u,%u\n",
    pPC->CompId.osnum,pPC->CompId.objid,pPC->NeiNum);
#endif

  // If more than 1 neighbour, have a branch
  if (pPC->NeiNum > 1)
  {
    // Branch Counter
    pPC->BranchNum = 0 ;
    pPC->ItemNum  = g_ItemNum;

    for(pPC->i = 0; pPC->i < pPC->TotalCps; pPC->i = pPC->i + 1) 
    {
      if(pPC->pNeiId[pPC->i].objid != NULL_OBJID) 
      {
        // New branch
        pPC->BranchNum = pPC->BranchNum + 1 ;

        if(pPC->BranchNum == 1) 
        {
          AddCompToList(&pPC->CompId,   pPC->ItemNum,
            START_BRANCH,pPC->BranchNum,pPC->NeiNum);
        }
        else
        {
          AddCompToList(&pPC->CompId,   pPC->ItemNum,
            BEGIN_BRANCH,pPC->BranchNum,pPC->NeiNum);
       }
        ProcComp(&pPC->pNeiId[pPC->i],&pPC->CompId);

        AddCompToList(&pPC->CompId,   pPC->ItemNum,
            END_BRANCH,pPC->BranchNum,pPC->NeiNum);
      }
    }
  }

  // No Branches
  if (pPC->NeiNum == 1)
  {
    // Find the actual neighbour
    for(pPC->i = 0; pPC->i < pPC->TotalCps; pPC->i = pPC->i + 1)
    {
      if (pPC->pNeiId[pPC->i].objid != NULL_OBJID)
      {
        ProcComp(&pPC->pNeiId[pPC->i],&pPC->CompId);
      }
    }
  }
  _FREE(pPC->pNeiId);

// Takes care of popping the stack
ProcComp_Ret:
  g_pPC_Stack = g_pPC_Stack->pNext;
  _FREE(pPC);
  pPC = g_pPC_Stack;

  // Done
  return 1;
}

// -------------------------------------------
// Traverse the network and build list
int BuildCompList (pCompId,pMdEnv)
struct GRid       *pCompId;
struct GRmd_env   *pMdEnv;
{
  COMP_ITEM *pItem;
  struct GRid PrevCompId;

  // Master Component Item Counter
  g_ItemNum = 0;

  // Save md_env
  g_pMdEnv = pMdEnv;

  // Clear Previous Comp Id
  PrevCompId.objid = NULL_OBJID;

  // Free any existing list
  FreeCompList();

  // Make sure starts out null
  g_pPC_Stack = NULL;

  // Process the Component
  status("Processing...");
  ProcComp(pCompId,&PrevCompId);
  status("Processing complete.");

  // Done
  return 1;
}

// ---------------------------------------------------------------
// Main routine, route type and report file name are optional args
main( argc,argv)
int   argc;
char *argv[];
{
  // Initial sellected component
  struct  GRid      CompId;
  struct  GRmd_env  MdEnv;

  char cmd[128];

#if DEBUG_MEM
  VD_memReset();
  VD_memOn();
#endif

#if DEBUG_OBJ
  printf("\n");
#endif


  message(" I/ROUTE from to report ");

  // Determine type ofr route network
  if (argc > 1) g_RouteType = *argv[1];
  else          g_RouteType = ' ';

  while((g_RouteType!='p') && (g_RouteType!='r') && (g_RouteType!='h'))
  {
    ci$get(prompt = "Enter p,h or r (piping,hvac,raceway)", string = cmd);
    if ((*cmd >= 'A') && (*cmd <= 'Z')) { *cmd = *cmd + 32; }
    g_RouteType = *cmd;
  }

  // Get Report File Name
  if (argc > 2) strcpy(g_RepFileName,argv[2]);
  else          
  {
    *g_RepFileName = NULL;
    GetRepFileName();
  }

  // Make sure globals are NULL
  g_pCompListHead = NULL;
  g_pCompListTail = NULL;
  g_pHngrListHead = NULL;
  g_pHngrListTail = NULL;

  while(1)
  {
    // Locate a component
    if (GetCompLocate(&CompId,&MdEnv) != 1) return 0;

    // Generate list of id's
    BuildCompList(&CompId,&MdEnv);

    // Make a report
    GenCompReport();

    // Free the lists
    FreeCompList();

#if DEBUG_MEM
    // Check for leaks
    VD_memStatus();
#endif

  }
  return 1;
}

// ----------------------------------------------------------
// Prompts the user for a file name and checks it's validity
int GetRepFileName()
{
  FILE *file;
  char  cmd[80];
  
try_again:

  ci$get(prompt = "Enter report file name", string = g_RepFileName);
  if (*g_RepFileName == 0) goto try_again;
  
  file = fopen(g_RepFileName,"rb");
  if (file == NULL) goto wrapup;
  
  fclose(file);
    
  ci$get(prompt = "Overwrite file? (y = yes, n = no)", string = cmd);
  if ((*cmd == 'y') || (*cmd == 'Y')) goto wrapup;
  goto try_again;
    
wrapup:

  return 1;
    
}

#if 0
// ----------------------------------------------------------
// Prompts the user for a file name and checks it's validity
int GetRepFileName()
{
  struct stat state_file ;
  char cmd[80];

  while(1)
  {

    while(*g_RepFileName == NULL)
    {
      ci$get(prompt = "Enter report file name", string = g_RepFileName);
    }
    return 1;
    
    if (stat(g_RepFileName, &state_file)) return 1;

    // Could be a directory
    if (state_file.st_mode & S_IFDIR)
    {
      status("Report file name cannot be a directory!");
    }
    else
    {
      ci$get(prompt = "Overwrite file? (y = yes, n = no)", string = cmd);
      if ((*cmd == 'y') || (*cmd == 'Y')) return 1;
    }
    *g_RepFileName = NULL;
  }
}
#endif

// ----------------------------------------------
// Wrap the locate first element here
int GetCompLocate(pCompId,pMdEnv)
struct GRid *pCompId;
struct GRmd_env *pMdEnv;
{
  int count;
  int status;

  OM_S_CLASSLIST clist;						
  int size;
  char *classnames[2];

  /* Specify eligible classes for locate as below */
  switch(g_RouteType)
  {
    case 'p':
      classnames[0]="VRPComp";
      classnames[1]="VRPCComp";
    break;
    case 'h':
      classnames[0]="VRHComp"; 
      classnames[1]="VRHCComp"; 
    break;
    case 'r':
      classnames[0]="VRRComp"; 
      classnames[1]="VRRCComp"; 
    break;
  }

  size = 2;
  clist.p_classes = _CALLOC(size,  OMuword);              
  if (clist.p_classes == 0) return 0;				

  ex$build_classlist ( classnames  = classnames,		
                              size        = size,			
                              p_classlist = &clist );
			
  clist.w_flags = OM_CLST_subclass;

  do
  {
    count = 1;
    status = ci$locate( 
      prompt       = "Select Dangle", 
      obj          = &pCompId->objid,
      osnum        = &pCompId->osnum,
      eligible_classes = &clist,
      md_env       = pMdEnv,
      properties   = LC_DP_ONLY | LC_LC_ONLY | LC_RW,
      owner_action = LC_RIGID_COMP | LC_RIGID_OWNER | LC_FLEX_COMP | LC_FLEX_OWNER | LC_REF_OBJECTS,
      stackable    = 1,
      count	   = &count);
  }
  while(status != 1);
  _FREE(clist.p_classes);
  return 1;
}

// ------------------------------------------
// Looks up given attribute value
// Look up "spec_code" as a way of verifying route parameter
int GetCompAttrValue(pCompId,pMdEnv,pAttrName)
struct GRid *pCompId;
struct GRmd_env *pMdEnv;
char *pAttrName;
{
  int msg;
  int status;
  int index;

  struct ACrg_coll RgColl;

  // Get the data
  strcpy(RgColl.name,pAttrName);
  status = vd$review_parameters(
    pMsg = &msg, 
    pComponent =  pCompId,
    NbParams   =  1,
    pList      = &RgColl,
    pMdEnv     =  pMdEnv);

  if (status != 1)
  {
    return 0;
  }
  return 1;
}

/* --------------------------------------------------
  Returns the number of neighbors for given comp id.
  Returns 0 if fails.
*/
int GetCompNbOfNeighbours(pCompId,pMdEnv,pNbOfNeighbours)
struct GRid     *pCompId;
struct GRmd_env *pMdEnv;
int             *pNbOfNeighbours;
{
  int msg;
  int status;

  status = ci$send( msg = message VRGeneric.VRGetNumberOfCpts(
						       &msg,
						       pNbOfNeighbours,
						       pMdEnv ),
		  targetid = pCompId->objid,
		  targetos = pCompId->osnum ) ;

  if (status != 1)
  {
    *pNbOfNeighbours = -1;
    return 0;
  }

#if DEBUG_OBJ
  printf("NUM COMP: %u,%u,%u\n",
    pCompId->osnum,pCompId->objid,*pNbOfNeighbours);
#endif

  return 1;
}

/* ------------------------------------------------ */
/* Stores any support id's                          */
int GetCompSupport(pCompId, ItemNum)
struct GRid *pCompId;
int ItemNum;
{
  IGRlong 	msg;
  IGRlong       status;
  IGRint 	NbHangers, i;
  IGRint	size;
  IGRdouble	d30CpCoors[30];
  struct GRid	s10HangerIds[10];
  COMP_HNGR   *pHngr;

  status = ci$send(msg=message VRGeneric.VRGetHangers(&msg,10, s10HangerIds,
			 &NbHangers, d30CpCoors, g_pMdEnv),
		  targetid = pCompId->objid,
		  targetos = pCompId->osnum ) ;

  for(i = 0; i < NbHangers; i = i + 1)
  {
    pHngr = _CALLOC(1,COMP_HNGR);
    pHngr->CompId.objid = pCompId->objid;
    pHngr->CompId.osnum = pCompId->osnum;
    pHngr->HngrId.objid = s10HangerIds[i].objid;
    pHngr->HngrId.osnum = s10HangerIds[i].osnum;
    pHngr->ItemNum = ItemNum;

    if (g_pHngrListHead == NULL) g_pHngrListHead = pHngr;
    if (g_pHngrListTail != NULL) g_pHngrListTail->pNext = pHngr;
    g_pHngrListTail = pHngr;
  }

  return 1;
}

// -------------------------------------------------
// Frees up allocated component list and hanger list
int FreeCompList()
{
  COMP_ITEM *pComp,*pCompNext;
  COMP_HNGR *pHngr,*pHngrNext;

  for(pComp = g_pCompListHead; pComp; pComp = pCompNext)
  {
    pCompNext = pComp->pNext;
    _FREE(pComp);
  }
  g_pCompListHead = NULL;
  g_pCompListTail = NULL;

  for(pHngr = g_pHngrListHead; pHngr; pHngr = pHngrNext)
  {
    pHngrNext = pHngr->pNext;
    _FREE(pHngr);
  }
  g_pHngrListHead = NULL;
  g_pHngrListTail = NULL;

}

/*****************************************************************

  Report Section

  Once a list of component id's has been generated, call
  GenCompReport() to actually produce a report.

  GenCompReport fills in an array of type COMP_REP for each of the
  different reports (piping,hvac,raceway) define.  Each COMP_REP
  represents a component attribute and includes the name and formating
  information.

  GenCompReport prints the header (top of page) section.  It then
  cycles through the list of component id's and prints each one.

  GenCompReport finishes by printing a different type of report for
  any supports (hangers) which may have been found.

  The following functions are provided:

  GenCompReport - Main report generator

  SetCompRep    - Helper function to fill in values for COMP_REP

  PrintCompHeader - Prints report header information
  PrintCompData   - Prints 1 component

  PrintBeginBranch - Prints Branch Information
  PrintStartBranch
  PrintEndBranch

  PrintCheck  - Gets called each time a line is printed.  It checks
                to make sure that there is room on the page for another
                line.  If there are > REP_PAGE_LINES lines already printed 
                then a new page is started and a new header section printed.

  PrintChar     - Prints a single character across the width of the page
  PrintStr      - Prints 1 line.
  PrintNewLine  - Prints a new (blank) line.
  PrintPageNum  - Prints page number and date/time.
  PrintCentered - Prints a centered line.
  PrintFormFeed - Ejects a page from the printer.

  PrintOpen  - Opens  print file.
  PrintClose - Closes print file.

  PrintSupports   - Prints hanger report
  PrintHngrHeader - Prints hanger header section.

****************************************************************************/

#define REP_PAGE_WIDTH 132
#define REP_PAGE_LINES  60

#define REP_TYPE_COMP 0
#define REP_TYPE_HNGR 1

// How to print a single component attribute
typedef struct
{
  int  width;     // Total field width
  char fmt [16];  // printf Format string to use, 
  char hdr1[16];  // Upper column header
  char hdr2[16];  // Lower column header
                  // Note: attribute name is stored in ACrg_coll
} COMP_REP;

COMP_REP          g_CompRep[16];
struct ACrg_coll  g_RgColl [16];

int   g_NumAttrs;     // Number of attributes in report
int   g_PageNum;      // Current page number
int   g_LineNum;      // Current line number
int   g_RepType;      // 0 = Component, 1 = Support
char  g_RepName[32];  // Name of the report

// -----------------------------------------------
// Master report generator
int GenCompReport()
{
  char cmd[128];
  COMP_ITEM *pItem;

  // Setup file
  if (PrintOpen(g_RepFileName) != 1) return 0;

  // Specify attributes for each type of report
  switch(g_RouteType)
  {
    case 'p':
      strcpy(g_RepName,"P I P I N G");
      g_NumAttrs = 10;
      SetCompRep(0,10,"%s",     "",    "COMP",   VR_N_COMP_CODE_AN);
      SetCompRep(1,10,"%s",     "",    "CLASS",  VR_N_CLASS_AN);
      SetCompRep(2,10,"%s",     "",    "ZONE",   VR_N_ZONE_AN);
      SetCompRep(3,10,"%s",     "SEQ", "NUMBER", VR_N_SEQ_NUMBER_AN);
      SetCompRep(4,10,"%4.1f\"","DIAM","GREEN",  VR_N_GDIAMETER_DB);
      SetCompRep(5,10,"%4.1f\"","DIAM","RED",    VR_N_RDIAMETER_DB);
      SetCompRep(6,10,"%s",     "INSUL","TYPE",  VR_N_INSUL_TYPE_AN);
      SetCompRep(7,10,"%4.1f\"","INSUL","THK",   VR_N_INSUL_THK_DB);
      SetCompRep(8,10,"%s",     "HEAT", "TRACE", VR_N_TRACING_CODE_AN);
      SetCompRep(9,10,"%s",     "FLUID","CODE",  VR_N_FLUID_CODE_AN);
    break;

    case 'h':
      strcpy(g_RepName,"H V A C");
      g_NumAttrs = 11;
      SetCompRep( 0,10,"%s",     "",     "COMP",    VR_N_COMP_CODE_AN);
      SetCompRep( 1,10,"%s",     "",     "CLASS",   VR_N_CLASS_AN);
      SetCompRep( 2,10,"%4.1f\"","WIDTH","GREEN",   VR_N_WIDTH1_DB);
      SetCompRep( 3,10,"%4.1f\"","DEPTH","GREEN",   VR_N_DEPTH1_DB);
      SetCompRep( 4,10,"%4.1f\"","WIDTH","REP",     VR_N_WIDTH2_DB);
      SetCompRep( 5,10,"%4.1f\"","DEPTH","RED",     VR_N_DEPTH2_DB);
      SetCompRep( 6,10,"%.0f",   "SHAPE","CODE",    VR_N_SHAPE_IN);
      SetCompRep( 7,10,"%s",     "INSUL","TYPE",    VR_N_INSUL_TYPE_AN);
      SetCompRep( 8,10,"%4.1f\"","INSUL","THK",     VR_N_INSUL_THK_DB);
      SetCompRep( 9,10,"%8.1f",  "FLOW", "FT3/MIN", VR_N_FLOW_RATE_DB);
      SetCompRep(10,10,"%8.1f",  "VELOC","FT/S",    VR_N_MAX_VELOC_DB);
    break;

    case 'r':
      strcpy(g_RepName,"R A C E W A Y S");
      g_NumAttrs = 9;
      SetCompRep( 0,10,"%s",     "",     "COMP",    VR_N_COMP_CODE_AN);
      SetCompRep( 1,10,"%s",     "",     "CLASS",   VR_N_CLASS_AN);
      SetCompRep( 2,10,"%4.1f\"","WIDTH","GREEN",   VR_N_WIDTH1_DB);
      SetCompRep( 3,10,"%4.1f\"","DEPTH","GREEN",   VR_N_DEPTH1_DB);
      SetCompRep( 4,10,"%4.1f\"","WIDTH","REP",     VR_N_WIDTH2_DB);
      SetCompRep( 5,10,"%4.1f\"","DEPTH","RED",     VR_N_DEPTH2_DB);
      SetCompRep( 6,10,"%.0f",   "SHAPE","CODE",    VR_N_SHAPE_IN);
      SetCompRep( 7,10,"%s",     "INSUL","TYPE",    VR_N_INSUL_TYPE_AN);
      SetCompRep( 8,10,"%4.1f\"","INSUL","THK",     VR_N_INSUL_THK_DB);
    break;
  }


  // Begin of the printing process

  g_PageNum = 0;
  g_LineNum = 0;
  g_RepType = REP_TYPE_COMP;
  PrintCompHeader();

  PrintStr("BEGIN TRACE\n");

  // Cycle Through
  for(pItem = g_pCompListHead; pItem; pItem = pItem->pNext)
  {
    switch(pItem->Type)
    {
      case 0: 
        PrintCompData(pItem);
      break;

      case START_BRANCH:
        PrintStartBranch(pItem);
      break;

      case BEGIN_BRANCH:
        PrintBeginBranch(pItem);
      break;

      case END_BRANCH:
        PrintEndBranch(pItem);
      break;

      case LOOP_DETECTED:
        PrintCompData(pItem);
        PrintStr("LOOP DETECTED\n");
      break;
    }
  }

  // Finish Up
  PrintStr("END TRACE\n");
  PrintSupports();
  PrintClose();

  // Toss file into editor for debugging
  //  sprintf(cmd,"me %s &",g_RepFileName);
  //  system (cmd);

  // Done
  return 1;
}

// -----------------------------------------------
// Fills in values for 1 report column
int SetCompRep(i,width,fmt,hdr1,hdr2,attr)
int i,width;
char *fmt,*hdr1,*hdr2,*attr;
{
  COMP_REP *pCompRep;
  pCompRep = &g_CompRep[i];

  pCompRep->width = width;

  strcpy(pCompRep->fmt, fmt);
  strcpy(pCompRep->hdr1,hdr1);
  strcpy(pCompRep->hdr2,hdr2);

  strcpy(g_RgColl[i].name,attr);
  return 1;
}

// -----------------------------------------------
// Print Header of report
int PrintCompHeader()
{
  int  i;
  char line[150];
  char data[64];
  char fmt [12];
  COMP_REP *pRep;

  // Stuff at top
  PrintChar('='); 
  PrintNewLine();

  PrintCentered(g_RepName);
  PrintNewLine();

  PrintPageNum();
  PrintNewLine();

  PrintCentered("F R O M - T O  R E P O R T");
  PrintNewLine();

  PrintChar('=');
  PrintNewLine();
  PrintNewLine();

  // First column header line
  sprintf(line,"%-10s ","");
  for(i = 0; i < g_NumAttrs; i = i + 1)
  {
    pRep = &g_CompRep[i];
    sprintf(fmt,"%%-%us ",pRep->width);
    sprintf(data,fmt,pRep->hdr1);
    strcat(line,data);
  }
  strcat  (line,"\n");
  PrintStr(line);

  // Second column header line
  sprintf(line,"%-10s ","ITEM");
  for(i = 0; i < g_NumAttrs; i = i + 1)
  {
    pRep = &g_CompRep[i];
    sprintf(fmt,"%%-%us ",pRep->width);
    sprintf(data,fmt,pRep->hdr2);
    strcat(line,data);
  }
  strcat  (line,"\n");
  PrintStr(line);
  PrintChar('-');
  return 1;
}

// -----------------------------------------------
// Prints Data for single component
int PrintCompData(pItem)
COMP_ITEM *pItem;
{
  long  msg;
  int   i;
  char  line[150];
  char  data[80];
  COMP_REP *pRep;

  // Get the data
  vd$review_parameters(
    pMsg = &msg, 
    pComponent = &pItem->CompId,
    NbParams   =  g_NumAttrs,
    pList      =  g_RgColl,
    pMdEnv     =  g_pMdEnv);

  // Dump it
  sprintf(line,"%-10u ",pItem->ItemNum);
  for(i = 0; i < g_NumAttrs; i = i + 1)
  {
    pRep = &g_CompRep[i];
    switch( g_RgColl[i].desc.type )
    {
      case AC_ATTRIB_TEXT: 
        sprintf(data,pRep->fmt,g_RgColl[i].desc.value.att_txt); 
      break;

      case AC_ATTRIB_DOUBLE: 
        sprintf(data,pRep->fmt,g_RgColl[i].desc.value.att_exp); 
      break;

      default:
        strcpy(data,"*ERROR*");

    }
    // Fix width
    *(data + pRep->width + 1) = NULL;
    while(strlen(data) <= pRep->width) strcat(data," ");
    strcat(line,data);
  }
  strcat(line,"\n");
  PrintStr(line);
  return 1;
}


// ------------------------------------------------
// Start of a branch
int PrintStartBranch(pItem)
COMP_ITEM *pItem;
{
  PrintNewLine(); 
  PrintCheck();
  fprintf(g_pFile,"START BRANCH %u OF %u (ITEM %u)\n",
          pItem->TypeNum,pItem->TypeMax,pItem->ItemNum);
  PrintCompData(pItem);
  return 1;
}

// ------------------------------------------------
// Beginning of a branch
int PrintBeginBranch(pItem)
COMP_ITEM *pItem;
{
  PrintNewLine(); 
  PrintCheck();
  fprintf(g_pFile,"BEGIN BRANCH %u OF %u (ITEM %u)\n",
          pItem->TypeNum,pItem->TypeMax,pItem->ItemNum);
  PrintCompData(pItem);
  return 1;
}

// ------------------------------------------------
// Ending of a branch
int PrintEndBranch(pItem)
COMP_ITEM *pItem;
{
  PrintCheck();
  fprintf(g_pFile,"END BRANCH %u (ITEM %u)\n",
          pItem->TypeNum,pItem->ItemNum);
  return 1;
}

// ------------------------------------------------
// Prints character string
int PrintStr(str)
char *str;
{
  PrintCheck();
  fprintf(g_pFile,"%s",str);
  return 1;
}

// ------------------------------------------------
// Prints a new (empty) line
int PrintNewLine()
{
  PrintCheck();
  fprintf(g_pFile,"\n");
  return 1;
}

// ------------------------------------------------
// Prints a form feed (to start new page)
int PrintFormFeed()
{
  fprintf(g_pFile,"%c\n",0x0C);
  return 1;
}

// --------------------------------------------
// Repeats character across width of page
int PrintChar(c)
char c;
{
  int i;

  PrintCheck();

  for(i = 0; i < REP_PAGE_WIDTH; i = i + 1)
  {
    fprintf(g_pFile,"%c",c);
  }
  fprintf(g_pFile,"\n");
  return 1;
}

// --------------------------------------------
// Centers the string on the page
int PrintCentered(str)
char *str;
{
  int cnt,i;

  PrintCheck();

  cnt = (REP_PAGE_WIDTH - strlen(str)) / 2;
  for(i = 0; i < cnt; i = i + 1)
  {
    fprintf(g_pFile," ");
  }
  fprintf(g_pFile,"%s\n",str);
  
  return 1;
}

// -----------------------------------------------
// Checks to see if room for line on page
// Starts new page if required
int PrintCheck()
{
  g_LineNum = g_LineNum + 1;
  if (g_LineNum < REP_PAGE_LINES) return 1;
  g_LineNum = 0;

  PrintFormFeed();

  switch(g_RepType)
  {
    case REP_TYPE_COMP: PrintCompHeader(); break;
    case REP_TYPE_HNGR: PrintHngrHeader(); break;
  }

  return 1;
}

extern time ();
extern ctime();

// ------------------------------------------------
// Prints right justified page number and date/time
int PrintPageNum()
{
  char date[64],*p;
  char page[64];
  int  cnt,i;

  long current_time;  // From types.h

  PrintCheck();

  // Print current date/time
  time(&current_time);
  strcpy(date,(char*)ctime(&current_time));
  for(p = date; *p >= ' '; p = p + 1);
  *p = NULL;

  fprintf(g_pFile,"%s",date);

  // Format page number
  g_PageNum = g_PageNum + 1;
  sprintf(page,"PAGE - %3u",g_PageNum);

  // Speces between date and page
  cnt = REP_PAGE_WIDTH - strlen(date) - strlen(page);
  while(cnt > 0)
  {
    fprintf(g_pFile," ");
    cnt = cnt - 1;
  }
  fprintf(g_pFile,"%s\n",page);
  return 1;
}

// -------------------------------------------------
// Open Print File
int PrintOpen(file_name)
char *file_name;
{
  g_pFile = fopen(file_name,"wt");
  if (g_pFile == NULL)
  {
    status("Could not open report file!");
    return 0;
  }
  return 1;
}

// -------------------------------------------------
// Closes print file
int PrintClose()
{
  fclose(g_pFile);
  return 1;
}

/****************************************************************
  Hanger Support Report Generator
****************************************************************/

// -------------------------------------------------
// Support attribute information
struct tagVRSupAttr	
{
    IGRchar	szTagNumber [20];
    IGRdouble	dSize;
    IGRint	Type;
    IGRchar	szDetailNumber [20];
    IGRdouble	dWeight;
    IGRchar	szRemarks [40];
    IGRint	ApprvStatus;
    IGRint	ConstrStatus;
    IGRchar	cNoMtoFlag;
};

// --------------------------------------------------
// Print any support hangers found
int PrintSupports()
{
  IGRlong 	      msg,status;
  struct tagVRSupAttr sSupAttr;
  COMP_HNGR *pHngr;

  // See if had any
  if (g_pHngrListHead == NULL) return 1;

  // Header
  g_LineNum = 0;
  g_RepType = REP_TYPE_HNGR;
  PrintFormFeed();
  PrintHngrHeader();

  // Loop Through
  for(pHngr = g_pHngrListHead; pHngr; pHngr = pHngr->pNext)
  {
    status = ci$send(msg = message VRHanger.VRGetAttributes(&msg, &sSupAttr),
			  targetid = pHngr->HngrId.objid,
			  targetos = pHngr->HngrId.osnum);

    PrintCheck();
    fprintf(g_pFile,"%u\t%s\t\t%lf\t%i\t%s\t\t%lf\n",
      pHngr->ItemNum,
      sSupAttr.szTagNumber, sSupAttr.dSize,  
      sSupAttr.Type, sSupAttr.szDetailNumber,  sSupAttr.dWeight);
  }
  return 1;
}

// ----------------------------------------------------------
// Prints hanger header information
int PrintHngrHeader()
{
  PrintChar('=');
  PrintCentered("S U P P O R T   I N F O R M A T I O N");
  PrintNewLine();
  PrintPageNum();
  PrintNewLine();
  fprintf(g_pFile,"ITEM\tTAG NUMBER\tSIZE\t\tTYPE\tDETAIL NUMBER\tWEIGHT\n");
  PrintChar('-');
  return 1;
}

