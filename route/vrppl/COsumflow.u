/* -------------------------------------------------------------- */
/*
/*      * 19 Apr 99     02.05.02.01
/*
/*              Anand
/*              - Adapted this PPL (originally COflow.u) to get it to 
/*              work for the "Sum Air Flow" command (for TR 179900287).
/*
/*      * 15 Dec 95     02.04.00.11
/*
/*              Shankar
/*              - Fix to avoid display of components whose Equi.
/*              Diameter is not found in database.
/*
/*	* 27 Sep 94	02.03.01.19
/*	
/*		Lori
/*		- Fix to avoid duct work in reference files
/*		from being resized. TR#179148458
/*
/*
/*	* 26 Aug 94	02.03.01.10
/*		
/*		Manyam
/*		- Fix for the flow related problems encountered 
/*		with SPLITS during Resizing( incorrect flow values 
/*		being assigned to all correction components ). 
/*		Broadcast the function "VRSetCorCmpFlow()" to
/*		all the elements in the subgraph.
/*
/*	* 23 Aug 94	02.03.01.03
/*
/*		Manyam
/*		- Fix for the correction problem encountered with 
/*		  Splits during resizing( Transition length problems).
/*
/*	* 21 Jul 94	02.03.01.02
/*
/*		Manyam
/*		- Fix to avoid Nozzles from getting resized during 
/*		resizing & also did some clean up.
/*
/*	* 28-Oct-91	1.4.3.6	
/*
/*		Bruno
/*		- Add a call to VRupdate_diam function for updation
/*		of the equivalent diameter in the components' parameter
/*		box.
/*		- Remove call to VRkludge_flow ( right before call to
/*		VRupdate_diam ) because it was useless since VRcompute_flow
/*		stores the flow in the component and its parameter box.
/*
/* -------------------------------------------------------------- */
#include <stdio.h>
#include "ciminimum.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "nddef.h"
#include "GMdef.h"
#include "GM.h"
#include "GMmacros.h"
#include "GMerrordef.h"
#include "ACrg_collect.h"
#include "VRsize.h"
#include "graph.h"
#include "ndmacros.h"
#include "VRGlobMac.h"
#include "VRDbStruct.h"

/*D
  Description : Ask to the user the graph to compute  and compute the flow for
                all the elements of the selected graph
  Constraint  : none
*/ 
 
#define MAX_RESP        256   /* Maximum length for a response                */
#define MSG0                  "Sum Air Flow"
#define MSG1                  "Select the origin the Net"
#define MSG2                  "Accept/Reject"
#define MSG3                  "Select the parts to avoid /Reject"
#define MSG8                  "Computing the air flow..."

extern  UI_message();         /* Function to display the message field        */
extern  UI_prompt();          /* Function to display the prompt field         */
extern  UI_status();          /* Function to display the status field         */
extern  GMinit_graph();       /* Function to activate a graph                 */
extern  int GMget_graph();    /* Function to get a graph                      */
extern  GMbroadcast_graph();  /* Function to broadcast a graph                */
extern  GMremove_graph();     /* Function to disactivate a graph              */
extern  GMsel_and();          /* Function to select the nodes of the graph    */
extern  GMl_activate();       /* Function to activate a list                  */
extern  GMl_disactivate();    /* Function to disactivate a list               */
extern  int VRget_diconnect();    /* Function to get the directed connexions...   */
extern  VRinject_flow();      /* Function to update the flow for terminators  */
extern  VRcompute_flow();     /* Function to compute the resultanat flow      */
extern  VRdisplay_elmt();     /* Function to highlight an element of the net  */
extern  VRmodify_body();      /* Function to modify the body's elements       */
extern  VRGetPath();	      /* Function to retrieve the path to the ascii   */
extern  VRget_fixobj();       /* Function to get fix objects of the net       */
extern  VRadd_batch();        /* Function to add the parents in the batch     */
extern  CIexpand();           /* Function to expand the path                  */
extern  NDexec_batch();       /* Function to execute the batch                */
extern  NDget_list();	      /* Get list of component from working graph     */
extern  NDget_graph();	      /* Get assoc graph of the modified components   */
extern  NDupdate_graph();     /* Update assoc graph			      */
extern int FI_msg_box();      /* Function to diaply the error box	      */
extern int VRSetCorCmpFlow(); /* Function to update flow values in cor-cmps   */


extern GRclassid OPP_VRNozzle_class_id;
extern GRclassid OPP_VRComponent_class_id;

main()
{
	struct GMgraph	graph;       /* graph containing the elements of the net     */
	struct GMgraph	sub_graph;   /* Graph containing the fix elements of the net */
	enum GRdpmode	mode;        /* Mode to highligth the net                    */
	int		response;    /* Response of the locate                       */
	int		status;      /* Status returned by om                        */
	struct GRid	object;      /* Located object                               */
	int         	finish;      /* Flag = TRUE if all the segment are selected  */
	struct GRmd_env loc_env;     /* Locate environment                           */
	int         	index;       /* Index for a loop                             */
	int        	exception_type; /* Type of exception to do                      */
	unsigned short 	type;        /* Type of element to broadcast                 */
	struct GRid 	tip_object;  /* Start object of the selected net             */
	int         	size_struct; /* Size of the structure in the list            */
	long        	msg;         /* Returned code of a message                   */
	struct sim_havcdb hvac_db;   /* HVAC simulated data base                     */
	struct GRevent 	event;       /* event to decide the auto sizing              */
	char        	filename     /* Full name of the files                       */
	             [MAX_RESP];
	struct VRgrinfo	grinfo;      /* Information for graph manager's functions    */
	IGRint		NbObj;	     /* Number of components modified */
	struct GRid	*pBuffIds;   /* Pointer on buffer of modified components */
	IGRchar		*cPtr, cBuf[256];

        OM_S_CLASSLIST locate_eligible_thing;

        GRclassid class_array[2];

	exception_type = NULL;
	UI_message(MSG0);

	/*A Select the origin of the net	*/

	status = gm$init_graph(p_graph = &graph);
	gm$status();
 
	for(finish=FALSE; !finish;)
    	{

          locate_eligible_thing.w_count  = 2;
          locate_eligible_thing.w_flags  = 1;
          class_array[0] = OPP_VRComponent_class_id;
          class_array[1] = OPP_VRNozzle_class_id;
          locate_eligible_thing.p_classes  = class_array;

    	  status = ci$locate
                (response    = &response,
 	        obj          = &tip_object.objid,
                osnum        = &tip_object.osnum,
                owner_action = LC_RIGID_COMP | LC_RIGID_OWNER |
                               LC_FLEX_COMP  | LC_NO_REF_OBJECTS,
		eligible_classes = &locate_eligible_thing,
                md_env       = &loc_env,
  	        prompt       = MSG1,
  	        acc_prompt   = MSG2);
	  UI_message(MSG0);
     
	  switch (response)
      	  {
	    case D_RESET:
	    return(status);
      	    break;

	    case DATA :
	    /*A Get the corresponding graph */
 
	    grinfo.p_add    = (char *)&graph;
	    grinfo.p_md_env = &loc_env;
     
	    GMget_graph( (struct GRid *)NULL,
			0,
			&tip_object,
			1,
			VRget_diconnect, 
			(IGRchar *)&grinfo, 
	            	NULL,
			NULL,
			TRUE,
			&graph);

	    /*A Highlight this graph */

      	    mode = GRhd;
	    type = GM_BODY|GM_EXTERN;
	    grinfo.p_add    = (char *)&mode;
	    grinfo.p_md_env = &loc_env;

      	    status = 
	    gm$broadcast_graph
             (select_fct   = GMsel_and,
              p_sel_info   = &type,
              broad_fct    = VRdisplay_elmt,
              p_broad_info = &grinfo,
              broad_mode   = GM_ORDER,
              p_graph      = &graph);
      	    gm$status(type = EXCEPTION_1);

      	    ci$getevent(response = &response,
                  event = &event,
                  prompt = MSG2);
      	    UI_message(MSG0);

      	    if(((response == STRING)&&((event.event.keyin[0]=='y')
      		||(event.event.keyin[0]=='Y')))||(response == DATA))
		        finish = TRUE;
	    else
            {
        	mode = GRheo;
	        status = 
		gm$broadcast_graph
                 (broad_fct    = VRdisplay_elmt,
                  p_broad_info = &grinfo,
                  broad_mode   = GM_ORDER,
                  p_graph      = &graph);
	        gm$status(type = EXCEPTION_1);
        	finish = FALSE;
      	    }/* end if */

	    default:
	    break;

	  }/* end switch*/

	}/* end for(finish)*/
 
	/*A Get the subgraph */

	status = 
	gm$init_graph(p_graph = &sub_graph);
	gm$status(type = EXCEPTION_1);

	grinfo.p_add = (char *)&graph;
	status = 
	GMget_graph(	(struct GRid *)NULL,
		0,
		&tip_object,
		1,
		VRget_fixobj, 
		(IGRchar *)&grinfo, 
            	NULL,
		NULL,
		TRUE,
		&sub_graph);
	gm$status(type = EXCEPTION_2);

	/*A Compute the flows	*/

	UI_status(MSG8);
	/*C KLUDGE FOR DOUBLE INSTANCES */

	/*A Set flow direction to OUT for the termination 
	components ( diffusors )			*/
	type = GM_EXTERN;
	status = gm$broadcast_graph
             (select_fct   = GMsel_and,
              p_sel_info   = &type,
              broad_fct    = VRinject_flow,
              p_broad_info = &loc_env,
              broad_mode   = GM_ORDER,
              p_graph      = &sub_graph);
	gm$status(type = EXCEPTION_2);


	grinfo.p_add = (char *)&sub_graph;
	type = GM_BODY;
	status = 
	gm$broadcast_graph
             (select_fct   = GMsel_and,
              p_sel_info   = &type,
              broad_fct    = VRcompute_flow,
              p_broad_info = &grinfo,
              broad_mode   = GM_ORDER,
              p_graph      = &sub_graph);
	gm$status(type = EXCEPTION_2);

	/*A Erase the highlight */

	mode = GRheo;
	grinfo.p_add    = (char *)&mode;
	status = 
	gm$broadcast_graph
             (broad_fct    = VRdisplay_elmt,
              p_broad_info = &grinfo,
              broad_mode   = GM_ORDER,
              p_graph      = &graph);
	gm$status(type = EXCEPTION_2);

	/*A Remove the graph */

	gm$free_graph(p_graph = &sub_graph);
	gm$free_graph(p_graph = &graph);

exception:

	/*A Exception handler	*/
	switch(exception_type)
    	{
	  case EXCEPTION_5:
	  status = GMl_disactivate(&hvac_db.circ_list);

	  case EXCEPTION_4:
	  status = GMl_disactivate(&hvac_db.oval_list);

	  case EXCEPTION_3:
	  status = GMl_disactivate(&hvac_db.rect_list);

	  case EXCEPTION_2:
	  gm$free_graph(p_graph = &sub_graph);

	  case EXCEPTION_1:
	  gm$free_graph(p_graph = &graph);

	}/* end switch*/

	UI_status("");

	return status;

}/* end main  */


wakeup()
{
  UI_message(MSG0);
}/* end wake_up */

