/* $Id: */

/* I/ROUTE
 *
 * File:	vrppl/EquipN.u
 *
 * Description:
 *
 *	This ppl has to be assign to each macro created with
 *	nozzles in it.
 *	To assign it :
 *		 edit the macro definition ( Modify Macro Definition )
 *		 add under "Placement Options" : "~~post_placement"
 *		 set the equivalent value to the name of this ppl.
 *
 *	Hence the "post_placement" function will be activated each time
 *	an occurrence of this macro will be placed.
 *
 *	Its goal is to get all the VRNozHold feet of the macro and
 *	to generate real nozzle from them.
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 *	?? ?? ??	??		Creation
 *	10/13/94	Manyam		Fix for TR#179423164
 *					Modified to get the symbology from 
 *					"VRNozHold" object( Macro's foot)
 *					instead of getting from the Macro 
 *					definition. Symbology problem.
 *	05/14/97	AdZuurhout	Fix for TR#179701015- hardcoded the
 *					option-code for nozzles.
 *	12/31/97	Onay		Created from a copy of VREquipNoz.u
 */
#include "ciminimum.h"
#include "cisymb.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "dp.h"
#include "msdef.h"

#include "VRdef.h"
#include "VRcompdef.h"
#include "VRdimdef.h"
#include "VRstructs.h"
#include "VRmacros.h"
#include "ACattrib.h"
#include "ACrg_collect.h"

#include "VRutildef.h"
#include "VRutilmacros.h"
#include "VRnozzmacros.h"

#include "asmacros.h"
#include "macro.h"

#include "AS_status.h"


extern int printf(), ACread(), free();
extern int VREvaluateNozz(), VRPlaceNozz();
extern int ASmake_source_from_env();

struct GRid 		MACRO_ID;
struct GRmd_env		MOD_ENV;

post_placement()
{
	IGRint				status,Size,i,j,k,l,Index, Product;
	/* to regenerate the collections of attributes */
	IGRint				NbCollections,NbAttributes[VR_NB_ATTR];
	struct ACrg_coll		Attributes[200];
	IGRlong				retmsg;
	struct GRid			TempList[VR_NB_ATTR+1],NozzId, RefId;
	extern	OM_S_CHANSELECT 	AC_mto_graf_chns;
	extern GRclassid		OPP_VRNozHold_class_id,
					OPP_VDequipment_class_id;
	GRclassid			ClassId;
	struct VRGenInfo		NozzInstance;
	IGRdouble			dAngle;
	struct GRsymbology		Symb;
	struct GRvg_construct		CnstList;

	struct GRid			GraphicsId;	/* Macro occurrence Id */
	struct GRid			FootId;		/* Macro's foot Id */
	struct GRid			DefId; 		/* macro definition Id */
	IGRint				NumFeet;
	struct myfeet			*FeetDesc;
	IGRshort			nMatType;
	IGRdouble			dMatrix[16];

	IGRchar				ClassName[100];

/* -- Initialize templates -- */

for ( i=0; i<VR_NB_ATTR+1; i=i+1 )
{
	TempList[i].osnum = MOD_ENV.md_id.osnum;
} /*end loop on templates */



/* ------------------- KLUDGE : If it is an equipment, get its macro foot */

/* This kludge should be replaced by getting all objects on the
   owner-component graph ( deep scann ) */

om$get_classid(	objid	= MACRO_ID.objid,
		osnum	= MACRO_ID.osnum,
		p_classid = &ClassId);

if ( ClassId == OPP_VDequipment_class_id )
{
	/*| for equipments, go deeper in the owner graph to find the graphics */

	status =
	om$get_channel_count( osnum 	= MACRO_ID.osnum,
                              objid 	= MACRO_ID.objid ,
                              p_chanselect = &AC_mto_graf_chns,
                              count 	= &Size );

	/* verify that there is only one foot */
	if (Size != 1) {printf ("Not Implemented\n"); exit;}

	/* Get the graphics macro id */
	ACread(MACRO_ID, &AC_mto_graf_chns, &GraphicsId, Size);
}
else
{
	GraphicsId.objid = MACRO_ID.objid;
	GraphicsId.osnum = MACRO_ID.osnum;
}

#ifdef	VRDEBUG
        om$get_classname( objid   = GraphicsId.objid,
                	  osnum   = GraphicsId.osnum,
                        classname = ClassName);
	printf ("Object<%d,%d> = <%s>\n", GraphicsId.objid,GraphicsId.osnum, ClassName );
#endif


/* -------------------end of kludge */

/* We have to go through the macro definition in the case the graphics
   is an ACheader (no feet connected to it */

/* -- Get definition of the graphic macro -- */

	status =
	ci$send ( msg = message ACcpx.find_macro ( &DefId ),
			targetid = GraphicsId.objid,
			targetos = GraphicsId.osnum );

#ifdef	VRDEBUG
	printf ("Def<%d,%d>\n", DefId.objid,DefId.osnum );
#endif

/* -- Get feet names from definition -- */

	status =
	ci$send ( msg = message ACcpx_defn. ACgive_feet_desc(&NumFeet, &FeetDesc),
			targetid = DefId.objid,
			targetos = DefId.osnum );

#ifdef	VRDEBUG
	for (i=0; i<NumFeet; i=i+1)
	{
	printf ("Foot[%d] :\t Name : <%s>\n\t\t Type : <%d>\n\t\t Pos :  <%d>\n\t\t Prop :  <%d>\n",
			i, FeetDesc[i].name, FeetDesc[i].chan, FeetDesc[i].pos, FeetDesc[i].prop );
	}
#endif

/* -- Loop on macro's feet -- */
for ( i=0; i<NumFeet; i=i+1 )
{
#ifdef	VRDEBUG
printf (" Foot[%d] = <%s>\n", i, FeetDesc[i].name );
#endif
	/* -- Get the foot id -- */

	status =
	ci$send ( msg = message NDmacro.ACreturn_foot(&retmsg, FeetDesc[i].name,
					&FootId,&nMatType, dMatrix),
		targetid = GraphicsId.objid,
		targetos = GraphicsId.osnum );

#ifdef	VRDEBUG
	printf("MATRIX\n");
	for(k=0; k<16; k=k+4 )
	{
		for( l=0; l<4; l=l+1 )
		{
			printf("dMatrix[%d] = %f ", k+l, dMatrix[k+l] );
		}
		printf("\n");
	}
	printf("MATRIX\n");

#endif

#ifdef	VRDEBUG
        om$get_classname( objid   = FootId.objid,
                	  osnum   = FootId.osnum,
                        classname = ClassName);
	printf ("Object<%d,%d> = <%s>\n", FootId.objid,FootId.osnum, ClassName );
#endif


	/* -- Get foot class -- */

	om$get_classid(	objid	= FootId.objid,
			osnum	= FootId.osnum,
			p_classid = &ClassId);

	/* -- For each foot which is a VRNozHold : -- */

	if ( ClassId == OPP_VRNozHold_class_id )
	{
#	ifdef	VRDEBUG
	printf (" It is a Nozzle\n");
#	endif

		NozzId.objid = NULL_OBJID;

		/* -- Generate attributes collections -- */

		/* Get attributes from VRNozHold */

		status = ci$send (
			msg = message VRNozHold.VRGetInstance
				( &retmsg, &Product,
					   &NozzInstance.szNumber,
					   &NozzInstance.szNotes,
					   &NozzInstance.Attr.Nozz.dSecAngle ),
			targetid = FootId.objid,
			targetos = FootId.osnum );
		if ( ! (status&1) || (retmsg != MSSUCC) )
		{
			printf ("This nozzle failed \n");
			continue;
		}

		/* get attributes */
		status = ci$send (
			msg = message VRNozHold.VRGiveAttributes
				( &retmsg, VR_NB_ATTR, 200, &NbCollections, NbAttributes,
				  Attributes ),
			targetid = FootId.objid,
			targetos = FootId.osnum );
		if ( ! (status&1) || (retmsg != MSSUCC) )
		{
			printf ("This nozzle failed \n");
			continue;
		}

#ifdef	VRDEBUG
printf (" %d collections\n",NbCollections );
for (j=0; j<NbCollections; j=j+1)
 printf (" %d attr in coll %d\n", NbAttributes[j], j );
#endif

		/* create collections */

		Index = 0;
		for (j=0; j<NbCollections; j=j+1)
		{
			TempList[j].objid = NULL_OBJID;

			status = 
			VR$ModifyCollection
			( p_msg 		= &retmsg,
			  Operation		= VR_MERGE_COLL,
			  p_ParamsListToModify	= &Attributes[Index],
			  NbParamsToModify	= NbAttributes[j],
			  p_OutputCollectionId	= &TempList[j] );

			Index = Index + NbAttributes[j];

			if ( ! (status&1) || (retmsg != MSSUCC) )
			{
				printf ("Collection failed \n");
				continue;
			}
#ifdef	VRDEBUG
	printf (" Template[%d] = <%d, %d>\n", j, TempList[j].objid, TempList[j].osnum );
#endif

		}/* end loop on collections */

		/* -- Place a nozzle -- */

		status = ci$send (
			msg = message ACncpx.ACget_NV_rep(&NozzInstance.cRep),
			targetid = MACRO_ID.objid,
			targetos = MACRO_ID.osnum );
		as$status ();

		if ( !NozzInstance.cRep ) NozzInstance.cRep = 4;

		/* KLUDGE ---> force HVAC nozzle's code until redefined */
		if ( Product == VR_HVAC )
		{
#ifdef	VRDEBUG
	printf (" KLUDGE ---> HVAC => force code \n");
#endif
			strcpy (NozzInstance.szAABBCC,"HVNOZ");
		}

		NozzInstance.nStatus = 0;
		NozzInstance.nJustif = VR_CENTER_JUST;
		/* Added for TR179701015 to force nozzle option-code to 1 */
		NozzInstance.nOption = 1;

		status = 
		VR$EvaluateNozz
       			( p_msg 	= &retmsg,
	 		  Product 	= Product,
	 		  p_Instance 	= &NozzInstance,
	 		  p_SysParamsId = &TempList[0],
	 		  p_UsrParamsId = &TempList[1],
	 		  p_MssParamsId = &TempList[2],
			  p_ComponentId = &NozzId,
	 		  p_NbMissingParams = NULL,
	 		  p_NbCpts = NULL,
	 		  p_MdEnv = &MOD_ENV );

		if ( ! (status&1) || (retmsg != MSSUCC) )
		{
			printf ("Nozzle evaluation failed \n");
			goto VRNoNozzle;
		}

		/*A get symbology */

		/*C Fix for TR#179423164 : Manyam	*/
 		status = 
		ci$send ( msg = message GRvg.GRgetsymb(
				&retmsg, &Symb ),
			targetid = FootId.objid,
			targetos = FootId.osnum );

#ifdef	VRDEBUG
printf ("Color = %d\n", Symb.display_attr.color);
printf ("Level = %d\n", Symb.level);
printf ("Style = %d\n", Symb.display_attr.style);
#endif

		as$status();
		if ( ! (status&1))
		{
			printf ("This nozzle failed \n");
			goto VRNoNozzle;
		}

		CnstList.level   = Symb.level;
		CnstList.display = &Symb.display_attr;

		/* get the right object to connect to */

		status =
		ci$send ( msg = message ASnode.ACgive_path( (IGRint *) &retmsg,
					&GraphicsId, ClassName  ),
			targetid = MACRO_ID.objid,
			targetos = MACRO_ID.osnum );

		strcat (ClassName, ":");
		strcat (ClassName, FeetDesc[i].name);
#ifdef	VRDEBUG
	printf (" Foot path = <%s>\n", ClassName );
#endif
		status =
		ci$send ( msg = message ASnode.ACconnect_pretend( (IGRint *) &retmsg,
					ClassName, &RefId  ),
			targetid = MACRO_ID.objid,
			targetos = MACRO_ID.osnum );
#ifdef	VRDEBUG
	printf ("RefId = <%d,%d>\n", RefId.objid,RefId.osnum );
#endif

/*
		status =
		as$make_source ( go_grid = FootId,
				  mod_env = &MOD_ENV,
				  as_os   = MOD_ENV.md_id.osnum,
				  as_grid = &RefId);
		as$status ( action = GOTO_VALUE, value = VRNoNozzle );
*/
		status = 
		VR$PlaceNozz 
       			( p_msg 	= &retmsg,
			  p_ComponentId = &NozzId,
	 		  p_Instance 	= &NozzInstance,
			/*  p_expressions = NULL,*/
			  p_RefId	= &RefId,
			  p_CnstList	= &CnstList,
	 		  p_MdEnv 	= &MOD_ENV );
		if ( ! (status&1) || (retmsg != MSSUCC) )
		{
			printf ("Nozzle placement failed \n");
			goto VRNoNozzle;
		}
		status =
		ci$send( msg = message NDnode.NDdisplay(0,GRbd,&MOD_ENV),
                       targetid = NozzId.objid,
                       targetos = NozzId.osnum);

		continue;
VRNoNozzle :

		if ( NozzId.objid != NULL_OBJID )
		{
			printf ("DELETENOZZLE\n");
		}
	}/* end generate nozzle */

}/* end loop on feet */

wrapup :

	return OM_S_SUCCESS;

}/* end post_placement */
