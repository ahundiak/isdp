/* $Id: VRfixtopo.u,v 1.4 2001/10/22 14:53:16 louis Exp $  */
 
/***************************************************************************
 * I/ROUTE
 *
 * File:        vrppl/VRfixtopo.u 
 *
 * Description: Analyzes all parent segments of components and CComps.
 *              Checks the plane locations of the segments
 *              Moves the planes to where the planes apparently go
 *
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: VRfixtopo.u,v $
 *      Revision 1.4  2001/10/22 14:53:16  louis
 *      TR5650
 *
 *      Revision 1.3  2001/10/18 19:51:38  louis
 *      TR5650 symbolization is by offset value
 *
 *      Revision 1.2  2001/10/01 18:47:31  louis
 *      TR5154-add COz_compoint, VRfixtopo, and COz_fixsegs to Validate Route
 *
 *      Revision 1.1  2001/09/19 15:23:53  louis
 *      changed the name from VRfixmess.u to VRfixtopo.u
 *
 *      Revision 1.4  2001/09/14 19:02:58  louis
 *      Added bad planes test on CCOMPs
 *
 *      Revision 1.3  2001/08/13 19:24:11  louis
 *      minor corrections
 *
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 08/02/01  L.Waddell TR4724-Shifting duct syndrome.
 * 09/14/01  law       TR4724-badplanes changed an interface
 * 09/19/01  law       TR4724-changed name to VRfixtopo.u
 * 09/28/01  law       TR5154-Added to Validate Route command
 * 10/17/01  law       TR5650-Float interface to symbolization
 ***************************************************************************/

#include "ciminimum.h"
#include "cimacros.h"   
#include "cieveryone.h"
#include "OMprimitives.h"
#include "griodef.h"
#include "igr.h"
#include "lc.h"
#include "ndmacros.h"
#include "nddef.h"
#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "nddef.h"
#include "VDmem_ppl.h"
#include "VRdimdef.h"
#include "AS_status.h"
#include "VRattr_def.h"
#include "bsparameters.h"
#include "v_dbgmacros.h"
#include "vdVALmacros.h"

extern GRclassid OPP_VRComponent_class_id;
extern GRclassid OPP_VRConcComp_class_id;
#define SEGMENTCLS      2

extern VRskxform();
extern VR_check_seg_comp();
extern MAidmx();
extern VCobjInActiveSpace();
extern VRGetClsType();
extern NDexec_batch();
extern VRgetdist();
extern VRget_segment_geom();
extern void BSpl_pl_pl();
extern VR_find_ccomp_cpt();

main()
{
  struct GRid 	*compts; 
  struct GRmd_env 	md_env;
  IGRint numpts;
  IGRint noclasses;
  GRclassid Classes[2];
  struct GRid   *loc_obj;
  IGRint        count,bad_intersect,NbParents,badpln;
  struct GRid   ObjParents[20];
  struct GRid   PlnParents[4];
  IGRint        SgParents;
  IGRmatrix     xform_matrix;
  IGRmatrix tmp_matrix;
  IGRint segend,nbpts;
  IGRdouble dnEndPoints[6];
  IGRdouble dOrigCoor[3],dist0,dist1;
  IGRint        i,j,k,nObjCls,cn_type;
  struct GRid new_objid,go_planes,tmpplanes[4];
  IGRdouble plnmtrx[16];
  IGRint CpNum, nonebad;
  IGRdouble plnloc[3],cptloc[3];
  struct IGRplane plninfo[4];
  IGRdouble locpoint[12],locnormal[12];
  IGRshort mattype;
  IGRlong       sts, msg;
  IGRint retcode,skipplane;
  IGRint nCpNum;
  IGRshort ccompcpt,shrtndx;
  IGRdouble gap,bgap;
  IGRlong ret;
  BSrc          bsretcode;
  IGRint        flag;
  IGRchar rptfld[180];
  IGRpoint      q, r;
  IGRvector     u, v;
  struct GRid locplanes[3*VR_MAX_CPTS];
  IGRint NbPlanes;
  IGRdouble con_cor[3*VR_MAX_CPTS];
  struct GRlc_cvl  *p_cvl;

  
  __DBGpr_com( " >> Entered the PPL " );

  ci$get_module_info( md_env = &md_env );

  MAidmx(&msg,xform_matrix);
  Classes[0] = OPP_VRComponent_class_id;
  noclasses = 1;
  cn_type = 2;
  for(k = 0; k < 4; k = k+1)
  {
                    plninfo[k].point = &locpoint[3*k];
                    plninfo[k].normal = &locnormal[3*k];
  }
  sts = VCobjInActiveSpace( &msg, &count, &loc_obj, Classes, noclasses );
  __DBGpr_int("Total count of VRComp class objects checked",count);
  if(count)
  {
    for(i=0; i<count; i=i + 1)
    {
       rptfld[0] = '\0';
       sts = VR_check_seg_comp(loc_obj[i],&md_env,rptfld,&bad_intersect,&bgap);

       if(bad_intersect)
       {
         __DBGpr_obj("Comp has Bad segs",loc_obj[i]);
         ci$send(msg = message NDnode.NDget_objects
                             ( ND_ROOT, ObjParents, 20, NULL,
                             0, OM_K_MAXINT, &NbParents ),
              targetid = loc_obj[i].objid,
              targetos = loc_obj[i].osnum );

         ci$send( msg = message VRGeneric.VRGetOrigCoor ( &msg,
                       dOrigCoor,&md_env),
                   targetid = loc_obj[i].objid,
                   targetos = loc_obj[i].osnum );

         for(j=0; j<NbParents; j = j + 1)
         {
            sts = VRGetClsType( &nObjCls, ObjParents[j] );
            /*** We only process segments ***/
            if(nObjCls == SEGMENTCLS)
            {
               /*** Get the end of the segment ***/
               ci$send(msg = message NDnode.NDget_objects
                             ( ND_ROOT, PlnParents, 4, NULL,
                             0, OM_K_MAXINT, &SgParents ),
                    targetid = ObjParents[j].objid,
                    targetos = ObjParents[j].osnum );

               nbpts = 2;
               ci$send( msg     = message VRCnrlSeg.VRget_terminators(
                           &msg, &nbpts, &md_env,
                           dnEndPoints, NULL),
                         targetid = ObjParents[j].objid,
                         targetos = ObjParents[j].osnum );

               sts = VRgetdist(&dnEndPoints[0],dOrigCoor,&dist0);
               sts = VRgetdist(&dnEndPoints[3],dOrigCoor,&dist1);
                   if(dist0 > dist1)
                   {
                      segend = 1;
                   }
                   else
                   {
                      segend = 0;
                   }

               for(k=0;k<SgParents;k = k + 1)
               {
                 VRskxform( &msg, xform_matrix, &PlnParents[k], &md_env );
                 nd$exec_batch();
               }
               ci$send(msg = message NDnode.NDcompute_node(
                             &msg, cn_type, 4, PlnParents, &md_env),
                    targetid = ObjParents[j].objid,
                    targetos = ObjParents[j].osnum );
               nd$exec_batch();
               /*** Origin may have moved with recomputes ***/
               ci$send( msg = message VRGeneric.VRGetOrigCoor ( &msg,
                       dOrigCoor,&md_env),
                      targetid = loc_obj[i].objid,
                      targetos = loc_obj[i].osnum );
               /*** Assume the segment is now on the plane ***/
               sts = VRgetdist(&dnEndPoints[segend*3],dOrigCoor,&dist0);
               if(dist0 > BSBASISVAL)
               {
                 /* Get the plane info for the planes */
                 for(k=0; k<4; k = k + 1)
                 {
                    ci$send( msg      = message NDnode.ASreturn_go
                                           ( &go_planes, &mattype, plnmtrx ),
                        targetid = PlnParents[k].objid,
                        targetos = PlnParents[k].osnum );

                    ci$send(msg = message GRvg.GRdetplane(&msg,&mattype,
                            plnmtrx, &plninfo[k]),
                        targetid = go_planes.objid,
                        targetos = go_planes.osnum );
                 }

                 /* Get the location of the planes intersection*/

                 tmpplanes[0] = PlnParents[0];
                 tmpplanes[1] = PlnParents[1];
                 tmpplanes[2] = PlnParents[2];
                 tmpplanes[3] = PlnParents[3];
                 skipplane=3;
                 if(segend) skipplane = 0;

                 for(k=0; k<4; k=k + 1)
                 {
                    ci$send( msg      = message NDnode.ASreturn_go
                                           ( &go_planes, &mattype, plnmtrx ),
                        targetid = tmpplanes[k].objid,
                        targetos = tmpplanes[k].osnum );
                    ci$send(msg = message GRvg.GRdetplane(&msg,&mattype,
                            plnmtrx, &plninfo[k]),
                        targetid = go_planes.objid,
                        targetos = go_planes.osnum );
                    VRget_segment_geom( &retcode, plninfo, &dnEndPoints[0],
                                       &dnEndPoints[3] );
                    /*** Origin may have moved with recomputes ***/
                    ci$send( msg = message VRGeneric.VRGetOrigCoor ( &msg,
                             dOrigCoor,&md_env),
                        targetid = loc_obj[i].objid,
                        targetos = loc_obj[i].osnum );

                    /*** end plane may not be on origin ***/
                    MAidmx(&msg,tmp_matrix);
                    if(k != skipplane)
                    {
                       tmp_matrix[3] = dOrigCoor[0] - dnEndPoints[segend*3];
                       tmp_matrix[7] = dOrigCoor[1] - dnEndPoints[segend*3+1];
                       tmp_matrix[11]= dOrigCoor[2] - dnEndPoints[segend*3+2];
                    }
                    VRskxform( &msg, tmp_matrix, &tmpplanes[k], &md_env );
                    ci$send(msg = message NDnode.NDcompute_node(
                             &msg, cn_type, 4, tmpplanes, &md_env),
                       targetid = ObjParents[j].objid,
                       targetos = ObjParents[j].osnum );
                    nd$exec_batch();
                }
               }
             }
          }
        }
     }
  }
  if( loc_obj ) free( loc_obj );
  Classes[0] = OPP_VRConcComp_class_id;
  noclasses = 1;
  sts = VCobjInActiveSpace( &msg, &count, &loc_obj, Classes, noclasses );
  __DBGpr_int("Total count of VRComp class objects checked",count);
  /*** Sometimes the planes are off, sometimes the segment is off ***/
  /*** The plan is to first move the planes by the plane offset   ***/
  /*** Then move the planes by the segment offset                 ***/
  if(count)
  {
    for(i=0; i<count; i=i + 1)
    {
       rptfld[0] = '\0';
       sts = VR_check_seg_comp(loc_obj[i],&md_env,rptfld,&bad_intersect,&bgap);
       if(bad_intersect)
       {
          /* Get the number of cpts on the ccomp */
          ci$send( msg      = message VRGeneric.VRGetNumberOfCpts
                                                 ( &ret, &nCpNum, &md_env ),
                    targetid = loc_obj[i].objid,
                    targetos = loc_obj[i].osnum );

          ci$send ( msg = message VRGeneric.VRGetPlanes ( &msg, (3*VR_MAX_CPTS),
                                        locplanes, &NbPlanes, &md_env),
                    targetid = loc_obj[i].objid,
                    targetos = loc_obj[i].osnum );

          /* For each cpt */
          for(CpNum=0; CpNum < nCpNum; CpNum = CpNum + 1)
          {
             /* Suspicion that moving the planes is useless */
             tmpplanes[0] = locplanes[3*CpNum    ];
             tmpplanes[1] = locplanes[3*CpNum + 1];
             tmpplanes[2] = locplanes[3*CpNum + 2];
             /* Get the plane location */
             for(k=0; k<3; k = k + 1)
             {
                ci$send( msg      = message NDnode.ASreturn_go
                                           ( &go_planes, &mattype, plnmtrx ),
                        targetid = tmpplanes[k].objid,
                        targetos = tmpplanes[k].osnum );
                ci$send(msg = message GRvg.GRdetplane(&msg,&mattype,
                            plnmtrx, &plninfo[k]),
                        targetid = go_planes.objid,
                        targetos = go_planes.osnum );
             }
             BSpl_pl_pl
             ( &(plninfo[0].point[0]), &(plninfo[0].normal[0]),
               &(plninfo[1].point[0]), &(plninfo[1].normal[0]),
               &(plninfo[2].point[0]), &(plninfo[2].normal[0]),
               &flag, plnloc, q, r, u, v, &bsretcode  );

             /* Get the location of the cpt */
             ci$send( msg      = message VRGeneric.VRGetCptGeom
                                 ( &msg, CpNum, cptloc, NULL,
                                   NULL, &md_env ),
                      targetid = loc_obj[i].objid,
                      targetos = loc_obj[i].osnum ) ;
             /* Move the plane to the cpt */
             
             /* The offsets have been 0.0 in every case reviewed!?? */
             for(k=0; k<3; k = k + 1)
             {
                MAidmx(&msg,tmp_matrix);
                tmp_matrix[3] = cptloc[0] - plnloc[0];
                tmp_matrix[7] = cptloc[1] - plnloc[1];
                tmp_matrix[11]= cptloc[2] - plnloc[2];
                VRskxform( &msg, tmp_matrix, &tmpplanes[k], &md_env );
                nd$exec_batch();
             }
          }
          /******** Now move the segment end to the cpt ************/
          ci$send(msg = message NDnode.NDget_objects
                             ( ND_ROOT, ObjParents, 20, NULL,
                             0, OM_K_MAXINT, &NbParents ),
              targetid = loc_obj[i].objid,
              targetos = loc_obj[i].osnum );

          for(j=0; j<NbParents; j = j + 1)
          {
             sts = VRGetClsType( &nObjCls, ObjParents[j] );
             /*** We only process segments ***/
             if(nObjCls == SEGMENTCLS)
             {
                sts = VR_find_ccomp_cpt(ObjParents[j],loc_obj[i],
                                   &ccompcpt,&gap,&badpln,&md_env);
                if(gap > BSBASISVAL)
                {
                   nbpts = 2;
                   ci$send( msg     = message VRCnrlSeg.VRget_terminators(
                           &msg, &nbpts, &md_env,
                           dnEndPoints, NULL),
                         targetid = ObjParents[j].objid,
                         targetos = ObjParents[j].osnum );

                   ci$send( msg      = message VRGeneric.VRGetIndex(
                           &msg,&ObjParents[j],&shrtndx),
                         targetid = loc_obj[i].objid,
                         targetos = loc_obj[i].osnum );

                   ci$send( msg      = message VRGeneric.VRGetCptGeom
                              ( &msg, ccompcpt, cptloc, NULL,
                                NULL, &md_env ),
                         targetid = loc_obj[i].objid,
                         targetos = loc_obj[i].osnum );

                   MAidmx(&msg,tmp_matrix);
                   tmp_matrix[3] = -cptloc[0] + dnEndPoints[3*shrtndx];
                   tmp_matrix[7] = -cptloc[1] + dnEndPoints[3*shrtndx+1];
                   tmp_matrix[11]= -cptloc[2] + dnEndPoints[3*shrtndx+2];
                   tmpplanes[0] = locplanes[3*ccompcpt    ];
                   tmpplanes[1] = locplanes[3*ccompcpt + 1];
                   tmpplanes[2] = locplanes[3*ccompcpt + 2];
                   for(k=0; k<3; k = k + 1)
                   {
                      VRskxform( &msg, tmp_matrix, &tmpplanes[k], &md_env );
                      nd$exec_batch();
                   }
               }
            }
         }
       }
    }
  }
  if( loc_obj ) free( loc_obj );
  vd$VAL_openLog();
  Classes[0] = OPP_VRConcComp_class_id;
  Classes[1] = OPP_VRComponent_class_id;
  noclasses = 2;
  sts = VCobjInActiveSpace( &msg, &count, &loc_obj, Classes, noclasses );
  nonebad = 1;
  if(count)
  {
    for(i=0; i<count; i=i + 1)
    {
       rptfld[0] = '\0';
       sts = VR_check_seg_comp(loc_obj[i],&md_env,rptfld,&bad_intersect,&bgap);
       if(bad_intersect)
       {
          nonebad = 0;
          vd$VAL_addObject( PostText = rptfld,GRid = loc_obj[i]);
       }
    }
  }
  if(nonebad)
  {
      vd$VAL_addInfo( Text = "No bad Comp-Segment intersections found");
      vd$VAL_addInfo( Text = "No bad CComp-Segment intersections found");
  }

  vd$VAL_closeLog();

  if( loc_obj ) free( loc_obj );

  __DBGpr_com( " Exiting the PPL " );
}
