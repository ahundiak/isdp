/* $Id: COz_rtePen.u,v 1.4 2002/02/07 20:26:51 ramarao Exp $  */
/***************************************************************************
 * I/ROUTE
 *
 * File:        route/vrppl/COz_rtePen.u
 *
 * Description: Validate penMacros with Route Components.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COz_rtePen.u,v $
 *      Revision 1.4  2002/02/07 20:26:51  ramarao
 *      Fixed TR# 5884.
 *
 *      Revision 1.3  2001/09/10 19:17:32  ramarao
 *      Fixed a small bug.
 *
 *      Revision 1.2  2001/09/02 16:54:10  ramarao
 *      Fix as part of ETL# 8822.
 *
 *      Revision 1.1  2001/08/22 16:06:01  ramarao
 *      Implemented CR# 5374.
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      08/22/01        Rama Rao        File Creation.
 ***************************************************************************/

#include "VDppl.h"
#include "VDmac.h"
#include "VDobj.h"
#include "emssfintdef.h"
#include "vdVALmacros.h"
#include "vdAPImacros.h"
#include "vd_ve.h"
#include "v_edgedef.h"
#include "v_edgemacros.h"
#include "vsgeommacros.h"

extern 	VDpms_findall_ancestryobjects(), VD_findall_objects_in_range(),
	BSbxint(), EMintersect_two_element(), VDsupInitCnst(), 
	SMCreatBndPl();

extern GRclassid	OPP_nci_macro_class_id, OPP_VRComponent_class_id;

main()
{
IGRlong                 sts, msg, rc;
IGRint                  i, j, k, loc_cnt, nb_class, state, comp_count,
			num_inter;
IGRshort		world;
IGRchar			macName[128], penName[128], msgStr[128];
IGRboolean		int_found, nothing_special;
GRclassid               classid[1];
GRobjid                 *loc_list;
GRspacenum		osnum;
GRrange			range, crv_range, comp_range;
struct GRobj_info 	compInfo;
struct VDve_elem_buf    bufGraphics;
struct GRid             obj_chk, pcgMacroID, *GRinter;
struct GRmd_env		loc_env;
struct GRobj_env	*comp_list, footOE, planeOE;
struct GRlc_info     	cvInfo, sfInfo ;
struct GRvg_construct   cst;

   nb_class  = 1;
   loc_cnt   = 0;
   comp_count= 0;
   loc_list  = NULL;
   comp_list = NULL;
   GRinter   = NULL;
   world     = TRUE;

   nothing_special        = TRUE;
   bufGraphics.count      = 0 ;
   bufGraphics.buf_siz    = 0 ;
   bufGraphics.obj_info_p = NULL ;

   sts = MSSUCC;

   ci$get_module_info( md_env = &loc_env );

   osnum = loc_env.md_id.osnum;

   planeOE.obj_id.osnum = osnum ;

   VDsupInitCnst( &cst ) ;

   classid[0] = OPP_nci_macro_class_id;

   vd$VAL_openLog();

   loc_cnt = 0;
   VDpms_findall_ancestryobjects( osnum, nb_class, classid, 
		     	  	  &loc_cnt, NULL );
   if( !loc_cnt )  
   {
	vd$VAL_addInfo( Text = "No Penetration Macros Found" );
	goto wrapup;
   }

   if( loc_list ) { free( loc_list ); loc_list = NULL; }
   loc_list  = ( GRobjid * ) malloc( sizeof(GRobjid)*loc_cnt );
   VDpms_findall_ancestryobjects( osnum, nb_class, classid,
                                  &loc_cnt, loc_list );
   for( i=0; i<loc_cnt; i=i+1 )
   {
      obj_chk.objid = loc_list[i];
      obj_chk.osnum = osnum;

      vdobj$Get( objID = &obj_chk, macName = macName );

      if( !strcmp( macName, "penMacro" ) )  break;
   }

   if( i == loc_cnt )
   {
      vd$VAL_addInfo( Text = "No Penetration Macros Found" );
      goto wrapup;
   }

   nb_class  = 1;
   classid[0] = OPP_VRComponent_class_id;

   range[0] = -1e+10; range[1] = -1e+10; range[2] = -1e+10;
   range[3] =  1e+10; range[4] =  1e+10; range[5] =  1e+10;

   VD_findall_objects_in_range( range, nb_class, classid,
                       TRUE, loc_env, &comp_count, &comp_list );
   if( comp_count == 0 )
   {
      vd$VAL_addInfo( Text = "No Distributive systems components Found" );
      goto wrapup;
   }

   for( i=0; i<loc_cnt; i=i+1 )
   {
       	obj_chk.objid = loc_list[i];
       	obj_chk.osnum = osnum;

	vdobj$Get( objID = &obj_chk, macName = macName );

	if( strcmp( macName, "penMacro" ) )  continue;

        ci$send( msg = message ACncpx.ACget_STATE( &state ),
                 targetid = obj_chk.objid,
                 targetos = obj_chk.osnum );
        if( state & ncpx_root ) continue;

        footOE.obj_id.objid = NULL_OBJID;
        vdobj$GetFoot ( objID    = &obj_chk,
                        footName = "crv",
                        footOE   = &footOE      );
	if( footOE.obj_id.objid == NULL_OBJID ) continue;

        ci$send( msg = message GRvg.GRgetrang( &msg, 
				&footOE.mod_env.md_env.matrix_type, 
				 footOE.mod_env.md_env.matrix,
                                 &world, crv_range ),
                 targetid = footOE.obj_id.objid,
                 targetos = footOE.obj_id.osnum );

	int_found = FALSE;
	vdobj$Get( objID = &obj_chk, objName = penName );

	for( j=0; j<comp_count; j=j+1 )
	{
           ci$send( msg = message GRvg.GRgetrang( &msg,
                                &comp_list[j].mod_env.md_env.matrix_type,
                                 comp_list[j].mod_env.md_env.matrix,
                                 &world, comp_range ),
                 targetid = comp_list[j].obj_id.objid,
                 targetos = comp_list[j].obj_id.osnum );

	   if( !(BSbxint( &rc, &crv_range[0], &crv_range[3], 
			  &comp_range[0], &comp_range[3] ) ) ) continue;

	   cvInfo.located_obj = footOE.obj_id;
	   cvInfo.module_info = footOE.mod_env;

	   if( bufGraphics.obj_info_p )
	   {
	       om$dealloc( ptr = bufGraphics.obj_info_p );
	       bufGraphics.obj_info_p = NULL;
      	       bufGraphics.count      = 0 ;
    	       bufGraphics.buf_siz    = 0 ;
	   }
	   sts = vd_$select_obj_comps( msg     = &msg,
                                       option  = VD_K_gm_WIREFRAME |
						 VD_K_gm_SURFACE | 
						 VD_K_gm_SOLIDS,
                                       count   = 1,
                                       objEnvs = &comp_list[j],
                                       elmList = &bufGraphics );

	   for( k=0; k<bufGraphics.count; k=k+1 )
	   {
	       sfInfo.located_obj = bufGraphics.obj_info_p[k].obj_id;
	       sfInfo.module_info = bufGraphics.obj_info_p[k].mod_env;
 
	       num_inter = 0;
	       if( GRinter ) { free( GRinter ); GRinter = NULL; }
	       sts = EMintersect_two_element( &sfInfo, &cvInfo,
			     EMSINT_TRIM_HANDLESTOP | NULL,
			     &cst, &num_inter, &GRinter, &msg );
	       if( (sts&1&msg) && num_inter > 0 ) break;
	   }
	   if( k == bufGraphics.count )  continue;

	   nothing_special = FALSE;

	   sprintf( msgStr, "%s interferes with", penName );
           vd$VAL_addObject( GRid     = obj_chk,
                             PostText = msgStr );

           ci$send( msg = message GRgraphics.GRgetobjinfo( &msg,
						&compInfo ),
                 targetid = comp_list[j].obj_id.objid,
                 targetos = comp_list[j].obj_id.osnum );

           vd$VAL_addObject( GRid     = comp_list[j].obj_id,
                             PreText  = "   ",
                             PostText = compInfo.type );

	   int_found = TRUE;
	   vdobj$Delete( objID  = GRinter, 
			 objCNT = num_inter,
		         objENV = &loc_env );
	}
	if( int_found == TRUE ) continue;

	planeOE.obj_id.objid = NULL_OBJID;
        cvInfo.located_obj        = footOE.obj_id;
        cvInfo.module_info        = *(cst.env_info);
        cvInfo.geom_parms.leaf_id = footOE.obj_id;
	
	SMCreatBndPl( &msg, &cvInfo, NULL, &cst, &planeOE.obj_id );
	planeOE.mod_env = *(cst.env_info);

	for( j=0; j<comp_count; j=j+1 )
        {
           ci$send( msg = message GRvg.GRgetrang( &msg,
                                &comp_list[j].mod_env.md_env.matrix_type,
                                 comp_list[j].mod_env.md_env.matrix,
                                 &world, comp_range ),
                 targetid = comp_list[j].obj_id.objid,
                 targetos = comp_list[j].obj_id.osnum );

           if( !(BSbxint( &rc, &crv_range[0], &crv_range[3],
                          &comp_range[0], &comp_range[3] ) ) ) continue;

           cvInfo.located_obj = planeOE.obj_id;
           cvInfo.module_info = planeOE.mod_env;

           if( bufGraphics.obj_info_p )
           {
               om$dealloc( ptr = bufGraphics.obj_info_p );
               bufGraphics.obj_info_p = NULL;
               bufGraphics.count      = 0 ;
               bufGraphics.buf_siz    = 0 ;
           }
           sts = vd_$select_obj_comps( msg     = &msg,
                                       option  = VD_K_gm_WIREFRAME |
                                                 VD_K_gm_SURFACE |
                                                 VD_K_gm_SOLIDS,
                                       count   = 1,
                                       objEnvs = &comp_list[j],
                                       elmList = &bufGraphics );

           for( k=0; k<bufGraphics.count; k=k+1 )
           {
               sfInfo.located_obj = bufGraphics.obj_info_p[k].obj_id;
               sfInfo.module_info = bufGraphics.obj_info_p[k].mod_env;

               num_inter = 0;
               if( GRinter ) { free( GRinter ); GRinter = NULL; }
               sts = EMintersect_two_element( &sfInfo, &cvInfo,
                        	EMSINT_TRIM_HANDLESTOP | NULL,
                        	&cst, &num_inter, &GRinter, &msg );
               if( !(sts&1&msg) || num_inter == 0 ) continue;

               vdobj$Delete( objID  = GRinter,
                             objCNT = num_inter,
                             objENV = &loc_env );

	       break;
	    }
	    if( k != bufGraphics.count ) break;
	}

	if( j == comp_count )
	{
	   sprintf( msgStr, "%s is empty.", penName );

           vd$VAL_addObject( GRid     = obj_chk,
                             PostText = msgStr );
	   nothing_special = FALSE;
	}

	vdobj$Delete( objOE = &planeOE );
   }

   if( nothing_special )
   {
       vd$VAL_addInfo( 
          Text = "No interferences or empty penetration macros found." );
   }

wrapup:
   vd$VAL_closeLog();
   if( bufGraphics.obj_info_p )
   {
        om$dealloc( ptr = bufGraphics.obj_info_p );
        bufGraphics.obj_info_p = NULL;
   }

   if( GRinter   ) { free( GRinter   ); GRinter   = NULL; }
   if( loc_list  ) { free( loc_list  ); loc_list  = NULL; }
   if( comp_list ) { free( comp_list ); comp_list = NULL; }
   return 1;
}
