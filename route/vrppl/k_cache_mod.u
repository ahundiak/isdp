/* --	VROUTE
	Initialization program.
   -- */
#include <stdio.h>
#include "ciminimum.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "cilocate.h"
#include "vrdef.h"
#include "vrmacros.h"
#include "AS_status.h"
#include "VRcompdef.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "nddef.h"
#include "VDmem.h"

extern 	int 		printf(), free();
extern	char		*calloc();
extern 	int 		ShowObj();
extern	int		GRdpb_get();
main()
{
	IGRlong			retmsg;
	IGRint			status,i,response;
	IGRint			NbObj;
	struct GRid		CompObj, *objects;
	struct GRmd_env		md_env;
	IGRlong	NumberOfBytes;   /* number of bytes : used by DBP macros */
	IGRlong	BytesReceived;   /* number of received bytes             */

	ci$locate(	obj             = &CompObj.objid,
			osnum           = &CompObj.osnum,
                	response	= &response,
			owner_action 	= LC_RIGID_COMP |
					  LC_RIGID_OWNER |
					  LC_FLEX_COMP,
			md_env		= &md_env,
			classes		= "VRGeneric",
			prompt          = "Identify component/Move-on for All");

	switch (response)
	{
	case RESET :
	break;
	        
	case DATA :
	VRUpdCacheModel ( 1, &CompObj, &md_env );
	exit;

	default:
	exit;
	}/* end switch*/

	/* -- Process all components in file -- */

	/* -- Get Module env -- */
	NumberOfBytes = sizeof( struct GRmd_env );
	status = gr$get_model_env(
				msg    = &retmsg,
			       	sizbuf = &NumberOfBytes,
			       	buffer = &md_env,
			       	nret   = &BytesReceived );
	as$status( action = RET_STATUS );
	as$status( sts = retmsg, action = RET_STATUS );

	objects = NULL;
	printf ("--------------------- Piping ----------------------\n");
	status = 
	vr$select_component( 	pMsg 		= &retmsg,
				Product 	= VR_PIPING,
				pAddrList 	= &objects,
				pNumber		= &NbObj );

	if( ! status )
	{
		printf(" Error in fct VRSelectComponent\n");
		goto HVAC_MGT;
	}

	if( objects == NULL )
	{
          printf(" NO COMPONENTS\n");
        }

	VRUpdCacheModel ( NbObj, objects, &md_env );

HVAC_MGT :
	printf ("--------------------- Hvac ----------------------\n");
	status = 
	vr$select_component( 	pMsg 		= &retmsg,
				Product 	= VR_HVAC,
				pAddrList 	= &objects,
				pNumber		= &NbObj );

	if( ! status )
	{
		printf(" Error in fct VRSelectComponent\n");
		goto RWAY_MGT;
	}

	if( objects == NULL )
	{
          printf(" NO COMPONENTS\n");
        }

	VRUpdCacheModel ( NbObj, objects, &md_env );


RWAY_MGT :
	printf ("--------------------- Rway ----------------------\n");
	status = 
	vr$select_component( 	pMsg 		= &retmsg,
				Product 	= VR_RWAY,
				pAddrList 	= &objects,
				pNumber		= &NbObj );

	if( ! status )
	{
		printf(" Error in fct VRSelectComponent\n");
		return  OM_E_ABORT;
	}

	if( objects == NULL )
	{
          printf(" NO COMPONENTS\n");
        }

	VRUpdCacheModel ( NbObj, objects, &md_env );



}
extern	GRclassid	OPP_ACheader_class_id,
			OPP_VRHanger_class_id;

VRUpdCacheModel ( NbObj, objects, md_env )
IGRint 		NbObj;
struct GRid 	*objects;
struct GRmd_env	*md_env;
{
	IGRint		i,status, j, NbCaches;
	IGRlong		retmsg;
	struct GRid 	Header, ModelMgr, *CacheIds, PbId;
	IGRshort	nType;
	IGRdouble	dMat[16];
	GRclassid	ClassId;
	IGRboolean	bFound, bExclude;
	IGRshort	nSysType;

	printf (" ====== TOTAL : %d objects ====== \n",NbObj);

	NbCaches = 0;
	CacheIds = NULL;

	/*A allocate the memory for cacheids	*/
	CacheIds = ( struct GRid *)
		_CALLOC( NbObj, struct GRid );
	if ( CacheIds == NULL )
	{
		printf( "k_cache_mod : could not allocate dynamic memory \n");
		goto	wrapup;
	}

	/*A get all the cacheids	*/
	for (i=0; i<NbObj; i=i+1 )
	{	
		bFound = FALSE;
		bExclude = FALSE;
		PbId.objid = NULL_OBJID;

		/*A exclude the dangles and supports from the list 
		supports not yet supported */
		status =
		om$get_classid(	osnum		= objects[i].osnum,
				objid		= objects[i].objid,
				p_classid	= &ClassId );
		if( ! (status&1))	continue;


		if( om$is_ancestry_valid(
			subclassid	= ClassId,
			superclassid	= OPP_VRHanger_class_id ) 
		    == OM_S_SUCCESS )	bExclude = TRUE;
		else {
			/*A get the cmp's item number */
			status = 
		  	ci$send( msg      = message VRGeneric.VRGetSysType(
				&retmsg, &nSysType ),
	   		targetid	= objects[i].objid,
	   		targetos	= objects[i].osnum );
			as$status();
			
			if ( nSysType == VR_DANGLING )
				bExclude = TRUE;
		}

		/*A get the model object */
		status =
		ci$send(msg	 = message VRGeneric.VRGetModel
				(&retmsg, &PbId, md_env ),
			targetid = objects[i].objid,
			targetos = objects[i].osnum );

		/*" PbId.objid  = %ld , PbId.osnum = %d \n",
			PbId.objid, PbId.osnum	*/

		/*A see whether the pb is already in the list */
		for ( j=0; j<NbCaches; j=j+1 )
			if ( CacheIds[j].objid == PbId.objid &&
				CacheIds[j].osnum == PbId.osnum )
				{
					bFound = TRUE;
					break;
				}

		if ( !bFound && PbId.objid != NULL_OBJID && !bExclude )
		{
			CacheIds[NbCaches] = PbId;
			NbCaches = NbCaches+1;
		}

	}/* end get all the Cache Ids */

	/*A delete all the Pb's	*/
	for ( i=0; i< NbCaches; i = i+1 )
	{	
		status =
		ci$send( msg = message ACrg_collect.GRchgname
				( &retmsg, md_env, "" ),
			targetid = CacheIds[i].objid,
			targetos = CacheIds[i].osnum );
		as$status( );

		/*A set the state of pb to "delete if there are no children */
		status =
		ci$send( msg = message NDnode.NDchg_state(
				( (IGRchar) ND_DEL_NO_CH ),
				( (IGRchar) ND_DEL_NO_CH ) ),
			targetid = CacheIds[i].objid,
			targetos = CacheIds[i].osnum );
		as$status( ) ;
	}

	/*A create the cache and edit the macro */
	for (i=0; i<NbObj; i=i+1 )
	{	
		/* -- Recompute Component -- */
		/* -- to make shure that the macro is edited -- */
		status =
		ci$send(msg	 = message VRGeneric.VRGetMacro
				(&retmsg, (char *)NULL, (char *)NULL,
				(IGRshort *) NULL, 
				&PbId,
				(IGRint *) NULL, (IGRchar ***) NULL,
				(char *) NULL, md_env),
			targetid = objects[i].objid,
			targetos = objects[i].osnum );
		as$status();
	}

	for (i=0; i<NbObj; i=i+1 )
	{

		/* -- Get graphics (only ACheaders) -- */
		status =
		ci$send( msg = message ACncpx.ACreturn_foot
				( &retmsg, "graphics", &Header, nType, dMat ),
				targetid = objects[i].objid,
				targetos = objects[i].osnum);
		as$status();

		status =
		om$get_classid(	osnum		= Header.osnum,
				objid		= Header.objid,
				p_classid	= &ClassId );
		if( ! (status&1))	continue;

		if( om$is_ancestry_valid(
			subclassid	= ClassId,
			superclassid	= OPP_ACheader_class_id ) 
		    != OM_S_SUCCESS )	continue;

		/* -- Get ACmodel Mgr from ACheader -- */

/*		ShowObj ( &Header ); */

		status =
		ci$send( msg = message ACheader.ACget_model_mgr
				( &retmsg, &ModelMgr),
				targetid = Header.objid,
				targetos = Header.osnum);
		as$status();
		if (! (status & 1) ) continue;

/*		ShowObj ( &ModelMgr ); */

		/* -- Delete Model Mgr -- */

		status =
		ci$send(msg	 = message ACmodel_mgr.delete(0),
			targetid = ModelMgr.objid,
			targetos = ModelMgr.osnum );
		as$status();
	}

	for (i=0; i<NbObj; i=i+1 )
	{

		/* -- Recompute Component -- */
		status =
		ci$send(msg	 = message VRGeneric.VRGetStatus
				(&retmsg, &nType),
			targetid = objects[i].objid,
			targetos = objects[i].osnum );
		as$status();

		if ( nType & VR_CORRECTION ) continue;

		status =
		ci$send(msg	 = message NDnode.NDs_compute_node
				(&retmsg, 0, md_env),
			targetid = objects[i].objid,
			targetos = objects[i].osnum );
		as$status();

	}

wrapup :
	if ( CacheIds ) _FREE( CacheIds );
	return 1;
}
