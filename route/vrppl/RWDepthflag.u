/* $Id: RWDepthflag.u,v 1.2 2001/02/20 01:16:20 build Exp $  */

/*************************************************************************
 * I/ROUTE
 *
 * File:        vrppl/RWDepthflag.u
 *
 * Description:
 *      The function implemented in this file will return the depth flag for 
 *      the component .
 *      Here the flag indicates whether the depth for a particular component
 *	shape is to querried from the database or not .
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: RWDepthflag.u,v $
 *      Revision 1.2  2001/02/20 01:16:20  build
 *      Replaced v_dbgmacros.h with product specific dbgmacros.h
 *
 *      Revision 1.1.1.1  2001/01/04 21:13:03  cvs
 *      Initial import to CVS
 *
# Revision 1.1  1999/04/23  11:17:36  pinnacle
# Created: vrppl/RWDepthflag.u by sbilla for route
#
 *
 *
 * History:
 *       Date             Name     Description
 *       04/23/99         Reddy    Creation
 *
 *************************************************************************/

/**
The following code assumes that at connect point '0' and connect point 1 the
components are in the order in which the following shape_codes are defined;
e.g , when oval -> Rect transition componet is placed, the case statement
VR_RECT_OVAL will be reached and it assumes Rectangular shape at connect
point 0 and oval at connect point 1. It doesn't take the direction of sketch
into account. For both Rect->Oval shape and Oval->Rect shape same component
will be queried.

The solution for this can be to find out the shape_codes at each connect
point and set the depth flags accordingly . Shape codes at each connect
point  are to be obtained from macroname by using nc macro.
**/


/***
#include "macro.h"
#include "acmacros.h"
 ***/

#include "VDppl.h"
#include "VDobj.h"
#include "VDsa.h"
#include "vrmacros.h"
#include "VRDbParamDef.h"
#include "vrdbgmacros.h"
#include "VRdef.h"

IGRint  shape_code ;
IGRint  depthflag1;
IGRint  depthflag2;

/**
IGRchar macro_name[30];
extern int              ACfind_macro_defn();
**/

int getRWDepthFlag( )
{


  __DBGpr_com( " \tEntered the PPL >>" );

#ifdef INCLUDE_MACROISSUE
    struct GRid macro_defn;
    struct myfeet *myfeet=NULL;


    /* hardcoding the Rectangular -> Oval transition macro name for testing*/
    strcpy( macro_name, "suwrotrs" ); 
    status = ac$find_macro_defn( action         = ACfind_load,
                               macro_name       = macro_name,
                               p_macro_defn_id  = &macro_defn );

    status =
    ci$send(msg = message ACcpx_defn.ACgive_feet_desc( &feet_num, &myfeet),
                targetid = mac_defn.objid,
		targetos = mac_defn.osnum );

    for(i=0;i<feet_num;i=i+1)
    {
	    if( cpt_num )
	    {
		if( !strncmp( myfeet[i].name, "VRcpt_0", 7 ) ) 
		{
		}
	    }
	    else
	    {
		if( !strncmp( myfeet[i].name, "VRcpt_0", 7 ) ) 
		{
		}
	    }
    }
#endif

  switch( shape_code )
      {

	case VR_RECT      :
		depthflag1 = 0 ;     /* Rectangular */
		depthflag2 = 0 ;     
		break ;

	case VR_OVAL      :
		depthflag1 = 1 ;     /* Oval */
		depthflag2 = 1 ;     
		break;
       
	case VR_CIRC      :
		depthflag1 = 0 ;     /* Circular */
		depthflag2 = 0 ;     
		break;

	case VR_CORNER    :
		depthflag1 = 1 ;     /* Radius Corner */
		depthflag2 = 1 ;     
		break;

	case VR_ELLIPSE   :
		depthflag1 = 1 ;     /* Elliptical  */
		depthflag2 = 1 ;     
		break;

        case VR_RECT_OVAL :          /* rect --> oval        16  */
                depthflag1 = 0 ;
                depthflag2 = 1 ;
                break;

        case VR_RECT_CIRC :
                depthflag1 = 0 ;     /* rect --> circular    32  */
                depthflag2 = 0 ;     
                break;

        case VR_RECT_CORN :
                depthflag1 = 0 ;     /* rect --> corner      48  */
                depthflag2 = 1 ;     
                break;

        case VR_RECT_ELLP :
                depthflag1 = 0 ;     /* rect --> ellipse     64  */
                depthflag2 = 1 ;     
                break;

        case VR_OVAL_CIRC :
                depthflag1 = 1 ;     /* oval --> circular    33  */
                depthflag2 = 0 ;     
                break;

        case VR_OVAL_CORN :
                depthflag1 = 1 ;     /* oval --> corner      49  */
                depthflag2 = 1 ;     
                break;

        case VR_OVAL_ELLP :
                depthflag1 = 1 ;     /* oval --> ellipse     65  */
                depthflag2 = 1 ;     
                break;

        case VR_CIRC_CORN :
                depthflag1 = 0 ;     /* corn --> circular    50  */
                depthflag2 = 1 ;     
                break;

        case VR_ELLP_CORN :
                depthflag1 = 1 ;      /* ellipse -->corn     52  */
                depthflag2 = 1 ;     
                break;

        case VR_CIRC_ELLP :
                depthflag1 = 0 ;     /* circ --> ellipse     36  */
                depthflag2 = 1 ;     
                break;
	default :
		__DBGpr_com( " This shape doesn't exist ");
		break ;
      }

      __DBGpr_int( " Shape_code is" , shape_code); 
      __DBGpr_int( " Depth flag 1 is " , depthflag1);
      __DBGpr_int( " Depth flag 2 is " , depthflag2);
      __DBGpr_com( " End of PPL ");

	return 1 ;
}

