/* MOMO Modif : 24-10-91 ==> version 1.4.3.6
/*
/* get the locate criteria from the last command
/*
/**/
/* $Id: COtrace.u,v 1.3 2002/04/18 19:07:44 louis Exp $     */

/* I/<product>
 *
 * File	:	vrppl/COtrace.u
 *
 * Description:	This file is for "Select Components along Network" command.
 *
 * History :
 *
 *	Name		|  Date		|  Description.
 *	
 *	Mallik		| 8-11-94	|  CR # 179420251
 *			|		|  Introduce a filter to select only
 *			|		|  Route Objects.
 *	
 *	Waddell		| 2-13-97	|  TR # 179603292
 *			|		|  Installed selection and locate
 *			|		|  filters and ordered components using
 *			|		|  VRtrace_network function.
 *	Anand		| 4-18-02	|  TR6291-rearranged to get rid of link
 *                      |               |  errors
 */

#include "cieveryone.h"
#include "lc.h"
#include "cimacros.h"
#include "asmacros.h"
#include "codef.h"
#include "msmacros.h"
#include "msdef.h"
#include "GMdef.h"
#include "GM.h"
#include "GMndg.h"
#include "exmacros.h"
#include "grgsdef.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "comiscmac.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "OMerrordef.h"
#include "GMerrordef.h"
#include "ACrg_collect.h"
#include "VRsize.h"
/* Added for _CALLOC TR 179603292 */
#include "VDmem_ppl.h"

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Command object COtrace.u                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

  /* TR# 179603292 - law (02/04/97) */
  /* Note that check_buff collection is optimized for time */
  /* The collection for the 2nd tip is slower than for 1   */
  /* Only 1 collection is made for the entire network      */
  /* check_buff MAY be different from ran_set              */
/*
  Description : Ask to the user differents objects limiting of a non directed
                graph and do a graphic set with the made graph.
  Constraint  : none
*/ 
 
#define VR_MAX_TIP    200     /* Maximum number of tips in the graph          */
#define MSG0                  "Select Components Along Network"
#define MSG1                  "Select a tip of the Net/Reset"
#define MSG2                  "Accept/Reject"
#define MSG3                  "Select the parts to avoid /Reject"

extern  UI_message();         /* Function to display the message field        */
extern  UI_prompt();          /* Function to display the prompt field         */
extern  UI_status();          /* Function to display the status field         */
extern  VRget_allow_connect();/* Function to get the connections of an object */
extern  GMndg_activate();     /* Function to activate a non directed graph    */
extern  GMndg_getgraph();     /* Function to get a non directed graph         */
extern  GMndg_clear();        /* Function to clear a non directed graph       */
extern  GMh_getlist();        /* Function to get the indexes of the graph     */
extern  GMh_key();            /* Function to get object from indexes          */
extern  GMndg_disactivate();  /* Function to disactivate a non directed graph */
/* extern  DItranslate();   Not used TR#179603292 */
extern  DImain();             /* Function to translate the name of a directory*/
extern  GRdpb_get();          /* Function to get the active environment       */
extern  GRgs_fun();           /* Function to clear the graphic sets           */
extern  CObuild_button();     /* Function to build an software input          */
extern  GMgridcmp();          /* Function to compare the grids                */
extern  GMh_grid();           /* Function to hash a grid                      */
extern  VRdisplay_elmt();     /* Function to highlight an element of the net  */
extern  GMh_activate();       /* Function to activate a hcode                 */
extern  GMh_add();            /* Function to add an element in a hcode        */
extern  GMh_disactivate();    /* Function to disactivate a hcode              */
extern  EX_get_super();       /* Function to get the graphic set manager      */
extern  EXputq2();
extern  VRtrace_network();    /* Function to trace networks TR#179603292      */
extern	GRgsmgr_fun();
extern ASget_as_owner();

extern	OMuword	OPP_VRGeneric_class_id; /* Added for TR#179603292 */
extern GRclassid OPP_VRCptIn_class_id;  /* Added for TR#179603615 */

/* Modified COMP_ITEM for TR#179603615 */
typedef struct
{
  unsigned int  ItemNum;
  int branchno; /* TypeNum */
  int Type; /* Type */
  int num_neigh; /* TypeMax */
  GRclassid comp_class;
  int comp_hit_flg; /* Selected component of network */
  struct COMP_ITEM *pNext; /* next component in net */ /* pNext */
  struct COMP_ITEM *pPrev; /* previous component in net */
  struct GRid CompId; /* CompId */
} COMP_ITEM;


  /* TR# 179603292 - law (02/04/97) */
  /* Check if object is one of objects selected to avoid             */
  /* The avoid software does not delete the object selected to avoid */
  /* This is an external filter to remove those selected objects     */
  /* TR# 179603615 - law (03/03/97) */
  /* Added VRCptIn class objects to delete */
int keep_object(no_avoids,orig_avoid,p_object)
int no_avoids;
COMP_ITEM *orig_avoid;
struct GRid *p_object;
{
  COMP_ITEM *this_avoid;
  int not_finished;
  /* Added for TR#179603615 */
  GRclassid ClassId;
  int loc_status;

  if(no_avoids)
  {
    this_avoid = orig_avoid;
    not_finished = 1;
    while(not_finished)
    {
      /*Modified for TR#179603615 */
      if((this_avoid->CompId.objid == p_object->objid) &&
         (this_avoid->CompId.osnum == p_object->osnum))
      {
        return 0;
      }
      this_avoid = this_avoid->pNext;
      if(this_avoid == NULL) not_finished = 0;
    }
  }

  /* Added for TR#179603615 */
  loc_status = om$get_classid ( objid = p_object->objid,
                                osnum = p_object->osnum,
                                p_classid = &ClassId);
  if ( ! loc_status & 1 ) return 0;

   if ( ClassId == OPP_VRCptIn_class_id )
   {
       return 0;
   }
  return 1;
}

main()
  {
  int         response;       /* Response of the locate                       */
  int         status;         /* Status returned by om                        */
  int         msg;            /* Return code of the messages                  */
  int         nb_tip;         /* Number of tips of the graph                  */
  struct GRid tip_list        /* tips of the graph to select                  */
              [VR_MAX_TIP];
  struct GMndgraph graph;     /* Graph containing the objects                 */
  int         index1;         /* Index for a loop                             */
  int         nb_elmt;        /* Number of elements in the graph              */
  unsigned short *p_key;      /* Array of the graph's keys                    */
  struct GRid object;         /* Located object                               */
  struct GRid *p_object;      /* Pointer to graph's object                    */
  int         dp_type;        /* Type of display                              */
  int         command;        /* Flag = TRUE if the command is possible       */
  int         finish;         /* Flag = TRUE if all the segment are selected  */
  int         ss_response;    /* Response to put on the queue                 */
  int         env_prop;       /* Environment properties for the saved set     */
  int         set_prop;       /* Properties of the saved set                  */
  struct GRid grset_obj;      /* Graphic set object                           */
  struct GRid svset_obj;      /* Save set object                              */
  struct GRid gsmgr_obj;      /* Graphic set manager's object                 */
  struct GRevent event;       /* Event to build with the graphic set          */
  int         size;           /* Size of the buffer to put on the soft. queue */
  int         nb_byte;        /* Number of bytes returned for the module env. */
  struct GRmd_env active_env; /* Active environment to translate a dir name   */
  struct GRmd_env loc_env;    /* Locate environment                           */
  OM_S_CHANSELECT chan_sel;   /* Channel selector of the grset manager        */
  int         nb_grset;       /* Number of graphic set already connected      */
  enum GRdpmode mode;         /* Mode to highligth the net                    */
  struct GMhcode h_cut;       /* Hcode table containing the cuts objects      */
  int         exception_type; /* Type of exception to do                      */
  OM_S_CHANSELECT from_svset; /* Channel selector from the save set           */
  OM_S_CHANSELECT to_grset;   /* Channel selector to the graphic set          */
  struct VRgrinfo info_list;  /* Information for fct: VRget_allow_connect     */
/* Added for TR179603292 */
  struct GRid *proc_list;     /* list to be added to que                      */
  struct GRid *ran_set;       /* random ordered list                          */
  struct GRid *sort_list;     /* ran_set list sorted by connection            */
  int ndx;
  int not_finished;
  int no_avoids;
  int no_deletes;
  COMP_ITEM *this_avoid;
  COMP_ITEM *prev_avoid;
  COMP_ITEM *next_avoid;
  COMP_ITEM *orig_avoid;
  struct GRid *check_buff; /* master list of components */
  int notcollected; /* flag for collection of check_buff */
  int comp_nt_fnd;  /* flag for tip non-match in network */
  struct GRmd_env 	locate_env;
  int 			i,criteria_flag;
  struct GRlc_locate   	attributes;
  OM_S_CLASSLIST	locate_rtree_thing;	/* actual CLASSLIST thing */
  OM_S_CLASSLIST	locate_eligible_thing;  /* actual CLASSLIST thing */
  int cmd_empty;
  int loc_status;        /* local status */
  int *tmpaddr;
  struct GRid *loc_object; /* single GRid element buffer */
  int chk_cmp;           /* Numberof components in check_buff;
  /* End add for TR# 179603292 - law (02/04/97) */

  /* TR# 179603615 - law (03/06/97) */
  struct GRid CorId;
  int redefine;
/* MOMO 24-10-91 

  GRclassid		obj_classid;

 MOMO 24-10-91 */


  UI_message(MSG0);

  nb_tip = 0;
  /* TR# 179603292 - law (02/04/97) */
  check_buff = NULL;
  ran_set = NULL;
  sort_list = NULL;
  proc_list = NULL;
  loc_object = NULL;
  orig_avoid = NULL;
  chk_cmp = 0;
  
  /* ---------------------------- */
  /* Select the tips of the graph */
  /* ---------------------------- */

  size = sizeof(active_env);
  status = gr$get_module_env
             (msg    = &msg,
              sizbuf = &size,
              buffer = &active_env,
              nret   = &nb_byte);
  gm$status();

  /* Added for TR# 179603292 - law (02/04/97) but could not get to work
   * Check if a command is active ...
   cmd_empty = ex$is_cmd_stack_empty();
   extern	EX_is_cmd_stack_empty();      NOT WORKING IN PPL
   if (cmd_empty)
   {
     UI_status(" Trace not callable from command");
     status = OM_S_SUCCESS ;
     goto wrapup;
   }
   */

  /* Added for TR# 179603292 - law (02/04/97) */
   status = gr$gsget_locate_criteria ( msg = &msg,
            locate_env = &locate_env,
            criteria_flag = &criteria_flag,
            attributes = &attributes,
            rtree_classes = &locate_rtree_thing,
            eligible_classes = &locate_eligible_thing);
  /* TR# 179603292 - law (02/04/97) */
  /* Check for previous locate filters */
  redefine = FALSE;
  if((locate_eligible_thing.w_count < 5) &&
     (locate_eligible_thing.w_count > 0))
  {
     for( i = 0; i < locate_eligible_thing.w_count; i = i+1)
     {
       status = om$is_ancestry_valid
                         (subclassid = locate_eligible_thing.p_classes[i],
                          superclassname="VRGeneric");
       if(status != OM_S_SUCCESS)
       {
         /* TR179603615 */
         /* There was protest about an error statement so removed prompt
         UI_status(" Unknown Trace Intent-Locate Adjusted ");
         */
         redefine = TRUE;
/*       Giving memory errors, went with class definition TR179603615
             locate_eligible_thing.p_classes[i] = OPP_VRGeneric_class_id ;
*/
       }
     }
  }
  else
  {
    redefine = TRUE;
/*  Giving memory errors, went with class definition TR179603615
    ********Prompt was not wanted, so removed caution prompt***********
    UI_status(" Unknown Trace Intent-Locate Redefined ");
    locate_eligible_thing.p_classes[0] = OPP_VRGeneric_class_id ;
    locate_eligible_thing.w_count = 1;
*/
  }

  notcollected = TRUE;  /* TR# 179603292 - law (02/04/97) */

  do
    {
    if(redefine)
    {
    loc_status = ci$locate
                (response    = &response,
 	        obj          = &object.objid,
                osnum        = &object.osnum,
                owner_action = LC_RIGID_COMP | LC_RIGID_OWNER |
                               LC_FLEX_COMP  | LC_REF_OBJECTS,
  /* bypassed memory problems TR# 179603615 - law (04/14/97) */
/*		eligible_classes = &locate_eligible_thing, */
		classes	     = "VRGeneric",
                md_env       = &loc_env,
  	        prompt       = MSG1,
  	        acc_prompt   = MSG2);
    }
    else /* Uses locate filter from previous command */
    {
    loc_status = ci$locate
                (response    = &response,
 	        obj          = &object.objid,
                osnum        = &object.osnum,
                owner_action = LC_RIGID_COMP | LC_RIGID_OWNER |
                               LC_FLEX_COMP  | LC_REF_OBJECTS,
  /* TR# 179603292 - law (02/04/97) */
		eligible_classes = &locate_eligible_thing,

  /* TR# 179603292 - law (02/04/97) */
/**
		classes	     = "VRGeneric",
 **/
                md_env       = &loc_env,
  	        prompt       = MSG1,
  	        acc_prompt   = MSG2);
    }

    UI_message(MSG0);
    switch (response)
      {
      case D_RESET:
      finish  = TRUE;
      goto wrapup;  /* TR# 179603292 - law (02/04/97) */
      break;

      case RESET :
      finish  = TRUE;
      break;
	        
      case DATA :
      /* TR# 179603292 - law (02/04/97) */
      /* locate may return an error */
      finish  = FALSE;
      if(!( loc_status & 1 ))
      {
        UI_status(" Object Not Found");
        break;
      }
      /* If object has an owner, use the owner ID */

/*      status = ASget_as_owner( &object, &CorId );
      if( CorId.objid != NULL_OBJID )
      {
         object.objid = CorId.objid;
         object.osnum = CorId.osnum;
      }
*/
      /* If more than 1 tip, check this one for same network */
      if((nb_tip == 1) && notcollected)
      {
        /* Create a buffer to hold point lists for network */
     /* Used VRtrace_network instead of GMndg for TR#179603615 */
     loc_status = VRtrace_network(nb_tip,tip_list,&nb_elmt,NULL,0,
                         NULL,&loc_env,&check_buff);  

     chk_cmp = nb_elmt;
        /* end for(index1)*/

        notcollected = FALSE;
        UI_status("");
      }
      comp_nt_fnd = FALSE;
      if( nb_tip ) /* check_buff setup with 1st select */
      {
        comp_nt_fnd = TRUE;
        for (index1 = 0; (index1 < chk_cmp) && comp_nt_fnd; index1 = index1 + 1)
        {
          if((object.objid == (check_buff+index1)->objid) &&
             (object.osnum == (check_buff+index1)->osnum))
            comp_nt_fnd = FALSE;
        }
      }
      if(comp_nt_fnd)
      {
        /* put out an error and skip the point */
        UI_status(" component not found in network");
        break;
      }
      /* See if tip has alread been selected */
      comp_nt_fnd = TRUE;
      for (index1=0; index1< nb_tip; index1=index1 + 1)
      {
        if((tip_list[index1].objid == object.objid) &&
           (tip_list[index1].osnum == object.osnum))
        {
          comp_nt_fnd = FALSE;
        }
      }
      if( ! comp_nt_fnd)
      {
        UI_status(" component already selected ");
        break;
      }

/* End add for TR#179603292 */

      tip_list[nb_tip] = object;
      nb_tip = nb_tip+1;
      break;

      default:
      break;
    }/* end switch*/
  } while(!finish);
  /* TR# 179603292 - law (02/04/97) */
  /* Used VRtrace_network instead of GMndg for TR#179603615 */ 
  loc_status = VRtrace_network(nb_tip,tip_list,&nb_elmt,NULL,0,
                         NULL,&loc_env,&sort_list);  

  /* Collect the points for the first avoid if only 1 tip TR#179603292 */
  if(( check_buff == NULL ) && (nb_tip == 1) && notcollected && (nb_elmt > 0))
  {
     chk_cmp = nb_elmt;
     check_buff = _CALLOC(chk_cmp,struct GRid);
  }
  /* Display the selected graph */
  for(index1=0; index1<nb_elmt; index1=index1+1)
    {
    p_object = &sort_list[index1];
    mode = GRhhdo;
/* status -> loc_status TR#179603292 */
    loc_status =ci$send ( msg = message NDnode.NDdisplay (0, mode, &active_env),
			targetid = p_object->objid,
			targetos = p_object->osnum );
    /*if more than 1 tip-check_buff already collected TR#179603292 */
    if((check_buff != NULL) && notcollected)
    {
       (check_buff + index1)->objid = p_object->objid;
       (check_buff + index1)->osnum = p_object->osnum;
    }
  }/* end for(index1)*/

  /* TR# 179603292 - law (02/04/97) */
  if((check_buff != NULL) && notcollected) notcollected = FALSE;  

  /* ------------------------- */
  /* Select the parts to avoid */
  /* ------------------------- */
  no_avoids = 0;
  /* If more than 1 tip, avoids are disabled.TR# 179603292 - law (02/04/97) */
  if(nb_tip == 1)
    {
    do
      {
      /* status -> loc_status TR#179603292 */
      loc_status = ci$locate
                (response    = &response,
 	        obj          = &object.objid,
                osnum        = &object.osnum,
                owner_action = LC_RIGID_COMP | LC_RIGID_OWNER |
                               LC_FLEX_COMP  | LC_REF_OBJECTS,

  /* TR# 179603292 - law (02/04/97) */
		eligible_classes = &locate_eligible_thing,
/**
		classes	     = "VRGeneric",
 **/

                md_env       = &loc_env,
  	        prompt       = MSG3,
  	        acc_prompt   = MSG2);
      UI_message(MSG0);

      switch (response)
        {
        case D_RESET:
        finish  = TRUE;
        goto wrapup;  /* TR# 179603292 - law (02/04/97) */
        break;

        case RESET :
        finish  = TRUE;
        break;
	        
        case DATA :
        finish  = FALSE;
        /* TR# 179603292 - law (02/04/97) */
        /* Check if an avoid item is a start collecting object */
        if((object.objid == tip_list[0].objid) &&
           (object.osnum == tip_list[0].osnum))
        {
          UI_status(" Cannot avoid selected start! ");
          break;
        }
        /* TR# 179603292 - law (02/04/97) */
        /* Check if object to avoid is in the selected network */
        comp_nt_fnd = FALSE;
        if(check_buff != NULL)
        {
          comp_nt_fnd = TRUE;
          for(index1=0; (index1<chk_cmp) && comp_nt_fnd; index1=index1+1)
          {
            if((object.objid == (check_buff + index1)->objid) &&
               (object.osnum == (check_buff + index1)->osnum))
               comp_nt_fnd = FALSE;
          }
        }
        if(comp_nt_fnd)
        {
          UI_status(" Avoid Component NOT in selected network");
          break;
        }
        /* See if the component to avoid has already been selected */
        if( ! keep_object(no_avoids,orig_avoid,&object))
        {
          UI_status(" Avoid Component already selected");
          break;
        }
        /* TR# 179603292 - law (02/04/97) */
        /* Add the selected object to the linked list */
        this_avoid = _CALLOC(1,COMP_ITEM);
        if(no_avoids)
        {
          prev_avoid->pNext = this_avoid;
        }
        else
        {
          orig_avoid = this_avoid;
          /* Large block of code deleted here for TR#179603615 */
        }
        this_avoid->CompId.objid = object.objid;
        this_avoid->CompId.osnum = object.osnum; /* Added for TR179603615 */
        prev_avoid = this_avoid;          
        /* Add the new element to remove */

        no_avoids = no_avoids + 1;

        if(sort_list)
          _FREE(sort_list); /* Free befor new for TR#179603615 */

        /* Used VRtrace_network instead of GMndg for TR#179603615 */
        /* Get and display the new graph */
        loc_status = VRtrace_network(nb_tip,tip_list,&nb_elmt,NULL,no_avoids,
                         orig_avoid,&loc_env,&sort_list);  

        for(index1=0; index1<nb_elmt; index1=index1+1)
          {
          p_object = &sort_list[index1];
          mode = GRhhdo;
          /* TR# 179603292 - law (02/04/97) */
          if(keep_object(no_avoids,orig_avoid,p_object))
          {
             loc_status = ci$send ( msg = message NDnode.NDdisplay
                        (0, mode, &active_env),
			targetid = p_object->objid,
			targetos = p_object->osnum );
          }
        }/* end for(index1)*/
        break;

        default:
        break;
      }/* end switch*/
    } while(!finish);
  }/* end if(nb_tip)*/
  /* ----------------------------------- */
  /* Fill the graphic set with the graph */
  /* ----------------------------------- */

  /* Initialize the graphic set */

  status = ex$get_super
             (mod_id      = active_env.md_id.objid,
              mod_osnum   = active_env.md_id.osnum,
              super_name  = GR_GSMGR,
              create      = TRUE,
              super_class = "GRgsmgr",
              super_id    = &gsmgr_obj.objid,
              super_osnum = &gsmgr_obj.osnum);
  gm$status(type = EXCEPTION_2);

  status = om$make_chanselect
             (channame     = "GRgsmgr.select_set",
              p_chanselect = &chan_sel);
  gm$status(type = EXCEPTION_2);

  /* status -> loc_status TR179603292 */
  loc_status = om$get_channel_count
             (objid        = gsmgr_obj.objid,
              osnum        = gsmgr_obj.osnum,
              p_chanselect = &chan_sel,
              count        = &nb_grset);
 
  /* status -> loc_status TR179603292 */
  if((loc_status & 1) && nb_grset)
    {
    status = gr$gsempty(msg          = &msg,
                        senderid     = gsmgr_obj.objid,
                        senderos     = gsmgr_obj.osnum,
                        p_chanselect = &chan_sel);
  }/* end if status*/

  set_prop = GRIS_CURRENT;
  grset_obj.objid = NULL_OBJID;
  grset_obj.osnum = gsmgr_obj.osnum;
  status = ci$send
             (msg     = message GRgrset.GSinit(&msg,&set_prop,&gsmgr_obj,
                        &chan_sel),
              targetid = grset_obj.objid,
     	      targetos = grset_obj.osnum);
  gm$status(type = EXCEPTION_2);

  env_prop = GSIS_SV_SPEC_MASK;
  svset_obj.objid = NULL_OBJID;
  svset_obj.osnum = loc_env.md_id.osnum;
  status = ci$send
             (msg = message GRsvset.GSsvinit(&msg,&loc_env,&env_prop,NULL),
              targetid = svset_obj.objid,
     	      targetos = svset_obj.osnum);
/*
  gm$status(type = EXCEPTION_2);

  suppress error print at end of reject range  */

  if (!(status &1))
  {
    exception_type = EXCEPTION_2;
    goto exception;
  }

  status = om$make_chanselect
             (channame     = "GRgrset.to_sets",
              p_chanselect = &to_grset);
  gm$status(type = EXCEPTION_2);

  status = om$make_chanselect
             (channame     = "GRgrset.to_owners",
              p_chanselect = &from_svset);
  gm$status(type = EXCEPTION_2);

  status = ci$send
             (msg = message Root.connect
                    (from_svset,OM_K_MAXINT,grset_obj.objid,grset_obj.osnum,
                     to_grset,OM_K_MAXINT),
              targetid = svset_obj.objid,
     	      targetos = svset_obj.osnum);
  gm$status(type = EXCEPTION_2);

  /* TR#179603292 - (17 Jan 1997-law) */
  /* Points collected are in random order */
  /* Store the collection into an array and send to VRtrace_network. */
  /* Note that check_buff is a temporary TOTAL network collection */

  /* TR#179603615 - block of code deleted */
  /* Free sort_list before new is added */
if(sort_list)
    _FREE(sort_list);

/* Modified calls to VRtrace_network for TR#179603615 */
if(nb_tip == 1)
{
  loc_status = VRtrace_network(nb_tip,tip_list,&nb_elmt,NULL,no_avoids,
                         orig_avoid,&loc_env,&sort_list);  
}
else if (nb_tip > 1)
{
  loc_status = VRtrace_network(nb_tip,tip_list,&nb_elmt,NULL,0,
                         NULL,&loc_env,&sort_list);  
}
  /* If no error, send ordered components to que. */
  /* Removed ran_set processing for TR#179603615 */
  proc_list = sort_list;

  loc_object = _CALLOC(1,struct GRid);
  /* end TR#179603292 - (17 Jan 1997-law) */

  /* Fill the graphic set with the graph objects */
  for(index1=0; index1<nb_elmt; index1=index1+1)
    {
    /* TR#179603292 - (17 Jan 1997-law) */

    loc_object->objid = (proc_list+index1)->objid;
    loc_object->osnum = (proc_list+index1)->osnum;
        status = ci$send
              (msg = message GRgrset.GSadd(&msg,loc_object,NULL),
               targetid = svset_obj.objid,
   	       targetos = svset_obj.osnum);
        gm$status(type = EXCEPTION_2);
  }/* end for(index1)*/

  /* Format the response data */

  status = co$build_button
             ( msg    = &msg,
               button = &event.event.button);
  gm$status(type = EXCEPTION_2);

  event.num_id   = 1;
  event.num_val  = 0;
  event.response = EX_DATA;
  event.subtype  = GRst_LOCATE;
  event.located_object[0].located_obj = grset_obj;
  event.located_object[0].module_info = active_env;

  size = sizeof( struct GRevent );

  /* Put the save set on top of the software queue*/

  response = EX_OBJID;
  ex$putque
    (msg      = &msg,
     response = &response,
     byte     = &size,
     buffer   = &event.event.button);


  /* Remove the graph */
/*  Removed GMndg for TR#179603615
  GMh_disactivate(&h_cut);
  GMndg_disactivate(&graph);
*/
exception:
  switch(exception_type)
    {
    case EXCEPTION_2:  /* exits modified for TR#179603615 */
/*    GMh_disactivate(&h_cut); */
      this_avoid = orig_avoid;  /* This is to prevent compile errors */

    case EXCEPTION_1:
/*    GMndg_disactivate(&graph); */
      this_avoid = orig_avoid;  /* This is to prevent compile errors */

  }/* end switch */

  wrapup:  /* TR# 179603292 - law (02/04/97) */

  _FREE(proc_list);
  _FREE(loc_object);
  if (no_avoids)
  {
    this_avoid = orig_avoid;
    while(this_avoid)
    {
      next_avoid = this_avoid->pNext;
      _FREE(this_avoid)
      this_avoid = next_avoid;
    }
  }
  /* Free up the check_buff */
  if(check_buff != NULL) _FREE(check_buff);

  return (status);
}/* end main  */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
wakeup()
  {
  UI_message(MSG0);
}/* end wake_up */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

