/* $Id: COz_ModHose.u,v 1.2 2001/02/20 01:15:51 build Exp $ */
 
/***************************************************************************
 * I/ROUTE
 *
 * File:        vrppl/COz_ModHose.u
 *
 * Description:
 * 	This ppl has been written to Modify the Intermediate Vertex Points of
 *	the HOSE component. 
 *	
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COz_ModHose.u,v $
 *      Revision 1.2  2001/02/20 01:15:51  build
 *      Replaced v_dbgmacros.h with product specific dbgmacros.h
 *
 *      Revision 1.1  2001/01/12 23:44:38  anand
 *      New PPLs added in Service Pack.
 *
# Revision 1.1  2000/08/22  22:14:12  pinnacle
# Created: route/vrppl/COz_ModHose.u by apazhani for Service Pack
#
 *
 * History:
 *
 * MM/DD/YY  		AUTHOR  	DESCRIPTION
 * 08/22/2000  		Alwin   	Created for CR179901822
 ***************************************************************************/

#include <stdio.h>
#include <string.h>
#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"

#include "nddef.h"
#include "AS_status.h"
#include "VRattr_def.h"
#include "vrdbgmacros.h"
#include "nddef.h"
#include "ndmacros.h"
#include "VRutilmacros.h"
#include "ACattrib.h"
#include "ACrg_collect.h"
#include "griodef.h"
#include "VRmacros.h"
#include "VDmem_ppl.h"
#include "exdef.h"
#include "vrco_pto.h"
#define VR_FIXED_PLANE 1

extern struct GRid NULL_GRID;

extern 		GRdpb_get();
extern 		NDexec_batch();
extern 		NDwait_batch();
extern GRclassid	OPP_VRPComp_class_id;
extern GRclassid	OPP_VRPCComp_class_id;
extern GRclassid	OPP_ACheader_class_id;
extern GRclassid	OPP_ACrg_collect_class_id;

// Global Variables
IGRint		NbMissingParams; 
struct GRid	located_object;
struct GRmd_env	md_env;
struct GRid	MissingParamId, SysId, UsrId;

struct GRid	 	NewComponentId;
struct ACrg_coll 	MissingParamsList[VR_MAX_ATTR];
struct GRid	NewMissParamId;

print_matrix( dMatrix )
IGRdouble       *dMatrix;
{
        IGRint  k, l;

#ifdef vdsDEBUG
        printf("MATRIX\n");
        for(k=0; k<16; k=k+4 )
        {
                for( l=0; l<4; l=l+1 )
                {
                        printf("%f ", dMatrix[k+l] );
                }
                printf("\n");
        }
        printf("MATRIX\n");
#endif
}

IGRlong VRValidateComp()
{
     IGRint		i, nCount;
     IGRlong		retmsg, sts;

     NbMissingParams = 0;
     nCount = 0;

     // Check for the existence for the Missing Collector.
     sts = ci$send( msg = message VRGeneric.VRGetParams( &retmsg,
				&SysId, &UsrId, &MissingParamId ),
		    targetid = located_object.objid,
		    targetos = located_object.osnum );

     if( MissingParamId.objid == NULL_OBJID ) return MSFAIL;

     /*
      * Check for the existence of the attributes specific to HOSE Component.
      * dogx_0, dogy_0, dogz_0, dogx_1, dogy_1 & dogz_1
      */
     sts = ci$send( msg      = message ACrg_collect.AClist_attribute
			 ( &retmsg, VR_MAX_ATTR, 
			 MissingParamsList, &NbMissingParams ),
	      targetid = MissingParamId.objid,
	      targetos = MissingParamId.osnum );

     for( i=0; i<NbMissingParams; i=i+1 )
     {
       if( !strcmp( MissingParamsList[i].name, "dogx_0" ) ) nCount = nCount + 1;
       if( !strcmp( MissingParamsList[i].name, "dogx_1" ) ) nCount = nCount + 1;
       if( !strcmp( MissingParamsList[i].name, "dogy_0" ) ) nCount = nCount + 1;
       if( !strcmp( MissingParamsList[i].name, "dogy_1" ) ) nCount = nCount + 1;
     }

     if( nCount == 4 ) return MSSUCC;
     return MSFAIL;
}


/*
 * This function is written to convert the Coordinates obtained from the Event,
 * to the Local Reference Coordinate of the Cpt.
 *
 * The User event might be wrt to non-Base Coordinate system. In this case we
 * need to obtain the coordinate wrt Base Coordinate system and convert it
 * wrt to Ref Coordinate of the Located Component.
 */

IGRlong VRConvertValuesToLocalCS( dogx, dogy, dogz )
IGRdouble	*dogx, *dogy, *dogz;
{
   /* 
    * Get the Coordinates of the Active Coordinate system. Remember this could
    * Base Coordinate itself, in that case matrix would UNIT Matrix.
    */
   IGRdouble		dCoordWRTBase[3]; // Coordinates wrt BASECoordinate Sys
   IGRdouble		cs_ref_matrix[16], CompMatrix[16];
   IGRlong		sts, msg;
   IGRchar		cstype[256];
   struct GRid		active_cs_id;
   struct ret_struct 	StrOrigin;

   /****
   sts = VRskget_active_cs( NULL, &active_cs_id,
			   cs_ref_matrix, cstype );
   print_matrix(  cs_ref_matrix );

   dCoordWRTBase[0] = -cs_ref_matrix[3] + (*dogx);
   dCoordWRTBase[1] = -cs_ref_matrix[7] + (*dogy);
   dCoordWRTBase[2] = -cs_ref_matrix[11] + (*dogz);
   ****/
   dCoordWRTBase[0] = (*dogx);
   dCoordWRTBase[1] = (*dogy);
   dCoordWRTBase[2] = (*dogz);

   __DBGpr_vec( " Coordinate's WRT BASECoordinate Sys ", dCoordWRTBase );

   /****
   sts = VR$GetMatrix(	
			p_msg 		= &msg,
			p_ComponentId	= &located_object,
			p_Matrix	= CompMatrix,
			CompCpt		= 0,
			p_MdEnv		= &md_env );

   __DBGpr_com( " Matrix of the Component Cpt 0 " );
   print_matrix( CompMatrix );
   ****/

   sts = ci$send( msg = message VRGeneric.VRGetMatrix( &msg, NULL,
					NULL, CompMatrix, &md_env ),
				targetid = located_object.objid,
				targetos = located_object.osnum );
   print_matrix( CompMatrix );

   *dogx = -CompMatrix[3] + dCoordWRTBase[0];
   *dogy = -CompMatrix[7] + dCoordWRTBase[1];
   *dogz = -CompMatrix[11] + dCoordWRTBase[2];

#ifdef vdsDEBUG
   printf( "\n Coord. wrt Component Ref Coord Sys : <%f %f %f>\n", 
			*dogx, *dogy, *dogz );
#endif
  return MSFAIL;
}

IGRlong VRCreateNewHose()
{
  IGRint	i, nMacroType, mat_type, nFeetCount, size_list;
  IGRint	nProduct, NbCpts, nLocalNbMissingParams;
  IGRint	props, action;
  IGRint	CmpNbCpts, CmpType, CmpOption, CmpItemNum, CmpStatus;

  IGRchar	cRep, CmpNoMtoFlag;
  IGRchar	szMacroName[20];
  IGRchar	szCmpAABBCCcode[20], CmpNumber[80], CmpNotes[80];

  IGRlong 	status, sts, retmsg, msg;
  IGRdouble	dAngle, Matrix[16];

  enum GRdpmode	mode;
  struct GRid	NewMacro, SymbolId;
  struct GRid	GraphicId;

  struct VRGenInfo	CompInstance;
  struct GRsymbology	Symb;

  __DBGpr_com( " >> VRCreateNewHose " );

  /*Erase the display of this object, permanently. Otherwise it will lead
  to confusion. */
  props = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  action = 0;
  sts = ci$send ( msg = message GRgraphics.GRchgprops(
					  &msg, &action, &props ),
		 targetid = located_object.objid,
		 targetos = located_object.osnum );

  // Create a New Missing Parameters collection, for modifying the
  // dog_* parameters. So that it won't affect the contents of the
  // actual component.
  NewMissParamId.osnum       = md_env.md_id.osnum;
  NewMissParamId.objid       = NULL_OBJID;

  /**
  sts = om$construct (  classid = OPP_ACrg_collect_class_id,
                           p_objid      = &NewMissParamId.objid,
                           osnum        = NewMissParamId.osnum,
                           msg  =
                              message NDnode.NDchg_state (~0, ND_DEL_NO_CH));
  **/

  sts = ci$send( msg = message ACrg_collect.NDchg_state (~0, ND_DEL_NO_CH),
			  targetid = NewMissParamId.objid,
			  targetos = NewMissParamId.osnum ) ;
  as$status ();

  sts = ci$send( msg      = message ACrg_collect.ACadd_list_attribute
			  ( &retmsg, NbMissingParams, MissingParamsList ),
			  targetid = NewMissParamId.objid,
			  targetos = NewMissParamId.osnum ) ;
  as$status() ;

  /* ---- Get specific attributes from the component ---- */
  sts =
  VRGetCmpInfo( &msg, szCmpAABBCCcode, CmpNumber, CmpNotes,
                &CmpOption, &located_object, &md_env );

  __DBGpr_str( " Comp Code ", szCmpAABBCCcode );
  __DBGpr_str( " Comp number ", CmpNumber );
  __DBGpr_str( " Comp Notes ", CmpNotes );
  __DBGpr_int( " Comp Option ", CmpOption );

  /* ---- Get Component type from the component ---- */
  sts = VRGetCmpType( &msg, &CmpType, &located_object, &md_env );

  __DBGpr_int( " Comp Type ", CmpType );

  sts = ci$send( msg = message VRGeneric.VRGetProduct( &nProduct, NULL ),
		    targetid = located_object.objid,
		    targetos = located_object.osnum );
  __DBGpr_int( " Product number", nProduct );

  sts = ci$send( msg = message VRGeneric.VRGetSysType( &msg, &CmpItemNum ),
		    targetid = located_object.objid,
		    targetos = located_object.osnum );
  __DBGpr_int( " Comp ItemNum ", CmpItemNum );

  sts = ci$send( msg = message VRGeneric.VRGetNumberOfCpts( &msg, 
				&CmpNbCpts, &md_env ),
		    targetid = located_object.objid,
		    targetos = located_object.osnum );

  __DBGpr_int( " Comp. no. of Cpts ", CmpNbCpts );

  // Get the symbology
  sts = ci$send( msg      = message GRvg.GRgetsymb (&msg, &Symb),
		    targetid = located_object.objid,
		    targetos = located_object.osnum );

  // Get the reprsentation
  sts = ci$send( msg      = message ACncpx.ACget_NV_rep( &cRep ),
		    targetid = located_object.objid,
		    targetos = located_object.osnum );

  // Get the Instance Data of the HOSE component
  sts = ci$send( msg = message VRGeneric.VRGetInstance( &msg,
			     &CompInstance ),
		 targetid = located_object.objid,
		 targetos = located_object.osnum );

  dAngle = CompInstance.Attr.CComp.dAngleToCommon;
  __DBGpr_dbl( " dAngle ", dAngle );

  CmpStatus = 0;
  CmpNoMtoFlag = '\0';

  nLocalNbMissingParams = 0;
  NewComponentId.objid = NULL_OBJID;
  NewComponentId.osnum = md_env.md_id.osnum;
  sts = VR$Evaluate( 	p_msg           = &msg,
                        Product         = VR_PIPING,
                        AABBCCcode      = szCmpAABBCCcode,
                        ItemNum         = CmpItemNum,
                        SStatus         = CmpStatus,
                        Number          = CmpNumber,
                        Notes           = CmpNotes,
                        NoMtoFlg        = CmpNoMtoFlag,
                        p_Option        = &CmpOption,
                        Symbology       = &Symb,
                        Representation  = cRep,
                        p_Type          = &CmpType,
                        p_NbCpts        = &CmpNbCpts,
                        p_SysParamId    = &SysId,
                        p_UsrParamId    = &UsrId,
                        p_MissParamId   = &NewMissParamId,
                        p_ComponentId   = &NewComponentId,
                        p_NbMissParams  = &nLocalNbMissingParams,
                        p_AddrMissings  = NULL,
                        p_MdEnv         = &md_env );
  __DBGpr_int( " No. of Missing Params ", nLocalNbMissingParams );
  __DBGpr_obj( " New Component Id ", NewComponentId );

  if( !(sts & 1) || (nLocalNbMissingParams > 0) )
  {
    printf("\n\t Evaluation of the HOSE failed\n" );
    goto wrapup;
  }

  // Get the Matrix of the HOSE component
  sts = ci$send( msg = message VRGeneric.VRGetMatrix( &msg, NULL,
					NULL, Matrix, &md_env ),
				targetid = located_object.objid,
				targetos = located_object.osnum );
  print_matrix( Matrix );

  mode = GRbe;
  status = ci$send( msg      = message GRgraphics.GRdisplay
                               ( &msg, &md_env.md_env.matrix_type,
                                 md_env.md_env.matrix, &mode,
                                 &md_env.md_id ),
		    targetid = NewComponentId.objid,
		    targetos = NewComponentId.osnum ) ;
  as$status();

  /* -- Orient the HOSE component -- */
  VR$OrientComp( p_retmsg = &msg,
                 p_CmpId  = &NewComponentId,
                 Justif   = 0, //Cpt 0
                 Matrix   = Matrix,
                 Angle    = dAngle,
                 p_MdEnv  = &md_env );
  if( ! (1 &  msg) )
  {
	printf("\n\t  Orientation process of HOSE failed\n" );
	goto wrapup;
  }

  /* -- Display the Oriented Component -- */
  mode = GRbd;
  status = ci$send( msg      = message GRgraphics.GRdisplay
                               ( &msg, &md_env.md_env.matrix_type,
                                 md_env.md_env.matrix, &mode,
                                 &md_env.md_id ),
		    targetid = NewComponentId.objid,
		    targetos = NewComponentId.osnum ) ;
  as$status();

  __DBGpr_com( " << Fn VRCreateNewHose " );
  return OM_S_SUCCESS;

wrapup:
  __DBGpr_com( " << Fn VRCreateNewHose " );
  return OM_E_ABORT;
}

void VRDeleteTempObject()
{
    IGRint	props, action, cn_type;
    IGRlong	msg;

    cn_type = ND_COMP;
    nd$wait_batch(
		  type       = GR_DELETED,
		  l_object   = &NewComponentId,
		  l_obj_info = &cn_type,
		  nb_obj     = 1 );
    nd$exec_batch();

    props = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    action = 1;
    ci$send ( msg = message GRgraphics.GRchgprops(
					    &msg, &action, &props ),
		   targetid = located_object.objid,
		   targetos = located_object.osnum );
}

main()
{
  IGRboolean			bCompModified;
  IGRint 			bSameStage, cn_type, i, j, ArraySize;
  IGRint			M_response, NbParents, NbPlanes;
  IGRint			props, action;
  IGRchar			txt[256];
  IGRlong 			sts, msg, ret;

  IGRdouble			dogx_0, dogy_0, dogz_0;
  IGRdouble			dogx_1, dogy_1, dogz_1;

  OM_S_CLASSLIST        	locate_eligible_thing;
  GRclassid			ClassId[2];
  struct GRid			*buffer, PlaneIds[10];
  struct GRevent  		event;
  struct ACrg_coll		ListAttr[4];
  struct GRvg_construct  	cst_list;
  struct IGRdisplay  		ActiveDisplay; 
  struct VRGenInfo		CompInstance;
  struct GRas        		assoc_list;

  ClassId[0] = OPP_VRPComp_class_id;
  ClassId[1] = OPP_VRPCComp_class_id;

  locate_eligible_thing.w_count = 2;
  locate_eligible_thing.p_classes = ClassId;

  __DBGpr_com( " >> Entered the PPL " );

  message( "Modify Flexible Hose" );

  ci$get_module_info( md_env = &md_env );

  while( 1 )
  {
LocateComponent:
      // Delete the Temporary Object
      if( NewComponentId.objid != NULL_OBJID )
      {
	  VRDeleteTempObject();
      }

      ci$locate(  prompt  = "Identify Flex HOSE",
		  acc_prompt      = "Accept/Reject" ,
		  eligible_classes= &locate_eligible_thing,
		  owner_action    = LC_RIGID_OWNER | LC_RIGID_COMP |
				    LC_FLEX_OWNER | LC_FLEX_COMP,
		  obj             = &located_object.objid,
		  osnum           = &located_object.osnum,
		  response        = &M_response,
		  md_env          = &md_env ) ;

      bCompModified = FALSE;
      switch (M_response) 
      {
	 case EX_DATA  :
	     __DBGpr_obj( " Located Object", located_object );

	     sts = VRValidateComp();
	     if( !sts & MSSUCC ) 
	     {
		UI_status( "Located Wrong Component" );
		goto LocateComponent;
	     }

	     // Create a HOSE Temporarily for dynamics sake and delete it later
	     sts = VRCreateNewHose();
	     if( !(sts & 1) )  
	     {
		UI_status(" HOSE Evaluate failed" );
		exit;
	     }

	     bSameStage = TRUE; // for the first entry

FirstPoint:
	     while( bSameStage )
	     {
                strcpy(txt, "Position first bend vertex/Move on for second bend vertex" );
                ci$getevent( prompt   = txt,
                             mask     = GRm_RJT_MOVEON | GRm_DATA,
			     stackable= 1,
                             event    = &event,
                             response = &M_response);

		__DBGpr_int( " Response ", M_response );

		if( M_response == EX_DATA )
		{
		   bCompModified = TRUE;
		   dogx_0 = 0.0;
		   dogy_0 = 0.0;
		   dogz_0 = 0.0;

		   __DBGpr_com( " User specified first point :: " );
		   __DBGpr_dbl( " First pt -X ", event.event.button.x );
		   __DBGpr_dbl( " First pt -Y ", event.event.button.y );
		   __DBGpr_dbl( " First pt -Z ", event.event.button.z );

		   dogx_0 = event.event.button.x;
		   dogy_0 = event.event.button.y;
		   dogz_0 = event.event.button.z;

		   sts = VRConvertValuesToLocalCS( &dogx_0, &dogy_0, &dogz_0 );

		   strcpy( ListAttr[0].name, "dogx_0" );
		   ListAttr[0].desc.type = AC_ATTRIB_DOUBLE;
		   ListAttr[0].desc.value.att_exp = dogx_0;

		   strcpy( ListAttr[1].name, "dogy_0" );
		   ListAttr[1].desc.type = AC_ATTRIB_DOUBLE;
		   ListAttr[1].desc.value.att_exp = dogy_0;

		   sts = VR$ModifyCollection(
			     p_msg           	     = &msg,
			     Operation               = VR_MERGE_COLL,
			     p_ParamsListToModify    = ListAttr,
			     NbParamsToModify        = 2,
			     p_OutputCollectionId    = &NewMissParamId );

		   cn_type = ND_COMP;
		   nd$wait_batch(
				 type       = GR_GEOM_POSTED,
				 l_object   = &NewComponentId,
				 l_obj_info = &cn_type,
				 nb_obj     = 1 );
		   nd$exec_batch();
		}
		else if( M_response == EX_BACK_UP )
		{ 
		   VRDeleteTempObject();
		   goto LocateComponent;
		} 
		else if( M_response == EX_RJT_MOVEON ) bSameStage = FALSE; 
		else 
		{ 
		   __DBGpr_com( " Terminate the Command " );
		   VRDeleteTempObject();
		   exit;
		} 
	     }

SecondPoint:
	     bSameStage = TRUE;
	     while( bSameStage )
	     {
		strcpy( txt, "Position second bend vertex/Move-on to End" );
		ci$getevent( prompt   = txt,
			   mask     = GRm_RJT_MOVEON | GRm_DATA,
			   stackable= 1, //to allow stacking of commands
			   event    = &event,
			   response = &M_response);

		if( M_response == EX_DATA )
		{
		   bCompModified = TRUE;
		   dogx_1 = event.event.button.x;
		   dogy_1 = event.event.button.y;
		   dogz_1 = event.event.button.z;

		   sts = VRConvertValuesToLocalCS( &dogx_1, &dogy_1, &dogz_1 );

		   strcpy( ListAttr[0].name, "dogx_1" );
		   ListAttr[0].desc.type = AC_ATTRIB_DOUBLE;
		   ListAttr[0].desc.value.att_exp = dogx_1;

		   strcpy( ListAttr[1].name, "dogy_1" );
		   ListAttr[1].desc.type = AC_ATTRIB_DOUBLE;
		   ListAttr[1].desc.value.att_exp = dogy_1;

		   sts = VR$ModifyCollection(
			     p_msg           	     = &msg,
			     Operation               = VR_MERGE_COLL,
			     p_ParamsListToModify    = ListAttr,
			     NbParamsToModify        = 2,
			     p_OutputCollectionId    = &NewMissParamId );

		   cn_type = ND_COMP;
		   nd$wait_batch(
				 type       = GR_GEOM_POSTED,
				 l_object   = &NewComponentId,
				 l_obj_info = &cn_type,
				 nb_obj     = 1 );
		   nd$exec_batch();
		}
		else if( M_response == EX_BACK_UP ) goto FirstPoint;
		else if( M_response == EX_RJT_MOVEON ) bSameStage = FALSE;
		else
		{ 
		   __DBGpr_com( " Terminate the Command " );
		   VRDeleteTempObject();
		   exit;
		} 
	     }

ReplaceComponent:

	      if( bCompModified )
	      {
		 // Get the content from the Modified Missing colletor and
		 // place it in the Actual Component Missing Collector
		 sts = ci$send( msg  = message ACrg_collect.AClist_attribute
				     ( &msg, VR_MAX_ATTR, 
				     MissingParamsList, &NbMissingParams ),
			  targetid = NewMissParamId.objid,
			  targetos = NewMissParamId.osnum );

		 sts = VR$ModifyCollection(
			   p_msg           	     = &msg,
			   Operation               = VR_MERGE_COLL,
			   p_ParamsListToModify    = MissingParamsList,
			   NbParamsToModify        = NbMissingParams,
			   p_OutputCollectionId    = &MissingParamId );

		 // Delete the Temporary Object and apply the changes over
		 // the old/actual component
		 VRDeleteTempObject();

		 ArraySize = 10;
		 NbPlanes = 0;
		 sts = ci$send( msg = message VRGeneric.VRGetPlanes( &msg,
				 ArraySize, PlaneIds, &NbPlanes, &md_env ),
		     targetid = located_object.objid,
		     targetos = located_object.osnum );

		 // Arrest the Terminator plane of the Component
		 sts= ci$send( msg      = message VRplane.VRchg_plane_state
					       ( VR_FIXED_PLANE, 1 ),
			targetid = PlaneIds[2].objid,
			targetos = PlaneIds[2].osnum );

		 cn_type = ND_COMP;
		 nd$wait_batch(
			       type       = GR_GEOM_POSTED,
			       l_object   = &located_object,
			       l_obj_info = &cn_type,
			       nb_obj     = 1 );
		 nd$exec_batch();

		 // Release the Terminator plane of the Component
		 sts= ci$send( msg      = message VRplane.VRchg_plane_state
					       ( VR_FIXED_PLANE, 0 ),
			targetid = PlaneIds[2].objid,
			targetos = PlaneIds[2].osnum );
	      }
	      break;

	 case EX_RJT_MOVEON :

	    /* DO NOTHING */
	    break;

	 default :
	    exit;
	    break;
      }
      props = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
      action = 1;
      sts = ci$send ( msg = message GRgraphics.GRchgprops(
					      &msg, &action, &props ),
		     targetid = located_object.objid,
		     targetos = located_object.osnum );
      located_object.objid = NULL_OBJID;
      UI_status( "Successful Modification" );
  } /* End of while loop */

  __DBGpr_com( " << Exiting the PPL " );
}

delete()
{
  // While the command terminated delete the Temporary object
  VRDeleteTempObject();
}

// rest are all dummy methods
init()
{
}

wakeup()
{
}

sleep()
{
}
