/* $Id: VRvalidate.u,v 1.6 2002/04/15 20:04:22 anand Exp $  */

/***************************************************************************
 * I/ROUTE
 *
 * File:        vrppl/VRvalidate.u
 *
 * Description:
 *
 * Dependencies:
 *              I/Route parameters routine.
 *
 * Revision History:
 *      $Log: VRvalidate.u,v $
 *      Revision 1.6  2002/04/15 20:04:22  anand
 *      Removed version.h and associated dependencies. version.h is
 *      an include file in /opt/ingr/exnucdp.
 *
 *      Revision 1.5  2001/11/01 18:13:33  ylong
 *      *** empty log message ***
 *
 *      Revision 1.4  2001/10/10 19:43:08  ylong
 *      CR5362, validate pen
 *
 *      Revision 1.3  2001/03/22 15:53:42  ad
 *      Make it ROUTE only
 *
 *      Revision 1.2  2001/03/07 21:50:01  jvhanson
 *      found the error finding key problem, it was in the loop getevent
 *
 *      Revision 1.1  2001/03/07 19:19:55  jvhanson
 *      new core file route validate commands
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      03/06/01        jvh             Command to validate route stuff
 *	03/21/00	adz		Make independent from Struct.
 ***************************************************************************/

#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <memory.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "OMindex.h"
#include "madef.h"
#include "OMerrordef.h"
#include "OMminimum.h"
#include "OMprimitives.h"
#include "igrtypedef.h"
#include "igetypedef.h"
#include "exmacros.h" 
#include "version.h"
#include "EXproduct.h"
#include "igrdp.h"
#include "go.h"
#include "godef.h"
#include "grmacros.h"
#include "v_edgemacros.h"
#include "v_edgedef.h"
#include "vrdbgmacros.h"
#include "refdef.h"
#include "ref.h"
#include "AS_status.h"
#include "FI.h"
#include "CIforms.h"
#include "VDpplInfo.h"
#include "vdsetmacros.h"

#include "dp.h"
#include "dpdef.h"
#include "nddef.h"
#include "ndmacros.h"
#include "VDmem_ppl.h"

#define  FI_STRLEN 132
#define  AS_DEBUG 	1 
#define  OK		134250505
#define  Transient 	1
#define  EXECUTE 	1
#define	 RUN		2 
#define	 EXIT		4 
#define	 MESSAGET	9
#define	 MESSAGEB	10
#define	 LIST		11
#define	 NAVIGATE	13 
#define	 EVENTOBJ	14 
#define	 EVENTSET	20 
#define	 TITLE		12 
#define	 MIGRATE	100 
#define	 WRITEFILE	15 
#define	 FILENAME	16 
#define	 MIGCHK		17 
#define	 DUPCHK		18
#define	 NAMCHK		19 
#define	 CLEANBTN	21
#define	 CLEANLSTM	57
#define	 DELETE		28 
#define	 BROWSE		23 
#define	 SELECTALL	30
#define	 MIGERR		34
#define	 DUPERR		35
#define	 NAMERR		36
#define  REFFLD		38
#define	 LEVBTN		40
#define	 LEVFLD		41
#define	 LEVSKP		51
#define  IGNOREST	54
#define  LINE		55
#define  CLEANFILE	"VRvalidate.lis"
#define  CLEANFILE1     "VPvalidate.lis"
#define  DUPEXCEPTION	"dup_excepts.lis"

#define	 APP		"Route"
#define  cmdtitle	"Validate Route" 
#define  cmdtitle1      "Validate Pen"
#define  MAXLISTLEN	10000
#define  MAXDISPLIST	5000
#define  FNAME 		"VRvalidate.fm"	/* change form name */
#define  FLABEL		100
#define  tmpfilename	".process.log"  /* validate route */
#define	 MAXNUM		50000
#define	 MAX_CHA_EXC	40
#define  MAX_EXC	100

int		myCmdType ;
//#define  DEBUG		1
extern int errno;
IGRchar		outputfilename[128];
IGRlong		time_1 ;
IGRlong		time_2 ;
IGRlong		time_3 ;
IGRboolean	migchk;
IGRboolean	dupchk;
IGRboolean	namchk;
IGRint		msg ;
IGRint		form_exists;
IGRint		form_displayed ;
IGRint		k ;
IGRint		l ;
IGRint		row;
IGRint		rerun;
IGRint		numMacros;
IGRint		migcnt ;
IGRint		dupcnt ;
IGRint		owncnt ;
IGRint		ignst;
IGRint		refosnums[150];
IGRint		beamcount ;
IGRint		platecount ;
IGRint		dupcount ;
IGRint		objtype ;
IGRint 		done ;
IGRint		skipCount;
IGRint		skipLevels[ 1024 ];
IGRchar		objName [ DI_PATH_MAX ] ;
IGRchar		ofilename [ DI_PATH_MAX ] ;
IGRchar		utogg ;
IGRchar		msg_str[ 128 ] ;
IGRchar		skipString[ 256 ] ;
struct GRid	*fixid ;
IGRint		*layer ;
IGRint		*selected ;
IGRint		macroCount ;
FILE		*logfile ;
struct GRid	FORM_ID ;
Form		STFORM ;
GRobj   	obj ;
IGRlong		CurOsnum ;
struct GRmd_env	MOD_ENV;
IGRchar		*except_names[MAX_EXC], buff[MAX_CHA_EXC*MAX_EXC];
IGRint		num_exceptions;
struct {
  int response;
  int *data;
} e;

struct CIform_st form_st;

extern ASmake_source_from_env();
extern struct EX_prod_def  *EX_product_list;
extern ci_notification ();
extern char *malloc();
//extern long *time();
extern GRget_properties(); 
extern int EX_getpath();
extern int FI_append_symbol_path ();
extern int FI_append_form_path ();
extern FIf_new ();
extern FIf_set_cmd_oid_os ();
extern FIf_delete ();
extern FIf_display ();
extern FIf_erase ();
extern FIfld_set_text ();
extern FIfld_get_num_rows ();
extern FIfld_get_value ();
extern FIfld_set_value ();
extern FIfld_get_select ();
extern FIg_disable ();
extern FIg_enable ();
extern FIg_erase ();
extern FIfld_set_list_num_rows ();
extern FIg_reset ();
extern FIfld_get_list_text ();
extern FIfld_set_list_text ();
extern FIfld_get_text ();
extern FIg_get_value ();
extern FIg_get_text ();
extern FIfld_set_select ();
extern FIfld_get_active_row ();
extern FIg_get_state ();
extern FIg_set_text ();
extern FIfld_set_default_text ();
extern FIfld_get_list_num_rows ();
extern FIfld_get_list_select ();
extern FIg_display ();
extern FIfld_delete_rows();
extern FIfld_set_list_scroll();
extern FIfld_set_active_row ();

extern IGRint EX_get_global();
extern GRchange_properties();
extern GRsymbology_options();
extern GRdisplay_object();
extern IGRint VDcheckGroupOfMacros() ;
extern IGRint mod();
extern IGRint VDgetName();
extern IGRint EX_get_super();
extern NDexec_batch();
extern NDput_mod_batch();
extern NDget_mod_batch();
extern char *strncpy();
extern EX_get_modid_given_osnum();

ppl_info()
{
char	txtstr1[1024];
char	txtstr2[1024];
char	txtstr3[1024];

	VDpplInitInfo( &PPL_INFO );

	/* Define Command info structure */

	strcpy( PPL_INFO.title, "Validate Tools for Route Files." );
        strcpy( PPL_INFO.product, "ISDP I/ROUTE" );
        strcpy( PPL_INFO.version, "02.06.01.15" );
        strcpy( PPL_INFO.desc_short, "form driven validation tool." );

        PPL_INFO.desc_count = 3 ;   /* maximnum 10 */
	
        PPL_INFO.desc[0]="This command has several validation routines for checking route files. It also has a mechanism to allow the adimistrator the ability to add additional ppls to the list of validation ppls." ;

	sprintf( PPL_INFO.desc[1], "The output is sent to a file %s in the local directory and also displayed on the validation command form.  The elements displayed on the form with ID[?, ?] are able to be located, deleted, navigated, browsed, and evented.", tmpfilename );
	
        //PPL_INFO.desc[1]="The output is sent to a file .process.log in the local directory and also displayed on the validation command form.  The elements displayed on the form with ID[?, ?] are able to be located, deleted, navigated, browsed, and evented." ;
        PPL_INFO.desc[2]="To add a command to the list the filename is VRPvalidate.lis in the Route/config directory.  If you want the output of your command to be posted back into the validate form then you must create the output file named .process.log, when your command is finished executing VRvalidate reads the file .process.log and displays the results in the form. If you want locatable objects in the form the object id must be in the syntax \"id[ id, os]\", \"Id[ id, os]\", or \"ID[ id, os]\"." ;
        return 1;
}


/*******************************************************************************/
int   getProdInfo( run_name , logo , conf_path )
IGRchar     * run_name ;
IGRchar     * logo ;
IGRchar     * conf_path ; 
{

        struct EX_prod_def      *prodDef ;
        IGRchar                 config_path[512] ;
        IGRint                  name_found ;
        IGRint                  prod_found ;
        IGRint                  i ;
        IGRlong                 sts ;
        IGRchar                 name[512] ;

        SetProc( getProdInfo ); Begin

        name_found = FALSE ;
        prod_found = FALSE ;
        sts = OM_S_SUCCESS ;

        if( ( run_name == NULL ) && ( logo == NULL ) ){
                __DBGpr_com(" Invalid Arguments" );
                return OM_E_INVARG ;
        }
        
        if( conf_path != NULL ){ *conf_path = '\0';  }

        prodDef = EX_product_list ;

        if( run_name )  __DBGpr_str(" Run_Name ", run_name );
        if( logo     )  __DBGpr_str(" LOGO     ", logo );
        

        while( prodDef ){
        
          __DBGpr_str("   RUN_NAME ",  prodDef->run_name);
          __DBGpr_str("   LOGO_PTR ",  prodDef->logo);

  
  	  if( strcmp(prodDef->run_name, run_name) == 0 ){
             
            name_found = TRUE;

	    //#ifdef DEBUG
            __DBGpr_str("===run_name     ",  prodDef->run_name);
            __DBGpr_str("===logo_ptr     ",  prodDef->logo);
            __DBGpr_str("===module_class ",  prodDef->module);
            __DBGpr_str("===search_path  ",  prodDef->srch_path);
            __DBGpr_str("===config_path  ",  prodDef->config_path);
            __DBGpr_str("===product_path ",  prodDef->product_path);
            __DBGpr_int("===license      ",  prodDef->license );
            __DBGpr_int("===status       ",  prodDef->status );
            __DBGpr_int("===flags        ",  prodDef->flags );
            __DBGpr_com(" \n\n");
	    //#endif
            strcpy( config_path , prodDef->config_path);
            break;
            
          }
          prodDef = prodDef->next;
        }

        if ( !name_found ) return OM_E_NOTIMPL ;

        __DBGpr_str( "Checking path", config_path );

            
        i = 0;
        sts = OM_S_SUCCESS;
        while ( sts ){

          sts = ex$get_path( index = i , path = name, len = sizeof(name) );

          __DBGpr_int ( "Path no", i );
          __DBGpr_str ( "Config path", name );

          if( !strcmp( name, config_path )){

            __DBGpr_com("FOUND PRODUCT");
            prod_found = TRUE;
            break;
          }
          i = i + 1;
        }

        /*
         * Give return value.
         */
        if( prod_found ){
          if ( conf_path != NULL ){
                strcpy ( conf_path, config_path );
                __DBGpr_str(" CONFIG ", conf_path );
          }
          End ;
          return OM_S_SUCCESS ;
        }
        else{
          End ;
          return OM_E_NOTIMPL ;
       }
}


/************************************************************************
this function prints a string into the log file, and records -1 as the
object id in a list for selection later.
***********************************************************************/
printStr ( inStr )
char	*inStr;
{
char	name[ DI_PATH_MAX ];
char	objclassname[ DI_PATH_MAX ];
char	TmpStr[256];
char	ObjStr[256];
       
			
	sprintf( TmpStr , "%s ", inStr );
	fprintf( logfile , "%s\n", TmpStr );

	__DBGpr_str( "TmpStr ", TmpStr );

}


/************************************************************************
this function prints an object into the log file, and records the 
object id into a list for selection on a form.
***********************************************************************/
IGRint printObj ( in_obj, inStr, checklev )
struct GRid in_obj;
IGRchar	*inStr;
IGRint	checklev;
{
IGRchar	name[ DI_PATH_MAX ];
IGRchar	objclassname[ DI_PATH_MAX ];
IGRchar	TmpStr[256];
IGRchar	ObjStr[256];
IGRchar	valstr[40];
struct GRsymbology  symb ;   
   
	msg = om$get_classname(	osnum = in_obj.osnum,
				objid = in_obj.objid,
				classname = objclassname );
				  			
	/* get the name of the object */
	msg = VDgetName( in_obj, name );
			
	sprintf( TmpStr , "%sID[%d, %d], type[%s], name[%s]", 
		inStr , in_obj.objid, in_obj.osnum, objclassname, name );

	fprintf( logfile , "%s\n", TmpStr );
	
	return TRUE;
}




/*************************************************************
  This function will check to see if the object is in the 
  :usr: partition in the file
**************************************************************/

IGRint checkName ( InObj , name )
struct GRid	InObj;
char		name[DI_PATH_MAX];
{
IGRint	msg;
IGRint	sts;
IGRint	i;
IGRint	found;
IGRint	off;

	/* get the name of the object */
	sts = ci$send( msg = message GRvg.GRgetname( &msg , name ),
		targetid = InObj.objid ,
		targetos = InObj.osnum );
		
        if( !( msg & 1 & sts ) ) return -1 ;
	
	/* check the name to see if it is in the usr partition */
	
	found = 0;
	off = 0;
	
	/* if empty then return false */
	if ( strlen(name) < 1 ) return -1;
	
	#ifdef DEBUG
	printf("strlen of %s=%d\n",name, strlen(name));
	#endif
	
	msg = FALSE;
	
	for( i=0; i<strlen(name);i=i+1){
	
		if( name[i] == 58 ){ 
			found = found + 1; 
			off = i;
			#ifdef DEBUG
			printf("found=%d at index %d\n", found , i );
			#endif
		}
	
		if( found == 3 ){
				msg = FALSE;
				goto wrapup;
		}	
		
		if( found == 2 ) {
			if ( name[i+0] == 58 &&
			     name[i+1] == 117 &&
			     name[i+2] == 115 &&
			     name[i+3] == 114 &&
			     name[i+4] == 58 ){ 
				

				#ifdef DEBUG
				printf("found :usr: [%c%c%c%c%c]", 
					name[i+0],
					name[i+1],
					name[i+2],
					name[i+3],
					name[i+4]);
				#endif
				msg = TRUE;
				break;
			} else {
				msg = FALSE;
				goto wrapup;
			}
		}
	}
	#ifdef DEBUG
	printf(":usr: found in %s\n", name );
	#endif
wrapup:

	return msg;
}

/******************************************************/

IGRint findTheForm( fileName, filePath )
IGRchar *fileName, *filePath;
{
IGRint  i, msg ;
IGRchar initPath[1024] ;
FILE   *file;

  file = NULL ;

  // Flip through paths
  i = 0;
  msg = FALSE;
  while(1) {

    *initPath = 0;
    ex$get_path(index = i,
                path  = initPath,
                len   = sizeof(initPath),
                type  = EX_CONFIG_PATH);

    if (*initPath == 0) goto wrapup;

    sprintf(filePath,"%sconfig/english/forms/%s", initPath , fileName );
    file = NULL;
    file = fopen(filePath,"rt");
    if ( file ) {

      #ifdef DEBUG_findfiles
      printf("Setup %s\n",filePath);
      #endif
      sprintf(filePath,"%sconfig/english/forms", initPath );
      fclose( file );
      file = NULL;
      msg=TRUE;
      goto wrapup;
    }

    i=i+1;
  }
wrapup:

return msg;

}



/******************************************************************/
void form_init ( product_path )
IGRchar		*product_path;
{
IGRchar			form_path[256];
IGRint			pstatus;
IGRint			sts ;
  SetProc( form_init ); Begin
  
  if( form_exists == TRUE ) {
    __DBGpr_com ( "form_exists == TRUE");
    return;
  }
  __DBGpr_com ( "form_exists == FALSE");
  

  /***  Tell I/Forms where to find our form path ************************/

  sts = findTheForm ( FNAME , form_path );
  if( sts == FALSE){ return; }
  
  FI_append_form_path ( form_path );

  /*
   * the initialization of the form, which includes setting linking the form
   * to the command object; Get the form input and display the found
   * information in the form.
   */
 
  pstatus = FIf_new(	FLABEL ,		
  			FNAME,
  			ci_notification,
  			&STFORM ) ;
  			
  if ( (pstatus != FI_SUCCESS) || ( STFORM == NULL) )
  {
      strcpy (msg_str, "FATAL: Cannot initialize the form");
      strcat (msg_str, "\n");
      write (msg_str, "Error code = ", pstatus, "\n");
      goto wrapup;
  }

  if(myCmdType) { 
  /* set the title of the form */
    FIg_set_text ( STFORM, 12, cmdtitle1 );
  } else { 
    FIg_set_text ( STFORM, 12, cmdtitle );
  }
  
  

  form_exists = TRUE;
  

  /*
   * MY_ID and OM_Gw_current_OS are symbolic constants that are defined in
   * the "ciminimum.h" include file. 
   */

  pstatus = FIf_set_cmd_oid_os ( STFORM , MY_ID , OM_Gw_current_OS ) ;
  if (pstatus != FI_SUCCESS)
  {
      strcpy (msg_str, "FATAL: Cannot link to the I/Forms system");
      strcat (msg_str, "\n");
      write (msg_str, "Error code = ", pstatus, "\n");

      /****   The form has been loaded into memory at this point.  we need to
              delete it from memory at this point.  ***********************/

      FIf_delete ( STFORM );
      form_exists = FALSE;
      form_displayed = FALSE;
      goto wrapup;
  }

  form_exists = TRUE;
  
wrapup:  
  
  End
  return ;
}

/******************************************************************/
void form_disp (  )
{
IGRint			pstatus;

  SetProc( form_disp ); Begin

  /*
   * display the form
   */

  if( form_exists == TRUE ){
    
    pstatus = FIf_display ( STFORM ) ;
    if( pstatus != FI_SUCCESS ){

      strcpy (msg_str, "FATAL: Cannot display the form");
      strcat (msg_str, "\n");
      write (msg_str, "Error code = ", pstatus, "\n");

      FIf_delete ( STFORM ) ;
      form_exists = FALSE;
      form_displayed = FALSE;
      goto wrapup;
    }
    form_displayed = TRUE;
  } else {
    #ifdef DEBUG
    printf("form does not exist\n");
    #endif
    
    status("form not found");
  }
  
wrapup:  
  
  End
  return ;
}


/******************************************************/

IGRint getProductData ( product_path )
IGRchar	* product_path ;
{
IGRint	sts ;
  /*
   * get the product configuration from ingrconfig 
   */
  
  sts = getProdInfo( APP, NULL, product_path );
  
  #ifdef DEBUG
  printf("in getProductData path[%s]\n", product_path );
  #endif
  
  if (sts != OM_S_SUCCESS)
  {
      write (msg_str, "Error code = ", sts, "\n");
  }
  return ( sts );
}

/********************************************************/
saveAs( )
{
IGRchar	filnam[256] ;
IGRchar	cpstr[256] ;

	FIg_get_text( STFORM , FILENAME, filnam );
	if( strcmp( filnam, "" ) == 0 ){
		/* disable the write button */
		FIg_disable( STFORM, WRITEFILE );
		return;
	}
			     
	sprintf( cpstr , "/bin/cp ./%s %s", outputfilename , filnam );	
	sh( cpstr );

}

/*****************************************************************
 take a set of levels and check values and set in list 
 ****************************************************************/

setLevs( tmpstr, tmplev, numlevs, check )
IGRint	tmplev, *numlevs, *check;
IGRchar *tmpstr;
{
IGRint	stlev, max, i, j;
IGRint	enlev;

   #ifdef DEBUG
   printf("strlen of tmpstr=%d\n", strlen(tmpstr));
   #endif
   
   if( strlen( tmpstr ) == 0 ) return;
   
   enlev = atoi( tmpstr );
   
   /* make sure we are in the right range */
   
   if( enlev < 0 || enlev > 1023 ) return;
   
   if( *check == 1){
   	j=0;
	if( enlev < tmplev ){
		stlev = enlev;
		enlev = tmplev;
	} else {
		stlev = tmplev;
	}
	max = ( enlev - stlev ) + 1;
	for( i=0; i< max; i=i+1){
		skipLevels[stlev + i] = TRUE;
		j=j+1;
	}
	*numlevs = *numlevs + max;
	*check = 0;
   } else {
	#ifdef DEBUG
   	printf("setting skipLevels[%d] = %d, numlevs=%d\n", enlev , TRUE , *numlevs );
   	#endif
   	
   	skipLevels[enlev] = TRUE;
   	*numlevs = *numlevs + 1;
   }

}

/***************************************************************************
  Function parseSkipLevels will turn the string into an array of levels to
  ignore.
****************************************************************************/
IGRint parseSkipLevels (  )
{
IGRint check;
IGRint	j, i, count, numlevs, stlev, enlev, tmplev;
IGRchar	tmpstr[256];

  /* reset the skip level list */
  for(j=0;j<1024;j=j+1) skipLevels[j] = FALSE;
  
  check = 0;
  j = 0;
  numlevs = 0;
  count = strlen(skipString);
  
  #ifdef DEBUG
  printf("string[%s] count=%d\n", skipString, count);
  #endif
  
  for( i=0;i<count ; i=i+1){
  	#ifdef DEBUG
  	printf("char[%d]=%d\n", i, skipString[i]);
  	#endif
  	
	if( skipString[i] > 47 && skipString[i] < 58 ){
		tmpstr[j] = skipString[i];
		j=j+1;
		
	}else if( skipString[i] == 32 ){
		tmpstr[j] = 0;
		#ifdef DEBUG
		printf("got a space i=%d, j=%d, tmpstr[%s]\n", i , j , tmpstr );
		#endif
		j=0;
		setLevs( tmpstr , tmplev, &numlevs, &check );
		
	}else if( skipString[i] == 45 || skipString[i] == 58 ){
		tmpstr[j] = 0;
		#ifdef DEBUG
		printf("got a - or : i=%d, j=%d, tmpstr[%s]\n", i , j , tmpstr );
		#endif
		tmplev = atoi( tmpstr );
		j=0;
		check = 1;
		
	}else if( skipString[i] == 44 ){
		tmpstr[j] = 0;
		#ifdef DEBUG
		printf("got a , i=%d, j=%d, tmpstr[%s]\n", i , j , tmpstr );
		#endif
		j=0;
		setLevs( tmpstr , tmplev, &numlevs, &check );
		
	}
	/*
	else if( skipString[i] == 10 ||  skipString[i] == 0){
		tmpstr[j] = 0;
		#ifdef DEBUG
		printf("got a , i=%d, j=%d, tmpstr[%s]\n", i , j , tmpstr );
		#endif
		j=0;
		setLevs( tmpstr , tmplev, &numlevs, &check );
		
	}
	*/
  }
  
  tmpstr[j] = 0;
  
  #ifdef DEBUG
  printf("end i=%d, j=%d, tmpstr[%s], numlevs=%d\n", i , j , tmpstr, numlevs );
  #endif
  
  setLevs( tmpstr , tmplev, &numlevs, &check );
  j=0;
  
  #ifdef DEBUG
  for(i=0;i<1024;i=i+1){
  	if( skipLevels[i] == TRUE ) printf("%d, ", i );
  }
  printf("\n");
  #endif

}



/********************************************************/
fillForm( )
{
IGRint		eof, sel, pos, ivalue, i , j, k;
IGRint		Fal , col , rownum, obj , osn , skipduetolevel;
IGRchar		buff[512], valstr[40], objstr[10], osnstr[10];
IGRdouble	dblid , value;
struct GRid	in_obj;
struct GRsymbology  symb ;   

  #ifdef DEBUG
  printf("in fill forma\n");
  #endif

  eof = FALSE;
  
  /* open the log file */
  logfile = NULL ;
  logfile = ( FILE * ) fopen( outputfilename , "r") ;
  if ( logfile == NULL) {
	printf("could not open the log file \n" ) ;
	fclose( logfile);
	exit;
  }
  
  
  #ifdef DEBUG
  printf("in fill formb\n");
  #endif
  
  FIg_reset ( STFORM, LIST );
  rownum = 0;
  col = 0;
  Fal = FALSE;
  parseSkipLevels();
 
  #ifdef DEBUG
  printf("in fill formc\n");
  #endif

  if( macroCount < MAXLISTLEN && fixid != NULL ){
  	_FREE( fixid );
  	_FREE( layer );
  	_FREE( selected );
  }
  #ifdef DEBUG
  printf("fill form1\n");
  #endif
  
  /* allocate the memory for the objid's and layer list */
  if( fixid == NULL  ){
      	fixid = _MALLOC ( MAXDISPLIST , struct GRid  );
	if( fixid == NULL ){
  		printf("couldn't allocate memory for fixid %d ids\n", MAXDISPLIST );
  		exit;
  	}
  	
  	layer = _MALLOC ( MAXDISPLIST , IGRint  );
  	if( layer == NULL ){
  		printf("couldn't allocate memory for layer %d ids\n", MAXDISPLIST );
  		exit;
  	}
  	
  	selected = _MALLOC ( MAXDISPLIST , IGRint );
  	if( selected == NULL ){
  		printf("couldn't allocate memory for selected %d ids\n", MAXDISPLIST );
  		exit;
  	}
  }

  #ifdef DEBUG
  printf("fill form2\n");
  #endif
  
  while ( !eof ){
  
  	strcpy(buff, "");
	fgets( buff , 512 , logfile );
        if ( strcmp(buff, "") == 0 ) break;
      	FIfld_set_text ( STFORM , LIST, rownum, col, buff , Fal );
      	
   	symb.level = -1;
      	in_obj.objid = -1;
      	skipduetolevel = FALSE;
      	for( i=0;i<strlen(buff)-3;i=i+1){
      		if( (buff[i+0] == 'I' || buff[i+0] == 'i' ) &&
      		    (buff[i+1] == 'D' || buff[i+1] == 'd' ) &&
      		     buff[i+2] == '['  ){
      			//grab the objid and osnum
      			k=0;
      			for( j=0; j< 10;j=j+1){
      				if( buff[j+i+3] == ',' ) break;
      				objstr[j] = buff[j+i+3];
      			}
      			objstr[j] = 0;
      			in_obj.objid = atoi( objstr );
      			
       			for( k=0; k<10;k=k+1){
      				if( buff[k+j+i+4] == ']' ) break;
      				osnstr[k] = buff[k+j+i+4];
      			}
      			osnstr[k] = 0;
      			in_obj.osnum = atoi( osnstr );
      			
      			osnstr[0] = 0;
      			objstr[0] = 0;
      			
  			#ifdef DEBUG
  			printf("read id[%d, %d]\n", in_obj.objid, in_obj.osnum);
  			#endif
  			
   			/* get the level the object is on and skip it if need be */
			gr$get_symbology( object_id = &in_obj, symb = &symb);
	
			if( symb.level > -1 ){
				#ifdef DEBUG
				printf("skipLevels[ symb.level ] = %d, symb.level=%d t=%d, f=%d\n", 
					skipLevels[ symb.level ], symb.level, TRUE, FALSE );
				#endif
					
	    			if( skipLevels[ symb.level ] == TRUE ){
					#ifdef DEBUG
					printf("skipping this object because it's on a skip level\n");
					#endif
					skipduetolevel = TRUE;
	    			}
			}
      			break;
      			
      		}
      	}
      	
     	if ( skipduetolevel == FALSE ){
	     	fixid[rownum] = in_obj;
	     	layer[rownum] = symb.level;
		selected[rownum] = -1;
      	
		#ifdef DEBUG
		printf("read id[%d, %d], string[%s,%s]\n", in_obj.objid, in_obj.osnum, objstr, osnstr);
		#endif
	
		rownum = rownum + 1;
	}

	skipduetolevel = FALSE; 

      	if ( rownum > MAXDISPLIST ){
      		sprintf( msg_str , "Only %d lines displayed, fix some and try again", MAXDISPLIST );
      		status( msg_str );
      		break;
      	}
      	
  }  
    
  fclose( logfile );
  logfile = NULL;
      
}

/**************************************************************************************/

IGRint getconfigfiles( fileName, outfile )
IGRchar *fileName;
FILE **outfile;
{
IGRint	i, msg;
IGRchar filePath[1024];
IGRchar initPath[1024];
FILE   *file;

  file = NULL;
  // Flip through paths
  i = 0;
  msg = FALSE;

  /* now check the local directory */
  file = NULL;
  file = fopen(fileName,"rt");
  if ( file ) {
      
    #ifdef DEBUG_findfiles
    printf("Setup %s\n",filePath);
    #endif
      
    *outfile = file;
    goto wrapup;
    msg=TRUE;
  }
  
 /* now check all the product paths including the sp's */
  while(1) {

    *initPath = 0;
    ex$get_path(index = i,
                path  = initPath,
                len   = sizeof(initPath),
                type  = EX_CONFIG_PATH);

    if (*initPath == 0) goto wrapup;

    sprintf(filePath,"%sconfig/%s",initPath,fileName);
    file = NULL;
    file = fopen(filePath,"rt");
    if ( file ) {
      
      #ifdef DEBUG_findfiles
      printf("Setup %s\n",filePath);
      #endif
      
      *outfile = file;
      msg=TRUE;
      goto wrapup;
    }

    i=i+1;
  }

 
  
wrapup:

return msg;

}


/**************************************************************************************/

IGRint getExceptions ()
{
IGRchar	fixFilename[256];
IGRchar	tmpStr[256];
IGRchar	tmpStr2[MAX_CHA_EXC];
IGRchar pplname[100];
IGRchar dispname[156];
FILE	*lookup;
IGRint	i,j,k,sts;
IGRchar	msg_buf[256] ;
IGRchar err_buff[512];
IGRint	eof;
//jimbo

  SetProc( getExceptions ); Begin  
  strcpy( fixFilename , DUPEXCEPTION );
  
  /* open the file for read */
  sts = getconfigfiles( fixFilename , &lookup );

  if (lookup == NULL)
  {
	sprintf (msg_buf, "FATAL: Cannot open %s File, errno=%d",
				fixFilename , errno );	
	#ifdef DEBUG_2
	printf( "%s\n" , msg_buf );
	#endif
	return (-5); //file not opened
  }
  
  num_exceptions = 0; //initialize the row counter
  eof = FALSE;
  while( !eof )  
  {
  	strcpy( tmpStr, "" );
	fgets(tmpStr, 256, lookup);
	
	eof = feof( lookup );
	
        if( num_exceptions >= MAX_EXC - 1 ){
		//#ifdef DEBUG
		printf("breaking out of read exceptions due to too many exceptions eof=%d\n", eof);
		//#endif
        	break;
        }
	
	if( tmpStr[0] == 0) {
		#ifdef DEBUG
		printf("end of data\n");
		#endif
		break;
	}else if(tmpStr[0] == '#' ){
		#ifdef DEBUG
		printf("skipping[%s] this is a comment line.\n", tmpStr);
		#endif
		continue;
	}
	
	strncpy( tmpStr2, tmpStr, MAX_CHA_EXC );
        strcpy(&buff[ num_exceptions * MAX_CHA_EXC],tmpStr2 );
        except_names[ num_exceptions ] = &buff[ num_exceptions * MAX_CHA_EXC];
        
        #ifdef DEBUG
        printf("exception[%d] = [%s]\n", num_exceptions, except_names[num_exceptions]);
        #endif
        
        num_exceptions = num_exceptions + 1;	
  }

  sts = 1;

wrapup:

  if (lookup != NULL){ fclose( lookup ); lookup = NULL;}

  End
 
}

/**************************************************************************************/

IGRint getListOfFixFiles()
{
IGRchar	fixFilename[256];
IGRchar	tmpStr[256];
IGRchar pplname[100];
IGRchar dispname[156];
FILE	*lookup;
IGRint	i,j,k,sts;
IGRchar	msg_buf[256] ;
IGRchar err_buff[512];

  SetProc( getListOfFixFiles ); Begin 

  strcpy( fixFilename , CLEANFILE );
  if(myCmdType)  strcpy( fixFilename , CLEANFILE1 );
  /* open the file for read */
  sts = getconfigfiles( fixFilename , &lookup );

  if (lookup == NULL)
  {
	sprintf (msg_buf, "FATAL: Cannot open %s File, errno=%d",
				fixFilename , errno );	
	#ifdef DEBUG_2
	printf( "%s\n" , msg_buf );
	#endif
	return (-5); //file not opened
  }
  
  FIg_reset ( STFORM, CLEANLSTM );
  
  k=0; //initialize the row counter
  
  while(1)  
  {
	fgets(tmpStr, 256, lookup);
	
	if( tmpStr[0] == 0) {
		#ifdef DEBUG
		printf("end of data\n");
		#endif
		break;
	}else if(tmpStr[0] == '#' ){
		#ifdef DEBUG
		printf("skipping[%s] this is a comment line.\n", tmpStr);
		#endif
		continue;
	}
	
	#ifdef DEBUG
	printf("%s",tmpStr );
	#endif
	
	j=0;
	
	if( isalpha( tmpStr[0])==0){
		tmpStr[0] = 0;
		continue;
	}
	
	for(i=0;i < strlen( tmpStr ) ; i=i+1){
		if( tmpStr[i] == " " && j == 0 ){
			pplname[i] = 0;
			i=i+1; //this skips the space we just found
			j=i;
		}
		
		if( j == 0 ){ 
			pplname[i] = tmpStr[i]; 
		} else {
			dispname[i-j] = tmpStr[i];
		}	
	}
	dispname[i-j] = 0;
	
	#ifdef DEBUG
	printf("pplname=%s, dispname=%s\n", pplname , dispname );
	#endif
	
	/* now add the pplname and dispname to the drop down list */
	
	FIfld_set_text ( STFORM , CLEANLSTM , k , 0 , dispname , FALSE );
	FIfld_set_text ( STFORM , CLEANLSTM , k , 1 , pplname , FALSE );
	
	k=k+1;	

	pplname[0] = 0;
	dispname[0] = 0;
	tmpStr[0] = 0;
	
  }

  sts = 1;

wrapup:

  if (lookup != NULL){ fclose( lookup ); lookup = NULL;}

  End
 
}
/********************************************************/


get_ref_list ()
{
IGRint		sts ;
IGRint		msg ;
IGRint		count ;
IGRint		i ;
IGRint		m ;
IGRint		sel;
IGRint		number ;
IGRint		array_size ;
IGRint		var_size ;
IGRint		bad_var ;
IGRlong		zero ;
IGRlong		temp ;
IGRulong	ref_prop ;
GRobj		*OBJECTS , mgr_objid ;
IGRshort	*OSNUMS;
struct GRinquire_list   list[3];
IGRchar		file_name[FI_STRLEN];
IGRchar		saved_view[FI_STRLEN];
IGRchar		filename[128];
OMuword		osnum;
struct EX_var_list ex_var[2];

   sel = FALSE;
   
   var_size = 1024;

   ex_var[0].var = 1;
   ex_var[0].var_value = &filename[0];
   ex_var[0].num_bytes = &var_size;

   ex_var[1].var = NULL;

   msg = EX_get_global( 0, &ex_var[0], &bad_var);

   refosnums[0] = 2;
   CurOsnum = 2;

   FIfld_set_list_text ( STFORM, REFFLD , 0 , 0 , filename, sel );
   FIfld_set_text ( STFORM, REFFLD , 0 , 0 , filename, FALSE );

   ci$get_module_info(md_env = &MOD_ENV);

   sts = ex$get_super (
                mod_id = MOD_ENV.md_id.objid,
                mod_osnum = MOD_ENV.md_id.osnum,
                super_name = REFERENCE_FILE_MANAGER,
                create = TRUE, super_class = "Super_rfmgr",
                super_id = &mgr_objid);

   sts = ci$send(msg = message Super_rfmgr.GRget_channel_count(
                &msg,&ref_prop, &zero, &count),
		targetid = mgr_objid,
                targetos = MOD_ENV.md_id.osnum);

   #ifdef DEBUG
   printf("sts=%d,msg=%d,count=%d\n", sts, msg, count);
   #endif

   array_size = count * sizeof(GRobjid);
   OBJECTS = NULL;
   OSNUMS = NULL;
   if( count  < 1){ count = 1; }

   OBJECTS = _MALLOC ( count , GRobj );
   if( OBJECTS == NULL ){
  	msg = FALSE;
  	goto wrapup;
   }
   
   OSNUMS = _MALLOC ( count , IGRshort );
   if( OSNUMS == NULL ){
   	msg = FALSE;
   	goto wrapup;
   }
   
   sts = ci$send(msg = message Super_rfmgr.GRget_channel_objects(
                &msg,
                &ref_prop,
                &zero,
                &array_size,
                OBJECTS,
                OSNUMS,
                &count),
                targetid = mgr_objid,
                targetos = MOD_ENV.md_id.osnum);

    #ifdef DEBUG
    printf("Super msg,msg=", sts , msg ) ;
    printf("MOD_ENV.md_id.osnum=%d\n",MOD_ENV.md_id.osnum ) ;
    #endif

            for (i=0; i < count; i=i+1)

    #ifdef DEBUG
    printf("the object ids[%d, %d]\n", OBJECTS[i] , OSNUMS[i] ) ;
    #endif

    list[0].var = REFERENCE_FILE_NAME;
    list[0].var_ptr = file_name;
    list[0].num_requested = FI_STRLEN;

    list[1].var = SAVED_VIEW_NAME;
    list[1].var_ptr = saved_view;
    list[1].num_requested = FI_STRLEN;

    list[2].var = END_PARAM;
    list[2].var_ptr = NULL;
    list[2].num_requested = NULL;

    m=0;
    #ifdef DEBUG
    printf( "number of references=%d\n", count );
    #endif
    
    for (i=0; i < count; i=i+1) {

	sts = ci$send (msg = message GRreffile.GRinquireref(
                        &msg,
                        &MOD_ENV,
                        list,
                        &temp,
                        &zero,
                        NULL),
                        targetid = OBJECTS[i],
                        targetos = OSNUMS[i]);

	sts = ci$send (msg = message GRreffile.GRgetosnum(
                        &msg,
			&osnum ),
                        targetid = OBJECTS[i],
                        targetos = OSNUMS[i]);

	#ifdef DEBUG
    	printf("filename =%s\n", list[0].var_ptr ) ;
    	printf("save view=%s\n", list[1].var_ptr ) ;
    	printf("ref osnum[%d]\n", osnum );
    	#endif
    	
	FIfld_set_list_text( STFORM, REFFLD, i+1,0, list[0].var_ptr, sel );
	refosnums[i+1] = osnum;


    }/* end of for (i=0; i < count; i=i+1)  */

wrapup:

    _FREE( OBJECTS );
    _FREE( OSNUMS );
}
/************************************************************************
this is a simplified get channel objects. the out_objs is allocated 
by this function but the caller needs to free the data after it is done.
************************************************************************/
getChannelObjects ( in_obj, channame , count, out_objs )
struct GRid	in_obj;
char		*channame;
int		*count;
struct GRid	**out_objs;
{
IGRint		msg, i, size;
IGRchar		name[ DI_PATH_MAX ];
IGRchar		objclassname[ DI_PATH_MAX ];
struct GRid	tmpObj;
int		first;
struct GRid 	*out_objst;
OM_S_OBJECT_LINKAGE     *ls_list;
OM_S_CHANSELECT 	cmp_chan;

	*count = 0 ;
	ls_list = NULL;
	
        msg = om$make_chanselect (
                channame = channame,
                p_chanselect = &cmp_chan);

        #ifdef DEBUG
        printf("om$make_chanselect msg=%d\n", msg ) ;
        #endif
		
        msg = om$get_channel_count (
                osnum           = (int)in_obj.osnum,
                objid           = in_obj.objid,
                p_chanselect    = &cmp_chan,
                count           = &size);

        
        #ifdef DEBUG
        printf("number components on %s=%d, msg=%d,  ", channame , size, msg ) ;
        #endif
        
        if( !(msg & 1)){ size = 0;} 
        
        *count = size;
        if( size == 0 ){ msg = TRUE; goto wrapup; }
        
        msg = TRUE ;
        	
    if( out_objs != NULL ){
    	
    	ls_list = _MALLOC ( size , OM_S_OBJECT_LINKAGE );
	if ( ls_list == NULL ){ 
		printf("object linkage malloc failed\n"); 
		msg = FALSE; 
		goto wrapup;
	}
	
	msg = om$get_channel_objects(
				objid           = in_obj.objid,
                                osnum           = (int)in_obj.osnum,
                                p_chanselect    = &cmp_chan,
                                list            = ls_list,
                                size            = size,
                                count           = count );
                                
        if( *count == 0 ){ msg = TRUE; goto wrapup; }
        
	out_objst = NULL;
    	out_objst = _MALLOC ( *count , struct GRid );
	if ( out_objst == NULL ){ 
		printf("Grid malloc failed\n"); 
		msg = FALSE ; 
		goto wrapup;
	}
	
	#ifdef DEBUG
	printf("found %d objects on %s channel\n",*count, channame );
	#endif
	
	for ( i = 0 ; i < *count ; i = i + 1 ) {
		out_objst[i].objid = ls_list[i].S_objid;
		out_objst[i].osnum = ls_list[i].osnum;
	}
	
	msg = TRUE;
   } 
   
   #ifdef DEBUG
   else {
   	printf("out_objs is NULL\n");
   }
   #endif
   	
wrapup:

   _FREE( ls_list );
   if( out_objs != NULL ){  *out_objs = out_objst; }
  
   return( msg );

}



/********************************************************/
IGRint	checkOwnerChannels ( tmp_obj )
struct GRid	tmp_obj;
{
IGRint	m , cnt, sts, msg;
struct GRid	*Objs;
IGRchar		objclassname[128];
struct GRid	tmpobj;

	Objs = NULL;

	/* check the children channel */
	cnt = 0;
	
	msg = getChannelObjects ( tmp_obj, "NDchildren.children" , 
				  &cnt, NULL );
	
	#ifdef DEBUG			  
	printf("id[%d,%d] children cnt=%d, msg=%d\n", 
			tmp_obj.objid, tmp_obj.osnum , cnt , msg );
	#endif
	
	if( cnt > 0 ) return TRUE;

	/* check the notification channel */
	cnt = 0;
	
	msg = getChannelObjects ( tmp_obj, "GRnotify.notification" , 
				  &cnt, NULL );
				  
	#ifdef DEBUG			  
	printf("notification cnt=%d, msg=%d\n", cnt , msg );
	#endif
			
	if( cnt > 0 ) return TRUE;

	/* check the owner channel */
	cnt = 0;
	msg = getChannelObjects ( tmp_obj, "GRconnector.to_owners" , 
				  &cnt, &Objs );
				  
	#ifdef DEBUG			  
	printf("owner cnt=%d, msg=%d, ", cnt , msg );
	#endif
			
	m = cnt ;
	for( k=0;k<m; k=k+1){
		/* check the classid of the owner */
		sts = om$get_classname(osnum = Objs[k].osnum,
				  	objid = Objs[k].objid,
				  	classname = objclassname);
				  	
		#ifdef DEBUG			  
		printf("owner[%d] classname[%s],", k , objclassname );		
		#endif
		
		if( !( sts & 1 ) ) continue ;
		
		if( om$is_ancestry_valid ( 
		    subclassname = objclassname,
		    superclassname = "LCcmd_iso") == OM_S_SUCCESS ){
			cnt = cnt - 1;	
		}
	}

	#ifdef DEBUG			  
	printf("after LCcmd check owner cnt=%d, msg=%d\n", cnt , msg );
	#endif
	
        _FREE( Objs );
	if( cnt > 0 ) return TRUE;

	return FALSE;
}

/********************************************************/
IGRint	checkOnlyOwnerChannel( tmp_obj )
struct GRid	tmp_obj;
{
IGRint	m , cnt, sts, msg;
struct GRid	*Objs;
IGRchar		objclassname[128];
struct GRid	tmpobj;

	Objs = NULL;


	/* check the owner channel */
	cnt = 0;
	msg = getChannelObjects ( tmp_obj, "GRconnector.to_owners" , 
				  &cnt, &Objs );
				  
	#ifdef DEBUG			  
	printf("owner cnt=%d, msg=%d, ", cnt , msg );
	#endif
			
	m = cnt ;
	for( k=0;k<m; k=k+1){
		/* check the classid of the owner */
		sts = om$get_classname(osnum = Objs[k].osnum,
				  	objid = Objs[k].objid,
				  	classname = objclassname);
				  	
		#ifdef DEBUG			  
		printf("owner[%d] classname[%s],", k , objclassname );		
		#endif
		
		if( !( sts & 1 ) ) continue ;
		
		if( om$is_ancestry_valid ( 
		    subclassname = objclassname,
		    superclassname = "LCcmd_iso") == OM_S_SUCCESS ){
			cnt = cnt - 1;	
		}
	}

	#ifdef DEBUG			  
	printf("after LCcmd check owner cnt=%d, msg=%d\n", cnt , msg );
	#endif
	
        _FREE( Objs );
	if( cnt > 0 ) return TRUE;

	return FALSE;
}




/********************************************************/

go ()
{

IGRint		i ;
IGRint		j ;
IGRint		n ;
IGRint		m ;
IGRint		max ;
IGRint		stat ;
IGRint		pro ;
IGRint		inc ;
IGRint		skipDupCheck ;
IGRint		skipNameCheck ;
IGRint		off1 ;
IGRint		off2 ;
IGRint		*match ;
IGRint		owncnt;
IGRint		notcnt  ;
IGRlong		namcnt ;
IGRchar		tmp_str[DI_PATH_MAX];
IGRchar		objclassname[DI_PATH_MAX];
IGRchar		product_path[ 256 ] ;
IGRdouble	percent;
struct GRid	tmp_obj ;
struct GRid	tmpobj ;
struct GRid	*Macros ;
struct GRid	*unNamed ;
struct GRid	lastid ;
struct GRmd_env	MOD_ENV ;

 
  if(myCmdType) { 
    message( cmdtitle1 );
  }
  else {
    message( cmdtitle );
  }

  row = 0 ;
  done = 0 ;
  beamcount = 0 ;
  platecount = 0 ;
  dupcount = 0;
  migcnt = 0;
  dupcnt = 0;
  owncnt = 0;
  namcnt = 0;
  n = 0 ;
  max = 0 ;
  match = NULL ;
  
  _FREE( fixid );
  _FREE( selected );
  _FREE( layer );
  
  if(CurOsnum == -1 ){
  	status("Reference file not found");
  	return;
  }
  
  
  for( i=34; i<38; i=i+1){
  	if( i==37 ) continue; // skip the hidden ownerr count
  	
	FIg_erase ( STFORM, i );
  	FIg_set_text ( STFORM, i, "0" );
	FIg_display ( STFORM, i );
  }
  
  if( migchk == FALSE && 
      namchk == FALSE &&
      dupchk == FALSE ) return;
  
  ci$get_module_info( md_env = &MOD_ENV);
  time( &time_1 ) ;
  time_3 = time_1;
  
  status("Processing...");

  #ifdef DEBUG
  printf("start time =%d\n", time_1 ) ;
  #endif

  /* start the log file */
  
  if( logfile == NULL ){
	  logfile = ( FILE * ) fopen( outputfilename , "w") ;
	  if ( logfile == NULL) {
		printf("could not open the log file \n" ) ;
		fclose( logfile);
		exit;
	  }
  }
  
  /* get and initialize the for containing the data */
  getProductData( product_path );
  
  #ifdef DEBUG
  printf("product path[%s]\n",product_path );
  #endif
  
  form_init ( product_path );
  if( form_exists != TRUE ){ 
  	printf("form not initialized, exiting\n");
  	goto wrapup;
  }
  
  FIg_disable( STFORM , MIGRATE ); 
  
  /* clear the list before starting */ 
  FIg_reset ( STFORM, LIST);
  
  /* reset the row counter for the list */
  row = 0;

  /* get the max number of objects in the object space */
  #ifdef DEBUG
  printf("about to get the max from osnum[%d]\n", CurOsnum);
  #endif
  max = OM_GA_OSDs[ CurOsnum ]->CurSpaceMapSize ;
  
  macroCount = max;
  if( max > MAXNUM ) macroCount = MAXNUM;
  skipDupCheck = FALSE ;

  /* allocate the memory for the locate list */
  fixid = NULL;
  fixid = _MALLOC ( macroCount , struct GRid  );
  if( fixid == NULL ){
  	printf("couldn't allocate memory for fixid %d ids\n", macroCount );
  	exit;
  }
  
  /* allocate the memory for the layer list */
  layer = NULL;
  layer = _MALLOC ( macroCount , IGRint  );
  if( layer == NULL ){
  	printf("couldn't allocate memory for layer %d ids\n", macroCount );
  	exit;
  }
  
  /* allocate the memory for the selected list */
  selected = NULL;
  selected = _MALLOC ( macroCount , IGRint );
  if( selected == NULL ){
  	printf("couldn't allocate memory for selected %d ids\n", macroCount );
  	exit;
  }
  
  /* initialize the fixids, selected ids and layers */
  for( i = 0 ; i < macroCount ; i=i+1 ) {
  	fixid[i].objid = -1;
  	selected[i] = -1;
  	layer[i] = -1;
  }
  
  /* allocate the memory for the macros to check */
  Macros = NULL;
  Macros = _MALLOC ( macroCount , struct GRid  );
  skipDupCheck = FALSE ;
  if( Macros == NULL ){
  	printf("couldn't allocate memory for %d GRids\n", macroCount );
  	skipDupCheck = TRUE;
  }
  
  /* allocate the memory for the unnamed ids */
  unNamed = NULL;
  unNamed = _MALLOC ( macroCount , struct GRid  );
  skipNameCheck = FALSE ;
  if( unNamed == NULL ){
  	printf("couldn't allocate memory for %d GRids\n", macroCount );
  	skipNameCheck = TRUE;
  }
  
  #ifdef DEBUG
  printf("current object space max: %d \n", max );
  #endif
  inc = 0;
  pro = max / 20;
  namcnt = 0;
  if( migchk == TRUE ) printStr( "Migrate Object List" );
  status("");

  for( i = 0 ; i < max ; i=i+1 ) {
  
  	/*set up some process display */
  	time( &time_2); 
  	percent = (double)(time_2-time_3)/60.0;	
  	if( percent > 0.05 ){
 		time_3 = time_2;
  		percent = 100.0 * ( (IGRdouble) i / (IGRdouble) max );
  		sprintf( msg_str , "Scanning file for problems, %.1f %s done." , 
  				 percent, "%" );
  		status( msg_str );
  	} 
  		
	tmp_obj.objid = i;
	tmp_obj.osnum = CurOsnum ;
	stat = om$get_classname(osnum = tmp_obj.osnum,
			  	objid = tmp_obj.objid,
			  	classname = objclassname);		
	if( !( stat & 1 ) ) continue ;

	if( om$is_ancestry_valid ( subclassname = objclassname,
		superclassname = "GRclippoly") == OM_S_SUCCESS ||
	    om$is_ancestry_valid ( subclassname = objclassname,
		superclassname = "GR3dorthpoly") == OM_S_SUCCESS ){
		
		continue;
	} else if( (om$is_ancestry_valid ( subclassname = objclassname,
		                           superclassname = "ACconst") == 
		                           OM_S_SUCCESS ||
 		    om$is_ancestry_valid ( subclassname = objclassname, 
					   superclassname = "nci_macro") == 
					   OM_S_SUCCESS ) &&
		    skipDupCheck == FALSE ){
		
		//printf("got a ACconst [%d, %d] ",tmp_obj.objid, tmp_obj.osnum );
		
		/* narrow the list to objects in :usr: partition */
		msg = checkName ( tmp_obj , objName );

		if( msg == -1){
		
			//printf("name[%s]", objName );
			msg = checkOwnerChannels( tmp_obj );
						
			if ( msg == FALSE ){
				/* add this to a list of unamed objects */
				unNamed[ namcnt ] = tmp_obj;
				namcnt = namcnt + 1;
			}

		}else if( msg == FALSE){
			//printf("msg == FALSE name[%s]\n", objName );
			continue;		
		}
			
		objtype = 2;
		dupcount = dupcount + 1;
		//check the owner channel to determine if this object should be checked
		if( checkOwnerChannels( tmp_obj ) == FALSE ){
			Macros[inc] = tmp_obj;
			inc = inc + 1;
		}
		
		numMacros = inc;
		//printf(" dupcount =%d, numMacros=%d\n", dupcount, numMacros );
		
	}else if( om$is_ancestry_valid ( subclassname = objclassname,
				superclassname = "VSbeam") == OM_S_SUCCESS ||
				om$is_ancestry_valid ( subclassname = objclassname,
				superclassname = "VSplate") == OM_S_SUCCESS){

		/* narrow the list to objects in :usr: partition */
		msg = checkName( tmp_obj , objName );
		if( msg == -1){
		
			msg = checkOwnerChannels( tmp_obj );
						
			if ( msg == FALSE ){
			    if( ignst == 0){
				/* add this to a list of unamed objects */
				//printf("plate or beam has no owners[%d]\n", tmp_obj.objid);
				unNamed[ namcnt ] = tmp_obj;
				namcnt = namcnt + 1;
			    }
			}else continue;
			
		}else if( msg == TRUE){
			
			#ifdef DEBUG			
			printf ( "Struct %s[%s], id[%d]",
				objName , objclassname , tmp_obj.objid );
			#endif
			
			if (om$is_ancestry_valid ( subclassname = objclassname,
                           	superclassname = "VSbeam") == OM_S_SUCCESS ){
				objtype = 0;
				beamcount = beamcount + 1;
			}else{
				objtype = 1;
				platecount = platecount + 1;
			}
		
			if( migchk == TRUE ) process_object ( tmp_obj );
		}
		
	}else if( om$is_ancestry_valid ( subclassname = objclassname,
		superclassname = "GRcurve") == OM_S_SUCCESS ||
		om$is_ancestry_valid ( subclassname = objclassname,
		superclassname = "EMSsurface") == OM_S_SUCCESS ||
		om$is_ancestry_valid ( subclassname = objclassname,
		superclassname = "expression") == OM_S_SUCCESS ){
		
		/* narrow the list to objects in :usr: partition */
		msg = checkName( tmp_obj , objName );
		if( msg == -1){
		
			msg = checkOwnerChannels( tmp_obj );
						
			if ( msg == FALSE ){
				/* add this to a list of unamed objects */
				unNamed[ namcnt ] = tmp_obj;
				namcnt = namcnt + 1;
			}
		}
	} else {
		__DBGpr_com(" Process Type Error ");			
		continue;
	}
	n=n+1;	
   }
   
   sprintf( msg_str , "Scanning file for problems, 100 %s done." ,"%" );
   status( msg_str );
   
   if( migchk == TRUE ) {
     	sprintf( msg_str , "%d Migrate problems" , migcnt );
   	printStr( msg_str );
   	printStr( "" );
   }

  #ifdef DEBUG
  printf("about to check the skipDupCheck\n");
  printf("dupchk=%d, namchk=%d, skipDupCheck=%d\n", dupchk, namchk, skipDupCheck );
  #endif
  
  if( skipDupCheck == FALSE && dupchk == TRUE ){

    if( inc < 2 ){
	sprintf ( msg_str , "Duplicate macro placements");
	printStr( msg_str );
	sprintf ( msg_str , "0 Duplicate macros");
	printStr( msg_str );
	printStr( "" );
   	goto namechk;
    }
    
    //if( dupchk == TRUE && inc > 1){
    if( inc > 1){

	#ifdef DEBUG
   	printf("calling VDcheckGroupOfMacros with %d macros\n");
   	#endif
   	
   	getExceptions ();
   	
   	msg = VDcheckGroupOfMacros ( Macros , MOD_ENV , &inc, &match,
   					num_exceptions, except_names);
   	
   	#ifdef DEBUG
   	printf("return from VDcheckGroupOfMacros=%d\n", msg);
   	printf("count out=%d\n", inc );
   	#endif
   	
	sprintf ( msg_str , "Duplicate macro placements");
	printStr( msg_str );

   	if( msg == FALSE ){
		sprintf ( msg_str , "Memory allocation problem, check back screen");
		printStr( msg_str );
		printStr( "" );
   		goto namechk;
   	}
   	
   	if( inc < 1  ){
		sprintf ( msg_str , "0 Duplicate macros");
		printStr( msg_str );
		printStr( "" );
   		goto namechk;
   	}
	
	lastid.objid = NULL_OBJID;
	
   	for( i = 0; i < inc; i = i + 1 ){
   		off1 = match[ i*2 ] ;
   		off2 = match[ i*2+1 ] ;
   		#ifdef DEBUG
   		printf("match[%d]=%d[%d]<->%d[%d]\n", 
   			i , 
   			off1 , 
   			Macros [ off1 ].objid ,
   			off2 , 
   			Macros [ off2 ].objid);
		#endif

		dupcnt = dupcnt + 1;
		if( lastid.objid != Macros[ off1 ].objid  ){
			lastid = Macros[ off1 ] ;
			printObj( Macros [ off1 ], "" , FALSE);
			printObj( Macros [ off2 ], "     " , FALSE) ;
		}else {
			printObj( Macros [ off2 ], "     " , FALSE);
		}

		#ifdef DEBUG			
		printf ( "Struct %s[%s], id[%d]",
			objName , objclassname , tmp_obj.objid );
		#endif
	}
	sprintf ( msg_str , "%d Duplicate macros", inc );
	printStr( msg_str );
  	
  	_FREE( match );
	printStr( "" );
    }
    
namechk:
	//dummy statement didn't have time to clean up
	sprintf ( msg_str , "%d", j );
  }

  
    if( namchk == TRUE ){
	sprintf ( msg_str , "Unnamed Objects");
	printStr( msg_str );
    	j=0;
   	for( i = 0; i < namcnt; i = i + 1 ){
		if( printObj( unNamed[ i ], "" , TRUE ) == TRUE ) j=j+1;
	}
	sprintf ( msg_str , "%d Unnamed Objects", j );
	printStr( msg_str );
	namcnt = j;
    }
 	
  printStr( "" );
  sprintf( msg_str , "Checked %d beams, %d plates, %d macros, %d errors.", 
	beamcount , platecount , dupcount , migcnt + dupcnt + namcnt );
  FIfld_set_text( STFORM, MESSAGEB, 0 , 0 , msg_str, FALSE );

  /* clear the field first */
  FIfld_set_text( STFORM, MESSAGET, 0 , 0 , "", FALSE );
  if( migcnt > 0 ) {
  	sprintf( msg_str , "Run \"Cleanup Routines\" to try to fix these errors.");
  	FIfld_set_text( STFORM, MESSAGET, 0 , 0 , msg_str, FALSE );
  }

  time( &time_2); 	
  if( (time_2-time_1)/60.0 > 2 ){
 	sprintf( msg_str , "Processing time = %.3f minutes.", (time_2-time_1)/60.0);
  } else {
	sprintf( msg_str , "Finished really fast, eh??");
  }
  
  /* display all the error */
  FIg_erase ( STFORM, MIGERR );
  FIg_erase ( STFORM, DUPERR );
  FIg_erase ( STFORM, NAMERR );
  FIg_set_text ( STFORM, MIGERR , itoa(migcnt) );
  FIg_set_text ( STFORM, DUPERR , itoa(dupcnt) );
  if( namchk == TRUE ) FIg_set_text ( STFORM, NAMERR , itoa(namcnt) );
  FIg_display ( STFORM, MIGERR );
  FIg_display ( STFORM, DUPERR );
  FIg_display ( STFORM, NAMERR );

wrapup:
  status("");
  
  _FREE( Macros );
  _FREE( unNamed );
  _FREE( match );
  fclose( logfile );
  fillForm( );
  
} 
/***********************************************************************
this function checks a structure element and a macro object to see
if there is a connection through a boobeam or booplate
***********************************************************************/
int checkForBoolean( strObj, accObj )
struct GRid	strObj, accObj;
{
struct GRid	*Objs;
struct GRid	*structObjs;
struct GRid	*pretObjs;
int	count;

	count = 0;
	Objs = NULL;
	structObjs = NULL;
	pretObjs = NULL;
	
	/* this should get the ACpretend hole */
	msg = getChannelObjects ( accObj , "NDchildren.children" , &count, &Objs );

	#ifdef DEBUG
	if( msg == TRUE ) printf( "get ChannelObjects is true\n");
	#endif
	
	if( count == 0 ) { 
		msg = TRUE; 
		#ifdef DEBUG
		printf("no children on ACconst TRUE\n"); 
		#endif
		goto wrapup; 
	}
	
	/* this should get the boolean plate or beam */
	msg = getChannelObjects ( Objs[0] , "NDchildren.children" , &count, &structObjs );
	if( count == 0 )  { 
		msg = FALSE; 
		#ifdef DEBUG
		printf("no children on ACpretend FALSE\n"); 
		#endif
		goto wrapup; 
	}
	
	/* this should get the strObj and ACpretend */
	msg = getChannelObjects ( structObjs[0] , "NDfather.father" , &count, &pretObjs );
	if( count == 0 ) { 
		msg = FALSE; 
		#ifdef DEBUG
		printf("no father on Boolean FALSE\n");
		#endif
		goto wrapup; 
	}
	
	#ifdef DEBUG
	printf("st[%d, %d], ac[%d, %d]\np0[%d, %d], p1[%d, %d]\n",
		strObj.objid, strObj.osnum,
		accObj.objid, accObj.osnum,
		pretObjs[0].objid, pretObjs[0].osnum,
		pretObjs[1].objid, pretObjs[1].osnum);
	#endif
	
	if( (pretObjs[0].objid == strObj.objid &&  
	     pretObjs[0].osnum == strObj.osnum &&
	     pretObjs[1].objid == accObj.objid &&  
	     pretObjs[1].osnum == accObj.osnum ) ||
 	    (pretObjs[1].objid == strObj.objid &&  
	     pretObjs[1].osnum == strObj.osnum &&
	     pretObjs[0].objid == accObj.objid &&  
	     pretObjs[0].osnum == accObj.osnum ) ){
	     msg = TRUE;
	 } else {msg = FALSE;}

wrapup:
	_FREE( Objs );
	_FREE( structObjs );
	_FREE( pretObjs );
	return( msg );

}


/* *******************************************************************
  the return code is the number of macros found on the children channel
*********************************************************************/

int checkForACconst ( in_obj )
struct GRid	in_obj;
{
int	msg, v, ACcount, size, macCount;
int	first;
char	name[ DI_PATH_MAX ];
char	objclassname[ DI_PATH_MAX ];
struct GRid	tmpObj;
struct GRid	*Objs;

	Objs = NULL;
	first = 0;
	macCount = 0;
	
	msg = getChannelObjects ( in_obj, "NDchildren.children" , &ACcount, &Objs );
	
	if( msg != TRUE ) goto wrapup;
	
	#ifdef DEBUG
	printf("retrieved %d children from id[%d, %d]\n", 
		ACcount, in_obj.objid, in_obj.osnum );
	#endif
	
	/* go through the children and look for ACconsts */
	
        for( v = 0 ; v < ACcount ; v = v + 1 ) {
        
		tmpObj.objid = Objs[v].objid;
		tmpObj.osnum = Objs[v].osnum;
        
		msg = om$get_classname(	osnum = tmpObj.osnum,
					objid = tmpObj.objid,
				  	classname = objclassname );
				  			
   		#ifdef DEBUG
   		printf("id[%d, %d]=%s\n", tmpObj.objid, 
   				tmpObj.osnum, objclassname );
   		#endif
   		
                if( !( msg & 1 ) ) continue ;
		if(om$is_ancestry_valid ( subclassname = objclassname ,
			superclassname = "ACconst") == OM_S_SUCCESS 	){
			
			//Check to find the ~~operator in templates
			//msg == checkForTildeOp ( tmpObj );
			//if ( msg == FALSE ) continue;
			
			msg = checkForBoolean ( in_obj, tmpObj );
			if ( msg == FALSE ) continue;
			
			macCount = macCount + 1;
			
			
			if( first == 0){
				first = 1;
				printObj( in_obj, "" , FALSE );
				migcnt = migcnt + 1;
			}
			printObj( tmpObj, "     " , FALSE );
		}
	}
	
wrapup:

	_FREE( Objs );
	return ( macCount );

}

/********************************************************** 
   this function will check if object is consumed, 
   if it is then check for ACconsts as children
************************************************************/

long process_object ( in_obj )
struct GRid		in_obj;
{
	IGRint			i, sts ;
	IGRlong			msg ;
	unsigned short		prop_mask ;

	SetProc( process_object ); Begin

	msg = MSSUCC ;
	sts = MSSUCC ;

	sts = gr$get_properties(object_id	= &in_obj, 
				properties_mask = &prop_mask);
        #ifdef DEBUG
	printf(" Properties %d\n", prop_mask );
	printf(" Properties %d\n", prop_mask );
	#endif

	if(	(! (prop_mask & GRIS_DISPLAYABLE) ) ||
		(! (prop_mask & GRIS_LOCATABLE	) )) {
		
		#ifdef DEBUG
		printf("\t[%d,%d] is non locatable or not displayed\n", 
			in_obj.objid , in_obj.osnum );
		#endif
		
		__DBGpr_obj(" Object is NON LOCATE/NON DISPLAY", in_obj );
		
		/* 
		   check for ACconsts in Children channel since this 
		   object seems to have been consumed
		*/
		
		msg = checkForACconst ( in_obj ); 
		if ( msg > 0 ) { 
			
			#ifdef DEBUG
			printf("\tERROR: %d ACconsts were found and this is a consumed obj\n", msg ); 
			#endif
			if( msg == 1 )
				sprintf( msg_str , "ERROR: 1 ACconst was found on this consumed object.", msg ); 
			else
				sprintf( msg_str , "ERROR: %d ACconsts were found on this consumed object.", msg ); 
  			printStr( msg_str );
		}
	}
 
wrapup:

	End
	return sts ;
}

	






/***************************************************************************
   Function wakeup
      Used in form control.  Is called automically by system form routines.
****************************************************************************/
wakeup ()
{
  char	cmd_name[100],
        cmd_key[20] ;

#ifdef DEBUG
  printf("in command wakeup, done=%d\n", done );
#endif
  /* 
   * This is fairly Important Stuff!
   * The process for determining from a the .tbl file what
   * the COci,x,0,....
   * value of x so that you know synonym commands in PPLs is determined this way
   * Synonym commands don't have the .t or .sl files for PPLS
   * Synonym commands are determined by fetching a ci$send ... command below!
   */
  ci$send(msg	= message ci.cmd_info(	cmd_name,
					cmd_key,
					&myCmdType,
					EX_INQ ),
	  targetid= my_id(),
	  targetos= my_os() ) ;
  
  /* printf("myCmdType[%d]\n",myCmdType); */
  
  if(myCmdType) { 
    message( cmdtitle1 );
  }
  else {
    message( cmdtitle );
  }

  if (  rerun == TRUE ){
  	FIg_reset ( STFORM, LIST);
	rerun = FALSE;
	go();
  }
#ifdef DEBUG
  printf("end of wakeup\n");
#endif
}
/******* End of wakeup ********/

/***************************************************************************
   Function sleep
      Used in form control.  Is called automically by system form routines.
****************************************************************************/
sleep ()
{
#ifdef debug
printf("in sleep\n");
#endif
}
/******* End of sleep ********/


deleteItem( InObj , row )
struct GRid 	*InObj;
IGRint		row;
{
IGRint	msg, mode;

	//printf("in deleteItem about to clean up form\n");
	fixid[row].objid = -1;
	selected[row] = -1;
	InObj->objid = -1;
	
	FIfld_set_text ( STFORM , LIST, row , 1, "" , 1 ); 
	FIfld_set_select( STFORM , LIST , row , 0 , 0);
		
	msg = nd$mod_batch( request = ND_INQ,
			    req_mode = NULL,
			    p_ret_mode = &mode);
			    
	//printf("batch msg=%d, mode=%d\n", msg , mode );
	
	msg = nd$mod_batch( request = ND_SET,
		    	req_mode = ND_IMMEDIATE,
		    	p_ret_mode = NULL);
}



/***************************************************************************
   Function delete
      Used in form control.  Is called automically by system form routines.
****************************************************************************/
delete ()
{
#ifdef DEBUG
printf("in command delete, done=%d\n", done );
#endif

    _FREE( fixid );
    _FREE( selected );
    _FREE( layer );

   if( form_exists == TRUE )
   {
      FIf_delete ( STFORM );
      form_exists = FALSE;
      form_displayed = FALSE;
   }
}
/******* End of delete ********/

SetButtons(butflag,CurOsnum, mltflag)
IGRint	butflag,CurOsnum, mltflag;
{

 	if( butflag == TRUE){
		FIg_enable( STFORM, NAVIGATE );
		FIg_enable( STFORM, EVENTOBJ );
		FIg_enable( STFORM, BROWSE );
		if( CurOsnum == 2 ){
			FIg_enable( STFORM, LEVBTN );
			FIg_enable( STFORM, DELETE );
		}
		if( mltflag > 1 ){ 
			FIg_enable( STFORM, EVENTSET );
		}else{
			FIg_disable( STFORM, EVENTSET );
		}
		
	} else {
		FIg_disable( STFORM, NAVIGATE );
		FIg_disable( STFORM, EVENTOBJ );
		FIg_disable( STFORM, EVENTSET );
		FIg_disable( STFORM, LEVBTN );
		FIg_disable( STFORM, DELETE );
		FIg_disable( STFORM, BROWSE );
	}



}

#include "grgsmacros.h"
extern GRgsinit();

Make_set ( msg, mod_env, gr_ids, num, gs_id )
    IGRint * msg;
    struct GRmd_env * mod_env;
    struct GRid * gr_ids;
    IGRint num;
    struct GRid * gs_id;
{
    IGRint stat, properties, relation, i;
    struct GRid sv_id;

    stat = OM_S_SUCCESS;
    *msg =  MSSUCC;

    gs_id->osnum = mod_env->md_id.osnum;

    stat = gr$gsinit ( 	msg = msg,
			flag = 2,
			senderid = NULL_OBJID,
  			osnum = gs_id->osnum,
			p_objid = &(gs_id->objid) );

    if ( !(stat & *msg & 1) ) goto quit;

    /*
     * Start a transition on the graphics set. This creates the
     * saved set.
     */
    properties = 0;
    stat = ci$send ( msg = message GRgrset.GSstart_transition ( 
			(IGRlong *)msg,
			mod_env,
			&properties,
			NULL,
			&sv_id ),
			targetid = gs_id->objid,
			targetos = gs_id->osnum );

    if ( !(stat & *msg & 1) ) goto quit;
    /*
     * Add all the ids to the graphics set.
     */
    for ( i=0; i<num; i=i+1 )
    {
        relation = GO_INSIDE;
        stat = ci$send ( msg = message GRgrset.GSadd ( 
        		(IGRlong *)msg,
                        &gr_ids[i],
                        &relation ),
                        targetid = sv_id.objid,
                        targetos = sv_id.osnum);

        if ( !(stat & *msg & 1) ) goto quit;
    }

    /*
     * Clean up.
     */
    stat = ci$send ( msg = message GRgrset.GSend_transition ( 
    			(IGRlong *)msg,
			NULL ),
                       targetid = gs_id->objid,
                       targetos = gs_id->osnum);

quit:

    if ( !(stat & *msg & 1) ) *msg = MSFAIL;

    return ( OM_S_SUCCESS);
}

/******************************************************************************/

form_notification ()
{

IGRint		msg ;
IGRint		j ;
IGRint		numrows ;
IGRint		sel ;
IGRint		pos ;
IGRint		sts ;
IGRint		actflag ;
IGRint		butflag ;
IGRint		mltflag ;
IGRint		chkobj ;
IGRint		actrow ;
IGRint		selchk ;
IGRint		levchk ;
IGRint		clnrow ;
IGRint		msel ;
IGRint		tolev ;
IGRushort	mask ;
IGRdouble	dblId ;
IGRdouble	value ;
struct GRid 	tmpobj ;
struct GRid 	pplgrid ;
IGRchar		filnam[256] ;
IGRchar		macname[40] ;
IGRchar		ciString[128] ;
IGRchar		esc[3] ;
IGRchar		valstr[40];
struct GRsymbology  symb ;      
struct GRid	Set;
struct GRid	*SetComps;

      #ifdef DEBUG
      printf("got a hit on the form in form_notification\n");
      #endif
      
      status("");
      
      /* get the active row */
      FIfld_get_active_row( STFORM, LIST , &actrow, &msg );
      actflag = TRUE;

      /* check to see if the active row is an object and is hilighted */
      FIfld_get_select( STFORM , LIST , actrow, 0 , &sel);
      chkobj = 0;
      if( fixid != NULL ) chkobj = fixid[actrow].objid;	
      if( sel == 0 || chkobj < 1 ){ 
	  #ifdef DEBUG
      	  printf("selected row was not hilighted row[%d], selchk[%d], changing actrow 0\n", 
      	  		actrow, selchk );
	  #endif
	  actrow = 0;
      	  actflag = FALSE;
      }

      
      FIfld_get_num_rows( STFORM, LIST, &numrows );
      
      #ifdef DEBUG
      FIfld_get_text( STFORM, LIST , actrow, 0 , 40 , macname, &msel, &msg );	
      if( fixid != NULL){
	  printf("numrows=%d, actrow=%d, id[%d], rowtxt[%s]\n", 
	      	numrows, actrow, fixid[actrow].objid, macname );
      }else{
	  printf("numrows=%d, actrow=%d, no fixid, rowtxt[%s]\n", 
	      	numrows, actrow, macname );
      }
      #endif
      
      k = 0;
      
      #ifdef DEBUG
      printf("about to loop %d times looking for a selected object\n", numrows );
      #endif
      
      if( fixid != NULL && selected != NULL && actflag == FALSE ){
        
        for( j=0; j<numrows; j=j+1){
        
		FIfld_get_select( STFORM , LIST , j , 0 , &sel);	
      		if( sel == 1 && fixid[j].objid > 0 ){ 
      			/* set this one to the active row and quit */
      			actrow = j;
      			actflag = TRUE;
			FIfld_set_active_row( STFORM , LIST , j , 0  );
			#ifdef DEBUG
			printf("found a good object[%d, %d] at %d\n", 
				fixid[j].objid, fixid[j].osnum, j );
			#endif
      			break;
      		}
	}
      }

      switch (form_st.gadget_label) {
      
        case EXIT: 
             		
	  	__DBGpr_com ("form: ACCEPT or EXIT ");
         	ci$put( response = TERMINATE );
         	break;
         	
        case EXECUTE:
        case RUN: 
             		
	  	__DBGpr_com ("form: run");
         	go();
         	break;
         	         	
        case DELETE: 
             		
	  	__DBGpr_com ("form: Delete");
	  	
	  	for(j=0; j<numrows; j=j+1){
	  	
		   FIfld_get_select( STFORM , LIST , j , 0 , &sel);
		   if( sel != 0 && fixid[j].objid > 0){
		   	#ifdef DEBUG
			printf("about to delete id[%d,%d]\n",
				fixid[j].objid, fixid[j].osnum);
			#endif
				
                	GRdisplay_object( &fixid[j] , NULL ,  GRbehe );
                	
    			sts = ci$send(msg = message GRvg.GRdelete(
    				&msg,&MOD_ENV),
                		targetid = fixid[j].objid,
                		targetos = fixid[j].osnum );
                
                	if( !( sts & msg & 1 )){

				ASmake_source_from_env( &fixid[j] , &MOD_ENV , &tmpobj );

				#ifdef DEBUG
				printf("delete failed in[%d,%d], try source[%d,%d]\n",
					fixid[j].objid , fixid[j].osnum , 
					tmpobj.objid  , tmpobj.osnum );
				#endif

    				sts = ci$send(msg = message ACcpx.NDdelete(
    					&MOD_ENV),
                			targetid = tmpobj.objid,
                			targetos = tmpobj.osnum );
                		
				if( !( sts & 1 )){

	                		printf("something went wrong in NDdelete\n");
        	        		status("delete failed");
                			GRdisplay_object( &fixid[j] , NULL ,  GRheo );
                			
                		}else{
                	 		deleteItem( &fixid[j] , j );
		   			
                		}

                	}else{
                		deleteItem( &fixid[j] , j );
               		}
                    }
                }
         	break;
         	
        case LEVBTN: 
             		
	  	__DBGpr_com ("form: MOVE");
	  	
	  	FIg_get_state( STFORM, LEVBTN, &levchk ); 
	  	FIfld_get_value ( STFORM, LEVFLD , 0 , 0 , &value , &sel, &pos);
	  	tolev = value ;
	  	
        	mask = GRIS_DISPLAYABLE | GRIS_LOCATABLE;

	  	for(j=0; j<numrows; j=j+1){
	  	
		   FIfld_get_select( STFORM , LIST , j , 0 , &sel);
		   if( sel != 0 && fixid[j].objid > 0){
			
			gr$get_symbology(  object_id = &fixid[j], symb = &symb);
		   
            		GRdisplay_object( &fixid[j] , NULL ,  GRbehe );
			
	  		if( levchk == 1 ){
				#ifdef DEBUG
				printf("moving id[%d,%d] to %d\n",
					fixid[j].objid, fixid[j].osnum, 
					tolev);
				#endif
				
				symb.level = tolev;
				gr$put_symbology( object_id = &fixid[j], symb = &symb);
        			gr$put_properties(object_id = &fixid[j], properties_mask = mask);
				
			} else {
				#ifdef DEBUG
				printf("moving id[%d,%d] back to %d\n",
					fixid[j].objid, fixid[j].osnum, 
					layer[j]);
				#endif
				
				symb.level = layer[j];
				gr$put_symbology(  object_id = &fixid[j], symb = &symb);
			}
		   
            		GRdisplay_object( &fixid[j] , NULL ,  GRbdhd );
                    }
                }
         	break;
         	
        case WRITEFILE:
             		
	  	__DBGpr_com ("form: write file");
		FIg_get_text( STFORM , FILENAME, filnam );
		if( strcmp( filnam, "" ) == 0 ){
			/* disable the write button */
			FIg_disable( STFORM, WRITEFILE );
		} else {
			FIg_enable( STFORM, WRITEFILE );
		  	saveAs( );
		}
         	break;
         	
        case FILENAME: 
             		
	  	__DBGpr_com ("form: FILENAME field");
		FIg_get_text( STFORM , FILENAME, filnam );
		if( strcmp( filnam, "" ) == 0 ){
			/* disable the write button */
			FIg_disable( STFORM , WRITEFILE );
		} else {
			FIg_enable( STFORM , WRITEFILE );
		}
         	break;
         	
        case LEVSKP : 
             		
	  	__DBGpr_com ("form: level skip field");
		FIg_get_text( STFORM , LEVSKP , skipString );
		parseSkipLevels ();
         	break;

        case BROWSE: 
             		
	  	__DBGpr_com ("form: Browse");
		ci$put(cmd="browse object");
      		ci$put(obj=fixid[actrow].objid, osnum=&fixid[actrow].osnum);
         	break;

        case SELECTALL: 
                          
	  	__DBGpr_com ("form: Select all");
	  	
	  	FIg_get_state( STFORM, SELECTALL , &selchk ); 
	  	#ifdef DEBUG
	  	printf("Selectall was hit value = %d\n", selchk );
	  	#endif
	  	
	  	if( selected != NULL ){
		   if( selchk == 1 ){
      			
      			for( j=0; j<numrows; j=j+1){
				FIfld_set_select( STFORM , LIST , j , 0 , 1);
     				selected[j] = 1;
				GRdisplay_object( &fixid[j] , NULL ,  GRhdo );
			}
			if( CurOsnum == 2 ){
				FIg_enable( STFORM, DELETE );
				FIg_enable( STFORM, LEVBTN );
			}
			
		   } else {
			
      			for( j=0; j<numrows; j=j+1){
				FIfld_set_select( STFORM , LIST , j , 0 , 0);
     				selected[j] = -1;
				GRdisplay_object( &fixid[j] , NULL ,  GRheo );
			}
			FIg_disable( STFORM, DELETE );
			FIg_disable( STFORM, LEVBTN );			
		   }
		   SetButtons(butflag,CurOsnum, mltflag);
		}
			
         	break;

        case CLEANBTN: 

	  	__DBGpr_com ("form: clean btn");
	
		sprintf( msg_str, "echo 'nothing output to %s' > %s", tmpfilename, tmpfilename );
		
		sh( msg_str );
		
		FIfld_get_num_rows(STFORM, CLEANLSTM , &numrows );
		
      		for( j=0; j<numrows; j=j+1){
			FIfld_get_select( STFORM , CLEANLSTM , j , 0 , &sel);
			if( sel == TRUE ){
				FIfld_get_text( STFORM, CLEANLSTM , j, 1 , 40 , macname, &msel, &msg );	
			}	
		}
		
		if( strcmp( macname, "" ) == 0  ){ 
		
			status("Select a clean command from the list");
		
		} else {
			status("");
			  			
			sprintf( ciString, "%s" , macname );

        		ci$load ( file_name = ciString,
                  		  load      = LOAD,
                  		  file_id   = &pplgrid.objid,
                  		  stat      = &msg );

        		if( msg != CI_S_SUCCESS )break;

       			ci$run( file_id   = &pplgrid.objid,
               			entry     = "main" );

		}
		
		fillForm();
		
		if(myCmdType) { 
			message( cmdtitle1 );
		}
		else {
			message( cmdtitle );
		}

         	break;
         	
        case REFFLD: 
      		/* get the active row */
      		FIfld_get_list_num_rows( STFORM, REFFLD, 0, &msg );
      		for( j=0;j<msg;j=j+1){
      		
      			FIfld_get_list_select ( STFORM, REFFLD, j, 0 , &sel );
      			if( sel != 0 ){
				CurOsnum = refosnums[j] ;
				#ifdef DEBUG
				printf("active osnum=%d, actrow=%d\n", CurOsnum , j );
				#endif
				break;
			}
		}
		if( CurOsnum == 2 ){
			FIg_enable( STFORM, SELECTALL );
			FIg_enable( STFORM, DELETE );
			FIg_enable( STFORM, LEVBTN );
			FIg_enable( STFORM, CLEANBTN );
			FIg_enable( STFORM, CLEANLSTM );		
		}else {
			FIg_disable( STFORM, SELECTALL );
			FIg_disable( STFORM, DELETE );
			FIg_disable( STFORM, LEVBTN );
			FIg_disable( STFORM, CLEANBTN );
			FIg_disable( STFORM, CLEANLSTM );
		}
		
         	break;
         	
        case MIGCHK: 
	  	FIg_get_value( STFORM, MIGCHK, &value ); 
		migchk = value;
         	break;
         	
        case DUPCHK: 
	  	FIg_get_value( STFORM, DUPCHK, &value ); 
		dupchk = value;
         	break;
         	
        case IGNOREST: 
	  	FIg_get_value( STFORM, IGNOREST, &value ); 
		ignst = value;
		//printf("ignore structure =%d\n", ignst );
         	break;

        case NAMCHK: 
	  	FIg_get_value( STFORM, NAMCHK, &value ); 
		namchk = value;
		if( namchk == 1 ){
			FIg_display( STFORM , IGNOREST );
			FIg_display( STFORM , LINE );
		}else{
			FIg_erase( STFORM , IGNOREST );
			FIg_erase( STFORM , LINE );
		}
         	break;
        case MIGRATE:
		rerun = TRUE;
		ci$put(cmd="migrate cutouts");
		break;
		
        case NAVIGATE:
	  	__DBGpr_com ("form: Navigate");
		ci$put(cmd="navigate");
      		ci$put(obj=fixid[actrow].objid, osnum=&fixid[actrow].osnum);
         	break;
		
        case EVENTOBJ:
      		ci$put(obj=fixid[actrow].objid, osnum=&fixid[actrow].osnum);
		break;
		
        case EVENTSET:
        	/* CREATE A SET AND EVENT IT */
	  	__DBGpr_com ("form: Event set");
	  	if( mltflag > 1 ){
	  	  SetComps = NULL;
      		  SetComps = _MALLOC ( mltflag , struct GRid  );
      		  if( SetComps != NULL ){
      		    k=0;	  	
	  	    for(j=0; j<numrows; j=j+1){
	  	
		     FIfld_get_select( STFORM , LIST , j , 0 , &sel);
		     if( sel != 0 && fixid[j].objid > 0){
		   	#ifdef DEBUG
			printf("about to add id[%d,%d] to set\n",
				fixid[j].objid, fixid[j].osnum);
			#endif
			SetComps[k] = fixid[j];
			k=k+1;
				
                      }
                    }
                    Make_set ( &msg, &MOD_ENV, SetComps, k, &Set );
      		    ci$put(obj=Set.objid, osnum=&Set.osnum);
      		    _FREE( SetComps );
      		  }else{
      		  	status( "Couldn't create set");
      		  }
                }
    
		break;
		
        case LIST:

		__DBGpr_com ("form: list ");
		break;

       }  /** switch **/
       
       mltflag = 0;
       butflag = FALSE;
       for( j=0; j<numrows; j=j+1){
      
	  /* check to see if this array has been initialized */
	  if( fixid != NULL && selected != NULL ){
	  	
      		/* erase every one in the list */
		FIfld_get_select( STFORM , LIST , j , 0 , &sel);	
      		if( selected[j] == 1 && sel == 0 ){
     			GRdisplay_object( &fixid[j] , NULL ,  GRheo );
     			selected[j] = -1;
      		}
      		
      		/* check the selected and display them */
		if( sel != 0 ){
		
			#ifdef DEBUG
			printf("row %d select=%d, id[%d, %d]\n", 
				j, sel, 
				fixid[j].objid , 
				fixid[j].osnum  );
			#endif
			
			if ( fixid[j].objid > 0 ) {
				#ifdef DEBUG
				printf("j[%d], actrow[%d], mltflag[%d]\n",
					j, actrow, mltflag);
				#endif
				
				if( actflag == FALSE && mltflag == 0 ){
					actrow = j;
					FIfld_set_active_row( STFORM , LIST , j , 0  );
				}
				
      				butflag = TRUE;
				mltflag = mltflag + 1;
				
				if ( selected[j] != 1) {
					selected[j] = 1;	
					GRdisplay_object( &fixid[j] , NULL ,  GRhdo );
				}
      			}
			k=k+1;			
		}	
            }           
	}

	SetButtons( butflag , CurOsnum , mltflag );
 
        #ifdef DEBUG
        printf("out of switch\n");
        #endif
}


/************************************************************************
   Function get_input
	Initializes default values, calls up the form and retrieves 
	information from the form.
*************************************************************************/

get_input ( inprompt )
IGRchar	inprompt[50];
{
IGRint	msg , j , numrows , sel , pos ;
IGRdouble	dblId, value;

    if(myCmdType) { 
	message( cmdtitle1 );
    }
    else {
	message( cmdtitle );
    }
    prompt( inprompt );

    /* Process the form gadgets */

    while (1)   /* loop until user cancels the form. */
    {
      /*** suspend the command file and wait for the form.   ***/

      ci$get (prompt = inprompt , response = &e);
    }
} 
/******* End of get_input ********/





/********************************************************/

main(argc, argv)
int     argc;
char    **argv;
{
IGRchar		product_path[ 256 ] ;

  /* initialize some stuff */
  migchk=FALSE;
  dupchk=FALSE;
  namchk=FALSE;
 // ownchk=FALSE;
  ignst=FALSE;
  fixid = NULL;
  selected = NULL;


  //if there is an input this will be the save filename for that session
  if( argc > 1 ){
	strcpy(	outputfilename , (char *) argv[1]);
	sprintf( msg_str , "output filename[%s]", outputfilename );
	status( msg_str );
  }else{
    
  	strcpy( outputfilename , tmpfilename );
  }
  
  
  
  if(myCmdType) { 
	message( cmdtitle1 );
  }
  else {
	message( cmdtitle );
  }

  rerun = FALSE;
  logfile = NULL ;
  /* get and initialize the for containing the data */
  getProductData ( product_path );
  
  #ifdef DEBUG
  printf("product path[%s]\n",product_path );
  #endif
  
  form_init ( product_path );
  if( form_exists != TRUE ){ 
  	#ifdef DEBUG
  	printf("form not initialized, exiting\n");
  	#endif
  	
  	status("form not found, exiting");
  	exit;
  }else {
	  form_disp(  );
  }
  
  getListOfFixFiles();

  get_ref_list();  			
  
  get_input ( "Select options" );
  
  _FREE( fixid );
  _FREE( selected );
  _FREE( layer );
}


/************************* THE END ***********************/
