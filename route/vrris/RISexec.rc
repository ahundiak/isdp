/* $Id: RISexec.rc,v 1.1.1.1 2001/01/04 21:13:06 cvs Exp $  */

/***************************************************************************
 * I/ROUTE
 *
 * File:	vrpdu/RISexec.rc
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: RISexec.rc,v $
 *	Revision 1.1.1.1  2001/01/04 21:13:06  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/30  10:52:34  pinnacle
# ROUTE 2.5.1
#
# Revision 1.1  1997/07/17  18:30:54  pinnacle
# route 2.5
#
# Revision 1.1  1996/07/25  18:25:44  pinnacle
# Creation of Route 241 project
#
# Revision 1.6  1996/04/22  16:07:14  pinnacle
# Replaced: vrris/RISexec.rc for:  by hverstee for route240
#
# Revision 1.3  1996/04/05  17:14:40  pinnacle
# Replaced: vrris/RISexec.rc for:  by ashankar for route240
#
# Revision 1.2  1996/04/05  17:10:14  pinnacle
# Replaced: vrris/RISexec.rc for:  by ashankar for route240
#
# Revision 1.1  1996/03/06  18:24:42  pinnacle
# Created: vrris/RISexec.rc by azuurhou for route240
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	06/17/91 	mman		creation date
 *	03/06/95	adz		Correction in initialization
 *					TR 179528263 ;
 ***************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include "VRDbStruct.h"
#include "VDmem.h"
#include "ris.h"

/*    declare external static switches     */

        exec sql begin declare section;
                static int first_pipcomps_one;
                static int first_pipcomcod;
                static int first_pipschthk;
                static int first_pipcomptyp;
                static int first_pipcomps_two;
                static int first_hvaccomps;
                static int first_hvaccomptyp;
                static int first_pipcodlst;

        exec sql end declare section;

/****************************************************/

RISexecute_query( ris_string, out_data, rows, cols, dat_cnt )

     char             *ris_string; /* RIS command string        */
     struct VRrisdat  out_data[];  /* output data if any        */
     int              *rows;       /* no. of rows retrieved     */
     int              *cols;       /* no. of columns            */
     int              *dat_cnt;    /* count of output structs   */
{
/*******************************************************************/
/*                                                                 */
/* This routines executes any RIS command and returns data incase  */
/* there is any output.                                            */
/*                                                                 */
/*******************************************************************/

	exec sql begin declare section;
		int     i, j;
                char    sql_stmt[700];
		char	buffer[100];
		sqlda	in_desc;
		sqlda	out_desc;
                int     count;
		char	*err_ptr;
	exec sql end declare section;

	/* define exception handlers */
	
	exec sql whenever sqlerror goto :error;
	exec sql whenever not found goto :not_found;

        /* Initialize structures */

	*rows		= 0 ;
	*dat_cnt	= 0 ;
	
	j	= 0 ;
	count	= 0 ;

	in_desc.sqld = 0;
	in_desc.sqln = 0;
	in_desc.sqlvar = 0;

	out_desc.sqld = 0;
	out_desc.sqln = 0;
	out_desc.sqlvar = 0;

        strcpy ( sql_stmt, ris_string);	
	exec sql prepare stmt1 from :sql_stmt;
	
	exec sql describe input stmt1 using descriptor in_desc;

	if (in_desc.sqld)
	{
	  in_desc.sqlvar = _MALLOC(in_desc.sqld, sqlvar );

	  for ( i = 0; i < in_desc.sqld; ++i )
	  {
	    in_desc.sqlvar[i].sqldata = 0 ;
	    in_desc.sqlvar[i].sqlind = 0 ;
	    in_desc.sqlvar[i].sqlnull = 0;
	  }

	  in_desc.sqln = in_desc.sqld;
	
	  exec sql describe input stmt1 using descriptor in_desc;

	  for( i = 0; i < in_desc.sqld; ++i)
	  {
		gets(buffer);

		in_desc.sqlvar[i].sqldata =
                        _MALLOC(in_desc.sqlvar[i].sqllen, char);
	
		if (buffer[0] == '\0')
		{
		  *in_desc.sqlvar[i].sqldata = '\0';
		  in_desc.sqlvar[i].sqlnull = 1;
		  in_desc.sqlvar[i].sqlind = _MALLOC(1, long );
		  *in_desc.sqlvar[i].sqlind = -1;
		}
		else
		{
		  in_desc.sqlvar[i].sqlnull = 0;
		  switch(in_desc.sqlvar[i].sqltype)
		  {
			case RIS_CHARACTER:
				strncpy(in_desc.sqlvar[i].sqldata, buffer,
						in_desc.sqlvar[i].sqllen);
				break;

			case RIS_SMALLINT:
				sscanf(buffer, "%hd", in_desc.sqlvar[i].sqldata);
				break;

			case RIS_INTEGER:
				sscanf(buffer, "%d", in_desc.sqlvar[i].sqldata);
				break;

			case RIS_REAL:
				sscanf(buffer, "%f", in_desc.sqlvar[i].sqldata);
				break;

			case RIS_DOUBLE:
				sscanf(buffer, "%lf", in_desc.sqlvar[i].sqldata);
				break;

			default:
				printf("Invalid data type found\n");
				exit(0);
		  }
		}
	  }
	}

	exec sql describe output stmt1 using descriptor out_desc;

	if (out_desc.sqld == 0){
	  exec sql execute stmt1 using descriptor in_desc;
	  exec sql clear stmt1;
          return 1;
	}
	
	exec sql declare curs1 cursor for stmt1;
	exec sql open curs1 using descriptor in_desc;

	out_desc.sqlvar = _MALLOC(out_desc.sqld, sqlvar );
	out_desc.sqln = out_desc.sqld;

	for ( i = 0 ; i < out_desc.sqld; ++i )
	{
	  out_desc.sqlvar[i].sqldata = 0 ;
	  out_desc.sqlvar[i].sqlind  = 0 ;
	  out_desc.sqlvar[i].sqlnull = 0;
	}
	
	exec sql describe output stmt1 using descriptor out_desc;

        *cols = out_desc.sqld;

	for ( i = 0; i < out_desc.sqld; ++i )
	{
	  out_desc.sqlvar[i].sqldata = _MALLOC(out_desc.sqlvar[i].sqllen, char);
	  out_desc.sqlvar[i].sqlind  = _MALLOC(1, long );
	  out_desc.sqlvar[i].sqlnull = 1;
	}

	for (j=0, count=0;;)
	{
	    exec sql fetch curs1 using descriptor out_desc;
	    count++;

            for (i = 0; i < out_desc.sqld; ++i)
            {

               j++;                                
               strncpy( out_data[j-1].name, out_desc.sqlvar[i].sqlname.sqlnamec, out_desc.sqlvar[i].sqlname.sqlnamel );
               out_data[j-1].name[out_desc.sqlvar[i].sqlname.sqlnamel] = 0;

               switch(out_desc.sqlvar[i].sqltype)
               {
                 case RIS_CHARACTER:
                     out_data[j-1].data.type = VR_RISDB_TEXT;
		     take_trailing_blanks_off( out_desc.sqlvar[i].sqldata, out_desc.sqlvar[i].sqllen);
/*                     strncpy(out_data[j-1].data.val.attr_c, out_desc.sqlvar[i].sqldata, out_desc.sqlvar[i].sqllen); */
                     strcpy(out_data[j-1].data.val.attr_c, out_desc.sqlvar[i].sqldata); 
                     out_data[j-1].data.val.attr_c[out_desc.sqlvar[i].sqllen] = 0;
                     break;

                 case RIS_INTEGER:
                     out_data[j-1].data.type = VR_RISDB_INT;
                     sprintf(buffer,"%d", *(int*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_int = atoi(buffer);
                     break;

                 case RIS_SMALLINT:
                     out_data[j-1].data.type = VR_RISDB_INT;
                     sprintf(buffer, "%hd", *(short*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_int = atoi(buffer);
                     break;

                 case RIS_DOUBLE:
                     out_data[j-1].data.type = VR_RISDB_DOUBLE;
                     sprintf(buffer,"%lf", *(double*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_dbl = atof(buffer);
                     break;

                 case RIS_REAL:
                     out_data[j-1].data.type = VR_RISDB_DOUBLE;
                     sprintf(buffer,"%f", *(float*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_dbl = atof(buffer);
                     break;

                 default:
                     break;
               }
	    }  
        }

not_found:

	exec sql whenever not found continue;
        exec sql close curs1;
/*        exec sql clear cursor curs1;*/
        exec sql clear stmt1;

	if( in_desc.sqlvar ){
          for(i=0; i< in_desc.sqld; i++)
          {
              _FREE(in_desc.sqlvar[i].sqldata);
              _FREE(in_desc.sqlvar[i].sqlind);          
          }
          _FREE(in_desc.sqlvar);
	}

	if( out_desc.sqlvar ){
          for(i=0; i< out_desc.sqld; i++)
          {
              _FREE(out_desc.sqlvar[i].sqldata);
              _FREE(out_desc.sqlvar[i].sqlind);          
          }
          _FREE(out_desc.sqlvar);
	}

        *rows = count;
        *dat_cnt = j;
	return 1;
	
error:
	exec sql whenever sqlerror continue;
        exec sql close curs1;
/*        exec sql clear cursor curs1; */
        exec sql clear stmt1;
	exec sql report error into :err_ptr;
        puts(err_ptr);

	if( in_desc.sqlvar ){
          for(i=0; i< in_desc.sqld; i++)
          {
              _FREE(in_desc.sqlvar[i].sqldata);
              _FREE(in_desc.sqlvar[i].sqlind);          
          }
          _FREE(in_desc.sqlvar);
	}

	if( out_desc.sqlvar )
	{
          for(i=0; i< out_desc.sqld; i++)
          {
               _FREE(out_desc.sqlvar[i].sqldata);
               _FREE(out_desc.sqlvar[i].sqlind);          
	  }
          _FREE(out_desc.sqlvar);
        }

	return 0;
}


int RISprepare_query(  ris_string, stmt_id )

     char             *ris_string; /* RIS command string        */
     int              stmt_id;
{

	exec sql begin declare section;

                char    sql_stmt[700];
		char	*err_ptr;
	exec sql end declare section;

	/* define exception handlers */
	
	exec sql whenever sqlerror goto :error;

	/* prepare a dynamic SQL statement */
       
        strcpy ( sql_stmt, ris_string);	
        switch(stmt_id)
        {
           case PIP_COMPS1_PREP_ID2:
                if(!first_pipcomps_one)
                {
                   exec sql prepare stmt2 from :sql_stmt;
                   first_pipcomps_one = 1;
                }
                break;

           case PIP_COMCOD_PREP_ID3:
                if(!first_pipcomcod)
                {
                  exec sql prepare stmt3 from :sql_stmt;
                  first_pipcomcod = 1;
                }
                break;
           case PIP_SCHTHK_PREP_ID4:
                if(!first_pipschthk)
                {
                  exec sql prepare stmt4 from :sql_stmt;
                  first_pipschthk= 1;
                }
                break;
           case PIP_COMPTYP_PREP_ID5:
                if(!first_pipcomptyp)
                {
                  exec sql prepare stmt5 from :sql_stmt;
                  first_pipcomptyp= 1;
                }
                break;
           case PIP_COMPS2_PREP_ID6:
                if(!first_pipcomps_two)
                {
                  exec sql prepare stmt6 from :sql_stmt;
                  first_pipcomps_two = 1;
                }
                break;
           case HVAC_COMPS_PREP_ID7:
                if(!first_hvaccomps)
                {
                  exec sql prepare stmt7 from :sql_stmt;
                  first_hvaccomps = 1;
                }
                break;
           case HVAC_COMPTYP_PREP_ID8:
                if(!first_hvaccomptyp)
                {
                  exec sql prepare stmt8 from :sql_stmt;
                  first_hvaccomptyp = 1;
                }
                break;
           case PIP_CODLST_PREP_ID9:
                if(!first_pipcodlst)
                {
                  exec sql prepare stmt9 from :sql_stmt;
                  first_pipcodlst= 1;
                }
                break;
           default:
                printf("RISprepare_query: Invalid statement id\n");
        }
        return 1;
	
error:
	exec sql whenever sqlerror continue;
	exec sql report error into :err_ptr;
        puts(err_ptr);
	return 0;
}

RISexecute_query1( stmt_idx,inp_buf, inp_cnt, out_data, rows, cols, dat_cnt)

     int              stmt_idx;
     char             inp_buf[10][20]; /* buffer for input data     */
     int              inp_cnt;     /* no of elements in buffer  */
     struct VRrisdat  out_data[];  /* output data if any        */
     int              *rows;       /* no. of rows retrieved     */
     int              *cols;       /* no. of columns            */
     int              *dat_cnt;    /* count of output structs   */
{
/*******************************************************************/
/*                                                                 */
/* This routines executes ONLY SELECT statements and returns data  */
/* incase there is any output.                                     */
/*                                                                 */
/*******************************************************************/

	exec sql begin declare section;
		int     i, j;
		sqlda	in_desc;
		sqlda	out_desc;
                int     count;
                char    buffer[100];
		char	*err_ptr;
	exec sql end declare section;

	/* define exception handlers */
	
	exec sql whenever sqlerror goto :error;
	exec sql whenever not found goto :not_found;

        /* Initialize structures */

	*rows		= 0 ;
	*dat_cnt	= 0 ;
	
	j	= 0 ;
	count	= 0 ;

	in_desc.sqld = 0;
	in_desc.sqln = 0;
	in_desc.sqlvar = 0;
	
	out_desc.sqld = 0;
	out_desc.sqln = 0;
	out_desc.sqlvar = 0;
	
	/* see if there are any input parameters */
	
        switch(stmt_idx)
        {
           case PIP_COMPS1_PREP_ID2:
        	exec sql describe input stmt2 using descriptor in_desc;
                break;
           case PIP_COMCOD_PREP_ID3:
                exec sql describe input stmt3 using descriptor in_desc;
                break;
           case PIP_SCHTHK_PREP_ID4:
        	exec sql describe input stmt4 using descriptor in_desc;
                break;
           case PIP_COMPTYP_PREP_ID5:
        	exec sql describe input stmt5 using descriptor in_desc;
                break;
           case PIP_COMPS2_PREP_ID6:
        	exec sql describe input stmt6 using descriptor in_desc;
                break;
           case HVAC_COMPS_PREP_ID7:
        	exec sql describe input stmt7 using descriptor in_desc;
                break;
           case HVAC_COMPTYP_PREP_ID8:
        	exec sql describe input stmt8 using descriptor in_desc;
                break;
           case PIP_CODLST_PREP_ID9:
        	exec sql describe input stmt9 using descriptor in_desc;
                break;
           default:
                printf("RISexecute_query1:Invalid statement id\n");
                break;
        }


	if (in_desc.sqld)
	{
		/* allocate input buffers for any input parameters */

		in_desc.sqlvar = _MALLOC(in_desc.sqld, sqlvar );
		in_desc.sqln = in_desc.sqld;
	        for ( j = 0; j < in_desc.sqld; j++ )
	        {
	          in_desc.sqlvar[j].sqldata = 0 ;
	          in_desc.sqlvar[j].sqlind  = 0 ;
	          in_desc.sqlvar[j].sqlnull = 0;
	        }
	
		/* get information about the input parameters */
	
                switch(stmt_idx)
                {
                   case PIP_COMPS1_PREP_ID2:
        		exec sql describe input stmt2 using descriptor in_desc;
                        break;
                   case PIP_COMCOD_PREP_ID3:
        	        exec sql describe input stmt3 using descriptor in_desc;
                        break;
                   case PIP_SCHTHK_PREP_ID4:
        		exec sql describe input stmt4 using descriptor in_desc;
                        break;
                   case PIP_COMPTYP_PREP_ID5:
        		exec sql describe input stmt5 using descriptor in_desc;
                        break;
                   case PIP_COMPS2_PREP_ID6:
        		exec sql describe input stmt6 using descriptor in_desc;
                        break;
                   case HVAC_COMPS_PREP_ID7:
        		exec sql describe input stmt7 using descriptor in_desc;
                        break;
                   case HVAC_COMPTYP_PREP_ID8:
        		exec sql describe input stmt8 using descriptor in_desc;
                        break;
                   case PIP_CODLST_PREP_ID9:
        		exec sql describe input stmt9 using descriptor in_desc;
                        break;
                   default:
                        printf("RISexecute_query1:Invalid statement id\n");
                        break;
                }


                if(inp_cnt != in_desc.sqld )
                { 
                   printf("RISexecute_query1:Invalid no of input parameters in input buffer\n");

                }

		for (i = 0; i < in_desc.sqld; ++i)
		{

		  /* set up the program address, and (optional) indicator */
		  in_desc.sqlvar[i].sqldata =
                              _MALLOC(in_desc.sqlvar[i].sqllen, char);
	
		  in_desc.sqlvar[i].sqlnull = 0;
		  switch(in_desc.sqlvar[i].sqltype)
		  {
		    case RIS_CHARACTER:
			strncpy(in_desc.sqlvar[i].sqldata, inp_buf[i],
						in_desc.sqlvar[i].sqllen);
			break;

		    case RIS_SMALLINT:
               		sscanf(inp_buf[i], "%hd", in_desc.sqlvar[i].sqldata);
			break;

		    case RIS_INTEGER:
			sscanf(inp_buf[i], "%d", in_desc.sqlvar[i].sqldata);
			break;

		    case RIS_REAL:
			sscanf(inp_buf[i], "%f", in_desc.sqlvar[i].sqldata);
			break;

		    case RIS_DOUBLE:
			sscanf(inp_buf[i], "%lf", in_desc.sqlvar[i].sqldata);
			break;

		    default:
			printf("RISexecute_query1:Invalid data type in input buffer\n");
                        break;
		  }
		}
	}

	/*
	**	if the statement is not a SELECT statement (sqld == 0),
	**		execute the statement.
	**	else
	**		declare a cursor for, open, and fetch from the statement.
	*/

	/* get the count of output */
        switch(stmt_idx)
        {
           case PIP_COMPS1_PREP_ID2:
        	exec sql describe output stmt2 using descriptor out_desc;
                break;
           case PIP_COMCOD_PREP_ID3:
        	exec sql describe output stmt3 using descriptor out_desc;
                break;
           case PIP_SCHTHK_PREP_ID4:
        	exec sql describe output stmt4 using descriptor out_desc;
                break;
           case PIP_COMPTYP_PREP_ID5:
        	exec sql describe output stmt5 using descriptor out_desc;
                break;
           case PIP_COMPS2_PREP_ID6:
        	exec sql describe output stmt6 using descriptor out_desc;
                break;
           case HVAC_COMPS_PREP_ID7:
        	exec sql describe output stmt7 using descriptor out_desc;
                break;
           case HVAC_COMPTYP_PREP_ID8:
        	exec sql describe output stmt8 using descriptor out_desc;
                break;
           case PIP_CODLST_PREP_ID9:
        	exec sql describe output stmt9 using descriptor out_desc;
                break;
           default:
                printf("RISexecute_query1:Invalid statement id\n");
                break;
        }

	/* open the SELECT statement */

        switch(stmt_idx)
        {
           case PIP_COMPS1_PREP_ID2:
   	        exec sql declare curs2 cursor for stmt2;
        	exec sql open curs2 using descriptor in_desc;
                break;
           case PIP_COMCOD_PREP_ID3:
         	exec sql declare curs3 cursor for stmt3;
         	exec sql open curs3 using descriptor in_desc;
                break;
           case PIP_SCHTHK_PREP_ID4:
	        exec sql declare curs4 cursor for stmt4;
        	exec sql open curs4 using descriptor in_desc;
                break;
           case PIP_COMPTYP_PREP_ID5:
	        exec sql declare curs5 cursor for stmt5;
         	exec sql open curs5 using descriptor in_desc;
                break;
           case PIP_COMPS2_PREP_ID6:
            	exec sql declare curs6 cursor for stmt6;
           	exec sql open curs6 using descriptor in_desc;
                break;
           case HVAC_COMPS_PREP_ID7:
            	exec sql declare curs7 cursor for stmt7;
           	exec sql open curs7 using descriptor in_desc;
                break;
           case HVAC_COMPTYP_PREP_ID8:
            	exec sql declare curs8 cursor for stmt8;
           	exec sql open curs8 using descriptor in_desc;
                break;
           case PIP_CODLST_PREP_ID9:
            	exec sql declare curs9 cursor for stmt9;
           	exec sql open curs9 using descriptor in_desc;
                break;
           default:
                printf("RISexecute_query1:Invalid statement id\n");
                break;
        }

	/*
	**	allocate a sqlvar struct for each column and call describe
	**	again to get information about each result column.
	*/

	out_desc.sqlvar = _MALLOC(out_desc.sqld, sqlvar );
	out_desc.sqln = out_desc.sqld;
	for ( i = 0; i < out_desc.sqld; ++i )
	{
	  out_desc.sqlvar[i].sqldata = 0 ;
	  out_desc.sqlvar[i].sqlind  = 0 ;
	  out_desc.sqlvar[i].sqlnull = 0;
	}

        switch(stmt_idx)
        {
           case PIP_COMPS1_PREP_ID2:
		exec sql describe output stmt2 using descriptor out_desc;
                break;
           case PIP_COMCOD_PREP_ID3:
        	exec sql describe output stmt3 using descriptor out_desc;
                break;
           case PIP_SCHTHK_PREP_ID4:
        	exec sql describe output stmt4 using descriptor out_desc;
                break;
           case PIP_COMPTYP_PREP_ID5:
        	exec sql describe output stmt5 using descriptor out_desc;
                break;
           case PIP_COMPS2_PREP_ID6:
        	exec sql describe output stmt6 using descriptor out_desc;
                break;
           case HVAC_COMPS_PREP_ID7:
        	exec sql describe output stmt7 using descriptor out_desc;
                break;
           case HVAC_COMPTYP_PREP_ID8:
        	exec sql describe output stmt8 using descriptor out_desc;
                break;
           case PIP_CODLST_PREP_ID9:
        	exec sql describe output stmt9 using descriptor out_desc;
                break;
           default:
                printf("RISexecute_query1:Invalid statement id\n");
                break;
        }

        *cols = out_desc.sqld;

	/* allocate buffers for each result column */
	for ( i = 0; i < out_desc.sqld; ++i )
	{
	  out_desc.sqlvar[i].sqldata = _MALLOC(out_desc.sqlvar[i].sqllen, char);
	  out_desc.sqlvar[i].sqlind = _MALLOC(1, long );
	  out_desc.sqlvar[i].sqlnull = 1;
	}

        count = 0;
        j = 0;
	for (;;)
	{
	    /* fetch a row of output */

             switch(stmt_idx)
             {
               case PIP_COMPS1_PREP_ID2:
            	    exec sql fetch curs2 using descriptor out_desc;        
                    break;
               case PIP_COMCOD_PREP_ID3:
        	    exec sql fetch curs3 using descriptor out_desc;        
                    break;
               case PIP_SCHTHK_PREP_ID4:
        	    exec sql fetch curs4 using descriptor out_desc;        
                    break;
               case PIP_COMPTYP_PREP_ID5:
        	    exec sql fetch curs5 using descriptor out_desc;        
                    break;
               case PIP_COMPS2_PREP_ID6:
        	    exec sql fetch curs6 using descriptor out_desc;        
                    break;
               case HVAC_COMPS_PREP_ID7:
        	    exec sql fetch curs7 using descriptor out_desc;        
                    break;
               case HVAC_COMPTYP_PREP_ID8:
        	    exec sql fetch curs8 using descriptor out_desc;        
                    break;
               case PIP_CODLST_PREP_ID9:
        	    exec sql fetch curs9 using descriptor out_desc;        
                    break;
               default:
                     printf("RISexecute_query1:Invalid statement id\n");
                     break;
             }

	     count++;

             for (i = 0; i < out_desc.sqld; ++i)
             {
	       /* Check if value is NULL */
               j++;                                
               /* Get column name  */
               strncpy( out_data[j-1].name, out_desc.sqlvar[i].sqlname.sqlnamec, out_desc.sqlvar[i].sqlname.sqlnamel );
               out_data[j-1].name[out_desc.sqlvar[i].sqlname.sqlnamel] = 0;

               switch(out_desc.sqlvar[i].sqltype)
               {
                 case RIS_CHARACTER:
                     out_data[j-1].data.type = VR_RISDB_TEXT;
		     take_trailing_blanks_off( out_desc.sqlvar[i].sqldata, out_desc.sqlvar[i].sqllen);
/*                     strncpy(out_data[j-1].data.val.attr_c, out_desc.sqlvar[i].sqldata, out_desc.sqlvar[i].sqllen); */
                     strcpy(out_data[j-1].data.val.attr_c, out_desc.sqlvar[i].sqldata); 
                     out_data[j-1].data.val.attr_c[out_desc.sqlvar[i].sqllen] = 0;
                     break;

                 case RIS_INTEGER:
                     out_data[j-1].data.type = VR_RISDB_INT;
                     sprintf(buffer,"%d", *(int*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_int = atoi(buffer);
                     break;

                 case RIS_SMALLINT:
                     out_data[j-1].data.type = VR_RISDB_INT;
                     sprintf(buffer, "%hd", *(short*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_int = atoi(buffer);
                     break;

                 case RIS_DOUBLE:
                     out_data[j-1].data.type = VR_RISDB_DOUBLE;
                     sprintf(buffer,"%lf", *(double*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_dbl = atof(buffer);
                     break;

                 case RIS_REAL:
                     out_data[j-1].data.type = VR_RISDB_DOUBLE;
                     sprintf(buffer,"%f", *(float*)out_desc.sqlvar[i].sqldata);
                     out_data[j-1].data.val.attr_dbl = atof(buffer);
                     break;

                 default:
                     break;
               }
             }  
        }
	                
not_found:

	exec sql whenever not found continue;
        switch(stmt_idx)
        {
	   case PIP_COMPS1_PREP_ID2:
			exec sql close curs2;
			break;
           case PIP_COMCOD_PREP_ID3:
			exec sql close curs3;
			break;
           case PIP_SCHTHK_PREP_ID4:
			exec sql close curs4;
			break;
           case PIP_COMPTYP_PREP_ID5:
			exec sql close curs5;
			break;
           case PIP_COMPS2_PREP_ID6:
			exec sql close curs6;
			break;
           case HVAC_COMPS_PREP_ID7:
			exec sql close curs7;
			break;
           case HVAC_COMPTYP_PREP_ID8:
			exec sql close curs8;
			break;
           case PIP_CODLST_PREP_ID9:
			exec sql close curs9;
			break;
           default:
                printf("RISexecute_query1:Invalid statement id\n");
                break;
        }

	if( in_desc.sqlvar ){
          for(i=0; i< in_desc.sqld; i++)
          {
              _FREE(in_desc.sqlvar[i].sqldata);
              _FREE(in_desc.sqlvar[i].sqlind);          
          }
          _FREE(in_desc.sqlvar);
	}

	if( out_desc.sqlvar ){
          for(i=0; i< out_desc.sqld; i++)
          {
              _FREE(out_desc.sqlvar[i].sqldata);
              _FREE(out_desc.sqlvar[i].sqlind);          
          }
          _FREE(out_desc.sqlvar);
	}

        *rows = count;
        *dat_cnt = j;
	return 1;
	
error:
	exec sql whenever sqlerror continue;
	exec sql report error into :err_ptr;
        puts(err_ptr);
        switch(stmt_idx)
        {
           case PIP_COMPS1_PREP_ID2:
			exec sql close curs2;
			break;
           case PIP_COMCOD_PREP_ID3:
			exec sql close curs3;
			break;
           case PIP_SCHTHK_PREP_ID4:
			exec sql close curs4;
			break;
           case PIP_COMPTYP_PREP_ID5:
			exec sql close curs5;
			break;
           case PIP_COMPS2_PREP_ID6:
			exec sql close curs6;
			break;
           case HVAC_COMPS_PREP_ID7:
			exec sql close curs7;
			break;
           case HVAC_COMPTYP_PREP_ID8:
			exec sql close curs8;
			break;
           case PIP_CODLST_PREP_ID9:
			exec sql close curs9;
			break;
           default:
                printf("RISexecute_query1:Invalid statement id\n");
                break;
        }

	if( in_desc.sqlvar )
	{
          for(i=0; i< in_desc.sqld; i++)
          {
              _FREE(in_desc.sqlvar[i].sqldata);
              _FREE(in_desc.sqlvar[i].sqlind);          
          }
          _FREE(in_desc.sqlvar);
	}

	if( out_desc.sqlvar )
	{
          for(i=0; i< out_desc.sqld; i++)
          {
              _FREE(out_desc.sqlvar[i].sqldata);
              _FREE(out_desc.sqlvar[i].sqlind);          
          }
          _FREE(out_desc.sqlvar);
	}

	return 0;
}


int take_trailing_blanks_off( sqlstring, sqllen)
char *sqlstring;
int  sqllen;
{
	int  i;

	i=sqllen -1;
	while( sqlstring[i] == ' ' && i != 0 )
	   sqlstring[i--] = 0;
	return 0;
}

/**************************************************************/
/*    clear cache function                                    */

void VR_DbC_ClRIS ()
{

  RIScpp_stmt_id0 = -1;
  RIScpp_stmt_id1 = -1;
  RIScpp_stmt_id2 = -1;
  RIScpp_stmt_id3 = -1;
  RIScpp_stmt_id4 = -1;
  RIScpp_stmt_id5 = -1;
  RIScpp_stmt_id6 = -1;
  RIScpp_stmt_id7 = -1;
  RIScpp_stmt_id8 = -1;

  first_pipcomps_one = 0;
  first_pipcomcod    = 0;
  first_pipschthk    = 0;
  first_pipcomptyp   = 0;
  first_pipcomps_two = 0;
  first_hvaccomps    = 0;
  first_hvaccomptyp  = 0;
  first_pipcodlst    = 0;

  return;
}


