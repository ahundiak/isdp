/* $Id: VDXcre_dgn.u,v 1.6.2.2 2003/05/27 14:00:21 ahundiak Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:	vds/vdextr/ppl/VDXcre_dgn.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: VDXcre_dgn.u,v $
 *      Revision 1.6.2.2  2003/05/27 14:00:21  ahundiak
 *      ah
 *
 *      Revision 1.6.2.1  2003/04/29 16:10:18  anand
 *      TR5982
 *
 *      Revision 1.6  2001/05/08 15:36:18  anand
 *      Undoing fix for TR 5143 per customer's request.
 *
 *      Revision 1.4  2001/02/15 01:05:15  ramarao
 *      *** empty log message ***
 *
 *      Revision 1.3  2001/02/15 00:59:44  ramarao
 *      *** empty log message ***
 *
 *      Revision 1.2  2001/01/19 21:56:03  jayadev
 *      changes in SP by andy
 *
# Revision 1.6  2000/11/27  20:05:04  pinnacle
# Replaced: vds/vdextr/ppl/VDXcre_dgn.u for:  by aharihar for Service Pack
#
# Revision 1.5  2000/09/28  21:25:18  pinnacle
# Replaced: vds/vdextr/ppl/VDXcre_dgn.u for:  by aharihar for Service Pack
#
# Revision 1.4  2000/08/08  18:28:56  pinnacle
# Replaced: vds/vdextr/ppl/VDXcre_dgn.u for:  by aharihar for Service Pack
#
# Revision 1.3  2000/08/04  15:35:42  pinnacle
# Replaced: vds/vdextr/ppl/VDXcre_dgn.u for:  by aharihar for Service Pack
#
# Revision 1.2  2000/08/03  20:15:26  pinnacle
# Replaced: vds/vdextr/ppl/VDXcre_dgn.u for:  by aharihar for Service Pack
#
# Revision 1.1  2000/05/02  21:23:10  pinnacle
# Created: vds/vdextr/ppl/VDXcre_dgn.u by apazhani for Service Pack
#
# Revision 1.7  2000/01/26  16:27:38  pinnacle
# Replaced: vdextr/ppl/VDXcre_dgn.u for:  by impd252 for vds
#
# Revision 1.6  1999/07/22  14:07:54  pinnacle
# ah
#
# Revision 1.5  1999/06/14  15:02:02  pinnacle
# Compnent reference Point
#
# Revision 1.4  1999/06/08  15:41:08  pinnacle
# ylong
#
 *
 * HISTORY:                             
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 06/08/99  ylong   Added function extract_dynapipe_attributes()
 * 06/14/99  ah      Added dp_comp_ref_pnt
 * 07/22/99  ah      Copy .drv file to .efd file
 * 05/02/00  Alwin   Corrected the way the OBJID was printed to output 
 *					 drv & htm files. TR179901490
 * 08/03/2k  Anand   CR 179901735 - Added function ExtrDynEqptNozAttr
 * 09/28/2k  Anand   CR 179902056 - Added call for attribute dp_eqpt_parent_id
 * 11/27/2k  Anand   CR jts 4093 - Added call for attribute dp_eqpt_angle_rot
 * 04/28/03  Anand   TR jts TR 5982 - Kludge for 'bend_sweep'.
 ****************************************************************************/

 
#include "VDXcre_inc.h"
#include "ACattrib.h"
#include "vd_ve.h"
#include "v_edgedef.h"
#include "v_edgemacros.h"
#include "vdparmacros.h"
#include "VDatparmacros.h"
#include "vdsetmacros.h"

/*
#define	DEBUG		1
#define	vdsDEBUG	1
*/
/* #include "VDPdef.h" */       /* Not needed */
#include "VDmem_ppl.h"
#include "vdrefmacros.h"
#include "vdtree.h"		/* Assembly Tree production table */
#include "PDMStoolspro.h"
#include "PDUerror.h"
#include "PDUdesignpro.h"
#include "PDMmacros.h"

#include "SQLerrordef.h"
#include "SQLstruct.h"
#include "SQLproto.h"

#include "MEMerrordef.h"
#include "NFMerrordef.h"
#include "MEMstruct.h"

#include "OMerrordef.h"
#include "OMminimum.h"

#include "exmacros.h"

#define   VD_PPL
#include "VDsa.h"

//#include "VDobj.h"
#include "v_dbgmacros.h"

/* defines for Postman */
#define CLIX_CONNECT    -1
#define CLIX_DISCONNECT -2

extern int EX_filename1 __((char *result, int len));  /*** BW. 3/18/94 **/
extern int PDMGetPartInfoGivenFileName ();

extern int	printf ();
extern int	*open ();
extern char	*strncpy ();
extern char	*strrchr ();
extern int	tolower ();
extern int	strncmp ();
extern int	fclose ();
extern int	close ();
extern int	IGEstop();
extern		UI_echo();
extern int	UI_status();
extern int	VDSverify_login();
extern int	check_v_geom();
extern int	GRset_conversion_type ();
extern int	GUwrite_element ();
extern int	GUget_next_ele ();
extern int	GUotype9 ();
extern int	system();

extern		VDXotype5lv1(); 
extern		GRgsmgr_fun(); 
extern		GRgs_fun(); 
extern		GRget_properties(); 
extern		GRabsg_del_all();
extern	int	VDX_ObjDataReduction();
extern		VD_ShowObj ();
extern		EX_get_oid_nodname ();


/* External function for the PME process */
extern 	int	POSTMAN_REQUEST_ON_CLIX();
extern	IGRint	VDPGetFileId();
extern 		MEMclose();
extern 		MEMbuild_array();
extern  int	SQLquert();
#define VDPOBID_LEN 25

/* jvh added for chord height tol */
#define	BSTOLCHRDHT	10
extern 		BSxtractpar();
extern int	VDXtype18();

/****  Global variables ****/

extern MYFILE	*VDXdrv_outfile, *VDXdri_outfile, *VDXdst_outfile;
MYFILE  *VDXwrl_outfile, *VDXhtm_outfile; //jvh 8/19/96
extern FILE	*VDXlog_file;

/*
 * VDS Data Reduction Routine ....
 */
extern IGRboolean VDS_gK_DoDataReduction ;

IGRchar			VDXclr_tbl_file[128];
VDXtype_totals		VDXtypes;

int VDXcount;

struct GRobj_env	*VDXobj_env;
extern struct GUcvt_bufs VDXcvt_buffers;

struct GRmd_env		VDXalt_env;
struct IGRbsp_surface	*VDXsrf_struct;
struct GRmd_env		VDXmod_env;
struct GRid		VDXobj;
struct GRsymbology	VDXsymbology;
IGRdouble		VDXscale_factor;
IGRint			VDXscale;
IGRint			VDXblock_ptr;
IGRint			VDXbyte_ptr;
long			VDXstart_time;
IGRshort		VDXwrite_mode;
IGRint			VDXele_type;
char			VDXmsg_buf[256];
IGRint			VDX_types[100];
IGRint			VDXnum_pnts[100];
IGRdouble		VDXpnts[2000];
IGRint			VDXprofile_count;
IGRchar			*VDX_geom;
IGRdouble		VDX_range[6];
short			HasAttributes;
IGRushort  		VDXproperties;
IGRshort		VDXgg[4];


IGRint			PME_CONNECT;
IGRint			PME_ERROR;  
char			server_name[25];

extern IGRlong		VDXIGDS_filedesc;
extern IGRchar		*VDXptr;
extern VDXglobals	VDXform_info ;


extern BStst_plan ();
extern int MAmulmx ();
extern int MAtypemx ();
extern int GRsymbology_options ();
extern char *malloc ();
extern free ();
//extern strtok();
extern long	PlaceCirRevOrPro();
extern int errno;
extern int EX_getpath() ;

/****************************************************************************
 *  This routine initializes all global variables.                          * 
 ****************************************************************************/

int	VDXpr_mat( comment, matrix )
IGRchar		*comment ;
IGRdouble	*matrix ;
{
	int i, j ;

#ifdef	vdsDEBUG
	for( j = 0 ; j < 4 ; j = j+1 ){
		i = j*4 ;
                printf( "\t%s: | %7.2lf, %7.2lf, %7.2lf, %7.2lf |\n",
                                comment,
                                matrix[0+i], matrix[1+i],
                                matrix[2+i], matrix[3+i] ) ;
        }
#endif
	return 1 ;
}

void VDXinit ()
{
     SetProc( VDXinit ); Begin

     VDXtypes.type_46 = 0;
     VDXtypes.type_25 = 0;
     VDXtypes.type_24 = 0;
     VDXtypes.type_23 = 0;
     VDXtypes.type_18 = 0;
     VDXtypes.type_15 = 0;
     VDXtypes.type_2 = 0;
     VDXtypes.object_count = 0;
     VDXtypes.processed = 0;

     VDXcount = 0;

     VDXhtm_outfile = NULL;
     VDXdrv_outfile = NULL;
     VDXdri_outfile = NULL; 
     VDXdst_outfile = NULL;
     VDXlog_file    = NULL;
     VDXIGDS_filedesc  = -1;
     VDXptr         = NULL;
     VDXobj_env     = NULL;
     strcpy (VDXmsg_buf, "");

     End
     return;
}


void VDXcleanup ()
{
    SetProc( VDXcleanup ); Begin

    if(VDXlog_file    != NULL)	fclose( VDXlog_file );
    if(VDXhtm_outfile != NULL)	fclose( VDXhtm_outfile );
    if(VDXdrv_outfile != NULL)	fclose( VDXdrv_outfile );
    if(VDXdri_outfile != NULL)	fclose( VDXdri_outfile );
    if(VDXdst_outfile != NULL)	fclose( VDXdst_outfile );
    VDXlog_file		= NULL;
    VDXhtm_outfile	= NULL;
    VDXdrv_outfile	= NULL;
    VDXdri_outfile	= NULL;
    VDXdst_outfile	= NULL;

    if (VDXcvt_buffers.file_des != -1)	close ((int) VDXcvt_buffers.file_des);
    if (VDXIGDS_filedesc != -1)		close ((int) VDXIGDS_filedesc);

    VDXcvt_buffers.file_des = -1;
    VDXIGDS_filedesc = -1; 

    if( VDXptr != NULL ){	free (VDXptr);		VDXptr = NULL;	}
    End
    return;
}



/****************************************************************************
 *                                                                          *
 *  Routine:   VDXcre_dgn                                                   *
 *  Date:      May 31, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This PPL is used to take an I/VDS  design file and converts it into an  *
 *  IGDS design file.  It will compress the VDS elements into their IGDS    *
 *  equivalent primitive elements.  This routine will also create attribute *
 *  linkages for all I/VDS nongraphic object attributes.                    *
 *                                                                          *
 *  This code is a superset of the initial Extract for Review cre_dgn1.u    *
 *  PPL  written by Jim Hanson.                                             *
 *                                                                          *
 ****************************************************************************/

VDXcre_dgn (mode, design_file, all_or_evgen, output_file, form)

IGRint		mode;
IGRchar		*design_file; 
IGRint		all_or_evgen;
IGRchar		*output_file; 
Form		form;
{
	IGRchar		filename[40];
	IGRlong		msg;
	IGRint		i;
	IGRlong		sts;
	IGRchar		rpt_file[256];
	IGRchar		htm_file[256];
	IGRchar		dst_file[256];
	IGRchar		dri_file[256];
	IGRchar		drv_file[256];
	IGRchar		dgn_file[256];
	FILE		*ptr;
        char		server[25];
        int		PMEstat;
	int	 	conn_status;

	// Used for final copy of drv to efd
	IGRchar cmd[512];
	IGRchar *p;
	
  SetProc( VDXcre_dgn ); Begin

  strcpy (filename, "VDXcre_dgn");
  strcpy(drv_file,"Not Yet Assigned");
  
  VDXinit ();  /** Initialize all the global variables.  **/

  ci$get_module_info (md_env = &VDXmod_env);

  VDXgen_filename (output_file, rpt_file, ".log");

  PME_CONNECT = 0 ;
  PME_ERROR   = 0 ;
  ptr 	      = NULL;
  PMEstat     = 0 ;
  conn_status = 0 ;

  /*
   * Open the log file
   */

  VDXlog_file = (FILE *) fopen (rpt_file, "w");
  if (VDXlog_file == NULL)
  {
      /**  This is not a fatal error, we just cannot create the log file **/

      strcpy (VDXmsg_buf, "WARNING: Cannot create the log file\n");
      status (VDXmsg_buf);
      if (errno ==  EEXIST) 
         sprintf (VDXmsg_buf, "<%s> file already exists", rpt_file);
      else 
         sprintf (VDXmsg_buf, "Cannot create <%s> no write permission",
                  rpt_file);
      VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
  }


  if (mode == VDX_INTERACTIVE)
  { 
	__DBGpr_com(" Interactive Processing ...  ");

	strcpy (VDXmsg_buf, " "); 
	VDXcenter_message (form, FI_MSG_FIELD, VDXmsg_buf);

	sts =  VDXpre_process (mode, all_or_evgen, form);
	if (sts != VDX_S_SUCCESS){
		VDXcleanup ();
		strcpy (VDXmsg_buf, "Fatal Pre-processing error: returning");
		VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
		exit;        
	}
  }
/*
  else{
	__DBGpr_com(" Batch Processing ...  ");

	VDXobj_env = NULL ;
 	sts = VDXloc_batch(  &msg, &VDXcount, &VDXobj_env );
	VDXptr = VDXobj_env ;
	if( !(sts & msg & 1 )){
		VDXcleanup ();
		strcpy (VDXmsg_buf, "Batch Locate Process Failed ");
		VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
		exit ;
	}
  }
*/

  if( mode == VDX_INTERACTIVE ){
      strcpy (VDXmsg_buf, "Processing...,  Please wait"); 
      VDXcenter_message (form, FI_MSG_FIELD, VDXmsg_buf);
  }

  sts = VDXopen_files(	mode, output_file, form,
                        htm_file, dst_file, dri_file, drv_file, dgn_file);
  if( sts != VDX_S_SUCCESS ){
      VDXcleanup ();
      strcpy (VDXmsg_buf, "Fatal Error opening output files: returning");
      VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
      strcat (VDXmsg_buf, "\n");
      status (VDXmsg_buf);
      exit;        
  }

/* TLS Get the server name from the command file, get its net address
       and then set the PROXY_CLIENT_ADRDRESS environment variable
*/

   *server_name = '\0' ;

   PMEstat = VDXget_servername(server);
   __DBGpr_int("PMEstat", PMEstat);
   if( strlen( server))
   {
     sprintf(server_name, "%s", server);
     __DBGpr_str("server ", server);
     __DBGpr_str("server_name ", server_name);
   }


/* TLS  Try to connect to PME to extract PME data. 
	The second argument '0', represents that we want to connect.
	Set Global Flag based on connection/not.
*/

     if(*server_name)
     {
       __DBGpr_com("Connecting to PME.........");
       PMEstat = VDXconn_status(server_name, 0, &conn_status);
       if(conn_status == 0)
       {
         PME_CONNECT = 0;
         __DBGpr_com("Connected..........");
         __DBGpr_int(" PME_CONNECT ", PME_CONNECT );
         __DBGpr_int("PMEstat", PMEstat);
       }
       else
       {
         if(conn_status == 1)
           PME_CONNECT = 1;
	  __DBGpr_int(" PME_CONNECT ", PME_CONNECT );
       }
     }
     else
     {
       PME_CONNECT = 1;
        __DBGpr_int(" PME_CONNECT ", PME_CONNECT );
     }
      
  /**  Process/translate all objects found  **/

  __DBGpr_com("before VDXprocess");
  sts = VDXprocess( mode );
  if (sts != VDX_S_SUCCESS)
  {
      VDXcleanup ();
      strcpy (VDXmsg_buf, "Fatal Error during translation: returning");
      VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
      strcat (VDXmsg_buf, "\n");
      status (VDXmsg_buf);
      exit;        
  }


  VDXclose_up_dgn ();

  if (mode == VDX_INTERACTIVE){
      sprintf( VDXmsg_buf, "File: <%s> created.", dgn_file );
      VDXcenter_message (form, FI_MSG_FIELD, VDXmsg_buf);
  }

  strcpy (VDXmsg_buf, "Successful Completion : File created\n"); 
  
  // Copy drv file to efd file
  // printf("Drv File '%s'\n",drv_file);
#if 1
  sprintf(cmd,"/bin/cp %s %s",drv_file,drv_file);
  p = strrchr(cmd,'.');
  if (p) {
    strcpy(p,".efd");
    system(cmd);
  }
#endif
  VDXreport_file_generate(	VDXstart_time,
				design_file,
				dst_file, dri_file, drv_file, dgn_file);

  fclose (VDXlog_file);

  if( mode == VDX_BATCH ){
  	VDXreport_batch(	design_file, rpt_file,
				dst_file, dri_file,
				drv_file, dgn_file);
  }

/* 
	TLS If connected to PME, disconnect now 
*/

    __DBGpr_com("Disconnecting from PME.........");
    if( PME_CONNECT == 0 )
    {
      PMEstat = VDXconn_status(server_name, 1, &conn_status);
      __DBGpr_int("conn_status ", conn_status);
      if(conn_status == 0)
      {
        __DBGpr_com("Disconnected..........");
      }
      else
      {
        __DBGpr_com("ERROR in Disconnecting..........");
      }
    }

  End 
}

IGRint isVecEq( vec1, vec2, TOL)
double	vec1[3], vec2[3], TOL;
{
	if (vec1[0] + TOL > vec2[0] &&
	    vec1[0] - TOL < vec2[0] &&
	    vec1[0] + TOL > vec2[0] &&
	    vec1[0] - TOL > vec2[0] &&
	    vec1[0] + TOL > vec2[0] &&
	    vec1[0] - TOL > vec2[0] ) return TRUE;
	else return FALSE;
}

/*************************************************************/
/* this function will search through a macro for graphics to copy */

long VDXprocess_object( in_obj, obj_env )
struct GRid		in_obj;
struct GRmd_env		obj_env;
{
	IGRint			i, sts ;
	IGRlong			msg ;
	unsigned short		prop_mask ;
	struct	VDve_elem_buf	buf ;

	SetProc( VDXprocess_object ); Begin

	msg = MSSUCC ;
	sts = VDX_S_SUCCESS ;

	sts =
	gr$get_properties(	object_id	= &in_obj, 
				properties_mask = &prop_mask);
	__DBGpr_int(" Properties ", prop_mask );
	if(	(! (prop_mask & GRIS_DISPLAYABLE) ) ||
		(! (prop_mask & GRIS_LOCATABLE	) )) {
		__DBGpr_obj(" Object is NON LOCATE/NON DISPLAY", in_obj );
		goto wrapup;
	}
 
	/* process the object attributes. */
	sts = VDXprocess_attributes( in_obj, obj_env);

        buf.count       = 0 ;
        buf.buf_siz     = 0 ;
        buf.obj_info_p  = NULL ;

        /* Get all the surfaces of the object.*/

        __DBGpr_obj(" Object ", in_obj );

        /*
         * Get the Solids, Surfaces and Wireframe objects of the
         * input object.
         */
        sts =
        vd_$select_obj_comps(   msg     = &msg,
                                option  = VD_K_gm_SURFACE|VD_K_gm_WIREFRAME,
				grIds	= &in_obj,
				theEnv	= &obj_env,
                                elmList = &buf );

        __CheckRC( sts, msg, "vd_$select_obj_comps", wrapup );

        __DBGpr_int(" NUMBER COMP", buf.count );

#ifdef  vdsDEBUG
        __DBGpr_com(" Component List : ");
        for( i=0; i<buf.count; i=i+1 ) VD_ShowObj( & buf.obj_info_p[i].obj_id );
#endif

        if( ! buf.count )       goto wrapup ;

	for( i=0 ; i<buf.count ; i=i+1 ){

	        sts =
		gr$get_properties(object_id     = &buf.obj_info_p[i].obj_id,
                                properties_mask = &prop_mask);
		__DBGpr_int(" Properties ", prop_mask );
		if( (! (prop_mask & GRIS_DISPLAYABLE) ) ||
                    (! (prop_mask & GRIS_LOCATABLE  ) )) {
                  __DBGpr_obj(" Object is NON LOCATE/NON DISPLAY", in_obj );
		  continue ;
		}

		VDXprocess_graphics(	&( buf.obj_info_p[i].obj_id ),
					&( buf.obj_info_p[i].mod_env ));
	}

	wrapup :

		if( buf.obj_info_p ) free( buf.obj_info_p  );
		End
		return sts ;
}

int VDXprocess_attributes( in_obj, obj_env )
struct GRid		in_obj;
struct GRmd_env		obj_env;
{
	IGRchar		classname[OM_K_MAXCLASS_LEN];
	IGRint		sts ;

	SetProc( VDXprocess_attributes ); Begin

	sts = om$get_classname(	objid		= in_obj.objid,
				osnum		= in_obj.osnum,
				classname	= classname );
	if( om$is_ancestry_valid(
			subclassname	= classname,
			superclassname	= "VDSroot") == OM_S_SUCCESS ){

		__DBGpr_obj(" >>>> Get Data ", in_obj );
		VDXget_coll_data (in_obj, obj_env, VDXdrv_outfile);
		VDXwrite_HTM_coll_data (in_obj, obj_env, VDXhtm_outfile);
	}

wrapup:

	End
	return status ;
}


IGRint VDXcopy_element( in_obj, in_env)
struct	GRid		*in_obj ;
struct	GRmd_env	*in_env ;
{
  int hh;
  int msg;
  long bsRC;
  IGRboolean fill_bit;
  IGRboolean world;
  IGRboolean planar;
  IGRchar name[132];
  IGRchar ele_class[20];
  IGRchar objname[128];
  IGRint numbdrys;
  IGRint sts;
  IGRshort type;
  unsigned short options;
  unsigned short *bdry_props;
  IGRdouble *bdry_range;
  IGRdouble pnt[3];
  struct GRprops geometric_props;
  struct IGRpolyline *bdry_xyz, *bdry_uv;
  struct IGRarc	arc;
  GRobjid *loopids;

  SetProc( VDXcopy_element ); Begin
  om$get_classname (objid = in_obj->objid,
		    osnum = in_obj->osnum,
		    classname = ele_class);

  __DBGpr_obj(" ElmId   ", *in_obj );
  __DBGpr_str(" CLASS   ", ele_class );
  __DBGpr_int( "MtxType ", in_env->md_env.matrix_type );
    VDXpr_mat(" Mtx     ", in_env->md_env.matrix );

  strcpy (name, itoa (VDXgg[0]));
  fill_bit = FALSE;
  world = 0;

  sts = ci$send (msg = message GRvg.GRgetprops (&msg, &VDXproperties),
	   	targetid = in_obj->objid, targetos = in_obj->osnum);

  if( !(msg&sts&1)){ goto wrapup ; }

  sts = ci$send(msg = message GRvg.GRgeomprops (
	  	&msg, &in_env->md_env.matrix_type,
		in_env->md_env.matrix, &geometric_props),
	  	targetid = in_obj->objid, targetos = in_obj->osnum);

  if( !(msg&sts&1)){ goto wrapup ; }

  sts = ci$send (msg = message GRgraphics.GRgetrang (
		&msg, &in_env->md_env.matrix_type, 
		in_env->md_env.matrix, &world, VDX_range),
	   	targetid = in_obj->objid, targetos = in_obj->osnum);

  if( !(msg&sts&1)){ goto wrapup ; }

  GRabsg_del_all();
  VDX_geom = NULL ;
  sts = ci$send (msg = message GRvg.GRgenabsg(&msg,
		&in_env->md_env.matrix_type, in_env->md_env.matrix, &VDX_geom ),
	   	targetid = in_obj->objid, targetos = in_obj->osnum );

  if( !(msg&sts&1)){ goto wrapup ; }

  if( VDX_geom == NULL )    { goto wrapup ; }

  if (om$is_ancestry_valid (subclassname = ele_class,
			    superclassname = "EMSsubbs") == OM_S_SUCCESS)
  {
      __DBGpr_com("VDXcopy_el : EMSsubbs ");

      VDXsrf_struct = (struct IGRbsp_surface *) VDX_geom;

      BStst_plan (VDXsrf_struct->u_num_poles * VDXsrf_struct->v_num_poles,
		  VDXsrf_struct->poles, VDXsrf_struct->weights, &planar, pnt, &msg);

      __DBGpr_int(" Planar ", planar );

      sts = ci$send (msg = message EMSsubbs.EMget_boundaries (
		&msg,
		&in_env->md_env.matrix_type,
		in_env->md_env.matrix,
		&VDXsrf_struct->on_off,
		&VDXsrf_struct->num_boundaries,
		&VDXsrf_struct->bdrys),
	        targetid = in_obj->objid, targetos = in_obj->osnum);

      if( !(msg&sts&1)){ goto wrapup ; }

      __DBGpr_int(" Num Bound ", VDXsrf_struct->num_boundaries );

      if (strcmp (ele_class, "EMSplane") == 0 ||
	  strcmp (ele_class, "EMAplane") == 0 ||
	  planar == 1)
      {
	  options = EMS_GETB_COMPATIBLEXYZ | EMS_GETB_COMPATIBLEUV;
	  sts = ci$send (msg = message EMSsubbs.EMssgetbdry (
			&msg, &in_env->md_env.matrix_type,
			in_env->md_env.matrix, options,
			&numbdrys, &bdry_xyz, &bdry_uv,
			&bdry_range, &bdry_props, &loopids),
		   	targetid = in_obj->objid, targetos = in_obj->osnum);

          if( !(msg&sts&1)){ goto wrapup ; }

	  __DBGpr_com(" Call VDXtype2 \n");
	  VDXtypes.type_2 = VDXtypes.type_2 + 1;

	  sts = VDXtype2 (VDX_range, bdry_xyz, numbdrys, &msg, &VDXIGDS_filedesc,
                    VDXcvt_buffers.dgn_buf,  
		   VDXcvt_buffers.ele_buf, &VDXcvt_buffers.ele_size, ele_class,
		   &VDXsymbology, &VDXproperties, VDXgg, VDXscale);

	  CheckRC( sts, 1 );

	  if (bdry_xyz)
	    {
	      for (hh = 0; hh < numbdrys; hh = hh + 1)
		{
		  MEM_FREE (bdry_xyz[hh].points);
		}
	      MEM_FREE (bdry_xyz);
	    }
	  if (bdry_uv)
	    {
	      for (hh = 0; hh < numbdrys; hh = hh + 1)
		{
		  MEM_FREE (bdry_uv[hh].points);
		}
	      MEM_FREE (bdry_uv);
	    }

	  MEM_FREE (bdry_range);
	  MEM_FREE (bdry_props);
	  MEM_FREE (loopids);
      }
      else if ((strcmp (ele_class, "EMScone") == 0 ||
		strcmp (ele_class, "EMAcone") == 0 ||
		strcmp (ele_class, "EMAcylindr") == 0 ||
		strcmp (ele_class, "EMScylindr") == 0) &&
	       VDXsrf_struct->num_boundaries == 0)
      {
	  __DBGpr_com("VDXcopy_el : cone/cylinder ");
	  __DBGpr_int("VDXcopy_el : # bnd ", VDXsrf_struct->num_boundaries );


	  sts = ci$send (msg = message EMSsurface.EMget_params ( &msg, NULL, in_env, &type, VDX_geom),
		   targetid = in_obj->objid, targetos = in_obj->osnum);

          if( !(msg&sts&1)){ goto wrapup ; }

	  __DBGpr_com(" Call VDXtype23 \n");

	  VDXtypes.type_23 = VDXtypes.type_23 + 1;

	  sts = VDXtype23 (&msg, &VDXIGDS_filedesc, VDXcvt_buffers.dgn_buf,
		VDXcvt_buffers.ele_buf, &VDXcvt_buffers.ele_size, ele_class,
		VDX_geom, VDX_range, &VDXsymbology, &VDXproperties, 
		VDXgg, VDXscale);

	  CheckRC( sts , msg );
      }
      else
      {
	  /* if the surface has no boundaries then try to create type 18 surf */
	  if (VDXsrf_struct->num_boundaries < 1)
	  {
		/* VDXeval_surf now creates the type18 surfaces */
	  	/* if it fails then create a bspline surface */

		msg = VDXeval_surf( in_obj );

		__DBGpr_int("VDXeval_surf msg  ", msg );

		CheckRC( 1, msg );
	  }
	
	  __DBGpr_com("VDXcopy_el : The REST ");
          if (msg < 1 || VDXsrf_struct->num_boundaries > 0)
	  {

	   	__DBGpr_com(" Process Type 24 ");

	   	if( VDS_gK_DoDataReduction ){

		sts = VDX_ObjDataReduction( &msg, NULL, in_obj, &VDXmod_env );

	    	if( sts & msg & 1 ){
	      		__DBGpr_com(" Continue with Reduced Data ... ");

	      		GRabsg_del_all();
	      		VDX_geom = NULL ;

	      		sts = ci$send(msg = message GRvg.GRgenabsg(&msg,
				&in_env->md_env.matrix_type, in_env->md_env.matrix, &VDX_geom ),
				targetid = in_obj->objid, targetos = in_obj->osnum);

	      		if( !(msg&sts&1)){ goto wrapup ; }
	      		if( VDX_geom == NULL ){ goto wrapup ; }

	      		VDXsrf_struct = (struct IGRbsp_surface *) VDX_geom;

	      		BStst_plan(
		  		VDXsrf_struct->u_num_poles * VDXsrf_struct->v_num_poles,
		  		VDXsrf_struct->poles,
		  		VDXsrf_struct->weights,
		  		&planar,
		  		pnt,
				&msg);

	      		__DBGpr_int(" Planar ", planar );

	      		sts = ci$send(msg = message EMSsubbs.EMget_boundaries (
				&msg,
				&in_env->md_env.matrix_type,
				in_env->md_env.matrix,
				&VDXsrf_struct->on_off,
				&VDXsrf_struct->num_boundaries,
				&VDXsrf_struct->bdrys),
		      		targetid = in_obj->objid, targetos = in_obj->osnum);

	      		if( !(msg&sts&1)){ goto wrapup ; }

	      		__DBGpr_int(" Num Bound ", VDXsrf_struct->num_boundaries );
	    	}
	   } /* Data Reduction */

	   __DBGpr_com(" Call VDXtype24 \n");

	   VDXtypes.type_24 = VDXtypes.type_24 + 1;

	   sts = VDXtype24 (&msg, &VDXIGDS_filedesc, VDXcvt_buffers.dgn_buf,
		       VDXcvt_buffers.ele_buf, &VDXcvt_buffers.ele_size, ele_class,
		       VDXsrf_struct, VDX_range, &VDXsymbology,
			&geometric_props, &VDXproperties, VDXgg, VDXscale);

	   CheckRC( sts, msg );
		
	  }
	}

  }	/* end of is object a surface */

#ifdef	NOT_NEEDED_V240

  else if (strcmp (ele_class, "GR3dpllnstr") == 0 ||
  	   strcmp (ele_class, "GR3dpolygon") == 0 ||
	   strcmp (ele_class, "GR3dorthpoly") == 0 ||
	   strcmp (ele_class, "GR3dlinestr") == 0 ||
	   strcmp (ele_class, "GR3dlineseg") == 0 ||
	   strcmp (ele_class, "GR3dpoint") == 0 ||
	   strcmp (ele_class, "GR3dorthlnst") == 0)
  {

      __DBGpr_com(" Call VDXtype46 \n");
      VDXtypes.type_46 = VDXtypes.type_46 + 1;
      sts = VDXtype46 (VDX_range, VDX_geom, &msg, &VDXIGDS_filedesc, 
			VDXcvt_buffers.dgn_buf, VDXcvt_buffers.ele_buf, 
			&VDXcvt_buffers.ele_size, ele_class, &VDXsymbology, 
			&VDXproperties, VDXgg, VDXscale);
      CheckRC( sts, 1 );

  }

#endif

  else if( strcmp (ele_class, "GR3dcircle") == 0 ||
	   strcmp (ele_class, "GR3dellipse") == 0)
  {
	/*
	 * Circle Arc will be extracted as closed circles.
	 * strcmp (ele_class, "GR3dcirarc") == 0 ||
	 */

      VDX_geom = NULL ;
      sts =
      ci$send (msg = message GRconic.GRgetarc(	
		&msg, &in_env->md_env.matrix_type,
		in_env->md_env.matrix, &arc ),
		targetid = in_obj->objid,
		targetos = in_obj->osnum);

      if( !(msg&sts&1)){ goto wrapup ; }

	__DBGpr_dbl(" prim_axis ", arc.prim_axis );
	__DBGpr_dbl(" sec_axis  ", arc.sec_axis );
	__DBGpr_vec(" origin    ", arc.origin );

      __DBGpr_com(" Call VDXtype15 \n");
      VDXtypes.type_15 = VDXtypes.type_15 + 1;

      sts = VDXtype15 (&msg, &VDXIGDS_filedesc, VDXcvt_buffers.dgn_buf,
		VDXcvt_buffers.ele_buf, &VDXcvt_buffers.ele_size, ele_class,
		&arc, VDX_range, &VDXsymbology, &VDXproperties, VDXgg,
		VDXscale);

      CheckRC( sts, msg );
  }
  else
  {
      /* Invalid Object : just log it. */
      __DBGpr_com(" Call NOTHING ... ");

      sprintf(VDXmsg_buf,  
               "\t\t\tObject Not Processed [%d,%d]",
			in_obj->objid, in_obj->osnum);
      VDXdebug (0, VDXlog_file, NULL, VDXmsg_buf); 
   }

wrapup:

   End
   return (VDX_S_SUCCESS);
}





VDXprocess_graphics( in_obj, in_env )
struct GRid		*in_obj;
struct GRmd_env		*in_env;
{
	IGRchar			classname[OM_K_MAXCLASS_LEN];
	IGRint			sts ,
				cpFlag ;
	IGRlong			msg;
	struct	GRid		cpObj ;
	IGRchar			objname[128];

	SetProc( VDXprocess_graphics ); Begin

	cpFlag	= FALSE ;

	sts = om$get_classname(	objid		= in_obj->objid,
				osnum		= in_obj->osnum,
				classname	= classname );

	sprintf(VDXmsg_buf, "\tGeom:\t[%d,%d]\tClass: %s.",
				in_obj->osnum, in_obj->objid, classname );
	VDXdebug (0, VDXlog_file, NULL, VDXmsg_buf); 

	cpObj.objid	= NULL_OBJID ;

	__DBGpr_obj(" Graphical Element ", *in_obj );

	if( om$is_ancestry_valid(
			subclassname	= classname,
			superclassname  = "EMSsubbs" ) == OM_S_SUCCESS){

		cpFlag = TRUE ;

		cpObj.objid = NULL_OBJID ;
		cpObj.osnum = VDXmod_env.md_id.osnum;


		sts = ci$send (msg = message GRvg.GRcopy( &msg,
			in_env, &VDXmod_env, &cpObj.objid),
			targetid = in_obj->objid, targetos = in_obj->osnum);

		//printf("GRvg.GRcopy msg=%d, sts=%d, id[%d, %d] cp[%d, %d]\n",msg, sts, in_obj->objid,in_obj->osnum, cpObj.objid, cpObj.osnum);

		if( !( sts & msg & 1 )){
			__DBGpr_obj(" Copy failed ", *in_obj );
			return 1 ;		
		}

		if( cpObj.objid == NULL_OBJID ){
			__DBGpr_obj(" Copy failed ", *in_obj );
			return 1 ;
		}

		__DBGpr_obj(" Copy_elem ", cpObj );

		msg = VDXcopy_element( &cpObj, &VDXmod_env);

		sts = ci$send(msg = message GRgraphics.GRdelete( &msg, &VDXmod_env),
			targetid = cpObj.objid,
			targetos = cpObj.osnum);

	}
	else{
		msg = VDXcopy_element( in_obj, in_env);
	}

wrapup:
   End
	return 1;
}

IGRint VDXcre_type18()
{
IGRboolean fill_bit;
IGRint	msg;
IGRint	sts;
IGRint	i, j, k;
IGRchar ele_class[20];
IGRint	count;

	SetProc( VDXcre_type18 ); Begin

	strcpy(ele_class,"no_class");

	fill_bit = FALSE;

	k=0;
/*
	printf("group [%d, %d, %d, %d]\n",VDXgg[0], VDXgg[1], VDXgg[2], VDXgg[3]);
	printf("VDXscale=%d\n",VDXscale);
	if( VDXprofile_count == 0 ) count = 4; else count = VDXprofile_count;
	for( i=0; i<count;i=i+1){
		printf("numpoint[%d]=%d\n",i,VDXnum_pnts[i]);
		for(j=0;j<VDXnum_pnts[i];j=j+1){
			printf("pnts[%.4f, %.4f, %.4f]\n", VDXpnts[k], VDXpnts[k+1], VDXpnts[k+2]);
			k=k+3;
		}
	}
	printf("about to create a surface num_profiles=%d\n",VDXprofile_count);
*/
	sts = VDXtype18 (&msg, 
			&VDXIGDS_filedesc, 
			VDXcvt_buffers.dgn_buf,
			VDXcvt_buffers.ele_buf, 
			&VDXcvt_buffers.ele_size,
			ele_class, 
			VDXprofile_count, 
			VDX_types, 
			VDXnum_pnts, 
			VDXpnts,
			&VDXsymbology,
			&VDXproperties, 
			&fill_bit, 
			VDXgg, 
			VDXscale, 
			VDX_range);

	CheckRC( sts, msg );
	if( !(sts & msg & 1 )){
		printf("something went wrong creating type 18\n");
		msg = FALSE;
	}
	else msg = TRUE;

	VDXtypes.type_18 = VDXtypes.type_18 + 1;

	End

	return msg;
}


/****************************************************************************
 *  This routine will open the seed3d.dgn file for read-only.               *
 *  It will first look in the local directory for "seed3d.dgn"  and if it   *
 *  does not find it, then it will look in the product directory for it.    *
 ****************************************************************************/

long VDXopen_dgn_seedfile (sfilename)  
  char *sfilename;
{
  int  i, retFlag;

  retFlag = VDX_S_SUCCESS;
  strcpy (sfilename, "seed3d.dgn");

  /**  First check in the local directory for the seedfile  **/
  VDXcvt_buffers.file_des = open (sfilename, GUREAD_ONLY);
  if (VDXcvt_buffers.file_des != -1) goto wrapup;

  // Loop and check each config directory	
  for( i = 0;  ; i = i + 1 ) {
    *sfilename = 0;
    ex$get_path(index = i,
		path  = sfilename,
		len   = 256);

    if (*sfilename == 0) {
      printf("seed file not found\n");
      retFlag = VDX_E_FileNoEx;
      goto wrapup;
    }
    strcat(sfilename,"config/seed3d.dgn");

    VDXcvt_buffers.file_des = open (sfilename, GUREAD_ONLY);
    if (VDXcvt_buffers.file_des != -1) goto wrapup;
  }

wrapup:
  return retFlag;
}


long VDXopen_files (mode, design_file, form,
                    htm_file, dst_file, dri_file, drv_file, dgn_file)
   int  mode;
   char *design_file;
   Form form; 
   char *htm_file;     /*  O */
   char *dst_file;     /*  O */
   char *dri_file;     /*  O */
   char *drv_file;     /*  O */
   char *dgn_file;     /*  O */
{

  char sfilename[256];
  char htm_filename[256];
  char drv_filename[256];
  char dri_filename[256];
  char dgn_filename[256];
  char dst_filename[256];
  IGRlong sts;
  char filename[40];
  
  strcpy (filename, "VDXopen_files");
  __DBGpr_com ("ENTER VDXopen_files");

  /**  get the seedfile  **/

  sts = VDXopen_dgn_seedfile (sfilename);  
  if (sts != VDX_S_SUCCESS)
     return (sts);

  VDXcvt_buffers.ele_type = -1;

  GRset_conversion_type (GRIGDS);

  sts = VDXgen_filename (design_file, VDXclr_tbl_file, ".tbl"); 
  if (sts != VDX_S_SUCCESS)
     return (sts);

  sts = VDXgen_filename (design_file, dgn_filename, ".dgn"); 
  if (sts != VDX_S_SUCCESS)
     return (sts);
  strcpy (dgn_file, dgn_filename); 

  sts = VDXgen_filename (design_file, dri_filename, ".dri"); 
  if (sts != VDX_S_SUCCESS)
     return (sts);
  strcpy (dri_file, dri_filename); 

  sts = VDXgen_filename (design_file, drv_filename, ".drv"); 
  if (sts != VDX_S_SUCCESS)
     return (sts);
  strcpy (drv_file, drv_filename); 

  sts = VDXgen_filename (design_file, htm_filename, ".htm");
  if (sts != VDX_S_SUCCESS) return (sts);
  strcpy (htm_file, htm_filename);

  sts = VDXgen_filename (design_file, dst_filename, ".dst"); 
  if (sts != VDX_S_SUCCESS)
     return (sts);
  strcpy (dst_file, dst_filename); 

  __DBGpr_str(" dgn_filename ", dgn_filename );
  __DBGpr_str(" dri_filename ", dri_filename );
  __DBGpr_str(" drv_filename ", drv_filename );
  __DBGpr_str(" dst_filename ", dst_filename );

  sts = VDXwrite_dst (dst_filename);
  if (sts != VDX_S_SUCCESS)
     return (sts);

  sts = VDXwrite_rpt_heading (VDXlog_file);
  if (sts != VDX_S_SUCCESS)
   {
      /**  This is not a fatal error, we just cannot write the report
	   heading to the log file.                                     **/

      write ("WARNING: Cannot write the report heading to the log file");
      write ("\n");
   }

  sts = VDXwrite_htm (htm_filename, design_file);
  if (sts != VDX_S_SUCCESS) return (sts);

  sts = VDXwrite_dri (dri_filename, dgn_filename, drv_filename);
  if (sts != VDX_S_SUCCESS)
     return (sts);

  sts = VDXinit_drv_file (drv_filename);
  if (sts != VDX_S_SUCCESS)
     return (sts);

  sts = VDXinit_dgn_file (dgn_filename);
  if (sts != VDX_S_SUCCESS)
     return (sts);

   return (VDX_S_SUCCESS);
}



int VDXclose_up_dgn ()
{

  IGRint msg, stat;
  IGRlong num_bytes_read;

  SetProc( ENTER VDXclose_up_dgn ); Begin

  num_bytes_read = 2;
  VDXcvt_buffers.ele_buf[0] = 0xFF;
  VDXcvt_buffers.ele_buf[1] = 0xFF;
  VDXcvt_buffers.ele_type = -1;

  stat = GUwrite_element (&msg, VDXcvt_buffers.dgn_buf,
			  VDXcvt_buffers.ele_buf,
			  VDXcvt_buffers.ele_type,
			  &num_bytes_read, &VDXIGDS_filedesc,
			  &VDXwrite_mode, &VDXblock_ptr,
			  &VDXbyte_ptr);


  VDXwrite_mode = GUFLUSH;
  stat = GUwrite_element (&msg, VDXcvt_buffers.dgn_buf,
			  VDXcvt_buffers.ele_buf,
			  VDXcvt_buffers.ele_type,
			  &num_bytes_read, &VDXIGDS_filedesc,
			  &VDXwrite_mode, &VDXblock_ptr,
			  &VDXbyte_ptr);

  //*  Increase the size of the IGDS design file.

  VDXwrite_mode = GUINCREASE;
  VDXcvt_buffers.ele_size = 10;
  stat = GUwrite_element (&msg, VDXcvt_buffers.dgn_buf,
			  VDXcvt_buffers.ele_buf,
			  VDXcvt_buffers.ele_type,
			  &VDXcvt_buffers.ele_size,
			  &VDXIGDS_filedesc,
			  &VDXwrite_mode, &VDXblock_ptr,
			  &VDXbyte_ptr);

  /***  BW. 4/8/94  Guarantee that all the files are being closed before
        cre_dgn1 is exited.                                              ***/

  fclose (VDXdrv_outfile);
  VDXdrv_outfile = NULL;
  close ((int) VDXcvt_buffers.file_des);
  VDXcvt_buffers.file_des = -1; 
  close ((int) VDXIGDS_filedesc);
  VDXIGDS_filedesc = -1; 
  fclose (VDXdri_outfile);
  VDXdri_outfile = NULL;
  fclose (VDXdst_outfile);
  VDXdst_outfile = NULL;

/*****
 fprintf (VDXlog_file, "Exiting VDXclose_up_dgn\n");
*****/

  End
  return (0); 
}


delete ()
{

  /*  close the seed file and the new IGDS file */

  if (VDXdrv_outfile != NULL)
     fclose (VDXdrv_outfile);
  VDXdrv_outfile = NULL;

  if (VDXcvt_buffers.file_des != NULL)
      close ((int) VDXcvt_buffers.file_des);
  VDXcvt_buffers.file_des = -1; 
  if (VDXIGDS_filedesc != NULL)
      close ((int) VDXIGDS_filedesc);
  VDXIGDS_filedesc = -1; 

}


int VDXeval_surf (in_obj) 
struct GRid *in_obj;
{
  /*****   int ord, m, k, cc;   ******/
  int m, k, n, xx, sts;
  IGRdouble uval[200];
  double rad1, rad2, matrix[16], cen1[3], cen2[3], sweep;
  IGRint msg;
  IGRint	chkcount, i, types[50];
  IGRdouble	params[50];
  struct GRid	tmpObj;
  IGRboolean	isarc;
  IGRdouble	TOL;
  IGRboolean fill_bit;
   char		objname[128];

#ifdef DEBUG
  int ord;
#endif

  SetProc (VDXeval_surf ); Begin

#ifdef DEBUG
  write ("in_obj=", in_obj->objid, ',', in_obj->osnum, '\n');
  ord = VDXsrf_struct->u_order;
  write ("u_order=", ord, '\n');
  ord = VDXsrf_struct->v_order;
  write ("v_order=", ord, '\n');
  ord = VDXsrf_struct->u_non_uniform;
  write ("u_uniform=", ord, '\n');
  ord = VDXsrf_struct->v_non_uniform;
  write ("v_uniform=", ord, '\n');
#endif

  if (VDXsrf_struct->u_order > 3 || VDXsrf_struct->v_order > 3)
    return (-1);
  if (VDXsrf_struct->u_num_poles > 100 || VDXsrf_struct->v_num_poles > 1000)
    return (-1);

  VDXprofile_count = 0;
  isarc = FALSE;
  BSxtractpar( &msg, BSTOLCHRDHT, &TOL);


  if (VDXsrf_struct->u_order < 3)
  {
      __DBGpr_com ("get profile linestr");

      VDXnum_pnts[0] = VDXsrf_struct->u_num_poles;
      VDXnum_pnts[1] = VDXsrf_struct->u_num_poles;
      VDX_types[0] = 0;
      VDX_types[1] = 0;

      for (m = 0; m < VDXsrf_struct->u_num_poles * 3; m = m + 1) VDXpnts[m] = VDXsrf_struct->poles[m];

      for (m = VDXsrf_struct->u_num_poles * 3;
	   m < VDXsrf_struct->u_num_poles * 6;
	   m = m + 1)
	{
	  VDXpnts[m] = VDXsrf_struct->poles[VDXsrf_struct->u_num_poles * 
					   (VDXsrf_struct->v_num_poles - 2) * 3 + m];
	}

      m = (6 * VDXsrf_struct->u_num_poles);

  }
  else
  {
      __DBGpr_com ("get profile arc");

      VDXnum_pnts[0] = 4;
      VDXnum_pnts[1] = 4;
      VDX_types[0] = 1;
      VDX_types[1] = 1;

      for( i=0; i<4; i=i+1){

	uval[i*2] = i*(1.0/3.0);
	uval[i*2+1] = 0.0;
	uval[i*2+8] = i*(1.0/3.0);
	uval[i*2+9] = 1.0;
      }
      uval[16] = 0.7; uval[17] = 0;
      uval[18] = 0.7; uval[19] = 1;
      
      ci$send (msg = message GRvg.EMptatpr (
			  &msg, &VDXmod_env.md_env.matrix_type,
			     VDXmod_env.md_env.matrix, uval, 20, VDXpnts),
	       targetid = in_obj->objid,
	       targetos = in_obj->osnum);
      m = 24;

      __DBGpr_com (" call VDXradius1 #0" );
      msg = VDXradius1 (&VDXpnts[0], &VDXpnts[3], &VDXpnts[6], &VDXpnts[24],
		     &rad1, cen1, matrix, &sweep);
      __DBGpr_int (" VDXradius1 #0 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_com (" call VDXradius1 #1" );
      msg = VDXradius1 (&VDXpnts[0], &VDXpnts[3], &VDXpnts[6], &VDXpnts[9],
		     &rad1, cen1, matrix, &sweep);
      __DBGpr_int (" VDXradius1 #1 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_com (" call VDXradius1 #2" );
      msg = VDXradius1 (&VDXpnts[12], &VDXpnts[15], &VDXpnts[18], &VDXpnts[27],
		     &rad2, cen2, matrix, &sweep);
      __DBGpr_int (" VDXradius1 #2 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_com (" call VDXradius1 #3" );
      msg = VDXradius1 (&VDXpnts[12], &VDXpnts[15], &VDXpnts[18], &VDXpnts[21],
		     &rad2, cen2, matrix, &sweep);
      __DBGpr_int (" VDXradius1 #3 ", msg );
      if (msg < 0) return (-1);

      isarc = TRUE; /* a flag for next check */

      __DBGpr_dbl("profile rad1 ", rad1 );
      __DBGpr_dbl("profile rad2 ", rad2 );
      __DBGpr_vec("center #1 ", cen1 );
      __DBGpr_vec("center #2 ", cen2 );
  }

/*
   Get the v set of data
 */
  tmpObj.objid = in_obj->objid; tmpObj.osnum = in_obj->osnum;

  if (VDXsrf_struct->v_order < 3)
  {
        __DBGpr_com (" get rule linestring");

	/*  just get all the profiles along the linestring */

	for(k=0;k<VDXsrf_struct->v_num_poles;k=k+1)
	{
      		if ( VDXsrf_struct->u_order == 2){
			VDXnum_pnts[k] = VDXsrf_struct->u_num_poles;
	      		VDX_types[k] = 0;  /* linear object */
		}else{
			VDXnum_pnts[k] = 4;	
			VDX_types[k] = 1;  /* arc object */
		}
	}
	VDX_types[k] = 1; /*surface of projection */
	VDXprofile_count = k;
	m=0;

	/* get all the profiles */
	if ( VDXsrf_struct->u_order == 2)
	{
		for(k=0;k<VDXsrf_struct->v_num_poles*VDXsrf_struct->u_num_poles*3;k=k+1)
		{	
			  VDXpnts[k] = VDXsrf_struct->poles[k];
		}
		msg = VDXcre_type18();
		//VDXtypes.type_18 = VDXtypes.type_18 + 1;
	}
	else
	{
		VDXprofile_count = 0;
		for(k=0;k<VDXsrf_struct->v_num_poles;k=k+1)
		{

			msg = PlaceCirRevOrPro(tmpObj, 
					1.0/(VDXsrf_struct->v_num_poles-1)*k, 
					1.0/(VDXsrf_struct->v_num_poles-1)*(k+1), 
					2, VDXnum_pnts, VDX_types,
					VDXpnts, VDXmod_env);

 			msg = VDXcre_type18();
			//VDXtypes.type_18 = VDXtypes.type_18 + 1;
		}
		msg = TRUE;
	}
  }
  else
  {

    /* this kludge is for decomposing a surface along v knots */
    msg = check_v_geom( tmpObj, VDXmod_env, &chkcount, types, params, TOL);

    if( chkcount > 0 && isarc == TRUE)
    {
	for(i=0;i<chkcount;i=i+1)
	{
		if( types[i] == 1)
		{
			msg = PlaceCirRevOrPro(tmpObj, 
					params[i], params[i+1], types[i],
					VDXnum_pnts, VDX_types,
					VDXpnts, VDXmod_env);			
		}
		else if( types[i] == 2)
		{
			msg = PlaceCirRevOrPro(tmpObj, 
					params[i], params[i+1], types[i],
					VDXnum_pnts, VDX_types,
					VDXpnts, VDXmod_env);
		}

		if( msg == TRUE)
		{

		 	msg = VDXcre_type18();
			VDXtypes.type_18 = VDXtypes.type_18 + 1;
		}
	}
    }
    else
    {
      __DBGpr_com (" get rule arc point data\n");

      /* get the rotation arc information */

      VDXnum_pnts[2] = 4;
      VDXnum_pnts[3] = 4;
      VDX_types[2] = 1;
      VDX_types[3] = 1;
      VDX_types[4] = 8;		/* surface of revolution */

      /* if profile start points and trace start points are coincident. */

      for(i=0;i<4;i=i+1){ 
	uval[i*2] = 0.0; 
	uval[i*2+1] = i*(1.0/3.0);
	uval[i*2+8] = 1.0; 
	uval[i*2+9] = i*(1.0/3.0);
      }
      uval[16] = 0;
      uval[18] = 1;

      ci$send (msg = message GRvg.EMptatpr (
		&msg, &VDXmod_env.md_env.matrix_type,
		VDXmod_env.md_env.matrix, uval, 16, &VDXpnts[m]),
		targetid = in_obj->objid, targetos = in_obj->osnum);

      if ( isVecEq( &VDXpnts[0], &VDXpnts[VDXnum_pnts[0] * 3 + 0], TOL) &&
 	   isVecEq( &VDXpnts[VDXnum_pnts[0] * 6], &VDXpnts[VDXnum_pnts[0] * 6 + 3], TOL) ){

		for(i=0;i<7;i=i+2) uval[i] = .3333;
		uval[16] = .3333;
      }

      if ( isVecEq( &VDXpnts[VDXnum_pnts[0] *3 - 3 ], &VDXpnts[VDXnum_pnts[0] * 6 - 3 ], TOL) &&
 	   isVecEq( &VDXpnts[VDXnum_pnts[0] *6 + 12], &VDXpnts[VDXnum_pnts[0] * 6 + 15], TOL) ){

		for(i=0;i<4;i=i+1) uval[i*2+8] = .6666;
		uval[18] = .6666;
      }

      for(i=0;i<4;i=i+1){
	uval[i*2+1] = i*(1.0/3.0);
	uval[i*2+9] = i*(1.0/3.0);
      }
      uval[17] = .7;
      uval[19] = .7;

      ci$send (msg = message GRvg.EMptatpr (
			  &msg, &VDXmod_env.md_env.matrix_type,
			 VDXmod_env.md_env.matrix, uval, 20, &VDXpnts[m]),
	       targetid = in_obj->objid,
	       targetos = in_obj->osnum);

      __DBGpr_com (" Call VDXradius1 #4 ");
      msg = VDXradius1 (&VDXpnts[m + 0], &VDXpnts[m + 3], &VDXpnts[m + 6],
			&VDXpnts[m + 24], &rad1, cen1, matrix, &sweep);
      __DBGpr_dbl("profile sweep", sweep );
      __DBGpr_int (" VDXradius1 #4 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_com (" Call VDXradius1 #5 ");
      msg = VDXradius1 (&VDXpnts[m + 0], &VDXpnts[m + 3], &VDXpnts[m + 6],
			&VDXpnts[m + 9], &rad1, cen1, matrix, &sweep);
      __DBGpr_dbl("profile sweep", sweep );
      __DBGpr_int (" VDXradius1 #5 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_com (" Call VDXradius1 #6 ");
      msg = VDXradius1 (&VDXpnts[m + 12], &VDXpnts[m + 15], &VDXpnts[m + 18],
			&VDXpnts[m + 27], &rad2, cen2, matrix, &sweep);
      __DBGpr_dbl("profile sweep", sweep );
      __DBGpr_int (" VDXradius1 #6 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_com (" Call VDXradius1 #7 ");
      msg = VDXradius1 (&VDXpnts[m + 12], &VDXpnts[m + 15], &VDXpnts[m + 18],
			&VDXpnts[m + 21], &rad2, cen2, matrix, &sweep);
      __DBGpr_dbl("profile sweep", sweep );
      __DBGpr_int (" VDXradius1 #7 ", msg );
      if (msg < 0) return (-1);

      __DBGpr_dbl("profile rad1 ", rad1 );
      __DBGpr_dbl("profile rad2 ", rad2 );
      __DBGpr_vec("center #1 ", cen1 );
      __DBGpr_vec("center #2 ", cen2 );
	msg = VDXcre_type18();
    }
   }

#ifdef vdsDEBUG
      for( m=0 ; m<5 ; m=m+1 )
	__DBGpr_int(" VDX_types ", VDX_types[m] );

      for( m=0 ; m<4 ; m=m+1 )
      __DBGpr_int(" VDXnum_pnts ", VDXnum_pnts[m] );
#endif

  End 
  return (msg);
}

/*
 * This function extracts dynapipe (dynavent) related attributes from
 * an equipment and its embedded nozzles - Anand for CR 179901735 (Sep 2k)
 */
IGRstar ExtrDynEqptNozAttr( DIR, mod_env, outfile )
TGRid	  *DIR;
TGRmd_env *mod_env;
MYFILE	  *outfile;
{
    IGRlong	sts, type ; /* type = 0 (dbl) - type = 1 (txt) */
    IGRint	count,i,j;
    IGRdouble   dbCount , DblBuf ;
    IGRchar	Attr[30],TxtBuf[256],num[3];

    SetProc( ExtrDynEqptNozAttr ); Begin

    __DBGpr_obj(" Object passed", *DIR );

    /* Get the equipment's "parent" (for fabricated components placed on
     * components,  this would be the object id of the component on which the
     * fabricated component is placed). Per CR 179902056, the id should be
     * arrived as "The value should be the items Parents =>Parents => Contents
     * => Object ID." Anand (Sept 2k) */
    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "dp_eqpt_parent_id",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"dp_eqpt_parent_id: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" dp_eqpt_parent_id: [%s]\n", TxtBuf);
#endif
    }

    /* Fetch the Equipment's Reference Point, y-vector and x-vector from ref */
    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "dp_eqpt_ref_pnt",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"dp_eqpt_ref_pnt: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" dp_eqpt_ref_pnt: [%s]\n", TxtBuf);
#endif
    }

    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "dp_eqpt_angle_pos",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"dp_eqpt_angle_pos: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" dp_eqpt_angle_pos: [%s]\n", TxtBuf);
#endif
    }

    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "dp_eqpt_angle_rot",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"dp_eqpt_angle_rot: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" dp_eqpt_angle_rot: [%s]\n", TxtBuf);
#endif
    }

    /* Get other parameters */
    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "surf_area",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"surf_area: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" surf_area: [%s]\n", TxtBuf);
#endif
    }

    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "addnl_wt",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"addnl_wt: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" addnl_wt: [%s]\n", TxtBuf);
#endif
    }


    // get the number of embedded nozzles in the equipment
    dbCount = 0 ;
    sts = vdsa$GetStruct( objID  = DIR,
			  objENV = mod_env,
			  name   = "dp_nozz_count",
			  dbl    = &dbCount );
    __DBGpr_dbl(" Num Nozzles", dbCount );
    count = (IGRint) dbCount ;
    __DBGpr_int(" Num Nozzles", count);
    if( !sts || count == 0 )
    {
	fprintf(outfile,"%s: %s\n", "dp_nozz_count", "0");
	sts = 0 ;
	return sts;
    }

    fprintf(outfile,"%s: %d\n", "dp_nozz_count", count);

    // get connect point coordinates
    for( i=0 ; i<count ; i=i+1 )
    {
	if( i < 10 )
	    sprintf(num,"0%d_", i);
	else
	    sprintf(num,"%d_", i);

	/* Get attributes for each nozzle (14 in all) */
	for( j=0 ; j<14 ; j=j+1 )
	{
	    type = 1 ;	/* Default information is STRING */
	    Attr[0] = '\0';
	    strcpy( Attr, "dp_nozz_" );
	    strcat( Attr, num );

	    switch( j )
	    {
		case  0: strcat(Attr,"veloc_calc");	type = 0; break;
		case  1: strcat(Attr,"press_drop");	type = 0; break;
		case  2: strcat(Attr,"equiv_dia");	type = 0; break;
		case  3: strcat(Attr,"insul_thk");	type = 0; break;
		case  4: strcat(Attr,"insul_type");	type = 1; break;
		case  5: strcat(Attr,"acst_insul_thk");	type = 0; break;
		case  6: strcat(Attr,"acst_insul_type");type = 1; break;
		case  7: strcat(Attr,"press_class");	type = 1; break;
		case  8: strcat(Attr,"max_veloc");	type = 0; break;
		case  9: strcat(Attr,"size_method");	type = 1; break;
		case 10: strcat(Attr,"shape_code");	type = 0; break;
		case 11: strcat(Attr,"max_depth");	type = 0; break;
		case 12: strcat(Attr,"duct_matl");	type = 1; break;
		case 13: strcat(Attr,"ref");		type = 1;
	    }

	    __DBGpr_str(" Seeking value of attribute",Attr);

	    if( type )
	    {
		TxtBuf[0] = '\0' ;
		sts=vdsa$GetStruct( objID  = DIR,
				    objENV = mod_env,
				    name   = Attr,
				    txt    = TxtBuf);

		if( (sts&1) && strcmp(TxtBuf, "") )
		{
		    fprintf(outfile,"%s: %s\n", Attr, TxtBuf);
#ifdef vdsDEBUG
		    printf("%s: [%s]\n", Attr, TxtBuf);
#endif
		}
		else
		    fprintf(outfile,"%s: %s\n", Attr, "unknown");
	    }
	    else
	    {
		DblBuf = 0 ;
		sts=vdsa$GetStruct( objID  = DIR,
				    objENV = mod_env,
				    name   = Attr,
				    dbl    = &DblBuf);

		if( sts&1 )
		{
		    fprintf(outfile,"%s: %lf\n", Attr, DblBuf);
#ifdef vdsDEBUG
		    printf("%s: [%lf]\n", Attr, DblBuf);
#endif
		}
		else
		    fprintf(outfile,"%s: %s\n", Attr, "unknown");
	    }
	}
    }

    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "zone_number",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"zone_number: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" zone_number: [%s]\n", TxtBuf);
#endif
    }

    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "service",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"service: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" service: [%s]\n", TxtBuf);
#endif
    }

    TxtBuf[0] = '\0';
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "spec_name",
			 txt    = TxtBuf);

    if(sts && strcmp(TxtBuf, ""))
    {
      fprintf(outfile,"spec_name: %s\n", TxtBuf);
#ifdef vdsDEBUG
      printf(" spec_name: [%s]\n", TxtBuf);
#endif
    }
}

/*
 * This func is used to extract # of connect points, connect point coordinates,
 * and angle in a component. by ylong
 */
IGRstar extract_dynapipe_attributes(DIR, mod_env, outfile)
TGRid	  *DIR;
TGRmd_env *mod_env;
MYFILE	  *outfile;
{
    IGRdouble	count;
    IGRchar		txt_buf[256], num[4];
    IGRchar		comp_code[80];
    IGRchar		ang_name[80], ang_value[80];
    IGRchar		cnt_name[80];
    IGRchar		pnt_name[80];
    IGRchar		pnt_tail[12];
    IGRstar		sts ;
    IGRlong		status, msg ;
    IGRint		i ;

    /* Below lines added by Anand for CR 179901735 */
    IGRchar		ClassName[80];

    status = om$get_classname( objid	= DIR->objid,
			       osnum	= DIR->osnum,
			       classname	= ClassName );
    __DBGpr_str("Class to which DIR belongs", ClassName );

    if( strcmp(ClassName,"VDequipment") == 0 && status == OM_S_SUCCESS )
    {
	sts = ExtrDynEqptNozAttr( DIR, mod_env, outfile );
	return sts;
    }
    /* Above lines added by Anand for CR 179901735 */

    /* Below lines added by Anand as a kludge for TR 5982 */

	/*****************************************************
	 * Get the 'bend_sweep' of component as a smart      *
	 * attribute.  The sts is returned as false, but the *
	 * value comes out correctly.  Report the same as    *
	 * 'alt_bend_sweep'                                  *
	 *****************************************************/

    vdsa$GetStruct( objID  = DIR,
		    objENV = mod_env,
		    name   = "bend_sweep",
		    dbl    = &count);

    fprintf(outfile,"alt_bend_sweep: %lf\n", count);

    /* Above lines added by Anand as a kludge for TR 5982 */

    // initialization
    strcpy( ang_name, "dp_comp_angle_pos" );
    strcpy( cnt_name, "dp_conn_pnt_count" );
    strcpy( pnt_tail, "_xyz" );
    comp_code[0] = '\0' ;
    txt_buf[0] = '\0' ;
    count = 0 ;

#ifdef DEBUG
    printf("Obj = [%d, %d]\n", DIR->objid, DIR->osnum);
#endif

#ifdef DEBUG
    // get comp_code
    sts = vdsa$GetStruct(	objID  = DIR,
			    objENV = mod_env,
			    name   = "comp_code",
			    txt    = txt_buf);

    if( sts && strcmp(txt_buf, "") ) {
	    strcpy(comp_code, txt_buf) ;
    }
    else {
	    strcpy(comp_code, "Uknown_code") ;
    }
#endif

    // get the angle of component
    sts = vdsa$GetStruct(	objID  = DIR,
			    objENV = mod_env,
			    name   = ang_name,
			    txt    = txt_buf);

    if( sts ) {
	    strcpy(ang_value, txt_buf) ;
	    fprintf(outfile,"%s: %s\n", ang_name, ang_value);
	    #ifdef DEBUG
	    printf("%s  %s: %s\n", comp_code, ang_name, ang_value);
	    #endif
    }

    // get the number of connect points in a component
    sts = vdsa$GetStruct(	objID  = DIR,
			    objENV = mod_env,
			    name   = cnt_name,
			    dbl    = &count);

    if( !sts || (int)count == 0 ) {
	    fprintf(outfile,"%s: %s\n", cnt_name, "0");
	    sts = 0 ;
	    goto wrapup ;
    }

    fprintf(outfile,"%s: %d\n", cnt_name, (int)count);
#ifdef DEBUG
    printf("%s  %s: %d\n", comp_code, cnt_name, (int)count);
#endif

    // get connect point coordinates
    for( i=0 ; i<(int)count ; i=i+1 ) {

	    if( i < 10 ) {
		    sprintf(num,"0%d", i);
	    }
	    else {
		    sprintf(num,"%d", i);
	    }

	    strcpy( pnt_name, "dp_conn_pnt_" );
	    strcat( pnt_name, num );
	    strcat( pnt_name, pnt_tail );

	    txt_buf[0] = '\0' ;
	    sts = vdsa$GetStruct(	objID  = DIR,
				    objENV = mod_env,
				    name   = pnt_name,
				    txt    = txt_buf);

	    if( sts && strcmp(txt_buf, "") )
	    {
		    fprintf(outfile,"%s: %s\n", pnt_name, txt_buf);
#ifdef DEBUG
		    printf("%s  %s: [%s]\n", comp_code, pnt_name, txt_buf);
#endif
	    }
	    else {
		    fprintf(outfile,"%s: %s\n", pnt_name, "unknown");
	    }
    }
    // Reference Point
    *txt_buf = 0;
    sts = vdsa$GetStruct(objID  = DIR,
			 objENV = mod_env,
			 name   = "dp_comp_ref_pnt",
			 txt    = txt_buf);

    if(sts && strcmp(txt_buf, "") )
    {
      fprintf(outfile,"%s: %s\n", "dp_comp_ref_pnt", txt_buf);
#ifdef DEBUG
      printf("%s  %s: [%s]\n", comp_code, "dp_comp_ref_pnt", txt_buf);
#endif
    }
    sts = 1 ;
wrapup:

    return sts ;
}


long VDXget_coll_data (DIR, VDXmod_env, outfile)
struct GRid DIR;
struct GRmd_env VDXmod_env;
MYFILE *outfile;

{
	IGRint			sts, i ;
	IGRlong			msg ;
	IGRshort		out[2];
	IGRchar			*pPtr,
				pBuf[256],
				pBuf1[256] ;
	IGRint			count ,
				prdCount ;
	IGRint			count1 ,
				prdCount1 ;
	IGRint			count2 ,
				prdCount2 ;
	struct	GRid		go ;
	struct	ACrg_coll	*list	;
	struct	ACrg_coll	*list1	;
	struct	ACrg_coll	*list2	;
	struct	ACrg_coll	*prdList	;
        
	char			file_id[VDPOBID_LEN]	;
	char			vds_id[10];
	char 			*context;
	char 			*pme_id;
	char			*ctx_no;
	int			y;
	char 			*temp;
	int			PMEstat, stat;
	int			outlen;
	char			*outbuf, *temp_str;

	char		strOBJID[20]; // added by Alwin

	SetProc( VDXget_coll_data ); Begin

	__DBGpr_com(" CAll VDXget_coll_data ");

	count		= 0 ;
	prdCount	= 0 ;
	y		= 0 ;
	list1		= NULL ;
	list2		= NULL ;
	prdList		= NULL ;
	context = NULL;
	pme_id = NULL;
	ctx_no = NULL;
	temp = NULL;
 	outlen = 0;
	outbuf = NULL;
	temp_str = NULL;
        PMEstat = 0;
        file_id[0] = '\0';
        vds_id[0] = '\0';
	stat = 0;

	/*
	 * To be sure the tempate feet objects are activated, left do
	 * a return_go on the macro object.
	 */	
	go = DIR ;
	sts =
	ci$send( msg = message NDmacro.ACreturn_foot( &msg, "", 
					&go,NULL, NULL ),
		targetid = go.objid,
		targetos = go.osnum );
			
	CheckRC( sts, msg );
						
	sts =
	vd$get_params(	sts	= &msg,
			object	= & DIR,
			md_env	= & VDXmod_env,
			count	= &count1,
			plist	= &list1 );
	CheckRC( sts, msg );
	
	/* Get the Tree Extract for Review parameters */
	sts =
	vdat$get_params(	sts	= &msg,
				object	= & DIR,
				count	= &count2,
				plist	= &list2,
				type    = VDAT_EXTR_FOR_REVIEW );
	CheckRC( sts, msg );

	// Merge the Attributes (Tree and Internal) into a single list.

	mergeAttributeLists(list1,count1,list2,count2, &list, &count);


	/*
	 * Force to permit to add any information found.
	 */
        if( ( count == 0 )  || ( list == NULL ) ){
                __DBGpr_com(" No attributes Found ");
		count = 0 ;
        }

	sprintf(VDXmsg_buf, "\tAttr:\t%d Found", count );
	VDXdebug (0, VDXlog_file, NULL, VDXmsg_buf); 

	out[0] = (DIR.objid >> 16);
	out[1] = (DIR.objid);
	if (out[1] < 0)
	  out[1] = out[1] - 0xffff0000;
/*  
	fprintf (outfile, "lbl{%d %d %d %d text {\n",
             0x8000, out[0], out[1], DIR.osnum);
*/

	VDXgg[2] = 0;
	for( i=0; i<count; i=i+1 )
	{
	  pPtr = NULL ;
	  pBuf[0] = '\0';
	  pPtr = strrchr( list[i].name, ':' );
	  if( pPtr != NULL ) 
	  {	
		strcpy( pBuf1, pPtr );
		strcpy( pBuf, &pBuf1[1] );	
	  }
	  else 
	  {	
		strcpy( pBuf, list[i].name );	
	  }

          if( list[i].desc.type == AC_ATTRIB_TEXT )
	  {
		if( strcmp( pBuf, "comp_code") == 0 )
		{
			if( strcmp(list[i].desc.value.att_txt, "PIPING")== 0 )
			{
				// printf("%s: %s\n", pBuf, list[i].desc.value.att_txt);
				VDXgg[2] = 5;
				break;
			}
			else 
			{
				// printf("%s: %s\n", pBuf, list[i].desc.value.att_txt);
				VDXgg[2] = 3;
				break;
			}
		}
	  }
	}

	strOBJID[0] = '\0';
	sprintf( strOBJID, "%d", DIR.objid ); //added by Alwin
 	fprintf (outfile, "lbl{%d %d %s %d text {\n", 0, VDXgg[2], 
												  strOBJID, DIR.osnum);
   
/* TLS  Need to get the objects PME data and add it to .drv file */
     if(PME_CONNECT == 0)
     {

        PME_ERROR = 0;
	__DBGpr_int(" PME_ERROR ", PME_ERROR );

	__DBGpr_obj(" Object ", DIR );
  	/*strcpy (vds_id, itoa (out[1]) ); commented by Alwin */
  	strcpy (vds_id, strOBJID ); // Modified this line. Alwin
	__DBGpr_str( " vds_id ", vds_id );
	stat = VDPGetFileId(&msg, DIR.osnum, file_id);
	CheckRC( stat, msg );

       if(file_id[0] != '\0' )
       {
         __DBGpr_str(" file_id ", file_id);
       }
       else
       {
         __DBGpr_com(" file_id is null");
	 PME_ERROR = 1;
       }   

       if(PME_ERROR == 0)
       {
       	 if(server_name[0] != '\0')
           __DBGpr_str(" server_name ", server_name);
       	 if(vds_id[0] != '\0')
           __DBGpr_str(" vds_id ", vds_id );

       	 PMEstat = VDXsend_cmd(server_name, vds_id, file_id, &outbuf, &outlen);
       	 __DBGpr_int("returned from VDXsend_cmd PMEstat is ", PMEstat );

       	 if( (PMEstat == 0) )
       	 {
		if( (*outbuf) )
        	{
	  	__DBGpr_com("Inside the outbuf if statement");
          	__DBGpr_str(" outbuf ", outbuf );
          	__DBGpr_int(" outbuf ", (int *)outbuf );
         	 __DBGpr_int(" outlen ", outlen );
	  	temp = (char *) malloc(outlen);

 	  		if(temp)
          		{  
	    		sprintf(temp, "%s", outbuf);
            		__DBGpr_str(" temp ", temp );
          		}
	  		else
          		{
	    		PME_ERROR = 1;
	    	 	__DBGpr_int(" PME_ERROR ", PME_ERROR );
          		}
        	}
        	else
        	{
	   	PME_ERROR = 1;
	   	__DBGpr_int(" PME_ERROR ", PME_ERROR );
        	}
       	 }
       	 else
       	 {
	    PME_ERROR = 1;
	    __DBGpr_int(" PME_ERROR ", PME_ERROR );
       	 }
       }
     }

       __DBGpr_int(" past if outbuf PME_ERROR", PME_ERROR );

       /* ------------------------------------------------
        * CR179801166 Add file_name and pdm_part attributes
        */
       vdsa$GetStruct(objID = &DIR, name = VDSA_KEY_SA_PDM_FILE_NAME, txt = pBuf);

       if (*pBuf) fprintf(outfile,"%s: %s\n","file_name",pBuf);

       vdsa$GetStruct(objID = &DIR, name = VDSA_KEY_SA_PDM_POST_ID, txt = pBuf);
       pPtr = strrchr(pBuf,':');
       if (pPtr) *pPtr = 0;

       if (*pBuf) fprintf(outfile,"%s: %s\n","pdm_part",pBuf);

       // END OF CR179801166 Changes

       extract_dynapipe_attributes(&DIR, &VDXmod_env, outfile);
       

	for( i=0; i<count; i=i+1 )
	{

	  pPtr = NULL ;
	  pBuf[0] = '\0';
	  pPtr = strrchr( list[i].name, ':' );
	  if( pPtr != NULL ) {	strcpy( pBuf1, pPtr );
				strcpy( pBuf, &pBuf1[1] );	}
	  else {		strcpy( pBuf, list[i].name );	}

          if( list[i].desc.type == AC_ATTRIB_TEXT ){
		fprintf (outfile, "%s: %s\n", pBuf, list[i].desc.value.att_txt);
	  }
	  else{
		fprintf (outfile, "%s: %.4f\n", pBuf, list[i].desc.value.att_exp);
	  }
	}

	/*
	 * TLS - Add PME attributes to the .drv file if the PME_CONNECT and 
         *  PME_ERROR are both equal to 0.
	 */

	__DBGpr_int(" PME_CONNECT ", PME_CONNECT );
	__DBGpr_int(" PME_ERROR ", PME_ERROR );

	if((PME_CONNECT == 0) && (PME_ERROR == 0))
	{
          __DBGpr_str(" file_id ", file_id);
	  fprintf(outfile, "file_id: %s\n", file_id);

	  if(*temp)
	  {
	    	pme_id = strtok(temp, "*");
           	__DBGpr_str(" pme_id  ", pme_id );
	  	fprintf(outfile, "pme_id: %s\n", pme_id);

	   	ctx_no = strtok(NULL, "*");
           	__DBGpr_str(" ctx_no ", ctx_no );
	  	fprintf(outfile, "ctx_no: %s\n", ctx_no);

		y=1;
	    	context = strtok(NULL, "*");
		while ( context != NULL)
		{
           	 	__DBGpr_str(" context ", context );
			fprintf(outfile, "ctx%d: %s\n", y, context);
			y = y + 1;
	    		context = strtok(NULL, "*");

		}
	  }		

	}

	/*
	 * Add production data from the VD_AT_PIECES table.
	 */
	__DBGpr_int(" Process Production Flag ", VDXform_info.productionFlag );

	if( VDXform_info.productionFlag ){

	  __DBGpr_obj(" Process Production Data ", DIR );
	  prdCount = 0 ;

          if( VDSverify_login() == PDM_S_SUCCESS){
	    sts =
	    vd$db_get_params(	sts	= &msg,
				object	= &DIR,
				table	= VD_TREE_PIECES_TABLE,
				md_env	= &VDXmod_env,
				count	= &prdCount,
				plist	= &prdList );
	    CheckRC( sts, msg );
	    __DBGpr_int(" Number Prod Attrs ", prdCount );

            if( (!(msg&sts&1)) || ( prdCount == 0 )  || ( prdList == NULL )){
                __DBGpr_com(" No production data Found ");
		prdCount = 0 ;
            }
	  }

	  sprintf(VDXmsg_buf, "\tProd Attr:\t%d Found", prdCount );
	  VDXdebug (0, VDXlog_file, NULL, VDXmsg_buf); 

	  for( i=0; i<prdCount; i=i+1 ){

	    pPtr	= NULL ;
	    pBuf[0]	= '\0';
	    pPtr	= strrchr( prdList[i].name, ':' );
	    if( pPtr != NULL ){	strcpy( pBuf1, pPtr );
				strcpy( pBuf, &pBuf1[1] );	}
	    else {		strcpy( pBuf, prdList[i].name );}

	    if( strncmp("assembly_", pBuf, 9 ) == 0 ) continue ;
	    if( strncmp("leaf_"    , pBuf, 5 ) == 0 ) continue ;
            if( prdList[i].desc.type == AC_ATTRIB_TEXT ){
		fprintf (outfile, "%s: %s\n",
				pBuf, prdList[i].desc.value.att_txt);
	    }
	    else{
		fprintf (outfile, "%s: %.4f\n",
				pBuf, prdList[i].desc.value.att_exp);
	    }
	  }
	}

	fprintf (outfile, "}}\n");

	wrapup:
		if( list ) 	free( list );
		if( prdList )	free( prdList );
		if( temp )	free( temp );
		End 
		return( sts );
}


int mergeAttributeLists(list1, count1, list2, count2, list, count)
struct ACrg_coll *list1;
int count1;
struct ACrg_coll *list2;
int count2;
struct ACrg_coll **list;
int *count;
{

	struct ACrg_coll *listx;
	int 	i;
	int 	retFlag;

	// Init 
	retFlag = 0;
	if(count) *count = 0;
	if(list) *list = NULL;

	// Args Check
	if(list1 == NULL) goto wrapup;

	*count = count1 + count2;
	listx = _MALLOC(*count, struct ACrg_coll);

	*list = listx;
	
	if((*list)==NULL) 
	{     
	__DBGpr_com( " Allocation Error ");
	goto wrapup;
	}
	

	 i = count1*sizeof(struct ACrg_coll);
	 memcpy(listx, list1, i);

	 memcpy(listx+count1,list2, count2*sizeof(struct ACrg_coll)); 

retFlag = 1;
wrapup:
	return retFlag;
}

long VDXwrite_HTM_coll_data (DIR, VDXmod_env, HTMLoutfile)
struct GRid DIR;
struct GRmd_env VDXmod_env;
MYFILE *HTMLoutfile;
{
        IGRint                  sts, i, j ;
        IGRlong                 msg ;
        IGRshort                out[2];
        IGRchar                 *pPtr,
                                NameCheck[4],
                                pBuf[256],
                                pBuf1[256] ;
        IGRint                  count ;
        struct  GRid            go ;
        struct  ACrg_coll       *list   ;
		IGRchar					strOBJID[20]; // added by Alwin

        SetProc( VDXwrite_HTM_coll_data ); Begin

//      HasAttributes = 0;

        count = 0 ;
        list  = NULL ;

        /*
         * To be sure the tempate feet objects are activated, left do
         * a return_go on the macro object.
         */
        go = DIR ;
        sts =
        ci$send( msg = message NDmacro.ACreturn_foot( &msg, "",
                                        &go,NULL, NULL ),
                targetid = go.objid,
                targetos = go.osnum );

        CheckRC( sts, msg );

        sts =
        vd$get_params(  sts     = &msg,
                        object  = & DIR,
                        md_env  = & VDXmod_env,
                        count   = &count,
                        plist   = &list );
        CheckRC( sts, msg );

        __DBGpr_int(" Number Attrs HTM", count );


        if( ( count == 0 )  || ( list == NULL ) ){
                __DBGpr_com(" No attributes Found ");
		// Keep the header, skip the loop, AZ+KDD+Tawana.
                count = 0;
        }

        sprintf(VDXmsg_buf, "\tAttr:\t%d Found\n", count );
        VDXdebug (0, VDXlog_file, NULL, VDXmsg_buf);

        out[0] = (DIR.objid >> 16);
        out[1] = (DIR.objid);
        if (out[1] < 0)
          out[1] = out[1] - 0xffff0000;

        for( i=0; i<count; i=i+1 ){

          pPtr = NULL ;
          pBuf[0] = '\0';
          pPtr = strrchr( list[i].name, ':' );
          if( pPtr != NULL ) {  strcpy( pBuf1, pPtr );
                                strcpy( pBuf, &pBuf1[1] );      }
          else {                strcpy( pBuf, list[i].name );   }

          if( list[i].desc.type == AC_ATTRIB_TEXT ){

                for ( j=0;j<4;j=j+1) NameCheck[j] = tolower(pBuf[j]);

                //Check the trailing 3 chars for HTM, htm, TML, or tml

                if (i == 0)
                {
				strOBJID[0] = '\0';
				sprintf( strOBJID, "%d", DIR.objid  );
                fprintf (HTMLoutfile,"<H2>Attributes</H2>\n");

		/****
		fprintf (HTMLoutfile, "<H3><a name=\"%d\">LABEL KEY : %d %d </H3>\n",out[1], out[1], DIR.osnum);
		Commenting this line to change the format to "%s".TR179901490 Alwin****/

		fprintf (HTMLoutfile, "<H3><a name=\"%s\">LABEL KEY : %s %d </H3>\n",
							strOBJID, strOBJID, DIR.osnum);
                fprintf (HTMLoutfile,"<H4><blink>%d</blink> follow\n", count);
                }

                if (strncmp( NameCheck, "http",4) == 0 )
                {
                        fprintf (HTMLoutfile, "<LI><A HREF=\"http://%s\">%s: %s</A>\n", 
				list[i].desc.value.att_txt,pBuf, list[i].desc.value.att_txt);
                }
                else
                {
                        fprintf (HTMLoutfile, "<LI>%s: %s\n",
                                pBuf, list[i].desc.value.att_txt);
                }

          }
          else{
                fprintf (HTMLoutfile, "<LI>%s: %.4f\n",
                                pBuf, list[i].desc.value.att_exp);
          }
        }
        wrapup:
                if( list ) free( list );
                End
                return( sts );
}

IGRint VDXget_arrange_name( refname )
IGRchar *refname;
{
int     i;
int     j;

        SetProc( VDXget_arrange_name ); Begin

        __DBGpr_str(" ref_name ", refname );

        j = strlen (refname);
        for ( i=j; i>0; i = i - 1 ){

          if( refname[i] == ',' ){
            refname[i] = '\0';
            break;
          }
        }

        End
        return ( OM_S_SUCCESS );
}


IGRint  VDXget_ref_info1( mod_env, refcount, reftab )
struct GRmd_env         *mod_env;
IGRlong                 *refcount;
struct VDX_reffile      **reftab;
{
long            sts, status;
OM_S_OBJID      Super_id;
IGRshort        count_nested;
GRobjid         *objlist;
GRspacenum      *oslist;
int             on_off;
IGRint          i,j;
IGRint          msg;
IGRlong         count;
IGRulong        prop_mask, props;
unsigned short  properties;
IGRchar         buffer[512];
struct GRobj_info       refinfo;
struct VDX_reffile      *curref, *ref;
struct GRid     ref_object;

  objlist = (GRobjid *)(NULL);
  oslist  = (GRspacenum *)(NULL);
  *refcount = 0;
  count = 0;

  status = ex$get_objid_from_NOD(
                        NODname         = "IGENOD",
                        objname         = "Ref Mgr",
                        pobjid          = &Super_id,
                        modid           = mod_env->md_id.objid,
                        mod_osnum       = mod_env->md_id.osnum);
  if(!(status&1)) goto wrapup ;

  prop_mask = 0;
  count_nested = 0;
  status = ci$send(msg     = message Super_rfmgr.GRget_channel_count
                                   (&sts, &prop_mask, &count_nested, &count),
          targetid = Super_id,
          targetos = mod_env->md_id.osnum );

  if(!(status&1)) goto wrapup ;

  __DBGpr_int("channel count =", count);

  i = (int)count;
  objlist = om$calloc( num = i, structure = GRobjid );
  oslist  = om$calloc( num = i, structure = GRspacenum );

  prop_mask = 0; count_nested = 0;
  status =
  ci$send(msg      = message Super_rfmgr.GRget_channel_objects
                                     (&sts, &prop_mask, &count_nested, &count,
                                      objlist, oslist, &count),
          targetid = Super_id,
          targetos = mod_env->md_id.osnum );
  if(!(status&1)) goto wrapup ;

  i = (int) count;
  *reftab = om$calloc( num = i, structure = struct VDX_reffile );

  __DBGpr_int(" Channel objects retrieved ", count);

  curref = *reftab;
  *refcount = count;
  j = 0;
  for( i=0; i<count ; i = i + 1 ) {
    status =
    ci$send(msg      = message GRreffile.GRgetobjinfo( &sts, &refinfo ),
            targetid = objlist[i],
            targetos = oslist[i] );
    if(!(status&1)) continue;

    status =
    ci$send(msg      = message GRreffile.GRgetenvironment
                                          ( &sts, mod_env, &(curref->md_env) ),
            targetid = objlist[i],
            targetos = oslist[i] );
    if(!(status&sts&1)) continue;

    curref->osnum = curref->md_env.md_id.osnum;

    VDXget_arrange_name( refinfo.type );
    strcpy( curref->ref_name, refinfo.type );
    curref->ctx_id.objid = objlist[i];
    curref->ctx_id.osnum = oslist[i];

    __DBGpr_str(" refinfo.type ", refinfo.type );
    __DBGpr_obj(" Cur Refernce ", curref->md_env.md_id );

    on_off = 0 ;

    status =
    ci$send(msg = message GRreffile.GRgetrfprops
                                          ( &sts, &props ),
            targetid = objlist[i],
            targetos = oslist[i] );


    ref_object.objid = objlist[i];
    ref_object.osnum = oslist[i];
    gr$get_properties( object_id = &ref_object,
                       properties_mask = &VDXproperties);

    curref->properties = props;

    if ( VDXproperties & GRIS_DISPLAYABLE )
         on_off = 1;

    __DBGpr_int("on_off ", on_off);

    curref->display = on_off;

    j = j + 1;
    curref = curref + 1;

  }  

  if (j <= 0)
   {
      *refcount = 0;
      goto wrapup;
   }

  if( j < count )
   {
      i = j;
      *refcount = j;
      i = i * sizeof(struct VDX_reffile);
      *reftab = (struct VDX_reffile *)om$realloc( ptr  = (char *)*reftab,
                                                  size = i );
   }
   __DBGpr_int("refcount ", *refcount);

  if( objlist ) om$dealloc( ptr = objlist );
  if( oslist )  om$dealloc( ptr = oslist );

  return( OM_S_SUCCESS );

wrapup:
  if( objlist ) om$dealloc( ptr = objlist );
  if( oslist )  om$dealloc( ptr = oslist );
  if( *reftab ) om$dealloc( ptr = *reftab );
  *refcount = 0;
  return( OM_S_SUCCESS );
}


int VDXreport_file_generate (start_time, design_file, dst_file, dri_file,
                             drv_file, dgn_file)
     long start_time; 
     char *design_file;  /* Name of VDS design File */
     char *dst_file;
     char *dri_file;
     char *drv_file;
     char *dgn_file;
{
  extern double difftime ();
  int i, seconds, minutes;
  long finish_time; 
  double diff_time;
  extern long *time ();

  IGRint 		refcount;
  struct VDX_reffile    *reftab;
  char			ref_name[50];
  char			*tmpfile, *temp, temp1[128];
  char			desgfile[128], catalog[128], part[128], rev[10];
  int			ch, pdm_stat, check; 		
  char			*errPDM, cidate[40], ciuser[40];  
  char			query[512], *output_buffer;
  int			itemno, rows, ris_err_code;
  char			sql_str[512];
  MEMptr		bufr;
  char			**data;
  int			y;

  tmpfile 		= NULL;
  temp  		= NULL;
  ch			= '/';
  pdm_stat		= PDM_S_SUCCESS;
  check			= 0;
  bufr			= NULL;

/****
 fprintf (VDXlog_file, "Entering  VDXreport_file_generate\n");
*****/
  /* check for output files */

  time (&finish_time);

  diff_time = difftime (finish_time, start_time);
  seconds = (int) diff_time;


  fprintf (VDXlog_file,"\n\n------------------------------------------------------------------------\n");
  fprintf (VDXlog_file,"------------------------------------------------------------------------\n");
  fprintf (VDXlog_file, "\n\n%s", "               Output filenames\n\n");
  fprintf (VDXlog_file, "Control File     :   %s\n", dri_file);
  fprintf (VDXlog_file, "Display Set File :   %s\n", dst_file);
  fprintf (VDXlog_file, "Label File       :   %s\n", drv_file);
  fprintf (VDXlog_file, "IGDS Design File :   %s\n", dgn_file);
  fprintf (VDXlog_file, "Color Table File :   %s\n", VDXclr_tbl_file);

  fprintf (VDXlog_file, "\n\n\n%s", "               Input filename\n");
/*
  fprintf (VDXlog_file, "VDS Design File     : %s\n", design_file);
*/

  /* get the catalog, part no. , and revision for each file */
  temp = strrchr(design_file, ch);
  sprintf(temp1,"%s", temp);
  tmpfile = strtok(temp1, "/");
  sprintf(desgfile,"%s", tmpfile);

  fprintf (VDXlog_file, "VDS Design File     : %s\n", desgfile);

  pdm_stat = PDMGetPartInfoGivenFileName(desgfile, catalog, part, rev);
  if(pdm_stat != PDM_S_SUCCESS)
  {
    fprintf (VDXlog_file, "Unable to retrieve the catalog/part number/revision for the given file : %s\n\n", design_file);
    fprintf (VDXlog_file, "MAKE SURE THAT YOU ARE LOGGED INTO THE DATABASE.\n\n");
    UI_status("Unable to retrieve the catalog/part number/revision information.");
  }
  else
  {
   	fprintf (VDXlog_file, "Catalog             : %s\n", catalog);
       	fprintf (VDXlog_file, "Part No             : %s\n", part);
       	fprintf (VDXlog_file, "Revision            : %s\n", rev);

  	pdm_stat = PDM_S_SUCCESS;

	/* get the checked in date and user for the file */
  	pdm_stat = PDMquery_partno(catalog, part, rev, &itemno);
  	if(pdm_stat != PDM_S_SUCCESS)
  	{
    		fprintf (VDXlog_file, "Unable to retrieve the catalog/part number/revision for the given file : %s\n\n", design_file);
    		fprintf (VDXlog_file, "MAKE SURE THAT YOU ARE LOGGED INTO THE DATABASE.\n\n");
    		UI_status("Unable to retrieve the catalog/part number/revision information.");
  	}
        else
	{

  		y=0;
  		sprintf(sql_str, "%s f_%s %s %d %s %d",
                	"SELECT n_cidate, n_ciuser FROM ", catalog,
                	"WHERE n_itemnum = ", itemno,
                	"AND n_fileversion > ", y);
  		pdm_stat = SQLquery(sql_str, &bufr, 512);
  		if (pdm_stat != SQL_S_SUCCESS)
     			MEMclose(&bufr);
                else
  			pdm_stat = MEMbuild_array(bufr);
  		if (pdm_stat != MEM_S_SUCCESS)
     			MEMclose(&bufr);
                else
   		{
  			data = (char **) bufr->data_ptr;
  			strcpy(cidate, data[0]);
  			strcpy(ciuser, data[1]);  
  			if (strcmp (cidate, "") == 0)
    				fprintf(VDXlog_file, "Error in retrieving Checked in Date\n");  
  			else
    				fprintf(VDXlog_file, "Checked in Date     : %s\n", cidate);

 	 		if (strcmp (ciuser, "") == 0)
    				fprintf(VDXlog_file, "Error in retrieving Checked in User\n");  
  			else
    				fprintf(VDXlog_file, "Checked in User     : %s\n", ciuser);
  
  			fprintf(VDXlog_file, "\n");
  		}
	}

  }

 catalog[0] = '\0';		
 part[0] = '\0';		
 rev[0] = '\0';		
 cidate[0] = '\0';
 ciuser[0] = '\0';

 /* add the reference file information  */
 /**  call VDGetRefFiles to get the reference files for the active
              design file.                                             **/
  refcount = 0;
  reftab = NULL;
  VDXget_ref_info1 (&VDXmod_env, &refcount, &reftab);
    
  if(refcount <= 0)
    fprintf (VDXlog_file, "No reference file attached to  :   %s\n\n", design_file);
  else

  {
     for (i = 0; i < refcount; i = i + 1)
          {
             strncpy(ref_name,  reftab[i].ref_name, 39);
             fprintf (VDXlog_file, "VDS Reference File  : %s\n", ref_name);
  	     /* get the catalog, part no. , and revision for each file */
             pdm_stat = PDMGetPartInfoGivenFileName(ref_name, catalog, part, rev);
             if(pdm_stat != PDM_S_SUCCESS)
             {
             	fprintf (VDXlog_file, "Unable to retrieve the catalog/part number/revision for the given file : %s\n\n", ref_name);
    		fprintf (VDXlog_file, "MAKE SURE THAT YOU ARE LOGGED INTO THE DATABASE.\n\n");
    		UI_status("Unable to retrieve the catalog/part number/revision information.");
             }
	     else
	     {
             	fprintf (VDXlog_file, "Catalog             : %s\n", catalog);
             	fprintf (VDXlog_file, "Part No             : %s\n", part);
             	fprintf (VDXlog_file, "Revision            : %s\n", rev);

                /* get the checked in date and user for the file */
	  	pdm_stat = PDMquery_partno(catalog, part, rev, &itemno);
  		if(pdm_stat != PDM_S_SUCCESS)
  		{
    			fprintf (VDXlog_file, "Unable to retrieve the catalog/part number/revision for the given file : %s\n\n", design_file);
    			fprintf (VDXlog_file, "MAKE SURE THAT YOU ARE LOGGED INTO THE DATABASE.\n\n");
    			UI_status("Unable to retrieve the catalog/part number/revision information.");
  		}
 		else
		{

  			y=0;
  			sprintf(sql_str, "%s f_%s %s %d %s %d",
                		"SELECT n_cidate, n_ciuser FROM ", catalog,
                		"WHERE n_itemnum = ", itemno,
                		"AND n_fileversion > ", y);
  			pdm_stat = SQLquery(sql_str, &bufr, 512);
  			if (pdm_stat != SQL_S_SUCCESS)
     				MEMclose(&bufr);
			else
  				pdm_stat = MEMbuild_array(bufr);
  			if (pdm_stat != MEM_S_SUCCESS)
     				MEMclose(&bufr);
			else
			{
  				data = (char **) bufr->data_ptr;
  				strcpy(cidate, data[0]);
  				strcpy(ciuser, data[1]);
  				if (strcmp (cidate, "") == 0)
    					fprintf(VDXlog_file, "Error in retrieving Checked in Date\n");
  				else
    					fprintf(VDXlog_file, "Checked in Date     : %s\n", cidate);

  				if (strcmp (ciuser, "") == 0)
    					fprintf(VDXlog_file, "Error in retrieving Checked in User\n");
  				else
    					fprintf(VDXlog_file, "Checked in User     : %s\n", ciuser);
				fprintf(VDXlog_file, "\n");
			}
		}
  	catalog[0] = '\0';
  	part[0] = '\0';
  	rev[0] = '\0';
  	cidate[0] = '\0';
  	ciuser[0] = '\0';
             }
           } 
  }

/* end of reference file information   */

  minutes = seconds / 60;
  seconds = seconds % 60;
  fprintf (VDXlog_file, "\n%s\n\n          %d:%d\n\n", "     Processing time:",
	   minutes, seconds);
  fprintf (VDXlog_file, "\n%s  %d\n\n", "Total number of objects encountered:",
	   VDXtypes.object_count);
  fprintf (VDXlog_file, "\n%s  %d\n\n", "Total number of objects processed:  ",
	   VDXtypes.processed);
  fprintf (VDXlog_file, "\n%s  %d\n\n", "Total number of elements selected:  ",
	   VDXtypes.type_46 + VDXtypes.type_25 + VDXtypes.type_24 +
           VDXtypes.type_23 + VDXtypes.type_18 + VDXtypes.type_15 +
           VDXtypes.type_2);

  fprintf (VDXlog_file, "\n%s\n", "     Output entity totals:\n");
  fprintf (VDXlog_file, "      type 46 = %d\n", VDXtypes.type_46);
  fprintf (VDXlog_file, "      type 25 = %d\n", VDXtypes.type_25);
  fprintf (VDXlog_file, "      type 24 = %d\n", VDXtypes.type_24);
  fprintf (VDXlog_file, "      type 23 = %d\n", VDXtypes.type_23);
  fprintf (VDXlog_file, "      type 18 = %d\n", VDXtypes.type_18);
  fprintf (VDXlog_file, "      type 15 = %d\n", VDXtypes.type_15);
  fprintf (VDXlog_file, "      type  2 = %d\n", VDXtypes.type_2);
  fprintf (VDXlog_file, "---------------------\n");
  fprintf (VDXlog_file, "                %d\n",
           VDXtypes.type_46 + VDXtypes.type_25 + VDXtypes.type_24 +
           VDXtypes.type_23 + VDXtypes.type_18 + VDXtypes.type_15 +
           VDXtypes.type_2);
  fprintf (VDXlog_file, "\nEnd of report.\n\n");
  fprintf (VDXlog_file,"------------------------------------------------------------------------\n");
  fprintf (VDXlog_file,"------------------------------------------------------------------------\n\n");
/****
 fprintf (VDXlog_file, "Exiting\n");
****/
  return (0);
}

/****************************************************************************/

int VDXreport_batch(	design_file, rpt_file, dst_file,
			dri_file, drv_file, dgn_file)

IGRchar		*design_file; 
IGRchar		*rpt_file;
IGRchar		*dst_file;
IGRchar		*dri_file;
IGRchar		*drv_file;
IGRchar		*dgn_file;
{
  printf("\n");
  printf("-----------------------------------------------------------------\n");
  printf("-- Design Filename:\n");
  printf("\n\t\t%s\n\n", 	design_file);
  printf("-----------------------------------------------------------------\n");
  printf("-- Output Files\n\n");
  printf("\tControl File     :   %s\n", dri_file );
  printf("\tLabel File       :   %s\n", drv_file );
  printf("\tDisplay Set File :   %s\n", dst_file );
  printf("\tIGDS Design File :   %s\n", dgn_file );
  printf("\tColor Table File :   %s\n\n", VDXclr_tbl_file );
  printf("\tProcess Log File :   %s\n\n", rpt_file );
  printf("-----------------------------------------------------------------\n");
  return (0);
}

/****************************************************************************/

long  VDXpre_process (mode, all_or_evgen, form)
int	mode;
int	all_or_evgen;
Form	form;
{
     char filename[40];
     char class_name[132];
     struct GRid temp;
     IGRint msg, count, size_ob;
     double pnt[3];

     SetProc( VDXpre_process );

     strcpy (filename, "VDXpre_process");
      
     if (all_or_evgen)
     {
          /**  BW. 8/4/94  -  Readiness review committee asked that this
               change from all elements in file to Elements in view.   ****/

          /*** Get the elements in the view  ***/
	  __DBGpr_com(" VDXpre_process all_or_evgen ");

          ci$get (point = pnt, prompt = "Select the view");
          ci$put (cmd = "Elements In View");
          ci$put (point = pnt);
     }

#ifdef	NOT_NEEDED
/*******   Allow user to request action since he/she chose Event Generator.
     else 
      {
         / **  BW. 5/16/94  ** /
         / **  Check to see if there is an active fence,  If there is, 
              use it.                                                  ** / 
          
         gr$gsget_fence (msg = &msg,
                         fence_id = &temp);

	 if ((msg == MSSUCC) || / ** A fence is defined, use it ** /
             (msg == OM_S_SUCCESS) )
          {
              ci$put (cmd = "Elements Inside and Overlapping Fence");
          }
       }
******/
#endif

      if( !ci$locate(	prompt = "Use Event Generator to Select Elements",
		        properties = LC_LC_ONLY | LC_DP_ONLY | LC_RW ,
		        owner_action = LC_RIGID_COMP
		        	| LC_RIGID_OWNER | LC_FLEX_COMP
				| LC_FLEX_OWNER | LC_REF_OBJECTS |
                           	  LC_NO_INVIS_OVERRIDE,
		         md_env = &VDXalt_env,
		         obj = &VDXobj.objid,
		         osnum = &VDXobj.osnum))
       {
           strcpy (VDXmsg_buf, "Cannot get objects from design file");
           VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
           return (VDX_F_NoGetObj);
       }

       if (mode == VDX_INTERACTIVE)
       {
	  strcpy (VDXmsg_buf, "Pre-processing...,  Please wait");
	  VDXcenter_message (form, FI_MSG_FIELD, VDXmsg_buf);
       }

      om$get_classname (objid = VDXobj.objid,
			osnum = VDXobj.osnum,
			classname = class_name);

      if ((strcmp (class_name, "GRgrset") == 0)  ||
	  (strcmp (class_name, "GRfcset") == 0 ))
      {
	  count = 0;

	  gr$gsinqcount (msg = &msg,
			 count = &count,
			 senderid = NULL_OBJID,
			 object_id = &VDXobj);

	  if ( (msg != MSSUCC) || (count <= 0) )
	   {
               strcpy (VDXmsg_buf, "Cannot get objects from graphic set");
               VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
               return (VDX_F_NoGetObj);
	   }

	  VDXcount = count;

	  __DBGpr_int(" #Elements Found ", count );

	  size_ob = count * sizeof (struct GRobj_env);

	  VDXptr = malloc (size_ob);
	  if (VDXptr == NULL)
	  {
              sprintf (VDXmsg_buf,  
                       "FATAL: Memory allocation error size = <%d> bytes",
                       size_ob); 
              VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
              return (VDX_F_MemAllErr);
	  }
          VDXobj_env = (struct GRobj_env *) VDXptr;

	  gr$gsget_objects (msg = &msg,
			    array = VDXobj_env,
			    size = size_ob,
			    count = &count,
			    from_obj = 0,
			    to_obj = count - 1,
			    senderid = NULL_OBJID,
			    object_id = &VDXobj);
	  CheckRC( msg, 1 );
      }
      else
      {

	  __DBGpr_com(" Preprocess 1 object ");
	  count = 1;
	  VDXcount = count;
	  size_ob = count * sizeof (struct GRobj_env);

/*
	  VDXgr_grp = (struct GRid *) malloc (count * sizeof (struct GRid));
	  if (VDXgr_grp == NULL)
	   {
              sprintf (VDXmsg_buf,  
                       "FATAL: Memory allocation error size = <%d> bytes",
                       count * sizeof (struct GRid)); 
              VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
              return (VDX_F_MemAllErr);
	   }
*/
/*
	  VDXcopies = (struct GRid *) malloc (count * sizeof (struct GRid));
	  if (VDXcopies == NULL)
	   {
              sprintf (VDXmsg_buf,  
                       "FATAL: Memory allocation error size = <%d> bytes",
                       count * sizeof (struct GRid)); 
              VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
              return (VDX_F_MemAllErr);
	   }
*/
	  VDXptr = malloc (size_ob);
	  if (VDXptr == NULL)
	   {
              sprintf (VDXmsg_buf,  
                       "FATAL: Memory allocation error size = <%d> bytes",
                       size_ob); 
              VDXdebug (1, VDXlog_file, filename, VDXmsg_buf); 
              return (VDX_F_MemAllErr);
	   }

          VDXobj_env = (struct GRobj_env *) VDXptr;
	  VDXobj_env[0].obj_id = VDXobj;
	  VDXobj_env[0].mod_env = VDXalt_env;
      }

    End
    return (VDX_S_SUCCESS);
}



/****************************************************************************
 *                                                                          *
 *  Routine:   VDXprocess                                                   *
 *  Date:      June 2, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This routine performs the translation of the objects in VDXobj_env into *
 *  IGDS primitives.                                                        * 
 *                                                                          *
 ****************************************************************************/

long VDXprocess( mode )
int	mode;
{
    int  i, j;
    char		class_name[132];
    char		echoProc[200];
    char		filename[40];
    struct GRid temp_obj;
    struct GRobj_env	*PRCobj_env ;
    IGRint		PRCcount ;
    IGRint msg, sts ;
    unsigned short prop_mask;

    SetProc( VDXprocess ); Begin

    strcpy (filename, "VDXprocess");
    PRCobj_env = NULL ;
    PRCcount   = 0 ;
    for(i=0;i<4;i=i+1) VDXgg[i] = 0;
    VDXgg[3] = 0; /* initialize the graphic group count */

#ifdef	vdsDEBUG
    for (i = 0; i < VDXcount; i = i + 1)
	VD_ShowObj( &VDXobj_env[i].obj_id );
#endif
    /*
     * Preprocess the set.
     */
    sts = vd$filter_objects(	msg	= &msg,
				iCount	= VDXcount,
				iList	= VDXobj_env,
				oCount  = &PRCcount,
				oList	= &PRCobj_env );

    __DBGpr_int(" VDXcount ", VDXcount );
    __DBGpr_int(" PRCcount ", PRCcount );

#ifdef	vdsDEBUG
    for (i = 0; i < PRCcount; i = i + 1)
	VD_ShowObj( &PRCobj_env[i].obj_id );
#endif

    VDXtypes.object_count = VDXcount;
    j = 0;

    for (i = 0; i < PRCcount; i = i + 1)
    {

/*
 * Add the stop process to leave process.
 */
	if( mode == VDX_INTERACTIVE ){
	  if( IGEstop() ){
		/*
		 * Request to stop process
		 */
		goto wrapup ;
	  }

          sprintf( echoProc, "Processing %.0f%% ",
                                (double)(i*100./(double)PRCcount) );
	  UI_echo( echoProc );
	}

        om$get_classname (objid = PRCobj_env[i].obj_id.objid,
                          osnum = PRCobj_env[i].obj_id.osnum,
                          classname = class_name);

        /*
	 * IGNORE VDS PLANE SYSTEMS
	 */
        if (strcmp (class_name, "VRplane") == 0) continue;

        if( om$is_ancestry_valid ( subclassname = class_name,
		             superclassname = "SMInfPlane")  == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
		             superclassname = "VDSInfPl")    == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
		             superclassname = "SMfrm_syst")  == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
		             superclassname = "VRCnrlSeg")   == OM_S_SUCCESS ||
            om$is_ancestry_valid (  subclassname = class_name,
			     superclassname = "SMframe")     == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
			     superclassname = "GRreffile")   == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
		             superclassname = "GRgencs")     == OM_S_SUCCESS ){

	    __DBGpr_obj(" Not Processed ", PRCobj_env[i].obj_id );

	    continue;
	}

        sprintf( VDXmsg_buf,
		"\nProcess [%d,%d],\tClass: %s\t-----------------------\n",
			PRCobj_env[i].obj_id.osnum,
			PRCobj_env[i].obj_id.objid, class_name);
        VDXdebug( 0, VDXlog_file, NULL, VDXmsg_buf ); 

        VDXtypes.processed = VDXtypes.processed + 1;

	__DBGpr_com(" -------------------------------------------------------");
	__DBGpr_obj(" To process ", PRCobj_env[i].obj_id );
	__DBGpr_str(" Classname  ", class_name );

        VDXgg[0] = (IGRshort ) PRCobj_env[i].obj_id.objid;
        VDXgg[1] = (IGRshort ) PRCobj_env[i].obj_id.osnum;
	VDXgg[2] = 0;
        VDXgg[3] = VDXgg[3] + 1; /* increment the graphic group counter */

	if (om$is_ancestry_valid ( subclassname = class_name,
                           superclassname = "ACcpx") == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
                           superclassname = "EMScomposite") == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
                           superclassname = "GRclhdr") == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
                           superclassname = "GRsmhdr") == OM_S_SUCCESS ||
            om$is_ancestry_valid ( subclassname = class_name,
                           superclassname = "ASnode") == OM_S_SUCCESS)
	 {
	    __DBGpr_com(" Process Type 1 ");
	    gr$get_symbology ( object_id = &PRCobj_env[i].obj_id,
		               symb = &VDXsymbology);

	    VDXprocess_object(	PRCobj_env[i].obj_id,
				PRCobj_env[i].mod_env);
	}
	else if (om$is_ancestry_valid ( subclassname = class_name,
	                   superclassname = "EMSsubbs") == OM_S_SUCCESS)
	{
	    __DBGpr_com(" Process Type 2 ");

	    gr$get_symbology ( object_id = &PRCobj_env[i].obj_id,
		               symb = &VDXsymbology);

	    VDXprocess_graphics(&PRCobj_env[i].obj_id,
				&PRCobj_env[i].mod_env);
	}
	else{
	    __DBGpr_com(" Process Type Error ");

            sprintf (VDXmsg_buf,  
                     "\tObject Not Processed [%d,%d].",
					PRCobj_env[i].obj_id.osnum,
					PRCobj_env[i].obj_id.objid);
            VDXdebug (0, VDXlog_file, NULL, VDXmsg_buf); 
	}
     }			/* end of for count */

wrapup:

    if( VDXptr )	free (VDXptr); 		VDXptr = NULL;
 //   if( VDXgr_grp )	free (VDXgr_grp);	VDXgr_grp = NULL;
 //   if( VDXcopies )	free (VDXcopies);	VDXcopies = NULL;
    if( PRCobj_env )	free( PRCobj_env );	PRCobj_env = NULL ;

    UI_echo( "" );
    strcpy (VDXmsg_buf, "Successful completion");
    status (VDXmsg_buf);

    End
    return (VDX_S_SUCCESS);
} 




/****************************************************************************
 *                                                                          *
 *  Routine:   VDXwrite_dst                                                 *
 *  Date:      June 2, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This routine will create the Design Review (DRV) display set file.      *
 *  This file is hardcoded.                                                 * 
 *                                                                          *
 ****************************************************************************/

long VDXwrite_dst (dst_filename)  
  char *dst_filename;
{
    char filename[40];

    strcpy (filename, "VDXwrite_dst");
    VDXdst_outfile = (MYFILE *) fopen (dst_filename, "w");
    if (VDXdst_outfile == NULL)
     {
        write ("WARNING: Cannot create the Display Set file");
        write ("\n");
        if (errno ==  EEXIST) 
           sprintf (VDXmsg_buf, "<%s> file already exists", dst_filename);
        else 
           sprintf (VDXmsg_buf, "Cannot create <%s> no write permission",
                    dst_filename);
        VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
        strcat (VDXmsg_buf, "\n");
        status (VDXmsg_buf);
        return (VDX_F_FileNoWr);
     }
    else
     {
        fprintf (VDXdst_outfile, "%s\n", "Display Set File Version 1.0");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " [DEFINITION SECTION]");
        fprintf (VDXdst_outfile, "%s\n", " <Display Set>");
        fprintf (VDXdst_outfile, "%s\n", " 1 equipment");
        fprintf (VDXdst_outfile, "%s\n", " equipment");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Definition>");
        fprintf (VDXdst_outfile, "%s\n", "  FIND Data eqp_family:= *");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Display Set>");
        fprintf (VDXdst_outfile, "%s\n", " 2 struct plates");
        fprintf (VDXdst_outfile, "%s\n", " plates");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Definition>");
        fprintf (VDXdst_outfile, "%s\n", "  FIND Data family_name:= plates");
        fprintf (VDXdst_outfile, "%s\n", "  ADD Data family_name:= PLATES");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Display Set>");
        fprintf (VDXdst_outfile, "%s\n", " 3 struct beams");
        fprintf (VDXdst_outfile, "%s\n", " beams");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Definition>");
        fprintf (VDXdst_outfile, "%s\n", "  FIND Data family_name:= beams");
        fprintf (VDXdst_outfile, "%s\n", "  ADD Data family_name:= BEAMS");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Display Set>");
        fprintf (VDXdst_outfile, "%s\n", " 4 hvac");
        fprintf (VDXdst_outfile, "%s\n", " hvac");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Definition>");
        fprintf (VDXdst_outfile, "%s\n", "  FIND Data service:= air");
        fprintf (VDXdst_outfile, "%s\n", "  ADD Data service:= AIR");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Display Set>");
        fprintf (VDXdst_outfile, "%s\n", " 5 piping");
        fprintf (VDXdst_outfile, "%s\n", " piping");
        fprintf (VDXdst_outfile, "%s\n", " ");
        fprintf (VDXdst_outfile, "%s\n", " <Definition>");
        fprintf (VDXdst_outfile, "%s\n", "  FIND Data fluid_code:= *");
        fprintf (VDXdst_outfile, "%s\n", " ");
     }
    fclose (VDXdst_outfile);
    return (VDX_S_SUCCESS);
}



/****************************************************************************
 *                                                                          *
 *  Routine:   VDXwrite_rpt_heading                                         *
 *  Date:      June 2, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This routine will create the Design Review (DRV) display set file.      *
 *  This file is hardcoded.                                                 * 
 *                                                                          *
 ****************************************************************************/

long VDXwrite_rpt_heading (log_file)  
  FILE *log_file;
{

  struct tm
    {				/* see ctime(3) */
      int tm_sec;
      int tm_min;
      int tm_hour;
      int tm_mday;
      int tm_mon;
      int tm_year;
      int tm_wday;
      int tm_yday;
      int tm_isdst;
    };

   extern char *getlogin ();
   extern strftime ();
   extern gethostname ();
/**
   extern long *time ();
**/
   extern struct tm *localtime ();
 
   struct tm *tm_ptr;
   long  tp;
   char  fmt_time[64], *user_name, node_name[32];
 
   fmt_time[0] = '\0';
   node_name[0] = '\0';
   tm_ptr = NULL;
   user_name = NULL;
   time (&tp);
   VDXstart_time = tp;
   tm_ptr = localtime (&tp);
   strftime (fmt_time, 64, "Date: %m/%d/%y %H:%M", tm_ptr);
   gethostname (node_name, 32);
   user_name = getlogin ();
 
   fprintf (log_file, "%s\n", "EXTRACT FOR REVIEW\n\n");
   fprintf (log_file, "%s\n\n", fmt_time);
   if (user_name)
      fprintf (log_file, "Username: %s\n\n", user_name);
   else
      fprintf (log_file, "Username: %s\n\n", "NO USERNAME");
   fprintf (log_file, "Nodename: %s\n\n", node_name);

   return (VDX_S_SUCCESS);
}
 



/****************************************************************************
 *                                                                          *
 *  Routine:   VDXwrite_dri                                            *
 *  Date:      June 2, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This routine will create the Design Review (DRV) Control file (.dri).   *
 *                                                                          *
 ****************************************************************************/

long VDXwrite_dri (dri_filename, dgn_filename, drv_filename)  
  char *dri_filename;
  char *dgn_filename;
  char *drv_filename;
{
   char tmp_str[256];
   char *str_ptr;
   int i, j, k, x;
   char filename[40];

   strcpy (filename, "VDXwrite_dri");
   VDXdri_outfile = (MYFILE *) fopen (dri_filename, "w");
   if (VDXdri_outfile == NULL)
    {
        write ("FATAL: Cannot create the Control File");
        write ("\n");
        if (errno ==  EEXIST) 
           sprintf (VDXmsg_buf, "<%s> file already exists", dri_filename);
        else 
           sprintf (VDXmsg_buf, "Cannot create <%s> no write permission",
                    dri_filename);
        VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
        strcat (VDXmsg_buf, "\n");
        status (VDXmsg_buf);
        return (VDX_F_FileNoWr);
    }

   fprintf (VDXdri_outfile, "DesignReview_Control {\n");
   fprintf (VDXdri_outfile,
            "area { -2147483648 -2147483648 -2147483648 2147483648  2147483648  2147483648 } \n");

   /**   Strip off the path (per Gopal).  **/ 

   k = strlen (dgn_filename);
   j = k;
   while (j > 0)
    {
       if (dgn_filename[j] == '/')
          break;
       j = j - 1;
    }

   x = 0;
   for (i = j + 1; i < k; i = i + 1) 
    {
       tmp_str[x] = dgn_filename[i];  /* this should get the NULL char */ 
       x = x + 1;
    }
   tmp_str[x] = '\0';
   fprintf (VDXdri_outfile, "dgn { name {%s} ", tmp_str);


   k = strlen (drv_filename);
   j = k;
   while (j > 0)
    {
       if (drv_filename[j] == '/')
          break;
       j = j - 1;
    }

   x = 0;
   for (i = j + 1; i < k; i = i + 1) 
    {
       tmp_str[x] = drv_filename[i];  /* this should get the NULL char */ 
       x = x + 1;
    }
   tmp_str[x] = '\0';
   fprintf (VDXdri_outfile, "label{%s} } \n}\n", tmp_str);

   fclose (VDXdri_outfile);
   return (VDX_S_SUCCESS);
}


/****************************************************************************
 *                                                                          *
 *  Routine:   VDXwrite_htm                                                 *
 *  Date:      Aug 18, 1996                                                 *
 *             Jim Hanson                                                   *
 *                                                                          *
 *  This routine will create the HTML webbrouser file (.htm).               *
 *                                                                          *
 ****************************************************************************/

long VDXwrite_htm (htm_filename, vds_filename)
  char *htm_filename;
  char *vds_filename;
{
   char tmp_str[256];
   char *str_ptr;
   int i, j, k, x;
   char filename[40];
   char model_file[40];
   char temp[40];
   char *result;

   strcpy (filename, "VDXwrite_htm");
   VDXhtm_outfile = (MYFILE *) fopen (htm_filename, "w");
   if (VDXhtm_outfile == NULL)
   {
 	printf ("FATAL: Cannot create the HTML File\n");
        if (errno ==  EEXIST)
           sprintf (VDXmsg_buf, "<%s> file already exists", htm_filename);
        else
           sprintf (VDXmsg_buf, "Cannot create <%s> no write permission",
                    htm_filename);
        VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
        strcat (VDXmsg_buf, "\n");
        status (VDXmsg_buf);
        return (VDX_F_FileNoWr);
   }

   fprintf (VDXhtm_outfile, "<HTML>\n<HEAD>\n<TITLE>%s Desc</TITLE></HEAD><BODY>\n",htm_filename);
   sprintf(model_file, "%s", vds_filename);
   result = strtok(model_file, "/");
   while (result != NULL)
   { 
     sprintf(temp,"%s", result);
     result = strtok(NULL, "/");
     if(result != NULL)
       temp[0] = '\0';
   }
   fprintf (VDXhtm_outfile, "<H2><STRONG><CENTER>This is description of the components in file %s</CENTER></STRONG>\n", temp);
   return (VDX_S_SUCCESS);
}


/****************************************************************************
 *                                                                          *
 *  Routine:   VDXinit_drv_file                                             *
 *  Date:      June 2, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This routine will open the Design Review (DRV) Label file (.drv).       *
 *  and write the PDS file type entry to it.                                *
 *                                                                          *
 ****************************************************************************/

long VDXinit_drv_file (drv_filename)  
  char *drv_filename;
{
   char filename[40];

   strcpy (filename, "VDXinit_drv_file");
   VDXdrv_outfile = (MYFILE *) fopen (drv_filename, "w");
   if (VDXdrv_outfile == NULL)
    {
        write ("FATAL: Cannot create the Label File");
        write ("\n");
        if (errno ==  EEXIST) 
           sprintf (VDXmsg_buf, "<%s> file already exists", drv_filename);
        else 
           sprintf (VDXmsg_buf, "Cannot create <%s> no write permission",
                    drv_filename);
        VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
        strcat (VDXmsg_buf, "\n");
        status (VDXmsg_buf);
        return (VDX_F_FileNoWr);
    }

   fprintf (VDXdrv_outfile, "\npds_file_type{ 2 00 }\n");

   return (VDX_S_SUCCESS);
}

/****************************************************************************
 *                                                                          *
 *  Routine:   VDXinit_dgn_file                                             *
 *  Date:      June 7, 1994                                                 *
 *             Bureden Warren.                                              *
 *                                                                          *
 *  This routine will open the IGDS Design file (.dgn) and use the          *
 *  seed3d.dgn  seedfile to write the header and default information to the *
 *  IGDS file.                                                              *
 *                                                                          *
 ****************************************************************************/

long  VDXinit_dgn_file (dgn_filename)
  char *dgn_filename;
{

#define SUC	134250505

   double number[1];
   double newnum[1];
   char WU[3];
   char mess[256];
   unsigned short *wu;
   IGRboolean view_overflow;
   IGRboolean ext_type_nine;
   IGRshort write_init;
   IGRint go;
   IGRint msg;
   IGRint read_stat;
   IGRint stat;
   IGRlong sts;
   struct GRid view_setup[100];
   char filename[40];
   char txt[132]; 

#ifdef DEBUG
   int nn;
#endif

   extern int GRcvt_value_to_value ();

   strcpy (filename, "VDXinit_dgn_file");
   VDXIGDS_filedesc = open (dgn_filename, GUREAD_WRITE, GUACCESS_MODE);

   if (VDXIGDS_filedesc == -1)
   {
       sprintf( txt, "touch %s ", dgn_filename );
       stat =  system (txt);
       if( stat != 0 ){
	  write ("FATAL: ", txt, " Failed \n");
	  return (VDX_F_FileNoWr);
       }

       VDXIGDS_filedesc = open (dgn_filename, GUREAD_WRITE, GUACCESS_MODE);
       if (VDXIGDS_filedesc == -1)
        {
           write ("FATAL: Cannot create the IGDS File");
           write ("\n");
           if (errno ==  EEXIST) 
              sprintf (VDXmsg_buf, "<%s> file already exists", dgn_filename);
           else 
              sprintf (VDXmsg_buf, "Cannot create <%s> no write permission",
                       dgn_filename);
           VDXdebug (1, VDXlog_file, filename, VDXmsg_buf);
           strcat (VDXmsg_buf, "\n");
           status (VDXmsg_buf);
           return (VDX_F_FileNoWr);
        }
   }

   ext_type_nine = FALSE;
   view_overflow = FALSE;
   write_init = GUWRITE_INIT;

   stat = GUwrite_element (&msg, VDXcvt_buffers.dgn_buf,
			   VDXcvt_buffers.ele_buf, &VDXcvt_buffers.ele_type,
			   &VDXcvt_buffers.ele_size, &VDXIGDS_filedesc,
			   &write_init, &VDXblock_ptr, &VDXbyte_ptr);

   read_stat = TRUE;
   VDXcvt_buffers.ele_type = -1;

   while (read_stat == TRUE)
   {

      read_stat = GUget_next_ele (&sts, &VDXcvt_buffers);

      if (sts != GULAST_ELEMENT)
      {


	  //  Check for type 9 and set up the view information
	  //  and active parameters.


	  VDXele_type = ((*((IGRshort *) VDXcvt_buffers.ele_buf)) & 0x7f00) >> 8;

	  if (VDXele_type == 9 && go == 0)
	    {
	      wu = (unsigned short *) VDXcvt_buffers.ele_buf;
	      VDXscale = wu[557];
	      VDXscale = VDXscale * wu[559];
	      WU[0] = wu[560];
	      WU[1] = wu[560] >> 8;
	      WU[2] = 0;

	      number[0] = 1;

	      GRcvt_value_to_value (&msg, "UOM_DISTANCE", 2,
				    WU, NULL, 1, number, newnum);

	      if (msg != SUC)
		{
		  strcpy (mess, WU);
		  strcat (mess, " is not a defined working unit");
		  status (mess);
		  newnum[0] = 1;
		}

	      VDXscale = VDXscale / newnum[0];

#ifdef DEBUG
	      write ("working units=", WU, " * ", VDXscale, '\n');
	      for (nn = 557; nn < 560; nn = nn + 1)
		{
		  write ("nn[", nn, "]=", wu[nn], '\n');
		}
#endif
	      go = 1;
	    }

	  if ((((*((IGRshort *) VDXcvt_buffers.ele_buf))
		& 0x7f00) >> 8) == 9)
	    {
	      GUotype9 (&msg, VDXcvt_buffers.ele_buf,
			view_setup, &VDXscale_factor, NULL);

	      if (!ext_type_nine)

		{

		  GUotype9 (&msg, VDXcvt_buffers.ele_buf,
			    view_setup, &VDXscale_factor, NULL);

		  if (msg == GUVIEW_OVERFLOW)
		    {
		      view_overflow = TRUE;
		    }
		  ext_type_nine = TRUE;
		}
	    }


	  stat = GUwrite_element (&msg, VDXcvt_buffers.dgn_buf,
				  VDXcvt_buffers.ele_buf,
				  &VDXcvt_buffers.ele_type,
				  &VDXcvt_buffers.ele_size,
				  &VDXIGDS_filedesc,
				  &VDXwrite_mode,
				  &VDXblock_ptr,
				  &VDXbyte_ptr);
	}
    }

    __DBGpr_str(" Call Color Table ", VDXclr_tbl_file );
    VDXotype5lv1(	&msg,
			VDXclr_tbl_file,
			&VDXIGDS_filedesc,
			VDXcvt_buffers.dgn_buf,
			&VDXcvt_buffers.ele_buf,
			&VDXcvt_buffers.ele_size );

    return (VDX_S_SUCCESS);
}

