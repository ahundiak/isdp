#include "header.h"
#include "VDct1Attrs.h"
#include "VDris2.h"
#include "VDct1Part.h"

/* -------------------------------------------------
 * Individual stage information for NODE_INDEX
 */
IGRstat getNodeTypeInfo()
{
  NODE_CNT = 3;
  
  switch(NODE_INDEX) {

  case 0:
    strcpy(NODE_TYPE_INFO.type, VDCT1_NODE_TYPE_STD_PART4);
    strcpy(NODE_TYPE_INFO.desc, "STD PART[4]");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"");
    return 1;

  case 1:
    strcpy(NODE_TYPE_INFO.type, VDCT1_NODE_TYPE_NOUN_NAME);
    strcpy(NODE_TYPE_INFO.desc, "NOUN_NAME");
    strcpy(NODE_TYPE_INFO.level,"U01");
    strcpy(NODE_TYPE_INFO.table,"");
    return 1;

  case 2:
    strcpy(NODE_TYPE_INFO.type, VDCT1_NODE_TYPE_STD_PARTS);
    strcpy(NODE_TYPE_INFO.desc, "STANDARD PARTS");
    strcpy(NODE_TYPE_INFO.level,"002");
    strcpy(NODE_TYPE_INFO.table,"");
    return 1;
  }
  
  memset(&NODE_TYPE_INFO,0,sizeof(TVDctNodeTypeInfo));

  return 0;
}

/* -------------------------------------------------
 * Class filters, all root
 */
IGRstar getFilter()
{
  om$get_classid(classname = "VDSroot",
		 p_classid = &CLASS_LIST.p_classes[0]);
  CLASS_LIST.w_count = 1;

  return 1;
}

/* -------------------------------------------------
 * Assorted information about the set type
 */
IGRstar getSetTypeInfo()
{

  strcpy(SET_TYPE_INFO.type,"StdParts");
  strcpy(SET_TYPE_INFO.rev, "000");
  strcpy(SET_TYPE_INFO.desc,"Standard Parts Catalog");
  
  strcpy(SET_TYPE_INFO.nodeTable,"");
  strcpy(SET_TYPE_INFO.leafTable,"");

  return 1;
}

/* -------------------------------------------------
 * Say something if ppl is run by user
 */
main()
{
  getSetTypeInfo();

  printf("%s %s %s\n",
    SET_TYPE_INFO.type,
    SET_TYPE_INFO.rev,
    SET_TYPE_INFO.desc);

  return 1;
}

/* --------------------------------------------------
 * Used to retrieve attribute information
 */
IGRint        ATTR_INDEX; // Attribute Index
TVDctAttrName ATTR_NAMEX; // Attribute Name
TVDctAttrInfo ATTR_INFO;  // Attribute Information

/* --------------------------------------------------
 * For a given set wide attribute name, fill in the info
 * I - ATTR_NAMEX
 * O - ATTR_INFO
 */
IGRstat getAttrInfo()
{ 
  IGRstat retFlag;
  
  // Init 
  retFlag = 1;
  memset(&ATTR_INFO,0,sizeof(TVDctAttrInfo));

#include "attribute.h"

  // Not found
  retFlag = 0;
  
wrapup:
  return retFlag;
}

/* ---------------------------------------------------------------
 * Returns attribute name for a particular node type as
 * I - NODE_TYPE 
 * I - ATTR_INDEX
 * O - ATTR_NAMEX
 */

IGRstat getNodeAttrName()
{ 
  IGRstat retFlag;
  
  // Init 
  retFlag = 1;
  *ATTR_NAMEX = 0;
  
  if (!strcmp(NODE_TYPE,VDCT1_NODE_TYPE_STD_PART4)) {
    
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_ITEM_CAGE_NUM); goto wrapup;
    case  1: strcpy(ATTR_NAMEX,VDCT1_ATTR_ITEM_DESC);     goto wrapup;
    case  2: strcpy(ATTR_NAMEX,VDCT1_ATTR_ITEM_UM);       goto wrapup;
    case  3: strcpy(ATTR_NAMEX,VDCT1_ATTR_ITEM_REV);      goto wrapup;
    case  4: strcpy(ATTR_NAMEX,VDCT1_ATTR_ITEM_DATE);     goto wrapup;
      
    }
    
  }

  // Not found
  retFlag = 0;
    
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Called when node is created
 * I - NODE_PARENT_ID       If NULL_OBJID, top node, use SET_ID
 * I - SET_ID               Used for top node in tree
 * I - NODE_TYPE
 * I - NODE_NAME
 * O - NODE_ID
 *
 * Not alot of error checking here, rely on the
 * calling program to do things right
 */
IGRstat createNode()
{
  IGRstat       retFlag;
  TVDfld        fld;
  
  // Init
  retFlag = 0;
  NODE_ID.objid = NULL_OBJID;

  if (NODE_PARENT_ID.objid == NULL_OBJID) NODE_ID.osnum = SET_ID.osnum;
  else                                    NODE_ID.osnum = NODE_PARENT_ID.osnum;
  
  // Make the set object
  vdct1$CreateBaseObject(osnum     = NODE_ID.osnum,
                         classType = VDCT1_CLASS_TYPE_NODE,
                         objID     = &NODE_ID);
  if (NODE_ID.objid == NULL_OBJID) goto wrapup;

  // Connect to parent or the set
  if (NODE_PARENT_ID.objid == NULL_OBJID) {
    
    vdct1$ConnectMgrChild(mgrID   = &SET_ID,
			  childID = &NODE_ID);

    vdct1$GetBaseInfo(objID = &SET_ID, baseInfo = &BASE_INFO);

  }
  else {
    vdct1$ConnectTree1Child(treeID  = &NODE_PARENT_ID,
			    childID = &NODE_ID);

    vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &BASE_INFO);
  }
  
  // Set info
  strcpy(BASE_INFO.nodeName,NODE_NAME);
  strcpy(BASE_INFO.nodeType,NODE_TYPE);
  
  vdct1$SetBaseInfo(objID = &NODE_ID, baseInfo = &BASE_INFO);

  // Sets ATTR_NAMEX for each available attribute
  for(ATTR_INDEX = 0; getNodeAttrName(); ATTR_INDEX = ATTR_INDEX + 1) {
     
    // Get the full info
    getAttrInfo();

    // Check for setup error
    if (*ATTR_INFO.name != 0) {
	
      // printf("Adding Attribute %s\n",ATTR_INFO.name);
      
      vdfld$Set(fld  = &fld, 
		name = ATTR_INFO.name, 
		type = ATTR_INFO.type);

      vdcol$UpdAttrs(objID = &NODE_ID, 
		     fld   = &fld, 
		     cnt   = 1);
    }
  }
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Called when user tries to expand or contract
 */
IGRstat preExpandContractNode()
{
  IGRstat retFlag;
  IGRstat sts;

  TVDrisInfo ris;
  
  IGRchar msg[64];
  
  TGRid   nodeID;
  TGRid   nounID;
  TGRid   parentID;

  IGRchar prev[2];
  
  TVDfld  fld;

  // Init
  retFlag = 0;

  // printf("PreExpand Node %s '%c'\n",BASE_INFO.nodeType,*OP);

  // Only process if not done before
  if (*OP != ' ') goto wrapup;

  // Becomes the parent
  NODE_PARENT_ID = NODE_ID;

  // For the top level
  if (!strcmp(BASE_INFO.nodeType,VDCT1_NODE_TYPE_STD_PARTS)) {

    // Make this
    strcpy(NODE_TYPE,VDCT1_NODE_TYPE_NOUN_NAME);
    UI_status("NOUN NAME Query...");

    // Get the list
    vdris$InitInfo(info = &ris);
    VDct1QryDistinctNounNamesFromItems(&ris);
    if (ris.rows < 1) {
      UI_status("Query for noun_names failed");
      goto wrapup;
    }
    sprintf(msg,"Processing %d noun names",ris.rows);
    UI_status(msg);
    
    // Setup for nested nouns
    parentID = NODE_PARENT_ID;
    strcpy(prev," ");
    
    // Cycle through
    for(ris.i = 0; ris.i < ris.rows; ris.i = ris.i + 1) {

      if (*ris.buf[ris.i] != *prev) {
	*prev = *ris.buf[ris.i];
	NODE_PARENT_ID = parentID;	
	strcpy(NODE_NAME,prev);
	createNode();
	NODE_PARENT_ID = NODE_ID;
      }
      strcpy(NODE_NAME,ris.buf[ris.i]);
      createNode();
    }
    NODE_PARENT_ID = parentID;	
  
    // Free the buffer
    sprintf(msg,"Processed %d noun names",ris.rows);
    vdris$FreeInfo(info = &ris);

    // Done for this
    strcpy(OP,"-");
    UI_status(msg);
    retFlag = 1;
    goto wrapup;

  }

  // For a noun_name
  if (!strcmp(BASE_INFO.nodeType,VDCT1_NODE_TYPE_NOUN_NAME)) {

    // Make this
    strcpy(NODE_TYPE,VDCT1_NODE_TYPE_STD_PART4);
    UI_status("STANDARD PART Query...");

    // Get the list
    vdris$InitInfo(info = &ris);
    VDct1QryNounNameFromItems(&ris,BASE_INFO.nodeName);
       
    // Verify got something
    if (ris.rows < 1) {
      UI_status("Query for standard parts failed");
      goto wrapup;
    }
    sprintf(msg,"Processing %d parts",ris.rows);
    UI_status(msg);
    
    // Cycle through
    for(ris.i = 0; ris.i < ris.rows; ris.i = ris.i + 1) {

      ris.j = ris.i * ris.cols;
      
      strcpy(NODE_NAME,ris.buf[ris.j+VDCT1_RIS_COLI_ITEMS_ITEM_CAGE_NUM]);
      createNode();

      // Xfer Attributes
      vdcol$GetAttr (objID = &NODE_ID, name = VDCT1_ATTR_ITEM_CAGE_NUM, fld = &fld);
      strcpy(fld.val.txt,ris.buf[ris.j+VDCT1_RIS_COLI_ITEMS_ITEM_CAGE_NUM]);
      vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);

      vdcol$GetAttr (objID = &NODE_ID, name = VDCT1_ATTR_ITEM_REV, fld = &fld);
      strcpy(fld.val.txt,ris.buf[ris.j+VDCT1_RIS_COLI_ITEMS_ITEM_REV]);
      vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);

      vdcol$GetAttr (objID = &NODE_ID, name = VDCT1_ATTR_ITEM_UM, fld = &fld);
      strcpy(fld.val.txt,ris.buf[ris.j+VDCT1_RIS_COLI_ITEMS_UNIT_OF_MEASURE]);
      vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);

      vdcol$GetAttr (objID = &NODE_ID, name = VDCT1_ATTR_ITEM_DESC, fld = &fld);
      strcpy(fld.val.txt,ris.buf[ris.j+VDCT1_RIS_COLI_ITEMS_COPICS_SHORT_DESC]);
      vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);

      vdcol$GetAttr (objID = &NODE_ID, name = VDCT1_ATTR_ITEM_DATE, fld = &fld);
      strcpy(fld.val.txt,ris.buf[ris.j+VDCT1_RIS_COLI_ITEMS_UPDATEDATE]);
      vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);

    }
  
    // Free the buffer
    sprintf(msg,"Processed %d parts",ris.rows);
    vdris$FreeInfo(info = &ris);
    
    // Done for this
    strcpy(OP,"-");
    UI_status(msg);
    retFlag = 1;
    goto wrapup;

  }

  // Done
  retFlag = 1;

wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Returns the part_num (unique mino) in FLD
 * Different nodes will have different internal attributes
 */
IGRstat getPartNum()
{
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ITEM_NUM, fld = &FLD);
  return 1;
}
IGRstat getPartCageNum()
{
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ITEM_CAGE_NUM, fld = &FLD);
  return 1;
}
IGRstat getItemNum()
{
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ITEM_NUM, fld = &FLD);
  return 1;
}
IGRstat getItemCageNum()
{
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ITEM_CAGE_NUM, fld = &FLD);
  return 1;
}

/* --------------------------------------------------
 * Called when set is created
 * I - MGR_ID       set is linked to it, created using mgr osnum
 * I - SET_TYPE     Little bit redundant, keep for now
 * I - SET_TYPE_REV Use unless blank then use default
 * I = SET_NAME
 * O - SET_ID       NULL_OBJID if fails
 *
 * Not alot of error checking here, rely on the
 * calling program to check things
 */
IGRstat createSet()
{
  IGRstat       retFlag;
  TVDctBaseInfo baseInfo;
  
  // Init
  retFlag = 0;
  SET_ID.objid = NULL_OBJID;

  // Make the set object
  vdct1$CreateBaseObject(osnum     = MGR_ID.osnum,
                         classType = VDCT1_CLASS_TYPE_SET,
                         objID     = &SET_ID);
  if (SET_ID.objid == NULL_OBJID) goto wrapup;

  // Connect to manager
  vdct1$ConnectMgrChild(mgrID   = &MGR_ID,
   		        childID = &SET_ID);

  // Set info
  memset(&baseInfo,0,sizeof(TVDctBaseInfo));
  strcpy(baseInfo.setName,SET_NAME);
  strcpy(baseInfo.setType,SET_TYPE);

  if (*SET_TYPE_REV) strcpy(baseInfo.setTypeRev,SET_TYPE_REV);
  else {
    getSetTypeInfo();
    strcpy(baseInfo.setTypeRev,SET_TYPE_INFO.rev);
  }
  
  vdct1$SetBaseInfo(objID = &SET_ID, baseInfo = &baseInfo);

  // Create Top Level Node
  strcpy(NODE_TYPE,VDCT1_NODE_TYPE_STD_PARTS);
  strcpy(NODE_NAME,SET_NAME);
  NODE_PARENT_ID.objid = NULL_OBJID; 

  createNode();
  
  // Query the database and add in all the noun name nodes

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
