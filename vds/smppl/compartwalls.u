/* $Id: compartwalls.u,v 1.1.1.1 2001/01/04 21:07:36 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/smppl / compartwalls.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: compartwalls.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:36  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

#include "cieveryone.h"
#include "msdef.h"
#include "growner.h"
#include "cisend.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "emsdattyp.h"

#ifdef DEBUG
#	define STDOUT(x) printf( "%s\n", (x) )
#else
#	define STDOUT(x)
#endif

#define VERBOSE( x ) if( outputError ) { status( (x) ) ; STDOUT( (x) ) ; }

/*
 * Short cuts.
 */
#define _MD_ID		md_id.objid
#define _MD_OS		md_id.osnum
#define _MATRIX		md_env.matrix
#define _MATRIX_TYPE	md_env.matrix_type
#define	_grid		obj_id
#define	_objid		obj_id.objid
#define	_osnum		obj_id.osnum
#define _md_id		mod_env._MD_ID
#define _md_os		mod_env._MD_OS
#define _matrix		mod_env._MATRIX
#define _matrix_type	mod_env._MATRIX_TYPE

#define MACDEFNAME	"compartwalls"
#define PROFILE		0
#define FLOOR		1
#define CEILING		2
#define INPUTCOUNT	3
#define INPUT_1_CV	"profile"
#define INPUT_2_SF	"floor"
#define INPUT_3_SF	"ceiling"
#define OUTPUTCOUNT	20
#define OUTPUTPATTERN	"wall%d"
#define PATTERNSIZE	7

extern int	sprintf(),
		printf(),
		init_cnst_list() ;

struct GRmd_env	MOD_ENV ;
struct GRid	CI_MACRO_ID ;
int		outputError ;
/*----------------------------------------------------------------------------*/
main() {

	char		*input [ INPUTCOUNT],
			*output[OUTPUTCOUNT],
			buffer[OUTPUTCOUNT * PATTERNSIZE ],
			*b ;
	int		inputType [ INPUTCOUNT],
			outputType[OUTPUTCOUNT],
			i,
			n ;
	OM_S_OBJID	macroDefId ;
	long		sts ;

	input[PROFILE] = INPUT_1_CV ; inputType[PROFILE] = curve_generic ;
	input[FLOOR  ] = INPUT_2_SF ; inputType[FLOOR  ] = other_generic ;
	input[CEILING] = INPUT_3_SF ; inputType[CEILING] = other_generic ;

	b = buffer ;
	n = 0 ;
	for( i = 0 ; i < OUTPUTCOUNT ; i = i + 1 ) {
		output[i] = b + n ;
		n = n + 1 + sprintf( output[i], OUTPUTPATTERN, i ) ;
		outputType[i] = surface_generic ;		
	}

	macroDefId = NULL_OBJID ;
	ac$cimacdef(	cimacdef		= macroDefId,
			status			= &sts,
			name			= MACDEFNAME,
			temp_num		= INPUTCOUNT,
			temp_names		= input,
			temp_types		= inputType,
			extern_feet_num		= OUTPUTCOUNT,
			extern_feet_names	= output,
			external_feet_types	= outputType ) ;

	return 1 ;

} // main
/*----------------------------------------------------------------------------*/
int place() {

	long			msg ;
	struct GRid		output[OUTPUTCOUNT] ;
	int			noutputs,
				rc ;
	struct GRvg_construct	cst ;
	struct IGRdisplay	dsp ;

	init_cnst_list() ;
	get_symb() ;

	dsp.color	= cnst_list.color ;
	dsp.weight	= cnst_list.weight ;
	dsp.style	= cnst_list.style ;

	cst.msg		= &msg ;
	cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE ;
	cst.display	= &dsp ;
	cst.env_info	= &MOD_ENV ;
	cst.newflag	= 0 ;
	cst.level	= cnst_list.level ;
	cst.geometry	= NULL ;
	cst.class_attr	= NULL ;
	cst.name	= NULL ;

	outputError = TRUE ;
	rc = constructOutput( &cst, output, &noutputs ) ;
	if( rc ) {
		ci$send(msg	= message ci_macro.set_all_extern_feet(
						&msg, noutputs, output,
						&MOD_ENV ),
			targetid= CI_MACRO_ID.objid,
			targetos= CI_MACRO_ID.osnum ) ;
	}
	return rc ;

} // place
/*----------------------------------------------------------------------------*/
int compute() {

	long			msg ;
	struct GRid		output[OUTPUTCOUNT] ;
	int			noutputs,
				rc ;
	struct GRvg_construct	cst ;
	struct IGRdisplay	dsp ;

	/* Display & level don't matter at recompute since the macro
	 * software later sets them back to the values they had at placement
	 * time.
	 */
	dsp.color	= 1 ;
	dsp.weight	= 0 ;
	dsp.style	= 1 ;

	cst.msg		= &msg ;
	cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE ;
	cst.display	= &dsp ;
	cst.env_info	= &MOD_ENV ;
	cst.newflag	= 0 ;
	cst.level	= 1 ;
	cst.geometry	= NULL ;
	cst.class_attr	= NULL ;
	cst.name	= NULL ;

	outputError = FALSE ;
	rc = constructOutput( &cst, output, &noutputs ) ;
	if( rc ) {
		ci$send(msg	= message ci_macro.set_all_extern_feet(
						&msg, noutputs, output,
						&MOD_ENV ),
			targetid= CI_MACRO_ID.objid,
			targetos= CI_MACRO_ID.osnum ) ;
	}
	return rc ;

} // compute
/*----------------------------------------------------------------------------*/
#include "bsparameters.h"
extern double		BSdotp(),
			BSlenvec() ;
extern IGRboolean	BSmkvec(),
			BSnorvec(),
			BSorthovec(),
			BScrossp(),
			BSdistptpl(),
			MAidmx(),
			MAmulmx(),
			MAwclsmx(),
			MAlswcmx(),
			MAtypemx() ;
extern char		*malloc(),
			*memcpy() ;
extern void		free() ;
extern long		EFproject_any_curve_on_planen() ;
/*----------------------------------------------------------------------------*/
int constructOutput( cst, output, noutputs )

struct GRvg_construct	*cst ;
struct GRid		*output ;
int			*noutputs ; {

	long		sts,
			msg ;
	char		*input[INPUTCOUNT] ;
	struct GRobj_env
			inGR  [INPUTCOUNT] ;
	int		i,
			rc,
			floorParallelToCeiling,	/* TRUE/FALSE */
			prflWasProjected,
			nbComps ;
	struct GRid	assoc,
			prjOfPrfl,
			surfOfPrj,
			choppedOffSf,
			*component ;
	OMuword		pjClassid ;
	struct GRprops	gprops ;
	struct IGRplane	floor,
			ceiling ;
	IGRpoint	floorPnt,
			ceilingPnt,
			startPoint,
			endPoint ;
	IGRvector	floorNrm,
			ceilingNrm,
			globalZaxis,
			floorToCeiling,
			floorXceiling,	/* Vector floor x ceiling */
			translation ;
	IGRmatrix	trnslMx ;
	short		trnslMxType ;
	double		floorDotCeiling,
			floorToCeilingDotCeilingNrm,
			prjVecLen,
			t ;
	enum {
		nothingConstructed,
		surfaceCreated,
		surfaceDropped
	}		whereWasI ;

	whereWasI		= nothingConstructed ;
	prflWasProjected	= FALSE ;
	component		= NULL ;
	*noutputs		= 0 ;

	input[0] = INPUT_1_CV ; // Profile curve
	input[1] = INPUT_2_SF ; // 1st plane : floor
	input[2] = INPUT_3_SF ; // 2nd plane : ceiling

	for( i = 0 ; i < INPUTCOUNT ; i = i + 1 ) {

		// Gather input

		sts = ci$send(	msg	= message ACcpx.ACfind_temp_obj(
						&msg, input[i], &assoc ),
				targetid= CI_MACRO_ID.objid,
				targetos= CI_MACRO_ID.osnum ) ;
		if( !( sts & 1 & msg ) ) {
			VERBOSE( "Cannot get input" ) ;
			goto wrapup ;
		}
		/*
		 * Get graphics.
		 */
		sts = ci$send(	msg	= message NDnode.ASreturn_go(
							&inGR[i]._grid,
							&inGR[i]._matrix_type,
							inGR[i]._matrix ),
				targetid= assoc.objid,
				targetos= assoc.osnum ) ;
		if( !( sts & 1 ) ) {
			VERBOSE( "Cannot get gaphic input" ) ;
			goto wrapup ;
		}
	}

	floor.point	= floorPnt ;
	floor.normal	= floorNrm ;
	ceiling.point	= ceilingPnt ;
	ceiling.normal	= ceilingNrm ;

	/*
	 * Get the plane definitions of the floor and the ceiling; both planes
	 * will be considered as infinite.
	 */
	sts = ci$send(	msg	= message GRvg.GRdetplane(
						&msg,
						&inGR[FLOOR]._matrix_type,
						inGR[FLOOR]._matrix,
						&floor ),
			targetid= inGR[FLOOR]._objid,
			targetos= inGR[FLOOR]._osnum ) ;
	if( !( sts & 1 & msg ) ) {
		VERBOSE( "Input floor in not a plane" ) ;
		goto wrapup ;
	}
			
	sts = ci$send(	msg	= message GRvg.GRdetplane(
						&msg,
						&inGR[CEILING]._matrix_type,
						inGR[CEILING]._matrix,
						&ceiling ),
			targetid= inGR[CEILING]._objid,
			targetos= inGR[CEILING]._osnum ) ;
	if( !( sts & 1 & msg ) ) {
		VERBOSE( "Input ceiling in not a plane" ) ;
		goto wrapup ;
	}

	/*
	 * Project profile curve onto floor along z-vector of global
	 * coordinate system.
	 */
	globalZaxis[0] = globalZaxis[1] = 0 ; globalZaxis[2] = 1 ;
	sts = EFproject_any_curve_on_planen(	&msg,
						cst,
						&inGR[PROFILE]._grid,
						&inGR[PROFILE].mod_env,
						&floor,
						globalZaxis,
						&prjOfPrfl,
						&pjClassid ) ;
	if( sts & 1 & msg ) {
		prflWasProjected	= TRUE ;
		inGR[PROFILE]._grid	= prjOfPrfl ;
		inGR[PROFILE].mod_env	= *cst->env_info ;
	} // Else well keep input curve ... 

	/*
	 * Get geometric properties of profile to know whether it is a
	 * composite curve.
	 */
	sts = ci$send(	msg	= message GRvg.GRgeomprops(
						&msg,
						&inGR[PROFILE]._matrix_type,
						inGR[PROFILE]._matrix,
						&gprops ),
		       targetid= inGR[PROFILE]._objid,
		       targetos= inGR[PROFILE]._osnum ) ;
	if( !( sts & 1 & msg ) ) {
		VERBOSE( "Cannot get properties of input curve" ) ;
		goto wrapup ;
	}
	/*
	 * If floor and ceiling are orthogonal to each other, there is not
	 * much we can do.
	 */
	floorDotCeiling = BSdotp( &msg, floorNrm, ceilingNrm ) ;

	if( fabs( floorDotCeiling ) <= BSparameters[BSTOLORTHOVEC] ) {
		VERBOSE( "Floor & ceiling are perpendicular" ) ;
		sts = OM_W_ABORT ; goto wrapup ;
	}

	/*
	 * Checks whether ceiling & floor are parallel.
	 */
	BScrossp( &msg, floor.normal, ceiling.normal, floorXceiling ) ;
	floorParallelToCeiling =   BSlenvec( &msg, floorXceiling )
				 < BSparameters[BSTOLCOLLINVEC] ;

	/*
	 * We create the surface of projection from the floor up to the ceiling.
	 * The following computation will give us the direction.
	 */
	BSmkvec( &msg, floorToCeiling, floorPnt, ceilingPnt ) ;

	floorToCeilingDotCeilingNrm = BSdotp(	&msg,
						floorToCeiling,
						ceilingNrm ) ;
	t = floorToCeilingDotCeilingNrm / floorDotCeiling ;

	if( !floorParallelToCeiling ) {
		/*
		 * Find maximum distance between profile and ceiling
		 */
		sts = VSfindProjVectorLength(	&msg,
						&inGR[PROFILE],
						&floor,
						&ceiling,
						&prjVecLen ) ;
		if( !( sts & 1 & msg ) ) {
			goto wrapup ;
		}

		/*
		 * Put a little bit more, we'll chop off the extra matter
		 * later.
		 */
		prjVecLen = prjVecLen * 2 ;

		if( t > 0 ) {
			t =   prjVecLen ;
		} else {
			t = - prjVecLen ;
		}
	} else {

		t = floorToCeilingDotCeilingNrm / floorDotCeiling ;
	}

	sts = ci$send(	msg	= message GRcurve.GRendpts(
						&msg,
						&inGR[PROFILE]._matrix_type,
						inGR[PROFILE]._matrix,
						startPoint,
						endPoint ),
			targetid= inGR[PROFILE]._objid,
			targetos= inGR[PROFILE]._osnum ) ;
	if( !( sts & 1 & msg ) ) {
		VERBOSE( "Cannot get end points of input curve" ) ;
		goto wrapup ;
	}

	/*
	 * End point is the point on the line (floorPnt, floorNrm) which
	 * - is on ceiling if floor // ceiling
	 * - is beyong ceiling otherwise
	 * if we suppose that the profile curve lies on the floor :
	 *
	 *				   / ceiling
	 *				  + endPoint
	 *   endPoint			 /
	 * --+----------------- ceiling /
	 *
	 *   ^				  ^
	 *   |floorNrm			  |floorNrm
	 * --+----------------- floor	--+----------------- 
	 *   floorPnt			  floorPnt
	 */

	for( i = 0 ; i < 3 ; i = i + 1 ) {
		endPoint[i] = startPoint[i] + t * floorNrm[i] ;
	}

	surfOfPrj.osnum = cst->env_info->_MD_OS ;
	sts = ci$send(
		msg	= message EMSproject.EMplace_surface_of_projection(
					cst,
					&inGR[PROFILE]._grid,
					&inGR[PROFILE].mod_env,
					NULL,	/* Curve geom : unused	*/
					0,	/* Curve type : unused	*/
					startPoint,
					endPoint,
					FALSE,
					&surfOfPrj.objid ),
		construct= TRUE,
		targetid = surfOfPrj.objid,
		targetos = surfOfPrj.osnum ) ;

	msg = *cst->msg ;
	if( !( sts & 1 & msg ) ) {
		VERBOSE( "Cannot construct surface of projection" ) ;
		goto wrapup ;
	}

	whereWasI = surfaceCreated ;

	/*
	 * Move surface of projection to so that it will sit on the floor.
	 */
	BSmkvec( &msg, translation, startPoint, floorPnt ) ;
	BSnorvec( &msg, floorNrm ) ;
	t = BSdotp( &msg, translation, floorNrm ) ;

	for( i = 0 ; i < 3 ; i = i + 1 ) {
		translation[i] = t * floorNrm[i] ;
	}
	MAidmx( &msg, trnslMx ) ;
	trnslMx[ 3] = translation[0] ;
	trnslMx[ 7] = translation[1] ;
	trnslMx[11] = translation[2] ;
	MAtypemx( &msg, trnslMx, &trnslMxType ) ;

	sts = ci$send(	msg	= message GRgraphics.GRxform(
							&msg,
							cst->env_info,
							&trnslMxType,
							trnslMx,
							&surfOfPrj.objid ),
			targetid = surfOfPrj.objid,
			targetos = surfOfPrj.osnum ) ;
	if( !( sts & 1 & msg ) ) {
		goto wrapup ;
	}

	if( gprops.subtype == GRCC ) {
	
		/*
		 * Base curve was composite, hence we have a composite surface
		 * of projection.
		 */
		sts = ci$send(	msg	= message GRowner.GRget_number_components(
		 				&msg, &nbComps ),
				targetid = surfOfPrj.objid,
				targetos = surfOfPrj.osnum ) ;
		if( !( sts & 1 & msg ) ) {
			goto wrapup ;
		}
		component = (struct GRid *) malloc(   nbComps
						    * sizeof( struct GRid ) ) ;

		if( component == NULL ) {
			sts = OM_W_ABORT ; goto wrapup ;
		}
		sts = ci$send(	msg	= message GRowner.GRget_components(
	 					&msg,
	 					cst->env_info,
	 					component,
	 					nbComps,
						&nbComps,
						0,
						nbComps - 1 ),
				targetid= surfOfPrj.objid,
				targetos= surfOfPrj.osnum ) ;
		if( !( sts & 1 & msg ) ) {
			goto wrapup ;
		}

		sts = ci$send(	msg	= message GRowner.GRdrop(
							&msg, cst->env_info ),
				targetid = surfOfPrj.objid,
				targetos = surfOfPrj.osnum ) ;
		if( !( sts & 1 & msg ) ) {
			goto wrapup ;
		}

		whereWasI = surfaceDropped ;

		if( nbComps > OUTPUTCOUNT ) {
			for( i = OUTPUTCOUNT ; i < nbComps ; i = i + 1 ) {
				ci$send(msg	= message GRgraphics.GRdelete(
							&msg, cst->env_info ),
					targetid= component[i].objid,
					targetos= component[i].osnum ) ;
			}
			nbComps = OUTPUTCOUNT ;
		}
		memcpy( output, component, nbComps * sizeof( struct GRid ) ) ;
		*noutputs = nbComps ;

	} else {
		*noutputs	= 1 ;
		output[0]	= surfOfPrj ;
	}

	if( !floorParallelToCeiling ) {
		/*
		 * Must chop off the extra matter.
		 */
		for( i = 0 ; i < *noutputs ; i = i + 1 ) {

			sts = chopOffMatterBeyondCeiling(
								&msg,
			/* Plane to trim back against	*/	&ceiling,
			/* Pnt on side of matter to keep*/	floor.point,
			/* Surface to chop off		*/	output + i,
			/* Module env. of the above	*/	cst->env_info,
			/* Construction list		*/	cst,
			/* Chopped-off surface		*/	&choppedOffSf) ;

			if( sts & 1 & msg ) {
				output[i] = choppedOffSf ;
			} // else well keep original surface ...
		}
	}

	sts	= OM_S_SUCCESS ;
	msg	= MSSUCC ;

	wrapup :
		/*
		 * Get rid of projection of input profile onto floor.
		 */
		if( prflWasProjected ) {
			ci$send(msg	= message GRgraphics.GRdelete(
							&rc,
							&inGR[PROFILE].mod_env),
				targetid= inGR[PROFILE]._objid,
				targetos= inGR[PROFILE]._osnum ) ;
							
		}
		if( !( sts & 1 & msg ) ) {
			/*
			 * Clean up.
			 */
			switch( whereWasI ) {
			case nothingConstructed	: break ;
			case surfaceCreated	:
				ci$send(msg	= message GRgraphics.GRdelete(
							&msg, cst->env_info ),
					targetid = surfOfPrj.objid,
					targetos = surfOfPrj.osnum ) ;
				break ;
			case surfaceDropped	:
				break ;
			}
			rc = FALSE ;
		} else	rc = TRUE ;

		if( component ) free( component ) ;

		return rc ;

} // constructOutput
/*----------------------------------------------------------------------------*/
void createCoorSysFromPlane( plane, l2w, w2l )

struct IGRplane		*plane ;	/* Input plane			*/
IGRmatrix		l2w,		/* Matrix world -> plane CS	*/
			w2l ; {		/* Matrix plane CS -> world	*/

	long		msg ;
	int		i ;		/* Loop index			*/
	IGRvector	xvec,		/* Vector normal to plNormal	*/
			yvec ;		/* Vector normal to both above	*/
	IGRmatrix	rotmx ;		/* Rot matrix, no translation	*/

	/*
         * Create system of axes x, y and z = plNormal, local to the curve's
	 * plane.
	 */
	BSorthovec( &msg, plane->normal, xvec ) ;
	BScrossp( &msg, plane->normal, xvec, yvec ) ;

	MAidmx( &msg, rotmx ) ;

	for( i = 0 ; i < 3 ; i = i + 1 ) {
		rotmx[4*i+0] = xvec[i] ;
		rotmx[4*i+1] = yvec[i] ;
		rotmx[4*i+2] = plane->normal[i] ;
	}

	/*
	 * Create tranformation matrices world <-> plane CS.
	 */
	MAwclsmx( &msg, plane->point, rotmx, w2l ) ;
	MAlswcmx( &msg, plane->point, rotmx, l2w ) ;

} /* createCoorSysFromPlane */
/*----------------------------------------------------------------------------*/
int VSfindProjVectorLength( msg, curve, floor, ceiling, length )

long			*msg ;
struct GRobj_env	*curve ;
struct IGRplane		*floor,
			*ceiling ;
double			*length ; {

	/*
	 * NOTE: the input curve is supposed to be planar.
	 */
	long		sts ;
	GRrange		cvRange ;	/* Range of curve		*/
	struct IGRplane	cvPlane ;	/* Plane of curve		*/
	IGRvector	plNormal ;	/* Normal to plane of curve	*/
	IGRpoint	plPoint ;	/* Point on plane of curve	*/
	IGRmatrix	w2l,		/* Matrix world -> plane CS	*/
			l2w ;		/* Matrix plane CS -> world	*/
	short		type ;		/* Type of matrix w2l		*/
	int		i ;		/* Loop index			*/
	IGRboolean	world ;		/* For GRgetrang		*/
	double		*min,		/* Min point of curve's range	*/
			*max,		/* Max point of curve's range	*/
			LOCcorners[12], /* Corners of cv's box (local)	*/
			WLDcorners[12], /* Corners of cv's box (world)	*/
			distance,	/* Dist( box corner, ceiling )	*/
			point4IN [4],	/* For MAmulmx			*/
			point4OUT[4],	/* For MAmulmx			*/
			MxDistCvFloor,	/* Max dist( curve, floor )	*/
			MxDistCvCeiling;/* Max dist( curve, ceiling )	*/
	short		_4,		/* For MAmulmx			*/
			_1 ;		/* For MAmulmx			*/

	cvPlane.normal	= plNormal;
	cvPlane.point	= plPoint ;

	sts = ci$send(	msg	= message GRvg.GRdetplane(
							msg,
							&curve->_matrix_type,
							curve->_matrix,
							&cvPlane ),
			targetid= curve->_objid,
			targetos= curve->_osnum ) ;
	if( !( sts & 1 & *msg ) ) {
		VERBOSE( "Cannot get plane of input curve." ) ;
		goto wrapup ;
	}

	/*
         * Create system of axes x, y and z = plNormal, local to the curve's
	 * plane.
	 */
	createCoorSysFromPlane( &cvPlane, l2w, w2l ) ;

	MAtypemx( msg, w2l, &type ) ;
	/*
	 * Get range of curve in the CS of the plane of the curve.
	 */
	world = TRUE ;
	sts = ci$send(	msg	= message GRgraphics.GRgetrang(
					msg, &type, w2l, &world, cvRange ),
			targetid= curve->_objid,
			targetos= curve->_osnum ) ;
	if( !( sts & 1 & *msg ) ) {
		VERBOSE( "Cannot get range of input curve." ) ;
		goto wrapup ;
	}


	min = cvRange + 0 ;
	max = cvRange + 3 ;

	memcpy( LOCcorners + 0, min, sizeof( IGRpoint ) ) ;
	memcpy( LOCcorners + 3, min, sizeof( IGRpoint ) ) ;
	memcpy( LOCcorners + 6, max, sizeof( IGRpoint ) ) ;
	memcpy( LOCcorners + 9, max, sizeof( IGRpoint ) ) ;

	LOCcorners[3+0] = max[0] ;
	LOCcorners[9+0] = min[0] ;

	/*
	 * Map corners back to world.
	 */
	_1 = 1 ; _4 = 4 ; point4IN[3] = 1 ;

	for( i = 0 ; i < 4 ; i = i + 1 ) {

		memcpy( point4IN, LOCcorners + 3 * i, sizeof( IGRpoint ) ) ;

		MAmulmx(	msg,
				&_4,
				&_4,
				&_1,
				l2w,
				point4IN,
				point4OUT ) ;

		memcpy( WLDcorners + 3 * i, point4OUT, sizeof( IGRpoint ) ) ;
	}

	/*
	 * Now find maximum disptance between box of curve and ceiling.
	 */
	MxDistCvCeiling = 0 ;	
	for( i = 0 ; i < 4 ; i = i + 1 ) {
		BSdistptpl(	msg,
				WLDcorners + 3 * i,
				ceiling->point,
				ceiling->normal,
				&distance ) ;
		if( distance > MxDistCvCeiling ) {
			MxDistCvCeiling = distance ;
		}
	}
	/*
	 * Also find maximum disptance between box of curve and floor since
	 * curve may not be on the floor but on a plane parallel to it.
	 * we must have a projection vector large enough so that when the
	 * surface of projection created from the curve will still penetrate
	 * the ceiling when this surface is move so as to sit on the floor.
	 */
	MxDistCvFloor = 0 ;	
	for( i = 0 ; i < 4 ; i = i + 1 ) {
		BSdistptpl(	msg,
				WLDcorners + 3 * i,
				floor->point,
				floor->normal,
				&distance ) ;
		if( distance > MxDistCvFloor ) {
			MxDistCvFloor = distance ;
		}
	}

	*length = MxDistCvCeiling + MxDistCvFloor ;

	*msg = MSSUCC ;

	wrapup :
		return sts ;

} // VSfindProjVectorLength
/*----------------------------------------------------------------------------*/
long chopOffMatterBeyondCeiling(	msg,
					ceiling,
					pntOnMatterSide,
					sfToChopOffId,
					sfToChopOffEnv,
					cst,
					result )

long			*msg ;
struct IGRplane		*ceiling ;
IGRpoint		pntOnMatterSide ;
struct GRid		*sfToChopOffId ;
struct GRmd_env		*sfToChopOffEnv ;
struct GRvg_construct	*cst ;
struct GRid		*result ; {


	long			sts ;
	struct EMSdataselect	saveSidePlane ;

	result->objid	= NULL_OBJID ;

	saveSidePlane.datatype 		= EMSdata_plane ;
	saveSidePlane.data.plane	= ceiling ;

	sts = ci$send(	msg	= message EMSsurface.EMintsurf_saveside(
						msg,
						cst,
						&saveSidePlane,
						sfToChopOffEnv,
	/* If specified nat.norm ignored*/	pntOnMatterSide,
	/* Nat. norm. No importance	*/	TRUE,
	/* Boolean options		*/	0,
	/* Output int. curves		*/	NULL,
	/* Output pnts to signal gaps	*/	NULL,
	/* Want status messages?	*/	TRUE,
	/* Plane object			*/	NULL ),
			targetid= sfToChopOffId->objid,
			targetos= sfToChopOffId->osnum ) ;


	if( !( sts & 1 & *msg ) ) {
		VERBOSE( "Cannot trim back walls against ceiling." ) ;
		goto wrapup ;
	} else {
		// CAUTION : the input surface has been absorbed by a
		// boolean surface (EMsfboolean) result of the boolean
		// difference between the input surface and the plane to
		// chop it against. Hence we must fetch the top owner.

		sts = ci$send(	msg	= message EMSsurface.EMgetactiveid(
							msg, result, NULL ),
				targetid= sfToChopOffId->objid,
				targetos= sfToChopOffId->osnum ) ;
		if( !( sts & 1 & *msg ) ) {
			VERBOSE( "Cannot get active id." ) ;
			goto wrapup ;
		}

		// Now we can compress state tree of the result

		sts = ci$send(	msg     = message EMSdpr.EMmake_primitive1(
							msg,
							cst->env_info,
							result ),
				targetid= result->objid,
				targetos= result->osnum ) ;

	}

	wrapup :
		return sts ;

} /* chopOffMatterBeyondCeiling */
/*----------------------------------------------------------------------------*/

