/* $Id: COExSrfRg.u,v 1.1.1.1 2001/01/04 21:07:36 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/smppl / COExSrfRg.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COExSrfRg.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:36  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*

   File name :		COExSrfRg.u
   Revision date :	93/01/07

   Description :		
	Command object to extent a surface within a given range
	(see file ~sman/SMutil/SMextentSrf.I)
   History : TEST file only

 */

#include <stdio.h>
#include "msdef.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bserr.h"
#include "bsconic.h"
#include "nddef.h"
#include "AS_status.h"
#include "exmacros.h"
#include "grmacros.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "growner.h"
#include "msmacros.h"

extern int 	init_cnst_list()     ;
extern char	*malloc() ;
extern		free(), BSfreesf() ;
extern IGRlong SMextentObjSrfRg() ;
extern 		GRdisplay_object()  ;
extern		MSmessage() ;

main()
{
char			loc_mes[81], buffer[256] ;
long			status, msg  ;

IGRboolean		world, reduce_data ;
GRrange			ext_range ;
struct GRmd_env		mod_env ;

struct GRvg_construct   cst  ;
struct IGRdisplay	dis  ;
struct GRobj_env	surface, box ;
struct GRid		extentsrf ;
double			acc_point[3] ;

/*
	Initialisation
 */

strcpy(loc_mes,"<Test> Extent surface within range") ;

ci$get_module_info(md_env = &mod_env) ;
init_cnst_list() ;
get_symb() ;

dis.color	= cnst_list.color  ;
dis.weight	= cnst_list.weight ;
dis.style	= cnst_list.style  ;

cst.msg		= &msg ;
cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE ;
cst.display	= &dis ;
cst.env_info	= &mod_env ;
cst.newflag	= 0 ;
cst.level	= cnst_list.level ;
cst.geometry	= NULL ;
cst.class_attr	= 0 ;
cst.name	= 0 ;

/*
	Get composite surface, boundary curve and area point
 */

while (1) {

   message(loc_mes);
   if(!ci$locate( 	prompt       = "Identify a surface",
			acc_prompt   = "Accept with range box for extension",
			relocate_prompt = "No surface found",
			accept_point    = acc_point,
                  	properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                  	owner_action = LC_RIGID_COMP  |
                                 LC_RIGID_OWNER | LC_FLEX_COMP |
                                 LC_FLEX_OWNER  | LC_REF_OBJECTS,
			classes	     = "EMSsubbs",
			md_env	     = &surface.mod_env,
                  	obj          = &surface.obj_id.objid,
                  	osnum        = &surface.obj_id.osnum)) break ;
   ci$put(point = acc_point) ;

   while (1) {

      if(!ci$locate( 	prompt       = "Identify range box for extension",
			relocate_prompt = "No box found",
                  	properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                  	owner_action = LC_RIGID_COMP  |
                                 LC_RIGID_OWNER | LC_FLEX_COMP |
                                 LC_FLEX_OWNER  | LC_REF_OBJECTS,
 	          	/* classes      = "EMSblock", */
 	          	classes      = "EMSsurface",
			md_env       = &box.mod_env,
	          	obj          = &box.obj_id.objid,
                  	osnum        = &box.obj_id.osnum)) break ;


      /*
		Get range of the box
       */

      world = TRUE ;
      status = ci$send(msg = message GRgraphics.GRgetrang(&msg,
				&box.mod_env.md_env.matrix_type,
				box.mod_env.md_env.matrix,
				&world,
				ext_range),
		targetid = box.obj_id.objid,
	 	targetos = box.obj_id.osnum) ;
      as$status(action = GOTO_VALUE, value = wrapup) ;

      /* 
		Call extension function 
       */

      reduce_data = TRUE ; /* not yet implemented */
      status = SMextentObjSrfRg(&msg, &surface, ext_range, &cst,
			reduce_data, &extentsrf) ;
      as$status(sts = status & msg, action = GOTO_VALUE, value = wrapup) ;
      sprintf(buffer, "Successfull extension") ;
      ex$message(field = 2, in_buff = buffer) ;

      printf("%s \n", buffer) ;

      /* Display extended surface */

      gr$display_object(object_id = &extentsrf, mode = GRbd) ;

      } /* while range box */

   } /* while surface */


status = OM_S_SUCCESS ;

wrapup :
return status ;
}     /* main() */

