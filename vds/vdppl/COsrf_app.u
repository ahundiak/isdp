#include <stdio.h>

#include "cieveryone.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "EMSmsgdef.h"
#include "msdef.h"
#include "ciexec.h"
#include "cievent.h"
#include "AS_status.h"
#include "OMprimitives.h"

#include "growner.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "grmacros.h"
#include "dpdef.h"
#include "dpmacros.h"

char		 	loc_mes[80];
IGRlong			msg;
IGRlong                 order;
IGRdouble               max_err;
IGRdouble               ave_err;

struct GRmd_env 	MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;

struct	GRid		*SURFACE_ID;
struct	GRobj_env	*COMP_ENV;

extern void             BScveval();
extern int 		free(),
			init_cnst_list();
extern int 		VDcomment;

extern char             *malloc();
extern                  ASmake_source_from_env();
extern IGRdouble	BSdistptpts();

extern		        GRgs_fun();
extern		        GRgsmgr_fun();
extern		        EMdpb_get_trans();
extern		        DPdisbyoid(), DPerase_hilite();

extern unsigned short   OPP_EMSsubbs_class_id;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

main_approx( SURF )
struct GRid 		SURF;

{
  struct GRlc_info      Curve_Cont[4];
  int 		 	num_crv;
  IGRlong      	 	stat;
  struct GRid		CurveToApp;
  GRobj 		*ISOC;
  IGRdouble		uv[2];
  IGRboolean		uv_dir, trim_to_boundaries, nat_side;
  IGRint		num_cst_ISOC, num_par, i;
  IGRint		dpmode;
  struct GRid 		NewSurf;

  {
    ci$get_module_info    ( md_env = &MOD_ENV );
    ASmake_source_from_env( &SURF, &MOD_ENV, &SURF);

    /* retrieve the geometry of the surface */
    /* set the default paremeter for the iso extraction */

    num_par = 2;
    uv[0]   = 0;
    uv[1]   = 1;
    trim_to_boundaries = FALSE;

    /*****      extract the 2  iso-curves in u  ******/
    /*************************************************/

    ISOC = NULL;
    num_cst_ISOC = 0;
    uv_dir = TRUE;

    stat = ci$send( msg      = message EMSsubbs.EMisoparcvs(
                                                &msg,
                                                &MOD_ENV.md_env.matrix_type,
                                                 MOD_ENV.md_env.matrix,
                                                &cst,
                                                 trim_to_boundaries,
                                                 num_par,
                                                 uv,
                                                 uv_dir,
                                                &num_cst_ISOC,
                                                &ISOC),
                    targetid = SURF.objid,
                    targetos = SURF.osnum );

#ifdef DEBUG
    printf("num iso in U = %d\n", num_cst_ISOC);
#endif

    /* loop to approximate these 2 curves */
    num_crv = 0;
    for( i=0; i<2; i=i+1 )
    {
      CurveToApp.objid = ISOC[i];
      CurveToApp.osnum = MOD_ENV.md_id.osnum ;

      Compute_approx( CurveToApp, MOD_ENV, &Curve_Cont[num_crv], &ave_err, &max_err, &stat );

      if( !(stat&1) )
      {
#ifdef DEBUG
        printf("error in Compute_approx[%d], stat = %d\n", i, stat);
        printf("cst.msg1 = %d\n", cst.msg);
#endif
        Curve_Cont[num_crv].located_obj.objid = NULL_OBJID;
      }
      else
      {
#ifdef DEBUG
        printf("Curve_Cont[%d].objid = %d\n", num_crv, Curve_Cont[num_crv].located_obj.objid);
        printf("cst.msg1 = %d\n", cst.msg);
#endif
	num_crv = num_crv + 1;
      }

      ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
              targetid = CurveToApp.objid,
              targetos = CurveToApp.osnum);
    }

    /******      extract the 2  iso-curves in v ******/
    /*************************************************/
    num_cst_ISOC = 0;
    uv_dir       = FALSE;
    if( ISOC != NULL ) free(ISOC); ISOC = NULL;

    stat = ci$send( msg      = message EMSsubbs.EMisoparcvs(
						&msg,
                           			&MOD_ENV.md_env.matrix_type,
						 MOD_ENV.md_env.matrix,
						&cst,
						 trim_to_boundaries,
						 num_par,
                                                 uv,
                                                 uv_dir,
  						&num_cst_ISOC,
                              			&ISOC),
                    targetid = SURF.objid,
                    targetos = SURF.osnum );

#ifdef DEBUG
    printf("num iso in V = %d\n", num_cst_ISOC);
#endif

    /* loop to approximate these 2 curves */

    for( i=0;i<2;i=i+1 )
    {
      CurveToApp.objid = ISOC[i];
      CurveToApp.osnum = MOD_ENV.md_id.osnum ;

      Compute_approx( CurveToApp, MOD_ENV, &Curve_Cont[num_crv], &ave_err, &max_err, &stat );

      if( !(stat&1) )
      {
#ifdef DEBUG
        printf("error in Compute_approx[%d], stat = %d\n", (i+2), stat);
        printf("cst.msg1 = %d\n",cst.msg);
#endif
        Curve_Cont[num_crv].located_obj.objid = NULL_OBJID;
      }
      else
      {
#ifdef DEBUG
        printf("Curve_Cont[%d].objid = %d\n", num_crv, Curve_Cont[num_crv].located_obj.objid);
        printf("cst.msg1 = %d\n", cst.msg);
#endif
	num_crv = num_crv + 1;
      }

      ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
              targetid = CurveToApp.objid,
              targetos = CurveToApp.osnum);
    }

    if( ISOC != NULL ) free(ISOC); ISOC = NULL;

    /* make a coons surface and construct it */

    nat_side      = TRUE;
    NewSurf.objid = NULL_OBJID;
    NewSurf.osnum = MOD_ENV.md_id.osnum;
    cst.geometry  = NULL;

    if( num_crv == 3 )
    {
      stat = ci$send( msg= message EMSgenbs.EMbs4cvs (
					&msg,
					&Curve_Cont[0], NULL,
					&Curve_Cont[1], NULL,
					&Curve_Cont[2], NULL,
					(struct GRlc_info *) NULL, NULL,
					nat_side,
					&cst),
                      targetid = NewSurf.objid,
                      targetos = NewSurf.osnum );
    }
    else
    {
      stat = ci$send( msg= message EMSgenbs.EMbs4cvs (
					&msg,
					&Curve_Cont[0], NULL,
					&Curve_Cont[2], NULL,
					&Curve_Cont[1], NULL,
					&Curve_Cont[3], NULL,
					nat_side,
					&cst),
                      targetid = NewSurf.objid,
                      targetos = NewSurf.osnum );
    }

    if( !(stat&msg&1) )
    {
      NewSurf.objid = NULL_OBJID;
      status("approximation failed");
#ifdef DEBUG
      printf("Error in EMbs4cvs\n");
#endif
    }
    else
    {
      dpmode = GRbd ;

      stat = ci$send(msg = message GRgraphics.GRdisplay(
					&msg,
					&MOD_ENV.md_env.matrix_type,
					MOD_ENV.md_env.matrix,
					&dpmode,
					&MOD_ENV.md_id ),
                     targetid = NewSurf.objid,
                     targetos = NewSurf.osnum );
    }
    for(i=0;i<4;i=i+1)
    {
      if( Curve_Cont[i].located_obj.objid != NULL_OBJID )
      {
        ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
            	targetid = Curve_Cont[i].located_obj.objid,
            	targetos = Curve_Cont[i].located_obj.osnum);
      }
    }
  }
}

/*==========================================================================*/
init()
{
  extern void                       BScveval();
  strcpy(loc_mes,"Approximate Surface");

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= NULL;
  cst.class_attr	= 0;
  cst.name		= 0;
}

wakeup()
{
  message(loc_mes);
}

/*==========================================================================*/

Compute_approx( GCV, modenv, AppCurve, ave_tot, max_tot, msgmsg )
struct GRid 		GCV;
struct GRmd_env 	modenv;
struct GRlc_info 	*AppCurve;
IGRdouble               *ave_tot;
IGRdouble               *max_tot;
IGRlong			*msgmsg;

{
  struct IGRbsp_curve   *bsp_curve;
  IGRdouble		*points, u;
  IGRlong      	 	number_of_points, num_seg;
  IGRint		j,k,l, sts;
  IGRlong		mx_ind;
  IGRboolean		periodic;
  IGRdouble             ave_err, max_err, pt1[6];
  IGRint		deg;
  IGRdouble		CumDist2;

  bsp_curve = NULL;
  sts = ci$send(  msg = message GRvg.GRgenabsg( msgmsg,
					  &modenv.md_env.matrix_type,
					  modenv.md_env.matrix,
					  &bsp_curve ),
                  targetid = GCV.objid,
                  targetos = GCV.osnum );

  points = NULL;
  points = (IGRdouble *) malloc(3 * sizeof(IGRdouble)*bsp_curve->num_poles);
  deg = bsp_curve->order - 1;

  CumDist2 = 0.0;

  for( j=0; j<bsp_curve->num_poles-1; j=j+1 )
  {
    l = j + bsp_curve->order;
    u = 0;
    for(k=j+1; k<l; k=k+1)
    {
      u = u + bsp_curve->knots[k];
    }
    u = u / (IGRdouble)deg;
#ifdef DEBUG
    printf("u[%d] = %f\n", j, u);
#endif
    BScveval(bsp_curve, u, 0, &points[3*j], msgmsg);

    CumDist2 = CumDist2 + BSdistptpts( msgmsg, &bsp_curve->poles[3*j],
				               &bsp_curve->poles[3*(j+1)] );
  }

  k = 3*(bsp_curve->num_poles-1);
  for( j=0;j<3;j=j+1 )
  {
    points[j]   = bsp_curve->poles[j];
    points[j+k] =  bsp_curve->poles[j+k];
  }

  AppCurve->located_obj.objid = NULL_OBJID;
  if( CumDist2 < 1.0e-6 ) *msgmsg = MSFAIL;

//order                       = 5;
  number_of_points            = bsp_curve->num_poles;
  num_seg                     = 1;
  periodic                    = FALSE;
  ave_err                     = 0.0;
  max_err                     = 0.0;
  mx_ind                      = 0;
  AppCurve->located_obj.osnum = modenv.md_id.osnum;
  AppCurve->module_info       = modenv;
  cst.geometry                = NULL;

  sts = ci$send(msg      = message GRbcsubbc.EMleast_squares_fit_curvee(
					order,
 					periodic,
					number_of_points,
					points,
					NULL,
					NULL,
					NULL,
					num_seg,
					NULL,
					&ave_err,
					&max_err,
					&mx_ind,
					pt1,
					&cst ),
                targetid = AppCurve->located_obj.objid,
	        targetos = AppCurve->located_obj.osnum );
  *msgmsg = sts;
  *ave_tot = (*ave_tot + ave_err) * 0.5;
  if( max_err > *max_tot ) *max_tot = max_err;

wrapup:

  if( points != NULL ) free(points);

//  if ( VDcomment )
  {
    printf("avg_err = %f, max_err = %f\n",ave_err,max_err);
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

get_elements_in_fence( OBJ_ID )

struct	GRid		OBJ_ID;
{
  char	       *fnc_ptr;
  int		count, msg, sts, size_ob, sze;
  struct GRid	OBJET, clipping_grid;

  /* get clipping polygon */

  gr$gsget_fence( msg = &msg,fence_id = &clipping_grid );

  if( msg != MSSUCC ) clipping_grid.objid = NULL_OBJID;

  OBJET.objid = OBJ_ID.objid;
  OBJET.osnum = OBJ_ID.osnum;

  count = 0;
  gr$gsinqcount(	msg		= &msg,
			count		= &count,
			senderid	= NULL_OBJID,
			object_id	= &OBJET );

  if( msg != MSSUCC )
  {
    fprintf(stderr, "gr$gsinqcount failed" );
    return (0);
  }

//    DEBUG0 ("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n");
//    DEBUG1 ("NUMBER OF GRAPHIC SET MEMBERS = %d\n", count);

  size_ob	= count * sizeof(struct GRobj_env);
  fnc_ptr	= om$malloc( size =  size_ob);
  COMP_ENV	= (struct GRobj_env *) fnc_ptr;

  if ( COMP_ENV == NULL ) return (0);

  sze		= count * sizeof(struct GRid);
  fnc_ptr	= om$malloc( size =  sze);
  SURFACE_ID	= (struct GRid *) fnc_ptr;

  if ( SURFACE_ID == NULL ) return (0);

  //	Inquire fence for content.

  sts = gr$gsget_objects (	msg		= &msg,
				array		= COMP_ENV,
				size		= size_ob,
				count		= &count,
				from_obj	= 0,
				to_obj		= count -1,
				senderid	= NULL_OBJID,
				object_id	= &OBJET);

  if ( !( sts & OM_S_SUCCESS ) )
  {
    fprintf(stderr, "gr$gsget_objects error ; sts = %d , msg = %d\n",sts,msg ) ;
    om$report_error( sts = sts ) ;
    return (0) ;
  }

  return (count);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

process_elements_in_fence( count, COMP_ENV )

int			 count;
struct	GRobj_env	*COMP_ENV;
{
  char		OK;
  int		i0, nr_elm;

  OMuword	clid, srf_classid;
  struct GRid 	SURF;

  /* ------------------------------------------------------------------ */

  srf_classid = OPP_EMSsubbs_class_id;
  nr_elm = 0;

  // Now find all elements of class	: EMSsubbs

  for (i0=0; i0<count; i0=i0+1)
  {
    om$get_classid( objid	  = COMP_ENV[i0].obj_id.objid,
                    osnum	  = COMP_ENV[i0].obj_id.osnum,
                    p_classid = &clid);

    if ( om$is_ancestry_valid ( subclassid = clid, superclassid = OPP_EMSsubbs_class_id ) == OM_S_SUCCESS)
    {
      SURFACE_ID[nr_elm].osnum = COMP_ENV[i0].obj_id.osnum;
      SURFACE_ID[nr_elm].objid = COMP_ENV[i0].obj_id.objid;

      dp$display ( msg	= &msg,
                   mode	= GRhd,
                   oids	= &SURFACE_ID[nr_elm] );

      nr_elm = nr_elm + 1;
    }
  }

  OK = 'y';  
  ci$get ( char		= OK,
           prompt	= "Move-On(YES) to Continue ? (Y/N) [Y]" );

  dp$erase_hilite(msg	= &msg);

  if ( OK == 'n' )
    return (1);

//  if ( VDcomment )
  {
    printf ("\n-----------------\nNumber of Surfaces = %d, Approximation Order = %d\n", nr_elm, order);
    for (i0=0; i0 < nr_elm; i0=i0+1)
    {
      printf ("SURFACE_ID[%d] = [%d,%d]\n", i0, SURFACE_ID[i0].osnum, SURFACE_ID[i0].objid);
      SURF = SURFACE_ID[i0];

      main_approx ( SURF );
    }
  }
  printf ("\nNumber of Surfaces Approximated = %d, Approximation Order = %d\n-----------------\n", nr_elm, order);

  return (1);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

generate_surface_list()
{
  char          str[40];
  int		count, resp;
  IGRint	u_order, v_order;
  IGRlong	sav_order, msg;
  double	rep_pos[3];

  struct	GRid		OBJ_ID;
  struct        GRid 		SURF;
  struct	GRevent		grevent;

  /* ------------------------------------------------------------------ */

  gr$get_active_u_order( msg = &msg, order = &u_order);
  gr$get_active_v_order( msg = &msg, order = &v_order);

  order = u_order;
  if ( u_order > v_order )
    order = v_order;

  sav_order = order;

  sprintf(str, "Enter Order for Approximation [%d]:", order);

  ci$get ( value		= order,
           prompt		= str );

  if (order <= 0)
    order = sav_order;

  ci$getevent(event		= &grevent,
              response	        = &resp ,
              prompt		= "Locate Surfaces to Approximate",
              stackable	        = 1,
              mask		= GRm_SPECIFIED_OBJ | GRm_DATA | GRm_RESET );

  OBJ_ID.objid = grevent.located_object[0].located_obj.objid;
  OBJ_ID.osnum = grevent.located_object[0].located_obj.osnum;

  if( resp == SPECIFIED_OBJ )
  {
    count = get_elements_in_fence( OBJ_ID );

//    if ( VDcomment ) printf ("Number of elements in fence = %d\n", count);

    if ( count ) process_elements_in_fence( count, COMP_ENV );

    status("");
  }
  else if( resp == DATA )
  {
    rep_pos[0]	= grevent.event.button.x;
    rep_pos[1]	= grevent.event.button.y;
    rep_pos[2]	= grevent.event.button.z;
    ci$put (point = rep_pos);

    ci$locate(        prompt       = "Identify Surface to Approximate",
                      properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                      owner_action = LC_RIGID_COMP  |
                                     LC_RIGID_OWNER | LC_FLEX_COMP |
                                     LC_FLEX_OWNER  | LC_REF_OBJECTS,
                      classes      = "EMSsubbs",
                      obj          = &(SURF.objid),
                      osnum        = &(SURF.osnum),
                      response     = &resp,
                      md_env       = &MOD_ENV );

    printf ("SURFACE = [%d,%d], Approximation Order = %d\n", SURF.osnum, SURF.objid, order);
    main_approx ( SURF );
  }
  else if( resp == RESET )
  {
    status( "Located object not a Fence or Surface" ) ;
  }

  if( COMP_ENV != NULL )
  {
    om$dealloc(ptr = COMP_ENV);
    COMP_ENV = NULL;
  }

  if( SURFACE_ID != NULL )
  {
    om$dealloc(ptr = SURFACE_ID);
    SURFACE_ID = NULL;
  }

  return (1);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

main()
{
    generate_surface_list();
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
