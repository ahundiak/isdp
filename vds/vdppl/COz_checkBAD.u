/* $Id: COz_checkBAD.u,v 1.1 2001/01/18 20:38:41 hans Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:	vdppl/COz_checkBAD.u
 *
 * Description:
 *		Check if macro library has invalid macros added within
 *		the construction and report the object ID.
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_checkBAD.u,v $
 *	Revision 1.1  2001/01/18 20:38:41  hans
 *	SP16 additions/modifications
 *	
# Revision 1.1  2000/10/05  13:37:26  pinnacle
# Created: vds/vdppl/COz_checkBAD.u by impd252 for Service Pack
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	09/27/00	adz		creation date
 *
 ***************************************************************************/
#include "VDppl.h"
#include "VDobj.h"
#include "nddef.h"
#include "ndmacros.h"
#include "coparamac.h"
#include "VDbro1.h"

struct ObjInfo {

  TGRobj_env objOE;

  IGRboolean  sts;

  GRclassid classID;
  IGRchar   className[32];

  IGRchar   objName[1024];
  IGRchar   macName  [80];
  IGRchar   downScan [80];
  IGRchar   expStr [1024];

  TGRid macID;

};

/* include/protypes */

extern	int	EX_findmod();
extern	int	ACfind_macro_defn();
extern IGRlong 	VDbroGetObjDesc();
extern IGRlong	VDbroGetObjInfo();
extern		UI_status(), UI_echo();

extern	char	*strrchr();
extern	int	strcmp();

extern	GRclassid	OPP_ACcpx_class_id;

/**/
#define	DEBUG		1
/**/

#define		MAX_FILES	1000
#define		MAX_NAMES	30


main()
{
int			status;
long			msg;
OM_S_OBJID		mod_id;
OMuword			classid;
GRspacenum		cur_os;

struct	GRid		macroId , macId ;

IGRchar			*p ;
IGRchar			file_name[DI_PATH_MAX],
			macro_name[DI_PATH_MAX];

IGRint			i, j, os, id, max;
struct ObjInfo		objInfo;
IGRchar			objDesc[1024];

	/*
	 * Get the number of files attached.
	 */

	UI_message(" Check BAD Macros and Libraries " );

#ifdef	DEBUG
	printf(" MaxOS : %d \n", OM_Gw_maxOS );
#endif

	/*
	 * Get starting object space.
	 */

	ex$get_cur_mod( id = &mod_id, osnum = &cur_os );

	/*
	 * Show the available files/libraries.
	 */

	for( os=cur_os ; os<OM_Gw_maxOS ; os=os+1 ) {

	  if( OM_GA_OSDs[ os ] ){

	    sprintf( file_name, "Check: %s", OM_GA_OSDs[os]->name );

	    UI_status( file_name );

	    macroId.osnum = os ;
	    max = OM_GA_OSDs[os]->CurSpaceMapSize ;

	    strcpy( file_name, OM_GA_OSDs[os]->name );
	    if( p = strrchr( file_name, '/' ) )     p = p +1 ;
	    else                                    p = file_name ;

            printf("\n\tName[%d]: %s\t->%s\n\n", os, p, OM_GA_OSDs[os]->name );

	    for( id=0 ; id<max ; id=id+1 ) {

              status = 
	      om$get_classid(objid = id, osnum = os, p_classid = &classid ) ;
              if( !( status & 1 )) continue ;

              if( om$is_ancestry_valid(
                                superclassid    = OPP_ACcpx_class_id,
                                subclassid      = classid ) == OM_S_SUCCESS ){

		  macroId.objid = id ;

		  status =
		  ci$send( msg = message ACcpx.find_macro(&macId),
			   targetid = macroId.objid,
			   targetos = macroId.osnum );

		  if (!(status & 1)) {
          	  	printf("\tMACRO[%d,%d]: BAD ===== \n",
				macroId.osnum, macroId.objid );
		  }
	      } /* if ACcpx */

	    } /* for object in os */
	  }
	} /* for all os's */

	UI_status( "" );
	UI_echo( "" );
}
