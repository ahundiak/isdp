/* $Id: VDdisable.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $ */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:        vds/vdppl / VDdisable.u
 *
 * Description:
 * 
 * This PPL disables an AIM Enables item ( FSI ). A FSI can be disabled from
 * either a diagram or arrangement file. A Disabled AIM item is recorded in 
 * TrTbl as deleted. This ensures deletion of the FSI if posted to AIM. Thus
 * it is necessary for a user to post an FSI after disabling to clear up
 * things in AIM.
 * CR # 179801370
 *
 * Dependencies:
 *
 * Revision History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      04/30/99	SSR		TR # MP 81 Added FI_get_form_by_name()
 *      02/25/99	SSR		CR#179900379 PPL made to work for all
 *      				file types
 *      11/25/98	SSR		Creation
 *
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDPdef.h"
#include "ACdb_info.h"
#include "VDScheckdef.h"
#include "vdparmacros.h"
#include "VDPtrTbl.h"

extern  printf() ;
extern  UI_status ();
extern FIf_new();
extern FIfld_set_text();
extern FIf_display();
extern FIf_erase();
extern FIf_set_cmd_oid_os();
extern char* malloc();

struct CIform_st form_st;

Form			my_form, old_form;
struct GRid		DirId;
struct GRobj_env	*listObjs;


int form_notification()
{
  ci$put ( response = MOVE_ON );
}

/*
 * Checks for collector in SIRGLOBAl dir for any enabled items.
*/
int CheckAimDir()
{
  OMuword			curOs;
  int				status;
  IGRchar			DirName[DI_PATH_MAX];

  // Get Current Os.
  ex$get_cur_mod( osnum = &curOs );

  //Get enabled list object
  status = di$give_pathname ( osnum = curOs, pathname = DirName );
  strcat ( DirName, SIR_GLOBAL_DIR );
  strcat ( DirName, SIR_ENABLED_LIST );
  status = di$translate ( objname = DirName,
      p_objid = &DirId.objid,
      p_osnum = &DirId.osnum );

  if ( status != DIR_S_SUCCESS )
  {
    UI_status("No Aim Enabled items");
    return 1;
  }
  return 0;
}

/*
 * Read the aim enabled list from SIR_GLOBAL dir, prepare the display name,
 * show it in the form.
 * 
 */
int FillForm()
{
  int			status, nbItems, size, ret_size, i;
  IGRchar		buffer[140], str[100];
  struct GRid		Obj;
  struct GRmd_env	MdEnv;
  struct ACrg_coll	*Coll;
  struct ACobj_info_1	ObjInfo;

  //Get members of list object.
  ci$send ( msg = message VDPenabObj.VDPgetPMenabledList( &msg,
						&nbItems, &listObjs),
     		 	targetid = DirId.objid,
      			targetos = DirId.osnum);

  if(nbItems == 0)
  {
    UI_status("No AIM Enabled Items");
    ci$put(response = TERMINATE);
    FIf_erase ( my_form);
    return 1;
  }

  //Prepare the list and put info in form.
  //Info should look same as show aim enable items
  
  FIfld_set_num_rows ( my_form, 18, nbItems );
  size = sizeof( struct GRmd_env );
  gr$get_module_env( msg = &msg, sizbuf = &size,
      buffer = &MdEnv, nret = &ret_size);

  Coll = (struct ACrg_coll *) malloc(sizeof(struct ACrg_coll)*1);
  if ( Coll == NULL )
  {
    UI_status ("No Dynamic Memory");
    return OM_E_NODYNMEM;
  }
  
  for( i = 0 ; i < nbItems ; i=i+1 )
  {
    buffer[0] = '\0';
    LCget_info ( listObjs[i].obj_id.objid,
	listObjs[i].obj_id.osnum, str);

    Obj.objid = listObjs[i].obj_id.objid;
    Obj.osnum = listObjs[i].obj_id.osnum;
    
    status = VdsGet_db_info( &Obj, &ObjInfo, 1 );
 
    if(ObjInfo.quantity == EQUIPMENT_OBJ )
      strcpy(Coll[0].name,"wet_weight");
    
    else
      strcpy(Coll[0].name,"wet_wt");
      Coll[0].desc.type=AC_ATTRIB_DOUBLE;
      Coll[0].desc.value.att_exp =0.0;
      vd$review_params( pMsg = &msg, pComponent = &Obj,
                   pMdEnv = &MdEnv, pList = Coll,
		   NbParams = 1 );

      if(Coll[0].desc.type == AC_ATTRIB_DOUBLE)
	sprintf( buffer, "%s, Wet-Weight = %.3f",
                      str,Coll[0].desc.value.att_exp );
      else
        sprintf(buffer, "%s",str);
      
      FIfld_set_text( my_form, 18, i, 0, buffer, FALSE );
  }
  return 0;
}

main ()
{
  int			status, response, i, PrevRow;
  int			sel, pos, not_done, row;
  struct GRid		DisObj, TrTblId, DefId;
  IGRlong		msg;
  struct GRmd_env	md_env;
  enum GRdpmode		DisplayMode;
  struct VDPtrObjList	TrRow;
  IGRchar		DirName[DI_PATH_MAX];
  struct ACrg_coll      DefColl;
  OMuword		curOs;

  message ("Disable F S I");
 
  not_done = 1;
  msg = 1;
  DisObj.objid = 0;
  DisObj.objid = 0;
  PrevRow = 0;
  status = 0;

  // AIM connection is must!
  if ( WhichAim() != SIR )
  {
    UI_status ( "SIR server connection required");
    return 1;
  }

  // Get Current Os.
  ex$get_cur_mod( osnum = &curOs );

  //Get default data object
  status = di$give_pathname ( osnum = curOs, pathname = DirName );
  strcat ( DirName, SIR_GLOBAL_DIR );
  strcat ( DirName, SIR_REQ_DATA );
  status = di$translate ( objname = DirName,
      p_objid = &DefId.objid,
      p_osnum = &DefId.osnum );

  if ( status != DIR_S_SUCCESS )
  {
    UI_status("No AIM default data set");
    return 1;
  }

  /* PPL should work for ALL file types SSR 25Feb CR#179900379
  get the design file type
  status = VDgetDiagCtlPar( &msg, &diagCtl );

  Get file type from Def DAta
  strcpy(DefColl.name, SIR_FILE_TYP);
  ci$send(msg = message ACrg_collect.ACget_named_attribute(&msg,
							&DefColl),
		 targetid = DefId.objid,
		 targetos = DefId.osnum );

  if(msg == FALSE)
    If default collector doesn't have file type use design file type
    FileType = diagCtl;
  else
    FileType = DefColl.desc.value.att_exp;

  if( FileType == M_FILE )
  {
    UI_status("Can not Disable FSI for this file type");
    return 1;
  }
  CR# 179900379*/

  status = CheckAimDir();// Check for any aim enabled items
  if(status == 1 )
  {
    return 1;
  }

  // TR # MP 81
  // Don't create new form if already exixting
  old_form = NULL;
  status = FI_get_form_by_name("VDPDisEnab", &old_form);
  if(status == FI_SUCCESS)
  {
    UI_status("Same Command Already Running");
    return 0;
  }

  // Show up the form if enable items exist.
  status = FIf_new ( 111, "VDPDisEnab", ci_notification, &my_form );
  status = FIf_set_cmd_oid_os ( my_form, MY_ID, OM_Gw_current_OS );
  status = FIf_display ( my_form );
  status = FIfld_set_text ( my_form, 10, 0, 0,
      "select the FSI to be Disbled", FALSE );
  // Fill in the new form
  status = FillForm();
  if(status == 1 )
  {
    return 1;
  }
  
  
  while(not_done)
  {
    ci$get(prompt = " Process Form ", response = &response);

    switch ( form_st.gadget_label )
    {
     case FI_CANCEL : 
	 ci$put(response = TERMINATE);
	 FIf_erase ( my_form);
	 not_done = 0;
	 break;
     
     case FI_ACCEPT: 
	 // if no selected object.
	 if ( DisObj.objid == 0 || DisObj.osnum ==0 )
	 {
	   ci$put(response = TERMINATE );
	   FIf_erase ( my_form );
	   not_done = 0;
	   break;
	 }

	 // get the selected object and disable it.
	 else
	 {
	   status = VDPDisableObject ( msg, DisObj );
	   // add this obj in trans list with delete code.
	   // get trans list id
	   status = VDPGetTrTblId( msg, &TrTblId );
	   // Prepare obj to be added.
	   TrRow.ActionCode = VDP_DELETE;
	   TrRow.VDSobjid = DisObj.objid;
	   TrRow.oldVDSobjid = 0;
	   TrRow.PMEobid[0] = '\0';

	   ci$send(msg = message VDPtrTbl.VDPAddtoTrTable(msg, TrRow ),
	       targetid = TrTblId.objid,
	       targetos = TrTblId.osnum );

	   ci$put(response = TERMINATE);
	   FIf_erase ( my_form);
	   not_done = 0;
	   break;
	 }

     case 18:
	 DisplayMode = GRhe;
	 ci$get_module_info ( md_env = &md_env );
	 // Erase hilite of earlier hilited obj.
	 ci$send(msg = message GRgraphics.GRdisplay( &msg,
	       		&md_env.md_env.matrix_type,
			&md_env.md_env.matrix,
			&DisplayMode, &md_env.md_id),
	     targetid = listObjs[PrevRow].obj_id.objid,
	     targetos = listObjs[PrevRow].obj_id.osnum );

	 // Get the selected object hilite it.
	 FIfld_get_active_row ( my_form, 18, &row, &pos );
	 FIfld_get_select ( my_form, 18, row, 0, &sel );
	 //If row is selected hilite.
	 if ( sel == TRUE )
	   DisplayMode = GRhd;
	 // If row is un selected erase hilite.
	 if ( sel == FALSE )
	   DisplayMode = GRhe;

	 // Hilite the selected object.
	 ci$send(msg = message GRgraphics.GRdisplay( &msg,
	       		&md_env.md_env.matrix_type,
			&md_env.md_env.matrix,
			&DisplayMode, &md_env.md_id),
	     targetid = listObjs[row].obj_id.objid,
	     targetos = listObjs[row].obj_id.osnum );

	 if( sel == TRUE )// if row selected, set obj to be disabled.
	 {
	   DisObj.objid = listObjs[row].obj_id.objid;
	   DisObj.osnum = listObjs[row].obj_id.osnum;
	 }
	 else
	 {
	   DisObj.objid = 0;
	   DisObj.osnum = 0;
	 }

	 PrevRow = row;
	 break;

     case 2: // EXECUTE BUTTON
	 FIfld_get_active_row ( my_form, 18, &row, &pos );
	 FIfld_get_select ( my_form, 18, row, 0, &sel );
	 // if no selected object.
	 if ( DisObj.objid == 0 || DisObj.osnum ==0 )
	 {
	   break;
	 }

	 // get the selected object and disable it.
	 else
	 {
	   status = VDPDisableObject ( msg, DisObj );
	   // add this obj in trans list with delete code.
	   // get trans list id
	   status = VDPGetTrTblId( msg, &TrTblId );
	   // Prepare obj to be added.
	   TrRow.ActionCode = VDP_DELETE;
	   TrRow.VDSobjid = DisObj.objid;
	   TrRow.oldVDSobjid = 0;
	   TrRow.PMEobid[0] = '\0';

	   ci$send(msg = message VDPtrTbl.VDPAddtoTrTable(msg, TrRow ),
	       targetid = TrTblId.objid,
	       targetos = TrTblId.osnum ); 
	   
	   // Erase hilite 

	   DisplayMode = GRhe;
	   ci$get_module_info ( md_env = &md_env );
	   // Erase hilite of earlier hilited obj.
	   ci$send(msg = message GRgraphics.GRdisplay( &msg,
	       		&md_env.md_env.matrix_type,
			&md_env.md_env.matrix,
			&DisplayMode, &md_env.md_id),
	     targetid = DisObj.objid,
	     targetos = DisObj.osnum );
	   FillForm();
	   break;
	 }

    } // end switch
    
  } // End while not_done
  
  free(listObjs);
  return 1;

}

// Following added for TR # MP 81
sleep()
{
  if ( my_form )
    FIf_erase ( my_form );
}

delete()
{
  if(my_form)
  {
    VDahFrmSavePositionInFile(my_form);
    FIf_delete(my_form);
  }
  my_form = NULL;
}

wakeup()
{
  UI_message("Disable F S I");
  if(my_form)
    FIf_display(my_form);
}
