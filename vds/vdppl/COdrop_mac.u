/* $Id: COdrop_mac.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $ */

/*******************************************************************************
 * I/VDS
 *
 * File:  vds/vdppl/COdrop_mac.u  (vds/ppl/bin/COdrop_mac.e)
 *
 * Description:
 *
 *      This ppl file was adapted from grnuc/src/assoc/cisrc/COm_drop.u.
 *      It was created to accept an input generator for collecting more 
 *	  than one macro occurrence to drop.
 *	It is recommended that the pocket menu command, "Elements by 
 *	  Individual Selection" be used to group macros; using "Elements
 *	  in Current File" may cause problems.
 *
 * Revision History:
 *      $Log: COdrop_mac.u,v $
 *      Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *      Initial import to CVS
 *
# Revision 1.1  1999/03/05  19:03:38  pinnacle
# TR_179802469: Creation
#
 *
 * History:
 *      MM/DD/YY    AUTHOR      DESCRIPTION
 *      3/05/99     ejm         TR_179802469: Creation
 *                              Need a Drop Macro Occurrence command that
 *				accepts a group input generator.
 **************************************************************************** */

#include "cieveryone.h"
#include "cimacros.h"
#include "msdef.h"
#include "msmacros.h"
#include "ASmessages.h"
#include "coparamac.h"  // as$start_fence
#include "growner.h"    // struct GRobj_env

extern ASstart_var_fence();
extern ASend_fence();

/*
  Command object to drop a symbol macro to non_associative graphics
*/

int 	i,suc,msg;
IGRint	locNum;
char	loc_prompt[80];
extern int		MSmessage();
struct GRid		MACRO_ID;
struct GRmd_env 	md_env;
struct GRobj_env	*locOEs;

main()
{
  IGRint  response;
  IGRint  sts;

  ci$get_module_info( md_env = &md_env );
  while(1)
  {
    response = 0;
    ex$message( field = 1,   msgnumb = AC_M_DrMc );
    ex$message( field = 3, msgnumb = AS_P_LcMcOc, buff = loc_prompt );
    sts =  ci$locate(	prompt = loc_prompt, 

/*  classes = "ACncpx",  sometimes results in a memory fault with an
	object set.
			classes = "ACncpx",
                        properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                        owner_action = LC_RIGID_COMP
                                     | LC_RIGID_OWNER | LC_FLEX_COMP
                                     | LC_FLEX_OWNER  | LC_REF_OBJECTS,
*/
			response     = &response,
			obj          = &MACRO_ID.objid,
	    		osnum        = &MACRO_ID.osnum);

    if (!(sts & 1)) response = 0;

    switch(response) {

    case EX_OBJID:   // Object Set

      /* Grab Located Objects */
      as$start_fence(
      set       = &MACRO_ID,
      set_env   = &md_env,
      nb_obj    = &locNum,
      p_obj_env = &locOEs);

      for(i = 0; i < locNum; i = i + 1) {
        MACRO_ID = locOEs[i].obj_id;
        send GRowner.GRdrop(&msg,&md_env) to MACRO_ID.objid; 
      }

      ASend_fence();
      break;

    case EX_DATA:    // Single Object
      send GRowner.GRdrop(&msg,&md_env) to MACRO_ID.objid; 
      break;

    } // Switch
  } // While
}
