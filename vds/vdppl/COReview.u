/* $Id: COReview.u,v 1.1.1.1 2001/01/04 21:09:01 cvs Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:	vdppl/COReview.u
 *
 * Description:
 *		This functionality will check all the reference files
 *		to see what libraries were attached to them. 
 *		These libraries will be proposed in a form, which allow
 *		users to attached macro libraries from the reference file
 *		to the active file.
 *
 * Dependencies:
 *		Review.frm	in config/english/forms
 *
 * Revision History:
 *	$Log: COReview.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:01  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.2  1996/11/21  20:08:28  pinnacle
# ah Form Prob
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.3  1996/01/09  20:06:12  pinnacle
# Replaced: ./vdppl/COReview.u for:  by azuurhou for vds.240
#
# Revision 1.2  1995/11/21  00:57:40  pinnacle
# Replaced: ./vdppl/COReview.u for:  by azuurhou for vds.240
#
# Revision 1.1  1995/09/13  20:04:42  pinnacle
# Created: vdppl/COReview.u by azuurhou for vds.240
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *			adz		creation date
 *	01/09/95	adz		Adapt to methods in super_para.
 *
 ***************************************************************************/

#include <stdio.h>
#include <string.h>

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_easy.h"
#include "igrtypedef.h"
#include "exmacros.h"
#include "ex.h"
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "macro.h"
#include "fi.h"
#include "dp.h"
#include "dpmacros.h"
#include "acdef.h"
#include "acmacros.h"
#include "vdrefmacros.h"


/**
#define DEBUG	1
**/

/* form stuff */

typedef char * Form;

struct CIform_st
{
   int		form_label;
   int		gadget_label;
   double	value;
   Form		form_ptr;
}form_st;

#define	VD_MAX_RefLibInfo	100
#define	VD_MAX_RefLibBuff	1024

struct  VD_s_RefLibInfo{
        GRspacenum      osnum ;
        IGRchar         buffer[VD_MAX_RefLibBuff];
} ;

struct  VD_s_RefLibInfo VDflInfo[VD_MAX_RefLibInfo];
IGRint			VDflCount ;

/*
 * Gadgets
 */
#define		FORM_NAME	"Review.frm"

#define	VDrv_EXECUTE	2
#define	VDrv_RESET	3
#define	VDrv_CANCEL	4

#define	VDrv_txtREFFILE	12
#define	VDrv_REFFILE	13

#define	VDrv_txtREFLIB	21
#define	VDrv_REFLIB	17

#define	VDrv_ADD_TO	18
#define	VDrv_DEL_FROM	19

#define	VDrv_txtTO_BE	16
#define	VDrv_TO_BE	14

#define	VDrv_txtATTACH	20
#define	VDrv_ATTACH	15

#define	VDrv_SELECT_ALL	27
#define	VDrv_CLEAR_ALL	28

#define	VDrv_tglSELECT	22
#define	VDrv_tglAUTOSAV	23

#define	VDrv_FORM_NAME	11


#define	VDrv_MACROS	100

/*
 * Form routines.
 */

extern	int	printf();

/* extern	int	strlen(); */

extern	char	*strrchr(),
		*strchr();

extern	int	ci_notification(),
		FIf_new(),
		FIf_delete(),
		FIf_display(),
		FIf_erase(),
		FIg_display(),
		FIg_erase(),
		FIf_set_cmd_oid_os(),
		FIg_get_state(),
		FIg_get_value(),
		FIg_set_text(),
		FIg_set_state(),
		FIfld_get_text(),
		FIfld_get_select(),
		FIfld_get_num_rows(),
		FIfld_get_active_row(),
		FIfld_set_text(),
		FIfld_set_select(),
		FIfld_set_num_rows(),
		FIfld_set_active_row(),
		FIfld_set_list_num_rows(),
		FIfld_set_list_default_text(),
		FIfld_erase_cursor();

extern	int	UI_status(),
		UI_prompt(),
		UI_message();

extern	int	EX_findmod(),
		EX_get_super(),
		EX_get_modid_given_osnum(),
		EX_get_global();

extern	int	ACfind_macro_defn(),
		ACconstruct_path();
extern	int	ASget_as_owner();

extern	int	DPerase_hilite();
extern	int	GRdisplay_object();

extern	int	VDget_ref_os_list();

extern	OM_p_OSD		*OM_GA_OSDs;
extern	IGRint			ACauto_save;	/* Library option */



/*
 * Global defined variables.
 */
IGRchar			VDrv_designFile[DI_PATH_MAX];
IGRchar			VDrv_save_text[DI_PATH_MAX];

struct	GRmd_env	VDrv_md_env;
struct	GRid		VDrv_modObj;

/*
 * form interface globals
 */

Form		form;
IGRint		test_wakeup;
IGRshort	form_exists,
		test_wakuep,
		save_gadget,
		form_displayed;
IGRchar		form_name[DI_PATH_MAX];

/*****************************************************************************/

fill_in_ATTACH()
{
IGRchar			buffer[DI_PATH_MAX];
IGRchar			dummy[DI_PATH_MAX];
IGRint			i, count ;
IGRchar			**lines;

#ifdef DEBUG
	write(" START fill_in_ATTACH \n");
#endif

        sprintf( buffer , ":%s:constructs_lib:", VDrv_designFile );
	count = 0;
	lines = NULL ;

#ifdef	DEBUG
	printf(" BUFFER: %s \n", buffer );
#endif

	di$find( start_dir	= buffer, 
		 ptr		= &count,
                 max_level	= 1,
		 lines		= &lines,
                 options	= OPT_LEVEL );

	if( count == 0 )
	{ 
		UI_status("No macro libraries found"); 
#ifdef	DEBUG
		write("no macro libraries found\n");
#endif
	}

	FIfld_set_num_rows( form, VDrv_ATTACH, count );

	for( i=0 ; i<count ; i=i+1 ){

		strcpy( dummy, lines[i] );
 		di$split(	pathname = lines[i],
				dirname  = NULL,
				name	 = dummy );

#ifdef	DEBUG
	printf(" [%d]: %s\t%s\n", i, dummy, lines[i] );
#endif

		FIfld_set_text( form, VDrv_ATTACH, i, 0, dummy, FALSE );
	}

	di$free( count = count, lines = lines ) ;

#ifdef DEBUG
	write("END fill_in_ATTACH \n");
#endif
}

/*****************************************************************************/

int set_macro_list( macro_lib_name )
IGRchar			*macro_lib_name;
{
IGRchar			buffer[DI_PATH_MAX];
IGRchar			dummy[DI_PATH_MAX];
IGRint			i, j, count ;
IGRchar			**lines;
OMuword			classid;
DIgrid			*grids;

extern	GRclassid	OPP_ACcpx_defn_class_id;

#ifdef DEBUG
	write("START set_macro_list\n");
#endif
	grids = NULL ;
	lines = NULL ;
	count = 0 ;

	if( strcmp( macro_lib_name, "." ) == 0 ){
		sprintf( buffer, ":%s:constructs:", VDrv_designFile );
	}
	else{
		sprintf( buffer, ":%s:constructs_lib:%s:constructs:",
					VDrv_designFile, macro_lib_name );
	}
	
#ifdef	DEBUG
	printf(" BUFFER: %s \n", buffer );
#endif

	di$find( start_dir	= buffer , 
		 ptr		= &count ,
		 grids		= &grids ,
                 max_level	= 1 ,
		 lines		= &lines ,
                 options	= OPT_LEVEL);

	FIfld_set_num_rows( form, VDrv_MACROS, 0 );

	j = 0 ;
	for( i=0 ; i<count ; i=i+1 )
	{
		om$get_classid(	objid	= grids[i].objid,
				osnum	= grids[i].osnum,
				p_classid = &classid);

		if( om$is_ancestry_valid(
			superclassid = OPP_ACcpx_defn_class_id,
                        subclassid   = classid ) != OM_S_SUCCESS ) continue;

		strcpy( dummy , lines[i] );

 		di$split( pathname	= lines[i],
                	  dirname	= NULL,
                  	  name		= dummy );

#ifdef	DEBUG
	printf(" [%d]: %s\t%s\n", i, dummy, lines[i] );
#endif

		FIfld_set_num_rows( form, VDrv_MACROS, j+1 );
		FIfld_set_text( form, VDrv_MACROS, j, 0, dummy, FALSE );
		j=j+1;
	}

	di$free( count = count, lines = lines ) ;
	if( grids ) free( grids );

#ifdef DEBUG
	write(" END set_macro_list()\n");
#endif
	return( TRUE );
}

/*****************************************************************************/

init ()
{
	UI_message(" Review Reference Libraries" );
	UI_prompt(" Fill in form paramters ");
}

/*****************************************************************************/

delete()
{
#ifdef DEBUG
	write("START delete\n");
#endif

//	FIf_erase( form );
	if (form) FIf_delete( form );

#ifdef DEBUG
	write("END delete\n");
#endif
}

/*****************************************************************************/

init_session()
{
long		msg;
int		sts,
		macro_level,
		rep_max;

#ifdef	DEBUG
	printf(" START init_session \n" );
#endif

	VDrv_designFile[0]	= '\0';
	VDrv_save_text[0]	= '\0';

	form			= NULL;

	test_wakeup		= 1;
	form_exists		= FALSE;
	form_displayed		= FALSE;

	ci$get_module_info( md_env = &VDrv_md_env );

	VDrv_modObj.objid	= NULL_OBJID ;
	VDrv_modObj.osnum	= VDrv_md_env.md_id.osnum ;

	VDflCount		= 0 ;

#ifdef	DEBUG
	printf(" END init_session \n" );
#endif
}

/*****************************************************************************/

lib_get_info( info )

struct	VD_s_RefLibInfo		**info ;
{
IGRlong		msg ;
IGRint		sts ;
IGRint		i,
		size,
		osCnt ;
GRspacenum	*osList; 
struct	GRid	superId,
		superMod ;

#ifdef	DEBUG
	printf(" START lib_get_info \n" );
#endif

	/*
	 * Check object space about current situation.
	 */
	*info		= NULL ;
	VDflCount	= 0 ;

	osList		= NULL ;
	osCnt		= 0 ;

	for( i=0 ; i<VD_MAX_RefLibInfo ; i=i+1 ){
		VDflInfo[i].osnum = 0 ;
		VDflInfo[i].buffer[0] = '\0';
	}

#ifdef  DEBUG
	printf(" Get vd$get_ref_os_list \n");
#endif

	sts =
	vd$get_ref_os_list(	msg		= &msg ,
				main_os		= &VDrv_modObj.osnum,
				num_ref_os	= &osCnt,
				ref_os_list	= &osList );
	if( !(sts&1) ){ goto wrapup ; };

	if( osCnt == 0 ){
#ifdef	DEBUG
	  printf(" No Reference Files Found\n");
#endif
	  UI_status(" No Reference Files Found ");
	  return FALSE ;
	}
	  
#ifdef	DEBUG
	printf(" # ObjectSpace: %d\n", osCnt );
#endif

	for( i=0 ; i<osCnt ; i=i+1 ){

#ifdef	DEBUG
	  printf(" Objectspace[%d/%d]: %d\n", i, osCnt, osList[i] );
#endif

	  superMod.objid = NULL_OBJID ;
	  superMod.osnum = osList[i]  ;
	  sts =
	  ex$get_modid(	mod_osnum	= superMod.osnum,
			mod_id		= &superMod.objid );

	  superId.objid = NULL_OBJID ;
	  sts =
	  ex$get_super(		create		= 0,
				mod_id		= superMod.objid,
				mod_osnum	= superMod.osnum,
				super_name	= "super_para",
				super_class	= "super_para",
				super_id	= &(superId.objid),
				super_osnum	= &(superId.osnum) );
	  if( sts&1 ){

#ifdef	DEBUG
	    printf(" superId : %d,%d\n", superId.osnum, superId.objid );
#endif
	    sts =
	    ci$send(msg = message super_para.give_path_size( &size ),
		    targetid = superId.objid,
		    targetos = superId.osnum );
	    if( sts&1 || size < VD_MAX_RefLibBuff ){

	      if( VDflCount < VD_MAX_RefLibInfo ){
		VDflInfo[VDflCount].osnum	= superId.osnum ;
	        sts =
		ci$send(msg = message super_para.give_path(
					VDflInfo[VDflCount].buffer ),
			targetid = superId.objid,
			targetos = superId.osnum );
		if( sts&1 ){
#ifdef	DEBUG
		  printf(" [%d]: %s\n", VDflCount,VDflInfo[VDflCount].buffer);
#endif
		  VDflCount = VDflCount +1 ;
		}
	      }
	      else{
#ifdef	DEBUG
		printf("Max Reference Checking List ");
#endif
	        break ;
	      }
	    }
	  }
	}

#ifdef	DEBUG
	printf(" END lib_get_info \n" );
#endif

wrapup:
	
	*info	= VDflInfo ;
	if( osList ) free( osList );
	return FALSE ;
}

/*****************************************************************************/

form_notification()
{
IGRint			sts,num,state;
IGRint			i, row,sel,pos;
IGRchar			buffer[DI_PATH_MAX];

#ifdef DEBUG
	write(" START form_notification()\n");
#endif

    UI_message( "Review Reference Libraries " );

    save_gadget = form_st.gadget_label;

    switch ( form_st.gadget_label )
    {
	case 	VDrv_EXECUTE :

		process_TO_BE();

	case	VDrv_RESET :

		fill_in_form();
		
		break;

	case	VDrv_CANCEL :

		ci$put(	response	= MOVE_ON );
		break;

	case	VDrv_REFFILE :
		/*
		 * User selected an row.
		 */
                row = 0;
                FIfld_get_active_row( form, VDrv_REFFILE, &row, &pos );
                FIfld_get_text( form, VDrv_REFFILE, row, 0, DI_PATH_MAX,
                                        buffer, &sel, &pos );

#ifdef	DEBUG
		printf(" REFFILE : %s\n", buffer );
#endif

		clean_gadget( VDrv_REFLIB );
		FIg_set_state( form, VDrv_tglSELECT, FALSE );
		fill_in_REFLIB( buffer );
		
		break ;

	case	VDrv_tglAUTOSAV :

		/*
		 * Do Nothing.
		 */
		break ;

	case	VDrv_tglSELECT :

		FIg_get_state( form, VDrv_tglSELECT, &state );
#ifdef	DEBUG
		printf(" Current State : %d\n", state );
#endif
		if( ! state ){
			/*
			 * State is "Show All File".
			 */
			clean_gadget( VDrv_REFLIB );
			clean_gadget( VDrv_REFFILE );
			fill_in_REFFILE();
		}
		else{
			/*
			 * State is "Show Per Files"
			 */
			clean_gadget( VDrv_REFLIB );
			clean_gadget( VDrv_REFFILE );
			fill_in_REFFILE();

			FIfld_get_num_rows( form, VDrv_REFFILE, &row );
#ifdef	DEBUG
			printf(" TO_DO form_not : %d\n", row );
#endif
			for( i=0 ; i<row ; i=i+1 ){
			  buffer[0] = '\0';
			  FIfld_get_text( form, VDrv_REFFILE, i, 0,
					DI_PATH_MAX, buffer, &sel, &pos );
			  fill_in_REFLIB( buffer );
			}
		}

		break;

	case	VDrv_REFLIB :

		/*
		 * User select one or more libraries to add.
		 */
		break ;

	case	VDrv_SELECT_ALL :

                row = 0;
                sel = TRUE ;
                FIfld_get_num_rows( form, VDrv_REFLIB, &row );

                for( i=0 ; i<row ; i=i+1 ){
                  FIfld_set_select( form, VDrv_REFLIB, i, 0, sel );
                }
		break ;

	case	VDrv_CLEAR_ALL :

                row = 0;
                sel = FALSE ;
                FIfld_get_num_rows( form, VDrv_REFLIB, &row );
                for( i=0 ; i<row ; i=i+1 ){
                  FIfld_set_select( form, VDrv_REFLIB, i, 0, sel );
                }
		break ;

	case	VDrv_ADD_TO :

		/*
		 * Get the list of select library files from the 
		 * 'Reference Libraries' list and put them in the
		 * 'To Be Attached' list.
		 */
                row = 0;
                sel = TRUE ;
                FIfld_get_num_rows( form, VDrv_REFLIB, &row );

        	for( i=0 ; i<row ; i=i+1 ){

		  FIfld_get_text( form, VDrv_REFLIB, i, 0,
				DI_PATH_MAX, buffer, &sel, &pos );
                  if( sel ){
			add_in_list( VDrv_TO_BE, buffer );
                        /*
                         * set flag off.
                         */
                        FIfld_set_select( form, VDrv_REFLIB, i, 0, FALSE );
		  } /* if( sel ) */
                } /* for ... */

		break ;

	case	VDrv_DEL_FROM :

		/*
		 * Get the list of select library files from the
		 * 'To Be Attached' list and delete them from this list.
		 */
                row = 0;
		state = FALSE ;
                sel = TRUE ;
                FIfld_get_num_rows( form, VDrv_TO_BE, &row );

        	for( i=0 ; i<row ; i=i+1 ){
		  FIfld_get_text( form, VDrv_TO_BE, i, 0,
				DI_PATH_MAX, buffer, &sel, &pos );
                  if( sel ){
                        /*
                         * set flag off.
                         */
                        FIfld_set_text( form, VDrv_TO_BE, i, 0, "", FALSE );
			state = TRUE ;
		  } /* if( sel ) */
		}

		/*
		 * Cleanup the gaps in the gadget.
		 */
		if( state ) clean_gaps( VDrv_TO_BE );

		break ;

	case	VDrv_TO_BE :

		/*
		 * Select mode for 'To Be Attached' library files.
		 */
		break ;

	case	VDrv_ATTACH :

		/*
		 * Review mode only to show what's currently attached.
		 */
		break ;

	default:

#ifdef	DEBUG
		write(" form_not: unexpected state \n");
#endif
		break;
	}

#ifdef DEBUG
	printf("END form_notification\n");
#endif
}

/*****************************************************************************/

process_TO_BE()
{
IGRint		i;
IGRint		first, sel, pos, rows;
IGRchar		buffer[DI_PATH_MAX];

#ifdef DEBUG
	printf("START process_TO_BE\n");
#endif
	rows = 0 ;
	first = 1;
	FIg_get_state( form, VDrv_tglAUTOSAV, &ACauto_save );

	FIfld_get_num_rows( form, VDrv_ATTACH, &rows );
	if( rows ) first = 0 ;

#ifdef	DEBUG
	printf(" ATTACH [%d] : flag :%d\n", rows, first );
#endif

	FIfld_get_num_rows( form, VDrv_TO_BE, &rows );
	for( i=0 ; i<rows ; i=i+1 ){
	  FIfld_get_text( form, VDrv_TO_BE, i, 0, DI_PATH_MAX,
			  buffer, &sel, &pos );

#ifdef	DEBUG
	  printf(" PROCESS : %s\n", buffer );
#endif
	  if(buffer[0] != '\0'){

	    if(first){
		ac$construct_path(	mode = AC_SET,
					name = buffer );
	    }
	    else{
		ac$construct_path(	mode = AC_ADD_PATH,
					name = buffer);
	    }
            first = 0;
          }
	}

	UI_status(" List of Active Libraries Updated ");

#ifdef DEBUG
	printf("END process_TO_BE\n");
#endif

}

/*****************************************************************************/

check_in_list( gadget, name )
int		gadget ;
char		*name ;
{
int		i, sel, pos, rows;
IGRchar		buffer[DI_PATH_MAX];

	rows = 0 ;

	FIfld_get_num_rows( form, gadget, &rows );

	for( i=0 ; i<rows ; i=i+1 ){
	  FIfld_get_text( form, gadget, i, 0, DI_PATH_MAX, buffer, &sel, &pos );
	  if( ! strcmp( name, buffer )){ break; }
	}
	if( i == rows )	return FALSE ;
	
	return TRUE ;
}

/*****************************************************************************/

add_in_list( gadget, name )
int		gadget ;
char		*name ;
{
IGRint		i;
IGRint		sel, pos, rows;
IGRchar		buffer[DI_PATH_MAX];

	rows = 0 ;

	FIfld_get_num_rows( form, gadget, &rows );
#ifdef	DEBUG
	printf(" TO_DO add_in_list : %d\n", rows );
#endif

	for( i=0 ; i<rows ; i=i+1 ){
	  FIfld_get_text( form, gadget, i, 0, DI_PATH_MAX, buffer, &sel, &pos );
	  if( ! strcmp( name, buffer )){ break; }
	}

	if( i == rows ){
	  FIfld_set_num_rows( form, gadget, rows+1 );
	  FIfld_set_text( form, gadget, rows, 0, name, FALSE );
	}
}

/*****************************************************************************/

wakeup()
{
#ifdef DEBUG
	write("START wakeup\n");
#endif

	if( test_wakeup == 1)
	{
		if (form) FIf_display( form );
		form_displayed = TRUE;
	}

#ifdef DEBUG
	write("END wakeup\n");
#endif
}

/*****************************************************************************/

sleep()
{
#ifdef DEBUG
	write("START sleep\n");
#endif

	if( form_displayed == TRUE)
	{
		if (form) FIf_erase( form );
		form_displayed = FALSE;
	}

#ifdef DEBUG
	write("END sleep\n");
#endif
}

/**************************************************************************/

get_file_and_env()
{
IGRint			var_size[3];
IGRint			msg, error;
struct	EX_var_list	ex_var[2];

#ifdef DEBUG
	write("START get_file_and_env\n");
#endif

	var_size[0] = sizeof( VDrv_designFile );

	ex_var[0].var		= EX_CUR_FILENAME;
	ex_var[0].var_value	= &VDrv_designFile[0];
	ex_var[0].num_bytes	= &var_size[0];
	ex_var[1].var		= NULL;

	msg =
	ex$global(	mode	= 0,
			var	= ex_var,
			which_error = &error );

	if(msg != 1 ){
		write("ex_global failed" , error, "\n");
		write("EX_CUR_FILENAME",EX_CUR_FILENAME,"\n");
		write("EX_WORKING_DIR",EX_WORKING_DIR,"\n");
		write("EX_SUPPORT_DIR",EX_SUPPORT_DIR,"\n");
	}

	ex$get_cur_mod(	id	= &VDrv_modObj.objid,
			osnum	= &VDrv_modObj.osnum );

#ifdef DEBUG
	printf(" filename : %s \n", VDrv_designFile );
#endif

#ifdef DEBUG
	write("END get_file_and_env\n");
#endif
}

/*****************************************************************************/

clean_gaps( gadget )
int		gadget;

{
int		i, j, rows0, rows1 ;
int		sel, pos, len;
char		buffer[DI_PATH_MAX];

#ifdef DEBUG
	printf("START clean_gaps : %d \n", gadget );
#endif

	FIfld_get_num_rows( form, gadget, &rows0 );

#ifdef	DEBUG
	printf(" TO_DO clean_gaps : %d\n", rows0 );
#endif

	rows1 = rows0;
	for( i=0 ; i<rows0 ; i=i+1 ){
	  buffer[0] = '\0';
	  FIfld_get_text( form, gadget, i, 0, DI_PATH_MAX, buffer, &sel, &pos);

#ifdef	DEBUG
	  printf(" Check [%d]: %d >%s< \n", i, strlen(buffer), buffer );
#endif
	  len = strlen( buffer ) ;
	  if( len == 0 ){
	    for( j=i+1 ; j<rows1 ; j=j+1 ){
		buffer[0] = '\0';
		FIfld_get_text( form, gadget, j, 0, DI_PATH_MAX, 
				buffer, &sel, &pos );
		FIfld_set_text( form, gadget, j-1, 0, buffer, FALSE );
	    }
	    rows1 = rows0 - 1;
	    rows0 = rows1 ;
#ifdef	DEBUG
	    printf(" Reduce : %d\n", rows0 );
#endif
	    FIfld_set_num_rows( form, gadget, rows0 );
	  }
	}

	FIfld_get_num_rows( form, gadget, &rows0 );

#ifdef	DEBUG
	printf(" set_select : %d\n", rows0 );
#endif
	for( i=0 ; i<rows0 ; i=i+1 ){
	  FIfld_set_select( form, gadget, i, 0, FALSE );
	}

#ifdef	DEBUG
	printf("END clean_gaps : %d \n", gadget );
#endif
}

/*****************************************************************************/

clean_gadget( gadget )

int		gadget;
{
int		i, rows;
char		buffer[DI_PATH_MAX];

#ifdef DEBUG
	printf("START clean_gadget : %d\n", gadget );
#endif

	FIfld_erase_cursor( form, gadget );
	FIfld_get_num_rows( form, gadget, &rows );

#ifdef	DEBUG
	printf(" TO_DO clean_gadget : %d\n", rows );
#endif

	buffer[0] = '\0';
	for( i=0 ; i<rows ; i=i+1 ){
	  FIfld_set_text( form, gadget, i, 0, buffer, FALSE );
	}
	FIfld_set_num_rows( form, gadget, 0 );

#ifdef DEBUG
	write("END clean_gadget\n");
#endif
}

/*****************************************************************************/

fill_in_form()
{
	/*
	 * Cleanup the form.
	 */
	clean_gadget( VDrv_REFFILE );
	clean_gadget( VDrv_REFLIB );
	clean_gadget( VDrv_TO_BE );
	clean_gadget( VDrv_ATTACH );

	fill_in_ATTACH();
	fill_in_REFFILE();
}

/*****************************************************************************/

fill_in_REFFILE()
{
IGRint			i, sts ;
IGRlong			msg ;
struct VD_s_RefLibInfo	*info ;
IGRchar                 *c,*c1;
IGRchar			pathName[DI_PATH_MAX];

#ifdef DEBUG
	printf("START fill_in_REFFILE\n");
#endif

	/*
	 * Get the information pointer.
	 */

	info	= NULL ;
	lib_get_info( &info );
	if( info == NULL )	return FALSE ;

	/*
	 * VD_MAX_RefLibInfo is the maximum of the internel buffer.
	 */
#ifdef	DEBUG
	printf(" MAX_LIB : %d\n", VDflCount );
#endif

        for( i=0 ; i<VDflCount && i<VD_MAX_RefLibInfo ; i=i+1 ){

#ifdef	DEBUG
	  printf("SPACE[%d/%d] : %d\n", i, VD_MAX_RefLibInfo, info[i].osnum );
#endif
          if( info[i].osnum != 0 ){

            /*
             * Check if the object space is active.
             */
            if( OM_GA_OSDs[ info[i].osnum ] ){


                di$give_pathname(       osnum	= info[i].osnum,
                                        pathname = pathName );

		c = strrchr( pathName, ':' );
		if( c ){ add_in_list( VDrv_REFFILE, &c[1] ) ; }

	    } /*  OM_GA_OSDs[ info[i].osnum ] */
	  } /*  info[i].osnum != 0 */
	} /* for ... */

#ifdef DEBUG
	printf("END fill_in_REFFILE\n");
#endif
	return TRUE ;
}

/*****************************************************************************/

fill_in_REFLIB( file )
char		*file ;
{
IGRint			i, len, sts ;
IGRlong			msg ;
struct VD_s_RefLibInfo	*info ;
IGRchar                 *c,*c1;
IGRchar                 *p,*p1;
IGRchar			infoName[DI_PATH_MAX];
DIspacenum		refOs ;

#ifdef	DEBUG
	printf("START fill_in_REFLIB %s\n", file );
#endif

	info	= NULL ;
	lib_get_info( &info );
	if( info == NULL )	return FALSE ;

	refOs = -1 ;
	for( i=0 ; i< OM_Gw_maxOS ; i=i+1 ){
	  if( OM_GA_OSDs[ i ] ){
	    c = strrchr( OM_GA_OSDs[i]->name, '/' );
	    if( c ){
		c1 = c + 1 ;
		if( strcmp( c1, file ) == 0 ){
			refOs = i ;
			break ;
		}
	    }
	  }
	}

	if( refOs == -1 ) return FALSE ;

#ifdef	DEBUG
	printf(" REF OS : %d\n", refOs );
#endif

	/*
	 * VD_MAX_RefLibInfo is the hardcoded limit of design files.
	 */
	c = NULL ;
        for( i=0 ; i<VD_MAX_RefLibInfo ; i=i+1 ){
          if( info[i].osnum != 0 ){
	    if( info[i].osnum == refOs ){
               	c = info[i].buffer ;
		break ;
	    }
	  }
	}

	if( c == NULL )	return FALSE ;

	/*
	 * Display the buffer information into the form.
	 * Layout:
	 * 	"LibraryA,LibraryB,LibraryC,LibraryD".
	 */

        while( c != NULL ){
                c1 = strchr( c, ',');
                if( c1 != NULL ) *c1 = '\0';

		/*
		 * Correction to following cases:
		 * - "."				=> DGN_FILE
		 * - /part/l/custom/ppl/bin/LIBNAME"	=> LIBNAME
		 */
		len = strlen( c );
#ifdef	DEBUG
                printf("\tLIBRARY : %s\n", c );
#endif
		if(( len == 1 )&&(  c[0] == '.' )){
			sprintf( infoName,
				"Warning: File %s has internal library ",
				file );
			UI_status( file );
		}
		else{

		  /*
		   * Get right of total path storage.
		   */
		  p = NULL ;
		  p = strrchr( c, '/' );
		  if( p != NULL ){ 
			p1 = p+1 ;
			strcpy( infoName, p1 );
		  }
		  else	strcpy( infoName, c );

		  sts = check_in_list( VDrv_ATTACH, infoName );
		  if( sts == FALSE )	add_in_list( VDrv_REFLIB, infoName );

		}

                if( c1 == NULL ) break;
                c = c1+1;
                *c1 = ',';
	}

#ifdef	DEBUG
	printf("END fill_in_REFLIB %s\n", file );
#endif
	return	TRUE ;
}

/*****************************************************************************/

main()
{
IGRchar		*event_name;
IGRint		response;

#ifdef DEBUG
	printf("START main\n");
#endif
	/*
	 * Initialization of used globals.
	 */
	init_session();

	/*
	 * Get current filename and environment.
	 */
	get_file_and_env();

	if( FIf_new( 0, FORM_NAME, ci_notification, &form ))
	{
		printf("ERROR: initializing form\n");
		goto end_process;
	}
	else form_exists = TRUE;

	if( form ){

		if( FIf_set_cmd_oid_os(	form,
					MY_ID,
					OM_Gw_current_OS )){
			write("something went wrong in FIf_set_cmd_oid_os\n");
			form_exists = FALSE;	
			goto end_process;
		}

		if( FIf_display( form )){
			write("something went wrong in FIf_set_cmd_oid_os\n");
			form_exists = FALSE;	
			goto end_process;
		}
	}
	else form_displayed = TRUE;

	FIfld_set_num_rows( form, VDrv_REFFILE,	0 );
	FIfld_set_num_rows( form, VDrv_REFLIB,	0 );
	FIfld_set_num_rows( form, VDrv_TO_BE,	0 );
	FIfld_set_num_rows( form, VDrv_ATTACH,	0 );
	FIg_set_state( form, VDrv_tglSELECT, FALSE);
	FIg_set_state( form, VDrv_tglAUTOSAV, ACauto_save );

	fill_in_form();
	
	while(1){

		UI_message( "Review Reference Libraries " );
		ci$getevent( 
			prompt	 = "Process Form Information",
			data 	 = event_name, 
			response = &response);

 		if (response == EX_BACK_UP )
		{
			break;
		}
		else if( response == MOVE_ON ||
			 save_gadget == 4    ||
			 save_gadget == 2 ) break;	
	}

	UI_status("");

end_process :

	UI_message("");

#ifdef DEBUG
	printf("END main\n");
#endif
}
