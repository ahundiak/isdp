/* $Id: COz_FixTags.u,v 1.1 2001/01/18 20:38:24 hans Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/vdppl/COz_FixTags.u
 *
 * Description: Adds tags to objects missing them
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_FixTags.u,v $
 *	Revision 1.1  2001/01/18 20:38:24  hans
 *	SP16 additions/modifications
 *	
# Revision 1.2  2001/01/10  13:45:40  pinnacle
# Replaced: vds/vdppl/COz_FixTags.u for:  by rchennup for Service Pack
#
# Revision 1.1  2000/10/19  16:31:16  pinnacle
# ah
#
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 10/18/00  ah      Creation
 * 01/10/01  RR	     Add Tags to all "Taggable" NDnode objects.
 * -------------------------------------------------------------------*/
#include "VDppl.h"
#include "VDobj.h"

#include "OMtags.h"
#include "OMintprims.h"

extern VDclassid OPP_NDnode_class_id;

extern EX_findmod();

/* -----------------------------------------------
 * List all tags in the vla
 */
IGRstat dump_tags()
{
  IGRstat sts;
  
  TGRid tagID;

  OM_p_TAG_RECORD  tags;        /*  vla of tag records.  */
  OMuint           tagCnt;	/*  size of tag record vla. */
  IGRint i;

  FILE *file;
  
  tagID.osnum = 2;
  tagID.objid = OM_GA_tag_oids[tagID.osnum];

  sts = ci$send(msg = message OMTag.get_record_vla(&tags, &tagCnt, NULL),
                 targetid = tagID.objid,
                 targetos = tagID.osnum);

  printf("OMTag has %d entries\n",tagCnt);
  
  file = fopen("tags.lst","wt");
  if (file == NULL) return 0;
  for(i = 0; i < tagCnt; i = i + 1) {

    fprintf(file,"%8d %8d %6d %6d\n",
	    tags[i].objid,
	    tags[i].tag,
	    tags[i].version,i);
    
  }
  fclose(file);
  printf("Tags written to tags.lst\n");
  
  return 1;
  
}
IGRint missingTagCnt;
IGRint addedTagCnt;

/* -----------------------------------------------
 * Process an object
 */
IGRstat process(objID)
  TGRid *objID;
{
  IGRstat 		retFlag;
  IGRstat 		sts;
  OMuint 		tag;
  OM_p_CLASSDEF         p_ACLD;
 
  retFlag = 0;

  sts = vdobj$IsAncestryValid(objID = objID, 
			      superClassID = OPP_NDnode_class_id);
  if (!(sts & 1)) {
     goto wrapup;
  }

  om$get_class( osnum  = objID->osnum,
                objid  = objID->objid,
                pp_cld = &p_ACLD );
  
  // Get the tag
  tag = 0;
  om$objid_to_tag(osnum = objID->osnum,
		  objid = objID->objid,
		  p_tag = &tag);
  if (tag > 0) {
    // printf("Tag %d for %d\n",tag,objID->objid);
    retFlag = 1;
    goto wrapup;
  }

  if( !( p_ACLD->flags & OM_CLDf_TAGGABLE) )
  {
     //Object is not taggable.
     retFlag = 1;
     goto wrapup;
  }
    
  // Try to add it
  om$add_tag(osnum = objID->osnum,
	     objid = objID->objid,
	     p_tag = &tag);
  
  // Verify worked
  tag = 0;
  om$objid_to_tag(osnum = objID->osnum,
		  objid = objID->objid,
		  p_tag = &tag);
  if (tag > 0) {
    printf("Added tag %d for %d\n",tag,objID->objid);
    vdobj$Print(objID = objID);
    addedTagCnt = addedTagCnt + 1;
    retFlag = 1;
    goto wrapup;
  }

  // Report it
  printf("No tag for %d\n",objID->objid);
  missingTagCnt = missingTagCnt + 1;
  
 wrapup:
  return retFlag;
}

/* -----------------------------------------------
 * Main Routine
 */
main()
{
  IGRint max,i;
  TGRid  theID;

  IGRchar buf[128];
  
  missingTagCnt = 0;
  addedTagCnt = 0;

  if( !OM_Gf_tagging_enabled )
  {
    UI_status("Tagging is Disabled" );
    return 1;
  }
  
  // Cycle through current os
  ex$get_cur_mod(osnum = &theID.osnum);

#if 0
  theID.objid = 21918;
  process(&theID);
#endif

#if 1  

  UI_status("Scanning tags...");
  
  max = OM_GA_OSDs[theID.osnum]->CurSpaceMapSize;
  for(i = 0; i < max; i = i + 1) {
    theID.objid = i;
    process(&theID);
  }
#endif

  sprintf(buf,
	  "Added %d tags, Could not fix %d tags",
	  addedTagCnt,
	  missingTagCnt);

  UI_status(buf);
    
  return 1;
}
