/* $Id: VDclean_nci.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	VDclean_nci.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDclean_nci.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1999/09/13  15:24:06  pinnacle
# Created: vdppl/VDclean_nci.u by impd251 for vds
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	08/12/99	HF		Creation date
 *
 * -------------------------------------------------------------------*/

/*
 * PPL VDclean_nci.u
 *
 * This PPL provides a very fast function to find ALL objects of a particular CLASSID
 * in the specified object space (no locate required !!!).
 *
 * Usage: "ci=VDclean_nci"
 *
 * Following is an example of how to find & list ALL OPP_nci_macro_class_id's in OS 2
 */

#include <stdio.h>
#include <cieveryone.h>
#include <cimacros.h>
#include "OMindex.h"
#include <grmacros.h>

extern			VDpms_find_objects();
extern			GRdelete_object();

extern GRclassid	OPP_nci_macro_class_id;
extern GRclassid	OPP_expression_class_id;

main()
{
  char		       *c;
  int		        i0, j0, k0, m0, cnt, sts, chcnt[5];
  long     		msg;

  struct GRid	        obj_id;
  struct GRmd_env       ModuleInfo;

  struct GRid           macro;
  OM_S_OBJID	       *list;
  GRclassid	        class_id;
  OM_S_CHANSELECT       my_chansel[5];
  OM_S_OBJECT_LINKAGE	objet;

  my_chansel[0].type       = OM_e_name;
  my_chansel[1].type       = OM_e_name;
  my_chansel[2].type       = OM_e_name;
  my_chansel[3].type       = OM_e_name;
  my_chansel[4].type       = OM_e_name;
  my_chansel[0].u_sel.name = "children";
  my_chansel[1].u_sel.name = "father";
  my_chansel[2].u_sel.name = "notification";
  my_chansel[3].u_sel.name = "to_owners";
  my_chansel[4].u_sel.name = "to_components";

  class_id = OPP_expression_class_id;
  class_id = OPP_nci_macro_class_id;

  message ( "Delete all obsolete pla_encomp nci_macro's" );

  sts = VDpms_find_objects ( 2, class_id, &cnt, NULL );

  printf ( "\nVDpms_find_objects() : sts = %d, Number of objects = %d\n", sts, cnt );

  list = ( OM_S_OBJID * ) om$malloc ( size = cnt * sizeof ( OM_S_OBJID ) );

  ci$get_module_info ( md_env = &ModuleInfo );

  if ( list )
  {
    sts = VDpms_find_objects ( 2, class_id, &cnt, list );

    j0 = 0;
    m0 = 0;
    obj_id.osnum  = 2;
    objet.osnum   = 2;

    for ( i0=0; i0 < cnt; i0=i0+1)
    {
      c = NULL;
      sts =
	ci$send (	msg	 = message ACcpx.find_macro ( &macro ),
			targetid = list[i0],
			targetos = (OMuword)2);
      sts =
	ci$send (	msg	 = message ACcpx_defn.ACgive_name ( &c ),
			targetid = macro.objid,
			targetos = macro.osnum);

      objet.S_objid = list[i0];
      obj_id.objid  = list[i0];

      if ( strcmp ( c, "pla_encomp" ) == 0 )
      {
        for ( k0=0; k0 < 5; k0=k0+1)
        {
          sts = om$get_channel_count ( osnum		= objet.osnum,
                                       objid		= objet.S_objid,
                                       p_chanselect	= &my_chansel[k0],
                                       count		= &chcnt[k0] );
        }
        if ( chcnt[0] == 0 && chcnt[1] == 0 && chcnt[2] == 0 && chcnt[3] == 0 && chcnt[4] == 0 )
        {
          m0 = m0+1;
          gr$delete_object ( msg	  = &msg,
                             object_id    = &obj_id,
                             md_env       = &ModuleInfo,
                             display_flag = 0 );
        }
        else
        {
          printf ( "%8d %-14s %d, %d, %d, %d, %d\n", list[i0], c, chcnt[0], chcnt[1], chcnt[2], chcnt[3], chcnt[4] );
        }
        j0 = j0+1;
      }
    }
    printf ( "\nNumber of nci_macro's = %d, # of pla_encomp = %d, # of deleted(obsolete pla_encomp) = %d\n", cnt, j0, m0 );

    if (list)
    {
      om$dealloc ( ptr = list );
      list = NULL;
    }
  }
}
