/* $Id: COz_copyLo.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:	vdppl/COz_copyLo.u
 *
 * Description:
 *	This command copies table layouts/summarization criteria/sort criteria
 *	from a specified reference file into the active design file.
 *
 * Dependencies:
 *	Table Layout object.
 *
 * Revision History:
 *	$Log: COz_copyLo.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1996/04/01  16:45:36  pinnacle
# Replaced: vdppl/COz_copyLo.u for:  by kddinov for vds.240
#
# Revision 1.1  1995/11/07  15:53:56  pinnacle
# Created: vdppl/COz_copyLo.u by azuurhou for vds.240
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	09/27/95	rmn		creation date
 *
 ***************************************************************************/

#include <stdio.h>
#include <string.h>

#include "ciminimum.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "cilocate.h"
#include "cievent.h"

#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"

#include "exmacros.h"
#include "AS_status.h"

/*
#define	vdsDEBUG
*/

#include "v_dbgmacros.h"

#define LAYOUT_DIR	":table_layouts"
#define SUMMCRIT_DIR	":summ_criteria"
#define SORTCRIT_DIR	":sort_criteria"

#define BUF_SIZE	100

extern 	printf(), 
	malloc(),
	free(),
	EX_findmod(),
	UI_status();

main()
{
    OMuword			curOs;
    IGRlong			status,
				msg;	
    IGRint			i, len,
				rc,
				response,
				nbLayouts;
    struct GRevent	 	event;
    IGRchar			refName[DI_PATH_MAX],
				cmdName[BUF_SIZE],
				loName[DI_PATH_MAX],
				loType[DI_PATH_MAX],
				curLoName[DI_PATH_MAX],
				curLoDir[DI_PATH_MAX],
				tmpName[DI_PATH_MAX],
				curDir[DI_PATH_MAX],
				pathName[DI_PATH_MAX],
				fullPath[DI_PATH_MAX],
				info[BUF_SIZE];
    struct GRid			dirObj,
				obj,
				cpyObj;
    struct GRmd_env		modEnv, 
				objEnv,
				cpyEnv;

    strcpy( cmdName, "Copy table layouts to active file" );
    message( cmdName );

    /* get current osnum */

    ex$get_cur_mod( osnum = &curOs );

    /* osnum of object copy */

    cpyObj.osnum = curOs;

    /* get directory path name */

    status = di$give_pathname(	osnum		= curOs,
				pathname	= pathName );
    as$status();
    __DBGpr_str( "Path name", pathName );

    /* save current directory */

    status = di$pwd( dirname = curDir );
    __DBGpr_str( "Current directory", curDir );

    /* get current module environment */

    ci$get_module_info( md_env	= &modEnv );

REPEAT :

    while( 1 )
    {
	ci$getevent(	response	= &response,
			event		= &event,
			prompt		= "Key in Reference Filename ");

	if ( response != STRING )
	    continue;

	if( !strcmp( event.event.keyin, "quit") )
	    goto wrapup;

	strncpy( refName, event.event.keyin, DI_PATH_MAX );
	refName[ DI_PATH_MAX-1 ] = '\0';
	__DBGpr_str( "\n\tReference file name", refName );

	/*
	 * validate the file name 
	 */

    	sprintf( fullPath, "%s:ref:", pathName );
    	__DBGpr_str( "Directory path name", fullPath );

	len = strlen( fullPath );

	strncat( fullPath, refName, DI_PATH_MAX-len );
	fullPath[ DI_PATH_MAX-1 ] = '\0';
	__DBGpr_str( "Full Path name", fullPath );

	status = di$translate(	objname	= fullPath,
				p_objid	= &dirObj.objid,
				p_osnum	= &dirObj.osnum );

	if( status != DIR_S_SUCCESS )
	{
	    UI_status( "Invalid reference file name" );
	    continue;
	}

GET_LAYOUT_TYPE :

	/* get type of layouts to be copied */

	ci$getevent(	response	= &response,
			event		= &event,
			prompt		= "Layout=1 / Summ crit=2 / Sort crit=3 ? " );

	if ( response != VALUE )
	    goto GET_LAYOUT_TYPE;

	__DBGpr_dbl( "Input", event.event.value );

	if( event.event.value == 1 )
	    strcpy( loType, LAYOUT_DIR );
	else if( event.event.value == 2 )
	    strcpy( loType, SUMMCRIT_DIR );
	else if( event.event.value == 3 )
	    strcpy( loType, SORTCRIT_DIR );
	else
	{
	    UI_status( "Invalid input type" );
	    goto GET_LAYOUT_TYPE;
	}
	
	__DBGpr_str( "Layout type", loType );

	/* get the table layouts directory */

	len = strlen( fullPath );

	strncat( fullPath, loType, DI_PATH_MAX-len );
	fullPath[ DI_PATH_MAX-1 ] = '\0';

	/* check if layouts directory exists in reference file */

	__DBGpr_str( "Checking for existence of layout directory", fullPath );
	status = di$translate(	objname	= fullPath,
				p_objid	= &dirObj.objid,
				p_osnum	= &dirObj.osnum );

	if( status != DIR_S_SUCCESS )
	{
	    UI_status( "No layouts found in reference file" );
	    continue;
	}

	/* move to appropriate directory */

	__DBGpr_str( "Changing directory to ", fullPath );
	status = di$cd( dirname	= fullPath );
	as$status();

	/* get number of layouts present */

	nbLayouts = 0;
	status = di$start_dump(	regexp	= "*",
				options	= 0,
				ptr	= &nbLayouts );
	as$status();

	__DBGpr_int( "Number of layouts ", nbLayouts );

	if( !nbLayouts )
	{
	    UI_status( "No layouts found in reference file" );
	    continue;
	}

	/* clear status field */
	UI_status( "" );

	break;
    }

    /* create layout directory if not present */

    sprintf( curLoDir, "%s%s", pathName, loType );
    __DBGpr_str( "Current layout directory", curLoDir );

    status = di$translate(	objname	= curLoDir,
				p_objid	= &obj.objid,
				p_osnum	= &obj.osnum );
    if( status != DIR_S_SUCCESS )
    {
	/* create directory */

	__DBGpr_str( "Creating directory", curLoDir );

	status = di$mkdir(	dirname	= curLoDir,
				p_dirid	= &dirObj.objid,
				p_osnum	= &dirObj.osnum );
	as$status();
    }


    __DBGpr_int( "Number of layouts", nbLayouts );

    for( i = 0 ; i < nbLayouts ; i = i+1 )
    {
	__DBGpr_int( "Loop index", i );

	status = di$fetch_dump(	line	= loName,
				index	= i );
	as$status();

	__DBGpr_str( "Layout name", loName );

	status = di$split(	pathname	= loName,
				name		= tmpName );
	as$status();
	__DBGpr_str( "Split layout name", tmpName );

	/* if layout already exists in current os, do not copy */

	sprintf( curLoName, "%s%s:%s", pathName, loType, tmpName );
	__DBGpr_str( "Current layout name to search", curLoName );

	status = di$translate(	objname	= curLoName,
				p_objid	= &obj.objid,
				p_osnum	= &obj.osnum );

	if( status == DIR_S_SUCCESS )
	{
	    /* layout is present in design file */

	    sprintf( info, "\"%s\" not copied: exists in design file", tmpName );
	    printf( "\t%s\n", info );
	    UI_status( info );
	    continue;
	}

	obj.objid = NULL_OBJID;
	status = di$translate(	objname	= loName,
				p_objid	= &obj.objid,
				p_osnum	= &obj.osnum );
	as$status();

	__DBGpr_obj( "Table layout id to be copied", obj );

	if( obj.objid == NULL_OBJID )
	    continue;

	objEnv = modEnv;
	objEnv.md_id.osnum = obj.osnum;

	cpyEnv = modEnv;
	cpyObj.osnum = curOs;

	status = 
	ci$send(msg	= message GRgraphics.GRcopy( &msg, &objEnv, &cpyEnv,
							&cpyObj.objid ),
		mode	= WRT_message,
		targetid= obj.objid,
		targetos= obj.osnum );
	as$status();

	__DBGpr_obj( "Copied object id", cpyObj );

	printf( "\"%s\" copied\n", tmpName );
					
	if( cpyObj.objid == NULL_OBJID )
	{
	    printf( "Could not copy layout %s\n", tmpName );
	    continue;
	}

	/* name the object */

	status = 
	ci$send(msg	= message GRgraphics.GRputname( &msg, curLoName ),
		targetid= cpyObj.objid,
		targetos= cpyObj.osnum );
	as$status();
    }

    goto REPEAT;

wrapup :

    /* restore original directory */

    status = di$cd( dirname	= curDir );
    as$status();
}
