/* $Id: COz_fixrtree.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/vdppl / COz_fixrtree.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_fixrtree.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

#define DEBUG
#undef DEBUG

#define NC_CIFILE

#include "OMminimum.h"
#include "OMerrordef.h"
#include "OMindex.h"
#include "OMmacros.h"

#include "igrtypedef.h"
#include "igetypedef.h"
#include "gr.h"

#include "ciminimum.h"
#include "cimacros.h"

#include "emsdef.h"
#include "AS_status.h"

/*include "bstypes.h"
include "NCerr.h"
include "NCdebug.h"
include "NCmemory.h"
include "_cmdname.h"
*/
extern printf();
extern ShowObj();

/* NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC

NAME
  fixrtree

DESCRIPTION
  fix the rtree

HISTORY

       Author     Date           Description
       ------     ----           -----------
        pam     ??/??/90        initial spec & wroteit
        pam     04/18/90        add check for duplicates 90w0181
        pam     05/01/90        if duplicate; remove all and addwrng ITR ????
        elp     04/10/92        use emsdef.h instead of ncemsdef.h
        pam     11/12/92        DEBUG => PRINTD; REALLY_DEBUG => DEBUG
	bruno	07/27/93	Add ACrg_collect in "un-valid classes"
NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC NC*/

char scrstr[81];
int ii, jj;
struct GRmd_env md_env;

int array_size;
OM_S_KEY_DESC rtree_key_test;
DB_3D_DBL_BOX rtrange_test;
OM_S_KEY_DESC rtree_key_ret;
DB_3D_DBL_BOX rtrange_ret;

OM_S_CHANSELECT primary;

OM_S_OBJARRAY *obj_array;
OM_S_OBJID *arr;
int is_dup, is_good, all_good;
OMuword /* gag */ graph_cid, coll_cid, my_cid;

extern free();
extern char *malloc();
extern void sprintf();
extern int qsort();

extern void EMmake_chanselect();
/*
int NCprocmsg();
int NCshow_error();
int NCdebugprintf();
*/

extern int VD_ic();

main()
  {
IGRint 	ret0,ret2;
IGRlong	ret1;

  ret0 = OM_S_SUCCESS;

  obj_array = 0;
  all_good = 1;

  message ("Clean Range Tree");

  ci$get_module_info( md_env = &md_env );

  ret0 = om$get_classid( classname = "GRgraphics", p_classid = &graph_cid );
  as$status( sts = ret0 );
  ret0 = om$get_classid( classname = "ACrg_collect", p_classid = &coll_cid );
  as$status( sts = ret0 );

  EMmake_chanselect( module_primary, &primary );

  array_size = sizeof( OM_S_OBJARRAY );

  obj_array = (OM_S_OBJARRAY *) malloc( array_size );
  if( obj_array == 0 ) 
    {
    ret0 = OM_E_NODYNMEM;
	goto ret_error_exit;
    }
  /* obj_array == 0 */

  obj_array->size = array_size;
  obj_array->count = 0;
  obj_array->tree_type = KEY_3D_DBL;

  rtrange_test.xmin = -MAXDOUBLE;
  rtrange_test.ymin = -MAXDOUBLE;
  rtrange_test.zmin = -MAXDOUBLE;

  rtrange_test.xmax = MAXDOUBLE;
  rtrange_test.ymax = MAXDOUBLE;
  rtrange_test.zmax = MAXDOUBLE;

  rtree_key_test.type = KEY_3D_DBL;
  rtree_key_test.key.p_3ddbl = &rtrange_test;

  ret0 = ci$send( msg = message OMindex.translate( obj_array,
                                  &rtree_key_test, NULL, NULL, &ret1),
                  targetos = md_env.md_id.osnum,
                  targetid = md_env.md_id.objid,
                  p_chanselect = &primary );
  as$status( sts = ret0 );

  array_size = (sizeof(OM_S_OBJID) * obj_array->count) + sizeof(OM_S_OBJARRAY);
  free( obj_array );

  obj_array = (OM_S_OBJARRAY *) malloc(array_size);
  if( obj_array == 0 ) 
    {
	ret0 = OM_E_NODYNMEM;
	goto ret_error_exit;
    }
  /* obj_array == 0 */

  obj_array->size = array_size;
  obj_array->count = 0;
  obj_array->tree_type = KEY_3D_DBL;

  rtrange_test.xmin = -MAXDOUBLE;
  rtrange_test.ymin = -MAXDOUBLE;
  rtrange_test.zmin = -MAXDOUBLE;

  rtrange_test.xmax = MAXDOUBLE;
  rtrange_test.ymax = MAXDOUBLE;
  rtrange_test.zmax = MAXDOUBLE;

  rtree_key_test.type = KEY_3D_DBL;
  rtree_key_test.key.p_3ddbl = &rtrange_test;

  ret0 = ci$send( msg = message OMindex.translate( obj_array,
                                  &rtree_key_test, NULL, NULL, &ret1),
                  targetos = md_env.md_id.osnum,
                  targetid = md_env.md_id.objid,
                  p_chanselect = &primary );
  as$status( sts = ret0 );

  rtree_key_ret.type = KEY_3D_DBL;
  rtree_key_ret.key.p_3ddbl = &rtrange_ret;

  arr = obj_array->array;

  /* sort for later duplicate check */
  qsort( arr, obj_array->count, sizeof( OM_S_OBJID ), VD_ic );

  printf (" %d Objects \n", obj_array->count);

  for( ii = 0; ii < obj_array->count; ii = ii + 1 )
    {
    is_dup = 0;

    ret0 = om$is_objid_valid( osnum = md_env.md_id.osnum, objid = arr[ii] );
    if( !(ret0&1) )
    {
      is_good = 0;
    }
    else
      {
      ret0 = om$get_classid( osnum = md_env.md_id.osnum, objid = arr[ii],
                             p_classid = &my_cid );
      as$status( sts = ret0 );

      ret0 = om$is_ancestry_valid( superclassid = graph_cid,
                                   subclassid = my_cid );
      ret2 = om$is_ancestry_valid( superclassid = coll_cid,
                                   subclassid = my_cid );
      if( (ret0 == 1) && ret2!=1 )
        {
        /* duplicate check */
        is_good = 1;
        if( ii+1 )
          if( obj_array->count && arr[ii+1] == arr[ii] )
            is_good = 0;
        if( is_good )
          if( ii > 0 )
            if( arr[ii-1] == arr[ii] )
              {
              /* last of the duplicate entries */
              is_good = 0;
              is_dup = 1;
              }
        }
      /* OM_S_SUCCESS */
      else
        is_good = 0;
      ret0 = OM_S_SUCCESS;
      }
    /* else is_objid_valid */
    if( !is_good )
      {
      if( all_good )
        {
        status ( "rtree corrupted, fixing ... " );
        all_good = 0;
        }
      ret0 = ci$send( msg = message GRrtree.find_key( 0, &arr[ii], 
                              &rtree_key_ret, NULL, &ret1 ),
                      targetos = md_env.md_id.osnum,
                      targetid = md_env.md_id.objid,
                      p_chanselect = &primary );
      if( ! ( ret0 & 1 ) || ret1 )
        {
        printf( "error in GRrtree.find_key (%d,%d) = %d,%d\n", 
                       md_env.md_id.osnum, arr[ii], ret0, ret1 );
        continue;
        }
      ret0 = ci$send( msg = message OMindex.remove( &rtree_key_ret,
                                                    &arr[ii], NULL, &ret1),
                      targetos = md_env.md_id.osnum,
                      targetid = md_env.md_id.objid,
                      p_chanselect = &primary );
      if( ! ( ret0 & 1 ) || ret1 )
        printf( "error in OMindex.remove (%d,%d) = %d,%d\n", 
                       md_env.md_id.osnum, arr[ii], ret0, ret1 );
      ret0 = 1;
      ret1 = 0;
      if( is_dup )
        {
        ret0 = ci$send( msg = message GRgraphics.GRaddwrng( &ret1, &md_env ),
                              targetos = md_env.md_id.osnum, 
                              targetid = arr[ii] );
        if( ! ( ret0 & 1 ) || !( ret1 & 1 ))
          printf( "error in GRgraphics.GRaddwrng (%d,%d) = %d,%d\n", 
                         md_env.md_id.osnum, arr[ii], ret0, ret1 );
        ret0 = 1;
        ret1 = 0;
        }
      /* is_dup */
      }
    /* is_good */
    
    ret0 = 1;
    }
  /* for ii loop */

  ret0 = 1;

ret_error_exit:
  if( ! (ret0&1) )
    {
    printf( "verrtree ERROR return %d\n", ret0 );
    }

  }
/* main */

delete()
  {
  free( obj_array );
  }

