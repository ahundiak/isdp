/* $Id: COz_DelTag.u,v 1.1 2001/01/18 20:38:19 hans Exp $ */
/***************************************************************************
 * I/VDS
 *
 * File:        vdppl/COz_DelTag.u
 *
 * Description: Delete all the OMTagCon objects in active space, which
 * doesn't have a valid connections with the reference files.
 *
 * Retaining such objects results in huge file size, and also it tries to 
 * resolve them when the file comes up. Failuer to resolve connection ends up
 * in error.
 *
 * WHAT HAS BEEN DONE ? ( IN THIS PPL )
 *
 *	1. Get all the OMTagCon objects present in the file.
 *	2. For each OMTagCon objects get the OMTagCon connection records
 *	3. From the Connections Records, check each and every connection
 *	   objects listed, whether they're "ACprentendin or ASsourcein" objects.
 *	   B'cas these are objects which are used to establish connections
 *	   with the reference files.
 *	4. When all the objects are checked and found to be invalid, then
 *	   we can delete the OMTagCon object. 
 *	
 *	For Future : An attempt has been done to remove the invalid record
 *	from the OMTagCon object, with in vain. If we can do that, it can
 *	result in lot lesser file size. B'cas these objects are quite huge...
 *	hog the memory.
 *
 * Dependencies:
 *
 * Revision History:
 * $Log: COz_DelTag.u,v $
 * Revision 1.1  2001/01/18 20:38:19  hans
 * SP16 additions/modifications
 *
# Revision 1.1  2000/11/22  23:56:40  pinnacle
# Created: vds/vdppl/COz_DelTag.u by apazhani for Service Pack
#
 *
 *
 * History:
 * MM/DD/YY  	AUTHOR  DESCRIPTION
 * 10/26/2000   Alwin 	Created
 ***************************************************************************/

#include "OMminimum.h"
#include "OMtags.h"
#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "VDvla.h"
#include "OMintprims.h"
//#include "OMDB.h"
#include "OMspecify.h"
#include "VDmem_ppl.h"
#include "v_dbgmacros.h"

extern calloc();
extern EX_findmod();
extern VDtagDumpTagCon();

extern VDclassid OPP_OMTagCon_class_id;
extern OM_GA_p_tagcon;
extern OM_Gw_maxOS;
extern OM_Gp_CurSpaceMap;
#define   OM_TCf_unresolved_connection   2

/*
 * Defined in the OMTagConi.I file, use this for turning off the debug print
 * statement when calling the debug method to retrieve the instance date of the
 * OMTagCon object. Alwin
 */
extern int nDEBUG_ON; 

struct OM_sd_connect_record
{
   OM_S_OBJID     objid;       /* Object id of object in this OS.  */
   OMuint         tag;         /* Tag of object in other OS. */

   OM_S_CHANNUM   cnum;        /* Channel connected to in this OS. */
   OM_S_CHANNUM   other_cnum;  /* Channel connected to in the other OS. */

   OMuword        index;       /* Optional index on channel in this OS. */
   OMuword        other_index; /* Optional index on channel in the other OS. */

   OMuword        version;     /* Used to identify when the initial connection
                                  was made. */

   OMuword        flags;       /* Version mismatch or unresolved connection. */
   OMuword        next;        /* Index of next record or NULL. */
   OMuword        prev;        /* Index of previous record or NULL. */
};

extern EXGetTagConRecordInstance();
extern GRclassid	OPP_GRcontext_class_id;
extern GRclassid	OPP_ACpretendin_class_id;
extern GRclassid	OPP_ASsourcein_class_id;

/* This is function is same as VDobjInActiveSpace implemented in
$VDS/vdio/VDfunc.I file. Here I'm modifying this function slightly to provide
an extra feature to specify one more classes */

long VCobjInActiveSpace(msg, count, list, class, NbClasses)
long *msg;
int *count;
struct GRid **list;
OMuword *class;
IGRint NbClasses;
{
        OMuword         objClassid,     /* Class of `curObj'            */
                        actOs ;         /* OS number of active file     */
        struct GRid     curObj;
        int             i, j,           /* Loop index                   */
                        cnt,            /* Count of children            */
                        maxObjs ;       /* Max. of objs in Object Space */
                                        /* or in given list of parts.   */
        long            sts;

        cnt = 0;

        ex$get_cur_mod( osnum = &actOs ) ;
        maxObjs = OM_GA_OSDs[actOs]->CurSpaceMapSize ;
        curObj.osnum = actOs ;

        *list = _MALLOC ( maxObjs, struct GRid );

        for( i = 0 ; i < maxObjs ; i = i +1 )
        {
                curObj.objid = i ;
                sts = om$get_classid(   objid           = curObj.objid,
                                        osnum           = curObj.osnum,
                                        p_classid       = &objClassid ) ;
                if( !( sts & 1 ) ) {
                        /*
                         * Not an object id.
                         */
                        continue ;
                }

                for( j=0; j<NbClasses; j = j +1 )
                {
                    sts = om$is_ancestry_valid(
                                    superclassid        = class[j],
                                    subclassid          = objClassid ) ;
                    if( sts != OM_S_SUCCESS ) {
                            continue ;
                    } else {
                            (*list)[cnt] = curObj;
                            cnt = cnt + 1;
                    }
                }
        }

        if( cnt) *count = cnt;

        return( sts & *msg & 1 );
}

int VDTryDeletingIt( TagConId )
struct GRid TagConId;
{
  IGRint	*nTagCount, *nFirstTag, *nFirstFree;
  IGRint	i;
  IGRlong	sts;
  IGRboolean	bDelete_OMTagCon;
  GRclassid 	ClassId;
  struct OM_sd_connect_record *pConnRecord;

    /*
     * Fetch the instance data of the OMTagCon object.
     * When all the connected objects are not ACpretendin or ASsourcein
     * objects then delete the OMTagCon object.
     */

    nDEBUG_ON = 0;
    sts = ci$send( msg = message OMTagCon.debug(),
		    targetid = TagConId.objid );
    nDEBUG_ON = 1;

    pConnRecord  = NULL;

    // defined and implemented in the OMTagConi.I, to fetch the
    // instance data of the OMTagCon object
    sts = EXGetTagConRecordInstance( &nTagCount, &nFirstTag, 
				  &nFirstFree, &pConnRecord );

    __DBGpr_int( "No. Tag Connections ", *nTagCount );
    __DBGpr_int( "First Tag ", *nFirstTag );
    __DBGpr_int( "First Free Tag ", *nFirstFree );

    i = *nFirstTag;
    bDelete_OMTagCon = TRUE;
    while( (i != OM_K_TAGEND) && ( bDelete_OMTagCon == TRUE ) )
    {
	// get the ClassId of the connected object
	ClassId = OM_K_NOTUSING_CLASSID;

	__DBGpr_int( " Connection Objid ", pConnRecord[i].objid );

	sts = om$get_classid( objid = pConnRecord[i].objid,
			      p_classid = &ClassId );

	if( ( ClassId == OPP_ACpretendin_class_id ) ||
	    ( ClassId == OPP_ASsourcein_class_id ) )
	{
	   bDelete_OMTagCon = FALSE;
	   //printf("\n\t  Not Deleted " );
	}
	i = pConnRecord[i].next;
    }

    if( bDelete_OMTagCon )
    {
      __DBGpr_int( "Delete the OMTagCon object ", TagConId.objid );

      sts = ci$send( msg = message OMTagCon.delete( 0 ),
		      targetid = TagConId.objid );

      return 1;
    }
    else
       __DBGpr_com( "OMTagCon Object not deleted \n" );

    return 0;
}

main()
{
  TGRid fileID;
  TGRid grpID;
  TVDvlaID *vlaID;
  IGRint  i, os, nTagConnections;
  IGRlong sts;
  IGRint	fixed_size, totalSize;
  OMuint	tag_count;
  OM_S_OBJID	tag_oid;
  OMuword	tag_flags, tag_osnum;
  OMuword	savedOS;
  OM_p_TAGCON_LINK   	p_tc_link;
  OM_p_TAG_RECORD    	p_tag_rec;
  struct OM_sd_RIP	Instance;
  OM_p_VARLENARR_DEFN  vad;        /* VLA definitions */
  OM_p_VARLENARR_DESCR p;          /* pointer to VLA descriptor */

  IGRint	*nTagCount, *nFirstTag, *nFirstFree;
  struct OM_sd_connect_record *pConnRecord;
  int		 nTagConObjCount;
  GRclassid     Classes[2];
  struct GRid   *TagObjList;
  GRclassid 	ClassId;
  IGRboolean	bDelete_OMTagCon;
  struct GRid	OMTagConId;
  int 		slot, ndx;

   UI_status( " Cleaning OMTagCon objects..." ); 
   printf("\n\t  OMTagCon Cleaning : Begin >> n");

   tag_osnum = 2;
   savedOS = OM_Gw_current_OS; //save the current OS
   om$make_current_os( osnum = tag_osnum );

   Classes[0] = OPP_OMTagCon_class_id;

   nTagConObjCount = 0;
   // Get the list of OMTagCon objects in the file
   sts = VCobjInActiveSpace( &msg, &nTagConObjCount, &TagObjList, Classes, 1 );  
    printf("\n\t  No. of OMTagCon object in the file :%d \n", nTagConObjCount );
    UI_status( "Processing ... " );
    ndx = 0; //initialize
    for (os=0; os < nTagConObjCount; os=os+1)
    {
	OMTagConId = TagObjList[os];

	printf("\n\t  Processing 'OMTagCon' Object Id : <%d, %d> ",
				      OMTagConId.objid, OMTagConId.osnum  );

   	UI_status( " Cleaning OMTagCon objects......" ); 
	sts = VDTryDeletingIt( OMTagConId );
	if( sts & 1 )
	{
	   ndx = ndx + 1;
	   printf("\n\t  Deleted OMTagCon Object : <%d,%d>\n", 	
				OMTagConId.objid, OMTagConId.osnum );
	}
   	UI_status( " Cleaning OMTagCon objects......" ); 
	continue;

#if 0
RepeatProcess:
        nDEBUG_ON = 0;
	sts = ci$send( msg = message OMTagCon.debug(),
			targetid = OMTagConId.objid );
        nDEBUG_ON = 1;

	pConnRecord  = NULL;

	// defined and implemented in the OMTagConi.I, to fetch the
	// instance data of the OMTagCon object
	sts = EXGetTagConRecordInstance( &nTagCount, &nFirstTag, 
				      &nFirstFree, &pConnRecord );

	printf("\n\t  No. Tag Connections  : %d", *nTagCount );
	printf("\n\t  First Tag : %d", *nFirstTag );
	printf("\n\t  First Free Tag : %d", *nFirstFree );

	  if( (*nFirstTag) == OM_K_TAGEND ) continue; //reached end of tag

	  bDelete_OMTagCon = TRUE;
	  //for( i=0; ( i<(*nTagCount) && bDelete_OMTagCon ); i=i+1 )
	  i = *nFirstTag;
	  printf("\n\t  Value of OM_K_TAGEND : %d", OM_K_TAGEND );
	  while( i != OM_K_TAGEND )
	  {
	      /*
	       * Get the Object Classid and check whether its ACprentendin 
	       * object or not. If all the objects listed in the OMTagCon 
	       * record are not ACprentendin objects, then we can delete 
	       * the OMTagCon object itself. Even if one of the object is 
	       * of ACprentendin classid then we should not delete the 
	       * OMTagCon object, because the user might re-connect the 
	       * Reference File, then this object would be used for 
	       * establishing t he connnection back.
	       */
	      UI_status( "Processing ....... " );
	      printf("\n\t Processing ....... %d ", i );
	      printf("\n\t  Next I value : %d ", pConnRecord[i].next );

	      // get the ClassId of the connected object
	      ClassId = OM_K_NOTUSING_CLASSID;
	      printf("\n\t Connection Objid : %d \n", pConnRecord[i].objid );
	      sts = om$get_classid( objid = pConnRecord[i].objid,
				    p_classid = &ClassId );

	      if( ( ClassId == OPP_ACpretendin_class_id ) ||
		  ( ClassId == OPP_ASsourcein_class_id ) ) //||
		  //( ClassId == OPP_GRcontext_class_id ) ) 
	      {
		 bDelete_OMTagCon = TRUE;
		 printf("\n\t  Not Deleted " );
	      }
	      else
	      {
		 printf("\n\tDeleting one record from the OMTagCon Object\n");
		 bDelete_OMTagCon = FALSE;

		 /*** 
		 Since calling this method ...in addition to remove the
		 record also "Decreases the OMCO count by one. This might lead
		 to un-desirable results like, existing object Class Id could
		 be deleted for no reason. 
		 B'cas some of the "Objid" listed in the instance data 
		 won't be same object as it was before, this could be object
		 totally of different ClassId, just using the objid.

		 sts = ci$send( msg = message OMTagCon.remove( *nFirstTag ),
				  targetid = p_tc_link->objid );
		 ...So lets bring in the logic used in the OMTagCon.remove
		 method right here...
		 ***/

		 /*==============================================*/
		 /*  if record is at head of list update header  */
		 /*==============================================*/
		 if( i == 0 ) slot = (*nFirstTag);
		 else slot = pConnRecord[i].next;

		 if( slot == (*nFirstTag) )
		 {
		     *nFirstTag = pConnRecord[i].next;
		 }
		 else
		 {
		    printf("\n\t  Next index : %d ", pConnRecord[i].next );
		    printf("\n\t  Prev index : %d ", pConnRecord[i].prev );
		    pConnRecord[pConnRecord[i].next].prev=pConnRecord[i].prev;
		 }

		 /*==============================================*/
		 /* if record is at tail of list no need to update previous */
		 /*==============================================*/
		 if( pConnRecord[i].next != OM_K_TAGEND )
		 {
		     pConnRecord[pConnRecord[i].next].prev = pConnRecord[i].prev;
		 }

		 /*==============================================*/
		 /* update free list				   */
		 /*==============================================*/
		 pConnRecord[i].next = *nFirstFree;
		 *nFirstFree = i;
		 *nTagCount = (*nTagCount) - 1; //decrease the TagCount by 1
	      }

	      printf("\n\t  Tag Count value : %d", *nTagCount );
	      exit;
	      // Delete the OMTagCon object, as there is no valid connections
	      // with the reference files any more
	      if( ! bDelete_OMTagCon && (*nTagCount > 1)  ) goto RepeatProcess;
	      i = pConnRecord[i].next;
	      if( (*nTagCount) == 0 )
	      {
		i = OM_K_TAGEND;
  printf("\n\t  Deleted the OMTagCon object : %d \n", OMTagConId.objid );
		printf("\n\t  Deleting the OMTagCon object \n" );
		sts = ci$send( msg = message OMTagCon.delete(0),
				      targetid = OMTagConId.objid );
		
  om$make_current_os( osnum = savedOS ); //set the savedOD back
		exit;
	      }
	      printf("\n\t  Next 'i' value : %d ", i );
	  }
#endif
    }

    if( ndx > 0 )
      printf("\n\t  Delete <%d> invalid OMTagCon objects \n", ndx );

    om$make_current_os( osnum = savedOS ); //set the savedOD back

wrapup:
   printf("\n\t  OMTagCon Cleaning : End << \n");
}
