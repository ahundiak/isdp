/* $Id: COz_ctx.u,v 1.2 2001/01/18 22:15:41 hans Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	Coz_ctx.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_ctx.u,v $
 *	Revision 1.2  2001/01/18 22:15:41  hans
 *	SP16 modifications
 *	
 *	Revision 1.1  2001/01/18 20:38:47  hans
 *	SP16 additions/modifications
 *	
# Revision 1.1  2000/04/27  14:24:16  pinnacle
# Created: vds/vdppl/COz_ctx.u by azuurhou for Service Pack
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
 * PPL COz_ctx.u
 *
 * This PPL provides a very fast function to find ALL objects of a particular CLASSID
 * in the specified object space (no locate required !!!).
 *
 * Usage: "ci=COz_ctx"
 *
 * Following is an example of how to find & list ALL OPP_GRcontext_class_id's in OS 2
 */

#include <stdio.h>
#include <cieveryone.h>
#include <cimacros.h>
#include "OMindex.h"
#include <grmacros.h>
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "madef.h"

extern			VDpms_find_objects();
extern			GRdelete_object();
extern			DIuntranslate();
extern double           BSdetmat();

extern GRclassid	OPP_expression_class_id;
extern GRclassid	OPP_GRcontext_class_id;

main()
{
  char                  name[1024];
  int		        i0, j0, k0, m0, cnt, sts, chcnt[5], chtot[5], f_defer_flag;
  long     		msg;

  struct GRid	        obj_id, conID;
  struct GRmd_env       ModuleInfo;

  OM_S_OBJID	       *list;
  GRclassid	        class_id;
  OM_S_CHANSELECT       my_chansel[5];
  OM_S_OBJECT_LINKAGE	objet;

  my_chansel[0].type       = OM_e_name;
  my_chansel[1].type       = OM_e_name;
  my_chansel[2].type       = OM_e_name;
  my_chansel[3].type       = OM_e_name;
  my_chansel[4].type       = OM_e_name;
  my_chansel[0].u_sel.name = "children";
  my_chansel[1].u_sel.name = "father";
  my_chansel[2].u_sel.name = "notification";
  my_chansel[3].u_sel.name = "to_owners";
  my_chansel[4].u_sel.name = "to_components";

  my_chansel[0].u_sel.name = "to_super";
  my_chansel[1].u_sel.name = "to_reffile";
  my_chansel[2].u_sel.name = "to_misc";
  my_chansel[3].u_sel.name = "to_nested_files";

  class_id = OPP_expression_class_id;
  class_id = OPP_GRcontext_class_id;

  printf  ("++++++++++++++++++++++++++++++++++++++\n");
  printf  ( "Delete all obsolete GRcontext objects\n" );
  message ( "Delete all obsolete GRcontext objects" );
  fflush  ( 0 );

  list = NULL;
  sts = VDpms_find_objects ( (OMuword)2, (OMuword)class_id, &cnt, list );

  printf ( "\nVDpms_find_objects() : sts = %d, Number of objects = %d\n", sts, cnt );
  fflush ( 0 );

  if ( cnt > 0 )
  {
    list = ( OM_S_OBJID * ) om$malloc ( size = cnt * sizeof ( OM_S_OBJID ) );
  }
  else
  {
    return;
  }

  ci$get_module_info ( md_env = &ModuleInfo );

  if ( list )
  {
    sts = VDpms_find_objects ( (OMuword)2, (OMuword)class_id, &cnt, list );

    m0 = 0;
    obj_id.osnum  = 2;
    objet.osnum   = 2;
    chtot[0] = chtot[1] = chtot[2] = chtot[3] = 0;

    for ( i0=0; i0 < cnt; i0=i0+1)
    {
      objet.S_objid = list[i0];
      obj_id.objid  = list[i0];
      conID.objid   = list[i0];
      conID.osnum   = 2;

      {
        for ( k0=0; k0 < 4; k0=k0+1)
        {
          sts = om$get_channel_count ( osnum		= objet.osnum,
                                       objid		= objet.S_objid,
                                       p_chanselect	= &my_chansel[k0],
                                       count		= &chcnt[k0] );
          chtot[k0] = chtot[k0] + chcnt[k0];

        }

        printContext(&conID);

        printf ( "    ctxID[%d] %d, to_super %d, to_reffile %d, to_misc %d, to_nested_files %d\n",
                   i0, list[i0], chcnt[0], chcnt[1], chcnt[2], chcnt[3] );
      }
    }
    printf ( "\nNumber of GRcontext's = %d, # of deleted(obsolete) GRcontext's = %d\n", cnt, m0 );

//    printf ( "\nchtot[0] = %d, chtot[1] = %d, chtot[2] = %d, chtot[3] = %d\n", chtot[0], chtot[1], chtot[2], chtot[3] );
    printf  ("--------------------------------------\n");

    if (list)
    {
      om$dealloc ( ptr = list );
      list = NULL;
    }
  }
}

printContext(conID)
  struct GRid *conID;
{
  IGRint sts,msg;

  struct GRmd_env env;

  IGRint i,j, col, rc;
  IGRdouble det;

  IGRshort flag;
  struct GRid    conxID;

  sts = ci$send(msg = message GRcontext.GRgetmodule_env(&msg,&env),
		targetid = conID->objid,
		targetos = conID->osnum);
  if (!(sts & msg & 1))
  {
    printf("Problem getting enviroment.\n");
    goto wrapup;
  }
  sts = ci$send(msg = message GRcontext.
		GRgetinstance(&msg,
			      &env.md_env.matrix_type,
 			       env.md_env.matrix,
			      &env.md_id.osnum,
			      &flag,
			      &conxID),
		targetid = conID->objid,
		targetos = conID->osnum);

  if ( 1 && env.md_env.matrix_type == MAIDMX) goto wrapup;

  col = 4;
  det = 0.0;
  det = BSdetmat( col, env.md_env.matrix, &rc );
  if ( rc )
  {
    printf("BSdetmat error = %d\n", rc);
  }

  printf("------------------------------------\n");

  printf("GRcontext = [%d,%d], Matrix osnum %d, type %d, determinant = %lg\n",
         conID->osnum, conID->objid, env.md_id.osnum,env.md_env.matrix_type, det);
  for(i = 0; i < 4; i = i + 1)
  {
    for(j = 0; j < 4; j = j + 1)
    {
      printf("%22.19f ",env.md_env.matrix[(i*4)+j]);
    }
    printf("\n");
  }

wrapup:
  return 1;
}
