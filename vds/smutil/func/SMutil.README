30 Oct 1997 Art Hundiak
Got rid of warnings releated to uninitialized varialbes
and unused arguments

Description of the added functions:
===================================





SMGetCompFromDrw ====================================================

int SMGetCompFromDrw(
	struct GRid	*obj,		/* (I) input drawing      */
	struct GRid	*compart,	/* (O) returned compart   */
	struct GRmd_env *cmp_env	/* (O) env of the compart */
)

The function retrieve the compartment object that is
connected to the given drawing object.
 
return 1 if ok 
else 0.	

SMGetGraphDrw ==========================================================

int SMGetGraphDrw(
	struct GRid	*obj,		/* (I) input drawing 		*/
	int		*nb_graphic,	/* (O) nb of graphic foot	*/
	struct GRid	**graphics	/* (O) graphic foot 		*/
)

The function returns the list of all the graphic objects
defining the drawing that are composite curve or plane 
(feet of VDgeom) 
 
graphics is allocated by the function and must be deallocated
by the user.

return 1 if ok 
else 0.


SMGetListObj =======================================================

int	SMGetListObj(
	long		*msg,		/* (O) completion code 	*/
	struct GRid	*obj,		/* (O) list of object 	*/
	struct GRfunction_info	*f_info /* (O) info 		*/
)


The function adds the GRid of the object in the list if
the object is a VDdrawing of a compart.
 
info.cc is allocated by the function and must be deallocated 
by the user

return 1 if ok 
else 0.	


SMGetAllDrw ===============================================================

int SMGetAllDrw(
	int		*nb_obj, /* (O) nb object VDdrawing in design */
	struct GRid	**obj    /* (O) the VDdrawing objects         */
)

the function retrieve all the VDdrawing objects in the 
design file that are the drawing of a compartment.


obj is allocated by the function and must be deallocated
by the user.

return 1 if ok 
else 0.	


SMIsInCompt2D ===============================================================

int SMIsInCompt2D(obj, obj_env, no_pseudo, no_hull, cmp_id, cmp_name, nb_list,
			 totlist)
struct GRid	  *obj;  	/* [I] : object to test                    */
struct GRmd_env	  *obj_env;  	/* [I] : object env                        */
int		  no_pseudo;    /* [I] : 1 if pseudo not wanted            */
int		  no_hull;      /* [I] : 1 if hull not wanted              */
struct GRid       *cmp_id; 	/* [O] compartment in which is the object  */
IGRchar		  *cmp_name;	/* [O] compart name                        */
IGRint		  *nb_list;	/* [O] nb compart in the list              */
struct GRid       **totlist; 	/* [O] compartment list containing the obj */

Function that returns in which compartment drawing the element is
in (cog in the compart drawing range)

If Compart is pseudo, or hull_compart don't take it if no_pseudo=1
or no_hull = 1.


return 1 if ok 
else 0.	
	

SMIsInCompt ===============================================================

int SMIsInCompt(obj, obj_env,no_pseudo, no_hull, cmp_id, cmp_name, nb_list, 
		totlist)
struct GRid	  *obj;  	/* [I] : object to test                    */
struct GRmd_env	  *obj_env;  	/* [I] : object env                        */
int		  no_pseudo;    /* [I] : 1 if pseudo not wanted            */
int		  no_hull;      /* [I] : 1 if hull not wanted              */
struct GRid       *cmp_id; 	/* [O] compartment in which is the object  */
IGRchar		  *cmp_name;	/* [O] compart name                        */
IGRint		  *nb_list;	/* [O] nb compart in the list              */
struct GRid       **totlist; 	/* [O] compartment list containing the obj */


Function that returns in which compart the element is
(cog of the object in the compart range)

If Compart is pseudo, or hull_compart don't take it if
no_pseudo = 1 or no_hull = 1.

The return compart will be the smallest one (smallest volume) containing
the element.

The list of all compartments containing the object can also be
returned (cmp is allocated by the function and must be free by
the caller).

If We have a compart that is a disjoint union of 2 solid,
we can verify by getting these solids if the element is in one of
them or not (that case is not treated here, can be done later)

return 1 if ok 
else 0.	


VDGetCsFromEq ===================================================

int VDGetCsFromEq(equip, ref, info)
struct GRid		*equip;	/* [I] the equipment object 	*/
struct GRid		*ref;	/* [O] the output cs if found 	*/
int			*info;	/* [O] info on the cs 		*/


This function return the coordinate system attached to an 
equipment.

 info = 0 if there is only one graphic root that is the cs
 info = 1 if there is more than one graphics roots
 info = 2 if there is no cs
 
return 0 if no ref found


SMPtInsideCv ===============================================================

int SMPtInsideCv(
	IGRpoint		pt,	/* (I) input point                  */
	struct IGRbsp_curve	*curve, /* (I) geom of the curve            */
	struct GRid		*cv_id, /* (I) curve object (NULL if curve) */
	struct GRmd_env 	*ModEnv,/* (I) current env  (NULL if curve) */
	IGRint			*ind	/* (O) position of the point        */
)


This function determine if the given point is inside the closed
planar curve or not .

algorithm: transform the curve into the plan xy and call BSpt_in_cv.
 
ind = 0 ---> outside
ind = 1 ---> inside
ind = 2 ---> on
	
return 1 if ok 
else 0.	



SMPtInsideSf ================================================================

int SMPtInsideSf(
	IGRpoint		pt,	/* (I) input point                   */
	struct IGRbsp_surface	*surf,  /* (I) geom of the surface           */
	struct GRid		*sf_id, /* (I) surface object (NULL if surf) */
	struct GRmd_env 	*ModEnv,/* (I) current env  (NULL if surf)   */
	IGRint			*ind	/* (O) position of the point         */
)
 
This function determine if the given point is on the surface
 
ind = 0 ---> outside
ind = 1 ---> on

return 1 if ok 
else 0.	
	

SMGetAdjCompart ================================================

int SMGetAdjCompart(
struct GRid	  *obj,  	/* [I] : compart to test      */
IGRint		  *nb_list,	/* [O] nb compart in the list */
struct GRid       **totlist	/* [O] adjacent compartments  */
)


SMGetAdjCompart: This function returns the compartments that are 
adjacents to the given one. (it performs the intersection of the 
compart ranges)

totlist is allocated by the function and must be deallocated
by the user.

return 1 if ok 
else 0.	
 


SMGetInAdjCmpt ============================================================

int SMGetInAdjCmpt(obj, obj_env, no_pseudo, no_hull,cmp_id, cmp_name, nb_list, totlist)
struct GRid	  *obj;  	/* [I] : object to test 		   */
struct GRmd_env	  *obj_env;  	/* [I] : object env 			   */
int		  no_pseudo;    /* [I] : 1 if pseudo not wanted 	   */
int		  no_hull;      /* [I] : 1 if hull not wanted 		   */
struct GRid       *cmp_id; 	/* [O] compartment in which is the object  */
IGRchar		  *cmp_name;	/* [O] compart name 			   */
IGRint		  *nb_list;	/* [O] nb compart in the list 		   */
struct GRid       **totlist; 	/* [O] compartment list containing the obj */


Function that returns in which compart the element is
in (cog in the compart range)and all the adjacent compartments
to that one.

If Compart is pseudo, or hull_compart don't take it if
no_pseudo = 1 or no_hull = 1.

totlist is allocated by the function and must be deallocated
by the user.

return 1 if ok 
else 0.	
	


SMGetConxCmpt =============================================================
 
int SMGetConxCmpt(pt, fact, no_pseudo, no_hull,nb_list, totlist)
IGRpoint	  pt;		/* [I] : point to test 			  */
IGRdouble	  *fact;	/* [I] : fact for cht to construct range  */
int		  no_pseudo;    /* [I] : 1 if pseudo not wanted 	  */
int		  no_hull;      /* [I] : 1 if hull not wanted 		  */
IGRint		  *nb_list;	/* [O] nb compart in the list 		  */
struct GRid       **totlist; 	/* [O] compartment list containing the obj*/

 	
Function that returns the comparts that are adjacent to
the given pt. (create a range of fact*cht around the pt and intersect
that range with the compart ranges)

If Compart is pseudo, or hull_compart don't take it if
no_pseudo = 1 or no_hull = 1.

if fact is NULL, fact = 500

totlist is allocated by the function and must be deallocated
by the user.

return 1 if ok 
else 0.	
	

/* ====================== SMGetConxCmpt2D =====================


int SMGetConxCmpt2D(pt, fact, no_pseudo, no_hull,nb_list, totlist)
IGRpoint          pt;           /* [I] : point to test                    */
IGRdouble         *fact;        /* [I] : fact for cht to construct range  */
int               no_pseudo;    /* [I] : 1 if pseudo not wanted           */
int               no_hull;      /* [I] : 1 if hull not wanted             */
IGRint            *nb_list;     /* [O] nb compart in the list             */
struct GRid       **totlist;    /* [O] compartment list containing the obj*/


        Function that returns the comparts drawing that are adjacent to
        the given pt. (create a range of fact*cht around the pt and intersect
        that range with the compart ranges)

        If Compart is pseudo, or hull_compart don't take it if
        no_pseudo = 1 or no_hull = 1.

        if fact is NULL, fact = 500

        totlist is allocated by the function and must be deallocated
        by the user.

        return 1 if ok
        else 0.


