/* $Id: VDdrw2dVwi.I,v 1.1.1.1 2001/01/04 21:08:38 cvs Exp $ */
/*---------------------------------------------------------------------------
/*  I/VDS
 *
 * File:        vddraw/imp/VDdrw2dVwi.I
 *
 * Description:
 *
 *      This file implements the methods for the View Area control object,
 *	which concatenates all 2d visualization objects.
 *
 * Dependencies:
 *      VDdrw2dVw.S
 *
 * History:
 *      06/06/94        adz		Creation date.
 *
 * -------------------------------------------------------------------------
 */

class implementation VDdrw2dVw;

/*
%safe
#include <math.h>
%endsafe
*/

#include <math.h>
#include <values.h>
#include "OMprimitives.h"
#include "OMmacros.h"
#include "OMerrordef.h"
#include <stdio.h>
#include <string.h>
#include "msdef.h"
#include "refdef.h"
#include "madef.h"

#include "acdef.h"
#include "acmacros.h"
#include "asbox.h"
#include "dp.h"
#include "AS_debug.h"
#include "grerr.h"
#include "grgsdef.h"

#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"

#include "bserr.h"
#include "bsparameters.h"
#include "exmacros.h"

#include "grerr.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "asmacros.h"
#include "nddef.h"
#include "ndmacros.h"

#include "ACattrib.h"
#include "ACrg_collect.h"

#include "AS_status.h"

#include "vds.h"
#include "VDSutil_def.h" 
#include "VDmsg.h"
#include "SMmsg.h"
#include "vddrwattr.h"
#include "v_miscmacros.h"
#include "v_dbgmacros.h"
#include "vdsetmacros.h"
#include "vdsmacros.h"

extern	GRclassid	OPP_Gexp_class_id,
			OPP_Gtext_exp_class_id;

from	expression	import	modify;
from	VDmdlview	import	VDmv_give_name_desc;

/*----------------------------------------------------------------------------*/

method VDgetObjDef( long *msg ; VDobjDef *myDef ) {

	long		sts ;	/* OM return code	*/

	/*
	 * name.
	 */
	SetProc( VDdrw2dVw_VDgetObjDef ); Begin

	*msg	= MSSUCC ;

	myDef->info		= VD_I_ObjDrw2dVw ;
	myDef->type		= VD_O_drw2dVw ;

	sts	= OM_S_SUCCESS ;

	End ;
	return sts ;

} /* VDgetObjDef */

/*+mo
 -------------------------------------------------------------------------
  Public Message 
	ACconstruct_feet from NDnode

  Description:
 
	When the object is connected with VDdrw3dVw object, this object
	will keep trace of the location of the Drawing-Note location.
	The information and location of the note are generated by
	attribute information of the private collector of the object.
 
  Dependencies:
 
       VDdrw2dVw

  History:
 
       12/21/94	adz	creation date 
 
  -------------------------------------------------------------------------
 */

method	ACconstruct_feet(	IGRlong		*msg;
				IGRint		cn_type; 
				IGRint		count;
				struct GRid	list[];
				struct GRmd_env *md_env;
				IGRint		*fcount;
				struct GRid	*feet_list )
{
	/*
	 * Root list:
	 *	- Dynamic collection (description, location, comp_flag, ...).
	 * 	- Parent object.
	 */

	IGRint			sts = OM_S_SUCCESS,
				i ;

	SetProc( VDdrw2dVw_ACconstruct_feet ); Begin

	*msg = MSSUCC ;

	/*
	 * Create a temporary object to go thruuuuuuu  the compute.
	 */
	*fcount = 1 ;
	for( i=0 ; i<*fcount ; i++ ){
	  sts =
	  ACcreate_pl_hold( feet_list +i, OM_Gw_current_OS );
	}

	goto wrapup ;		/* Avoid warning */

	wrapup:
		End ;
		return sts;
}

/*+mo
 -------------------------------------------------------------------------
  Public Message 
	NDupdate from NDnode

  Description:
 
      This file implements the NDupdate for the object after modification.
 
  Dependencies:
	VDdrw2dVw

  History:
 
  -------------------------------------------------------------------------
 */


method	NDupdate(		IGRint		*msg;
				IGRint		cn_type; 
				IGRint		count;
				struct GRid	*parents;
				IGRint		*parent_state ;
				struct GRid	*context ;
				struct GRid	*new_objid ;
				struct GRmd_env	*md_env )
{
	IGRint		sts = OM_S_SUCCESS ;
	
	SetProc( VDdrw2dVw_NDupdate ); Begin

	*msg = MSSUCC ;

	sts =
	_VD_SEND_WRT_M( my_id, ACncpx.NDupdate(	msg,
						cn_type,
						count,
						parents,
						parent_state,
						context,
						new_objid,
						md_env ));
	__CheckRC( sts, *msg, "ACncpx.NDupdate", wrapup ) ;

	wrapup :
		End ;
		return sts ;
}


/*+mo
 -------------------------------------------------------------------------
  Public Message 
	VDcompute from VDSroot

  Description:
 
      This file implements the VDcompute call for all VDdrw3d objects.
 
  Dependencies:
	VDdrw2dVw

  History:
 
  -------------------------------------------------------------------------
 */

method	VDcompute(	long		*msg;
			int		*type )
{
	/*
	 * find the list of all the VDdrw3d object which are
	 * connect to this Volume Control object.
	 */
	IGRint			sts = OM_S_SUCCESS ,
				oType = VD_O_drw2dObj,
				count,
				sizBuf,
				sizRet ;
	struct	GRid		myGRid,
				*grids = NULL ;
	struct	GRmd_env	locEnv ;

	SetProc( VDdrw2dVw_VDcompute ); Begin

	*msg	= MSSUCC ;

	myGRid.objid	= my_id ;
	myGRid.osnum	= OM_Gw_current_OS ;

	sizBuf = sizeof( locEnv );
	sts =
	gr$get_module_env(	msg	= msg,
				sizbuf	= &sizBuf,
				buffer	= &locEnv,
				nret	= &sizRet );

        sts =
        VDdrw_GetChannelObjects( msg, &myGRid, NULL, oType, &count,&grids,NULL);
        __CheckRC( sts, *msg, "VDdrw_GetChannelObjects", wrapup );

	__DBGpr_int(" Object Found ", count );

	/*
	 * This way we can use the internal sets for processing increasement.
	 */
	sts =
	VDdrw_ProcessVDdrw_Objects( msg, &locEnv, oType, count, grids );
	__CheckRC( sts, *msg, "VDdrw_ProcessVDdrw_Objects", wrapup );

	wrapup :

		_FREE( grids );
		End ;
		return sts ;
}

/*+mo
 -------------------------------------------------------------------------
  Overridden Message
        ACmplace_from_def from ACncpx

  Abstract

	Place an occurence of the macro in the design file.

  Arguments
      int 		*suc       	O 	0 FAILED 1 SUCCESS
      int		prop            I 	see macro.h
      char		rep             I 	navsea representation
      char 		*macro_name	I 	the macro to place
      int 		numb_obj	I 	the number of real template
      struct GRid 	*uplist     	I 	the list of templates
      struct GRid 	*def_occ    	I 	transfer context has to be 
						performed from this default 
						occurence
      struct GRmd_env	*mod_env	I	module env

  Status/Return Code
     OM_S_SUCCESS	if success;
     OM_E_ABORT		if fails

 -------------------------------------------------------------------------
-mo*/
method ACmplace_from_def(	int		*rc,
						prop;
				char		rep;
				char		*macro_name;
				int		num_temp;
				struct GRid	*temp_list;
				struct GRid	*def_occ;
				struct GRmd_env *md_env ){

	/*
	 * Put the properties to no proptect:
	 *	- Does not create source,
	 *	- Does not verify the number (variable number of templates) 
	 *	- Does not verify the template types
	 */

	IGRint		sts = OM_S_SUCCESS ;

	SetProc( VDdrw2dVw_ACmplace_from_def ); Begin

	prop = prop | AChdr_noprotect | ACcant_place_sym | AChdr_nocompute ;

	sts =
	_VD_SEND_WRT_M( my_id, ACncpx.ACmplace_from_def(rc,
							prop,
							rep, 
							macro_name,
							num_temp,
							temp_list,
							def_occ,
							md_env ));
	__CheckRC( sts, *rc, "ACncpx.ACmplace_from_def", wrapup ) ;

	wrapup:
		End ;
		return	sts;
}

/*mo+
 -------------------------------------------------------------------------
  Public Message
        GRputattr	from GRvg

  Abstract
        Set the instance info for 3d visualization Volume Area object.

  Arguments
        OUT     long            *msg            Completion code.
	OUT	VDpartAttr	*attr		Information.

  Note

 -------------------------------------------------------------------------
-mo*/

method	GRputattr(	IGRlong         *msg ;
                        IGRchar		*attr ){

	IGRint			sts = OM_S_SUCCESS ,
				i ,
				lenBuf,
				lenStr,
				lenDiff,
				lenInfo,
				maxNote,
				*pInt ;
	IGRdouble		*pDouble ;
	VDpartAttr		*part ;
	VDdrw2dVwInfo		*vwInfo ;
	struct	IGRlbsys	*pLbsys ;
	GRname			buffer;

	SetProc( VDdrw2dVw_GRputattr ); Begin
	
	*msg	= MSSUCC ;
	part	= (VDpartAttr *) attr ;

	maxNote = VD_I_drwNoteOther2 - VD_I_drwNoteName ;

	switch(	part->Iwant ) {

	case	VD_I_drwInitialization	:
		sts =
		om$vla_set_dimension(	varray	= me->visual_2d, size = 0 );
		om$vla_set_dimension(	varray	= me->transp_2d, size = 0 );
		om$vla_set_dimension(	varray	= me->detach_2d, size = 0 );
		om$vla_set_dimension(	varray	= me->name     , size = 0 );
		om$vla_set_dimension(	varray	= me->note     , size = 7 );
		om$vla_set_dimension(	varray	= me->indx     , size = 7 );

		buffer[0] = '\0';
		
		for( i=0 ; i<= maxNote ; i++ ){
			me->indx[i] = i ;
			strcpy(	&me->note[ me->indx[i]], buffer );
		}

		for( i=0 ; i<32 ; i++ ) me->drwLevel[i] = ~0 ;
		me->drwPnt[0] = 0 ; me->drwPnt[1] = 0 ; me->drwPnt[2] = 0 ;
		me->drwVec[0] = 0 ; me->drwVec[1] = 0 ; me->drwVec[2] = 1 ;

                MAidmx( msg, me->drwLbs.matrix );
                me->drwLbs.diag_pt1[0] = -MAXDOUBLE ;
                me->drwLbs.diag_pt1[1] = -MAXDOUBLE ;
                me->drwLbs.diag_pt1[2] = -MAXDOUBLE ;
                me->drwLbs.diag_pt2[0] =  MAXDOUBLE ;
                me->drwLbs.diag_pt2[1] =  MAXDOUBLE ;
                me->drwLbs.diag_pt2[2] =  MAXDOUBLE ;

		break ;
	case	VD_I_drwInternalName	:

		lenInfo = 1 + strlen( part->aString );
		om$vla_set_dimension( varray = me->name, size = lenInfo );
		strcpy( me->name, part->aString );
		__DBGpr_str(" name  ", me->name  );

		break ;
	case	VD_I_drwNoteName	:
	case	VD_I_drwNoteScale	:
	case	VD_I_drwNoteLocation	:
	case	VD_I_drwNoteDesciption	:
	case	VD_I_drwNoteReference	:
	case	VD_I_drwNoteOther1	:
	case	VD_I_drwNoteOther2	:

		/*
		 * get the information from the buffer.
		 */
		i = part->Iwant - VD_I_drwNoteName ;

		__DBGpr_int( "Table Index ", i );
		lenBuf  = om$dimension_of(	varray	= me->note );
		lenStr  = strlen( &me->note[ me->indx[i]] );
		lenInfo = strlen( part->aString );
		lenDiff = lenInfo - lenStr ;

		__DBGpr_int( "	lenStr  ", lenStr  );
		__DBGpr_int( "	lenInfo ", lenInfo );
		__DBGpr_int( "	lenDiff ", lenDiff ); 

		/*
		 * Check what to do with buffer.
		 * If lenStr = lenInfo	-> copy info.
		 * If lenStr < lenInfo  -> copy info + move buffer 
		 *			   change indx list + rezise note..
		 * If lenStr > lenInfo  -> increase note + move buffer,
		 *			   change indx list + copy info.
		 */
		if( lenDiff == 0 ){
		  strcpy( &me->note[ me->indx[i]], (char *) part->aString );
		}
		else{
		  if( lenDiff > 0 )
		    om$vla_set_dimension(	varray	= me->note,
						size	= lenBuf + lenDiff );

		  if( i < maxNote ){
		      lenInfo = lenBuf - me->indx[i] ;
		      OM_BLOCK_MOVE(	&me->note[ me->indx[i+1] ],
					&me->note[ me->indx[i+1] + lenDiff ],
					lenInfo * sizeof( IGRchar ) );
		  }

		  strcpy( &me->note[ me->indx[i]], part->aString );

		  i++ ;
		  for( ; i<= maxNote ; i++ ) me->indx[i] += lenDiff ;

		  if( lenDiff < 0 )
		    om$vla_set_dimension(	varray	= me->note,
						size	= lenBuf + lenDiff );
		}

#ifdef	vdsDEBUG
		for( i=0 ; i<=maxNote ; i++ )
		  __DBGpr_str( "INFO ", &me->note[ me->indx[i]] );
#endif
	
		break ;
	case	VD_I_drwVisual	:
	case	VD_I_drwTrans	:
	case	VD_I_drwDetach	:

		/*
		 *  Temporary the support file for all are the same.
		 */

		lenInfo = 1 + strlen( part->aString );
		om$vla_set_dimension( varray = me->visual_2d, size = lenInfo );
		om$vla_set_dimension( varray = me->transp_2d, size = lenInfo );
		om$vla_set_dimension( varray = me->detach_2d, size = lenInfo );

		strcpy( me->visual_2d, part->aString );
		strcpy( me->transp_2d, part->aString );
		strcpy( me->detach_2d, part->aString );

		break ;
	case	VD_I_drwProjPnt :

		pDouble	= (IGRdouble *) part->specific ;
		me->drwPnt[0]	= pDouble[0] ;
		me->drwPnt[1]	= pDouble[1] ;
		me->drwPnt[2]	= pDouble[2] ;

		break ;
	case	VD_I_drwProjVec :

		pDouble	= (IGRdouble *) part->specific ;
		me->drwVec[0]	= pDouble[0] ;
		me->drwVec[1]	= pDouble[1] ;
		me->drwVec[2]	= pDouble[2] ;

		break ;
	case	VD_I_drwProjLbs :

		pLbsys = (struct IGRlbsys *) part->specific ;
		me->drwLbs = *pLbsys ;

		break ;
	case	VD_I_drwProjLevel :

		pInt = (IGRint *) part->specific ;
		for( i=0 ; i<32 ; i++ ) me->drwLevel[i] = pInt[i] ;

		break ;
	case	VD_I_drwProjAllInfo :

                vwInfo = (VDdrw2dVwInfo *) part->specific ;
                if( vwInfo->intName ){
                  lenInfo = 1 + strlen( vwInfo->intName );
                  om$vla_set_dimension( varray = me->name, size = lenInfo );
                  strcpy( me->name, vwInfo->intName );
		}

                if( vwInfo->visFile ){
		  lenInfo = 1 + strlen( vwInfo->visFile );
		  om$vla_set_dimension( varray= me->visual_2d, size= lenInfo );
		  om$vla_set_dimension( varray= me->transp_2d, size= lenInfo );
		  om$vla_set_dimension( varray= me->detach_2d, size= lenInfo );

		  strcpy( me->visual_2d, vwInfo->visFile );
		  strcpy( me->transp_2d, vwInfo->visFile );
		  strcpy( me->detach_2d, vwInfo->visFile );
		}

                if( vwInfo->trsFile ){
		  lenInfo = 1 + strlen( vwInfo->trsFile );
		  om$vla_set_dimension( varray= me->transp_2d, size= lenInfo );
		  strcpy( me->transp_2d, vwInfo->trsFile );
		}

                if( vwInfo->prjVec ){
		  me->drwVec[0]	= vwInfo->prjVec[0] ;
		  me->drwVec[1]	= vwInfo->prjVec[1] ;
		  me->drwVec[2]	= vwInfo->prjVec[2] ;
		}
		if( vwInfo->prjPnt ){
			me->drwPnt[0]	= vwInfo->prjPnt[0] ;
			me->drwPnt[1]	= vwInfo->prjPnt[1] ;
			me->drwPnt[2]	= vwInfo->prjPnt[2] ;
		}
		if( vwInfo->objLev ){
			for(i=0;i<32;i++) me->drwLevel[i] = vwInfo->objLev[i] ;
		}
		if( vwInfo->drwLbsys ){
			me->drwLbs = *vwInfo->drwLbsys ;
		}
		break ;
	default :

		__DBGpr_int(" Unknown Type ", part->Iwant );
	}

	End ;
	return OM_S_SUCCESS ;
}

/*me+
 -------------------------------------------------------------------------
  Public Message
        GRgetattr	from GRvg

  Abstract
	Retrieve attribute values.

  Arguments
        OUT     long            *msg            Completion code.
	IN	VDpartAttr	*attr		Information.

  Note

 -------------------------------------------------------------------------
-mo*/

method GRgetattr(	IGRlong         *msg ;
			IGRchar		*attr ){

	VDpartAttr		*part ;
	VDdrw2dVwInfo		*vwInfo ;
	IGRint			i, *pInt ;
	IGRdouble		*pDouble ;

	SetProc( VDdrw2dVw_GRgetattr ); Begin

	*msg	= MSSUCC ;
	part    = (VDpartAttr *) attr ;

	__DBGpr_int( "TYPE ", part->Iwant );

	switch(	part->Iwant ) {

	case	VD_I_drwInitialization	:

		__DBGpr_com(" Invalid Option " );
		*msg = OM_E_INVARG ;
		break ;
	case	VD_I_drwInternalName	:

		strcpy( part->aString, me->name );
		__DBGpr_str( " Info ", part->aString );

		break ;
	case	VD_I_drwNoteName	:
	case	VD_I_drwNoteScale	:
	case	VD_I_drwNoteLocation	:
	case	VD_I_drwNoteDesciption	:
	case	VD_I_drwNoteReference	:
	case	VD_I_drwNoteOther1	:
	case	VD_I_drwNoteOther2	:

		strcpy( part->aString,
			&me->note[ me->indx[(part->Iwant-VD_I_drwNoteName)]] );
		__DBGpr_str( " Info ", part->aString );
	
		break ;
	case	VD_I_drwVisual	:

		strcpy( part->aString, me->visual_2d );
		__DBGpr_str(" visual_2d ", me->visual_2d );

		break ;
	case	VD_I_drwTrans	:

		strcpy( part->aString, me->transp_2d );
		__DBGpr_str(" transp_2d  ", me->transp_2d  );

		break ;
	case	VD_I_drwDetach	:

		strcpy( part->aString, me->detach_2d );
		__DBGpr_str(" detach_2d ", me->detach_2d  );

		break ;
	case	VD_I_drwProjPnt :

		/*
		 * External buffering.
		 */
		pDouble		= (IGRdouble *) part->specific ;
		pDouble[0]	= me->drwPnt[0]	;
		pDouble[1]	= me->drwPnt[1]	;
		pDouble[2]	= me->drwPnt[2]	;

		break ;
	case	VD_I_drwProjVec :

		pDouble		= (IGRdouble *) part->specific ;
		pDouble[0]	= me->drwVec[0]	;
		pDouble[1]	= me->drwVec[1]	;
		pDouble[2]	= me->drwVec[2]	;

		break ;
	case	VD_I_drwProjLbs :

		*(struct IGRlbsys *)part->specific = me->drwLbs ;

		break ;
	case	VD_I_drwProjLevel :

		pInt = (IGRint *) part->specific ;
		for( i=0 ; i<32 ; i++ ) pInt[i] = me->drwLevel[i] ;

		break ;
	case	VD_I_drwProjAllInfo :

                vwInfo = (VDdrw2dVwInfo *) part->specific ;
                if( vwInfo->intName )
                        strcpy( vwInfo->intName, me->name );
                if( vwInfo->visFile )
                        strcpy( vwInfo->visFile, me->visual_2d );
                if( vwInfo->trsFile )
                        strcpy( vwInfo->trsFile, me->transp_2d );
                if( vwInfo->prjVec ){
			vwInfo->prjVec[0]	= me->drwVec[0]	;
			vwInfo->prjVec[1]	= me->drwVec[1]	;
			vwInfo->prjVec[2]	= me->drwVec[2]	;
		}
		if( vwInfo->prjPnt ){
			vwInfo->prjPnt[0]	= me->drwPnt[0]	;
			vwInfo->prjPnt[1]	= me->drwPnt[1]	;
			vwInfo->prjPnt[2]	= me->drwPnt[2]	;
		}
		if( vwInfo->objLev ){
			for(i=0;i<32;i++) vwInfo->objLev[i] = me->drwLevel[i] ;
		}
		if( vwInfo->drwLbsys ){
			*vwInfo->drwLbsys = me->drwLbs ;
		}

		break; 
	default :
		__DBGpr_int(" Unknown Type ", part->Iwant );
	}

	End ;
	return OM_S_SUCCESS ;
}


/*+mo
 -------------------------------------------------------------------------
  Private Message 
	VDdeleteIfEmpty 

  Description:
	Delete the object itself under certain conditions.
 
  Dependencies:
	VDdrw2dVw

  History:
 
  -------------------------------------------------------------------------
 */

method	VDdeleteIfEmpty(	IGRlong			*msg;
				struct	GRmd_env	*md_env ){

	long		        sts = OM_S_SUCCESS ;
	OMuint			cnt = 0 ;
	IGRint			action = 0 ;
	OM_S_CHANSELECT		*to_drw ;

	SetProc( VDdrw2dVw_VDdeleteIfEmpty ); Begin

	*msg = MSSUCC;

	sts = VDdrw_GetToDrwChannel( VD_O_drw2d, &to_drw );
	CheckRC( sts, 1 );

	sts =
	om$get_channel_count(	objid		= my_id,
				p_chanselect	= to_drw,
				count		= &cnt );
	CheckRC( sts, 1 );

       __DBGpr_int( "count ", cnt );

	if( ! cnt ){

		struct	GRid	myGRid ;

		myGRid.objid	= my_id ;
		myGRid.osnum	= OM_Gw_current_OS ;

                /*
                 * check if object exist in VDbatData object -> remove it.
                 */
                sts =
                VDbat_UpdateControlData( msg, md_env, &myGRid, action );
                CheckRC( sts, *msg );
		
		sts =
		_VD_SEND_WRT_M( my_id, ASnode.GRdelete( msg, md_env ));
		CheckRC( sts, *msg );
	}
	
	End ;
	return sts ;
}

/*
  -------------------------------------------------------------------------
 */

end implementation VDdrw2dVw;
 

