/* $Id: COcrv_sland.u,v 1.1.1.1 2001/01/04 21:08:55 cvs Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:	vdloft/ppl/COcrv_sland.u
 *
 * Description:
 *		A Command to place a landing curve macro.
 *		Some functions or variables may be superfluous and have 
 *		been left to demonstrate various features.
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COcrv_sland.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:08:55  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.2  1997/01/31  18:48:02  pinnacle
# This is the updated file for CR 179603367
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.3  1996/03/27  14:41:12  pinnacle
# Replaced: vdloft/ppl/COcrv_sland.u for:  by azuurhou for vds.240
#
# Revision 1.2  1996/03/27  13:54:24  pinnacle
# Replaced: vdloft/ppl/COcrv_sland.u for:  by azuurhou for vds.240
#
# Revision 1.1  1996/03/24  19:30:30  pinnacle
# Created: ./vdloft/ppl/COcrv_sland.u by azuurhou for vds.240
#
 *
 * History:
 *	MM/DD/YY	AUTHOR	DESCRIPTION
 *			adz	creation date
 *
 *	01/31/97	ejm	Command needs to operate similar to next seam
 *	CR# 179603367		where the original inputs are retained and the
 *				user only is required to change the offset
 *				distance.
 *
 *				The function, main, was changed by placing the
 *				call to, VDdw_loc_exp, to a different location
 *				in the "while" loop to change the sequencing of
 *				requesting input from the user.
 ***************************************************************************/
   
#include <stdio.h>
#include "ciminimum.h"
#include "cievent.h"
#include "OMminimum.h"
#include "cimacros.h"
#include "cieveryone.h"
#include "cievent.h"
#include "asmacros.h"
#include "expmacros.h"
#include "grio.h"
#include "growner.h"
#include "VDSudp_mac.h"


/*
 * if bugs be carefull with these defines
 * Imported from ci_easy.h.
 */

#define EXP_SCALAR	0
#define EXP_DISTANCE	1
#define EXP_ANGLE	2
#define EXP_DOUBLE	0  

#include "v_dbgmacros.h"		// defines __CheckRC

extern OMuword	OPP_EMSsurface_class_id,
		OPP_EMSplane_class_id,
		OPP_GRcurve_class_id,
		OPP_GRpoint_class_id;

OMuword		TEMP_cl,		// temp value for checking types
		classid[2];		// list of classids for locate filter

struct OM_sd_classlist  classlist;	// classlist fed to locate

int 		sts,			// return code
		suc,			// return code
		i,xx ,		// counter
		numTempls;		// number of templates for the block
/* int n; */

IGRint		numParams;		// num of params for the collection

IGRlong		l_ret,			// long return and status codes
		l_sts;


char		loc_mes[80],		// buffers for prompts 
		loc_prompt[80],
		eloc_prompt[80],
		exp_prompt[80];

char		reply;			// response to ci$get

double		exp_default;		// value of parameters

IGRvector	YDir,
		ZDir ;

GRobj		paramColl,		// collection of parameters for block
		smsBlock;		// the placed block

struct GRid	MacId,			// id of a given expression
		Parents[8] ,		// list of parents for the macro
		OffsetCurve ;

struct GRmd_env	MOD_ENV;		// environment of current active file
GRobj		ci_mac_bib_FileId;	// The ci_mac_bib library.

struct GRobj_env  BaseObj;

struct GRlc_info	LineObj ,
		  	SurfObj ;

extern ASmake_source_from_env( ) ;
extern int 	sscanf();
extern int	ASmake_source(),
		ASmake_source_from_env(),
		DImain(),
		DIfast_trans(),
		EXP_translate_exp(),
		EXP_create_double(),
		EXP_create();
extern 		sprintf();
extern	char    *strchr();
extern  char    *strpbrk();
extern  int  	printf();
extern		UI_status();

char		dbg_txt[120];		// text used for debug purposes

extern	char *	malloc();
extern		free();
extern 	int 	VDStranslate();

extern	int	VLinitCnst(),
		VLlinesSrf() ;

main()
{
int n;
	sts =
	ci$get_module_info(md_env = &MOD_ENV);
	__CheckRC( sts, 1, "get_module failed, forced to exit", wrapup );

	numTempls     =	0;

	/*
	 * SETUP LOCATE LIST.
	 */

	classid[0]	=	OPP_EMSsurface_class_id;
	classid[1]	=	OPP_GRcurve_class_id;
	classlist.w_count =	2;
	classlist.w_flags =	OM_CLST_subclass;
	classlist.p_classes = classid;

	strcpy( loc_prompt ,	"Identify surface ( gen.surf.  only )"  ) ;

	xx = 4 ;
	Parents[2].objid = NULL_OBJID ; 

	while(1){

/*
 * always return to here, let the user terminate
 */
loc0:

	  if(!ci$locate(
		prompt       = loc_prompt, 
                properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
		eligible_classes = &classlist,
                owner_action = LC_RIGID_COMP
                                    | LC_RIGID_OWNER | LC_FLEX_COMP
                                    | LC_FLEX_OWNER  | LC_REF_OBJECTS,
	        obj          = &BaseObj.obj_id.objid,
                osnum        = &BaseObj.obj_id.osnum,
		md_env       = &BaseObj.mod_env )) break;

		// so what was located
		sts =
	        om$get_classid(	osnum	  = BaseObj.obj_id.osnum,
				objid     = BaseObj.obj_id.objid,
				p_classid = &TEMP_cl ) ;
		__CheckRC(sts, 1,"Block: base object get_classid ",wrapup);

		/*
		 ** now get the basic values **
		 */
		exp_default = 1.0;
		Parents[xx].osnum = MOD_ENV.md_id.osnum ;
		Parents[xx].objid = NULL_OBJID ;

		__DBGpr_obj( "parents xx", Parents[xx] ) ;

		/*
		 * Increment of parent. Ordering of parents in main of 
		 * crv_sland.u
		 */
		xx = xx + 1 ;

		/* Process graphic inputs first: surface, line(curve), and */
		/* bounding points (endpoints).				   */

		if(( om$is_ancestry_valid(
				superclassid = OPP_EMSsurface_class_id, 
				subclassid   = TEMP_cl ) == OM_S_SUCCESS )
		   && ( xx > 5 )){

		  if( Parents[2].objid != NULL_OBJID ){

		    sts =
		    as$make_source(	go_grid	= BaseObj.obj_id,
					mod_env	= &MOD_ENV,
					as_grid	= &Parents[3] );
		    __CheckRC( sts, 1, "ASmake_source of expression", loc0 );

		    strcpy( loc_prompt,"Locate Surface");
		  }
		  else{
		    sts =
		    as$make_source(	go_grid = BaseObj.obj_id ,
					mod_env = &MOD_ENV,
					as_grid = &Parents[2]);
		    __CheckRC( sts, 1, "ASmake_source of expression", loc0 );

		    strcpy( loc_prompt,"Locate Next Point/Plane");

		    continue ;
		  }
		}

		else if( om$is_ancestry_valid(
				superclassid = OPP_EMSsurface_class_id,
				subclassid   = TEMP_cl ) == OM_S_SUCCESS ){
		  sts =
		  as$make_source(	go_grid = BaseObj.obj_id ,
					mod_env = &MOD_ENV,
					as_grid = &Parents[0]);
		  __CheckRC( sts, 1, "ASmake_source of expression", loc0 );

		  strcpy( loc_prompt,"Locate Line");

		  continue ;
		}

		else if( om$is_ancestry_valid(
				superclassid = OPP_GRpoint_class_id, 
				subclassid   = TEMP_cl ) == OM_S_SUCCESS ){

		  if( Parents[2].objid != NULL_OBJID ) {
		    sts =
		    as$make_source(	go_grid = BaseObj.obj_id ,
					mod_env = &MOD_ENV,
					as_grid = &Parents[3]);
		    __CheckRC( sts, 1, "ASmake_source of expression", loc0 );

		    strcpy( loc_prompt,"Locate Surface");
		  }
		  else{
		    sts =
		    as$make_source(	go_grid = BaseObj.obj_id ,
					mod_env = &MOD_ENV,
					as_grid = &Parents[2]);
		    __CheckRC( sts, 1, "ASmake_source of expression", loc0 );

		    strcpy( loc_prompt,"Locate Next pt/Plane");

		    continue ;
		  }
		}
		else if( om$is_ancestry_valid(
				superclassid = OPP_GRcurve_class_id,
				subclassid   = TEMP_cl ) == OM_S_SUCCESS ){
		  sts =
		  as$make_source(	go_grid = BaseObj.obj_id ,
					mod_env = &MOD_ENV,
					as_grid = &Parents[1] );
		  __CheckRC( sts, 1, "ASmake_source of expression", loc0 );

		  strcpy( loc_prompt,"locate first point /plane ");

		  continue;
		}

		else	continue ;



		inputs:       



		/* Process input values: method and law (of evolution)   */
		/* to calculate new landing curve and offsets for new    */
		/* location.						 */

		/* Pressing Return at prompt will indicate the default   */
		/* value 						 */

		xx = 4;
		status( "0 = chord-height,  1 = curvilinear" );
		strcpy( exp_prompt,	"Enter value for method: 0,1");
		strcpy( eloc_prompt,	"Enter value for method: 0,1");

		VDdw_loc_exp(	&sts, loc_mes, eloc_prompt, exp_prompt, 
				&exp_default, &( Parents[xx] ) );

		xx = 5;
		status( "0=linear, 1=cubic, 2=cubic2, 3=quintic" );
       		strcpy( exp_prompt,"Enter value for law: 0,1,2,3");
       		strcpy( eloc_prompt,"Enter value for law: 0,1,2,3");

		VDdw_loc_exp(	&sts, loc_mes, eloc_prompt, exp_prompt, 
				&exp_default, &( Parents[xx] ) );

		offsets:

		xx = 6;
       		strcpy(exp_prompt,"Enter value for 1st offset");
       		strcpy(eloc_prompt,"Enter value for 1st offset");

		VDdw_loc_exp(	&sts, loc_mes, eloc_prompt, exp_prompt, 
				&exp_default, &( Parents[xx] ) );

		xx = 7;
       		strcpy(exp_prompt,"Enter value for 2nd offset");
       		strcpy(eloc_prompt,"Enter value for 2nd offset");

		VDdw_loc_exp(	&sts, loc_mes, eloc_prompt, exp_prompt, 
				&exp_default, &( Parents[xx] ) );


#ifdef	vdsDEBUG
		for ( i=0; i<8 ; i=i+1 ) 
			__DBGpr_obj( "parent", Parents[i] );
#endif

		MacId.objid = NULL_OBJID;
		MacId.osnum = Parents[0].osnum;

		/* Place the landing curve */

		sts =
		ci$send(msg  = message nci_macro.init(
                                          &l_ret ,
                                          0, 
                                          "crv_sland",
                                          (OMuint)8,
                                          Parents ,
					  0,
                                          &MOD_ENV),
                        targetid = MacId.objid,
                        targetos = MacId.osnum );

		if( l_ret == 1 && sts == 1 )
		{
		  ci$get( prompt = "Duplicate line with different offsets?  (y/n)  [y]",		  char   = reply);

		  if( reply != 'n' && reply != 'N' )
	 	     goto offsets;
		}

		strcpy( loc_prompt , "Identify surface ( gen.surf.  only )"  ) ;

		xx = 4 ;
		Parents[2].objid = NULL_OBJID ; 
		__DBGpr_obj( "macro", MacId );

		__CheckRC( sts, l_ret, "crv_sland.init", loc0 );

	}  /* while user input*/

wrapup:

	return sts;

}  /* main */


/*==========================================================================*/

init(){

 	strcpy(loc_mes,"<Assoc> Place Offset Line along Surface");

        ci$load ( file_name = "ci_mac_bib.u",
                  load      = LOAD,
                  file_id   = &ci_mac_bib_FileId,
                  stat      = &suc );
        if( suc != CI_S_SUCCESS ) exit;
}

wakeup(){
	message(loc_mes);
}

//==========================================================================

									
/*======================================================================*
 *      manage the user interface (get user inputs) to locate an expression
 *	most of the code in this function is left to demonstrate various
 *	ways of handling expressions.  There are too many gotos, to use
 *	in production software, these are a legacy from the command object
 *	used as a base for this version.
 *======================================================================*/

int VDdw_loc_exp( loc_suc, loc_message, loc_prompt, exp_prompt, exp_default, 
             EXP_GRid )

char		loc_prompt[80];	// prompt to ask the name of the expression 
char		exp_prompt[80]; // prompt ask a value			    
char		loc_message[80];// prompt to set the message field          
struct GRid	*EXP_GRid;	// return objid & osnum of the expression   
int		*loc_suc;       // return status			    
double   	*exp_default;    /* default value of the expression         
                                   must be setup                            */
{ 

char		expc_prompt[256];
char		*exp_true_name;
char		exp_name[80];
char		*exp_value, exp_true_value[80];
char		*equal;
int		sts, mask, response;
short		sender_class;

struct GRmd_env	MOD_ENV;
struct GRevent	event;

        message(loc_message);
	strcpy(expc_prompt,exp_prompt);
        strcat(expc_prompt," (default = ");
        strcat(expc_prompt,ftoa(*exp_default));
        strcat(expc_prompt,")");

	sts = ci$get_module_info(md_env = &MOD_ENV);
	__CheckRC( sts, 1, "get_module", wrapup ) ;

step0:
	EXP_GRid->objid = NULL_OBJID;

	mask =  GRm_RJT_MOVEON | GRm_STRING | GRm_OBJID | GRm_BACK_UP;

        do
        {
           *loc_suc = ci$getevent( prompt = loc_prompt, response = &response,
	     			   data   = exp_value,  mask     = mask,
				   event = &event,
                                   stackable = 1 );
           status("");
           if( (response == EX_RJT_MOVEON) || (response == EX_BACK_UP ) )
           { 
		*loc_suc = 0; 
		sts = 0;
		goto wrapup;
	   }

        }
  	while( *loc_suc != 1 );

	// object via the navigate graph, not used in this command 

	if( response == EX_OBJID )
        {

	  om$get_classid( osnum     = event.located_object[0].located_obj.osnum,
			  objid     = event.located_object[0].located_obj.objid,
			  p_classid = &sender_class );

	  sts  = om$is_ancestry_valid( subclassid     = sender_class,
				       superclassname = "expression" );
	  __CheckRC( sts, 1, "is ancester an expression", step0 );

	  EXP_GRid->objid = event.located_object[0].located_obj.objid;
	  EXP_GRid->osnum = event.located_object[0].located_obj.osnum;
	  goto wrapup;
        }


// a caracter string has been returned, only response for this command 

        if( response == STRING )
        {
           strcpy(exp_name, exp_value);
           if(exp_name[0] == 0 ) goto step1;

// try to find an "=" in the string 

 	   equal = strchr(exp_value,'=');
           if( equal != NULL )
           {
          	*equal = '\0';
	  	sts = exp$translate(exp_name = exp_value,
			             p_exp_id = &EXP_GRid->objid,
			             p_osnum  = &EXP_GRid->osnum );

                if( EXP_GRid->objid == NULL_OBJID )
                {
	                UI_status(" Creating new expression ");
			sts = exp$create(exp_name = exp_value,
					  exp_syntax = equal + 1,
			      		  p_exp_id = &EXP_GRid->objid,
			                  p_osnum  = &EXP_GRid->osnum );
			if( sts  != 1 )
                        {
	                  UI_status(" Syntax error ");
			  __CheckRC( sts, 1, "expcreate", step0 );
			}
		}
                else if( sts  == 1 ){
			status(" left hand side already defined ");
			goto step0;
		}
            } // end of process of  expxx = value  

	    else
            {
          	vds$translate (objname = exp_name, 
                	       p_objid = &(EXP_GRid->objid),
                               p_osnum = &(EXP_GRid->osnum) );
		

          	if ( (EXP_GRid->objid) == NULL_OBJID )
          	{

//---  		try to create an unname expression 			---

			EXP_GRid->objid = NULL_OBJID;			
			exp_true_name = NULL;
			strcpy(exp_true_value, exp_value);
			*exp_default = atof( exp_value );
	                UI_status(" Creating new expression ");
			sts  = exp$create(exp_name   = exp_true_name,
					  exp_syntax = exp_true_value,
					  osnum      = MOD_ENV.md_id.osnum,
			      		  p_exp_id   = &EXP_GRid->objid,
			                  p_osnum    = &EXP_GRid->osnum );

			__CheckRC( sts, 1, "446 create", step1 ) ;
			if ( sts  == 1 ) goto step3;


step1:	   	        UI_status("expression does not exist");
step2:           	

	   		EXP_GRid->osnum = MOD_ENV.md_id.osnum ;           
	   		mask =  GRm_RJT_MOVEON | GRm_BACK_UP | GRm_STRING;

           		do
           		{
             		   *loc_suc = ci$getevent( prompt    = expc_prompt, 
                                                   response  = &response,
	      			                   data      = exp_value, 
                                                   mask      = mask,
                                                   stackable = 1 );

             		   if( (response == EX_RJT_MOVEON) ||  
   	                       (response == EX_BACK_UP)  ) goto step0;

           		}
           		while( *loc_suc != 1 );

	   		if( exp_value[0] == 0 )
                             strcpy( exp_value, ftoa(*exp_default));

			if(exp_name[0] == '\0' ) exp_true_name = NULL;
			else		     exp_true_name = exp_name;
			__DBGpr_str( " 485 exp_syntax",  exp_value ) ;

			if (exp_true_name)
				__DBGpr_str( " 485 exp_name  ",exp_true_name  );
			__DBGpr_obj( "exp obj", *EXP_GRid ) ;

	                UI_status(" Creating new expression ");
			sts  = exp$create(exp_name   = exp_true_name,
					  exp_syntax = exp_value,
					  osnum      = MOD_ENV.md_id.osnum,
			      		  p_exp_id   = &EXP_GRid->objid,
			                  p_osnum    = &EXP_GRid->osnum );
			if( sts  != 1 )
                        {
	                  UI_status(" Syntax error "); 
			  __CheckRC( sts, 1, "485 create", step2 ) ;
			}

	  	} /*  string was null */ 


            } /* expression didn't exist */   

step3:
	    sts = ci$send(msg      = message NDnode.NDchg_state( 
                                                   (char)16,(char)16 ),
                    targetid = EXP_GRid->objid,
                    targetos = EXP_GRid->osnum	 ); 
	    __CheckRC( sts, 1 , "NDnode.NDchg_state", wrapup ) ;

	} // end of process string 

	*loc_suc = sts ;
wrapup:
   return sts;

}	// end loc_exp

/****		the end of this command object      **************************/

