/* $Id: fms_annot221.u,v 1.1.1.1 2001/01/04 21:07:41 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/vdannot/imp / fms_annot221.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: fms_annot221.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:41  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
 * FROM		Ad Zuurhout
 *
 * DESCRIPTION	
 *		This ppl file contains a copy information of the ppl file
 *		"dim_forms.u", which is loaded optionally in GRNUC.
 *		In case this was not done, the command object "Place
 *		Formatted Text With Leader" and "Place Item Number" failed.
 *		
 *		Therefor a copy of the information is defined in this 
 *		ppl command.
 *
 * CREATION	30-SEP-1992
 */

#include "cieveryone.h"
#include "cisend.h"
#include "cievent.h"
#include "cierrordef.h"
#include "cilocate.h"
#include "ciexec.h"
#include "madef.h"
#include "msdef.h"

#include "fontdef.h"
#include "font.h"
#include "fontmacros.h"

#include "asbox.h"

#include "FI.h"
#include "FEI.h"
#include "CIforms.h"

#include "dimdef.h"
#include "dimformdef.h"
#include "dim.h"
#include "dimmacros.h"
#include "dimform.h"
#include "dimdload.h"
#include "dimfmext.h"
#include "dimglobal.h"
#include "dimgraph.h"
#include "form_env.h"
#include "form_loc.h"
#include "dm_status.h"
#include "igrtypedef.h"
#include "OMminimum.h"
#include "igewindef.h"
#include "igecolordef.h"
#include "igecolmacros.h"
#include "ctype.h"

extern int printf(), sprintf(),fprintf();
extern char *malloc();
extern int free();
extern int GRget_font_info();
extern ASsuper_construct();
extern ci_notification();
extern strtok();
extern IGEgetnmfrclr();
extern IGEgetclrfrnm();

extern struct DMenv_param frm_env;
extern struct DMloc_param frm_loc;
extern struct DMmisc_param frm_misc;
extern struct DMsenv_param frm_senv;
extern struct DMglobal_param frm_glob;
extern struct DMweld_param frm_weld;
extern struct DMgadget_stack edit_stack;
extern int    frm_state;

int super_user;
struct CIform_st form_st;

	/*****************************************************

	This variable indicates the current state of gadget
	selection, data selection and active stack:

	Possible Values:

	STATE_NONE		- Neither editing a dimension
				  nor changing the global dim
				  parameters.

				  This state is possible when
				  the user chooses "edit dim"
				  command and the command is
				  waiting for the user to
				  locate a dimension. All the
				  gadgets are turned off and
				  no "dm" keyins are allowed.

	STATE_GLOBAL		- All changes are to the global
				  parameters and to any active
				  dimensions (in placement).
				  This is the normal state. All
				  gadgets are turned ON. Stack
				  if OFF.

	STATE_DIMENSION		- Changes are to a single or a
				  group of dimensions. This
				  state is possible when the
				  edit dimension command is
					  active and a dimension is
				  located. The command would
				  wait for the user to make
				  all the changes and apply
				  those changes to the dimesion
				  object(s).

	STATE_REPLAY		- Replay of chages - form display
				  should not be affected.

	*****************************************************/

extern struct DMkeyin_desc DMkeyin_list[];
extern struct DMform_info DMform_list[FORM_COUNT+1];
int SRstatus[FORM_COUNT];

	/*****************************************************

	Information on the forms being maintained by this PPL
	file. This information include the names, ids, display
	status etc.

	The last entry in the array stores dummy information
	for supporting the "dm" keyin not on the form.

	*****************************************************/

char input_status[80];

#define FORM_DISPLAYED is_form_displayed((int)p_dm_gadget->form_no)

struct
{
	char	selection[MAX_LABEL_COUNT];
	char	display[MAX_LABEL_COUNT];
} display_status[FORM_COUNT];

OMuword current_os;		/* Module Object Space */
OMuword transient_os;		/* Transient Object Space */

init()
{
	int form_no, label;

	trace_in("init");

	ASsuper_construct();

	ci$get_module_info(md_os = &current_os);
	transient_os = my_os();
	frm_state = STATE_GLOBAL;
	edit_stack.count = 0;
	super_user = FALSE;

	for (form_no=0; form_no<FORM_COUNT; form_no=form_no+1)
	{
		DMform_list[form_no].form_id = NULL;

		for (label=0; label<MAX_LABEL_COUNT; label=label+1)
		{
			display_status[form_no].selection[label] = ON;
			display_status[form_no].display[label] = OFF;
		}
	}

	RETURN(TRUE);
}

update_active_dim()
{
	IGRint  sts, rc;
	struct GRid env_grid, senv_grid;
	int on, off;
	extern OM_S_CHANSELECT ND_children;

	trace_in("update_active_dim");

	dm$get_dim_param(type = DM_ENV_PARAM, p_grid = &env_grid);
	dm$get_dim_param(type = DM_SENV_PARAM, p_grid = &senv_grid);
	
	sts =
	ci$send(msg = message DMroot.test_state((IGRshort)(DIM_IN_PLACEMENT), &on, &off),
		targetid = env_grid.objid,
		targetos = env_grid.osnum,
		p_chanselect = &ND_children);
	dm$status(sts = sts, action = RET_STATUS);

	if (on)
	{
		sts =
		ci$send(msg = message DMroot.set_dim_state(BIT_OR, (char)(DIM_NEEDS_UPDATE)),
			targetid = env_grid.objid,
			targetos = env_grid.osnum,
			p_chanselect = &ND_children);
		dm$status(sts = sts, action = RET_STATUS);

		if (frm_misc.tog_term) ci$put(cmd_key = "DMTgTr");
	}

	sts =
	ci$send(msg = message DMroot.test_state(DIM_IN_PLACEMENT, &on, &off),
		targetid = senv_grid.objid,
		targetos = senv_grid.osnum,
		p_chanselect = &ND_children);
	dm$status(sts = sts, action = RET_STATUS);

	if (on)
	{
		sts =
		ci$send(msg = message DMroot.set_dim_state(BIT_OR, DIM_NEEDS_UPDATE),
			targetid = senv_grid.objid,
			targetos = senv_grid.osnum,
			p_chanselect = &ND_children);
		dm$status(sts = sts, action = RET_STATUS);
	}

	RETURN(TRUE);
}


keyboard_input(p_dm_keyboard)
struct DMkeyboard *p_dm_keyboard;
{
	int  sts;
	struct DM_data_st dm_gadget;

	trace_in("keyboard_input");

	p_dm_keyboard->status[0] = '\0';
	dm_gadget.origin = KEYBOARD_INPUT;
	dm_gadget.stackable = TRUE;

	sts = DMkeyboard_to_internal(p_dm_keyboard, &dm_gadget);
	if (!(sts & 1))
	{
		status(p_dm_keyboard->status);
		return(TRUE);
	}

	if (dm_gadget.label == SUPER_USER)
	{
		super_user = sval_int(dm_gadget);
		return(TRUE);
	}

	if (dm_gadget.label<0 && dm_gadget.form_no==NOT_ON_FORM && !super_user)
	{
		strcpy(p_dm_keyboard->status, "Parameter name not found");
		status(p_dm_keyboard->status);
		return(TRUE);
	}

	status(p_dm_keyboard->status);

	sts = DMinternal_to_keyboard(&dm_gadget, p_dm_keyboard, FALSE);
	error_chk(sts);
	sts = user_input(&dm_gadget);
	error_chk(sts);

	status(p_dm_keyboard->response);

	RETURN(TRUE);
}

load_data()
{

	trace_in("load_data");

	if (frm_state != STATE_GLOBAL)
		RETURN(TRUE);

	dm$get_dim_param(type = DM_ENV_PARAM, p_data = &frm_env);
	dm$get_dim_param(type = DM_LOC_PARAM, p_data = &frm_loc);
	dm$get_dim_param(type = DM_MISC_PARAM, p_data = &frm_misc);
	dm$get_dim_param(type = DM_SENV_PARAM, p_data = &frm_senv);
	frm_misc.tog_term = FALSE;

	RETURN(TRUE);
}

save_data()
{
	int mod_type;

	trace_in("save_data");

	if (frm_state != STATE_GLOBAL)
		RETURN(TRUE);

	dm$put_dim_param(type = DM_ENV_PARAM, p_data = &frm_env);
	dm$put_dim_param(type = DM_LOC_PARAM, p_data = &frm_loc);
	dm$put_dim_param(type = DM_MISC_PARAM, p_data = &frm_misc);
	DMmerge_senv(&frm_senv, &frm_env, &frm_loc, &frm_misc);
	dm$put_dim_param(type = DM_SENV_PARAM, p_data = &frm_senv);
	dm$put_dim_param(type = DM_GLOB_PARAM, p_data = &frm_glob);
	dm$put_dim_param(type = DM_WELD_PARAM, p_data = &frm_weld);

	update_active_dim();

	RETURN(TRUE);
}

user_input(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int sts;
	int msg, target;
	struct GRmd_env md_env;

	trace_in ("user_input");

	switch (frm_state)
	{
		/**************/
		case STATE_GLOBAL:
		/**************/

		load_data();

		frm_misc.tog_term = FALSE;

		if (p_dm_gadget->label == GAD_DIM_MODE)
		{
			ci$get_module_info(md_env = &md_env);

			if (get_value_int(p_dm_gadget) == MODELING_MODE)
				target = PASS_TO_CUROS;
			else	target = PASS_TO_REFOS;

			sts =
			DMdisplay_update(
				(char)'\0',
				(char)'\0',
				(char)'\0',
				(char)'\0',
				TRUE,
				FALSE,
				FALSE,
				0,
				NULL,
				target,
				&md_env);
			dm$status(sts = sts);
		}

		if (((p_dm_gadget->label == KEY_VIEW_ANG) ||
		     (p_dm_gadget->label == KEY_DIM_DISP))&&
		     (p_dm_gadget->form_no == NOT_ON_FORM))
		{
			ci$get_module_info(md_env = &md_env);

			sts =
			DMdisplay_update(
				(char)'\0',
				(char)'\0',
				(char)'\0',
				(char)'\0',
				TRUE,
				FALSE,
				FALSE,
				0,
				NULL,
				PASS_TO_ALLOS,
				&md_env);
			dm$status(sts = sts);
		}

		sts = process_gadget_input(p_dm_gadget);
		dm$status(sts = sts, action = RET_STATUS);

		save_data();
		update_global_attr(p_dm_gadget);

		RETURN(TRUE);

	}
}

warning(flag)
int flag;
{
	int form_no;
	Form form_id;

	trace_in("warning");

	if (flag == CI_W_CLOSING_DGN)
	{
		for (form_no=0; form_no<FORM_COUNT; form_no=form_no+1)
		{
			form_id = DMform_list[form_no].form_id;
			if (form_id)
			{
				FIf_erase(form_id);
				FIf_delete(form_id);
				DMform_list[form_no].form_id = NULL;
			}
		}

		ci$delete(file_name = "forms_annot");
	}

	RETURN(TRUE);
}

process_gadget_input(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int form_no;
	int label;

	trace_in("process_gadget_input");

	form_no = p_dm_gadget->form_no;
	label = p_dm_gadget->label;

	switch(form_no)
	{
	case NOT_ON_FORM:

		process_input_NOT_ON_FORM(p_dm_gadget);
		break;

	default:

		printf("process_gadget_input: Unknown form %d\n", form_no);
		break;
	}

	RETURN(TRUE);
}

process_input_NOT_ON_FORM(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	double bln_size;

	trace_in("process_input_NOT_ON_FORM");

	p_dm_gadget->stackable = TRUE;

	switch(p_dm_gadget->label)
	{

		case KEY_BLN_TYPE:
		frm_senv.bln_type = get_value_int(p_dm_gadget);
		break;

		case KEY_BLN_SIZE:
		bln_size = get_value_double(p_dm_gadget);
		if(bln_size < 1.5)
		    strcpy(input_status, "Balloon Size Ratio must be atleast 1.5");
		else	frm_senv.bln_size = bln_size;
		break;

		case KEY_NUM_SIDES:
		frm_senv.num_sides = get_value_int(p_dm_gadget);
		break;

		case KEY_ANNOT_ORIE:
		frm_senv.an_orie = get_value_int(p_dm_gadget);
		break;

		case KEY_ANNOT_POSN:
		frm_senv.an_posn = get_value_int(p_dm_gadget);
		break;

		default:
		printf("NOT_ON_FORM: Unknown key %d\n", p_dm_gadget->label);
		RETURN(FALSE);
	}

	RETURN(TRUE);
}

update_global_attr(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	IGRint sts, target;
	struct GRmd_env md_env;
	IGRchar g_type, g_mask;
	IGRboolean compute;

	compute = FALSE;
	target = PASS_TO_ALLOS;

	if (p_dm_gadget->form_no == FORM_ENVIRON)
	{
		switch (p_dm_gadget->label)
		{
			case GAD_DET_COLR:
			g_mask = DIM_DETACHED;
			g_type = DIM_DETACHED;
			break;

			case GAD_DRVG_COLR:
			g_mask = DIM_DRIVING;
			g_type = DIM_DRIVING;
			break;

			case GAD_DIM_COLR:
			g_mask = DIM_DRIVING;
			g_type = 0;
			break;

			case GAD_DIM_MODE:
			g_mask = 0;
			g_type = 0;
			if (get_value_int(p_dm_gadget) == DETAILING_MODE)
				target = PASS_TO_CUROS;
			break;

			default:
			return(TRUE);
		}
	}
	else if (p_dm_gadget->form_no == NOT_ON_FORM)
	{
		switch (p_dm_gadget->label)
		{
			case KEY_DIM_DISP:
			g_mask = 0;
			g_type = 0;
			break;

			case KEY_VIEW_ANG:
			g_mask = 0;
			g_type = 0;
			break;

			case KEY_REF_TYPE:
			g_mask = DIM_REFERENCE;
			g_type = DIM_REFERENCE;
			compute = TRUE;
			break;

			default:
			return(TRUE);
		}
	}
	else return(TRUE);

	ci$get_module_info(md_env = &md_env);

	sts =
	DMglupdate(
		target,
		g_type,
		g_mask,
		(char)'\0',
		(char)'\0',
		compute,
		&md_env);
	dm$status(sts = sts);

	return(TRUE);
}

