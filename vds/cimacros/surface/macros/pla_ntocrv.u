/* $Id: pla_ntocrv.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / pla_ntocrv.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: pla_ntocrv.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1995/10/25  17:26:26  pinnacle
# Replaced: cimacros/surface/macros/pla_ntocrv.u for:  by tlbriggs for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	10/25/95	tlb		EMS 3.2: changed cs.h to grcoordsys.h
 *
 * -------------------------------------------------------------------*/

/*

	File name :		pla_ntocrv.u
	Revision date :		92/10/09
	Authors :		Jean-Luc LOSCHUTZ
	Product :		I/VDS - PPMmacro library

	Description :
	-----------

		<Assoc> Place Plane Normal to Curve

		ci_macro to place a plane of a given, size normal to
		the derivate of a curve at a specific location point

	History :
	-------
	89/?/?		JLL	Creation date
	92/09/10	JLL	At the origin this ci_macros had just 3
				templates:
  				temp_names[0] = "length", to define the size
						of the plane to construct;  
  				temp_names[1] = "curve", from which we extract
						the first and second derivate.  
  				temp_names[2] = "point", point projected in
					        normal onto the curve;  
				I had   temp_names[3] = "track_point",
				an extrat one to let the user to
				locate a track point to handle the orientation
				of the normal. if he place then a pla_offext
				or a srf_offset from it he will handle
				without ambiguitie the orientation.
				This ci_macros has been reviewed in such
				way that the old instanciations having
				just 3 templates will still behave has before.
				Please do not change the part handling
				3 or 4 templates, because in the previous case
				the way I defined my plane was funny and
				the direction of the normal did not follow 
				the derivate of the parent curve.
 */

#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bserr.h"
#include "csdef.h"
#include "grcoordsys.h"
#include "macro.h"
#include "nddef.h"
#include "EMSssprops.h"


#define		EPSILON		1.E-10


IGRchar 		*temp_names[4], *feet_names[1];
IGRint			temp_types[4];
GRobj 			ci_mac_def1;
struct GRid		CI_MACRO_ID;


unsigned IGRchar	props;

IGRshort		type, mat_type;
IGRdouble		matrix[16];

IGRint			i, k,j;
IGRlong			msg, stat, rc;

IGRdouble 	        VX[3],VY[3], VZ[3], ux, uy;
IGRdouble 	        proj_pt[3], u_par, min_dist, dudv[24], pt[9];

struct IGRbsp_curve     *bsp_curve;


struct GRid		CUV, CRV ,GRid_plane;

struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct ret_struct	len, org_ref, TrackPt;
IGRint			NumTemp;
IGRdouble		dir[3];

extern IGRint 		init_cnst_list(),
			BSnorvec(),
			BScrossp(),
			BScveval();

extern IGRdouble	BSmdstptcv();
extern		ASsuper_construct();
extern IGRdouble	BSdotp();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

  temp_names[0] = "length";  
  temp_names[1] = "curve";  
  temp_names[2] = "point";  
  temp_names[3] = "track_point";

  temp_types[0] = parameter_generic | double_type;
  temp_types[1] = curve_generic | conic_generic | line_generic;
  temp_types[2] = point_generic;
  temp_types[3] = point_generic;

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          =  ci_mac_def1,
		status 	          = &stat, 	
		name              = "pla_ntocrv",
              	temp_num          = 4, 		
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );

}

/* ========================================================================= */
place ()
{

  comp_pla();

  if( GRid_plane.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_plane, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);

}


/* ========================================================================= */

compute ()
{

  comp_pla();

  if( GRid_plane.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_plane, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}

/* ========================================================================= */


comp_pla()
{
	GRid_plane.objid = NULL_OBJID;
	GRid_plane.osnum = MOD_ENV.md_id.osnum;

/*---------------------------------------------------------------------------*/
/*----		check if we have a track point or not			-----*/
/*---------------------------------------------------------------------------*/

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&NumTemp),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);

  #ifdef DEBUG
	write(" NumTemp =",NumTemp,"\n");
  #endif

  if(!(stat&1)) return;

/*---------------------------------------------------------------------------*/
/*----			get the direction value and size		-----*/
/*---------------------------------------------------------------------------*/
        
  	msg = ci$send( msg      = message  ACcpx.ACfind_exp_temp_struct
			           (&stat, 0, (char *)&len,&MOD_ENV ),
		 targetid = CI_MACRO_ID.objid,
		 targetos = CI_MACRO_ID.osnum );
	if( !(stat&msg&1) ){
		status(" bad object template " );
		return;
	}

/*---------------------------------------------------------------------------*/
/*----			get the curve					-----*/
/*---------------------------------------------------------------------------*/

        GRid_plane.objid = NULL_OBJID;

  	msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,1,&CUV),
           	 targetid = CI_MACRO_ID.objid,
           	 targetos = CI_MACRO_ID.osnum );

	if( !(stat&msg&1) ) return;

  	msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						"",
						&CRV, 
						&mat_type, 
					        matrix ),
	   	targetid = CUV.objid,
	   	targetos = CUV.osnum );
	if( !(stat&msg&1) ) return;
 
/*---------------------------------------------------------------------------*/
/*----			get the point					-----*/
/*---------------------------------------------------------------------------*/

  	msg = ci$send( msg      = message  ACcpx.ACfind_exp_temp_struct
		           (&stat, 2, (char *)&org_ref,&MOD_ENV ),
		 targetid = CI_MACRO_ID.objid,
	   	 targetos = CI_MACRO_ID.osnum );
	if( !(stat&msg&1) ){
		status(" bad object template " );
		return;
	}

/*---------------------------------------------------------------------------*/
/*----		retrieve the curve geometry and project point on curve	-----*/
/*---------------------------------------------------------------------------*/

  	stat = ci$send( msg = message GRvg.GRgenabsg( 
					 &msg,
			                 &mat_type, 
				         matrix, 
					 &bsp_curve ),
           targetid = CRV.objid,
 	   targetos = CRV.osnum );

	if( !(stat&msg&1) ) return;



  	msg = BSmdstptcv (      bsp_curve,
				org_ref.var.point_st.pt, 
				&u_par,
				proj_pt,
				&min_dist,
				&rc );
  	if( rc != BSSUCC ){
		#ifdef DEBUG
			write("error in BSmdstptcv");
		#endif
    		return;
  	}

  	BScveval ( bsp_curve , u_par, 2, dudv, &rc);
	#ifdef DEBUG
	  for(i=0; i<9; i=i+3) write("dudv[",i,"] = ",dudv[i],
						      dudv[i+1],
						      dudv[i+2], "\n");
	#endif

	if( ( fabs(dudv[6]) < EPSILON ) &&
	    ( fabs(dudv[7]) < EPSILON ) &&
	    ( fabs(dudv[8]) < EPSILON ) ){
   		dudv[6] = -1.0 * dudv[4];
   		dudv[7] = dudv[3];
   		dudv[8] = 0.0;
   		if( ( fabs(dudv[6]) < EPSILON ) && ( fabs(dudv[7]) < EPSILON ) )
		dudv[6] = 1.0;
        }

/*---------------------------------------------------------------------------*/
/*----		retrieve the track point if NumTemp = 4			-----*/
/*---------------------------------------------------------------------------*/

	if( NumTemp == 4 ){
  		msg = ci$send( msg      = message  ACcpx.ACfind_exp_temp_struct
		           	(&stat, 3, (char *)&TrackPt,&MOD_ENV ),
		 	       targetid = CI_MACRO_ID.objid,
	   	 	       targetos = CI_MACRO_ID.osnum );
		if( !(stat&msg&1) ){
			status(" bad object track point " );
			return;
		}

		for(i=0; i<3; i=i+1)
		 	dir[i] = TrackPt.var.point_st.pt[i] - 
				  org_ref.var.point_st.pt[i];

		BSnorvec( &stat,&(dudv[3]));
   		BScrossp( &stat,&(dudv[6]),&(dudv[3]),VY );
   		BScrossp( &stat,VY,&(dudv[3]),VX );
		BSnorvec( &stat,VX);

		if( BSdotp(&stat,&(dudv[3]),dir) > 0.0 )
			for(i=0; i<3; i=i+1) VY[i] = -VY[i];

        	BSnorvec( &stat,VY);
		#ifdef DEBUG
		printf("NumTemp == 4 VX=%f,%f,%f\n",VX[0],VX[1],VX[2]);
		printf("NumTemp == 4 VY=%f,%f,%f\n",VY[0],VY[1],VY[2]);
		#endif

   		for(i=0; i<3; i=i+1){
			ux      = len.var.root_pm_st.value * VX[i] ;
			uy      = len.var.root_pm_st.value * VY[i] ;
     			pt[i]   = dudv[i] - uy + ux;
			pt[i+3] = pt[i] + 2.0 * uy;
			pt[i+6] = pt[i+3] - 2.0 * ux;
   		}

	}
	else{
		BSnorvec( &stat,&(dudv[3]));
   		BScrossp( &stat,&(dudv[6]),&(dudv[3]),VY );
        	BSnorvec( &stat,VY);
   		BScrossp( &stat,VY,&(dudv[3]),VX );
		BSnorvec( &stat,VX);
		#ifdef DEBUG
		printf("NumTemp == 3 VX=%f,%f,%f\n",VX[0],VX[1],VX[2]);
		printf("NumTemp == 3 VY=%f,%f,%f\n",VY[0],VY[1],VY[2]);
		#endif

   		for(i=0; i<3; i=i+1){
			ux      = len.var.root_pm_st.value * VX[i] ;
			uy      = len.var.root_pm_st.value * VY[i] ;
     			pt[i]   = dudv[i] + uy - ux;
			pt[i+3] = pt[i] + 2.0 * ux;
			pt[i+6] = pt[i] - 2.0 * uy;
   		}

	}


  	init_cnst_list();
  	get_symb();

  	dis.color		= cnst_list.color;
  	dis.weight		= cnst_list.weight;
  	dis.style		= cnst_list.style;
  	cst.msg			= &msg;
  	cst.properties		= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  	cst.display		= &dis;
  	cst.env_info		= &MOD_ENV;
  	cst.newflag		= FALSE;
  	cst.level		= cnst_list.level;
  	cst.name		= NULL;
	cst.class_attr 		= NULL;
  	cst.geometry   		= NULL;

	type = 0;

   	stat = ci$send(msg      = message EMSplane.EMplane (&msg,&cst,pt,type),
           	       targetid = GRid_plane.objid,
	   	       targetos = GRid_plane.osnum );

#ifdef DEBUG
write("GRconstruct stat =",stat,"GRid_plane =",GRid_plane.objid,
                                              GRid_plane.osnum, "\n");
#endif
	if( !(stat&1) ) {
		GRid_plane.objid = NULL_OBJID;
	}

}

init()
/* for initialization at loading time */
{
  feet_names[0] = "n_plane";
}

