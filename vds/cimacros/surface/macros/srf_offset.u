/* $Id: srf_offset.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / srf_offset.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: srf_offset.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.1 - PPM macro library - (alc)

   History :
   92/07/09     	Conversion to 2.0
   92/11/05     	Use message EMSsurface.EMoffset()
   94/04/11  cvr        changed EMoffset to add new arguments 
                        according to ems3.0

 */
   

// #define CLOCK 1
#ifdef CLOCK
extern clock();
#endif

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "AS_status.h"
#include "EMSssprops.h"
#include "bserr.h"
/**
# define DEBUG 1
 **/

extern printf(), ASsuper_construct();

unsigned IGRchar	props;

IGRint			i, j, num;
IGRchar 		*temp_names[2], *feet_names[1];
IGRint			temp_types[2];

IGRshort	        mat_type,  option;

IGRlong                  stat, msg;

GRobj 	                ci_mac_def1;

IGRdouble 	                matrix[16], offs_val, v1[3];
struct GRid		S_OFFSET, GR_OBJ, GR_V_OBJ, CI_MACRO_ID;
struct GRmd_env         MOD_ENV, from_env;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct ret_struct	expr;
IGRboolean              is_natural_normal;
struct IGRbsp_surface	*sf;
struct GRparms		proj_parms;
IGRdouble		point[3], normals[12], orientation, proj_pt[3];

extern  IGRint 		init_cnst_list();
extern	IGRdouble	BSdistptpt();
extern  void		BSsfevaln();
extern  IGRdouble	BSdotp();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

  temp_names[0]  = "offs";  
  temp_names[1]  = "surf"; 

  temp_types[0]  = parameter_generic | double_type | point_generic;
  temp_types[1]  = other_generic;
 
  feet_names[0]  = "ressur";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat, 	
		name              = "srf_offset",
              	temp_num          = 2, 		
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{
#ifdef CLOCK
my_clock();	// un coup pour rien
write( "srf_offset compute begin clock() = ", my_clock(), '\n' );
#endif
  construct_SURF();

  if( S_OFFSET.objid  == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1, &S_OFFSET, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);

#ifdef CLOCK
write( "srf_offset compute end clock() = ", my_clock(), '\n' );
#endif

 return(1);
}

/* ========================================================================= */

place ()
{
  construct_SURF();

  if( S_OFFSET.objid  == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1, &S_OFFSET, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);

}

/* ========================================================================= */

construct_SURF()
{
  int 		num_nooffsetsfs ;
  GRobjid	*nooffsetsfs ;
  char 		*status_str  ;	/* new arguments for EMoffset() in 2.1 */

  S_OFFSET.objid = NULL_OBJID;


   msg = ci$send( msg = message ACcpx.ACfind_exp_temp_struct( &stat,
						        0,
						        (char *) &expr,
						        &MOD_ENV),
  	    targetid = CI_MACRO_ID.objid,
	    targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) ){
	status(" bad object for expression offset" );
	return;
  }

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,1,&GR_OBJ),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) )return;

  msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
					&stat ,
					"",
					&GR_V_OBJ, 
					&from_env.md_env.matrix_type, 
					from_env.md_env.matrix ),
	         targetid = GR_OBJ.objid,
	         targetos = GR_OBJ.osnum );
  if(!(stat&msg&1)) return;

  from_env.md_id.osnum = GR_V_OBJ.osnum;

/*
    ci$send( msg = message ASnode.ASreturn_go( &GR_V_OBJ, &mat_type, matrix ),
	      targetid = GR_OBJ.objid,
	      targetos = GR_OBJ.osnum );
*/

  ci$send( msg      = message  EMSsubbs.EMget_props( &msg,&props),
	   targetid = GR_V_OBJ.objid,
	   targetos = GR_V_OBJ.osnum );

#ifdef CLOCK
write( "srf_offset construct before  EMgenerate_offset_surface clock() = ", my_clock(), '\n' );
#endif

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= NULL;
  cst.class_attr	= 0;
  cst.name		= 0;


  if(expr.type != double_type) {
   	stat = ci$send( msg      = message GRgraphics.GRptproject(
                           			&msg,
						&from_env.md_env.matrix_type, 
						from_env.md_env.matrix,
						&expr.var.point_st.pt[0],
						proj_pt,
						&proj_parms),
            		targetid = GR_V_OBJ.objid,
            		targetos = GR_V_OBJ.osnum);

	#ifdef DEBUG
	write("GR_V_OBJ=",GR_V_OBJ.objid,GR_V_OBJ.osnum,"\n");
	write("proj_parms.leaf_id=",proj_parms.leaf_id.objid,
				    proj_parms.leaf_id.osnum,"\n");
	write("proj_parms.u,v=",proj_parms.u,
				    proj_parms.v,"\n");

	write("proj_pt=",proj_pt[0],proj_pt[1],proj_pt[2],"\n");

	#endif


	if(!(stat&msg&1)){
		printf("ERROR in GRgraphics.GRprproject in srf_offset\n");
		return;
	}
	

  	stat = ci$send( msg	    = message GRvg.GRgenabsg(
					&msg,
					&from_env.md_env.matrix_type, 
					from_env.md_env.matrix,
					(char *)&sf) ,
	          	targetid = GR_V_OBJ.objid,
	          	targetos = GR_V_OBJ.osnum );


	BSsfevaln(sf,proj_parms.u,proj_parms.v,4,&num,point,normals,&msg);
	if( msg != BSSUCC ) return;
	
	num = 3 * num;
	for(i=3;i<num;i=i+3){
		for(j=0;j<3;j=j+1) normals[j] = normals[j] + normals[i+j];
	}

	offs_val = 0.0;

	for(i=0;i<3;i=i+1){
		 v1[i] = expr.var.point_st.pt[i] - proj_pt[i];
		 offs_val = offs_val + v1[i]*v1[i];
	}
	
	/*
	 * offset is always positive.
	 */
	offs_val = sqrt(offs_val);	
	orientation = BSdotp(&msg,v1,normals);

	#ifdef DEBUG
	write("orientation = ",orientation,"\n");
	#endif

	option = 1;

	if( orientation > 0.0 ){
		if( props & EMSIS_NRML_REVERSED ) is_natural_normal = FALSE;
    		else	 			  is_natural_normal = TRUE; 
	}
	else{
		if( props & EMSIS_NRML_REVERSED ) is_natural_normal = TRUE;
    		else	 			  is_natural_normal = FALSE; 
	}

  }
  else{
	offs_val = expr.var.root_pm_st.value;

        if( offs_val < 0.0 ){
                is_natural_normal = FALSE ;
                offs_val = fabs(offs_val);
        }
        else    is_natural_normal = TRUE;

   	option = 1;

    	if( props & EMSIS_NRML_REVERSED ){
		if( is_natural_normal )	is_natural_normal = FALSE;
		else 			is_natural_normal = TRUE;
	}
  }

  #ifdef DEBUG
  write("is_natural_normal = ",is_natural_normal,"\n");
  #endif

   S_OFFSET.osnum = MOD_ENV.md_id.osnum;

   num_nooffsetsfs = 0 ;
   nooffsetsfs     = NULL ;
   status_str      = NULL ;	/* EMS 2.1 */
   stat = ci$send( msg      = message EMSsurface.EMoffset(
					&msg,
					option,
                           		&from_env.md_env.matrix_type,
                           		from_env.md_env.matrix,
					&cst,
					is_natural_normal,
					offs_val,
                                        0,
                                        NULL,
                                        NULL,
					num_nooffsetsfs,
					nooffsetsfs,
					status_str,
					&S_OFFSET.objid,
                                        NULL  ),
            targetid = GR_V_OBJ.objid,
            targetos = GR_V_OBJ.osnum) ;

   if( !(stat&1) ) S_OFFSET.objid = NULL ;
   as$status( sts = stat ) ;

}


#ifdef CLOCK
int clk;
my_clock()
{
	int tmp1, tmp2;
	tmp1 = clock();
	tmp2 = (clk - tmp1)/10000;
	clk = tmp1;
	write(clk/10000,"   ");
	return -tmp2;
}
#endif
