/* $Id $  */

/*************************************************************************
 * I/VDS
 *
 * File:        vds/cimacros/surface/srf_tangents.u
 *
 * Description: 
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY   AUTHOR       DESCRIPTION
 *      xx/xx/00   Rama Rao     File Creation
 *	07/25/00   Rama Rao	Header Creation and Angle Evaluation
 *************************************************************************/

#if 0
#define DEBUG 	1	 /* for debugging purpose */
#define DEBUGPLUS 	1	 /* for debugging purpose */
#endif

#define MACRO_NAME	"srf_tangents"
#define MAX_TEMP	1
#define MAX_FEET	100
#define MAX_CHAR_FEET	10

#define EXP_DOUBLE	0

#include <stdio.h>
#include "VDppl.h"
#include "ci_mac_def.h"
#include "AS_status.h"
#include "nddef.h"
#include "bserr.h"
#include "v_geommacros.h"

extern int   init_cnst_list(), BSsfkttol2(), BSfindmkts(), BSalloccv(), 
	     BSconstprcv(), BSsfeval_b(), free(), pr_mat(), BSmkvec(),
	     MAbcendpts(), EX_get_modid_given_osnum(), EXP_create_double();

struct GRid	CI_MACRO_ID;

IGRlong extarctTangentLinesInUDirection( obj, env, num, tan_lines )
	struct GRid      obj;
	struct GRmd_env  env;
	IGRint           *num;
	struct GRid 	 *tan_lines;  
{
    BSrc                        rc;
    IGRlong                     sts, msg;
    IGRint                      i, num_mul, *index, nd;
    IGRdouble                   knot_tol, *tmul, u_par, v_par, u_between, dotp,
				v_between, angle, fun1[12], fun2[12], fun3[12], 
				fun4[12], cross_vec[3], spt[3], ept[3];
    IGRpoint                    org;
    IGRshort                    option;
    IGRboolean                  tst_planar;
    struct  IGRbsp_surface      *surf_geom;
    struct  IGRbsp_curve        *cv;

    index=NULL; tmul=NULL; surf_geom=NULL; *num=0;

    tst_planar=FALSE; knot_tol=0.0; option=2;

    sts = OM_S_SUCCESS;

    #if DEBUG
	printf("Extracting tangent Lines in U-direction\n");
	printf("Input Object = %d, %d, Md_Env = %d, %d\n", obj.objid, obj.osnum, env.md_id.objid, env.md_id.osnum );
        printf("Macro id/osnum    = %d/%d \n", CI_MACRO_ID.objid, CI_MACRO_ID.osnum) ;
        printf("Modulenv id/osnum = %d/%d \n", MOD_ENV.md_id.objid, MOD_ENV.md_id.osnum) ;
        printf("Modulenv mattype  = %d \n\n",  MOD_ENV.md_env.matrix_type)  ;
        pr_mat("Modulenv matrix            ",  4, 4, MOD_ENV.md_env.matrix) ;
    #endif

    vd_$get_geometry( msg      = &msg,
		      grobjId  = &obj, 
	  	      grobjEnv = &env, 
		      geometry = &surf_geom        );
    if (!(sts & msg & 1)) {
        #if DEBUG
            printf("Problem in getting the Geometry\n");
        #endif
        sts = 0 ; as$status(sts = sts) ;
        goto wrapup ;
    }

    tmul  = (IGRdouble *) om$malloc( size = surf_geom->u_num_knots * 
					sizeof(IGRdouble) );
    index = (IGRint    *) om$malloc( size = surf_geom->u_num_knots * 
					sizeof(IGRint   ) );
    BSsfkttol2( surf_geom->u_order, surf_geom->v_order, surf_geom->u_knots,
             surf_geom->v_knots, surf_geom->u_num_poles, surf_geom->v_num_poles,
             surf_geom->poles, surf_geom->weights, &knot_tol, &rc );
    if( rc != BSSUCC ) goto wrapup;

    BSfindmkts( &rc, &surf_geom->u_order, &surf_geom->u_num_poles, 
		surf_geom->u_knots, &knot_tol, &num_mul, tmul, index);
    if (rc != BSSUCC) {     
	#if DEBUG
	    printf( "Error in BSalloccv(v=0)\n");
	#endif
        msg = MSFAIL; goto wrapup;     
    }

    if( surf_geom->u_phy_closed )
    {
	#if DEBUG
	    printf("SUrface is Physically Closed in U direction\n");
	#endif
        tmul[num_mul] = surf_geom->v_knots[surf_geom->u_order-1];
        num_mul = num_mul + 1;
    }

    #if DEBUG
        printf("Number of multiple knots = %d\n", num_mul );
	for(i=0; i<num_mul; i=i+1 )
	    printf("Knot[%d] = %g\n", i, tmul[i] );
    #endif

    init_cnst_list();
    get_symb();

    dis.color            = cnst_list.color;
    dis.weight           = cnst_list.weight;
    dis.style            = cnst_list.style;

    cst.msg              = &msg;
    cst.properties       = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    cst.display          = &dis;
    cst.env_info         = &MOD_ENV;
    cst.newflag          = FALSE;
    cst.level            = cnst_list.level;
    cst.geometry         = NULL;
    cst.class_attr       = NULL;
    cst.name             = NULL;

    option = 1;
    org[0] = 0.0;
    org[1] = 0.0;

    for( i=0; i<num_mul; i=i+1 )
    {
	cv=NULL;
        org[1] = tmul[i];
        /* Evaluate the isometric curve : u = 0 */
        BSalloccv ( surf_geom->v_order, surf_geom->v_num_poles, 
		    surf_geom->rational, 0, &cv, &rc );
        if (rc != BSSUCC) 
	{     
	    #if DEBUG
		printf( "Error in BSalloccv(v=0)\n");
	    #endif
            msg = MSFAIL; goto wrapup;     
	}

        BSconstprcv ( &rc, surf_geom, &option, (IGRdouble *) &org[1],
                      &tst_planar, cv );
        if (rc != BSSUCC) 
	{     
	    #if DEBUG
		printf( "Error in BSconstprcv(u=0)\n");
	    #endif
            msg = MSFAIL; goto wrapup;     
        }

	u_par = tmul[i];
        v_par = ( surf_geom->v_knots[surf_geom->v_order-1] +
		  surf_geom->v_knots[surf_geom->v_num_poles] ) * 0.5 ;

        nd = 1 ;
	BSsfeval_b( &rc, surf_geom, &u_par, &v_par, &nd, &u_between, 
		    &v_between, fun1, fun2, fun3, fun4 );

	BSnorvec( &rc, &fun1[3] );
	fun1[3] = -1*fun1[3]; fun1[4] = -1*fun1[4]; fun1[5] = -1*fun1[5];

  	BSnorvec( &rc, &fun2[3] );

	MAbcendpts( &msg, cv, spt, ept );
        BSmkvec ( &rc, &fun1[0], spt, ept );
        BSnorvec( &rc, &fun1[0] );

	BScrossp( &rc, &fun1[0], &fun1[3], cross_vec );
	BSnorvec( &rc, cross_vec );
	BScrossp( &rc, cross_vec, &fun1[0], &fun1[6] );
	BSnorvec( &rc, &fun1[6] );

        BScrossp( &rc, &fun1[0], &fun2[3], cross_vec );
	BSnorvec( &rc, cross_vec );
        BScrossp( &rc, cross_vec, &fun1[0], &fun2[6] );
	BSnorvec( &rc, &fun2[6] );

	dotp =  fun1[6]*fun2[6] + fun1[7]*fun2[7] + fun1[8]*fun2[8];
	angle = 180.0/3.14159265359 * acos( dotp );

	if( angle > 90.0 )	angle = 180 - angle ;

	tan_lines[2*i].objid = NULL_OBJID;
        tan_lines[2*i].osnum = MOD_ENV.md_id.osnum;

        cst.geometry = (char*) cv;

	msg = ci$send(msg = message GRbcsubbc.GRconstruct(&cst),
				targetid = tan_lines[2*i].objid,
				targetos = tan_lines[2*i].osnum	 );

	sts = exp$create( exp_value  = angle,
			  osnum      = MOD_ENV.md_id.osnum,
			  p_exp_id   = &tan_lines[2*i+1].objid,
			  p_osnum    = &tan_lines[2*i+1].osnum    );

        if( cv ) free ( cv );
        cst.geometry = NULL;
    }
    *num = num_mul;
wrapup:
    if( tmul  )     om$dealloc( ptr = tmul      ); tmul      = NULL;
    if( index )     om$dealloc( ptr = index     ); index     = NULL;
    if( surf_geom ) om$dealloc( ptr = surf_geom ); surf_geom = NULL;

    return sts;
}


IGRlong extarctTangentLinesInVDirection( obj, env, num, tan_lines )
	struct GRid      obj;
	struct GRmd_env  env;
	IGRint           *num;
	struct GRid 	 *tan_lines;  
{
    BSrc                        rc;
    IGRlong                     sts, msg;
    IGRint                      i, num_mul, *index, nd;
    IGRdouble                   knot_tol, *tmul, u_par, v_par, u_between, dotp,
                                v_between, angle, fun1[12], fun2[12], fun3[12],
                                fun4[12], cross_vec[3], spt[3], ept[3];
    IGRpoint                    org;
    IGRshort                    option;
    IGRboolean                  tst_planar;
    struct  IGRbsp_surface      *surf_geom;
    struct  IGRbsp_curve        *cv;

    index=NULL; tmul=NULL; surf_geom=NULL; *num=0;

    tst_planar=FALSE; knot_tol=0.0; option=2;

    sts = OM_S_SUCCESS;

    #if DEBUG
	printf("Extracting tangent Lines in V-direction\n");
	printf("Input Object = %d, %d, Md_Env = %d, %d\n", obj.objid, obj.osnum, env.md_id.objid, env.md_id.osnum );
        printf("Macro id/osnum    = %d/%d \n", CI_MACRO_ID.objid, CI_MACRO_ID.osnum) ;
        printf("Modulenv id/osnum = %d/%d \n", MOD_ENV.md_id.objid, MOD_ENV.md_id.osnum) ;
        printf("Modulenv mattype  = %d \n\n",  MOD_ENV.md_env.matrix_type)  ;
        pr_mat("Modulenv matrix            ",  4, 4, MOD_ENV.md_env.matrix) ;
    #endif

    vd_$get_geometry( msg      = &msg,
		      grobjId  = &obj, 
	  	      grobjEnv = &env, 
		      geometry = &surf_geom        );
    if (!(sts & msg & 1)) {
        #if DEBUG
            printf("Problem in getting the Geometry\n");
        #endif
        sts = 0 ; as$status(sts = sts) ;
        goto wrapup ;
    }

    tmul  = (IGRdouble *) om$malloc( size = surf_geom->v_num_knots * 
				sizeof(IGRdouble) );
    index = (IGRint    *) om$malloc( size = surf_geom->v_num_knots * 
				sizeof(IGRint   ) );
    BSsfkttol2( surf_geom->u_order, surf_geom->v_order, surf_geom->u_knots,
             surf_geom->v_knots, surf_geom->u_num_poles, surf_geom->v_num_poles,
             surf_geom->poles, surf_geom->weights, &knot_tol, &rc );
    if( rc != BSSUCC ) goto wrapup;

    BSfindmkts( &rc, &surf_geom->v_order, &surf_geom->v_num_poles, 
		surf_geom->v_knots, &knot_tol, &num_mul, tmul, index);
    if (rc != BSSUCC) 
    {     
	#if DEBUG
	    printf( "Error in BSalloccv(v=0)\n");
	#endif
        msg = MSFAIL; goto wrapup;     
    }

    if( surf_geom->v_phy_closed )
    {
        #if DEBUG
            printf("SUrface is Physically Closed in V direction\n");
        #endif
        tmul[num_mul] = surf_geom->v_knots[surf_geom->v_order-1];
        num_mul = num_mul + 1;
    }

    #if DEBUG
        printf("Number of multiple knots = %d\n", num_mul );
	for(i=0; i<num_mul; i=i+1 )
	    printf("Knot[%d] = %g\n", i, tmul[i] );
    #endif

    init_cnst_list();
    get_symb();

    dis.color            = cnst_list.color;
    dis.weight           = cnst_list.weight;
    dis.style            = cnst_list.style;

    cst.msg              = &msg;
    cst.properties       = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    cst.display          = &dis;
    cst.env_info         = &MOD_ENV;
    cst.newflag          = FALSE;
    cst.level            = cnst_list.level;
    cst.geometry         = NULL;
    cst.class_attr       = NULL;
    cst.name             = NULL;

    option    = 2;
    org[0] = 0.0;
    org[1] = 0.0;

    for( i=0; i<num_mul; i=i+1 )
    {
	cv=NULL;
        org[0] = tmul[i];
        /* Evaluate the isometric curve : v = 0 */
        BSalloccv ( surf_geom->u_order, surf_geom->u_num_poles, 
		    surf_geom->rational, 0, &cv, &rc );
        if (rc != BSSUCC) 
	{     
	    #if DEBUG
		printf( "Error in BSalloccv(v=0)\n");
	    #endif
            msg = MSFAIL; goto wrapup;     
	}

        BSconstprcv ( &rc, surf_geom, &option, (IGRdouble *) &org[0],
                      &tst_planar, cv );
        if (rc != BSSUCC) 
	{     
	    #if DEBUG
		printf( "Error in BSconstprcv(v=0)\n");
	    #endif
            msg = MSFAIL; goto wrapup;     
	}

        u_par = ( surf_geom->u_knots[surf_geom->u_order-1] +
                  surf_geom->u_knots[surf_geom->u_num_poles] ) * 0.5 ;
	v_par = tmul[i];

        nd = 1 ;
        BSsfeval_b( &rc, surf_geom, &u_par, &v_par, &nd, &u_between,
                    &v_between, fun1, fun2, fun3, fun4 );

        BSnorvec( &rc, &fun1[3] );
        fun1[3] = -1*fun1[3]; fun1[4] = -1*fun1[4]; fun1[5] = -1*fun1[5];

        BSnorvec( &rc, &fun2[3] );

        MAbcendpts( &msg, cv, spt, ept );
        BSmkvec ( &rc, &fun1[0], spt, ept );
        BSnorvec( &rc, &fun1[0] );

        BScrossp( &rc, &fun1[0], &fun1[3], cross_vec );
        BSnorvec( &rc, cross_vec );
        BScrossp( &rc, cross_vec, &fun1[0], &fun1[6] );
        BSnorvec( &rc, &fun1[6] );

        BScrossp( &rc, &fun1[0], &fun2[3], cross_vec );
        BSnorvec( &rc, cross_vec );
        BScrossp( &rc, cross_vec, &fun1[0], &fun2[6] );
        BSnorvec( &rc, &fun2[6] );

        dotp =  fun1[6]*fun2[6] + fun1[7]*fun2[7] + fun1[8]*fun2[8];
        angle = 180.0/3.14159265359 * acos( dotp );

        if( angle > 90.0 )      angle = 180 - angle ;

	tan_lines[2*i].objid = NULL_OBJID;
        tan_lines[2*i].osnum = MOD_ENV.md_id.osnum;

        cst.geometry = (char*) cv;

	msg = ci$send(msg = message GRbcsubbc.GRconstruct(&cst),
				targetid = tan_lines[2*i].objid,
				targetos = tan_lines[2*i].osnum	 );

        sts = exp$create( exp_value  = angle,
                          osnum      = MOD_ENV.md_id.osnum,
                          p_exp_id   = &tan_lines[2*i+1].objid,
                          p_osnum    = &tan_lines[2*i+1].osnum    );

        if( cv ) free ( cv );
        cst.geometry = NULL;
    }
    *num = num_mul;

wrapup:
    if( tmul  )     om$dealloc( ptr = tmul      ); tmul      = NULL;
    if( index )     om$dealloc( ptr = index     ); index     = NULL;
    if( surf_geom ) om$dealloc( ptr = surf_geom ); surf_geom = NULL;

    return sts;
}

IGRlong compute_tangentlines(compute_flag, direction, num_lines, TANL)
        IGRboolean      compute_flag ; /* I : FALSE (place), TRUE (compute) */
	IGRint		direction;     /* I : 0 - U, 1 - V          */
	IGRint		*num_lines;    /* O : Number of tangent lines */
        struct GRid     *TANL ;        /* O : list of tangent lines */
{
IGRlong			rc_evaluate, sts;
IGRint 			num_ent;
struct GRid             OBJ;
struct GRmd_env         OBJ_ENV ;

    *num_lines   = 0;
    num_ent     = 0;
    rc_evaluate = 1;

    sts = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,&OBJ,1,NULL,
                                             0,1,&num_ent),
               targetid = CI_MACRO_ID.objid,
               targetos = CI_MACRO_ID.osnum);
    if(!(sts & 1) || (num_ent != 1))
    {
        #ifdef DEBUG
        printf("Problem when sending NDnode.NDget_objects() message \n") ;
        #endif
        rc_evaluate = 0 ;
        goto quit ;
    }

    sts = ci$send(  msg = message NDnode.ASreturn_go(&OBJ,
                                  &OBJ_ENV.md_env.matrix_type,
                                  OBJ_ENV.md_env.matrix),
                targetid = OBJ.objid,
                targetos = OBJ.osnum) ;
    if (!(sts & 1)) 
    {
        #ifdef DEBUG
        printf("Problem when sending NDnode.ASreturn_go() message \n") ;
        #endif
        rc_evaluate = 0 ;
        goto quit ;
    }

    OBJ_ENV.md_id.objid = MOD_ENV.md_id.objid;
    OBJ_ENV.md_id.osnum = OBJ.osnum ;

    if( direction == 0 )
         sts = extarctTangentLinesInUDirection( OBJ, OBJ_ENV, 
						num_lines, &TANL[0] );
    else
	 sts = extarctTangentLinesInVDirection( OBJ, OBJ_ENV,
						num_lines, &TANL[0] );
    if (!(sts & 1))
    {
        #ifdef DEBUG
        printf("Problem in extarctTangentLines \n") ;
        #endif
        rc_evaluate = 0 ;
        goto quit ;
    }
quit:
    return rc_evaluate;
}

/* ------------------------------------------------------------------------- */
/*    The main function is the one implementing the definition creation      */
/* ------------------------------------------------------------------------- */
main ()
{
IGRint  i ;
IGRlong stat ;
IGRchar *temp_names[MAX_TEMP] ;
IGRchar *feet_names[MAX_FEET] ;
IGRchar buffer[MAX_CHAR_FEET * MAX_FEET] ;
IGRint  temp_types[MAX_TEMP]  ;
GRobj   ci_mac_def1    ;

    temp_names[0] = "surface"  ;      /* locate only class EMSsurface  */ 
    temp_types[0] = other_generic ;   /* surface_generic not in parametric.h */

    /* Set feet names */
    for (i = 0 ; i < MAX_FEET ; i = i + 2) 
    {
	sprintf(&buffer[i*MAX_CHAR_FEET], "tanline%d", (i/2)+1 )  ;
	feet_names[i] = &buffer[i*MAX_CHAR_FEET] ;
	sprintf(&buffer[(i+1)*MAX_CHAR_FEET], "angle%d", (i/2)+1 )  ;
	feet_names[i+1] = &buffer[(i+1)*MAX_CHAR_FEET] ;
    }

    ci_mac_def1 = NULL_OBJID ;

    ac$cimacdef(cimacdef          = ci_mac_def1,
		status 	          = &stat, 	
		name              = MACRO_NAME,
              	temp_num          = MAX_TEMP, 		
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = MAX_FEET,
		extern_feet_names = feet_names ) ;
} /* main() */

place ()
{
IGRboolean  compute_flag ;
IGRlong     sts, msg ;
IGRint	    direction, num_u_lines, num_v_lines;
struct GRid TANL[MAX_FEET] ; /* external boundary(ies) : composite curve */

    compute_flag = FALSE ; direction = 0; num_u_lines = 0;
    sts = compute_tangentlines(compute_flag, direction,
			&num_u_lines, &TANL[0]) ; /* get surface boundaries */
    if (!(sts & 1)) 
    {
	#ifdef DEBUG
	printf("\nplace() : error in compute_tangentlines()\n\n") ; 
	#endif
	return 0 ;
    }

    compute_flag = FALSE ; direction = 1; num_v_lines = 0;
    sts = compute_tangentlines(compute_flag, direction, &num_v_lines,
                        &TANL[2*num_u_lines]) ; /* get surface boundaries */
    if (!(sts & 1))
    {
        #ifdef DEBUG
        printf("\nplace() : error in compute_tangentlines()\n\n") ;
        #endif
        return 0 ;
    }

    if( num_u_lines || num_v_lines )
    {
        sts = ci$send(msg = message ci_macro.set_all_extern_feet
                                (&msg, MAX_FEET, &TANL[0], &MOD_ENV),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum) ; 
        as$status(sts = sts) ;
        if (!(sts & msg & 1))
        {
            printf("Error with ci_macro.set_all_extern_feet() in place() method \n") ;
            return 0 ;
        }
    } 
    else
    {
        #ifdef DEBUG
        printf("\nplace() : There are NO tangents lines\n") ;
        #endif
        return 0 ;
    }

    return 1 ;
} /* place() */

compute ()
{
IGRboolean  compute_flag ;
IGRlong     sts, msg ;
IGRint	    direction, num_u_lines, num_v_lines;
struct GRid TANL[MAX_FEET] ;

    compute_flag = TRUE ; direction = 0; num_u_lines = 0;
    sts = compute_tangentlines(compute_flag, direction,
                        &num_u_lines, &TANL[0]) ; /* get surface boundaries */
    if (!(sts & 1))
    {
        #ifdef DEBUG
        printf("\nplace() : error in compute_tangentlines()\n\n") ;
        #endif
        return 0 ;
    }

    compute_flag = TRUE ; direction = 1; num_v_lines = 0;
    sts = compute_tangentlines(compute_flag, direction, &num_v_lines,
                        &TANL[num_u_lines]) ; /* get surface boundaries */
    if (!(sts & 1))
    {
        #ifdef DEBUG
        printf("\nplace() : error in compute_tangentlines()\n\n") ;
        #endif
        return 0 ;
    }

    if( num_u_lines || num_v_lines )
    {
        sts = ci$send(msg = message ci_macro.set_all_extern_feet
                                (&msg, MAX_FEET, &TANL[0], &MOD_ENV),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum) ;
        as$status(sts = sts) ;
        if (!(sts & msg & 1))
        {
            printf("Error with ci_macro.set_all_extern_feet() in place() method\n") ;
            return 0 ;
        }
    }
    else
    {
        #ifdef DEBUG
        printf("\ncompute() : There are NO tangents lines\n") ;
        #endif
        return 0 ;
    }

    return(1);
} /* compute() */
