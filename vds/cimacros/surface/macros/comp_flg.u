/* $Id: comp_flg.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / comp_flg.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: comp_flg.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

#include	<stdio.h>
#include	"cieveryone.h"
#include	"growner.h"
#include	"cimacros.h"
#include	"ci_mac_def.h"
#include	"nddef.h"
#include	"macro.h"
#include	"bserr.h"
#include	"EMSdpb.h"
#include	"igrdp.h"
#include	"bsparameters.h"
#include	"grerr.h"
#include	"madef.h"
#include	"maerr.h"
#include	"msdef.h"
#include	"EMSssprops.h"
#include	"asbox.h"
#include	"asmacros.h"
#include	"emsmapdef.h"
#include	"emsimpdef.h"

#define 	MAX_TEMP	34
#define 	MAX_FEET	7
#define		EDGE_S		"start_crv"
#define		EDGE_E		"end_crv"
#define		EDGE_L		"left_crv"
#define		EDGE_C		"center_crv"
#define		EDGE_R		"right_crv"
#define		SURF_R		"res_surf"
#define		USER_A		"usr_attr"
#define		SUPPORT		"support_flg"
#define		EXT_PLANE	"extend_plane"
#define		RES_SURF	"ressur"

struct		GRid		CI_MACRO_ID;
struct		GRmd_env	MOD_ENV;
struct		GRid		GRidFram[4];
struct		GRid		GRidList[MAX_FEET];
		IGRlong		msg;
		IGRlong		stat;

extern				ASmake_source();
extern				BScrossp(), BSmkvec();
extern		IGRboolean	BSxtractpar();
extern  	IGRdouble	BSdistptpt(), BSdotp();
extern 		IGRint		GRabsg_del_by_objid();
extern				EFmsgReport();

extern		IGRint		generate_occ_name();
extern		IGRlong		BuildExtFourEdges(), RetrieveFlangeSupport();
extern		IGRlong		BuildSkinSrf(), BuildImpBndSrf();
extern		IGRlong		ConstructLine(), EvalPlateDir(), FreeIGRplane();
extern		void		OrderCrv();

/* ========================================================================= */
/* the main function is the one implementing the definition creation	     */
/* ========================================================================= */

main ()
{

	#define MACRO_NAME    	"comp_flg"
	#define MAX_CHA_TEMP	10

	extern			ASsuper_construct();


	IGRchar			*temp_names[MAX_TEMP], *feet_names[MAX_FEET];
	IGRint			temp_types[MAX_TEMP];
	IGRint			i, j;
	IGRchar			buff[MAX_TEMP*MAX_CHA_TEMP];
	GRobj 	 		ci_mac_def1;


  	temp_names[0] ="orient";
  	temp_types[0] = parameter_generic | double_type;

  	for (i=1; i<MAX_TEMP; i=i+1) {
		j = i * MAX_CHA_TEMP;
		sprintf(&buff[j],"flange%d",(i-1));
		temp_names[i] = &buff[j];
		temp_types[i] = macro_generic | other_generic;	
  	}

	feet_names[0] = EDGE_S;
	feet_names[1] = EDGE_E;
	feet_names[2] = EDGE_L;
	feet_names[3] = EDGE_C;
	feet_names[4] = EDGE_R;
	feet_names[5] = SURF_R;
	feet_names[6] = USER_A;
	

  	ci_mac_def1 = NULL_OBJID;

  	ac$cimacdef( 	cimacdef          = ci_mac_def1,
			status 	          = &stat,
			prop 		  = ACvariable_template, 	
			name              = MACRO_NAME,
              		temp_num          = MAX_TEMP,
			temp_names        = temp_names,
			temp_types        = temp_types,
	      		extern_feet_num   = MAX_FEET,
	 		extern_feet_names = feet_names );
}

/* ========================================================================= */

place ()
{
        IGRchar                 occ_name[256];
        IGRchar                 box_name[20];
	struct	GRsymbology	symbology;

	/* Compute the ci macro geometric feet */
  	construct_comp();

        /* Create the ci macro rg_collection foot */
        box_name[0] = '\0';
        GRidList[6].objid = NULL_OBJID;
        GRidList[6].osnum = MOD_ENV.md_id.osnum;
        stat = ci$send ( msg      = message ACrg_collect.ACcreate ( &msg,
                                                                    box_name ),
                         targetid = GRidList[6].objid,
                         targetos = GRidList[6].osnum );
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"ACrg_collect.ACcreate : sts");
                EFmsgReport(0,msg, "ACrg_collect.ACcreate : msg");
                return (0);
        }
	
  	if( GRidList[0].objid == NULL_OBJID ) return(0);

	symbology.display_attr.color            = cnst_list.color;
        symbology.display_attr.weight           = cnst_list.weight;
        symbology.display_attr.style            = cnst_list.style;
        symbology.level                         = cnst_list.level;

	stat = ci$send ( msg      = message GRvg.GRputsymb ( &msg, &symbology),
           		 targetid = GRidList[0].objid,
           		 targetos = GRidList[0].osnum);
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"GRvg.GRputsymb : sts");
                EFmsgReport(0,msg, "GRvg.GRputsymb : msg");
                return (0);
        }

	stat = ci$send ( msg      = message GRvg.GRputsymb ( &msg, &symbology),
           		 targetid = GRidList[1].objid,
           		 targetos = GRidList[1].osnum);
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"GRvg.GRputsymb : sts");
                EFmsgReport(0,msg, "GRvg.GRputsymb : msg");
                return (0);
        }

	stat = ci$send ( msg      = message GRvg.GRputsymb ( &msg, &symbology),
           		 targetid = GRidList[5].objid,
           		 targetos = GRidList[5].osnum);
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"GRvg.GRputsymb : sts");
                EFmsgReport(0,msg, "GRvg.GRputsymb : msg");
                return (0);
        }

	/* Set all the ci macro feet */
  	stat = ci$send ( msg      = message  ci_macro.set_all_extern_feet (
					&msg,
					(IGRint)MAX_FEET,
					GRidList,
					&MOD_ENV ),
	   	  	 targetid = CI_MACRO_ID.objid,
	   	  	 targetos = CI_MACRO_ID.osnum );
        if (!(stat&1&msg)) {
                EFmsgReport(0, stat, "ci_macro.set_all_extern_feet : sts");
                EFmsgReport(0, msg,  "ci_macro.set_all_extern_feet : msg");
        }

	/* Name the macro occurence */
	stat = generate_occ_name ( MACRO_NAME, CI_MACRO_ID, &MOD_ENV, &msg);
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"generate_occ_name() : sts");
                EFmsgReport(0,msg, "generate_occ_name() : msg");
        }

  	return(1);
}

/* ========================================================================= */

compute ()
{
        struct  GRid    	rg;
		IGRmatrix	GOmat;
		IGRshort	GOtyp;

        /* Save ID of the rg_collection foot */
        rg.objid = NULL_OBJID;
        rg.osnum = MOD_ENV.md_id.osnum;
        stat = ci$send ( msg      = message NDmacro.ACreturn_foot ( &msg,
                                                                    USER_A,
                                                                    &rg,
                                                                    &GOtyp,
                                                                    GOmat ),
                         targetid = CI_MACRO_ID.objid,
                         targetos = CI_MACRO_ID.osnum );
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"NDmacro.ACreturn_foot : sts");
                EFmsgReport(0,msg, "NDmacro.ACreturn_foot : msg");
        }

        /* Disconnect rg_collection foot from ci macro (RIGID CONNECTION !!!) */
        stat = ci$send ( msg      = message GRconnector.GRdisconn
                                        ( &msg, &CI_MACRO_ID),
                         targetid = rg.objid,
                         targetos = rg.osnum );
        if (!(stat&1&msg)) {
                EFmsgReport(0,stat,"GRconnector.GRdisconn : sts");
                EFmsgReport(0,msg, "GRconnector.GRdisconn : msg");
        }

        /* Compute the ci macro geometric feet */
        construct_comp();

        if( GRidList[0].objid == NULL_OBJID ) return(0);

        /* Set all the ci macro feet */
        GRidList[6] = rg;
  	stat = ci$send ( msg      = message  ci_macro.set_all_extern_feet (
					&msg,
					(IGRint)MAX_FEET,
					GRidList,
					&MOD_ENV ),
	   		 targetid = CI_MACRO_ID.objid,
	   		 targetos = CI_MACRO_ID.osnum );
	if (!(stat&1&msg)) {
		EFmsgReport(0, stat, "ci_macro.set_all_extern_feet : sts");
		EFmsgReport(0, msg,  "ci_macro.set_all_extern_feet : msg");
	}

  	return(1);
}

/* ========================================================================= */
construct_comp()
{

	struct		GRvg_construct	cst;
	struct		IGRdisplay	dis;
			IGRint		NumPar, NumFlg, NumEdg;
	struct		ret_struct	expr;
			IGRint		i, j, jP1, iM1;
	struct		GRid		ASFLG[MAX_TEMP], ASEDGE;
	struct		GRobj_env       *Edges, *Center;
			IGRint		NewNumEdg;
	struct		GRobj_env	NewEdges[4];
			IGRdouble	bid[6];
	struct		IGRplane        RefDir;
			IGRdouble	CurveOrig[12];
			IGRint		feet_num;
	struct		myfeet		*MyFeet;
	struct		GRid		MacDef;
	struct		GRid		*ExtPlane;
			IGRboolean	Skinning;
			IGRdouble	orient_flag;
			IGRchar		Class[81];

        struct          GRobj_env       OrdEdges[4];
        		IGRshort	inv[4];
        		IGRboolean	adj, clo;
			IGRshort	verif;
        		IGRdouble	BaseTol, ChtTol, DistTol;
			IGRpoint	pt1, pt2;

	extern 		IGRint 		init_cnst_list();


        BSxtractpar ( &msg, BSTOLBASIS, &BaseTol);
        BSxtractpar ( &msg, BSTOLCHRDHT, &ChtTol);
	DistTol = 5 * ChtTol;

        #ifdef DEBUG
        printf("BaseTol=%f\tChtTol=%f\tDistTol=%f\n", BaseTol, ChtTol, DistTol);
        #endif


  	GRidList[0].objid = NULL_OBJID;
  	Edges             = NULL;
  	Center            = NULL;
	MyFeet		  = NULL;
	ExtPlane	  = NULL;

	RefDir.point  = &bid[0];
	RefDir.normal = &bid[3];

  	/*--- retrieve the number of flanges ---*/
  	stat = ci$send ( msg      = message NDnode.NDget_objects (
					ND_ROOT,
					NULL,
					0,
					NULL,
					0,
					OM_K_MAXINT,
					&NumPar ),
	   	  	 targetid = CI_MACRO_ID.objid,
	   	  	 targetos = CI_MACRO_ID.osnum);
	if (!(stat&1)) {
		EFmsgReport(0, stat, "NDnode.NDget_objects : sts");
		return;
	}

	NumFlg = NumPar - 1;
  	NumEdg = 4 * NumFlg;




  	/*--- retrieve the orientation flag --- */
  	stat = ci$send ( msg      = message  ACcpx.ACfind_exp_temp_struct (
					&msg,
					0,
					(IGRchar *)&expr,
					MOD_ENV ),
           	 	 targetid = CI_MACRO_ID.objid,
           	 	 targetos = CI_MACRO_ID.osnum );
        if (!(stat&1&msg)) {
                EFmsgReport (0,stat, "ACcpx.ACfind_exp_temp_struct : sts");
                EFmsgReport (0,msg,  "ACcpx.ACfind_exp_temp_struct : msg");
		printf(" bad expression for orientation \n");
		return;
        }
	else {
		orient_flag =  expr.var.root_pm_st.value;
		if (orient_flag != 1.0) orient_flag = -1.0;
	}


  	/* --- malloc the GRobj_env struct for the NumPar * 4 edges ---*/

  	Edges = (struct GRobj_env *) 
	  		om$malloc(size = NumEdg * sizeof(struct GRobj_env));
  	if (Edges == NULL) {
		printf("Error not enough memory to alloc Edges\n");
		return;
  	} 


  	/* --- malloc the GRobj_env struct for the NumPar center lines ---*/

  	Center = (struct GRobj_env *) 
	  		om$malloc(size = NumPar * sizeof(struct GRobj_env));
  	if (Center == NULL) {
		printf("Error not enough memory to alloc Center\n");
		return;
  	} 


  	/* --- malloc the GRid struct for the NumPar extend planes ---*/

  	ExtPlane = (struct GRid *) 
	  		om$malloc(size = NumFlg * sizeof(struct GRid));
  	if (ExtPlane == NULL) {
		printf("Error not enough memory to alloc ExtPlane\n");
		return;
  	} 


  	/*--- retrieve all the 4 edges for each flange ---*/

  	jP1 = 0;

  	for (i=1;i<NumPar;i=i+1) {
	
		/* Find basis flanges (templates of macro to be) */
		stat = ci$send ( msg      = message  ACcpx.ACfind_exp_temp_obj (
						&msg,
						i,
						&ASFLG[i-1] ),
 	      			 targetid = CI_MACRO_ID.objid,
	      			 targetos = CI_MACRO_ID.osnum );

        	if (!(stat&1&msg)) {
                	EFmsgReport(0, stat, "ACcpx.ACfind_exp_temp_obj : sts");
                	EFmsgReport(0, msg,  "ACcpx.ACfind_exp_temp_obj : msg");
			printf("ACfind_exp_temp_obj error retrieve ASFLG[%d]\n",
				(i-1) );
			return;
        	}
	
		/* Find macro definition */
		stat = ci$send ( msg      = message ACcpx.find_macro (&MacDef),
 	      			 targetid = ASFLG[i-1].objid,
	      			 targetos = ASFLG[i-1].osnum );

        	if (!(stat&1)) {
                	EFmsgReport(0, stat, "ACcpx.find_macro : sts");
			printf("ACcpx.find_macro error retrieve ASFLG[%d]\n",
				(i-1) );
			return;
		}

		/* Retrieve support surface or plane */
		stat = RetrieveFlangeSupport ( ASFLG[i-1],
					       &ExtPlane[i-1],
					       SUPPORT,
					       EXT_PLANE,
					       RES_SURF,
					       &msg );
     		if( !(stat&1&msg) ) {
                	EFmsgReport(0, stat, "RetrieveFlangeSupport() : sts");
                	EFmsgReport(0, msg,  "RetrieveFlangeSupport() : msg");
		}

		/* --- For each ASFLG retrieve the for edge feet --- */
		stat = ci$send ( msg      = message ACcpx_defn.ACgive_feet_desc(
						&feet_num,
						&MyFeet ),
 	      			 targetid = MacDef.objid,
	      			 targetos = MacDef.osnum );

     		if( !(stat&1) ) {
                	EFmsgReport(0, stat, "ACcpx.ACgive_feet_desc : sts");
			printf("ACcpx_defn.ACgive_feet_desc error ASFLG[%d]\n",
				(i-1) );
			return;
		}

		#ifdef DEBUG
		printf("--->Template num = %d, feet_num = %d\n",i,feet_num);
		#endif

                /* Verification : all feet names must be here or exit */
                verif = 0;
                for (j=0;j<feet_num;j=j+1) {
                if      (!strcmp( MyFeet[j].name, EDGE_S)) verif=verif+1;
                else if (!strcmp( MyFeet[j].name, EDGE_E)) verif=verif+1;
                else if (!strcmp( MyFeet[j].name, EDGE_L)) verif=verif+1;
                else if (!strcmp( MyFeet[j].name, EDGE_C)) verif=verif+1;
                else if (!strcmp( MyFeet[j].name, EDGE_R)) verif=verif+1;
		#ifdef TRACE
                printf ("MyFeet[%d].name : <%s>\tverif=%d\n",
                        j, MyFeet[j].name, verif);
		#endif
                }
                if (verif != 5) {
                        printf ("Some feet names lacks in located macro\n");
                        exit;
                }

		for (j=0;j<feet_num;j=j+1) {

			if ( (strcmp( MyFeet[j].name, EDGE_S) )
			&&   (strcmp( MyFeet[j].name, EDGE_E) )
			&&   (strcmp( MyFeet[j].name, EDGE_L) )
			&&   (strcmp( MyFeet[j].name, EDGE_C) )
			&&   (strcmp( MyFeet[j].name, EDGE_R) ) ) {

				#ifdef DEBUG
			printf( "Feet names : <%s>\t<%s>\t<%s>\t<%s>\t<%s>\n",
				EDGE_S, EDGE_E, EDGE_L, EDGE_C, EDGE_R);
				printf( "Myfeet[%d].name : <%s> discarded\n",
					j, MyFeet[j].name);
				#endif
			}

			else {
				#ifdef DEBUG
				printf( "Myfeet[%d].name : <%s> processed\n",
					j, MyFeet[j].name);
				#endif

				if ( strcmp( MyFeet[j].name, EDGE_C) ) {
     				stat = ci$send (
				msg      = message NDmacro.ACreturn_foot (
				&msg,
				MyFeet[j].name,
				&Edges[jP1].obj_id,
				&Edges[jP1].mod_env.md_env.matrix_type,
				Edges[jP1].mod_env.md_env.matrix ),
	      			targetid = ASFLG[i-1].objid,
	      			targetos = ASFLG[i-1].osnum );
				}
				else {
     				stat = ci$send (
				msg      = message NDmacro.ACreturn_foot (
				&msg,
				MyFeet[j].name,
				&(Center[i-1].obj_id),
				&(Center[i-1].mod_env.md_env.matrix_type),
				Center[i-1].mod_env.md_env.matrix ),
	      			targetid = ASFLG[i-1].objid,
	      			targetos = ASFLG[i-1].osnum );
				}

        			if (!(stat&1&msg)) {
EFmsgReport(0, stat, "NDmacro.ACreturn_foot : sts");
EFmsgReport(0, msg,  "NDmacro.ACreturn_foot : msg");
printf("NDmacro.ACreturn_foot edge <%d>\tof flanges <%d>, stat=%d, msg=%d\n",
       j, i-1, stat, msg);
return;
     				}

				if (strcmp( MyFeet[j].name, EDGE_C) ) {
     				ci$send( msg      = message NDnode.ASreturn_go(	
					 &(Edges[jP1].obj_id), 
					 &Edges[jP1].mod_env.md_env.matrix_type,
					 Edges[jP1].mod_env.md_env.matrix ),
	      			 	 targetid = Edges[jP1].obj_id.objid,
	      			 	 targetos = Edges[jP1].obj_id.osnum );

				jP1 = jP1 + 1;
				}
				else {
     				ci$send( msg      = message NDnode.ASreturn_go (
				&(Center[i-1].obj_id), 
				&Center[i-1].mod_env.md_env.matrix_type,
				Center[i-1].mod_env.md_env.matrix ),
	      			 	 targetid = Center[i-1].obj_id.objid,
	      			 	 targetos = Center[i-1].obj_id.osnum );
				}
        			if (!(stat&1&msg)) {
EFmsgReport(0, stat, "NDnode.ACreturn_go : sts");
EFmsgReport(0, msg,  "NDnode.ACreturn_go : msg");
				}

			} /* end of test on feet names */
		} /* end of loop on feet */
  	} /* end of loop on edges */


	/* **************************************************************** */
	/* Check if the basis flanges are built with same reference surface */
	/* Skinning flag : TRUE		--> EMS skinning surface	    */
	/*		   FALSE	--> EMS impose boudary surface	    */
	/* **************************************************************** */
	Skinning = FALSE;
  	for (i=1;i<NumFlg;i=i+1) {
		if (  (ExtPlane[i].objid != ExtPlane[0].objid)
		   || (ExtPlane[i].osnum != ExtPlane[0].osnum) ) {
			Skinning = TRUE;
			break;
		}
	}
	
	#ifdef DEBUG
	for (i=0;i<NumFlg;i=i+1)
		printf( "ExtPlane[%d] = (%d|%d)\n",
			i, ExtPlane[i].objid, ExtPlane[i].osnum);
	printf( "Skinning = %d\n", Skinning);
	#endif


  	/* --- set up here the cst because will use it in BuildExtFourEdges - */

   	init_cnst_list();
   	get_symb();
	ci$get_module_info(md_env = &MOD_ENV);

   	dis.color	= cnst_list.color;
   	dis.weight	= cnst_list.weight;
   	dis.style	= cnst_list.style;

   	cst.msg		= &msg;
   	cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
   	cst.display	= &dis;
   	cst.env_info	= &MOD_ENV;
   	cst.newflag	= FALSE;
   	cst.level	= cnst_list.level;
   	cst.class_attr	= NULL;
   	cst.name	= NULL;
  

  	/* --- Build the New 4 sided Edges --- */
	for (i=0;i<4*NumFlg;i=i+1) {
		Edges[i].mod_env = MOD_ENV;
		#ifdef DEBUG
		printf( "Edge %d is (%d|%d) in (%d|%d)\n",
			i, Edges[i].obj_id.objid, Edges[i].obj_id.osnum,
			Edges[i].mod_env.md_id.objid,
			Edges[i].mod_env.md_id.osnum);
		#endif
	}
  	stat = BuildExtFourEdges ( Edges, NumFlg, &cst, DistTol, BaseTol,
			           NewEdges, &NewNumEdg, CurveOrig, &msg);
	if (!(stat&1&msg)) {
                EFmsgReport(0, stat, "BuildExtFourEdges() : sts");
                EFmsgReport(0, msg,  "BuildExtFourEdges() : msg");
		goto quit;
        }

	#ifdef DEBUG
	for (i=0;i<NewNumEdg;i=i+1) {
		printf( "New Edge %d is (%d|%d) in (%d|%d)\n",
			i, NewEdges[i].obj_id.objid, NewEdges[i].obj_id.osnum,
			NewEdges[i].mod_env.md_id.objid,
			NewEdges[i].mod_env.md_id.osnum);
	}
	#endif

        for (i=0;i<NewNumEdg;i=i+1) {
                GRidFram[i] = NewEdges[i].obj_id;
        #ifdef DEBUG
                printf( "\tNewEdge[%d] = (%d/%d)\n",
                        i, GRidFram[i].objid, GRidFram[i].osnum);
        #endif
        }

        /* --- Order the 4 Edges --- */
        OrderCrv ( NewEdges, NewNumEdg, DistTol, BaseTol,
                   OrdEdges, inv, &adj, &clo, &msg);
        if (msg == BSFAIL) { printf("OrderCrv() fails\n"); goto quit; }

        #ifdef JLL
        printf ("OrderCrv() returns adj=%d, clo=%d, msg=%d\n",
                adj, clo, msg);
        for (i=0;i<NewNumEdg;i=i+1) {
                printf ("NewEdge=(%d/%d)\tOrdEdge=(%d/%d)\tinv=%d\n",
                NewEdges[i].obj_id.objid, NewEdges[i].obj_id.osnum,
                OrdEdges[i].obj_id.objid, OrdEdges[i].obj_id.osnum,
                inv[i] );
		ci$send ( msg      = message GRcurve.GRendpts (
                                        &msg,
                                        &cst.env_info->md_env.matrix_type,
                                        cst.env_info->md_env.matrix,
                                        pt1,
                                        pt2 ),
                          targetid = NewEdges[i].obj_id.objid,
                          targetos = NewEdges[i].obj_id.osnum );
		printf ("New: (%f,%f,%f) --> (%f,%f,%f)\n",
			pt1[0], pt1[1], pt1[2], pt2[0], pt2[1], pt2[2]);
		ci$send ( msg      = message GRcurve.GRendpts (
                                        &msg,
                                        &cst.env_info->md_env.matrix_type,
                                        cst.env_info->md_env.matrix,
                                        pt1,
                                        pt2 ),
                          targetid = OrdEdges[i].obj_id.objid,
                          targetos = OrdEdges[i].obj_id.osnum );
		printf ("Ord: (%f,%f,%f) --> (%f,%f,%f)\n",
			pt1[0], pt1[1], pt1[2], pt2[0], pt2[1], pt2[2]);
        }
        #endif

 
  	/* --- Define the side direction of the surface wich will build to
	 	place automatically the plate on the right side --- */
  	stat = EvalPlateDir ( ASFLG, NumFlg, orient_flag, &RefDir, &msg); 
	if (!(stat&1&msg)) {
                EFmsgReport(0, stat, "EvalPlateDir() : sts");
                EFmsgReport(0, msg,  "EvalPlateDir() : msg");
		goto quit;
        }
   

	if (Skinning == TRUE) {
  		/* --- Build from the new Edges an encompassing plane or 
	 		a skinning surface  				--- */
        	stat = BuildSkinSrf ( RefDir, OrdEdges, NewNumEdg,
				      inv, adj, clo, &cst,
                         	      &GRidList[5], &msg );
		if (!(stat&1&msg)) {
                	EFmsgReport(0, stat, "BuildSkinSrf() : sts");
                	EFmsgReport(0, msg,  "BuildSkinSrf() : msg");
			goto quit;
        	}
	}
	else {
  		/* --- Build from new Edges an impose boundaries surface --- */
		stat = BuildImpBndSrf ( ExtPlane[0], &GRidList[5],
					OrdEdges, NewNumEdg, RefDir,
				        inv, adj, clo, &cst,
					MOD_ENV, &msg );
		if (!(stat&1&msg)) {
                	EFmsgReport(0, stat, "BuildImpBndSrf() : sts");
                	EFmsgReport(0, msg,  "BuildImpBndSrf() : msg");
			goto quit;
        	}
	}

	/* --- Build the center line --- */
	ConstructLine ( NumFlg, Center, &cst, &GRidList[3], DistTol, BaseTol);


	/* Complete GRid list */
	GRidList[0] = GRidFram[2];
	GRidList[1] = GRidFram[3];
	GRidList[2] = GRidFram[0];
	GRidList[4] = GRidFram[1];

quit:
 	if (Edges    != NULL) om$dealloc (ptr = Edges); 
 	if (Center   != NULL) om$dealloc (ptr = Center); 
 	if (ExtPlane != NULL) om$dealloc (ptr = ExtPlane); 
}
/*============================================================================*/
