/* $Id: srf_pro.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / srf_pro.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: srf_pro.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/02/01  14:08:52  pinnacle
# ah
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *      02/01/98        ah              Moved AS_status.h down
 * -------------------------------------------------------------------*/

/*
	File name : 	srf_pro.u
	Product :	I/VDS - surface
	Description :	Place associative surface of projection
	Product :	I/VDS 2.1 - PPM macro library
	History :

	92/02/18 jll Update
	92/05/12 alc Use curve object instead of curve geometry in
			EMSproject.EMplace_surface_of_projection() call.
	92/12/15 alc Set pos_orient to TRUE (to be consistent with EMS 2.1)
 */
	
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "msdef.h"
#include "EMSmsgdef.h"
#include "nddef.h"
#include "macro.h"
#include "AS_status.h"

#define		EPSILON		1.0E-7


IGRchar 		*temp_names[5], *feet_names[1];
IGRint			temp_types[5], num_temp;

GRobj 			ci_mac_def1;
struct GRid		CI_MACRO_ID;


IGRlong			EMSrtmsg;

IGRshort	 	matrix_type;

IGRint			i, j, k;
IGRlong			stat, msg;

IGRboolean		pos_orient_flag;
 
IGRdouble 	 	vec[3], lvec, trans_mat[16], matrix[16], t_plan[6];

struct IGRplane		plane;
struct GRid		CUV, GCV, SPRO;
struct GRmd_env		MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct GRprops          props;
struct IGRbsp_curve     *bsp_curve;
struct ret_struct	temp1_rts, temp2_rts, st_len, sw_len;

extern			printf() ;
extern double		fabs()   ;
extern IGRdouble	BSdotp() ;
extern IGRint 		init_cnst_list(),
			MAtypemx();
extern ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */
init()
{
  feet_names[0] = "ressur";
}

main ()
{

  temp_names[0]  = "stlen";  
  temp_names[1]  = "swlen";  
  temp_names[2]  = "pnt1";  
  temp_names[3]  = "pnt2";  
  temp_names[4]  = "crv0";

  temp_types[0]   = parameter_generic | double_type;
  temp_types[1]   = parameter_generic | double_type;
  temp_types[2]   = point_generic;
  temp_types[3]   = point_generic | curve_generic | conic_generic |line_generic;
  temp_types[4]   = curve_generic | conic_generic | line_generic;

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat, 	
		name              = "srf_pro",
              	temp_num          = 5, 		
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );

}

/* ========================================================================= */

place ()
{
  construct_pjs();
  if( SPRO.objid == NULL_OBJID ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1,&SPRO, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}

/* ========================================================================= */

compute ()
{
  construct_pjs();
  if( SPRO.objid == NULL_OBJID ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1,&SPRO, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}

/* ========================================================================= */

construct_pjs()
{
  IGRint 		i ;
  OM_S_OBJID		tmp_objid ; /* temporary constructed surface objid */
  struct GRmd_env	curve_module_info ; /* 92/05/12 */

  SPRO.objid = NULL_OBJID;
  SPRO.osnum = MOD_ENV.md_id.osnum;

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&num_temp),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);
  if(!(stat&1)) return;



/*----------------------------------------------------------------------*/
/*-------------        retrieve the start length       -----------------*/
/*----------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct(
			                &stat,0,(char *)&st_len,&MOD_ENV ),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) ){
	write(" bad expression for start length " );
	return;
  }

/*----------------------------------------------------------------------*/
/*-------------        retrieve the sweep length       -----------------*/
/*----------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct(
			                &stat,1,(char *)&sw_len,&MOD_ENV ),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) ){
	write(" bad expression for sweep length " );
	return;
  }
  if( fabs(sw_len.var.root_pm_st.value) < EPSILON ) return;

/*----------------------------------------------------------------------*/
/*-------------        get the profile to sweep        -----------------*/
/*----------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
					&stat,(num_temp-1),&CUV),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  
  if( !(stat&msg&1) ) return;
  msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						"",
						&GCV, 
						&matrix_type, 
						matrix ),
	   targetid = CUV.objid,
	   targetos = CUV.osnum );

  if( !(stat&msg&1) ){
	write(" bad curve \n" );
	return 0 ;
  	}

  /*
	Get curve module info (92/05/12)
   */

  curve_module_info.md_id.osnum = GCV.osnum ;
  curve_module_info.md_env.matrix_type = matrix_type ;
  for (i = 0 ; i < 16 ; i = i+1) 
	curve_module_info.md_env.matrix[i] = matrix[i] ;


  #ifdef DEBUG
	write("profil = ",GCV.objid,GCV.osnum,"\n");
  #endif

  ci$send( msg = message GRvg.GRgeomprops( &msg,
			       		   &matrix_type,
			       		   matrix,
			       		   &props ),
           targetid = GCV.objid,
 	   targetos = GCV.osnum );

/*----------------------------------------------------------------------*/
/*-------------        get the first axis point        -----------------*/
/*----------------------------------------------------------------------*/

   msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( 
							 &stat,
							 2,
							 (char *) &temp1_rts,
						    	 &MOD_ENV  ),
	    targetid = CI_MACRO_ID.objid,
	    targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) ){
	write(" bad axis point 1 " );
	return;
  }

  
  if( num_temp == 4 ){

	#ifdef DEBUG
	write(" case with 4 templates\n");
	#endif

  	plane.point = &t_plan[0];
  	plane.normal = &t_plan[3];

  	ci$send( msg = message  GRvg.GRdetplane( &EMSrtmsg,
			       		         &matrix_type,
			       		         matrix,
                                                 &plane),

		 targetid = GCV.objid,
		 targetos = GCV.osnum );

	if(  EMSrtmsg != MSSUCC  ){
		 write("GRvg.GRdetplane failed\n");
		 return;
	}
	
	temp2_rts = temp1_rts;

        for( j=0;j<3;j=j+1 ){ 
		temp1_rts.var.point_st.pt[j] = plane.point[j];
		vec[j] = temp2_rts.var.point_st.pt[j] - 
			 temp1_rts.var.point_st.pt[j];
	}

	lvec = BSdotp(&msg,vec,&plane.normal[0]);
    	for( j=0;j<3;j=j+1 ) 
		temp2_rts.var.point_st.pt[j] = plane.point[j] + 
					       lvec * plane.normal[j];

  }
  else{

/*----------------------------------------------------------------------*/
/*-------------        get the second axis point       -----------------*/
/*----------------------------------------------------------------------*/

	ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( 
							 &stat,
							 3,
							 (char *) &temp2_rts,
						    	 &MOD_ENV  ),
	    	 targetid = CI_MACRO_ID.objid,
	    	 targetos = CI_MACRO_ID.osnum );
  	if( stat != 1 ){
		write(" bad axis point 2 " );
		return;
  	}
  }

/*----------------------------------------------------------------------*/
/*--------         check if the vector of projection is not null   -----*/
/*----------------------------------------------------------------------*/

  for(j=0; j<3; j=j+1)
    vec[j] = temp2_rts.var.point_st.pt[j] - temp1_rts.var.point_st.pt[j];
  
  lvec = v_len(vec);
  #ifdef DEBUG
	write("dist p1 p2 =",lvec,"\n");
  #endif
  
  if( lvec < EPSILON ) return;

/*----------------------------------------------------------------------*/
/*--------          set up the construction list               --- -----*/
/*----------------------------------------------------------------------*/


   init_cnst_list();
   get_symb();

   dis.color		= cnst_list.color;
   dis.weight		= cnst_list.weight;
   dis.style		= cnst_list.style;

   cst.msg		= &msg;
   cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
   cst.display		= &dis;
   cst.env_info		= &MOD_ENV;
   cst.newflag		= 0;
   cst.level		= cnst_list.level;
   cst.geometry		= NULL;
   cst.class_attr	= 0;
   cst.name		= 0;

   CUV.objid = NULL_OBJID;

   pos_orient_flag = TRUE ; /* 92/12/15 (normal oriented to the interior) */


  ci$send( msg = message GRvg.GRgenabsg( &stat,
			                 &matrix_type, 
				         matrix, 
					 &bsp_curve ),
           targetid = GCV.objid,
 	   targetos = GCV.osnum );

/*---------------------------------------------------------------------------*/
/*- depending of start length and sweep length evaluate the vector of proj --*/
/*---------------------------------------------------------------------------*/

   if( ( fabs(st_len.var.root_pm_st.value) > EPSILON ) ||
       ( fabs((1.0 - sw_len.var.root_pm_st.value)) > EPSILON ) ) {



     	for(j=0; j<3; j=j+1){
 	   vec[j] = vec[j] / lvec;
      	   temp1_rts.var.point_st.pt[j] = temp1_rts.var.point_st.pt[j] + 
					  st_len.var.root_pm_st.value * vec[j];
      	   temp2_rts.var.point_st.pt[j] = temp1_rts.var.point_st.pt[j] +
					  sw_len.var.root_pm_st.value * vec[j];
      	   vec[j] = st_len.var.root_pm_st.value * vec[j];
        }


#if 0
	/* 92/05/12 */
   	stat = ci$send( msg = message EMSproject.EMplace_surface_of_projection(
						&cst,
						(struct GRid *)NULL,
						&MOD_ENV,
						bsp_curve,
						props.type,
						temp1_rts.var.point_st.pt,
						temp2_rts.var.point_st.pt,
						pos_orient_flag,
						&GCV.objid),
	    	targetid = SPRO.objid,
            	targetos = SPRO.osnum); 
#endif

/*
	message EMplace_surface_of_projection(struct GRvg_construct *construct;
                                      struct GRid *curve_id;
                                      struct GRmd_env *curve_module_info;
                                      struct IGRbsp_curve *curve_geom;
                                      unsigned IGRchar curve_type;
                                      IGRpoint point1, point2;
                                      IGRboolean pos_orient_flag;
                                      OM_S_OBJID *new_objid);
 */

	/* -> 92/05/12 */
   	stat = ci$send( msg = message EMSproject.EMplace_surface_of_projection(
						&cst,
						&GCV,
						&curve_module_info,
						NULL,
						0,
						temp1_rts.var.point_st.pt,
						temp2_rts.var.point_st.pt,
						pos_orient_flag,
						&tmp_objid),
	    	targetid = SPRO.objid,
            	targetos = SPRO.osnum) ; as$status(sts = stat) ; 

	GCV.objid = tmp_objid ;
 	GCV.osnum = MOD_ENV.md_id.osnum ; /* 92/02/21 */
	/* <- 92/05/12 */

	msg = *cst.msg ;
   	if ( !(stat & msg & 1) ){
		#ifdef DEBUG
		write("EMSproject.EMplace_surface_of_projection failed \n");
		#endif
		SPRO.objid = NULL_OBJID;
		return 0 ;
   	}

	SPRO = GCV;
	#ifdef DEBUG
		write("after EMSproject.EMplace_surface_of_projection\n");
		write("SPRO =",SPRO.objid,SPRO.osnum,", GCV =",
			       GCV.objid,GCV.osnum,"\n");
	#endif

  	for(i=0;i<16;i=i+1) trans_mat[i]=0.0;
  	trans_mat[0]  = 1.0;
  	trans_mat[5]  = 1.0;
  	trans_mat[10] = 1.0;
  	trans_mat[15] = 1.0;
   	trans_mat[3]  = vec[0];
   	trans_mat[7]  = vec[1];
   	trans_mat[11] = vec[2];

	MAtypemx(&msg,trans_mat,&matrix_type);
/*
  	CUV.osnum  = MOD_ENV.md_id.osnum;
	SPRO.objid = NULL_OBJID;
*/
	CUV = SPRO;

  	stat = ci$send(msg	= message GRgraphics.GRxform(
						&EMSrtmsg, 
						&MOD_ENV, 
						&matrix_type, 
						trans_mat,
						&SPRO.objid ),
		       targetid = CUV.objid,
	               targetos = CUV.osnum  );

  	if( !(stat&EMSrtmsg&1) ) {
		#ifdef DEBUG
			write(" GRgraphics.GRxform \n");
		#endif

     		SPRO.objid = NULL_OBJID;
     		ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV), 
             		targetid = CUV.objid,
	     		targetos = CUV.osnum );
  	}


   }/* end if we have to evaluate the vector of projection and do a GRxform */




   else{

#if 0
	/* 92/05/12 */
   	stat = ci$send( msg = message EMSproject.EMplace_surface_of_projection(
						&cst,
						(struct GRid *)NULL,
						&MOD_ENV,
						bsp_curve,
						props.type,
						temp1_rts.var.point_st.pt,
						temp2_rts.var.point_st.pt,
						pos_orient_flag,
						&CUV.objid),
	    		targetid = SPRO.objid,
            		targetos = SPRO.osnum); 

   	if ( !(stat&1) ){
		SPRO.objid = NULL_OBJID;
		return;
   	}
#endif

	/* -> 92/05/12 */
   	stat = ci$send( msg = message EMSproject.EMplace_surface_of_projection(
						&cst,
						&GCV,
						&curve_module_info,
						NULL,
						0,
						temp1_rts.var.point_st.pt,
						temp2_rts.var.point_st.pt,
						pos_orient_flag,
						&tmp_objid),
	    	targetid = SPRO.objid,
            	targetos = SPRO.osnum) ; as$status(sts = stat) ; 
	/* <- 92/05/12 */

	msg = *cst.msg ;
   	if ( !(stat & msg & 1) ){
		SPRO.objid = NULL_OBJID;
		return 0 ;
   		}

	SPRO.objid = tmp_objid ;

   }/* end of regular case */

}


