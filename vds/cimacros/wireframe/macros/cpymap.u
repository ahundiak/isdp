/* $Id: cpymap.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / cpymap.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: cpymap.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
/*
   History :
   -------
	91/12/10	Use from_env in NDcopy_to_root()
			(Macro occurrences in reference files)
	92/02/10	Use ex$get_modid() just after NDmacro.ACreturn_foot()
			(also : Macro occurrences in reference files )
	92/07/30	Get rid of NDcopy_to_root() (no longer needed in 2.0) 
 */

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "exmacros.h"

#define DEBUG 0
extern  int	printf()	;
extern		ASsuper_construct();
extern 		EX_get_modid_given_osnum() ;

#define  EPSILON       1.E-13
#define  MACRO_NAME    "cpymap"     /* Name of the macro                      */
#define  NB_TEMPLATE   6            /* Number of template of the macro        */
#define  NB_FEET       1            /* Number of feet of the macro            */

/* Definition of the names of the objects of the macro                        */

#define  SCALE      "scale"        /* scale factor                            */
#define  ST_CD_SYS  "start_cd_sys" /* Start Coordinate system                 */
#define  VW_CD_SYS  "view_cd_sys"  /* End  Coordinate system                  */
#define  SPINE_CRV  "spine_crv"    /* spine curve			      */
#define  ORG_REF    "pt_on_crv"     /* point on curve and ref origine          */
#define  OBJ_TO_MAP "obj_to_map"   /* Object to map                           */
#define  MAP_OBJ    "map_obj"      /* resultant object                        */

  char *template_name[NB_TEMPLATE];/* Names of the templates of the macro     */
  char *feet_name[NB_FEET];        /* Names of the feet of the macro          */
  int  temp_types[NB_TEMPLATE];    /* define template type                    */
  struct GRid temp_obj[NB_TEMPLATE];/* Template objects of the macro          */
  GRobj  macro_def_id;             /* Identifier of the macro definition      */
  GRobj  dummy;			   /* just a variable			      */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               main function                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

  int    stat;                   /* Returned status of the definition       */

main()
  {
  /*
  Description : Create the definition of the macro
  Constraint  : none
  */ 

  /* Declare the template names */

  template_name[0] = SCALE;
  template_name[1] = ST_CD_SYS;
  template_name[2] = VW_CD_SYS;
  template_name[3] = SPINE_CRV;
  template_name[4] = OBJ_TO_MAP;
  template_name[5] = ORG_REF;

  temp_types[0] = parameter_generic | double_type;
  temp_types[1] = ref_generic;
  temp_types[2] = ref_generic;
  temp_types[3] = curve_generic | conic_generic | line_generic;
  temp_types[4] = ~0;
  temp_types[5] = point_generic;

  /* Declare the feet names */

  feet_name[0] = MAP_OBJ;

  /* Construct the macro definition */

  macro_def_id = NULL_OBJID;

  ac$cimacdef(  cimacdef          = macro_def_id,
		status            = &stat,
		name              = MACRO_NAME,
		temp_num          = NB_TEMPLATE,
		temp_names        = template_name,
		temp_types	  = temp_types,
		extern_feet_num   = NB_FEET,
		extern_feet_names = feet_name  );

#if DEBUG
  printf( " cpymap exit main \n");
#endif

}/* end main */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                           cons_miror_obj function                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

  long   msg;                      /* Returned status of messages             */
  double length;                   /* Length of the hole                      */
  double diameter;                 /* Diameter of the hole                    */
  struct IGRdisplay display;       /* Attributes for the display              */
  struct GRvg_construct const;     /* Attributes for the construction         */
  struct GRid      CI_MACRO_ID;    /* Objid of the occurence of the macro     */
  struct GRid      referential;    /* Objid of the coordinate system          */
  struct GRid      original_obj;   /* Original object                         */
  struct GRid      map_obj;        /* Object obtained by miror                */
  struct GRmd_env  MOD_ENV;        /* Environment for construction            */
  struct GRmd_env  from_env;       /* Environment for construction            */
  double           *matrix;        /* Matrix of the graphic object            */
  double           tmp_matrix[16]; /* Tempory matrix                          */
  double           trans_matrix[16];/* Tempory matrix                         */
  double	   scale;           /* scale factor                            */
  short            mat_type;       /* Matrix type of the graphic object       */
  short            four;           /* Dimension of the matrix                 */
  struct GRid      newobjid;       /* Objid of the referential                */
  struct GRid      CUV;            /* Objid of                                */
  struct GRid      OFOOT;	   /* just variable		   	      */
  struct GRid	   spine_obj;      /* grid of spine			      */

  long			rc;
  int                   i, j;

  struct ret_struct	st_ref ,vw_ref ,expr, pt_on_crv;
  struct IGRbsp_curve   *bsp_curve;
  double                zvec[3], proj_pt[3], min_dist, eval[12], ref_mat[16];
  double		xvec[3], yvec[3], u_par;


extern int	BSmdstptcv(),
		BScveval(),
		BScrossp(),
		BSnorvec(),
		MAinvmx(),
		MAidmx(),
		MAmulmx(),
		MAtypemx();
cons_map_obj()
  {

    map_obj.objid = NULL_OBJID;


  /*------------------------------------------*/
  /* 1- Get the scale factor from expressions */
  /*------------------------------------------*/

   msg = ci$send( msg = message ACcpx.ACfind_temp_struct(&stat, SCALE,
						 (char *) &expr,&MOD_ENV),
	    targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   if( !(msg&stat&1) ) return;
   scale = expr.var.root_pm_st.value;

  /*-------------------------------------*/
  /* 2- Get the object to map  and scale */
  /*-------------------------------------*/

  msg = ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&stat,OBJ_TO_MAP,&CUV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
   if( !(msg&stat&1) ) return;

  msg =  ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						".",
						&original_obj, 
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix ),
	   targetid = CUV.objid,
	   targetos = CUV.osnum );

   if( !(msg&stat&1) ) return;

   from_env.md_id.osnum = original_obj.osnum ;
   ex$get_modid(mod_osnum = from_env.md_id.osnum,
	        mod_id    = &from_env.md_id.objid) ;

  

#if DEBUG
  printf( " cpymap original_obj[%d,%d]\n", 
	    original_obj.osnum,original_obj.objid ) ;
#endif

  /*---------------------------------------------*/
  /* 3- Get the matrix of the start referential  */
  /*---------------------------------------------*/


  msg = ci$send
    (msg      = message ACcpx.ACfind_temp_struct(&stat,ST_CD_SYS,
                                           (char *)&st_ref, &MOD_ENV ),  
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
  if( !(msg&stat&1) ) return;


  /*---------------------------------------------*/
  /* 4- Get the matrix of the view referential   */
  /*---------------------------------------------*/

  msg = ci$send
    (msg      = message ACcpx.ACfind_temp_struct(&stat,VW_CD_SYS,
                                         (char *)&vw_ref, &MOD_ENV ),  
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
  if( !(msg&stat&1) ) return;

  /*---------------------------------------------*/
  /* 5- Get the spine curve                      */
  /*---------------------------------------------*/

  msg = ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&stat,SPINE_CRV,&CUV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
  if( !(msg&stat&1) ) return;

   msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						".",
						&spine_obj, 
						&mat_type, 
					        trans_matrix ),
	   targetid = CUV.objid,
	   targetos = CUV.osnum );
  if( !(msg&stat&1) ) return;


  stat = ci$send( msg = message GRvg.GRgenabsg( &msg,
			                 &mat_type, 
				         trans_matrix, 
					 &bsp_curve ),
           targetid = spine_obj.objid,
 	   targetos = spine_obj.osnum );
  if( !(msg&stat&1) ) return;

#if DEBUG
write(" num_poles =",bsp_curve->num_poles,"\n");
#endif

  /*----------------------------------------------------------------*/
  /* 6- get xyz coordinates, point on curve                         */ 
  /*----------------------------------------------------------------*/

   msg = ci$send( msg = message  ACcpx.ACfind_temp_struct( &stat,
						     ORG_REF,
						     (char *)&pt_on_crv,
						     &MOD_ENV  ),
	    targetid = CI_MACRO_ID.objid,
	    targetos = CI_MACRO_ID.osnum );
#if DEBUG
write(" fin de saisie des objets \n");
#endif
  if( !(msg&stat&1) ) return;

   zvec[0] = vw_ref.var.ref_st.t[2];
   zvec[1] = vw_ref.var.ref_st.t[6];
   zvec[2] = vw_ref.var.ref_st.t[10];

#if DEBUG
write("zvec 1 ", zvec[0],zvec[1],zvec[2],"\n");
write("pt_on_crv ", pt_on_crv.var.point_st.pt[0],
                    pt_on_crv.var.point_st.pt[1],
                    pt_on_crv.var.point_st.pt[2],"\n");
#endif

   BSmdstptcv ( bsp_curve,
		pt_on_crv.var.point_st.pt, 
		&u_par,
		proj_pt,
		&min_dist,
		&rc );

  if( rc != 0 )
  {
#if DEBUG
write(" exit BSmdstptcv u_par rc = ",u_par,rc,"\n");
#endif
    return;
  }

  BScveval ( bsp_curve , u_par, 1, eval, &rc);
  BScrossp(&msg,&eval[3],zvec,xvec);

  if( msg != 0 )
  {
#if DEBUG
write("xvec 1 ", xvec[0],xvec[1],xvec[2],"\n");
#endif
    return;
  }

  BScrossp(&msg,xvec,&eval[3],yvec);
  if( msg != 0 )
  {
#if DEBUG
write("yvec 1 ", yvec[0],yvec[1],yvec[2],"\n");
#endif
    return;
  }


  BSnorvec(&msg,xvec);
  if( msg != 0 )
  {
#if DEBUG
write("xvec 2 ", xvec[0],xvec[1],xvec[2],"\n");
#endif
    return;
  }
  BSnorvec(&msg,yvec);
  if( msg != 0 )
  {
#if DEBUG
write("yvec 2 ", yvec[0],yvec[1],yvec[2],"\n");
#endif
    return;
  }
  BSnorvec(&msg,&eval[3]);
  if( msg != 0 )
  {
#if DEBUG
write("eval[3] ", eval[3],eval[4],eval[5],"\n");
#endif
    return;
  }

    MAidmx(&msg,ref_mat);
    j = 0;
    for(i=0;i<3;i=i+1)
    { 
	ref_mat[j]   = xvec[i]; 
	ref_mat[j+1] = yvec[i];
	ref_mat[j+2] = -1.0 * eval[3+i]; 
	ref_mat[j+3] = proj_pt[i];
	j = j + 4; 
    }
#if DEBUG
for(i=0;i<16;i=i+4)
{
write("ref_mat","\nt[",i,"] ", ref_mat[i],"t[",(i+1),"] ",
		ref_mat[i+1],"[",(i+2),"] ",
		ref_mat[i+2],"[",(i+3),"] ",
		ref_mat[i+3],"\n");

}
#endif



  /*-------------------------------------------------------------*/
  /* compute the transformation matrix to map the graphic object */ 
  /*-------------------------------------------------------------*/


  if( fabs(scale) <= EPSILON )
  {
	status(" scale value must be greater than 0.0");
	map_obj.objid = NULL_OBJID;
  }

  for( i=0;i<12;i=i+4){
    st_ref.var.ref_st.t[i]   = st_ref.var.ref_st.t[i]   / scale;
    st_ref.var.ref_st.t[i+1] = st_ref.var.ref_st.t[i+1] / scale;
    st_ref.var.ref_st.t[i+2] = st_ref.var.ref_st.t[i+2] / scale;
  }

  four = 4;

  MAinvmx(&msg,&four,st_ref.var.ref_st.t,tmp_matrix);
  MAmulmx(&msg,&four,&four,&four,ref_mat,tmp_matrix,trans_matrix);
  MAtypemx(&msg,trans_matrix,&mat_type);

  from_env.md_id.osnum = original_obj.osnum;
  stat = ci$send( msg	   = message GRgraphics.GRcopy(  
							 &msg,
							 &from_env,
                                             	         &MOD_ENV,
							 &map_obj.objid ),
                  	targetid = original_obj.objid,
	          	targetos = original_obj.osnum  );
   if( !( stat & msg & 1 ) ){
	#ifdef DEBUG
  	printf( "cpymir.u -  GRgraphics.GRcopy error\n" ) ;
	#endif
	return OM_E_ABORT ;
  	}

  /*-----------------------------------------------*/
  /*| We now can apply the xform to the object     */
  /*-----------------------------------------------*/

  dummy = NULL_OBJID ;
  map_obj.osnum = MOD_ENV.md_id.osnum;

  stat = ci$send(	msg	= message GRgraphics.GRxform(   &msg,
								&MOD_ENV,
								&mat_type,
								trans_matrix,
								&dummy ),
		targetid = map_obj.objid,
	        targetos = map_obj.osnum  );
  if( !( stat & 1 ) ){
  	printf( " GRgraphics.GRxform error\n" ) ;
	map_obj.objid = NULL_OBJID;
	return;
  }

  map_obj.objid = dummy;

#if DEBUG
  printf( " [%d,%d]GRgraphics.GRxform \n", map_obj.osnum, map_obj.objid ) ;
#endif


}/* end cons_map_obj */
  
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               place function                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

place()

  /*
  Description : Place an occurence of the macro definition
  Constraint  : none
  */ 
  {
  /* Construct the miror object */
#if DEBUG
write(" place enter cons_map_obj \n");
#endif
  cons_map_obj();
#if DEBUG
write(" place exit cons_map_obj \n");
#endif

  /* Connect the feet of the occurence */

  if( map_obj.objid == NULL_OBJID ) return(0);

  ci$send
    (msg      = message ci_macro.set_all_extern_feet
                        (&stat,NB_FEET,&map_obj,&MOD_ENV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  return(1);
}/* end place */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               compute function                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

compute()

  /*
  Description : recompute an occurence of the macro definition
  Constraint  : none
  */ 
  {
  cons_map_obj();

  /* Connect the feet of the occurence */

  if( map_obj.objid == NULL_OBJID ) return(0);

  ci$send
    (msg      = message ci_macro.set_all_extern_feet
                        (&stat,NB_FEET,&map_obj,&MOD_ENV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  return(1);
}/* end compute */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
