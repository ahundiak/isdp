/* $Id: scal_pro_v.u,v 1.1.1.1 2001/01/04 21:07:23 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / scal_pro_v.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: scal_pro_v.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:23  cvs
 *	Initial import to CVS
 *	
# Revision 1.2  1999/07/06  20:35:40  pinnacle
# Replaced: cimacros/wireframe/macros/scal_pro_v.u for:  by impd251 for vds
#
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/01/15  15:52:00  pinnacle
# AS_status
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *  MM/DD/YY  AUTHOR  DESCRIPTION
 *  01/15/98  ah      Move AS_status.h down so it compiles on Solaris
 *  07/06/99  jwf     Controll MAX_FEET.
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
/*
	File name :		scal_pro_v.u
	Creation date :		92/06/19
	Revision date :		92/06/19
	Author  :		Alain CLAUDE
	Product :		I/VDS - PPMmacro library

	Description :

	   This macro projects a curve on a surface along a vector (defined
	   by two points).  It should be used by the multi-scallop macro 
	   written by Robert Aish. 
 */

#include <stdio.h>
//#include "AS_status.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "nddef.h"
#include "macro.h"
#include "cimath.h"
#include "bserr.h"
#include "msdef.h"
#include "emssfintdef.h"
#include "igrdp.h"
#include "exmacros.h"
#include "grmacros.h"
#include "dp.h"
#include "AS_status.h"


#define MAX_FEET	100
#define MAX_CHA_FEET	9
#define MAX_TEMP        4	/* 4 templates */


struct GRid		CI_MACRO_ID ;
struct GRmd_env		MOD_ENV ;

IGRlong			stat, msg ;
IGRint      		num_crvs, i, j, k, num_temp ;

GRobj 			ci_mac_def1 ;
struct GRid		GRid_list[MAX_FEET];

IGRchar 		*temp_names[MAX_TEMP], *feet_names[MAX_FEET];
IGRint			temp_types[MAX_TEMP];
IGRchar			buff[MAX_FEET*MAX_CHA_FEET];


extern 			EX_get_modid_given_osnum()  ;
extern 	IGRint 		init_cnst_list(), BSmkvec() ;
extern	IGRdouble	BSdotp();
extern			ASsuper_construct();
extern int		MAidmx();
extern int 		MAtypemx();
extern			GRdisplay_object();
extern			BScrossp();

extern BuildSrf(), IntTwoSrf(), EvalFromTo() ; /* see VDSppl_util.I */


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */


main ()
{

  temp_names[0] = "srf1";  
  temp_names[1] = "crv1";  
  temp_names[2] = "pnt1";  
  temp_names[3] = "pnt2";  

  temp_types[0] = other_generic;
  temp_types[1] = curve_generic | conic_generic | line_generic;
  temp_types[2] = point_generic;
  temp_types[3] = point_generic;

  for (k=0; k<MAX_FEET; k=k+1){
	j = k * MAX_CHA_FEET;
	sprintf(&buff[j],"resi%d",k);
	feet_names[k] = &buff[j];
  }

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          =  ci_mac_def1,
		status 	          = &stat,
		name              = "scal_pro_v",
              	temp_num          = MAX_TEMP,
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = MAX_FEET, 
		extern_feet_names = feet_names );
 return(OM_S_SUCCESS) ;
}


/* ========================================================================= */


compute ()
{
  construct_scal();
  if( num_crvs == 0 ) return(0);

  if ( num_crvs > MAX_FEET )
  {
    num_crvs = MAX_FEET;
  }

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, num_crvs, GRid_list, &MOD_ENV ),
	   	targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum);
  return(1);
}


/* ========================================================================= */


place ()
{

  construct_scal() ;
  if( num_crvs == 0 ) return(0) ;

  if ( num_crvs > MAX_FEET )
  {
    num_crvs = MAX_FEET;
  }

  stat = ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, num_crvs, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum ) ;

  return(1);
}


/* ========================================================================= */


construct_scal()
{

#ifdef DEBUG
	printf("\n macro scal_pro_v : call to construct_scal() \n") ;
#endif

struct GRvg_construct	cst, cst_bis    ;
struct IGRdisplay	dis ;
struct GRmd_env		mod_env_bis     ;
struct GRlc_info	curve1,surface1 ;
struct ret_struct	temp1_rts, temp2_rts ;
struct GRid		CUV, ProjSurf, TempSrf ;
struct GRlc_info	LocProj ;
IGRdouble		FromTo[9];
IGRboolean		TrimRequired, AppRequired ;

  GRid_list[0].objid = NULL_OBJID;
  GRid_list[0].osnum = MOD_ENV.md_id.osnum;

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= NULL;
  cst.class_attr	= 0;
  cst.name		= 0;


  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&num_temp),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);
  if(!(stat&1)) return OM_E_ABORT ;


/*
	Get the original surface
 */

     stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&msg,0,&CUV),
 	      targetid = CI_MACRO_ID.objid ,
	      targetos = CI_MACRO_ID.osnum) ;  as$status(sts = stat) ;
     if( !(msg&stat&1) ) return OM_E_ABORT ;

     stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
				&msg,
				".",
				&surface1.located_obj, 
				&surface1.module_info.md_env.matrix_type, 
				surface1.module_info.md_env.matrix ),
	      targetid = CUV.objid,
	      targetos = CUV.osnum ) ;  as$status(sts = stat) ;

     if( !(msg&stat&1) ){
		#ifdef DEBUG
 		write("Bad surface as template\n");
		#endif
		return OM_E_ABORT ;
     }

     surface1.module_info.md_id.osnum = surface1.located_obj.osnum;
     ex$get_modid(	mod_osnum = surface1.module_info.md_id.osnum,
	        	mod_id    = &surface1.module_info.md_id.objid) ;


/*
	Get the curve to be projected
 */

     stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&msg,1,&CUV),
 	      targetid = CI_MACRO_ID.objid ,
	      targetos = CI_MACRO_ID.osnum) ;  as$status(sts = stat) ;
     if( !(msg&stat&1) ) return OM_E_ABORT ;

     stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
				&msg,
				".",
				&curve1.located_obj, 
				&curve1.module_info.md_env.matrix_type, 
				curve1.module_info.md_env.matrix ),
	      targetid = CUV.objid,
	      targetos = CUV.osnum ) ;  as$status(sts = stat) ;
     if( !(msg&stat&1) ) return OM_E_ABORT ;

     curve1.module_info.md_id.osnum = curve1.located_obj.osnum;
     ex$get_modid(	mod_osnum = curve1.module_info.md_id.osnum,
	        	mod_id    = &curve1.module_info.md_id.objid) ;

/*
	Get projection vector
 */

   stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( &msg,
							 2,
							 (char *) &temp1_rts,
						    	 &MOD_ENV  ),
	    targetid = CI_MACRO_ID.objid,
	    targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;
  if( !(msg & stat & 1) ){
	return OM_E_ABORT ;
  	}

   stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( &msg,
							 3,
							 (char *) &temp2_rts,
						    	 &MOD_ENV  ),
	    targetid = CI_MACRO_ID.objid,
	    targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;
  if( !(msg & stat &1) ){
	return OM_E_ABORT ;
  	}

  /*
	Construct an intermediate surface of projection, and intersect it
	with the original surface.
   */


  	EvalFromTo( &surface1, &curve1, temp1_rts.var.point_st.pt, 
	      temp2_rts.var.point_st.pt, FromTo, &msg ) ;
	if (!( msg & 1)) {
		#ifdef DEBUG
		printf("Error in EvalFromTo() \n") ;
		#endif
		return OM_E_ABORT ;
		}

	mod_env_bis      = *cst.env_info ;
        ex$get_modid(	mod_osnum = mod_env_bis.md_id.osnum,
	        	mod_id    = &mod_env_bis.md_id.objid) ;
	cst_bis          = cst ;
	cst_bis.env_info = &mod_env_bis ;

 	BuildSrf( &curve1, FromTo, &cst_bis, &TempSrf, &msg ) ;
	if (!( msg & 1)) {
		#ifdef DEBUG
		printf("Error in BuildSrf() \n") ;
		#endif
		return OM_E_ABORT ;
		}
  	LocProj.located_obj = TempSrf     ;
  	LocProj.module_info = mod_env_bis ;

	TrimRequired = FALSE ; /* because of a bug in EMintersect_surfaces() */
	AppRequired  = FALSE ;
  	IntTwoSrf( TrimRequired, AppRequired,
		&surface1, &LocProj, 
		&cst, &num_crvs, GRid_list, &stat) ; as$status(sts = stat) ;
	if (!( stat & 1)) {
		#ifdef DEBUG
		printf("Error in IntTwoSrf() \n") ;
		#endif
		stat = OM_E_ABORT ; /* and delete intermediate surface */
		}
	else stat = OM_S_SUCCESS ;

     	stat = ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
             	targetid = LocProj.located_obj.objid,
	        targetos = LocProj.located_obj.osnum) ; as$status(sts = stat) ;

	return stat ;
} /* construct_scal() */


/* ======================================================================== */


