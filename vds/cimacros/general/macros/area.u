/* $Id: area.u,v 1.1.1.1 2001/01/04 21:07:19 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/general/macros / area.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: area.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:19  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "EMSmsgdef.h"
#include "emsmapdef.h"
#include "emsimpdef.h"
#include "AS_status.h"

#define	EPSILON		1.0E-5

IGRshort		matrix_type;
IGRmatrix		matrix;

IGRlong			EMS_ret;
IGRchar 		*temp_names[2], *feet_names[1], *i_feet[1], str[40];
IGRchar 		txt[5];
IGRshort	 	mat_type;
OM_S_CHANSELECT		notify_chan, to_object;
struct GRid		MPROP;
IGRdouble		density, scaling_factor;
IGRboolean      	want_status;
IGRint			chan_index, num_surfaces;

IGRboolean 	        test_degeneracy, construct_loopset;
unsigned IGRchar   	curve_type;

IGRint			stat, msg, i, j;
GRobj 			ci_mac_def1, list[1], COMP;

IGRdouble 	        org[3], d1, out_in[20], pnt[3];
IGRdouble 	        stpt[3],enpt[3];

struct GRid		CUV, GCV, GRid_list[1], CI_MACRO_ID,AREA, SURF;

struct GRlc_info	entries[1];
struct GRmd_env		MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct GRprops          GRprops;
struct ret_struct 	expr, *expp;

struct 
{ 
	double ang;
	double spa;
	int num_ent;
	GRobj w_id;
	short w_os;
} var;

extern int 	init_cnst_list();
extern ASsuper_construct();


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  temp_names[0]  = "crv0";  
  temp_names[1]  = "area";  
  feet_names[0]  = "cdg";
  i_feet[0]      = "aexp";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef =  ci_mac_def1,
		status 	 = &stat, 	name = "area",
		int_name = "var",	int_size = sizeof(var),
              	temp_num = 2, 		temp_names = temp_names,
		intern_feet_num=1,	intern_feet_names= i_feet,
	      	extern_feet_num = 1, 	extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{

	  construct_comp();

	  if( GRid_list[0].objid == NULL_OBJID ) return(0);

	  feet_names[0] = "cdg";
	  i_feet[0] = "aexp";
	  expr.type = parameter_generic;
	  expr.var.root_pm_st.value=out_in[11];
	  expp=&expr;

	  ci$send( msg = message  ci_macro.chang_extern_feet
		 ( &stat, 1, feet_names,GRid_list, &MOD_ENV ),
		   targetid = CI_MACRO_ID.objid,
		   targetos = CI_MACRO_ID.osnum );

	  strcpy(str," area = ");
	  strcat(str,ftoa(expr.var.root_pm_st.value));
	  status(str);

	  ci$send( msg = message  ci_macro.set_intern_feet
		 ( &stat, 1,i_feet,&expp ),
		   targetid = CI_MACRO_ID.objid,
		   targetos = CI_MACRO_ID.osnum );
	  return(1);
}

/* ========================================================================= */

place ()
{
	  construct_comp();
	  if( GRid_list[0].objid == NULL_OBJID ) return(0); 
	
	  i_feet[0] = "aexp";
	  feet_names[0] = "cdg";
	  expr.type = parameter_generic;
	  expr.var.root_pm_st.value=out_in[11];
	  expp=&expr;

	  ci$send( msg = message  ci_macro.set_all_extern_feet
		 ( &stat, 1,GRid_list, &MOD_ENV ),
		   targetid = CI_MACRO_ID.objid,
		   targetos = CI_MACRO_ID.osnum );


	  strcpy(str," area = ");
	  strcat(str,ftoa(expr.var.root_pm_st.value));
 	  status(str);

	  ci$send( msg = message  ci_macro.set_intern_feet
		 ( &stat, 1,i_feet,&expp ),
		   targetid = CI_MACRO_ID.objid,
		   targetos = CI_MACRO_ID.osnum );
	  return(1);

}

/* ========================================================================= */

construct_comp()
{
      GRid_list[0].objid = NULL_OBJID;
      GRid_list[0].osnum = MOD_ENV.md_id.osnum;
      SURF.objid = NULL_OBJID;
      SURF.osnum = MOD_ENV.md_id.osnum;


      ci$send( msg      = message  ACcpx.ACfind_exp_temp_obj(&stat,1,&AREA),
               targetid = CI_MACRO_ID.objid,
               targetos = CI_MACRO_ID.osnum );

      if( stat != 1 ) return;

      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj(&stat,0,&CUV),
 	       targetid = CI_MACRO_ID.objid,
	       targetos = CI_MACRO_ID.osnum );

     if(stat == 0 ) exit;
     if(stat == 4 ) GCV = CUV;
     else{

         stat = ci$send( msg = message ASnode.ASreturn_go( &GCV, 
							   &matrix_type, 
							   matrix ),
	      	targetid = CUV.objid,
	      	targetos = CUV.osnum );
	 if( stat != 1 ) return;
     }

     ci$send( msg = message  GRvg.GRgeomprops( &msg,
			       		       &matrix_type, 
			       		       matrix,
			       		       &GRprops ),
	      targetid = GCV.objid,
	      targetos = GCV.osnum );

#ifdef DEBUG
	write("GRprops.type == 1 surf =",GRprops.type,'\n');
#endif

    		init_cnst_list();
    		get_symb();

    		dis.color	= cnst_list.color;
    		dis.weight	= cnst_list.weight;
    		dis.style	= cnst_list.style;

    		cst.msg		= &msg;
    		cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
    		cst.display	= &dis;
    		cst.env_info	= &MOD_ENV;
    		cst.newflag	= FALSE;
    		cst.level	= cnst_list.level;
    		cst.geometry	= (char *)NULL;
    		cst.class_attr	= NULL;
    		cst.name	= NULL;


     if( GRprops.type == 1 ){
#ifdef DEBUG
	write("a surface has been located \n");
#endif

		SURF = GCV;
     }
     else if( GRprops.type == 0 ){

#ifdef DEBUG
	write("a curve has been located \n");
#endif
        	ci$send( msg = message GRcurve.GRendpts
			(&msg, &matrix_type,
			matrix,stpt,enpt ),
	      		targetid = GCV.objid,
	      		targetos = GCV.osnum );

		if( 	(fabs( (stpt[0]-enpt[0]) ) > EPSILON) || 
			(fabs( (stpt[1]-enpt[1]) ) > EPSILON) ||
			(fabs( (stpt[2]-enpt[2]) ) > EPSILON) ){
#ifdef DEBUG
	write("curve not closed\n");
	write("stpt = ",stpt[0],stpt[1],stpt[2],"\n");
	write("enpt = ",enpt[0],enpt[1],enpt[2],"\n");
#endif
			status("curve not closed");
			return(0);
		}


/*-----------------------------------------------------------------------*/
/* ---  set the symbology compute the encompassing plane              ---*/
/*-----------------------------------------------------------------------*/


    		entries[0].located_obj = GCV;
    		entries[0].module_info = MOD_ENV;
    		curve_type = NULL;
    		test_degeneracy = TRUE;
    		construct_loopset = TRUE;

    		ci$send(msg = message EMSplane.EMplane_of_curve(
	     					&stat,
						&cst,
						&entries[0],
						NULL,
						(unsigned IGRchar *)&curve_type,
						test_degeneracy,
						construct_loopset,
						NULL,
						NULL   ),
            		targetid = SURF.objid,
            		targetos = SURF.osnum );

#ifdef DEBUG
write("stat EMSplane.EMplane_of_curve = ",stat," SURF.objid=",SURF.objid
							     ,SURF.osnum,"\n");
if( stat == EMS_S_Success ) write("EMSplane.EMplane_of_curve EMS_S_Success \n");
#endif


    		if( !(stat & EMS_S_Success) ){
			write(" Encompassing plane failed \n");
      			return;
    		}

     }/* a curve has been located, we needed to create the encompassing plane */


   for(i=0;i<3;i=i+1) org[i] = 0.0;

     MPROP.objid = NULL_OBJID;
     MPROP.osnum = MOD_ENV.md_id.osnum;

     stat = ci$send(msg       = message EMSmassprop.GRconstruct(&cst),
	            construct = 1,
                    targetid  = MPROP.objid,
	            targetos  = MPROP.osnum );
#ifdef DEBUG
write(" exit EMSmassprop.construct stat = ",stat,"MPROP.objid=",
					          MPROP.objid,MPROP.osnum,"\n");
#endif

     stat = om$make_chanselect ( channame     = "GRnotify.notification",
				 p_chanselect = &notify_chan );
#ifdef DEBUG
write(" exit om$make_chanselect GRnotify.notification\n");
#endif

     stat = om$make_chanselect ( channame     = "EMSmassprop.to_object",
			         p_chanselect = &to_object);

#ifdef DEBUG
write(" exit om$make_chanselect EMSmassprop.to_object\n");
#endif
     chan_index = GRDGNLIMITS_MAX_I;

     
     stat = ci$send(msg      = message Root.connect( to_object,
						     chan_index,
						     SURF.objid,
						     SURF.osnum,
						     notify_chan,
						     0),
             	    targetid = MPROP.objid,
	            targetos = MPROP.osnum );
#ifdef DEBUG
write(" exit Root.connect stat= ",stat,"\n");
#endif

     stat = ci$send(msg      = message EMSmassprop.EMinitialize(&EMS_ret),
             	    targetid = MPROP.objid,
	            targetos = MPROP.osnum );
#ifdef DEBUG
write(" exit EMSmassprop.EMinitialize stat= ",stat,"\n");
#endif

     stat = ci$send(msg      = message EMSmassprop.EMset_type( &EMS_ret,
							       1 ),
             	    targetid = MPROP.objid,
	            targetos = MPROP.osnum );    

/*-------------------------------------------------------------------------*/
/*---	evalute the area properties					---*/
/*-------------------------------------------------------------------------*/

#ifdef DEBUG
	write("enter EMSsurface.EMareaprop\n");
#endif
     want_status = TRUE;
     num_surfaces = 1;
     scaling_factor = 1.0;
     ci$send(msg = message EMSsurface.EMareaprop(
				 &EMS_ret,
				 want_status,
				 num_surfaces,
				 &MOD_ENV,
				 scaling_factor,
			         org,
                                 out_in),
           targetid = SURF.objid,
	   targetos = SURF.osnum );


#ifdef DEBUG
	write("exit EMSsurface.EMareaprop EMS_ret = ",EMS_ret,"\n");
#endif

   if( GRprops.type != 1 ) 
   	ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV), 
           	targetid = SURF.objid,
	   	targetos = SURF.osnum );


   if( EMS_ret != EMS_S_Success ) return;


   for(i=0;i<3;i=i+1) pnt[i] =out_in[i+2];

	status("");
	prompt("hit return to continue");
	write("\f\f\f\f\f");
	write("Centroid          [ ",out_in[2],out_in[3],out_in[4],"]",'\n');
	write("Surface area      = ",out_in[11],'\n');


     pnt[0] = out_in[2]; pnt[1] = out_in[3]; pnt[2] = out_in[4];


   cnst_list.weight = 3;
   set_symb();

   ci$send( msg      = message ASsrcpoint.place(0,0,pnt),
            targetid = GRid_list[0].objid,
	    targetos = GRid_list[0].osnum );

   ci$send(msg= message expression.NDgive_value(pnt), 
		targetid = AREA.objid,
		targetos = AREA.osnum);

   if( fabs( (out_in[11]-pnt[0]) ) > EPSILON ){

   ci$send(msg= message expression.modify("",ftoa(out_in[11]),&msg), 
		targetid = AREA.objid,
		targetos = AREA.osnum);

	write("we did the expression.modify \n");
  }
}


