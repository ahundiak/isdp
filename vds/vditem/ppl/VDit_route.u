
/***************************************************************************
 * I/VDS
 *
 * File:        vditem/ppl/VDit_route.u
 *
 * Description: PPL for determining mat_id_key of route objects.
 *              There are a few main functions within these PPL, all located
 *              near the end of this file.
 *              VDitemdbGetMatIDForCableObject for cables
 *              VDitemdbGetMatIDForConCompObject for connection components.
 *              VDitemdbGetMatIDForGuideObject for guides.
 *              VDitemdbGetMatIDForHvacObject for HVAC.
 *              VDitemdbGetMatIDForNozzleObject for Nozzles.
 *              VDitemdbGetMatIDForPipeObject for pipe.
 *              VDitemdbGetMatIDForRwayObject for RWAY.
 *              VDitemdbGetMatIDForTermObject for terminals.
 *              Any other function in this file exist as helper functions.
 *              Any function may be modified to suit the requirements of
 *              the customer.
 *              The only restriction is the name of this file, and the main
 *              functions must not be changed.
 *             
 *              For all of these main functions:
 *              Input:  KEY_VALUE_OBJID, this is the object being worked on.
 *                      This is a struct GRid  meaning it contains an objid
 *                      and osnum.
 *                      KEY_VALUE_OBJID.objid  and KEY_VALUE_OBJID.osnum
 *              Output: KEY_VALUE, this is a char of size 128.
 *
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: VDit_route.u,v $
 *      Revision 1.17  2002/06/06 20:54:03  jdsauby
 *      JTSMP TR6426, used domquery instead of risquery for caching data.
 *
 *      Revision 1.16  2002/05/23 14:21:41  jdsauby
 *      JTSMP TR 5586.  Utilized the generic XML cache for HVAC objects.
 *
 *      Revision 1.15  2001/10/23 15:01:46  anand
 *      Rollback of HVAC material list caching fix.
 *
 *      Revision 1.14  2001/09/21 20:05:57  anand
 *      Merged in Tom Sauer's changes.
 *
 *      Revision 1.13  2001/09/18 19:21:24  anand
 *      JTS TR MP5586
 *
 *      Revision 1.12  2001/05/30 18:00:56  jdsauby
 *      CR 5273, added get downcomerAttr routine
 *
 *      Revision 1.11  2001/05/10 15:22:35  jdsauby
 *      CRs 5204, 5203, 5179
 *
 *      Revision 1.10  2001/05/07 13:45:14  jdsauby
 *      Needed to uppercase duct_matl for RWAY objects due to AVD change in
 *      database tables.(VDit_route.u)  - jds
 *
 *      Revision 1.9  2001/04/16 20:24:35  jdsauby
 *      fixed
 *
 *      Revision 1.8  2001/03/16 20:06:20  jdsauby
 *      OOPS, left a traceFlag on.
 *
 *      Revision 1.7  2001/03/16 20:04:59  jdsauby
 *      Problem with Rway objects.  It is OK for method type to be blank.
 *
 *      Revision 1.6  2001/03/05 15:40:14  jdsauby
 *      stopped tracing
 *
 *      Revision 1.5  2001/02/22 16:09:42  jdsauby
 *      Stability issues, worked under CR4422
 *
 *      Revision 1.4  2001/02/21 13:09:41  jdsauby
 *      Some crashes have been found.  Just did some error checking and
 *      some misc. changes to fix.
 *
 *      Revision 1.3  2001/02/13 21:51:50  jdsauby
 *      Modified for problems with interference check
 *
 *      Revision 1.2  2001/02/02 19:05:34  jdsauby
 *      JS, JTS CR4087.
 *
 *      Revision 1.1  2001/01/10 18:04:41  art
 *      sp merge
 *
# Revision 1.2  2000/12/11  17:25:44  pinnacle
# js
#
# Revision 1.1  2000/12/06  19:08:12  pinnacle
# Created: vds/vditem/ppl/VDit_route.u by jdsauby for Service Pack
#
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 11/09/00  js      Creation
 * 
 * 
 ***************************************************************************/

#include "VDItemDBppl.h"
#include "vdsmacros.h"		// Added by TMS for caching workaround.
#include "VDctx.h"

//extern VDstrupr();
extern VDvalRisDomQuery();
extern snprintf();


#define VDITEMDB_DEFAULT_CAGE_CODE  "1CC97"

IGRstat getOneAttrFromSelectCache(sql, attr, value)
  IGRchar *sql;
  IGRchar *attr;
  IGRchar *value;
{
    IGRstat retFlag;
    IGRstat sts;
    TGRid   recordIDs;
    TGRid   recordID;
    IGRstat traceFlag;
  
    // arg check
    if (*sql == 0) goto wrapup;
    if (*attr == 0) goto wrapup;
    if (value == NULL) goto wrapup;  *value = 0;

    // init
    retFlag = 0;
    recordIDs.objid = NULL_OBJID;
    recordID.objid  = NULL_OBJID;
    traceFlag = 0;

    // Execute the qry
    if (traceFlag) printf("### checking cache\n");
    VDrisDomQueryCache(VDRIS_CACHE_ROUTE,sql,&recordIDs);
    if (recordIDs.objid == NULL_OBJID) goto wrapup;

    VDctxGetNthTreeChild(&recordIDs,0,&recordID);
    if (recordID.objid == NULL_OBJID) goto wrapup;

    VDctxGetTxtAtr(&recordID,attr,value);

    if (*value != 0) retFlag = 1;


wrapup:
    return retFlag;
}

/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a cable object.  This can be customized as desired.
 * I - KEY_VALUE_OBJID  the object being looked at
 * O - KEY_VALUE        the value to be returned 
 */
IGRstat VDitemdbGetMatIDForCableObject()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  /* -- Add Variables for any needed attributes here --*/
  IGRchar catNum [64];
  
  /* --------------------------------------------------*/
  
  TGRid   objID;
  IGRchar matKey[128];  // Do not change size or char array
  
  // Argument check, make sure there is an object
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;
  
  // Set to 1 for tracing, 0 for not tracing
  traceFlag = 0;
    
  // init
  retFlag = 0;
  matKey[0] = '\0';

  objID.objid = KEY_VALUE_OBJID.objid;
  objID.osnum = KEY_VALUE_OBJID.osnum;
  
  KEY_VALUE[0] = '\0';
  
  /* -- Init additional variables --*/
  catNum[0]  = '\0';
  
  /* -------------------------------------------------
   * Use vdsa$GetStruct(objID = &objID, name  = "attrName", txt = attr variable);
   * to get attributes from object and store into attr variable
   */

  // tracing
  if (traceFlag) printf(">>> VDitemdbGetMatIDForCableObject\n");

  // catalog_num
  vdsa$GetStruct(objID = &objID, name  = "catalog_num", txt = catNum);
  if (catNum[0] == '\0') goto wrapup;

  // build matKey = VDITEMDB_DEFAULT_CAGE_CODE-catalog_num
  sprintf( matKey, "%s-%s", VDITEMDB_DEFAULT_CAGE_CODE, catNum);
  if (matKey[0] == '\0') goto wrapup;
  
  // UPPER case
  VDstrupr(matKey);

  // Must set KEY_VALUE for a return value of key
  strcpy( KEY_VALUE,matKey );

  // done
  retFlag = 1;
  
 wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForCableObject\n");
  return retFlag;
}

/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a conection component object.  This can be customized as desired.
 * I - KEY_VALUE_OBJID  the object being looked at
 * O - KEY_VALUE        the value to be returned
 */
IGRstat VDitemdbGetMatIDForConCompObject()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  /* -- Add Variables for any needed attributes here --*/
  IGRchar catNum [64];
  
  /* --------------------------------------------------*/
  
  TGRid   objID;
  IGRchar matKey[128];  // Do not change size or char array
  
  // Argument check, make sure there is an object
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;
  
  // Set to 1 for tracing, 0 for not tracing
  traceFlag = 0;
    
  // init
  retFlag = 0;
  matKey[0] = '\0';

  objID.objid = KEY_VALUE_OBJID.objid;
  objID.osnum = KEY_VALUE_OBJID.osnum;
  
  KEY_VALUE[0] = '\0';
  
  /* -- Init additional variables --*/
  catNum[0]  = '\0';
  
  /* -------------------------------------------------
   * Use vdsa$GetStruct(objID = &objID, name  = "attrName", txt = attr variable);
   * to get attributes from object and store into attr variable
   */

  // tracing
  if (traceFlag) printf(">>> VDitemdbGetMatIDForConCompObject\n");

  // catalog_num
  vdsa$GetStruct(objID = &objID, name  = "catalog_num", txt = catNum);
  if (catNum[0] == '\0') goto wrapup;

  // build matKey = VDITEMDB_DEFAULT_CAGE_CODE-catalog_num
  sprintf( matKey, "%s-%s", VDITEMDB_DEFAULT_CAGE_CODE, catNum);
  if (matKey[0] == '\0') goto wrapup;
  
  // UPPER case
  VDstrupr(matKey);

  // Must set KEY_VALUE for a return value of key
  strcpy( KEY_VALUE,matKey );

  // done
  retFlag = 1;
  
 wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForConCompObject\n");
  return retFlag;
}


/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a guide object.  This can be customized as desired.
 * I - KEY_VALUE_OBJID  the object being looked at
 * O - KEY_VALUE        the value to be returned
 */
IGRstat VDitemdbGetMatIDForGuideObject()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  /* -- Add Variables for any needed attributes here --*/
  IGRchar catNum [64];
  
  /* --------------------------------------------------*/
  
  TGRid   objID;
  IGRchar matKey[128];  // Do not change size or char array
  
  // Argument check, make sure there is an object
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;
  
  // Set to 1 for tracing, 0 for not tracing
  traceFlag = 0;
    
  // init
  retFlag = 0;
  matKey[0] = '\0';

  objID.objid = KEY_VALUE_OBJID.objid;
  objID.osnum = KEY_VALUE_OBJID.osnum;
  
  KEY_VALUE[0] = '\0';
  
  /* -- Init additional variables --*/
  catNum[0]  = '\0';
  
  /* -------------------------------------------------
   * Use vdsa$GetStruct(objID = &objID, name  = "attrName", txt = attr variable);
   * to get attributes from object and store into attr variable
   */

  // tracing
  if (traceFlag) printf(">>> VDitemdbGetMatIDForGuideObject\n");

  // catalog_num
  vdsa$GetStruct(objID = &objID, name  = "catalog_num", txt = catNum);
  if (catNum[0] == '\0') goto wrapup;

  // build matKey = VDITEMDB_DEFAULT_CAGE_CODE-catalog_num
  sprintf( matKey, "%s-%s", VDITEMDB_DEFAULT_CAGE_CODE, catNum);
  if (matKey[0] == '\0') goto wrapup;
  
  // UPPER case
  VDstrupr(matKey);

  // Must set KEY_VALUE for a return value of key
  strcpy( KEY_VALUE,matKey );

  // done
  retFlag = 1;
  
 wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForGuideObject\n");
  return retFlag;
}

/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a terminal object.  This can be customized as desired.
 * I - KEY_VALUE_OBJID  the object being looked at
 * O - KEY_VALUE        the value to be returned
 */
IGRstat VDitemdbGetMatIDForTermObject()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  /* -- Add Variables for any needed attributes here --*/
  IGRchar catNum [64];
  
  /* --------------------------------------------------*/
  
  TGRid   objID;
  IGRchar matKey[128];  // Do not change size or char array
  
  // Argument check, make sure there is an object
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;
  
  // Set to 1 for tracing, 0 for not tracing
  traceFlag = 0;
    
  // init
  retFlag = 0;
  matKey[0] = '\0';

  objID.objid = KEY_VALUE_OBJID.objid;
  objID.osnum = KEY_VALUE_OBJID.osnum;
  
  KEY_VALUE[0] = '\0';
  
  /* -- Init additional variables --*/
  catNum[0]  = '\0';
  
  /* -------------------------------------------------
   * Use vdsa$GetStruct(objID = &objID, name  = "attrName", txt = attr variable);
   * to get attributes from object and store into attr variable
   */

  // tracing
  if (traceFlag) printf(">>> VDitemdbGetMatIDForTermObject\n");

  // catalog_num
  vdsa$GetStruct(objID = &objID, name  = "catalog_num", txt = catNum);
  if (catNum[0] == '\0') goto wrapup;

  // build matKey = VDITEMDB_DEFAULT_CAGE_CODE-catalog_num
  sprintf( matKey, "%s-%s", VDITEMDB_DEFAULT_CAGE_CODE, catNum);
  if (matKey[0] == '\0') goto wrapup;
  
  // UPPER case
  VDstrupr(matKey);

  // Must set KEY_VALUE for a return value of key
  strcpy( KEY_VALUE,matKey );

  // done
  retFlag = 1;
  
 wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForTermObject\n");
  return retFlag;
}

/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a hvac object.  This can be customized as desired.
 * I - KEY_VALUE_OBJID  the object being looked at
 * O - KEY_VALUE        the value to be returned
 */

IGRstat VDitemdbGetMatIDForHvacObject()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  /* -- Add Variables for any needed attributes here --*/
  IGRchar cageNum [64];
  IGRchar mino    [64];
  IGRchar specName[64];
  IGRchar ductMatl[64];
  
  /* --------------------------------------------------*/
  
  /* --- Variables required for HVAC Cache workaround --- */

  IGRint	sts;
  IGRlong	msg;
  IGRchar	listFilePath[256];
  IGRchar	string[128];
  IGRchar*	s;
  IGRchar*	stop;
  FILE*		fp;

  TGRid recordIDs;
  TGRid recordID;
  
  /* ---------------------------------------------------- */
  
  TGRid       objID;
  IGRchar     matKey[128];  // Do not change size or char array
  IGRchar     sql[256];
  
  /* Implemented this in Route to remind that this VDS PPL uses I/Route
   * functionality! Ensure to call this VDS PPL when in I/Route only! */
//  extern VRGetCageMinoFromHvcMatlList( IGRchar *specName, IGRchar *ductMatl,
//				       IGRchar *cageNum , IGRchar *mino );

  // Argument check, make sure there is an object
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;
  
  // Set to 1 for tracing, 0 for not tracing
  traceFlag = 0;
    
  // init
  retFlag = 0;
  matKey[0] = '\0';

  objID.objid = KEY_VALUE_OBJID.objid;
  objID.osnum = KEY_VALUE_OBJID.osnum;
  
  KEY_VALUE[0] = '\0';
  
  /* -- Init additional variables --*/
  cageNum[0]  = '\0';
  mino[0]     = '\0';
  specName[0] = '\0';
  ductMatl[0] = '\0';
  
  /* -------------------------------------------------
   * Use vdsa$GetStruct(objID = &objID, name  = "attrName", txt = attr variable);
   * to get attributes from object and store into attr variable
   */

  // tracing
  if (traceFlag) printf(">>> VDitemdbGetMatIDForHvacObject\n");

  /* -------------------------------------------------
   * HVAC has fabricated components and in-line equipment components both
   * of which fall under the hvac category.  If it is an in-line equipment
   * component, we can simply ask the component for it's cage-mino values.
   * If they come back as NULL, then it must be a fabricated component.
   * For fabricated components, need to query the hvac_material_list db
   * table for cage-mino based on spec, and material.
   */

  // in-line equipment, ask for cage mino directly
  if (traceFlag) printf("### asking for cage\n");
  vdsa$GetStruct(objID = &objID, name  = "cage", txt = cageNum);
  
  if (traceFlag) printf("### asking for mino\n");
  vdsa$GetStruct(objID = &objID, name  = "mino", txt = mino);

  if ( (cageNum[0] != '\0') && (mino[0] != '\0') )
  {
    // build matKey = cage-mino
    sprintf( matKey, "%s-%s", cageNum, mino );
    if (matKey[0] == '\0') goto wrapup;

    // UPPER case
    VDstrupr(matKey);
    
    // Must set KEY_VALUE for a return value of key
    strcpy( KEY_VALUE,matKey );
    
    // done
    retFlag = 1;
    goto wrapup;
    
  }
  
  // Should only make it to here for fabricated components
  
  // need spec_name
  if (traceFlag) printf("### asking for spec_name\n");
  vdsa$GetStruct(objID = &objID, name  = "spec_name", txt = specName);
  if (specName[0] == '\0') goto wrapup;
  
  // need duct_matl
  if (traceFlag) printf("### asking for duct_matl\n");
  vdsa$GetStruct(objID = &objID, name  = "duct_matl", txt = ductMatl);
  if (ductMatl[0] == '\0') goto wrapup;
  
  /* Replaced SQL query by the following function call - Anand */
/***** Disabled until this can be stabilized - TS
  sts = VRGetCageMinoFromHvcMatlList( specName, ductMatl, cageNum, mino );
*** End Disabled Section ********/
  sts = 0;		// Remove when above is re-enabled.
   
  snprintf(sql,sizeof(sql),
	  "select cage,mino from hvac_material_list where matl_class='%s' and duct_matl='%s';",
	  specName, ductMatl);

  // Execute the qry
  if (traceFlag) printf("### checking cache\n");
  VDrisDomQueryCache(VDRIS_CACHE_ROUTE,sql,&recordIDs);
  if (recordIDs.objid == NULL_OBJID) goto wrapup;

  VDctxGetNthTreeChild(&recordIDs,0,&recordID);
  if (recordID.objid == NULL_OBJID) goto wrapup;

  VDctxGetTxtAtr(&recordID,"cage",cageNum);
  VDctxGetTxtAtr(&recordID,"mino",mino);

  if (*mino != 0 && *cageNum != 0) sts = 1;


  if ( sts&1 )
  {
      // set matKey
      if (traceFlag) printf("### setting from cache\n");
      sprintf( matKey, "%s-%s", cageNum, mino );
  }
  else
  {
      if (traceFlag) printf("### setting from file\n");
    // ** Changes made by T. Sauer for SP 12G **
    sts = vd$file_path( msg = &msg, fileToFind = "h_mtl_lst.txt",
			dirToSearchFirst = ".",
			dirInProdPathToSearchThen = "config",
			absPathName = listFilePath );
    if ( sts )
    {
      fp = fopen( listFilePath, "r" );
      do
      {
	s = fgets( string, 127, fp );
	if ( s == NULL ) break;
	stop = strchr( string, '|' );
	if ( stop == NULL ) continue;
	*stop = 0;
	if ( strcmp( string, specName ) != 0 ) continue;
	s = stop + 1;
	stop = strchr( s, '|' );
	if ( stop == NULL ) continue;
	*stop = 0;
	if ( strcmp( s, ductMatl ) != 0 ) continue;
	s = stop + 1;
	stop = strchr( s, '|' );
	if ( stop )
	{
	  *stop = '-';
	  stop = strchr( s, '|' );
	  if ( stop )
	    *stop = 0;
	  else
	  {
	    stop = strchr( s, '\n' );
	    if ( stop ) *stop = 0;
	  }
	}
	strcpy( matKey, s );
	break;
      } while( TRUE );
      fclose( fp );
    }
#if 0
    else  // build a query
    {
      vdris$InitInfo(info = &ris);

      sprintf(ris.sql,
	    "select cage,mino from hvac_material_list where matl_class='%s' and duct_matl='%s';",
	    specName, ductMatl);
    
    // query it
      vdris$Query(info = &ris);
      if ( ris.rows < 1 )
      {
	vdris$FreeInfo(info = &ris);
	goto wrapup;
      }

    // set matKey, ris.buf[0] = cage, ris.buf[1] = mino

      sprintf( matKey, "%s-%s", ris.buf[0], ris.buf[1] );
      vdris$FreeInfo(info = &ris);
    }
#endif
  }

  
  // UPPER case
  VDstrupr(matKey);

  // Must set KEY_VALUE for a return value of key
  strcpy( KEY_VALUE,matKey );
  if (traceFlag) printf(" return value of key [%s]\n", KEY_VALUE );

  // done
  retFlag = 1;
  
wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForHvacObject\n");
  return retFlag;
}

/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a pipe object.  This can be customized as desired.
 * I - KEY_VALUE_OBJID  the object being looked at
 * O - KEY_VALUE        the value to be returned
 */
IGRstat VDitemdbGetMatIDForPipeObject()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  /* -- Add Variables for any needed attributes here --*/
  IGRchar cage [64];
  IGRchar mino [64];
  
  /* --------------------------------------------------*/
  
  TGRid   objID;
  IGRchar matKey[128];  // Do not change size or char array
  
  // Argument check, make sure there is an object
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;
  
  // Set to 1 for tracing, 0 for not tracing
  traceFlag = 0;
    
  // init
  retFlag = 0;
  matKey[0] = '\0';

  objID.objid = KEY_VALUE_OBJID.objid;
  objID.osnum = KEY_VALUE_OBJID.osnum;
  
  KEY_VALUE[0] = '\0';
  
  /* -- Init additional variables --*/
  cage[0] = '\0';
  mino[0] = '\0';
  
  /* -------------------------------------------------
   * Use vdsa$GetStruct(objID = &objID, name  = "attrName", txt = attr variable);
   * to get attributes from object and store into attr variable
   */

  // tracing
  if (traceFlag) printf(">>> VDitemdbGetMatIDForPipeObject\n");

  // cage
  vdsa$GetStruct(objID = &objID, name  = "cage", txt = cage);
  if (cage[0] == '\0') goto wrapup;

  // mino
  vdsa$GetStruct(objID = &objID, name  = "mino", txt = mino);
  if (mino[0] == '\0') goto wrapup;

  // build matKey = cage-mino
  sprintf( matKey, "%s-%s", cage, mino);
  if (matKey[0] == '\0') goto wrapup;
  
  // UPPER case
  VDstrupr(matKey);

  // Must set KEY_VALUE for a return value of key
  strcpy( KEY_VALUE,matKey );

  // done
  retFlag = 1;
  
 wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForPipeObject\n");
  return retFlag;
}



/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a nozzle object.  This currently is not determined
 */
IGRstat VDitemdbGetMatIDForNozzleObject()
{
    return 0;
}

/* -------------------------------------------
 * Get the downcomer attribute
 * **/
IGRstat getDownComerAttr(objID, a_downComer)
  TGRid   *objID;
  IGRchar *a_downComer;
{
    IGRstat    traceFlag;
    IGRstat    retFlag;
    IGRstat    sts;
    IGRdouble  dc;
    IGRint     dp,dp1,dp2,dp3,dp4,dp5,dp6,dp7,dp8,dp9;
    IGRchar    downComer[128];

    // init
    traceFlag = 0;
    retFlag   = 0;
    dc        = 0.0;
    dp=dp1=dp2=dp3=dp4=dp5=dp6=dp7=dp8=dp9 = 0;

    // argument check
    if (a_downComer) *a_downComer = 0;
    if (objID->objid == NULL_OBJID) goto wrapup;

    // say hi
    if (traceFlag) printf(">>> getDownComerAttr\n");

    // try to get dp
    vdsa$GetStruct(objID = objID, name  = "dp", dbl = &dc);
    if (dc > 0.0) {
	dp =(dc/25.4) + 0.99;
	sprintf(downComer,"%d",dp);

	if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
	retFlag = 1;
	goto wrapup;
    }


    // dp not found, look for dp1 and follow

    // dp1
    sts = vdsa$GetStruct(objID = objID, name  = "dp1", dbl = &dc);
    if (!(sts & 1)) goto wrapup;
    
    dp1 = (dc/25.4) + 0.99;
    sprintf(downComer,"%d",dp1);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);

    // have a value from here
    retFlag = 1;
    
    // dp2
    sts = vdsa$GetStruct(objID = objID, name  = "dp2", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp2 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d",dp1,dp2);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
    
    // dp3
    sts = vdsa$GetStruct(objID = objID, name  = "dp3", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp3 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d-%d",dp1,dp2,dp3);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
    
    // dp4
    sts = vdsa$GetStruct(objID = objID, name  = "dp4", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp4 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d-%d-%d",dp1,dp2,dp3,dp4);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
    
    // dp5
    sts = vdsa$GetStruct(objID = objID, name  = "dp5", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp5 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d-%d-%d-%d",dp1,dp2,dp3,dp4,dp5);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
	
    // dp6
    sts = vdsa$GetStruct(objID = objID, name  = "dp6", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp6 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d-%d-%d-%d-%d",dp1,dp2,dp3,dp4,dp5,dp6);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
    
    // dp7
    sts = vdsa$GetStruct(objID = objID, name  = "dp7", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp7 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d-%d-%d-%d-%d-%d",dp1,dp2,dp3,dp4,dp5,dp6,dp7);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
    
    // dp8
    sts = vdsa$GetStruct(objID = objID, name  = "dp8", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp8 = (dc/25.4) + 0.99;;
    sprintf(downComer,"%d-%d-%d-%d-%d-%d-%d-%d",
	    dp1,dp2,dp3,dp4,dp5,dp6,dp7,dp8);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);
    
    // dp9
    sts = vdsa$GetStruct(objID = objID, name  = "dp9", dbl = &dc);
    if (!(sts & 1)) goto wrapup;

    dp9 = (dc/25.4) + 0.99;
    sprintf(downComer,"%d-%d-%d-%d-%d-%d-%d-%d-%d",
	    dp1,dp2,dp3,dp4,dp5,dp6,dp7,dp8,dp9);
    if (traceFlag) printf("### downComer Attribute <%s>\n",downComer);


    // done, no other dps to consider

wrapup:
    if (retFlag) strcpy(a_downComer,downComer);
    if (traceFlag) printf("<<< getDownComerAttr <%s>\n",a_downComer);
    return retFlag;
}
    
  
/* --------------------------------------------
 * Clean Method Type for query
 * **/
IGRstat cleanMethodType(mtype, cleantype)
  IGRchar *mtype;
  IGRchar *cleantype;
{
    IGRstat retFlag;
    IGRchar *p;
    IGRint  i, alpha, intstr;
   
    
    // arg check
    if (mtype[0] == '\0') goto wrapup;
    
    // init
    retFlag = 0;

    // set them to be equal
    strcpy(cleantype,mtype);

    // check for a decimal
    if (p = strchr(cleantype,'.')) {
	alpha = 0;

	// does it also have a letter making it alpha-numeric?
	for (i = 0; i < strlen(cleantype); i = i + 1) {
	    if (cleantype[i] >= 'A') {
		alpha = 1;
	    }
	}
	if (alpha == 0)  {
	    // no letters, pure number
	    intstr = atoi(mtype);
	    sprintf(cleantype,"%d",intstr);
	}
    }

    // done

wrapup:
    return retFlag;
}

/* ---------------------------------------------
 * Qry the material code from rway_codelist, list_num 145
 */
IGRstat qryMaterialCode(duct_matl, material)
  IGRchar *duct_matl;
  IGRchar *material;
{
  IGRstat retFlag;
  IGRchar d_matl[80];
  IGRstat sts;
  IGRchar sql[1024];
  
  //TVDrisInfo ris;

  // Arg check
  //vdris$InitInfo(info = &ris);
  if (duct_matl == NULL) goto wrapup;
    
  // init
  retFlag = 0;
  *d_matl = 0;

  // local copy
  strcpy(d_matl,duct_matl);
  if (*d_matl == 0) goto wrapup;

  // uppercase d_matl
  VDstrupr(d_matl);
  
  // build the sql
  sprintf(sql,
	  "select short_txt from rway_codelist where list_num = 145 and long_txt = '%s';",
	  d_matl);

  // try the cache
  sts = getOneAttrFromSelectCache(sql,"short_txt",material);
  if (!(sts & 1)) {

      // try a regular query
      //vdris$Query(info = &ris);
      //if ( ris.rows < 1 ) goto wrapup;

      // set it
      //strcpy(material,ris.buf[0]);
      goto wrapup;
  }
  
  // done
  retFlag = 1;
  
 wrapup:
  //vdris$FreeInfo(info = &ris);
  return retFlag;
}

/* ---------------------------------------------
 * compute the mino for wway objects.  The mino
 * is actually queried from the db (OPS) based on
 * attributes that exist on the model object
 */
IGRstat computeMatIDForRWayObject(objID, mino)
  TGRid   *objID;
  IGRchar *mino;
{
  IGRstat retFlag;
  IGRstat sts;
  IGRstat traceFlag;
  IGRint  i;
  
  IGRchar methd[32],cleanMethod[32];
  IGRchar *p,*buf;
  IGRchar ops_type[80];
  IGRchar ops_modifier[80];
    
  IGRchar    methodType[32],cleanType[32];
  IGRchar    material  [32],duct_matl[32];
  IGRdouble  width;
  IGRchar    attrWidth[80];
  IGRdouble  noTiers;
  IGRchar    downComer [128];
  IGRchar    sql[1024];

  //TVDrisInfo ris;
  
  traceFlag = 0;
  if (traceFlag) printf(">>>computeMatIDForRWayObject\n");
  
  // Arg check
  //vdris$InitInfo(info = &ris);
  if (objID->objid == NULL_OBJID) goto wrapup;
  
  // init
  retFlag       = 0;
  methd[0]      = '\0';
  methodType[0] = '\0';
  cleanType[0]  = '\0';
  downComer[0]  = '\0';
  duct_matl[0]  = '\0';
  width         = 0;
  noTiers       = 0;

  mino[0] = '\0';
   
  // get some attributes
  if (traceFlag) printf("### getting attributes ...\n");
  
  // get method_no first
  vdsa$GetStruct(objID = objID, name  = "method_no", tyt = methd);
  if (methd[0] == '\0') goto wrapup;
  if (traceFlag) printf("### method_no = %s\n",methd);
   
  // clean the method no, should be in format '2-b-1'
  // clean out any '-'
  p = 0;
  while (p = strchr(methd,'-')) 
     strcpy(p,p+1);
   
  // clean out any '"'
  p = 0;
  while (p = strchr(methd,'"'))
    strcpy(p,p+1);
  
  strcpy(cleanMethod,methd);
  
  if (traceFlag) printf("### clean method = %s\n",cleanMethod);
    
  // get methode_type
  vdsa$GetStruct(objID = objID, name  = "method_type", tyt = methodType);
  if (methodType[0] == '\0') goto wrapup;
  if (traceFlag) printf("### method_type = %s\n",methodType);
   
  // clean out any '"' from method_type
  p = 0;
  while (p = strchr(methodType,'"'))
    strcpy(p,p+1);
  
  // could have been placed as a number (ie 1.00000), need to drop the decimal zeros
  cleanMethodType(methodType,cleanType);
  //if (cleanType[0] == '\0') goto wrapup;  it can be blank

  // get duct_matl
  vdsa$GetStruct(objID = objID, name  = "duct_matl", txt = duct_matl);
  if (duct_matl[0] == '\0') goto wrapup;
  if (traceFlag) printf("### duct_matl = %s\n",duct_matl);
  
  // Convert material to alpha code
  sts = qryMaterialCode(duct_matl,material);
  if (!(sts & 1)) goto wrapup;
  
  // get width_1
  vdsa$GetStruct(objID = objID, name  = "width_1", dbl = &width);
  if (width <= 0) goto wrapup;
  if (traceFlag) printf("### width_1 = %.0f\n",width);

  // Convert width from mm to inch
  width = width/25.4;
  if (width < 8.0) sprintf(attrWidth,"%.3f",width);
  else             sprintf(attrWidth,"%.0f",width);
  
  // get no_tiers_1
  vdsa$GetStruct(objID = objID, name  = "no_tiers_1", dbl = &noTiers);
  if (noTiers <= 0) goto wrapup;
  if (traceFlag) printf("### no_tiers_1 = %.0f\n",noTiers);

  // dp is a tricky on, if dp is not found, then it might be dp1
  // if dp1 is found, then we need to keep looking for the other dps
  // until ther are no more
  getDownComerAttr(objID, downComer);
  if (downComer[0] == '\0') goto wrapup;

  // build the ops_type
  sprintf(ops_type,"WH%s%s",cleanMethod,cleanType);
  
  // build the ops_modifier
  sprintf(ops_modifier,"%s-%s-%.0f-%s",material,attrWidth,noTiers,downComer);
  
  // now query the tm_items to get the mino
   // build the query
  sprintf(sql,
	  "select item_num from tm_items where tree_type='%s' and tree_modifier='%s' and item_cur_rev=1;",
	  ops_type,ops_modifier);
  if (traceFlag) printf("### %s\n",sql);
  
  // try from cache
  sts = getOneAttrFromSelectCache(sql,"item_num",mino);
  if (!(sts & 1)) {
      // query
      //vdris$Query(info = &ris);
      //if ( ris.rows < 1 ) goto wrapup;

      // set it
      //strcpy(mino,ris.buf[0]);
      goto wrapup;
  }
  if (traceFlag) printf ("### mino = %s\n",mino);

  // done
  if (mino[0] != '\0') retFlag = 1;
    
wrapup:
  if (traceFlag) printf("<<< computeMatIDForRWayObject\n");
  //vdris$FreeInfo(info = &ris);
  return retFlag;
}
  
/* --------------------------------------------------------
 * Waveguide MINOs are gotten from the part_num attribute in
 * the rway_comps table
 */
IGRstat computeMatIDForWaveguideObject(objID, mino)
  TGRid   *objID;
  IGRchar *mino;
{
  IGRstat retFlag;
  IGRstat sts;
  IGRstat traceFlag;
  
  IGRchar comp_code[32];
  IGRchar sql[1024];
  
  //TVDrisInfo ris;
  
  // init 
  //vdris$InitInfo(info = &ris);
  retFlag = 0;
  traceFlag = 0;
  comp_code[0] = '\0';

  // get comp_code
  vdsa$GetStruct(objID = objID, name  = "comp_code", txt = comp_code);
  if (comp_code[0] == '\0') goto wrapup;
  if (traceFlag) printf("### comp_code = %s\n",comp_code);

  // build the query
  sprintf(sql,
	  "select part_num from rway_comps where comp_code = '%s';",
	  comp_code);
  if (traceFlag) printf("### %s\n",sql);
  
  // try from cache
  sts = getOneAttrFromSelectCache(sql,"part_num",mino);
  if (!(sts & 1)) {

      // query
      //vdris$Query(info = &ris);
      //if ( ris.rows < 1 ) goto wrapup;

      // set it
      //if (traceFlag) printf ("### ris.buf[0] = %s\n",ris.buf[0]);

      //strcpy(mino,ris.buf[0]);
      goto wrapup;
  }
  if (traceFlag) printf ("### mino = %s\n",mino);
  
  
  // done
  retFlag = 1;

    
wrapup:
  //vdris$FreeInfo(info = &ris);
  return retFlag;
  
}


/* --------------------------------------------------------
 * Collars will use method_no, method_type, material, width_1,
 * depth_1, trans_len, collar_type
 */
IGRstat computeMatIDForRWayCollarObject(objID, mino)
  TGRid   *objID;
  IGRchar *mino;
{
  IGRstat retFlag;
  IGRstat sts;
  IGRstat traceFlag;
  
  IGRint  i;
  
  IGRchar methd[32],cleanMethod[32];
  IGRchar *p,*buf;
  IGRchar ops_type[80];
  IGRchar ops_modifier[80];
    
  IGRchar    methodType[32],cleanType[32];
  IGRchar    material  [32],duct_matl[32];
  IGRdouble  width1,depth1,trans_len;
  IGRchar    attrWidth1[80],attrDepth1[80],attrTrans_len[80];
  IGRdouble  ductThk;
  IGRdouble  whole;
  IGRchar    sql[1024];
  
  //TVDrisInfo ris;
  
  // init 
  //vdris$InitInfo(info = &ris);
  traceFlag     = 0;
  retFlag       = 0;
  methd[0]      = '\0';
  methodType[0] = '\0';
  cleanType[0]  = '\0';
  duct_matl[0]  = '\0';
  width1        = 0;
  depth1        = 0;
  trans_len     = 0;

  mino[0]       = '\0';
   
  // get some attributes
  if (traceFlag) printf("### getting attributes ...\n");
  
  // get method_no first
  vdsa$GetStruct(objID = objID, name  = "method_no", tyt = methd);
  if (methd[0] == '\0') goto wrapup;
  if (traceFlag) printf("### method_no = %s\n",methd);
   
  // clean the method no, should be in format '3-a-1'
  // clean out any '-'
  p = 0;
  while (p = strchr(methd,'-')) 
     strcpy(p,p+1);
   
  // clean out any '"'
  p = 0;
  while (p = strchr(methd,'"'))
    strcpy(p,p+1);
  
  strcpy(cleanMethod,methd);
  
  if (traceFlag) printf("### clean method = %s\n",cleanMethod);
    
  // get methode_type
  vdsa$GetStruct(objID = objID, name  = "method_type", tyt = methodType);
  if (methodType[0] == '\0') goto wrapup;
  if (traceFlag) printf("### method_type = %s\n",methodType);
  
  // clean out any '"' from method_type
  p = 0;
  while (p = strchr(methodType,'"'))
    strcpy(p,p+1);
  
  // could have been placed as a number (ie 1.00000), need to drop the decimal zeros
  cleanMethodType(methodType,cleanType);
  //if (cleanType[0] == '\0') goto wrapup;  it can be blank

  // get duct_matl
  vdsa$GetStruct(objID = objID, name  = "duct_matl", txt = duct_matl);
  if (duct_matl[0] == '\0') goto wrapup;
  if (traceFlag) printf("### duct_matl = %s\n",duct_matl);
  
  // Convert material to alpha code
  sts = qryMaterialCode(duct_matl,material);
  if (!(sts & 1)) goto wrapup;
  
  // get width_1
  vdsa$GetStruct(objID = objID, name  = "width_1", dbl = &width1);
  if (width1 <= 0) goto wrapup;
  if (traceFlag) printf("### width_1 = %.3f\n",width1);

  // Convert width from mm to inch
  width1 = width1/25.4;
  whole  = floor( width1 + 0.001 );
  if ( whole < 8.0  ||  fabs( width1 - whole ) >= 0.001 )
	sprintf(attrWidth1,"%.3f",width1);
  else
	sprintf(attrWidth1,"%.0f",width1);
  
  // get depth_1
  vdsa$GetStruct(objID = objID, name  = "depth_1", dbl = &depth1);
  if (depth1 <= 0) goto wrapup;
  if (traceFlag) printf("### depth_1 = %.3f\n",depth1);

  // Convert depth from mm to inch
  depth1 = depth1/25.4;
  whole  = floor( depth1 + 0.001 );
  if ( whole < 8.0  ||  fabs( depth1 - whole ) >= 0.001 )
	sprintf(attrDepth1,"%.3f",depth1);
  else
	sprintf(attrDepth1,"%.0f",depth1);
    
  // get trans_len
  vdsa$GetStruct(objID = objID, name  = "trans_len", dbl = &trans_len);
  if (trans_len <= 0) goto wrapup;
  if (traceFlag) printf("### trans_len = %.3f\n",trans_len);

  // Convert trans_len from mm to inch
  trans_len = trans_len/25.4;
  whole  = floor( trans_len + 0.001 );
  if ( whole < 8.0  ||  fabs( trans_len - whole ) >= 0.001 )
	sprintf(attrTrans_len,"%.3f",trans_len);
  else
	sprintf(attrTrans_len,"%.0f",trans_len);

  // get ductThk
  vdsa$GetStruct(objID = objID, name  = "duct_thk", dbl = &ductThk);
  if (traceFlag) printf("### duct_thk = %.3f\n",ductThk);

  // build the ops_type
  sprintf(ops_type,"CLR%s-%s",cleanMethod,cleanType);
  
  // build the ops_modifier
  sprintf(ops_modifier,"%s-%sX%sX%sX%.3f",
	  material,attrWidth1,attrDepth1,attrTrans_len,ductThk);

    // now query the tm_items to get the mino
   // build the query
  sprintf(sql,
	  "select item_num from tm_items where tree_type='%s' and tree_modifier='%s' and item_cur_rev=1;",
	  ops_type,ops_modifier);
  if (traceFlag) printf("### %s\n",sql);
  
  // try from cache
  sts = getOneAttrFromSelectCache(sql,"item_num",mino);
  if (!(sts & 1)) {
      // query
      //vdris$Query(info = &ris);
      //if ( ris.rows < 1 ) goto wrapup;

      // set it
      //strcpy(mino,ris.buf[0]);
      goto wrapup;
  }
  if (traceFlag) printf ("### mino = %s\n",mino);

  // done
  retFlag = 1;
    
wrapup:
  if (traceFlag) printf("<<< computeMatIDForRWayCollarObject\n");
  //vdris$FreeInfo(info = &ris);
  return retFlag;
}


IGRstat computeMatIDForRWayTransitObject(objID, mino)
  TGRid   *objID;
  IGRchar *mino;
{
  IGRstat retFlag;
  IGRstat sts;
  IGRstat traceFlag;
  
  IGRchar comp_code[32];
  IGRchar collar_type[32];
  IGRchar collarType[32];
  IGRchar *p;
  IGRint  i;
  
  IGRchar ops_type[80];
  IGRchar ops_modifier[80];
    
  IGRchar    material[32],duct_matl[32];
  IGRdouble  width1,depth1,trans_len;
  IGRchar    attrWidth1[80],attrDepth1[80],attrTrans_len[80];
  IGRdouble  ductThk;
  IGRdouble  whole;
  IGRchar    sql[1024];
  
  //TVDrisInfo ris;
  
  // init 
  //vdris$InitInfo(info = &ris);
  traceFlag   = 0;
  retFlag     = 0;
  comp_code[0]  = '\0';
  collar_type[0]  = '\0';
  duct_matl[0]  = '\0';
  width1      = 0;
  depth1      = 0;
  trans_len   = 0;

  mino[0] = '\0';
   
  // get some attributes
  if (traceFlag) printf("### getting attributes ...\n");
  
  // get comp_code
  vdsa$GetStruct(objID = objID, name  = "comp_code", txt = comp_code);
  if (comp_code[0] == '\0') goto wrapup;
  if (traceFlag) printf("### comp_code = %s\n",comp_code);
  
  // get collar_type
  vdsa$GetStruct(objID = objID, name  = "collar_type", txt = collar_type);
  if (collar_type[0] == '\0') goto wrapup;
  if (traceFlag) printf("### collar_type = %s\n",collar_type);

  // clean out any '"'
  p = 0;
  while (p = strchr(collar_type,'"'))
    strcpy(p,p+1);
  
  strcpy(collarType,collar_type);
  
  // get duct_matl
  vdsa$GetStruct(objID = objID, name  = "duct_matl", txt = duct_matl);
  if (duct_matl[0] == '\0') goto wrapup;
  if (traceFlag) printf("### duct_matl = %s\n",duct_matl);
  
  // Convert material to alpha code
  sts = qryMaterialCode(duct_matl,material);
  if (!(sts & 1)) goto wrapup;
  
  // get width_1
  vdsa$GetStruct(objID = objID, name  = "width_1", dbl = &width1);
  if (width1 <= 0) goto wrapup;
  if (traceFlag) printf("### width_1 = %.0f\n",width1);

  // Convert width from mm to inch
  width1 = width1/25.4;
  whole  = floor( width1 + 0.001 );
  if ( whole < 8.0  ||  fabs( width1 - whole ) >= 0.001 )
	sprintf(attrWidth1,"%.3f",width1);
  else
	sprintf(attrWidth1,"%.0f",width1);
  
  // get depth_1
  vdsa$GetStruct(objID = objID, name  = "depth_1", dbl = &depth1);
  if (depth1 <= 0) goto wrapup;
  if (traceFlag) printf("### depth_1 = %.0f\n",depth1);

  // Convert depth from mm to inch
  depth1 = depth1/25.4;
  whole  = floor( depth1 + 0.001 );
  if ( whole < 8.0  ||  fabs( depth1 - whole ) >= 0.001 )
	sprintf(attrDepth1,"%.3f",depth1);
  else
	sprintf(attrDepth1,"%.0f",depth1);
    
  // get trans_len
  vdsa$GetStruct(objID = objID, name  = "trans_len", dbl = &trans_len);
  if (trans_len <= 0) goto wrapup;
  if (traceFlag) printf("### trans_len = %.0f\n",trans_len);

  // Convert trans_len from mm to inch
  trans_len = trans_len/25.4;
  whole  = floor( trans_len + 0.001 );
  if ( whole < 8.0  ||  fabs( trans_len - whole ) >= 0.001 )
	sprintf(attrTrans_len,"%.3f",trans_len);
  else
	sprintf(attrTrans_len,"%.0f",trans_len);

  // get ductThk
  vdsa$GetStruct(objID = objID, name  = "duct_thk", dbl = &ductThk);
  if (traceFlag) printf("### duct_thk = %.3f\n",ductThk);

  // build the ops_type
  //strcpy(ops_type,comp_code);
  sprintf(ops_type,"%s-%s",comp_code,collarType);
  
  // build the ops_modifier
  sprintf(ops_modifier,"%s-%sX%sX%sX%.3f",
	  material,attrWidth1,attrDepth1,attrTrans_len,ductThk);

    // now query the tm_items to get the mino
   // build the query
  sprintf(sql,
	  "select item_num from tm_items where tree_type='%s' and tree_modifier='%s' and item_cur_rev=1;",
	  ops_type,ops_modifier);
  if (traceFlag) printf("### %s\n",sql);
  
  // try from cache
  sts = getOneAttrFromSelectCache(sql,"item_num",mino);
  if (!(sts & 1)) {
      // query
      //vdris$Query(info = &ris);
      //if ( ris.rows < 1 ) goto wrapup;

      // set it
      //strcpy(mino,ris.buf[0]);
      goto wrapup;
  }
  if (traceFlag) printf ("### mino = %s\n",mino);

  // done
  if (mino[0] != '\0') retFlag = 1;
    
wrapup:
  if (traceFlag) printf("<<< computeMinoForWWayObject\n");
  //vdris$FreeInfo(info = &ris);
  return retFlag;
  
}




/* -----------------------------------------------------------
 * This is the controlling function for determining KEY_VALUE for
 * a rway object.  
 */
IGRstat VDitemdbGetMatIDForRwayObject()
{
  IGRstat retFlag;
  IGRstat sts;
  IGRstat traceFlag;
    
  IGRdouble par_2;
  IGRchar   par[12];
  

  IGRchar mino[32];
  
  
  // Arg check
  if (KEY_VALUE_OBJID.objid == NULL_OBJID) goto wrapup;

  // init
  retFlag = 0;
  traceFlag = 0;
  par_2 = 0;
  KEY_VALUE[0] = '\0';
  mino[0] = '\0';

  // say hi
  if (traceFlag) printf (">>> VDitemdbGetMatIDForRwayObject\n");
  
  
  // Get the par_2 attribute
  vdsa$GetStruct(objID = &KEY_VALUE_OBJID, name  = "par_2", dbl = &par_2);
  if (traceFlag) printf("### par_2 = %.0f\n",par_2);
  sprintf(par,"%.0f",par_2);
  
  switch (*par) {
    
  case '1':
    sts = computeMatIDForRWayObject(&KEY_VALUE_OBJID,mino);
    if ( (!(sts & 1)) || (mino[0] == '\0') ) goto wrapup;
    sprintf(KEY_VALUE,"%s-%s",VDITEMDB_DEFAULT_CAGE_CODE,mino);
    retFlag = 1;
    goto wrapup;
        
  case '2':
    sts = computeMatIDForWaveguideObject(&KEY_VALUE_OBJID,mino);
    if ( (!(sts & 1)) || (mino[0] == '\0') ) goto wrapup;
    sprintf(KEY_VALUE,"%s-%s",VDITEMDB_DEFAULT_CAGE_CODE,mino);
    retFlag = 1;
    goto wrapup;
    
  case '3':
    sts = computeMatIDForRWayCollarObject(&KEY_VALUE_OBJID,mino);
    if ( (!(sts & 1)) || (mino[0] == '\0') ) goto wrapup;
    sprintf(KEY_VALUE,"%s-%s",VDITEMDB_DEFAULT_CAGE_CODE,mino);
    retFlag = 1;
    goto wrapup;
    
  case '4':
    sts = computeMatIDForRWayTransitObject(&KEY_VALUE_OBJID,mino);
    if ( (!(sts & 1)) || (mino[0] == '\0') ) goto wrapup;
    sprintf(KEY_VALUE,"%s-%s",VDITEMDB_DEFAULT_CAGE_CODE,mino);
    retFlag = 1;
    goto wrapup;
    
  default:
    sts = computeMatIDForRWayObject(&KEY_VALUE_OBJID,mino);
    if ( (!(sts & 1)) || (mino[0] == '\0') ) goto wrapup;
    sprintf(KEY_VALUE,"%s-%s",VDITEMDB_DEFAULT_CAGE_CODE,mino);
    retFlag = 1;
    goto wrapup;
    
  }
   
  // done

wrapup:
  if (traceFlag) printf("<<< VDitemdbGetMatIDForRwayObject\n");
  
  return retFlag;
}



