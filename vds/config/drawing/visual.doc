
	Automatic Process For Visualization Elements :

	--------------------------------------------------------------

			--- TABLE OF CONTENTS ---

	I   Introduction

	II  Name and location of the "Visual" file

	III Organization of a "Visual" file
	     A) Syntax for selection on element type
	     B) Transfer of attributes to drawn element
	     C) Example

	IV  Specification of element representation in drawing sheet
	     A) Representation types for object
	     B) Syntax
	     C) Display attributes
		i )   Color
		i)i   Style
		iii)  Weight
		iv)   Level
		v)    Hidden color
		vi)   Hidden style
		vii)  Hidden weight
		viii) Hidden level
		ix)    Scale
		x)   Offset
	    D) Examples

	V   Specification of symbol to be placed next to drawn element
	    A) Syntax
	    B) Display attributes
	    C) Justification
	    D) Width
	    E) Height
	    F) Size
	    G) Position
		i)   "top", "bottom", "left", "right"
		ii)  "center", "middle", "innermost"
		iii) "at-first-end", "at-second-end"
		iv)  "above", "below", "to-the-left", "to-the-right",
		     "offset"
		v)   "parallel", "orthogonal", "horizontal"
		vi)  "upside-down", "right-to-left", "not-reversed"
	    H) Font
	    I) Format
	    J) Available global text values
	    K) Use of an anchor point or an anchor curve
	    L) Examples

	VI  Expressions and operations

	VII Constant values

	VIII Functions
	    A) Accessing attributes of the element
	    B) Formatting numbers for text output
	    C) Retrieving the scale of the element
	    D) Retrieving the type of a construction
	    E) Finding a member of an element
	    F) Matching a string against a regular expression
	    G) String manipulation functions
	     - Duplicating a character string
	     - Concatenating strings
	     - Computing the length of a character string
	     - Getting the count of word in a string
	     - Getting a word in a string
	     - Extracting a sub-string from a string
	     - Substituting a sub-string by another
	     - Getting the time and date
	    H) Getting the basename of an element
	    I) Mapping ship locations to drawing sheet
	    J) Obtaining information from the relational data base

	IX  Conditionals
	    A) Syntax
	    B) Example

	X   Variables

	XI  Manipulating the relational data base

	XII Debugging

	XIII File inclusion

	XIV Definition of the language
	   A) List of keywords
	   B) Syntax

	XV Hints
	   A) How to have subscripts and superscripts in text
	   B) How to underline text
	   C) How to annotate a construction for a hole


	I Introduction
	--------------

		"Visual" is a simple language allowing the user to specify
	how VDS components from the model should be processed to generate
	a drawing in the drawing file ( referred to as `drawing sheet' ).

		For each VDS component entity (equipment, plate, beam, 
	stiffener, joint, pipe, hvac, rway ), "Visual" proposes a set of
	representations for these entities to be output to the drawing sheet.

                Visualization process does not distinguish between beams and
        stiffeners. Either beam or stiffener can be defined in setup file for 
        beams or stiffeners.

		"Visual" also allows the output of cells and constructions, 
	occurrences of macros to the drawing sheet.

		Moreover, "Visual" contains tools to place text and 
	text-symbols (defined in a font) next to the drawn elements.

		As each entity is being extracted, it will interpret the
	"Visual" file to take the ad hoc actions.

		The syntax of "Visual" is format-free: spaces, newlines and
	tabulations may be inserted anywhere between syntactic entities.
	Comments start with a '#' (sharp sign/pound sign); when a '#' is
	encountered, what follows is ignored up to the end of the line.



	In what follows the following vocabulary will be used:
	------------------------------------------------------

	Drawing sheet :	The (active) file where elements are drawn; This is
			always the Top view with the normal projection
			direction to the z-vector.

	Construction:	An occurrence of a macro.


	II Name and location of the "Visual" file
	-----------------------------------------

		The support file is used to read the symbology and the 
	output type of the objects to be processed.  The support file can 
        be written in any ASCII file. The ASCII file needs to be given as 
        input before selecting the objects.  For convience, we are talking 
	about the file "visual". The name can be user defined.

		The "Visual" default file has the name "visual" and is given
	in the VDS config/drawing directory. The user can define his own 
	file, which should be stored in the config/drawing directory of the
	product paths or in the current directory.

		Example: 

		When run from I/ROUTE, the search order will be

			./visual
			<user-path>/config/drawing/visual
			$ROUTE/config/drawing/visual
			$STRUCT/config/drawing/visual	(if Active)
			$VDS/config/drawing/visual
			...
	the first visual file found will be interpreted.

	III Organization of a "Visual" file
	----------------------------------

		A "Visual" is organized as follows :

	Selection on element type 1

			Actions
			Actions
		etc.

	Selection on element type 2

			Actions
		etc.
	etc.

	Actions have to be separated by a `;' (semi-colon) :

		<action> ; <action> ; <action>


	A) Syntax for selection on element type

	<element type> : { ... }

	where <element type> :

	 - vehicle :

		"equipment( <args> )", 
		"compartment",
		"struct-surf", "split-surf", "bould-surf",
		"split-volume", "limit-volume", "profile-volume",
		"section", 

	 - structural :

		"plate", "beam", "stiffener" or "joint"

	 - routing :

		"pipe", "hvac", "rway", "nozzle" 
		"cable", "guide", terminal", "connect_comp", "back_shell"

	 - others :

		"cell( <args> )",
		"sym( <args> )", 
		"macro( <args> )"
		"all"			(Any macro, cell, symbol type).

	All element types with the "( <args> )" allows user to give a 
	special treatment for nested macro, cell, or symbol names.
	
	Example:

		equipment( "desk" ): { ... }

		equipment : { ... }

	A special visualization process can be defined for the "desk" 
	equipment object. All other equipment will be treated by the
	default rules as given in "equipment : { ... }".


	B) Transfer of attributes to drawn element

	Information may be transferred from the 3d element to its drawing
	sheet representation (parameters), the name of the parameters to be
	transferred are then specified. 

	Example :

	If you want some beam attributes to be available in the drawing
	sheet, e.g. the family name and part number of the beam :

		beam : {
			with "family_name", "part_num" ;
			...
		}

	Extracting a construction and transferring its radius :

		macro ( "hole*" ) : {
			with "radius" ;
			...
		}

	Extracting equipment and transferring certain attributes :

		equipment : {

			with	"attr1", "attr2" ;
			...
			...
		}


	IV Specification of element representation in drawing sheet
	-----------------------------------------------------------

	A.1) General Representation types for object 

	"vis-edges-A"	: visible edging
        "vis-edges-B"   : visible edging and opaque hidden line
        "vis-edges-C"   : visible edging, opaque and self-hidden lines
        "env-edges-A"   : vis-edges-A for envelopes
        "env-edges-B"   : vis-edges-B for envelopes
        "env-edges-C"   : vis-edges-C for envelopes
        "member-A"      : component member of object using vis-edges-A
        "member-B"      : component member of object using vis-edges-B
        "member-C"      : component member of object using vis-edges-C
	"placemacro"	: Indivisual macro placement.

	A.2) Representation type for specific object
 
        Compartment
	===========
 
        "contour"       : To extract floor of the compartment.
        "intersection"  : To extract cross section of the compartment.
        "filled-display": Can be used with contour/intersection to display the
                          plane of contour/intersection.
        "cog"           : To extract center of gravity of the compartment.

	Beam and Stiffener
	====     =========

        "projection"    : project beam onto drawing sheet
        "axis"          : draw axis of element onto drawing sheet
	"axis-A"	: draw visible edging axis
	"axis-B"	: draw visible edging and opaque hidden axis
        "profile"       : draw profile of beam onto drawing sheet
        "intersection"  : as "profile" above

	Plate
	=====

        "projection"    : project plate onto drawing sheet
        "intersection"  : intersect plate and plane of view then project
                          intersection onto drawing sheet.
        "contour"       : draw contour of plate onto drawing sheet (will not
                          output inside holes)
        "edge"          : draw edge of plate onto drawing sheet`

	Joint
	=====

        "weldline"      : draw weld line onto drawing sheet (may amount to
                          a point if seen end-on)

	Pipe
	====
	
        "centerline"    : draw centerline of element onto drawing sheet
	"centerline-A"	: draw visible edging centerline
	"centerline-B"	: draw visible edging and opaque hidden centerline

	B Syntax

	   <representation>
	or <representation> [ <display-attributes> ]

	<display-attributes> :  <display-attribute>
			     or <display-attribute> , <display-attribute>, ...

	<display-attribute>  :  <attribute>
			     or <attribute> = <value>

	where	<representation> is among those specified in A).
		<display-attributes> are attributes for the display of
		the drawn element in the drawing sheet.
		
	C) Display attributes

	<attribute> is one among "color", "style", "weight", "level",
			"hidden-color", "hidden-style", "hidden-weight",
			"hidden-level", "filled-display".

	i) Color (or hidden-color)

		May be specified by name (red, green, blue, yellow, 
	cyan, etc.) or by number:

		color = "red"
		color = 3

		If "color" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid name or number (not between 0 and 511) is specified.

	ii) Style (or hidden-style)

		Specifies the style for the visible lines of the drawn
	element and is an integer:

		style = 1

		If "style" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid number (not between 0 and 255, system styles being from
	0 to 7 and user-defined styles from 8 up) is specified.

	iii) Weight (or hidden-weight)

		Must be specified as an integer :

		weight = 2

		If "weight" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid number (not between 0 and 31) is specified.

	iv) Level (or hidden-level)

		Must be specified as an integer :

		level = 3

		If "level" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid number (not between 0 and 1023) is specified.

	D) Examples

		beam :
		{
			vis-edges-B [ color = 5 ]
		}
	or
		equipment :
		{
			vis_edges-C [ weight = 2,
				      color  = "blue" ]
		}

		macro ( "hole" ) :
		{
			member-A( "curve" ) [
				style = 1,
				weight= 1
			]
			
		}

	V Specification of symbol to be placed next to drawn element
	------------------------------------------------------------

		By symbol we mean text, a radius symbol being a character
	in a special font.

	A) Syntax

	<symbol-placement> : "symbol" [ <symbol-attributes> ]

	<symbol-attributes> :  <symbol-attribute>
			    or <symbol-attribute> , <symbol-attribute> , ...

	<symbol-attribute>  :      <display-attribute>
			    and/or <text-attribute>

	<text-attribute> : <format>
                           <font>
                           <justification>
			   <size>
			   <width>
			   <height>
			   <position>

	B) Display attributes

		"color", "weight", "style" whose logics are the same as those
	developed in IV C) i), ii) and iii).

	C) Justification

		If not specified, a justification will be chosen by the sys-
	tem according to the context (element being drawn, text position,
	etc.). If specified the system's choice will be overridden.

	<justification> : "justification" = <value>
	<value> : "LEFT-BOTTOM"		(1)
		  "LEFT-BASE"		(2)
		  "LEFT-CENTER"		(3)
		  "LEFT-CAP"		(4)
		  "LEFT-TOP"		(5)
		  "CENTER-BOTTOM"	(6)
		  "CENTER-BASE"		(7)
		  "CENTER-CENTER"	(8)
		  "CENTER-CAP"		(9)
		  "CENTER-TOP"		(10)
		  "RIGHT-BOTTOM"	(11)
		  "RIGHT-BASE"		(12)
		  "RIGHT-CENTER"	(13)
		  "RIGHT-CAP"		(14)
		  "RIGHT-TOP"		(15)

	These values are exactly those of the text in I/EMS :


		5------------10----------15
		4------------9-----------14
		3 textextext 8 textextex 13
		2------------7-----------12
		1------------6-----------11

	D) Width

		Specifies the width of the text (floating-point value) :

		width = 2
		width = 4.5

	If not specified the Active Text Width will be used.

	E) Height

		Specifies the height of the text (floating-point value) :

		height = 2
		height = 4.5

	If not specified the Active Text Height will be used.

	F) Size

		Sets the width and height at the same time (floating-point
	value) :

		size = 2
		size = 4.5

	G) Position

	<position> : "position" ( <pos-attributes> )
	<position-attribute> :   <pos-attribute>
			      or <pos-attribute> , <pos-attributes> , ...

	<pos-attribute> : "top"					(A)
			  "bottom"				(A)
			  "left"				(A)
			  "right"				(A)
			  "at-first-end"			(A)
			  "at-second-end"			(A)
			  "center"				(A)
			  "middle"				(A)
			  "innermost"				(A)
			  "above" ( <value> )		
			  "below" ( <value> )
			  "to-the-left" ( <value> )
			  "to-the-right" ( <value> )
			  "offset" ( <direction> , <value> )
			  "horizontal"				(B)
			  "parallel"				(B)
			  "orthogonal"				(B)
			  "not-reversed"
			  "upside-down"
			  "right-to-left"

	All (A)'s and all (B)'s are mutually exclusive.

	i) "top", "bottom", "left", "right"

		At the top, bottom, left, right of the drawn element (these
	directions are understood from the drawing sheet point of view) :

		           TOP				TOP
		LEFT --------------- RIGHT               |
		          BOTTOM                    LEFT | RIGHT
							 |
                                                       BOTTOM

	ii) "center", "middle", "innermost"

		If the drawn element is an open curve, "center" and "middle"
	both coincide with the midpoint; if it is a closed curve, "center"
	is the center of the curve and middle its midpoint (wherever it is)

		-----CENTER-----	+-MIDDLE--------+
					|		|
		-----MIDDLE-----	|    CENTER	|
					|		|
					+---------------+

		"innermost" is the most interior point to a curve, that is
	the point surrounded by as much area as possible; "innermost" is
	different from "center" in that in lies always inside the closed
	planar curve whereas "center" may be outside.

	iii) "at-first-end", "at-second-end"

		The first and second end of drawn element are

	        | Element is horizontal | Element is vertical
	--------|-----------------------|------------------
	1st end	| leftmost end          | uppermost end
	2nd end | rightmost end         | lowermost end

		FIRST END --------------- SECOND END	FIRST END
							    |
							    |
							SECOND END

		If none of "top", "bottom", "left", "right", "center",
	"middle", "innermost", "at-first-end", "at-second-end" is specified,
	then "center" will be used.

	iv) "above", "below", "to-the-left", "to-the-right", "offset"

		Specifies an additional offset distance from the position:

				       ABOVE
                                         +
			TO THE LEFT + position + TO THE LEFT
					 +
                                       BELOW

	A value ( floating-point value) must be specified :

		above( 1 )
		to-the-left( 3.4 )

	"offset" groups "above", "below", "to-the-left" and "to-the-right"
	together :

	offset( top   , <value> ) is equivalent to above( <value> )
	offset( bottom, <value> ) is equivalent to below( <value> )
	offset( left  , <value> ) is equivalent to to-the-left( <value> )
	offset( right , <value> ) is equivalent to to-the-right( <value> )

	By default, no offsetting is performed.

	v) "parallel", "orthogonal", "horizontal"

		Specifies the direction of the text with respect to the
	element it is placed nearby:

						^
		PARALLEL --->		        | ORTHOGONAL
		------------------	------------------

	If neither "parallel" or "orthogonal" is specified, the text will
	be placed horizontal.

	vi) "upside-down", "right-to-left", "not-reversed"

		Will reverse the text either upside down :

		xxxxxxx                   x
                x                         xxxx
                xxxx      -upside down->  x
                x                         xxxxxxx

	or right to left

		xxxxxxx                     xxxxxxx
                x                                 x
                xxxx      -right to left->     xxxx
                x                                 x

		By default, text is written left to right and top down,
	that is "not-reversed".

	H) Font

		Specifies the font to be used for text: a character string
	containing the name of a physical font :

		font = "myfont"
		font = "102"

		If not specified, the default font (whose name is "default")
	will be used.

	I) Format

		The format attributes allow to specify the text string to
	be output, but also to embed text commands for a more sophisticated
	text.

	<format> : "format" = ( <commands-or-strings> )
	<commands-or-strings> :  <command-or-string>
			      or <command-or-string>,
			         <command-or-string> , ...

	<command-or-string> : <command>
			      <string>

	To output "ABC" :
			format = ( "ABC" )

	Note that empty text will not be placed, i.e.

			format = ( "" )

	will not construct a text.

	Commands allow to move the cursor inside the text, change font,
	define fields, move to those fields :

	<command> : "UP" ( <value> )
		    "DOWN" ( <value> )
		    "RIGHT" ( <value> )
		    "LEFT" ( <value> )
		    "SCALE" ( <value> )
		    "FONT" ( <physical-font-name> )
		    "START-FIELD"( <field-number> )
		    "END-FIELD"
		    "MOVE-TO-FIELD"( <field-number>, <justification-point> )

	UP     : moves cursor up    by <value> (floating-point value)
	DOWN   : moves cursor down  by <value> (floating-point value)
	RIGHT  : moves cursor right by <value> (floating-point value)
	LEFT   : moves cursor left  by <value> (floating-point value)
	SCALE  : scales following text by <value> (floating-point value)
	FONT   : changes font for the following text
	START-FIELD   : starts field number <field-number> (integer 0-255)
	END-FIELD     : ends last-started field
	MOVE-TO-FIELD : moves cursor to field <field-number> ( supposed
			previously defined by a START-FIELD/END-FIELD
			sequence ) and positions cursor at
			<justification-point> (one among LEFT-BOTTOM, etc.
			defined at V C) ).

	For instance, to output :

		      I am upstairs
		Hello
		      I am downstairs

	Use
	format	= (
		    START-FIELD( 0 ),		      # Start field 0
		    "Hello",			      # Fill it with "Hello"
		    END-FIELD,			      # End field 0
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ), # Go back to field
		    UP( 0.5 ),			      # Move up
		    "I am upstairs",		      # Say "I am upstairs"
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ), # Go back to field
		    DOWN( 0.5 ),		      # Move down
		    "I am downstairs"		      z# Say "I am downstairs"
		   )

	Which amounts to the following cursor movement :

			 ^ UP I am upstairs ----->-----------+
		+-------+|				     v
		| Hello |<- MOVE TO FIELD 0, RIGHT CENTER <--+
                +-------+|
		^       ^v DOWN I am downstairs
		|       |
		|       END FIELD 0
		START FIELD 0

	J) Available global text values

		WIDTH, HEIGHT : always set to the current text width and
	height

		LEFT-BOTTOM	: 1
		LEFT-BASE	: 2
		LEFT-CENTER	: 3
		LEFT-CAP	: 4
		LEFT-TOP	: 5
		CENTER-BOTTOM	: 6
		CENTER-BASE	: 7
		CENTER-CENTER	: 8
		CENTER-CAP	: 9
		CENTER-TOP	: 10
		RIGHT-BOTTOM	: 11
		RIGHT-BASE	: 12
		RIGHT-CENTER	: 13
		RIGHT-CAP	: 14
		RIGHT-TOP	: 15

	The example in i) may be rewritten so as to make it text-height
	dependent :

	format	= (
		    START-FIELD( 0 ),
		    "Hello",
		    END-FIELD,
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
		    UP( 0.5 * HEIGHT ),
		    "I am upstairs",
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
		    DOWN( 0.5 * HEIGHT ),
		    "I am downstairs"
		   )

	K) Use of an anchor point or an anchor curve

		There may be cases when a macro occurrence is to be repre-
	sented on the drawing sheet by a symbol and nothing else. In this
	case a point is needed to position the symbol, which must be relative
	to the macro occurrence. The statement "anchor-point" is available
	for extraction of macro occurrences and is evaluated with the help
	of an output (a "member"):

	const ( definition = "hole*", view-criterion = "curve" ) : {

		top : {
			# Use the center of member "curve" for subsequent
			# symbol placement.

			anchor-point( "curve", center ) ;

			symbol [ ... ]

			...
		}
		...
	}

		The syntax of the "anchor-point" statement is :

			anchor-point( <member>, <which-point> )
		or	anchor-point( <member> )

	Where <member>	    : a member of the macro occurrence.
	      <which-point> : specifies which point to use.

	There are currently 3 possible values for <which-point> :

		center
		center-of-gravity
		average-point

	anchor-point( <member> ) is equivalent to
	anchor-point( <member>, average-point )

	The following logic is used to evaluate the anchor point :

	a) If which-point is not specified or is 'average-point' the fol-
	   lowing will be done :
	- the range of the member will be computed
	- the center of the range box will be projected onto the
	  drawing sheet and will be taken as the anchor point

	This behavior above will of course give the expected result if the
	member is a point or a coordinate system since their range boxes
	are reduced to a point.

	b) If which-point is 'center' :
	- if member is a closed curve, its center will be computed and then
	  projected onto the drawing sheet, if it is not closed its mid-point
	  will be used.
	- if member is a point (or a coordinate system) the point (or the
	  origin) will be projected onto the drawing sheet.
	- if member is a surface, the point at u=0.5, v=0.5 will be projected
	  onto the drawing sheet.
	- if member is a solid or a composite surface, the center of the
	  range box will be used as in a)

	c) If which-point is 'center-of-gravity'
	- member is a point : use point as in a)
	- member is a coordinate system : use origin as in a)
	- member is a curve : use center as in b)
	- member is a surface or a solid : use center of gravity.

		There may be other cases when the symbol must be positioned
	with respect to a curve that will not be output to the drawing sheet.
	In this case the "anchor-curve" statement allows to specify a curve
	which will be used to position the text :

		The syntax of the "anchor-curve" statement is :

			"anchor-curve" ( <curve> )

	where <curve> is a curve obtained by means of the functions
	"get-input()", "get-member()" and then projected to the drawing
	sheet with the function "project-curve()" [see chapter VIII].

	Note: when outputting several members of a construction and asso-
	ciating a symbol with them, it is necessary to specify anchor-curve
	or anchor-point for each symbol output: if not anchor is specified,
	the symbol will by default try to position itself with respect to
	all the curves which have been previously output:

		member-A( "m1" ) [ weight = 1 ] ;
		anchor-curve( get-member( "m1" ) ) ;
		symbol [ ... ] ;

		member-A( "m2" ) [ weight = 1 ] ;
		anchor-curve( get-member( "m2" ) ) ;
		symbol [ ... ] ;

	L) Examples

	- Outputting text parallel to element

		symbol [	format	= ( "Hello" )
				position= (at-first-end,parallel),
				color	= "green",
				weight	= 1,
				size	= 3
			]

	- Outputting arrows at both ends of element
 	  The arrowhead symbol ( ">" ) is character "A" of font "102"; this
	  font does not provide the reverse arrowhead ( "<" ), hence we must
	  include the reversal as a position modifier.

		# Output ">"
		# - At 1st end of element
		# - // to element
		# - right to left (reversal)
		symbol	[
				format		= ("A"),
				font		= "102",
				position	= (at-first-end,
						   parallel,
						   right-to-left)
			] ;
		# Output ">"
		# - At 2nd end of element
		# - // to element
		symbol	[
				format		= ("A"),
				font		= "102",
				position	= (at-second-end,parallel)
			] ;

	VI Expressions and operations
	-----------------------------

		"Visual" provides for expressions and operations between
	them ( as has been seen in "HEIGHT * 0.5" in V J ).

	The operators are
		"+"
		"-"
		"*"
		"/"
		"**"		(exponentiation)
		"&" "and"	logical AND
		"|" "or"	logical OR
		"!" "not"	logical NOT
		"="		equal
		"!="		not equal
		"<"		less than
		"<="		less than or equal to
		">"		greater than
		">="		greater than or equal to
		"(" ")"		priority modifiers

	Note :
		In <operand1> "and" <operand2>
		<operand2> is not evaluated if <operand1> is FALSE.

		In <operand1> "or" <operand2>
		<operand2> is evaluated only if <operand1> is TRUE.
		
	VII Constant values
	-------------------

		They exist in four types
			- integers
			- floating point numbers
			- character strings (delimited by double quotes)
			- units

	Units are specified as

			<value> <unit-type>

		E.g.	2 mm, 1.3 in, 3 m, 0.32 ft

	and are systematically converted to system units :

			1 m + 100 mm -> 1100 (if system unit is "mm")

	Example
		symbol	[
				format		= ("HELLO"),
				size		= 3 mm
			] ;

	Strings must have at most 63 characters, bigger strings will be
	truncated.

	When a value is an operand of a logical operator (and, or, not) it
	is taken to be true if it is a non-zero number or a non-empty string
	and false if it is zero or an empty string.

	VIII Functions
	--------------

	A) Accessing attributes of the element : "attribute()"

		The "attribute()" function returns the value of an attribute
	an element. It takes one or two arguments :

		1) the name of the attribute
		2) the element whose attribute is wanted (optional)

	If no second argument is specified then the element being extracted
	will be used.

		attribute( "memb_cut_len" ) returns the length of a beam.

	For example, to output the following text next to a beam:

		      wtee
		BEAM14
		      W10x20x30

	symbol [
		format	= (
			    START-FIELD( 0 ),
			    attribute( "memb_name" ),
			    END-FIELD,
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    UP( 0.5 * HEIGHT ),
			    attribute( "family_name" ),
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    DOWN( 0.5 * HEIGHT ),
			    attribute( "part_num" )
			   ),
		position = ( right )
		]

		On error (e.g. invalid number of arguments, unknown attribute)
	the function returns the value 0.

	B) Formatting numbers for text output : "format-number()"

		This functions format a number to be inserted in a text
	format:

		"format-number" ( <format> , <value> )
	
	where  <format> : character string specifying the format :
				<integer><delimiter><integer>
	       <value>  : the value to be formatted

	<delimiter> can be any character (in particular "." or ",").

	Examples
		format-number( "5.3", 123.45 ) -> "123.450"
		format-number( "5,1", 123.45 ) -> "123,5" (rounded)
		format-number( "5 1", 123.45 ) -> "123 5" (rounded)

	C) Retrieving the scale of the element : "drawing-scale()"

		If the element being extracted is in a reference file,
	the function "drawing-scale()" (no argument) will return the scale
	that was used when the file was attached (a double floating point
	value). For example, if the reference file was attached with scale
	1:100, drawing-scale() will return 0.01.

		If the element being extracted is not in a reference file,
	drawing-scale() will return 1.
	

	D) Retrieving the type of a construction : "const-type()"

		The function "const-type()" returns the type of the
	construction being processed (no argument) or of some specified
	element (one argument). It is useful when the definition of the macro
	has been specified with a regular expression to know exactly which
	kind of construction is being processed :

		const ( "hole*" ) : {

			$constType := const-type() ;
			select
				when $constType = "hole10" :
					...
				when $constType = "hole20" :
					...
			...
		}

        E) Finding a member of an element : "get-member()"

                The function "get-member()" returns a member of an
        element. It takes one or two arguments :

                1) the name of the member
                2) the element whose member is wanted

        If the second argument is not specified, then the element being
        processed will be used.

        Suppose we want the member "coordsys" of const "hole" :

                const ( "hole" ) : {
                        ...
                        $coordsys := get-member( "coordsys" ) ;
                        ...
                }

        Or we want member "line" of input "axis" of const "hole" :

                const ( "hole" ) : {
                        ...
                        $axis := get-input( "axis" ) ;
                        $coordsys := get-member( "line", "axis" ) ;
                        # NOTE
                        # The two calls above can be made in one go :
                        # $axis := get-member( "line", get-input( "axis" ) ) ;
                        ...
                }


	F) Matching a string against a regular expression : "match-regexp()"

		The function "match-regexp()" allows to match a character
	string against a regular expression, it	returns 1 (TRUE ) if the
	string matches the regular expression else 0 (FALSE) :

		"match-regexp" ( <regular expression>, <character string> )

	where : <regular expression> has the same syntax as those of the UNIX
	        shell
	        <character string> is a character string.

	For example :

		const ( "hole*" ) : {

			...
			$type := const-type() ;
			#
			# Same treatment for (et1,et2,et3).
			# Same treatment for (et4,et7,et7).
			# Treat et6 alone.
			select
				when match-regexp( "et[1-3]", $type ) :
				...
				when match-regexp( "et[457]", $type ) :
				...
				when $type = "et6" :
				...
			...
		}

	Q) String manipulation functions

	 - Duplicating a character string : "dup-string()"

		The function "dup-string", given a string and a count n,
	will duplicate it n times :

		dup-string( "-", 5 ) will return "-----".

	 - Concatenating strings

		The function "catenate-strings" catenates n strings:

			catenate-strings( "abc", "def", 123 )

	will return "abcdef123".

	 - Computing the length of a character string : "string-length"

		
	characters in a character string :

		string-length( "Hello" ) will return 5.

	- Getting the count of word in a string : "word-count()"

		The function "word-count" will return the number of words
	in a string; a word is a sequence of characters separated by spaces
	(blanks, tabs or newlines):

		word-count( "Hello world" ) will return 2.

	- Getting a word in a string : "get-word()"

		The function "get-word" will return the n-th word of a string;
	words are numbered from 0 to number-of-words - 1:

		get-word( "Hello world", 0 ) will return "Hello".
		get-word( "Hello world", 1 ) will return "world".
		get-word( $s, word-count( $s ) - 1 ) will return the last
		word of string $s.

	- Extracting a sub-string from a string : "sub-string()"

		The function "sub-string" will extract the characters from
	a string given the starting end ending position; characters are
	numbered for 0 to length-of-string - 1:

		sub-string( "Hello world", 0, 2 ) will return "Hel".
		sub-string( "Hello world", 4, 4 ) will return "o".
		sub-string( $s, 1, string-length( $s ) - 1 ) will
		returns string $s with its first character removed.

	- Substituting a sub-string by another : "substitute-string()"

		The function "substitute-string" replaces n occurrences of
	a sub-string withing a string by another:

		substitute-string(	<input string>,
					<sub-string to replace>,
					<replacement sub-string>,
					<number of replacements wanted> )

	and returns a string with the substitutions.

		substitute-string( "abcdef", "cd", "123", 1 )
			will return "ab123ef"
		substitute-string( "abcdefcd", "cd", "123", 1 )
			will return "ab123efcd"
		substitute-string( "abcdefcd", "cd", "123", 2 )
			will return "ab123ef123"
		substitute-string( "abcdefcd", "cd", "123", 5 )
			will return "ab123ef123"
		substitute-string( "abcdefcd", "cd", "123", 0 )
			will return "abcdefcd"

	To have all occurrences replaced set the number of replacements wanted
	to some big number.

	- Getting the time and date
		The function "time" returns the date and the time of day in
	various formats
			time( <format> )

	where format is a character string in which the special controls
	listed below will be interpreted

	%%   Same as %.
	%a   Abbreviated weekday name (e.g. Mon).
	%A   Full weekday name (e.g. Monday).
	%b   Abbreviated month name (e.g. Apr).
	%B   Full month name (e.g. April).
	%d   Day of month (01 - 31).
	%D   Date as %m/%d/%y
	%e   Day of month (1 - 31).  Single digits are preceded by a blank.
	%H   Hour (00 - 23).
	%I   Hour (00 - 12).
	%j   Day number of year (001 - 366).
	%m   Month number (01 - 12).
	%M   Minute (00 - 59).
	%p   Ante meridian or post meridian.
	%r   Time as %I:%M:%S %p.
	%R   Time as %H:%M.
	%S   Seconds (00 - 59).
	%T   Time as %H:%M:%S.
	%U   Week number of year (00 - 53).  Sunday is the first day of week.
	%w   Weekday number.  Sunday = 0.
	%W   Week number of year (00 - 53).  Monday is the first day of week.
	%y   Year within century (00 - 99).
	%Y   Year as ccyy (e.g. 1994).
	%Z   Time zone name (e.g. EUR, CDT)

	Examples:
		time( "%A %d %B" ) will return "Friday 13 April"
		time( "Today is %B %dth" ) will return "Today is Apr 13th"

	R) Intersection a curve with the view plane :
						"intersect-curve-with-view()"

		The function "intersect-curve-with-view" is intended to obtain
	a point when intersecting a curve traversing the view plane so as to
	position a symbol afterwards. This function is input to an object, which
	may be obtained via functions returning objects, such as "get-input"
	and "get-member"; this object is supposed to be a curve intersecting
	with the view plane to yield a point, this point is then projected
	onto the drawing sheet along the view vector.

	Example:

		$line  := get-member( "line" ) ;
		$point := intersect-curve-with-view( $line ) ;
		anchor-curve( $point ) ;
		symbol [ format = ( "Hello" ) ] ;

		This function will fail if the input object is not a curve or
	if the curve does not intersect the view plane.

	H) Getting the basename of an element : "basename()"

		The function "basename" returns the name of an element: the
	base name is the last part of the element's name (if it has one):

		the basename of a:b:c:d is "d"

		If it is called with no arguments, "basename" will return the
	basename of the element being processed:

		$n := basename() ;

		But it may be called with an element ( as returned, say, by
	"get-input" ) ;

		$element := get-input( "curve" ) ;
		$n	 := basename( $element ) ;

		If the element is not named, then "basename" returns an empty
	string ("").

	J) Obtaining information from the relational data base
	------------------------------------------------------

		The function "query-database" can be used to retrieve infor-
	mation from the relational data base via a RIS query statement:

		$result := query-database( "<RIS statement>" ) ;

		The value returned is an array of strings which can be
	accessed by	$result[0]
			$result[1]
			...
			$result[size-of-array( $result )-1]
	Example
		query-database( "SELECT item FROM sometable WHERE a < 1" ) ;

	This call will fail if one is not logged into the database or if
	the RIS statement is incorrect.

	K) Obtaining information from the design file
	---------------------------------------------

	The following functions will retrieve information from design file:
		get_objid():	Get active Object Id.
		get_osnum():	Get active Object Osnum.
		get_macro():	Get Name of the macro.
		get_curfile():	Get current design file.
		get_objfile():	Get design file of selected object.
		get_dyntable():	Get Name of dynamic table of object.

	L) Obtaining information from PPL files.

		Functionality is added to execute a PPL program from the
	parser (with arguments) and the result of the program can be
	written back into the system.

		$value := exec-ppl-func( "filename" );
		$value := exec-ppl-func( "filename", "functionname" );
		$result := exec-ppl-func( "filename", "functionname",
					 $arg0, $arg1, ... );
		The value returned can be an individual value or an array of
	strings which can be accessed by

			$result[0]
			$result[1]
			...
			$result[size-of-array( $result )-1]

	For example see below:


	M) Obtaining information from Expression (Dababase storage).

	We can create expression (strings) which will be stored in the DB.
	These expression can be retrieved for execution inside the parser.
	Syntax:
	
		$value := exec-expression("expression_name");
		$value := exec-expression("expression_name", $object );

	compartment : {
 
       	This is useful to process a given expression "exp1" on the current
       	object.

          $value := exec-expression("exp1");
 
        When "exp1" should be processed with other object. User has to
        create one ppl like "APIexec_exp.u" to identify the required object

          $object := exec-ppl-func( "FunctionFile", "main" );
          $value  := exec-expression("exp1", $object);
 
        This function returns the value of the given attribute say "volume"
        of the current object.

          $dynselect := dyn-select("volume");
 
        When value should be got from the give dynamic table like
        "compart_dynamic".

          $dynselect := dyn-select("volume","compart_dynamic");
 
        Returns the object id of the current object

          $objid := get-objid();
 
        Returns the object space number of the current object

          $osnum := get-osnum();
 
        Retunrs macro name of object

          $macro := get-macro();
 
        Returns file name of active file

          $curfile := get-curfile();
 
        Returns file name of the current object

          $objfile := get-objfile();
 
        Retuns name of the dynamic table which current object will be posted

	  $dyntable := get-dyntable();

	IX Conditionals
	---------------

		select, when, otherwise, end

		select    : introduces a conditional (possibly with multiple
		            branches)
		when      : introduces a condition
		otherwise : introduces the action when all when's were not
		            satisfied
		end	  : terminates conditional

	A) Syntax

		"select"
			"when" <condition 1 is satisfied> :
				<action 1>
			"when" <condition 2 is satisfied> :
				<action 2>
			"otherwise" :
				<default action>
		"end"

		<condition> is one or several elementary conditions ORed,
		ANDed or negated such as :

		- when attribute( "composite" )
		- when attribute( "part_num" ) = "W10x20x30"
		       and not attribute( "composite" )

		The above conditional exists in degenerated forms :

		No "otherwise" : nothing done if no "when" is satisfied :

		"select"
			"when" ... :
			"when" ... :
		"end"

		One "when" only with or without "otherwise" :

		"select" "when" <condition> : <action>
			 "otherwise"        : <default> "end"
		"select" "when" <condition> : <action> "end"

		Conditionals may be nested.

	B) Example
		select
			when attribute( "plate_type" ) = "water_tight" :
				select when $certification :
					edge [style=1]
				otherwise :
					edge [style=2]
				end ;
			when attribute( "plate_type" ) = "gas_tight" :
				# do something
			otherwise
				# do something
		end

	X Variables
	-----------

		"Visual" provides for variables to allow for global flags to
	be defined or to improve readability.
		A variable must start with a `$' (dollar sign) followed by an
	identifier :
			$a
			$abc
			$_1
			$a1b2

	Variable names must have at most 63 characters, bigger names will be
	truncated.

		The assignment operator is `:=' :

			$a := "Hello"
			$a := 1.2
			$a := 13 ft
			$a := HEIGHT * 2 + WIDTH
			$a := $b - 0.3 * $c ** 2

	All variables are initialized to their name, hence if "$a" has not
	been assigned a value and we have $b := $a then $b's value will be
	"$a".

	Variable assignment may appear anywhere an action may appear but
	also at the top of the "Visual" file, before all selections on
	element types :

	$a := 1 ;
	$name := attribute( "part_num" ) ;

	plate : {
		...
	}

	For example, to have a global file allowing to differentiate between
	a fabrication drawing or a certification drawing, one may define
	at the top of the file :

	$fabrication := 1	# Taken to be "true"

	...
	select when $fabrication : ...
	end

	Or

	$mode := "fabrication" ;

	...
	select when $mode = "fabrication" : ...
	end

	Our text examples may be yet rewritten using variables

	$delta		:= 0.5 * HEIGHT ;
	$name		:= attribute( "memb_name" ) ;
	$type		:= attribute( "family_name" ) ;
	$profile	:= attribute( "part_num" ) ;
	$textColor	:= "yellow" ;
	$textWeight	:= 1 ;
	symbol [
		format	= (
			    START-FIELD( 0 ),
			    $name,
			    END-FIELD,
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    UP( $delta ),
			    $type,
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    DOWN( $delta ),
			    $profile
			   )
		color = $textColor,
		weight= $textWeight
		]

	Variables may be assigned the following text position values:
			"top"
			"bottom"
			"left"
			"right"
			"at-first-end"
			"at-second-end"
			"center"
			"middle"
			"innermost"
			"horizontal"
			"parallel"
			"orthogonal"
			"not-reversed"
			"upside-down"
			"right-to-left"

	and then be used inside a "position" list :

		$where	:= at-first-end ;
		$how	:= parallel ;
		symbol [ position = ( $where, $how ), ... ]

	Some functions which generate more than one item return an array.
	The elements of an array of n elements are numbered from 0 to n-1.
	The i-th array of an arrray $a is accessed by

				$a[<index>]

	The number of elements in array $a is obtained by

				size-of-array( $a )

	XI  Manipulating the relational data base
	-----------------------------------------

		It is sometimes desriable to report in the relational
	database the elements which have been processed. This can be done
	with the "updata-database" instruction:

		updata-database[ statement = <RIS update statement> ]

	For instance, to update the beam being processed using its base
	name as a selection criterion:


  	update-database[
  	  statement = catenate-strings(
	         "UPDATE struct_bm_dynamic SET chg_no = 1 WHERE memb_name = '",
	         basename(),
	         "' AND chg_no = 0"
	        )
  	]

	An update-database instruction will fail if one is not logged into
	the database or if the RIS statement is incorrect.

	XIII Debugging
	--------------

		To allow for fine tuning of "Visual" file and discovering
	errors a trace facility is implemented :

		"verbose" : turns on verbose mode
		"silent"  : turns off verbose mode

	By default, "Visual" does not output any errors. If verbose is on,
	the execution trace is output to the terminal (standard output).

	You may choose to have the trace of the execution to be written to
	a file by putting the statement :

		set logfile <filename> ;

	in your "Visual" file :

		set logfile "drawing.log" ;
	or	set logfile "/usr/tmp/drwlog" ;

	"verbose" and "silent" may appear at the same locations as variable
	assignments :

	beam : {
		vis-edges-A [ style = 1 ] ;
		verbose ;
		symbol [ ... ] ;
		silent
	}

	The following portion of "Visual" file :

	verbose ;
	$fabrication := 1 ;

	stiffener : {

		....

		symbol	[
			format	= (
				    START-FIELD( 0 ),
				    "Hello",
				    END-FIELD,
				    MOVE-TO-FIELD( 0, RIGHT-BASE ),
				    UP( HEIGHT * 0.5 ),
				    "I'm upstairs",
				    MOVE-TO-FIELD( 0, RIGHT-BASE ),
				    DOWN( HEIGHT * 0.5 ),
				    "I'm downstairs",
				    FONT( 102 ),
				    "ABC"
				   ),
			position= (parallel),
			color	= "green",
			weight	= 0,
			style	= 0,
			size	= 3 inch
		]
	}
		

	Will output the following trace :

 Line number in "Visual" file
   |
   V
>> Object 2, 171
   2 *-* Variable setting $fabrication <- 1
   4 *-* Element type 'stiffener' : Yes
   5 *-* View top
   7 *-* Output symbol with
         > format =
         > START-FIELD = 0
         > string = 'Hello'
         > END-FIELD =
         > MOVE-TO-FIELD = 0
  13 OP 3 * 0.5 -> 1.5
         > UP = 1.5
         > string = 'I'm upstairs'
         > MOVE-TO-FIELD = 0
  16 OP 3 * 0.5 -> 1.5
         > DOWN = 1.5
         > string = 'I'm downstairs'
         > FONT = '102'
         > string = 'ABC'
  20 *-* End (format at 8)
         > position =
         > parallel
  21 *-* End (position at 21)
         > color = 'green'
         > weight = 0
         > style = 0
  25 *-* Unit conversion: 3 inch -> 3
         > size = 3
  26 *-* End (symbol at 7)
  59 *-* Element type 'beam' : No
  70 *-* Element type 'plate' : No
  80 *-* Element type 'joint' : No
>> End object 2, 171

	XVI File inclusion
	------------------

		The visual file may be split up in several files which are
	included via the "include" statement :

		include "<file name>" ;

	Included files may themselves include files, the level of nesting
	being limited to 10.

	The search for the included files follows the following rules:

	  - if an absolute path is specified ( e.g. "/usr/me/myvisual" )
	    then only the directory specified in the path is explored.

	  - if a relative path is specified ( e.g. "setups/visual_1" )
	    then the directory where the last search was successful
	    is tried first, then the directories "config/drawing" in the
	    product paths:

		1 <last-directory>/setups/visual_1
		2 <user-path>/config/drawing/setups/visual_1
		3 <struct-dir>/config/drawing/setups/visual_1
		4 <vds-dir>/config/drawing/setups/visual_1
		etc.

	    (2) is available if I/STRUCT is started with the option -S

			struct -cf myfile -S <user-path>

	    The <last-directory> in (1) is defined as follows

 FILE SCANNED			FIRST SEARCHED IN	LAST-DIRECTORY SET TO

 "visual"			"."            		<D>
 | include "setups/visual_1"	<D>			<D>/setups
 | | include "../a/visualA"	<D>/setups		<D>/setups/a
 | | include "../b/visualB"	<D>/setups		<D>/setups/b
 | include "setups/visual_2"	<D>    	


	XV  Definition of the language
	------------------------------

	A) List of keywords

	Keyword			| Related topic
	_______________________________________________________________
	CENTER-BASE		| Justification point of text
	CENTER-BOTTOM		| Justification point of text
	CENTER-CAP		| Justification point of text
	CENTER-CENTER		| Justification point of text
	CENTER-TOP		| Justification point of text
	DOWN			| Cursor movement inside of text
	END-FIELD		| End-of-field marker inside of text
	FONT			| Change-font statement inside of text
	HEIGHT			| Change-height statement inside of text
	LEFT			| Cursor movement inside of text
	LEFT-BASE		| Justification point of text
	LEFT-BOTTOM		| Justification point of text
	LEFT-CAP		| Justification point of text
	LEFT-CENTER		| Justification point of text
	LEFT-TOP		| Justification point of text
	MOVE-TO-FIELD		| Cursor movement inside of text
	RIGHT			| Justification point of text
	RIGHT-BASE		| Justification point of text
	RIGHT-BOTTOM		| Justification point of text
	RIGHT-CAP		| Justification point of text
	RIGHT-CENTER		| Justification point of text
	RIGHT-TOP		| Justification point of text
	SCALE			| Change-scale statement inside of text
	START-FIELD		| Beginning-of-field marker inside of text
	UP			| Cursor movement inside of text
	WIDTH			| Change-width statement inside of text
	above			| Text position
	anchor-curve		| Text position
	anchor-point		| Text position
	and			| Relational operator
	any-view		| View selector
	as			| Part of 'extract' introducing output type
	average-point		| Text position/anchor point
	at-first-end		| Text position
	at-second-end		| Text position
	attribute		| Function
	basename		| Function
	below			| Text position
	bottom			| Text position
	catenate-strings	| Function
	center			| Text position/anchor point
	center-of-gravity	| Text position/anchor point
	color			| Symbology for output
	const-type		| Function
	definition		| Selection of construction type
	drawing-scale		| Function
	dup-string		| Function
	end			| End of conditional
	end-on			| View type
	env-edges-A		| Graphic output
	env-edges-B		| Graphic output
	env-edges-B		| Graphic output
	filled-display		| Symbology for output
	font			| Font for text output
	format			| Format for text output
	format-number		| Function
	get-input		| Function
	get-member		| Function
	get-word		| Function
	height			| Height for text output
	hidden-color		| Symbology for output
	hidden-level		| Symbology for output
	hidden-style		| Symbology for output
	hidden-weight		| Symbology for output
	horizontal		| Text position
	innermost		| Text position
	justification		| Justification for text output
	left			| Text position
	level			| Symbology for output
	logfile			| Debugging
	match-regexp		| Function
	member-A		| Graphic output
	member-B		| Graphic output
	member-C		| Graphic output
	middle			| Text position
	not			| Relational operator
	not-reversed		| Text position
	offset			| Text position/Axis translation
	or			| Relational operator
	orthogonal		| Text position
	otherwise		| Conditional
	parallel		| Text position
	position		| Text position
	query-database		| Function
	right			| Text position
	right-to-left		| Text position
	scale			| Scale for profile output
	select			| Conditional
	set			| Global setting
	side			| View type
	silent			| Debugging
	size			| Size for text output
	statement		| Database update
	string-length		| Function
	style			| Symbology for output
	sub-string		| Function
	substitute-string	| Function
	symbol			| Text output
	time			| Function
	to-the-left		| Text position
	to-the-right		| Text position
	top			| Text position
	unknown-view		| View type
	update-database		| Database update
	upside-down		| Text position
	verbose			| Debugging
	view-cone-angle		| View type
	vis-edges-A		| Graphic output
	vis-edges-B		| Graphic output
	vis-edges-C		| Graphic output
	weight			| Symbology for output
	when			| Conditional
	width			| Width for text output
	with			| Part of 'extract' introducing attributes
	word-count		| Function

	all			| Element type	(needs to be avoided).
	beam			| Element type
	bound-surf		| Element type
	cell			| Element type
	compartment		| Element type
	equipment		| Element type
	hvac			| Element type
	inf-plane		| Element type
	joint			| Element type
	limit-volume		| Element type
	macro			| Element type
	perpendicular		| Element type
	pipe			| Element type
	plane-system		| Element type
	plate			| Element type
	profile-volume		| Element type
	section			| Element type
	stiffener		| Element type
	struct-surf		| Element type
	split-surf		| Element type
	split-volume		| Element type
	sym			| Element type
	rway			| Element type

	

	B) Syntax

	In the description of the syntax below, keywords are surrounded by
	simple quotes to differentiate them from non-terminal symbols.
	Operators will be surrounded by simple quotes to differentiate them
	from the symbols of the Backus-Naur form :

	- [ pattern ] means that pattern is optional.
	- { pattern } means that pattern may be repeated zero or more times.
	- pattern1 | pattern2 means that pattern1 or pattern2 can fit.
	- ( and ) are used to group sentenced when an | is involved :
				( pattern1 pattern2 ) | pattern3
	  is different from	pattern1 pattern2 | pattern3
	  which means		pattern1 ( pattern2 | pattern3 )
	- <> denotes the empty token

	program		::= [settings] type-selection
				{ [settings] type-selection }

	settings	::= setting { ; setting }

	setting		::= global_setting | assignment

	global_setting	::= 'verbose'
			  | 'env-processing'
			  | 'silent'
			  | 'set' 'view-cone-angle' exp
			  | 'set' 'logfile' exp

	assignment	::= variable ':=' exp-or-unit

	type-selection	::= element-type ':' '{' [extract] directives '}'

	element-type	::= construction 
			  | const 

	const		::= 'equipment'
			  | "Element_types"
			  | 'stiffener' | 'plate'	| 'joint'
			  | 'pipe'	| 'hvac' 	| 'rway'
			  | 'macro'


	construction	::= 'const' '(' string ')'

	with		::= 'with' string {',' string } ;

	actions		::= action { ';' action }

	action		::= output
			  | anchor_point
			  | assignment
			  | conditional
			  | global_setting
			  | <>

	output		::= graphic
			  | symbol
			  | database-update

	anchor_point	::= 'anchor-point' '(' exp { ',' which-point ')' }

	which-point	::= 'center'
			  | 'center-of-gravity'
			  | 'average-point'


	graphic		::= graphic-type [ arglist ] [ graphic-setup ]

	graphic-type	::= 'vis-edges-A'
			  | 'vis-edges-B'
			  | 'vis-edges-C'
			  | 'env-edges-A'
			  | 'env-edges-B'
			  | 'env-edges-C'
			  | 'member-A' '(' exp ')'
			  | 'member-B' '(' exp ')'
			  | 'member-C' '(' exp ')'

	graphic-setup	::= '[' graphic-attr { ','  graphic-attr } ']'

	graphic-attr	::= 'color'		'=' exp
			  | 'style'		'=' exp
			  | 'weight'		'=' exp
			  | 'level'		'=' exp
			  | 'scale'		'=' exp
			  | 'offset'		'=' exp-or-unit
			  | 'hidden-color'	'=' exp
			  | 'hidden-style'	'=' exp
			  | 'hidden-weigh'	'=' exp
			  | 'hidden-level'	'=' exp
			  | 'filled-display'

	symbol		::= 'symbol' [ symbol-setup ]

	symbol-setup	::= '[' symbol-attr { ','  symbol-attr } ']'

	symbol-attr	::= 'color'		'=' exp
			  | 'style'		'=' exp
			  | 'weight'		'=' exp
			  | 'level'		'=' exp
			  | 'font'		'=' exp
			  | 'format'		'=' '(' format-specs ')'
			  | 'justification'	'=' exp
			  | 'size'		'=' exp
			  | 'width'		'=' exp
			  | 'height'		'=' exp
			  | 'position'		'=' '(' positions ')'

	database-update	::= 'update-database' '[' 'statement '=' exp ']'

	format-specs	::= format-spec { ',' format-spec }

	format-spec	::= exp
			  | format-command

	format-command	::= 'UP'		'(' exp-or-unit ')'
			  | 'DOWN'		'(' exp-or-unit ')'
			  | 'LEFT'		'(' exp-or-unit ')'
			  | 'RIGHT'		'(' exp-or-unit ')'
			  | 'SCALE'		'(' exp ')'
			  | 'START-FIELD'	'(' exp ')'
			  | 'END-FIELD'
			  | 'MOVE-TO-FIELD'	'(' exp ',' exp ')'
			  | 'FONT'		'(' exp ')'

	positions	::= position { ',' position }

	position	::= exp
			  | 'offset'		'(' exp ',' exp-or-unit ')'
			  | 'above'		'(' exp-or-unit ')'
			  | 'below'		'(' exp-or-unit ')'
			  | 'to-the-left'	'(' exp-or-unit ')'
			  | 'to-the-right'	'(' exp-or-unit ')'

	exp-or-unit	::= exp [ unit ]

	exp		::=
			  | exp '<=' exp
			  | exp '<'  exp
			  | exp '>=' exp
			  | exp '>'  exp
			  | exp '='  exp
			  | exp '|'  exp
			  | exp '&'  exp
			  | exp '+'  exp
			  | exp '-'  exp
			  | exp '/'  exp
			  | exp '**' exp
			  | '-' exp
			  | '!' exp
			  | '(' exp ')'
			  | function '(' arglist ')'
			  | variable
			  | variable '[' exp ']'
			  | constant


	arglist		::= [ exp { ',' exp } ]

	constant	::= integer
			  | real
			  | string
			  | 'HEIGHT'
			  | 'WIDTH'
			  | text-just
			  | text-position

	text-just	::= 'LEFT-BOTTOM'
			  | 'LEFT-BASE'
			  | 'LEFT-CENTER'
			  | 'LEFT-CAP'
			  | 'LEFT-TOP'
			  | 'CENTER-BOTTOM'
			  | 'CENTER-BASE'
			  | 'CENTER-CENTER'
			  | 'CENTER-CAP'
			  | 'CENTER-TOP'
			  | 'RIGHT-BOTTOM'
			  | 'RIGHT-BASE'
			  | 'RIGHT-CENTER'
			  | 'RIGHT-CAP'
			  | 'RIGHT-TOP'

	text-position	::= 'top'
			  | 'bottom'
			  | 'right'
			  | 'left'
			  | 'at-first-end'
			  | 'at-second-end'
			  | 'center'
			  | 'middle'
			  | 'innermost'
			  | 'horizontal'
			  | 'vertical'
			  | 'parallel'
			  | 'orthogonal'
			  | 'not-reversed'
			  | 'upside-down'
			  | 'right-to-left'

	function	::= 'attribute'
			  | 'basename'
			  | 'catenate-strings'
			  | 'const-type'
			  | 'drawing-scale'
			  | 'dup-string'
			  | 'format-number'
			  | 'get-input'
			  | 'get-member'
			  | 'get-word'
			  | 'match-regexp'
			  | 'nearest-end-point'
			  | 'query-database'
			  | 'string-length'
			  | 'sub-string'
			  | 'substitute-string'
			  | 'time'
			  | 'word-count'

	conditional	::= 'select' selectors 'end'

	selectors	::= when-clause { , when-clause } otherwise-clause

	when-clause	::= 'when' exp ':' actions

	otherwise-clause::= 'otherwise'  ':' actions

	integer		::= digit { digit }

	real		::= integer '.' [ integer ] [ exponent ]
			  | [ integer ] '.' integer [ exponent ]
			  | integer exponent

	exponent	::= ( 'E' | 'e' ) { '+' | '-' } integer

	string		::= '"' [ character { character } ] '"'

	digit		::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

	character	::= 'any character from the ASCII set'

	variable	::= '$' ( letter | '_' ) [ { letter | '_' | digit } ]

	unit		::= 'any unit from the UOM table surrounded by "'


	XVI Hints
	---------

	A) How to have subscripts and superscripts in text

		The following piece of code will output the following text:

						     X  X XXX
						     X  X X  X
		X     X	XXXXXX X      X	      XXXXX  X  X XXX
		X     X	X      X      X	     X     X  XX  X
		X     X	X      X      X	     X     X
		XXXXXXX	XXX    X      X	     X     X
		X     X	X      X      X	     X     X
		X     X	X      X      X	     X     X XXX   XX  X   X XX  X
		X     X	XXXXXX XXXXXX XXXXXX  XXXXX  X  X X  X X X X X X X
						     X  X X  X X X X X  XX
						     XXX   XX   XXX  X   X

	symbol	[
		format	= (
	# Start a field so we can position with respect to it later, give it
	# the number 0.

			    START-FIELD( 0 ),

	# Write "HELLO"

			    "HELLO",

	# End "HELLO" field

			    END-FIELD,

	# Move to the right base of field number 0 (the "HELLO" field)
	# RIGHT-BASE is below the right bottom corner of the text in the
	# field.

			    MOVE-TO-FIELD( 0, RIGHT-BASE ),


	# Go up 70 % of the active text height

			    UP( HEIGHT * 0.7 ),

	# Go right 50 % of the active text height

			    RIGHT( HEIGHT * 0.5 ),

	# We are now where we want to write the superscript, since we want
	# the superscript smaller than the main text we scale it. Here the
	# superscript will have a size 50 % of the size of the main text.

			    SCALE( 0.5 ),

	# Write "UP"
			    "UP",

	# Since now all cursor movement are based on the current text size,
	# (which has been scaled), we unscale so has to move back to field #0.

			    SCALE( 2 ),

	# Move to the right base of field number 0 (the "HELLO" field)

			    MOVE-TO-FIELD( 0, RIGHT-BASE ),

	# Go down 70 % of the active text height

			    DOWN( HEIGHT * 0.7 ),

	# Go right 50 % of the active text height

			    RIGHT( HEIGHT * 0.5 ),

	# We are now where we want to write the subscript, since we want
	# the subscript smaller that the main text we scale it. Here the
	# subscript will have a size 50 % of the size of the main text.

			    SCALE( 0.5 ),

	# Write "DOWN"

			    "DOWN",

			   ),
			color	= "red"
		]

	B) How to underline text

		The following piece of code will output the following text:


		X     X	XXXXXX X      X	      XXXXX
		X     X	X      X      X	     X     X
		X     X	X      X      X	     X     X
		XXXXXXX	XXX    X      X	     X     X
		X     X	X      X      X	     X     X
		X     X	X      X      X	     X     X
		X     X	XXXXXX XXXXXX XXXXXX  XXXXX

		XXXXXXX XXXXXX XXXXXX XXXXXX XXXXXXX

		symbol	[
			format	= (
				    START-FIELD( 0 ),
				    "HELLO",
				    END-FIELD,
				    MOVE-TO-FIELD( 0, LEFT-BOTTOM ),
				    DOWN( HEIGHT * 0.5 ),
				    "-----"
				   )
			]

	   C) How to annotate a construction for a hole

		Suppose we have extraction statements for a family of
	constructions "hole1", "hole2", etc. and we want to annotate them
	specifying their type and diameter. We suppose that each construction
	has an attribute (a numerical member) called "radius" corresponding
	to the value of the radius of the hole.

	# "hole*" will catch "hole1", "hole2", etc.

	macro ( "hole*" ) : {

		# ...
		symbol	[
			format	= (
		# "const-type()" will return the exact type, e.g. "hole2"

				    const-type(),

		# Add a space
				    " ",

		# Character "n" of font number 100 is the diameter symbol

				    FONT( 100 ),
				    "n",

		# Go back to default font

				    FONT( "default" ),

		# Write diameter

				    2 * attribute( "radius" )

				   )
		]
	}


	This will output something like :
	                                            X
	X     X	 XXXXX  X      XXXXXX	      XXXXXX       XXXXXX    XXXXX
	X     X	X     X X      X	     X    XX       X              X
	X     X	X     X X      X	     X   X X       XXXXX          X
	XXXXXXX	X     X X      XXX	     X  X  X            X       XX
	X     X	X     X X      X	     X X   X            X         X
	X     X	X     X X      X	     XX    X            X         X
	X     X	 XXXXX  XXXXXX XXXXXX        XXXXXX        XXXXX  X  XXXXX 
	                                    X

