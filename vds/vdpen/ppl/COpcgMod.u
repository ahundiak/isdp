/* $Id: COpcgMod.u,v 1.6 2002/02/19 20:39:17 ylong Exp $  */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:        vds/vdpen/ppl/COpcgMod.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COpcgMod.u,v $
 *      Revision 1.6  2002/02/19 20:39:17  ylong
 *      *** empty log message ***
 *
 *      Revision 1.5  2001/10/16 13:51:39  ylong
 *      Replace built-in lists with vds/config/penetrations/DataList
 *
 *      Revision 1.4  2001/10/11 15:36:23  ylong
 *      TR5493
 *
 *      Revision 1.3  2001/05/16 16:25:44  ylong
 *      CR5211
 *
 *      Revision 1.2  2001/01/19 22:30:59  jayadev
 *      *** empty log message ***
 *
# Revision 1.11  2000/07/17  21:12:38  pinnacle
# ylong
#
# Revision 1.9  2000/06/27  20:13:22  pinnacle
# enable Object fit for review mod
#
# Revision 1.8  2000/06/23  18:16:24  pinnacle
# ylong
#
# Revision 1.3  2000/05/12  20:31:50  pinnacle
# Replaced: vds/vdpen/ppl/COpcgMod.u for:  by rchennup for Service Pack
#
# Revision 1.2  2000/04/29  17:47:36  pinnacle
# Replaced: vds/vdpen/ppl/COpcgMod.u for:  by rchennup for Service Pack
#
# Revision 1.13  2000/04/01  15:32:36  pinnacle
# ylong
#
# Revision 1.12  2000/03/21  22:38:30  pinnacle
# ylong
#
# Revision 1.11  2000/03/16  14:15:30  pinnacle
# refined for CR179901115
#
# Revision 1.9  1999/12/29  16:18:20  pinnacle
# TR179900986
#
# Revision 1.8  1999/12/03  16:49:40  pinnacle
# revised for misc
#
# Revision 1.7  1999/12/01  22:53:12  pinnacle
# TR179900968
#
# Revision 1.6  1999/10/07  20:58:58  pinnacle
# ylong
#
# Revision 1.5  1999/06/08  19:02:56  pinnacle
# ylong
#
# Revision 1.3  1999/05/28  22:04:30  pinnacle
# ylong
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/26/99        ylong           TR179900635
 *      06/01/99        ylong           TR179900657
 *      10/07/99        ylong		TR179900900
 *      12/01/99        ylong		TR179900968
 *      12/03/99        ylong		Revised for TR179900968
 *      12/28/99        ylong		TR179900986
 *      03/15/00        ylong		CR179901115
 *      03/20/00        ylong		TR179901189
 *      04/01/00        ylong		Change "Identify Deck Plane" to
 *					"Identify Deck Surfce or Plane"
 *      06/05/00        ylong           TR179901626, TR170091625, TR179901614
 *                                      CR179901628, CR179901629
 * -------------------------------------------------------------------*/
/************************************************************
 * PENETRATION CONTROL GROUP pcg
 * FILE:  	pcg.u
 * PURPOSE:  This PPL command will place a pcg macro
 * on a pcgMacro occurance
 *
 * DESCRIPTION: This command file controls a form that lets
 *    	the user select many options and places a macro on it
 *
 * NOTE:
 *
 ************************************************************/

#include "FI.h"       /* Forms Include File */

#include "VDppl.h"
#include "VDgeom.h"
#include "VDefp.h"
#include "VDmem_ppl.h"
#include "v_geommacros.h"
#include "ci_mac_def.h"
#include "VDSudp_mac.h"
#include "vdAPImacros.h"
#include "vdrefmacros.h"
#include "vdsmacros.h"
#include "asbox.h"
#include "VDobj.h"


/*
#define DEBUG 1
#define vdsDEBUG 1
*/

#include "v_dbgmacros.h"

/************************************************************
  Constants for the form.
 ************************************************************/
#define FORM_LABEL 100  /* Arbitrary Number for Form */
#define FORM_NAME  "VDpcg.frm"  /* Form File */
#define TITLE_STRING "Modify Pen Control"

#define ACCEPT		1
#define RUN		2
#define CANCEL		4
#define FORM_TITLE	11
#define PEN_FIELD	12
#define EXPRESSIONS	14
#define PS_FIELD	15
#define ABL_FIELD	16
#define XY_FIELD	17
#define XY_BTN		24
#define CUT_FIELD	19
#define APPROV_FIELD	20
#define REF_DECK_FIELD	21
#define FA_DIST_FIELD	23
#define FA_FIELD	27
#define FA_LOC_BTN	32
#define PEN_LOC_BTN 	33
#define OBJ_FIT_BTN	25
#define EXPR_DATA_FIELD	26
#define RESET_EXP_BTN	28

#define MAX_TEMPS	100

/************************************************************
  External functions.
 ************************************************************/
extern ci_notification();  /* The forms system automatically calls    */
                           /* this function, which in turn calls your */
                           /* form_notification function              */

extern FIf_set_cmd_oid_os();  /* This function tells the forms system */
                              /* to notify this command file when the */
                              /* user manipulates the form */

extern FIf_reset();
extern FIf_new();        /* Creates the form              */
extern FIf_display();    /* Draws the form                */
extern FIf_erase();      /* Erases the form               */
extern FIf_delete();     /* Removes the form              */
extern FIg_get_value();  /* Retrieves values from gadgets */
extern int FIg_display ();
extern int FIg_erase ();
extern int FIfld_set_text ();
extern int FIfld_get_text ();
extern int FIfld_set_list_text ();
extern int FIg_set_text ();
extern int FIg_set_state_on();
extern int FIg_set_state_off();
extern int FIg_enable();
extern int FIg_disable();
extern int GRdpb_get();
extern int ASmake_source_from_env();
extern int FIfld_set_list_num_rows();
extern int FIfld_set_num_rows();
extern int FIfld_get_num_rows();
extern int FIfld_set_mode();
extern int FIfld_set_list_default_text();
extern int EX_filename1();
extern int toupper();
extern int FIfld_pos_cursor();
extern int FImcf_get_select();
extern int VDGetGridsFromChan_of_Class();
extern GRclassid OPP_ACconst_class_id;
extern GRclassid OPP_nci_macro_class_id;
extern GRclassid OPP_ACpretendin_class_id;

extern int VD_findFileInDirOrProductPaths();
extern FILE* VD_openFile();
extern VD_drwGetACcpxInfo();
extern	BSpj_pt_sf() ;
extern  BSproj1() ;
extern GetObjByNameFromRef();
extern GRdisplay_object();
extern VDpms_findall_ancestryobjects();
extern DPdisbyoid();
extern VDpenFormFillInObjNames();
extern VDpenSetCmdSrc() ;
extern VDpenGetCmdSrc() ;
extern VDpenFormSetExpList();
extern VDpenFormSetList();
extern VDpenGetOrigAttr();

/************************************************************
  Global variables.
 ************************************************************/
int test_wakeup;  /* The wakeup function uses this flag to
                     test if the main function has started yet. */

int form_exists,    /* The delete function uses this flag
                       to test if the form exists */
    form_displayed, /* The sleep function uses this flag
                       to test if the form is displayed */
    not_done;       /* This value is set to 0 when the user
                       selects the cancel or exit & save buttons */

Form form;  /* Use this variable for the forms functions. */

struct CIform_st form_st; /* This structure contains information on
                             which form and gadget was manipulated. */


struct ACrg_coll  collAttrs[50];
struct GRid	GRIDS[4];

IGRint	notlocal;
IGRint	num_exps;
IGRint	expRow;

IGRchar	formStr[40];
IGRchar	pcgStr[80], penStr[80];
IGRchar	cutTypStr[80];
IGRchar	approvStr[80];
IGRchar	refStr[128];
IGRchar	planeStr[128];
IGRchar	psStr[128];
IGRchar	commentString[80];
IGRchar xyStr[80];
IGRchar deckStr[80];
IGRchar	macName[128];
IGRchar coordname[128];
IGRchar	structCut[80];
IGRchar	expTypStr[80];

IGRdouble	ablDbl, xyDbl, psDbl, faDbl;
IGRdouble	cm[16];

struct GRid	PCGMAC;
struct GRid	PENPRET;
struct GRid	OldCoord,
		PENMAC,
		OldPen,
		OldPret,
		OldDeck,
		OldDeckPret,
		DECK,
		DECKPRET,
		TEMPOBJ;

struct GRid	OldPlanePret,
		PLANEPRET,
		OldPlane,
		PLANE;
	
IGRdouble GetFALocation(plane)
struct GRid plane;
{
IGRint	msg, sts,i;
struct IGRplane plane_def;
struct GRmd_env	plane_env;
double	pnt[3];
double  nrm[3];
double  fa;

  ci$get_module_info( md_env = &plane_env);

   plane_def.point = pnt;
   plane_def.normal = nrm;

	sts = ci$send( msg = message GRvg.GRdetplane (
			&msg,
			&plane_env.md_env.matrix_type,
			plane_env.md_env.matrix,
			&plane_def),
			targetid = plane.objid,
			targetos = plane.osnum );
#ifdef DEBUG
	printf("EMSplane.EMplaneDef msg=%d, sts=%d\n", msg, sts);
	printf("pnt %.3fX, %.3fY, %.3fZ\nnrm %.3fX, %.3fY, %.3fZ\n", 
		plane_def.point[0],
		plane_def.point[1],
		plane_def.point[2],
		plane_def.normal[0],
		plane_def.normal[1],
		plane_def.normal[2]);
#endif

	fa =cm[3] - plane_def.point[0];
	return (fa);
}

void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  status("");   /* Clear the status field  */
  message("");  /* Clear the message field */
  exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  int error;

 /*************************
   Create (load) the form.
  *************************/
   error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &form );
  if ( form == NULL ) 
    {
      write( "Could not create the form.\n",
             "Error code = ",  error,  "\n"  );
      return_error();
    }

  form_exists = TRUE;  /* Flag for delete function */

 /**********************************************
   Tell the Forms System to notify this command
   file when the user manipulates the form.
  **********************************************/
  error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
  if ( error )
    {
      write( "Could not link to the Forms System.\n",
             "Error code = ",    error,         "\n"  );
      form_exists = FALSE;
      return_error();
    }

  /* Set the title on the form */
  FIg_set_text( form, FORM_TITLE, formStr);
  FIg_set_text( form, PEN_LOC_BTN, "Loc PCG");

 /*******************
   Display the form.
  *******************/
  
  error = FIf_display( form );
  if ( error )
    {
      write( "Could not display the form.\n",
             "Error code = ",  error,   "\n"  );
      return_error();
    }

  form_displayed = TRUE;  /* Flag for sleep function */
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  char outString[80];
  
  ci$put( response = MOVE_ON );  /* Give control to the main function */
}


wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  /* Display the form unless the command file is just starting */
  if ( test_wakeup == 1 && not_done )
    {
      FIf_display ( form );  /* Redisplay the form */
      form_displayed = TRUE; /* Set flag for sleep function */
    }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
  {
    FIf_erase ( form );
    form_displayed = FALSE;
  }
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
    {
      FIf_erase ( form );
      form_displayed = FALSE;
    }

  /* Delete the form if it exists */
  if ( form_exists )
      FIf_delete( form );
}

/**************************************************************************/
IGRlong GetObjByName( objName, className, objID )
IGRchar *objName ;
IGRchar *className ;
TGRid   *objID ;
{
IGRlong         ret ;
IGRlong         sts ;
IGRint          i, j, index, nb_obj;
GRspacenum      cur_osnum;
GRclassid       classid ;
GRobjid         *obj_list ;
TGRid           id;
int             NbRefOs;
GRspacenum      main_os, *RefOsList;
IGRchar		name[128];

        ret = 0 ;
        main_os = 2 ;
        NbRefOs = 0 ;
        obj_list = NULL  ;
        RefOsList = NULL ;

	UI_status("Searching for object. Please wait ...");

        /* get obj from current active file */
        objID->objid = NULL_OBJID ;
        vds$translate(  objname = objName,
                        p_objid = &objID->objid,
                        p_osnum = &objID->osnum );
        if( objID->objid != NULL_OBJID ) {
                ret = 1;
                goto wrapup ;
        }

        /* if obj not in active file, try ref files */

        sts = om$get_classid (  classname = className ,
                                p_classid = &classid);
        if( !(sts&1) ) {
                printf("om$get_classid failed\n");
                goto wrapup ;
        }

        sts = vd$get_ref_os_list (      msg           =  &msg,
                                        main_os       =  &main_os,
                                        num_ref_os    =  &NbRefOs,
                                        ref_os_list   =  &RefOsList );
        __DBGpr_int("NbRefOs", NbRefOs);
for(i = 0; i < NbRefOs; i = i+1 ) {
        nb_obj = 0 ;
        __DBGpr_int("RefOsList", RefOsList[i]);
        sts = VDpms_findall_ancestryobjects (
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        NULL);
        __DBGpr_int("nb_obj", nb_obj);
        if( !(sts&1) || !nb_obj ) {
                __DBGpr_com("VDpms_findall_ancestryobjects failed 1");
                continue ;
        }

        obj_list = NULL ;
        obj_list = _CALLOC( nb_obj, GRobjid ) ;
        if( obj_list == NULL ) {
                printf("_CALLOC failed for obj_list\n") ;
                goto wrapup ;
        }

        sts = VDpms_findall_ancestryobjects(
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        obj_list);
        if( !(sts&1) || !nb_obj ) {
                __DBGpr_com("VDpms_findall_ancestryobjects failed 2");
		nb_obj = 0;
                continue;
        }

        id.osnum = RefOsList[i];
        for(j = 0; j < nb_obj; j = j + 1 ) {
                id.objid = obj_list[j] ;
                name[0] =  '\0' ;
                gr$get_name(    GRid_in = id,
                                name = name);
                if( !strcmp(objName, name) ) {
                        *objID = id ;
                        ret = 1;
                        goto wrapup ;
                }

        }

        _FREE( obj_list ) ;
        obj_list = NULL ;
}

        ret = 1 ;
wrapup:
        _FREE( obj_list ) ;
        _FREE(RefOsList);
        //printf(">> Exit VStransEdgeToEJ_Bevel <<\n");
	UI_status(" ");
        return ret ;
}


#ifdef DEBUG
#define TRACE(txt)	write("ci_mac_bib: ", txt, '\n');
#else
#define TRACE(txt)  ;
#endif

#define EXP_DOUBLE 0

/*======================================================================*/
/*      locate an object or a expression				*/
/* copied & modified from vds/cimacros/wireframe/macros/ci_mac_bib.u	*/
/*======================================================================*/

int loc_obj_exp( loc_suc, loc_message, loc_prompt, 
                 class_obj,EXP_GRid )

int		*loc_suc;       /* return status			    */
char		loc_prompt[80];	/* prompt to ask the name of the expression */
char		loc_message[80];/* prompt to set the message field          */
struct GRid	*EXP_GRid;	/* return objid & osnum of the expression   */
char		*class_obj;	/* classes filter for located object	    */


{

char		exp_name[80];
char		*exp_value, msg_string[128] ;
int		stat, mask, response, count;
short		sender_class;

struct GRmd_env	MOD_ENV;
struct GRevent	event;

extern ASmake_source_from_env();


        message(loc_message);

	ci$get_module_info(md_env = &MOD_ENV);

step0:

	EXP_GRid->objid = NULL_OBJID;

	mask = GRm_RJT_MOVEON | GRm_BACK_UP | GRm_STRING | GRm_DATA | GRm_OBJID;

        do
        {
        
           *loc_suc = ci$getevent (	prompt		= loc_prompt, 
					response	= &response,
					data		= exp_value,  
					mask		= mask,
					event		= &event,
					stackable	= 1 );

           if( (response == EX_RJT_MOVEON) || (response == EX_BACK_UP ) )
           {
		*loc_suc = 0; 
                return(0);
           }
        }while( *loc_suc != 1 );

/* we got an object via the navigate graph */

	if( response == EX_OBJID )
        {
	  om$get_classid( osnum     = event.located_object[0].located_obj.osnum,
			  objid     = event.located_object[0].located_obj.objid,
			  p_classid = &sender_class );

	  stat = om$is_ancestry_valid( subclassid     = sender_class,
				       superclassname = "expression" );
	  if( stat  != 1 ) goto step0;
	  EXP_GRid->objid = event.located_object[0].located_obj.objid;
	  EXP_GRid->osnum = event.located_object[0].located_obj.osnum;
 	  *loc_suc = 2; 
	  return(1);
        }

/* we recieved a data point to locate an abject */

        if ( response == DATA )
        {
		ci$put( point = (double *)exp_value );
		if ( !ci$locate( prompt = loc_prompt,
                                 owner_action = LC_RIGID_COMP
                                              | LC_RIGID_OWNER | LC_FLEX_COMP
                                              | LC_FLEX_OWNER  | LC_REF_OBJECTS,
				 obj    = &(EXP_GRid->objid), 
				 osnum  = &(EXP_GRid->osnum),
				 md_env = &MOD_ENV,
				 classes= class_obj,
				 stackable = 1 ))
        	{
             		EXP_GRid->objid = NULL_OBJID;
             		*loc_suc = 0;
                        return(0);
        	}
		else
		{
			*loc_suc = 1;
                        return(1);
		}
        }

/* we recieved a data point to locate an abject */

	else if ( response == STRING )
        {
		strcpy(exp_name, exp_value);
		if(exp_name[0] == 0 ) goto step0;
		GetObjByName( exp_name, class_obj, EXP_GRid);
		__DBGpr_obj("EXP_GRid", *EXP_GRid);
          	if ( (EXP_GRid->objid) == NULL_OBJID )
          	{
			sprintf(msg_string, "Macro \"%s\" not found", exp_name);
			UI_status(msg_string);
			goto step0 ;
	  	} 

		gr$display_object(object_id = EXP_GRid, mode  = GRhd );
		*loc_suc = 2;
		return(1);
	} /* end of process string */

}

IGRboolean checkForProperName( selObj, objName, check )
struct GRid selObj;
IGRchar	*objName;
IGRint	check;
{
double pnt[3];
char	junk[80], junk1[80];
char	fullName[128];
int	ret;

	objName[0] = 0;

 	gr$get_name(	GRid_in = selObj, 
			full_name = fullName,
		 	name = objName);

	__DBGpr_str("Selected object name",objName);
	__DBGpr_str("Selected object full name", fullName);

	if(!strcmp(objName,"") && check == TRUE) 
	{
		strcpy(commentString, "This object is not named");
		return FALSE;
	}

	if ( check == TRUE ){

	  if( strlen(objName) != 9 ){
		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  if( objName[0] != 'P' && objName[0] != 'V' && 
	    objName[0] != 'E' && objName[0] != 'M' ){

		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  if( objName[5] != '-' ){

		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }
	}
	return TRUE;
}

/************************************************************
 * Added for CR179901115 by ylong
 */
IGRstat	GetDeckDist( surfID, point, distStr ) 
TGRid		surfID;
IGRdouble	*point;
IGRchar		*distStr;
{
	IGRstat		retFlag ;
	IGRlong		sts, msg ;
	TGRmd_env	env;
	IGRdouble	pnt[3], nrm[3] ;
	IGRdouble	dist ;
	IGRdouble	*u, *v ;
	IGRpoint	*proj_pts;	
	IGRdouble	vector[3] ;
	IGRint		num_pts ;
	TGRbsp_surface	*surf ;
	BSrc		rc ;
	GRrange		range ;
        IGRdouble       prj_pnt[3], pl_pnt[3], pl_nrm[3];
        struct IGRplane plane;

	retFlag = 0 ;
	surf	= NULL ;
	u	= NULL ;
	v	= NULL ;
	proj_pts[0]= NULL ; // proj_pts = NULL caused compile error

	ci$get_module_info( md_env = &env);

	__DBGpr_obj("surfID from deck", surfID);
	vd_$get_geometry(msg	 = &msg,
			grobjId  = &surfID,
			grobjEnv = &env ,
			geometry = &surf ) ;

	if ( !(msg & 1) || surf == NULL) {
		printf("vs$get_geometry failed for surf\n");
		goto wrapup;
	}

	vd_$getSurfaceRange(	msg	= &msg ,
				surface	= &surfID,
				range	= range ) ;
	if( !(msg&1) ) range[2] = 0 ;

	__DBGpr_vec("point", point);
	__DBGpr_vec("range 1", &range[0] ) ;
	__DBGpr_vec("range 2", &range[3] ) ;

	vector[0] = 0 ;
	vector[1] = 0 ;
	if( point[2] <= range[2] )	vector[2] = 1 ;
	else				vector[2] = -1 ;

	BSpj_pt_sf(surf, point, vector, &num_pts, proj_pts, &u, &v, &rc);
	if( rc != BSSUCC || num_pts < 1 ) {
  	   plane.point  = (IGRdouble *)&pl_pnt[0];
           plane.normal = (IGRdouble *)&pl_nrm[0];

	   pl_nrm[0] = pl_nrm[1] = pl_nrm[2] = 0.0;
	   sts = ci$send( msg = message GRvg.GRdetplane( 
					&msg,
					&env.md_env.matrix_type,
					env.md_env.matrix,
					&plane ),
			targetid = surfID.objid,
			targetos = surfID.osnum  );
	   if( !(sts&1&msg) )
	   {
		UI_status("Surface is not straight above pcg macro");
		strcpy( distStr, "") ;
		goto wrapup ;
	   }
	   BSproj1( &rc, point, pl_nrm, pl_pnt, prj_pnt );
	   if( rc != BSSUCC )
           {
                UI_status("Surface is not straight above pcg macro");
                strcpy( distStr, "") ;
                goto wrapup ;
           }
	   dist = prj_pnt[2] - point[2] ;
	}
	else 	dist = proj_pts[0][2] - point[2] ;

	if( dist >= 0. ) {
		sprintf( distStr, "X = %0.2f", dist ) ;
	}
	else {
		sprintf( distStr, "Y = %0.2f", -dist ) ;
	}

	__DBGpr_str("distStr", distStr);

	retFlag = 1 ;
wrapup:
	_FREE( surf ) ;
	_FREE( proj_pts[0] ) ; // _FREE( proj_pts ) caused compile error
	_FREE( u ) ;
	_FREE( v ) ;
	return retFlag ;
}

void enable_form()
{
	FIg_enable( form, CANCEL);
	FIg_enable( form, ACCEPT);
	FIg_enable( form, RUN);
	FIg_enable( form, FORM_TITLE);
	FIg_enable( form, PEN_FIELD);
	FIg_enable( form, EXPRESSIONS);
	FIg_enable( form, PS_FIELD);
	FIg_enable( form, ABL_FIELD);
	FIg_enable( form, XY_FIELD);
	FIg_enable( form, XY_BTN);
	FIg_enable( form, CUT_FIELD);
	FIg_enable( form, APPROV_FIELD);
	FIg_enable( form, REF_DECK_FIELD);
	FIg_enable( form, FA_DIST_FIELD);
	FIg_enable( form, FA_FIELD);
	FIg_enable( form, FA_LOC_BTN);
	FIg_enable( form, PEN_LOC_BTN );
	FIg_set_text(form, PEN_LOC_BTN, "Loc PCG");
	FIg_enable( form, OBJ_FIT_BTN );
	FIg_disable( form, EXPR_DATA_FIELD );
}

void disable_form()
{
	FIg_disable( form, ACCEPT);
	FIg_disable( form, RUN);
	FIg_disable( form, FORM_TITLE);
	//FIg_disable( form, EXPRESSIONS);
	FIg_disable( form, PS_FIELD);
	FIg_disable( form, ABL_FIELD);
	FIg_disable( form, XY_FIELD);
	FIg_disable( form, XY_BTN);
	FIg_disable( form, CUT_FIELD);
	FIg_disable( form, APPROV_FIELD);
	FIg_disable( form, REF_DECK_FIELD);
	FIg_disable( form, FA_DIST_FIELD);
	FIg_disable( form, FA_FIELD);
	FIg_disable( form, FA_LOC_BTN);
	FIg_disable( form, EXPR_DATA_FIELD );
	FIg_disable( form, RESET_EXP_BTN );
}

checkExpressions() 
{
	struct	ACrg_coll	expAttr[2];
	IGRlong			sts, msg;
	TGRid			attrID;
	TGRmd_env		mod_env;
	IGRint			nbRows, row, sel, pos;
	IGRchar			name[40];

	sts = ci$send( msg = message NDmacro.ACreturn_foot(
                               &msg ,
                               "Attributes",
                               &attrID,
                               &mod_env.md_env.matrix_type,
                               mod_env.md_env.matrix ),
               targetid = PCGMAC.objid,
               targetos = PCGMAC.osnum );
	if(!(sts&msg&1)) {
		printf("checkExpressions -- NDmacro.ACreturn_foot failed\n");
		goto wrapup;
	}
	strcpy(expAttr[0].name, "type");
	strcpy(expAttr[1].name, "structure_to_cut");
	expAttr[0].desc.type = 1;
	expAttr[1].desc.type = 1;

	FIfld_get_num_rows( form, EXPRESSIONS, &nbRows );
	if( nbRows < 1 ) goto wrapup;

	for( row = 0; row < nbRows; row = row+1 ) {
		FIfld_get_text(form, EXPRESSIONS, row, 0, 40, name, &sel, &pos);
		if( !strcmp( name, expAttr[0].name ) ) {
			FIfld_get_text(form, EXPRESSIONS, row, 1, 40, 
				expAttr[0].desc.value.att_txt, &sel, &pos);
		}
		else if( !strcmp( name, expAttr[1].name ) ) {
			FIfld_get_text(form, EXPRESSIONS, row, 1, 40, 
                                expAttr[1].desc.value.att_txt, &sel, &pos);
		}
	}
	sts = ci$send(	msg	 = message ACrg_collect.ACmod_list_attribute
                                                ( &msg, 2, expAttr ),
			targetid = attrID.objid,
			targetos = attrID.osnum );
	if(!(sts&msg&1)) {
	    goto wrapup;
	}

wrapup:
	return;
}


main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/


{

  int 	response;     
  int	iSwitch;
  int	i;
  int	m;
  int	msg;
  int	row, pos;
  int   selFlag;
  int	exitFlag;
  int	numAttrs;
  int	sts;
  int	k;
  int 	error;

  double dSwitch;
  double dDiameter;
  double dWidth;
  double dDepth;
  double dRadius_corner;
  double pnt[3], value ;

  GRobj	pplFileId;

  struct GRid	csObj;
  struct GRid	planeObj;
  struct GRid	CollID;
  struct GRid	winID;
  TGRid		objID ;


  struct GRid	penmac, penpret;

  char	NameToGive[128];
  char	tmpStr[80];
  char	objName[128], tmp[80];
  char	chkval[80];
  char  expnam[80], expval[80];
  char  penName[128];
  char  loc_msg[128], loc_prompt[128] ;
  double	deckPnt[3];
  struct GRevent event ;
 
 /***********************************************************
  Do a locate and check to see if the object is named properly
  before displaying the form.
  ***********************************************************/
  /* initialize some parameters before we start */
  strcpy(formStr, TITLE_STRING);
  message(TITLE_STRING);
  notlocal=TRUE;
  exitFlag = 1;


  test_wakeup = 1;        /* flag for wakeup function */
  form_exists = FALSE;    /* flag for delete function */
  form_displayed = FALSE; /* flag for sleep  function */

  form_st.gadget_label = -1 ;

again:

  objID.objid = NULL_OBJID ;
  strcpy( loc_msg, "Modify Penetration Control" );
  strcpy( loc_prompt, "Identify Penetration Control by Name or Locate");
  if(!LocateObj( "nci_macro", loc_prompt, &objID, objName, FALSE ) ) {
	if( form_displayed ) {
	    do {
                ci$get( prompt = "Quit Form", response = &response );
                if( form_st.gadget_label != CANCEL ) continue ;
                not_done = 0;           /* Stop the loop  */
                exitFlag = 0;           /* exit the program */
                FIf_erase ( form );     /* Erase the form */
                goto wrapup;
            } while( form_st.gadget_label != CANCEL ) ;

	}
	else goto wrapup ;
  }

  if( ispcgMacro(objID) != TRUE ) {
	sprintf(tmp, "\"%s\" is not a Penetration Control", objName);
	UI_status(tmp);
	goto again;
  }
  else {
	UI_status("");
  }

process_located_obj:

  ablDbl= 0.0;
  xyDbl = 0.0;
  psDbl = 0.0;
  faDbl = 0.0;
  xyStr[0]      = '\0';
  penName[0]    = '\0';
  structCut[0]  = '\0';
  expTypStr[0]  = '\0';

  DECK.objid = NULL_OBJID ;
  winID.objid = NULL_OBJID ;
  GRIDS[1].objid = NULL_OBJID;
  GRIDS[1].osnum = 2;
  GRIDS[3].objid = NULL_OBJID;
  GRIDS[3].osnum = 2;

  PENMAC.objid = NULL_OBJID;
  PENMAC.osnum = 0;
  expRow = 0;

  if( objID.objid != NULL_OBJID ) {
	PCGMAC = objID ;
	strcpy( pcgStr, objName );
  }
  strcpy( macName, pcgStr ) ; // save old name
  __DBGpr_str("pcgStr", pcgStr);

  not_done = TRUE;  /* Set this to FALSE when done with form */

  if ( !form_exists ) { /* condition added for TR179900968 */
	form_init();      /* Set up the form */
  }

  if( PCGMAC.osnum != 2 ) {
	disable_form() ;
	FIg_enable( form, CANCEL ) ;
  }
  else {
	enable_form();
  }

  get_current_file_name_and_mod_env();

/* get the coordinate system and initialize the variables */
  getCurrentCoord();
  gr$get_name(  GRid_in = PCGMAC,
                name    = pcgStr );
  __DBGpr_str("pcgStr at beginning locate", pcgStr);

  ablDbl = cm[11];

  if( cm[7] >= 0.0 ) {
	sprintf(psStr,"P%.3f", fabs(cm[7]));
  }else {
	sprintf(psStr,"S%.3f", fabs(cm[7]));
  }

  psDbl = cm[7];

  fillInForm();
  PLANEPRET = GRIDS[2];
  DECKPRET  = GRIDS[3];
  //loadDeckList();
  VDpenFormSetList ( form, REF_DECK_FIELD, "deck_list", -1 );
  VDpenFormSetList ( form, CUT_FIELD, "cut_type", -1 );
  VDpenFormSetList ( form, APPROV_FIELD, "approval", -1 );

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/

  while (not_done )
    {

      objID.objid = NULL_OBJID;
      objName[0] = '\0' ;
      if( form_st.gadget_label == RUN ) {
	strcpy(loc_prompt,"Identify Penetration Control");
      }
      else {
	strcpy(loc_prompt,"Fill in the form");
      }

      /* Suspend the command file and wait for the form */
      ci$get( prompt = loc_prompt, response = &response );
              
      status(""); /* clear the status field*/
	
      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){

        case CANCEL:
          /* Quit Button */
          not_done = 0;        /* Stop the loop  */
	  exitFlag = 0;		/* exit the program */
          FIf_erase ( form );  /* Erase the form */
          break;

	/* Locate PCG to modify, not PEN */
        case PEN_FIELD:
	  FIg_get_text(form, PEN_FIELD, objName);
	  GetObjByName( objName, "nci_macro", &objID) ;
	  if( objID.objid != NULL_OBJID ) {
		gr$display_object(object_id = &objID, mode  = GRhd );
		goto process_located_obj;
	  }
	  else {
	  	FIf_reset(form);
	  	VDpenFormFillInObjNames(form,PEN_FIELD, "pcgMacro");
	  	FIg_set_text(form, PEN_FIELD, objName);
		sprintf(tmpStr, "Cannot find PCG Macro %s", objName);
		status( tmpStr );
	  }
         
          break;

        case PEN_LOC_BTN:
          strcpy(loc_prompt, "Identify Penetration Control by Name or Locate");
	  disable_form();
	  while( objID.objid == NULL_OBJID) {
		if(!LocateObj("nci_macro",loc_prompt,&objID, objName, FALSE)){
		    FIg_set_text(form, PEN_FIELD, pcgStr);
		    objID.objid = NULL_OBJID ;
		    break ;
		}
		__DBGpr_com("check if pcg");
		if( ispcgMacro( objID ) != TRUE ) {
		    sprintf(tmp, "\"%s\" is not a Penetration Control",objName);
		    UI_status(tmp);
		    objID.objid = NULL_OBJID ;
		}
		__DBGpr_obj("objID", objID);
	  }
	  gr$display_object(object_id = &objID, mode  = GRhd );
	  goto process_located_obj;

          break;

        case FA_LOC_BTN:
          if( !LocateObj( "EMSplane","Identify Forward or Aft Reference Plane",
                                        &objID, objName, FALSE) ) break ;
          if( objID.objid == NULL_OBJID ) break ;

	  PLANE = objID ;
	  strcpy( planeStr, objName ) ;

	  faDbl = GetFALocation( PLANE );
          FIfld_set_text(form, FA_DIST_FIELD, 0, 0, ftoa(faDbl), FALSE);

	  sts = ASmake_source_from_env( &PLANE, &MOD_ENV, &PLANEPRET);
	
	  if( strcmp(planeStr, "") == 0 ) strcpy( planeStr,"Unnamed Plane");
  	  FIfld_set_text( form, FA_FIELD, 0, 0, planeStr, FALSE);

	  break;

        case XY_BTN:	/* Modified this case for CR179901115 */
	  if( !LocateObj("EMSsubbs", "Identify Deck Surface or Plane:",
                        &objID, objName, FALSE) ) break ;

          if( objID.objid == NULL_OBJID ) break ;

	  DECK = objID ; strcpy( deckStr, objName ) ;

          sts = ASmake_source_from_env( &DECK, &MOD_ENV, &DECKPRET );

          deckPnt[0] = cm[3]; deckPnt[1] = cm[7]; deckPnt[2] = cm[11] ;
          GetDeckDist( DECK, deckPnt, xyStr ) ;
          FIfld_set_text(form, XY_FIELD, 0, 0, xyStr, FALSE);

          break;

        case REF_DECK_FIELD:
          FIfld_get_text(form, REF_DECK_FIELD, 0, 0, 76, refStr, &selFlag, &pos);
	  break;

        case CUT_FIELD:

          FIfld_get_text(form, CUT_FIELD, 0, 0, 76, cutTypStr, &selFlag, &pos);
          if(!strcmp(cutTypStr,"") || !strcmp(cutTypStr,"---"))
          { 
  	  	FIfld_set_text( form, CUT_FIELD, 0, 0, "---", TRUE);	
          	status("Select a Cut type");
          	break;
          }
	  break;

        case APPROV_FIELD:
	  /* FILL IN THE SHAPE LIST */
          FIfld_get_text(form, APPROV_FIELD, 0, 0, 76, approvStr, &selFlag, &pos);
          if(!strcmp(approvStr,"") || !strcmp(approvStr,"---"))
          { 
  	  	FIfld_set_text( form, APPROV_FIELD, 0, 0, "---", TRUE);	
          	status("Select an approval type");
          	break;
          }
	  break;

	case EXPRESSIONS:
	  FIfld_get_active_row(form, EXPRESSIONS, &expRow, &pos);
	  FImcf_get_select(form, EXPRESSIONS, expRow, &selFlag);
	  FIfld_get_text(form, EXPRESSIONS, expRow, 0, 40, expnam, &selFlag, &pos);
	  FIfld_get_text(form, EXPRESSIONS, expRow, 1, 40, expval, &selFlag, &pos);
	  VDpenFormSetExpList( form, EXPR_DATA_FIELD, RESET_EXP_BTN,
				expnam, expval, selFlag);
	  break;

	case RESET_EXP_BTN:
	  expTypStr[0] == '\0';
	  structCut[0] == '\0';
	  FIfld_get_text(form, EXPRESSIONS, expRow, 0, 40, 
				expnam, &selFlag, &pos);
	  VDpenGetOrigAttr(PENMAC, expnam, expval);
          FIg_set_text(form, EXPR_DATA_FIELD, expval);
	  FIfld_set_text(form, EXPRESSIONS, expRow, 1, expval, selFlag);
	  break;

	case EXPR_DATA_FIELD:
	  FIg_get_text(form, EXPR_DATA_FIELD, expval);
	  FImcf_get_select(form, EXPRESSIONS, expRow, &selFlag);
	  if( expval[0] != '\0' && selFlag ) {
            FIfld_set_text(form, EXPRESSIONS, expRow, 1, expval, selFlag);
	    FIfld_get_text(form, EXPRESSIONS, expRow, 0, 40, expnam, &selFlag, &pos);
	    if( !strcmp(expnam, "structure_to_cut") ) {
		strcpy(structCut, expval);
	    }
	    else if( !strcmp(expnam, "type") ) {
		strcpy(expTypStr, expval);
	    }
	  }
	  break;

        case OBJ_FIT_BTN:
	  winID.objid = NULL_OBJID ;
          ci$getevent( prompt	= "Identify Window or Moveon for all", 
			response= &response,
	     		data	= tmp,
			event	= &event,
			mask	= GRm_DATA,
			window_id = &winID.objid,
			window_osnum = &winID.osnum,
			stackable = 1 );
	  if( winID.objid == NULL_OBJID ){
	    sts = vd$vw_fit_object(
                               factor   = 2.0,
                               object   = &PCGMAC,
                               md_env   = &MOD_ENV );
	  }
	  else {
	    sts = vd$vw_fit_object(
                               object   = &PCGMAC,
                               md_env   = &MOD_ENV,
                               ggid     = &winID,
                               factor   = 2.0,
                               num_ggid = 1 );
	  } 
	  gr$display_object(object_id = &PCGMAC, mode  = GRhd );

	  break;

        case RUN:
	  VDpenSetCmdSrc(1); //tell macro updating request is from this command
	  if( checkAndPlace() ) {
		computeTheMacro();
	  }
	  else {
		break;
	  }
	  FIf_reset(form);
	  disable_form();
	  UI_status("Searching for macros. Please wait ...");
  	  VDpenFormSetList ( form, REF_DECK_FIELD, "deck_list", -1 );
	  VDpenFormSetList ( form, CUT_FIELD, "cut_type", -1 );
	  VDpenFormSetList ( form, APPROV_FIELD, "approval", -1 );
	  VDpenFormFillInObjNames(form,PEN_FIELD, "pcgMacro");
	  FIg_set_text(form, PEN_FIELD, "");
	  UI_status("Modification done");
	  break;

        case ACCEPT:          
	  VDpenSetCmdSrc(1); //tell macro updating request is from this command
	  if( checkAndPlace() ) {
		computeTheMacro();
		break;
	  }
          not_done = 0;        /* Stop the loop  */
          FIf_erase ( form );  /* Erase the form */
          break;

        } /* END switch ( g_label ) */
    } /* END while ( not done ) */

wrapup:
	message("");
	prompt("");
	if ( exitFlag == 0 ) exit;


  /* The delete function will delete the form
     when the command file terminates */

}

/**********************************************************/

int LocateObj( inType, inPrompt, selObj, objName, check)
IGRchar	*inType;
IGRchar	*inPrompt;
TGRid	*selObj;
IGRchar	*objName;
IGRint	check;
{
        IGRlong loc_suc ;
        int     ret ;

        ret = 0 ;

        objName[0] = '\0' ;
        ret = loc_obj_exp( &loc_suc, TITLE_STRING, inPrompt, inType, selObj ) ;
        if( ret ){
                checkForProperName( *selObj, objName, check ) ;
        }

        return ret;

}

/***********************************************************/
IGRchar	filename[132];
IGRint 	var_size[3];
IGRint	bad_var;
struct EX_var_list	ex_var[4];
extern int EX_get_global();
extern int ACconstruct_path();

get_current_file_name_and_mod_env()
{

	SetProc(get_current_file_name_and_mod_env); Begin

// GET THE CURRENT FILE NAME

	var_size[0] = sizeof(filename);
	ex_var[0].var = EX_CUR_FILENAME;
	ex_var[0].var_value = &filename[0];
	ex_var[0].num_bytes = &var_size[0];
	var_size[1] = NULL;

	msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

	__DBGpr_str("filename",filename);

 	ci$get_module_info( md_env = &MOD_ENV);

	End
}


/*****************************************************************/

int	modifyMacro()
{

char	cRep;
int	count, msg, sts;
struct GRid	Locals[4];

	SetProc(modifyMacro); Begin

	sts = 0;

	__DBGpr_obj("OldPen", OldPen);
	__DBGpr_obj("OldPret", OldPret);

	__DBGpr_obj("OldPlane", OldPlane);

	__DBGpr_obj("OldDeck", OldDeck);
	__DBGpr_obj("OldDeckPret", OldDeckPret );

	__DBGpr_obj("PENMAC", PENMAC);
	__DBGpr_obj("PENPRET", PENPRET);

	__DBGpr_obj("PLANE", PLANE);

	__DBGpr_obj("DECK", DECK );
	__DBGpr_obj("DECKPRET", DECKPRET);

    if( PENMAC.objid == NULL_OBJID ) {
	UI_status("Penetration Macro does not exist! Command Failed"); 
	goto wrapup;
    }
	
    if( PENMAC.objid != OldPen.objid   || PENMAC.osnum != OldPen.osnum   ||
    	PLANE.objid  != OldPlane.objid || PLANE.osnum  != OldPlane.osnum ||
	DECK.objid   != OldDeck.objid  || DECK.osnum   != OldDeck.osnum )
    {
	
	ci$get_module_info( md_env = &MOD_ENV);

	PENPRET.objid = NULL_OBJID;
	PENPRET.osnum = 2;

	sts = ASmake_source_from_env(
		&PENMAC, &MOD_ENV, &PENPRET);

	GRIDS[0] = PENPRET;	
	GRIDS[2] = PLANEPRET;
	GRIDS[3] = DECKPRET;
	Locals[0] = OldPret;
	Locals[1] = GRIDS[1];
	Locals[2] = OldPlanePret;
	Locals[3] = OldDeckPret;
	
	__DBGpr_obj("GRIDS[0]", GRIDS[0]);
	__DBGpr_obj("local[0]", Locals[0]);
	__DBGpr_obj("local[1]", Locals[1]);
	__DBGpr_obj("local[2]", Locals[2]);
	__DBGpr_obj("local[3]", Locals[3]);
	
	if(Locals[3].objid == NULL_OBJID)	count = 3;
	else					count = 4;
	sts = ci$send(msg = message  NDnode.NDchange_connect( 
		&count,
		Locals,
		GRIDS),
		targetid = PCGMAC.objid,
		targetos = PCGMAC.osnum );

	__DBGpr_int("NDnode.NDchange_connect msg&sts", (sts&1) );
	__DBGpr_obj("macroid", PCGMAC);
	
	if( Locals[3].objid == NULL_OBJID && GRIDS[3].objid != NULL_OBJID ) {
		sts = ci$send(	msg	 = message NDnode.NDconnect
					(1, &GRIDS[3], NULL_GRID, ND_ADD ),
				targetid = PCGMAC.objid,
				targetos = PCGMAC.osnum );
		__DBGpr_int("sts from NDnode.NDconnect", (sts&1));
	}
	
	OldPret = PENPRET;
	OldPen = PENMAC;
	OldPlanePret = PLANEPRET;
	OldPlane = PLANE;
	OldDeckPret = DECKPRET;
	OldDeck = DECK;
   }

   sts = 1;
wrapup:
   End
   return sts;

}

/*********************************************************************/

computeTheMacro(){
int	msg, sts;

   SetProc( computeTheMacro ); Begin

   sts = ci$send(msg = message GRgraphics.GRxform( 
		&msg,
		&MOD_ENV,
		&MOD_ENV.md_env.matrix_type,
		MOD_ENV.md_env.matrix,
		&PCGMAC.objid),
		targetid = PCGMAC.objid,
		targetos = PCGMAC.osnum );

   __DBGpr_int("GRgraphics.GRxform msg&sts", (msg&sts&1) );

   End
}

/*****************************************************************/

int	putName( InGrid , hide)
struct GRid	*InGrid;
int		hide;
{
char	tmpname[30];
int	msg;
int	stat;

	if ( hide == FALSE){

		//sprintf( tmpname,"M%d%d",InGrid->objid, InGrid->osnum);	
		stat = ci$send( msg = message GRvg.GRputname(
			&msg,
			pcgStr),
			targetid = InGrid->objid,
			targetos = InGrid->osnum);
	
		if ( !(stat&msg&1) ) return FALSE;
	}
	return TRUE;
}



/*****************************************************************/

int	checkAndPlace()
{
  int	msg, m, i;
  int	sts;
  int	numReturned;
  char	txt[80];

	sts = 0;

	__DBGpr_obj("ABOUT TO CHANGE ALL OF THE PARAMETERS FOR ID",
				GRIDS[1]);

	/*create all the items for the input collector off of the form*/

	i=0;
	strcpy(collAttrs[i].name, "Approval");
	collAttrs[i].desc.type = 1; 
	strcpy(collAttrs[i].desc.value.att_txt, approvStr);

	i=i+1;
	strcpy(collAttrs[i].name, "PenetrationName");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, penStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "FwdAftPlane");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, planeStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "FwdAftValue");
	collAttrs[i].desc.type = 2; 	
	collAttrs[i].desc.value.att_exp = faDbl; 

	i=i+1;
	strcpy(collAttrs[i].name, "ReferenceDeck");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, refStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "CutType"); 
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, cutTypStr);

	i=i+1;
	strcpy(collAttrs[i].name, "Port_Starboard_pos");
	collAttrs[i].desc.type = 1;
	strcpy(collAttrs[i].desc.value.att_txt, psStr);

	i=i+1;
	strcpy(collAttrs[i].name, "Vertical_ABL");
	collAttrs[i].desc.type = 2; 	
	collAttrs[i].desc.value.att_exp= ablDbl;

	i=i+1;
	strcpy(collAttrs[i].name, "Vertical_XorY");
	collAttrs[i].desc.type = 1;
	strcpy(collAttrs[i].desc.value.att_txt, xyStr);

	if( expTypStr[0] != '\0' ) {
	   txt[0] = '\0';
	   VDpenGetOrigAttr(PENMAC, "type", txt);
	   if( strcmp( expTypStr, txt) ) {
		i=i+1;
		strcpy(collAttrs[i].name, "type");
		collAttrs[i].desc.type = 1;
		strcpy(collAttrs[i].desc.value.att_txt, expTypStr);
	   }
	}

	if( structCut[0] != '\0' ) {
	   txt[0] = '\0';
	   VDpenGetOrigAttr(PENMAC, "structure_to_cut", txt);
	   if( strcmp( structCut, txt) ) {
		i=i+1;
		strcpy(collAttrs[i].name, "structure_to_cut");
		collAttrs[i].desc.type = 1;
		strcpy(collAttrs[i].desc.value.att_txt, structCut);
	   }
	}

	i=i+1;

#ifdef DEBUG
	printf("number of atts in coll 1=%d\n",numReturned);
	for( numReturned = 0; numReturned< i; numReturned=numReturned+1){
		printf("%s is ",collAttrs[numReturned].name);
		if (collAttrs[numReturned].desc.type == 1){
			printf("att[%d]=[%s]\n",numReturned, 
				collAttrs[numReturned].desc.value.att_txt);
		}else{
			printf("att[%d]=[%.3f]\n",numReturned, 
				collAttrs[numReturned].desc.value.att_exp);
		}
	}
#endif

	sts = ci$send(	msg = message ACrg_collect.ACset_list_attribute(
						&msg, i, collAttrs),
			targetid = GRIDS[1].objid,
			targetos = GRIDS[1].osnum);
		
	//printf("ACset_list sts=%d, msg=%d\n",sts,msg);
		
	sts = modifyMacro();
	if( !sts ) goto wrapup;
	sprintf(pcgStr, "PCG-%s", coordname);
	__DBGpr_str("macName", macName);
	__DBGpr_str("pcgStr", pcgStr);
	if( strcmp( macName, pcgStr) ) {
		putName( &PCGMAC, FALSE ) ;
	}

	sts = 1;
wrapup:
	return sts;
}

/****************************************************************/

getCurrentCoord( )
{
	int	msg, sts, i;


	if( PENMAC.objid == NULL_OBJID ){

		// get the penetration macro id from the control macro

		sts = ci$send(	msg	 = message ACcpx.ACfind_exp_temp_obj(
						&msg, 0, &OldPret),
				targetid = PCGMAC.objid,
				targetos = PCGMAC.osnum);

		if (!(msg&sts&1)) {
		   __DBGpr_com("failed to get OldPret, parent 0 of PCGMAC");
		   return;
		}
		__DBGpr_obj("OldPret, parent of PCGMAC", OldPret);
	
		PENPRET = OldPret;

		sts = ci$send (	msg = message NDmacro.ACreturn_foot(
						&msg,
						"", 
						&PENMAC, 
						&MOD_ENV.md_env.matrix_type,
						MOD_ENV.md_env.matrix),
				targetid = OldPret.objid,
				targetos = OldPret.osnum);

	  	if (!(msg&sts&1)) {
 			__DBGpr_com("failed to get foot PENMAC of OldPret");
			return;
		}
		__DBGpr_obj("PENMAC, foot of OldPret", PENMAC);

	}

	sts = ci$send(	msg	 = message ACcpx.ACfind_exp_temp_obj
						(&msg, 0, &OldCoord),
			targetid = PENMAC.objid,
			targetos = PENMAC.osnum);
	if (!(msg&sts&1)) {
		__DBGpr_com("failed to get parent 0 of PENMAC");
		return;
	}
	__DBGpr_obj("OldCoord, parent 0 of PENMAC", OldCoord);


	sts = ci$send(	msg	 = message NDmacro.ACreturn_foot(
					&msg,
					"", 
					&OldCoord, 
					&MOD_ENV.md_env.matrix_type,
					MOD_ENV.md_env.matrix),
			targetid = OldCoord.objid,
			targetos = OldCoord.osnum);

	if (!(msg&sts&1)) {
		__DBGpr_com("failed to get foot of OldCoord");
		__DBGpr_int("NDmacro.ACreturn_foot msg&sts", (msg&sts&1) );
		return;
	}
	__DBGpr_obj("OldCoord, foot of OldCoord", OldCoord);

	/* get coord name */
	gr$get_name(	GRid_in = OldCoord,
			name	= coordname);

	/* get the coordinate system info */

	sts = ci$send(	msg	 = message GRgencs.GRgetmatrix ( &msg, cm),
			targetid = OldCoord.objid,
			targetos = OldCoord.osnum );
#ifdef DEBUG
	__DBGpr_com("cs matrix");
	for(i=0;i<4;i=i+1)
	{
		printf("\t%.3f, %.3f, %.3f, %.3f\n", 
		cm[i*4+0], cm[i*4+1], cm[i*4+2], cm[i*4+3]);

	}
#endif

	return;
}


/*****************************************************/
extern int	ACfind_macro_defn();

int ispcgMacro( objID )
TGRid	objID ;
{
int	stat;
char	macname[132];
char	msgStr[132];

	macname[0] = '\0';
	vdobj$Get(	objID = &objID,
			macName	= macname);

	if( strcmp( macname, "pcgMacro") != 0){
		sprintf(msgStr, "%s is NOT a pcgMacro.\n", macname);
		UI_status(msgStr);
		__DBGpr_str("IS not pcgMacro", macname);
		return FALSE;
	}else {
	
		__DBGpr_str("IS pcgMacro", macname);
		return TRUE;
	}

}

/**********************************************/

int ispenMacro( penmac )
	struct GRid	penmac ;
{
	/* get the macro's definition name */
	struct GRid 	TEMP;
	int	stat;
	char	macname[132];
	char	stripname[132];
	char	msgStr[132];
	struct GRid	defID;

	msg = ci$send( msg = message ci_macro.find_macro(
			&TEMP),
			targetid = penmac.objid,
			targetos = penmac.osnum);
	
	msg = ci$send( msg = message GRvg.GRgetname(
			&stat,
			macname),
			targetid = TEMP.objid,
			targetos = TEMP.osnum);
	
	__DBGpr_str("in ispenMacro macroname",macname);
	
	di$split ( pathname = macname,
		   dirname = NULL,
		   name = stripname );
	
	msg = ac$find_macro_defn( action = ACfind_load,
				  macro_name = stripname,
				  p_macro_defn_id = &defID);
	
	if( strcmp( stripname, "penMacro") != 0){
	
		sprintf(msgStr, "%s is NOT a penMacro.\n", stripname);
		status(msgStr);
		return FALSE;
	
	}else {
	
		__DBGpr_str("IS penMacro", stripname);
		return TRUE;
	}

}

/**********************************************/

int fillInForm()
{
int	msg, stat, i, k;
int	numReturned;
struct GRid	JUNK;
struct GRid	PENCOLL;

	for(i=0; i<4; i=i+1){
	
		msg = ci$send( msg = message ACcpx.ACfind_exp_temp_obj(
			&stat, i, &GRIDS[i]),
			targetid = PCGMAC.objid,
			targetos = PCGMAC.osnum);
			
#ifdef DEBUG
		printf("\tfind_exp_temp_obj msg=%d, stat=%d\n",msg, stat);
		printf("\tinput grids[%d]=id[%d, %d], msg=%d, stat=%d\n", 
			i, GRIDS[i].objid,  GRIDS[i].osnum, msg, stat);
#endif
                if (!(msg&stat&1))
                {
                  if( i==3 )
                  {
                        OldDeckPret.objid = NULL_OBJID ;
                        OldDeck.objid     = NULL_OBJID ;
                        continue;
                  }
                  else return;
                }

		if (i==0) OldPret = GRIDS[i];
		if (i==2) 
		{
		   OldPlanePret = GRIDS[i];
		   ci$send( msg = message NDmacro.ACreturn_foot(
					&msg,
                        		"",
					&OldPlane,
                        		&MOD_ENV.md_env.matrix_type,
                        		MOD_ENV.md_env.matrix),
                        targetid = OldPlanePret.objid,
                        targetos = OldPlanePret.osnum);
		   PLANE = OldPlane ;
		}

                if (i==3) 
                {
                   OldDeckPret = GRIDS[i];
                   ci$send( msg = message NDmacro.ACreturn_foot(
                                        &msg,
                                        "",
                                        &OldDeck,
                                        &MOD_ENV.md_env.matrix_type,
                                        MOD_ENV.md_env.matrix),
                        targetid = OldDeckPret.objid,
                        targetos = OldDeckPret.osnum);
		   DECK = OldDeck ;
		   __DBGpr_obj("OldDeck", OldDeck) ;
                }
	}
			
/*  
 * Resume to use ACreturn_foot after TR179900900 fixed
 */
	msg = ci$send( msg = message NDmacro.ACreturn_foot(
			&stat,
			"Attributes",
			&PENCOLL,
			&MOD_ENV.md_env.matrix_type,
			MOD_ENV.md_env.matrix),
			targetid = PCGMAC.objid,
			targetos = PCGMAC.osnum);

	if (!(msg&stat&1)) {
		return;
	}

	/* get all the data out of the input collector for macro placement */

	msg = ci$send( msg = message  ACrg_collect.AClist_attribute(
			&stat,
			50,
			collAttrs,
			&numReturned),
        		targetid = PENCOLL.objid,
        		targetos = PENCOLL.osnum );

	__DBGpr_int("number of atts in penColl",numReturned);

	if( !(msg&stat&1)) return FALSE;

	k=0;
	for (i=0; i<numReturned-1; i=i+1){

	    if ( i < 9){
	    	
	    	if( i==0){
	    		strcpy( approvStr, collAttrs[i].desc.value.att_txt );
	    		
          		FIfld_set_text(form, APPROV_FIELD, 0, 0, 
          				collAttrs[i].desc.value.att_txt, FALSE);	    	
	    	}else if( i==1 ){
	    		strcpy( penStr, collAttrs[i].desc.value.att_txt );
			__DBGpr_str("colector to penStr", penStr);
	    		
          		FIfld_set_text(form, PEN_FIELD, 0, 0, pcgStr);

	    	}else if( i==2 ){
	    		strcpy( planeStr, collAttrs[i].desc.value.att_txt );
	    		
          		FIfld_set_text(form, FA_FIELD, 0, 0, 
          				collAttrs[i].desc.value.att_txt, FALSE);	    	
	    	}else if( i==3 ){
	    		faDbl = collAttrs[i].desc.value.att_exp;
	    		
          		FIfld_set_text(form, FA_DIST_FIELD, 0, 0, 
          				ftoa(faDbl), FALSE);	    	
	    	}else if( i==4 ){
	    		strcpy( refStr, collAttrs[i].desc.value.att_txt );
	    		
          		FIfld_set_text(form, REF_DECK_FIELD, 0, 0, 
          				collAttrs[i].desc.value.att_txt, FALSE);	    	
	    	}else if( i==5 ){
	    		strcpy( cutTypStr, collAttrs[i].desc.value.att_txt );
	    		
          		FIfld_set_text(form, CUT_FIELD, 0, 0, 
          				collAttrs[i].desc.value.att_txt, FALSE);	    	
	    	}else if( i==6 ){
			psDbl = collAttrs[i].desc.value.att_exp;
			strcpy(psStr,collAttrs[i].desc.value.att_txt);
          		FIfld_set_text(form, PS_FIELD, 0, 0, psStr, FALSE);	    	
	    	}else if( i==7 ){
	    		ablDbl = collAttrs[i].desc.value.att_exp;
          		FIfld_set_text(form, ABL_FIELD, 0, 0, 
          				ftoa(ablDbl), FALSE);	    	
	    	}else if( i==8 ){
	    		strcpy( xyStr, collAttrs[i].desc.value.att_txt );
          		FIfld_set_text(form, XY_FIELD, 0, 0, xyStr, FALSE);
	    	}
#ifdef DEBUG
		printf("\tfillInForm[%d] %s\n", i, collAttrs[i].name);
#endif
		k=k+1;
		continue;
	    } 
	    
	    

	    FIfld_set_text( form, EXPRESSIONS, i-k,0, collAttrs[i+1].name,FALSE);
	    if( collAttrs[i+1].desc.type == 1){
		FIfld_set_text( form, EXPRESSIONS, i-k,1, 
				collAttrs[i+1].desc.value.att_txt,FALSE);

	    }
	    else{
		FIfld_set_text( form, EXPRESSIONS, i-k,1, 
				ftoa(collAttrs[i+1].desc.value.att_exp),FALSE);
	    }
	}

	FIg_display( form, OBJ_FIT_BTN );
	FIg_set_text(form, PEN_LOC_BTN, "Loc PCG");

	UI_status("Searching for macros. Please wait ...");
	VDpenFormFillInObjNames( form, PEN_FIELD, "pcgMacro" );
	UI_status(" ");
}



int loadDeckList()
{
FILE *checkFile;
IGRchar	filename[80];
IGRchar	deckname[80];
IGRint	Done;
IGRint	len;

long    msg ;
char    firstDir[100] ;
char    fileToFind[100] ;
char    dirInProdPathToSearchThen[100] ;

	/* check to see if file exists */
	checkFile = NULL ;
	strcpy(fileToFind, "DeckList");

        msg = MSFAIL ;
        strcpy(firstDir, ".");
        strcpy(dirInProdPathToSearchThen, "config/penetrations") ;
        VD_findFileInDirOrProductPaths(     &msg,
                                        fileToFind,
                                        firstDir,
                                        dirInProdPathToSearchThen,
                                        filename ) ;

        __DBGpr_str(" filename", filename);

        checkFile = VD_openFile( &msg, filename, "r" );
        //checkFile = ( FILE *) fopen ( filename, "r" );

        if( !(msg & 1) || checkFile == NULL ){
                msg = FALSE ;
                printf("Deck list file %s was not found.\n",filename);
                goto wrapup;
        }

	Done = 0;
	while(1)  
	{
		fgets( deckname, 80, checkFile);
		if ( deckname[0] == 0 ) break;

		len = strlen( deckname);
		deckname[ len - 1] = 0;
		FIfld_set_list_text( form, REF_DECK_FIELD, Done, 0,
				deckname, FALSE);

		Done = Done + 1;
		deckname[0] = 0;
 	}

wrapup:
	fclose ( checkFile );
}

/********************************************************/

int CreateCollector( inName, outObj )
char	inName[512];
struct GRid *outObj;
{
int	sts;
int	msg;

	outObj->osnum = 2;

	sts = om$construct( 
		classname = "ACrg_collect",
		osnum = 2,
		p_objid = &outObj->objid);

	//printf("created collector id[%d, %d]\n",outObj->objid, outObj->osnum);

	if( strcmp( inName, "") ){

		sts = ci$send( msg = message GRgraphics.GRputname (
			&msg,
			inName),
			targetid = outObj->objid,
			targetos = outObj->osnum );
	}

	return TRUE;
}

/********************************************************************
 * It is used to check if a pcgMacro exsits as a child of penMacro.
 *  by ylong
 */
int A_pcgMacro_exists( penmac ) 
	struct	GRid	penmac ;
{

	GRclassid	classid;
	struct	GRid	*foundIds, *tmpIds;
	struct	GRid	model_def;
	OM_S_CHANSELECT	children_chn, notify_chn;

	IGRchar fullName[256];
	IGRchar *objName;
	IGRint	pcgFlag, i, j, cnt;
	IGRint	num_found, num_tmp;
	IGRlong	sts, msg;

	foundIds = NULL ;
	num_found = 0 ;
	tmpIds = NULL ;
	num_tmp = 0 ;

	objName = NULL;
	pcgFlag = 0;

	/* first, check penMacro */
        sts = om$make_chanselect(channame     = "NDchildren.children",
                                 p_chanselect = &children_chn);
        if( !(sts & 1) ) {
		__DBGpr_com("om$make_chanselect failed") ;
		goto wrapup;
	}

        classid = OPP_nci_macro_class_id ;
        sts = VDGetGridsFromChan_of_Class (
                                        &msg,
                                        penmac,
                                        &children_chn,
                                        classid,
                                        &num_found,
                                        &foundIds ) ;

	/* second, check pretends for TR179900986 */
        if( !(sts&msg&1) || num_found <= 0 ) {
        	sts = om$make_chanselect(channame    = "GRnotify.notification",
					p_chanselect = &notify_chn);
        	if( !(sts & 1) ) {
			__DBGpr_com("om$make_chanselect failed") ;
			goto wrapup;
		}
		classid = OPP_ACpretendin_class_id ;
        	sts = VDGetGridsFromChan_of_Class (
					&msg,
					penmac,
					&notify_chn,
					classid,
					&num_tmp,
					&tmpIds ) ;
        	__DBGpr_int("Number of objs on channel notify",num_tmp);
        	if( !(sts&msg&1) || num_tmp <=0 ) {
			__DBGpr_com("Nothing found on penMacro");
			goto wrapup;
		}
	}

	if( num_tmp > 0 && num_found <= 0 ) {
		cnt = num_tmp ;
	}
	else {
		cnt = 1 ;
	}

	/* check if found objects are pcgMacro */
	for( i = 0; i < cnt; i = i+1 ) {
	    if( num_tmp > 0 ) {
        	classid = OPP_nci_macro_class_id ;
		sts = VDGetGridsFromChan_of_Class (
                                        &msg,
                                        tmpIds[i],
                                        &children_chn,
                                        classid,
                                        &num_found,
                                        &foundIds ) ;
		if( !(sts&msg& 1) ) {
			__DBGpr_com("VDGetGridsFromChan_of_Class failed");
			continue ;
		}
	    }

	    for( j = 0; j < num_found; j = j+1 ) {
		sts = ci$send(	msg      = message ACcpx.find_macro(&model_def),
				targetid = foundIds[j].objid,
				targetos = foundIds[j].osnum);
		if( !(sts & 1) ) {
			__DBGpr_com("ACcpx.find_macro failed");
			continue ;
		}

		objName = NULL ;
		sts = ci$send(	msg  = message ACcpx_defn.ACgive_name(&objName),
				targetid = model_def.objid,
				targetos = model_def.osnum);
		if( !(sts & 1) ) {
			__DBGpr_com("ACcpx_defn.ACgive_name failed");
			continue ;
		}

		pcgFlag = !strcmp( objName, "pcgMacro" );
		if( pcgFlag ) {
			_FREE( foundIds );
			goto wrapup ;
		}
	    }
	    _FREE( foundIds );
	    foundIds = NULL ;
	}

wrapup:
        if( pcgFlag ) {
           status("A pcg macro already exists. Macro not placed.");
        }

	_FREE( tmpIds );
	return pcgFlag ;
}

