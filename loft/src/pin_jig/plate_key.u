/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/pin_jig/plate_key.u
 *
 * Description: Key Lines Implementation.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      06/01/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "ci_mac_def.h"
#include "vlkline.h"

GRobj           ci_mac_def1;
struct GRid     GRIDS[MAX_KL_FEET], CI_MACRO_ID;

extern  EX_get_modid_given_osnum(), VD_is_ancestry_valid(), VLinitCnst(),
	VLsbGetMoldSurface(), VLklGetKeyLines(), VLklGetDiagonalChordDim(),
	VLklGetIntersectionLines(), VLcreateLoftJunction();

extern GRclassid        OPP_VSplate_class_id;

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */
main ()
{
   IGRint       i, msg, temp_types[MAX_KL_TEMP];
   IGRchar      *temp_names[MAX_KL_TEMP], *feet_names[MAX_KL_FEET],
                tmp_temp[MAX_KL_TEMP* MAX_KL_FEET], 
		buffer[MAX_KL_CHAR_FEET * MAX_KL_FEET];

   temp_names[0] = NAM_KL_FRAM;   	temp_types[0] = other_generic ;
   temp_names[1] = NAM_KL_ATTR;   	temp_types[1] = macro_generic ;

   for (i=2; i<MAX_KL_TEMP; i=i+1){
        sprintf( &tmp_temp[i*MAX_KL_CHAR_FEET], "%s%d", NAM_KL_PLATE, (i-1) );
	temp_names[i] = &tmp_temp[i*MAX_KL_CHAR_FEET];
        temp_types[i] = macro_generic ;
   }

   feet_names[0] = NAM_KL_FRLN;
   feet_names[1] = NAM_KL_KLIN;

   for (i = 2; i < 10; i = i + 1)
   {
	sprintf( &buffer[i*MAX_KL_CHAR_FEET], "%s%d", NAM_KL_DIAG, (i-1) );
	feet_names[i] = &buffer[i*MAX_KL_CHAR_FEET] ;
   }

   for (i = 10 ; i < MAX_KL_FEET ; i = i + 1)
   {
        sprintf(&buffer[i*MAX_KL_CHAR_FEET], "%s%d", NAM_KL_PNT, (i-9) )  ;
        feet_names[i] = &buffer[i*MAX_KL_CHAR_FEET] ;
   }

   ci_mac_def1 = NULL_OBJID;

   ac$cimacdef( cimacdef          = ci_mac_def1,
                status            = &msg,
                name              = NAM_KL_MACR,
                temp_num          = MAX_KL_TEMP,
                temp_names        = temp_names,
                temp_types        = temp_types,
                extern_feet_num   = MAX_KL_FEET,
                extern_feet_names = feet_names );

}

place ()
{
IGRlong         msg;

  construct_lines();

  if( GRIDS[0].objid == NULL_OBJID ||
      GRIDS[1].objid == NULL_OBJID     ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_KL_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);
  return(1);
}

compute ()
{
IGRlong         msg;

  construct_lines();

  if( GRIDS[0].objid == NULL_OBJID ||
      GRIDS[1].objid == NULL_OBJID     ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_KL_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);

  return(1);

}

construct_lines()
{
IGRint                  i, retFlag, count, num_pl, nb_attr;
IGRshort		action, props;
IGRlong                 sts, msg;
struct ACrg_coll	attrib[3];
struct GRsymbology      symbology;
struct GRvg_construct   cst;
struct GRid             planID, *list;
struct GRobj_env	plates[MAX_KL_TEMP-2], plane, boxOE, gr_obj, plate;

  retFlag  = FALSE;
  count    = 0;
  list     = NULL;

  for( i=0; i<MAX_KL_FEET; i=i+1 )  GRIDS[i].objid = NULL_OBJID;

  sts = vdchn$GetList(  objID   = &CI_MACRO_ID,
                        chnName = VDCHN_NAME_PARENT,
                        maxCnt  = MAX_KL_TEMP-2,
                        cnt     = &num_pl );
  num_pl = num_pl - 2 ;
  for( i=0; i<num_pl; i=i+1 )
     vdobj$GetTemplate( objID      = &CI_MACRO_ID,
                        nth        = i+2,
                        templateOE = &plates[i] );

  sts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
                                  &msg, 0, &planID ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Key Frame Plane input\n");
            goto wrapup ;
  }

  sts = ci$send( msg = message  NDmacro.ACreturn_foot(
                                &msg, "", &plane.obj_id,
                                plane.mod_env.md_env.matrix_type,
                                &plane.mod_env.md_env.matrix ),
                targetid = planID.objid,
                targetos = planID.osnum );
  if( !(sts&msg&1) ) 
  {
            printf("Can not get the Key Frame Graphic Input\n");
            goto wrapup ;
  }
  plane.mod_env.md_id.osnum = plane.obj_id.osnum;
  ex$get_modid( mod_osnum = plane.mod_env.md_id.osnum,
                 mod_id   = &plane.mod_env.md_id.objid );

  sts = VLklGetKeyLines( &msg, num_pl, plates, &plane, &GRIDS[0] );
  if( !(sts&msg&1) ) 
  {
     printf("Can not Get the Key Lines\n");
     goto wrapup ;
  }

  VLklGetDiagonalChordDim( &msg, num_pl, plates, &GRIDS[0], &GRIDS[2] );

  VLklGetIntersectionLines( &msg, num_pl, plates, &GRIDS[0], 
			    &count, &GRIDS[10] );

  vdobj$GetTemplate( objID      = &CI_MACRO_ID,
		     nth	= 1,
		     templateOE = &boxOE );

  sts = ci$send ( msg =  message ACrg_collect.AClist_attribute(
					&msg, 3, attrib, &nb_attr ),
		targetid = boxOE.obj_id.objid,
		targetos = boxOE.obj_id.osnum );

  gr_obj.obj_id  = GRIDS[1];
  gr_obj.mod_env = MOD_ENV ;

  sts = VLcreateLoftJunction( &msg, &gr_obj, NULL, attrib, nb_attr, NULL,
			      &gr_obj.mod_env, &GRIDS[1] );

  retFlag = TRUE;

wrapup:
  return retFlag ;
}
