/* ------------------------------------------------------
 * Verifies new bevels and features
 */

#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "VDmem_ppl.h"
#include "VDgeom.h"
#include "VLunwMisc.h"

#include "coparamac.h"

extern ASstart_var_fence();
extern ASend_fence();
extern VDstrupr();

#define thePrompt  "Select Bevel Feature(s)"
#define theCommand "Verify Bevels"
#define theFilter  "VLunwFeat"

IGRint traceFlag;


/* -------------------------------------
 * Process the object
 */
int process(featureOE)
TGRobj_env *featureOE;

{
  IGRstat    sts,msg;
  TGRobj_env modelOE;
  TGRobj_env unwrapOE;

  TVLunwBevelInfo bevel;
  
  // Get the model object
  vdobj$GetTemplate(objOE = featureOE,
		    nth   = 1,
		    templateOE = &modelOE);

  // Get the unwrap
  VLunwGetUnwrapForFeature(featureOE,&unwrapOE);

  // Say Hi
  printf("-------------- Unwrap Feature ------------\n");
  vdobj$Print(objOE = featureOE);
  vdobj$Print(objOE =  &modelOE);
  vdobj$Print(objOE = &unwrapOE);

  // Process bevels
  sts = VLunwIsBevel(&modelOE,NULL);
  if (sts & 1) {

    // Get the bevel info
    VLunwGetBevelInfo(&unwrapOE.obj_id,&modelOE.obj_id,&bevel);
    printf("Bevel Specx %s, Spec %s, Stock %.1f, Thickness %.1f, Adj Thickness %.1f\n",
	   bevel.specx,
	   bevel.spec,
	   bevel.stock,
	   bevel.thickness,
	   bevel.adj_thickness);
  }
  
  // Done
wrapup:
  return 1;
}

/* --------------------------------------
 * The main routine
 */
int main()
{
  int sts,msg;
  int response;
  
  TGRobj_env  objOE;
  TGRobj_env *locOEs;
  IGRint      locNum;
  IGRint      i;
  IGRchar     buf[128];

  traceFlag = 0;
  
  while(1) {

    objOE.obj_id.objid = NULL_OBJID;
    
    response = 0;

    UI_message(theCommand);

    sts = ci$locate(prompt  = thePrompt,
                    classes = theFilter,
		    // eligible_classes = &classList,
		    owner_action = LC_RIGID_OWNER | 
                                   LC_RIGID_COMP  |
                                   LC_FLEX_COMP   | 
                                   LC_FLEX_OWNER  |
                                   LC_REF_OBJECTS,

                    stackable    = 1,
		    response     = &response,
		    md_env       = &objOE.mod_env,
		    obj          = &objOE.obj_id.objid,
		    osnum	 = &objOE.obj_id.osnum);

    if (!(sts & 1)) response = 0;

    switch(response) {

    case EX_OBJID:   // Object Set

      printf("============= Object Set =============\n");
      
      /* Grab Located Objects */
      as$start_fence(
      set       = &objOE.obj_id,
      set_env   = &objOE.mod_env,
      nb_obj    = &locNum,
      p_obj_env = &locOEs);

      for(i = 0; i < locNum; i = i + 1) {
        process(&locOEs[i]);
      }

      ASend_fence();
      break;
      
    case EX_DATA:    // Single Object
      
      process(&objOE);
      break;

    } // Switch
  }

wrapup:
  return 1;
}

/* ------------------------------------------
 * Usual command object messages
 */
init()
{
}
sleep() 
{
}
wakeup()
{
  UI_message(theCommand); 
}
delete()
{
}
