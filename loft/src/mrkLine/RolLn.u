/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	I/LOFT:
		PPL file to define the template of the roll object's macro
		definition.  See VLrolLine.S for more information.

*============================================================================*/

#include	<stdio.h>
#include	"OMerrordef.h"
#include	"ciminimum.h"
#include	"cimacros.h"
#include	"ci_mac_def.h"
#include	"macro.h"
#include	"AS_status.h"
#include	"parametric.h"

#include	"vldbgmacros.h"

#include        "vlglinedef.h"		// gen line definitions
#include	"vlrolline.h"		// roll line internal defintions

extern		ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation	     */
/* ========================================================================= */

main ()
{
	IGRlong		sts;

	IGRchar		*temp_names[VLRolMaxNumTemplates],
			tmp_temp[VLRolMaxNumTemplates*20],
			*feet_names[VLRolNumFeet],
                        fnames[(VLRolNumFeet - 10) *  11 ],
			temp_buff[VLRolMaxNumTemplates],
			feet_buff[VLRolNumFeet];

	GRobj 	 	ci_mac_def1;

	IGRint		i, temp_types[VLRolMaxNumTemplates],
			temp_number,
			feet_number,
			currentFoot,
			currentLine,		// number of lines in the feet
			currentName ;		// posn of name in char. array 

	temp_number =  VLRolMaxNumTemplates	;
	feet_number =  VLRolNumFeet		;

	temp_names[VLRolCollIndex] = VLRolCollName	;
	temp_types[VLRolCollIndex] = other_generic	;

	temp_names[VLRolPlateIndex] = VLRolPlateName	;
	temp_types[VLRolPlateIndex] = macro_generic	| other_generic ;

	temp_names[VLRolProcessIndex] = VLRolProcessType ;
	temp_types[VLRolProcessIndex] = parameter_generic ;

        for (i=3; i<VLRolMaxNumTemplates; i=i+1){
           sprintf(&tmp_temp[i*20], "%s%d",VLRolGrCrvName, (i-3) );
           temp_names[i]  = &tmp_temp[i*20];
           temp_types[i] = curve_generic ;
        }
							
	feet_names[VLRolContsIndex] 	= N_MF_CONTENTS 	;

	feet_names[VLRolIndex]		= VLFirstRolName	;
	feet_names[VLVectRolIndex]	= VLFirstRolVectName	;

	feet_names[VLSecRolIndex]	= VLSecondRolName	;
	feet_names[VLSecVectRolIndex]	= VLSecondRolVectName	;

	feet_names[VLThrRolIndex]	= VLThirdRolName	;
	feet_names[VLThrVectRolIndex]	= VLThirdRolVectName	;

	feet_names[VLForRolIndex]	= VLFourthRolName	;
	feet_names[VLForVectRolIndex]	= VLFourthRolVectName	;

	feet_names[VLFifRolIndex]	= VLFifthRolName	;
	feet_names[VLFifVectRolIndex]	= VLFifthRolVectName	;

			// give the rest of the feet a generic name
	currentName = 0 ;
	currentLine = 6 ;

        for ( currentFoot = VLFifVectRolIndex+1; currentFoot < VLRolNumFeet ;
                                                currentFoot = currentFoot+1 )  {

			// line's name
              sprintf( &fnames[currentName * 11], "%.2dth line", currentLine ) ;
                fnames[(currentName * 11) + 10 ] = 0;
                feet_names[currentFoot] = &fnames[currentName*11] ;
                currentName=currentName+1 ;

                currentFoot=currentFoot+1 ;
			// vector's name
              sprintf( &fnames[currentName * 11], "%.2dth vect", currentLine );
                fnames[(currentName * 11) + 10 ] = 0;
                feet_names[currentFoot] = &fnames[currentName*11] ;
                currentName=currentName+1 ;
                currentLine=currentLine+1 ;
        }

  	ci_mac_def1 = NULL_OBJID;
  	ac$cimacdef( 	cimacdef          = ci_mac_def1		,
			name		  = VLMacroRolLn	,
			status 	          = &sts		,
              		temp_num          = temp_number		,
			temp_names        = temp_names		,
			temp_types        = temp_types		,
	      		extern_feet_num   = feet_number		,
	 		extern_feet_names = feet_names );

	__DBGpr_obj( "Placed macro defn", ci_mac_def1 );

return OM_S_SUCCESS;

}

/*********************	End of roll_line.u		***********************/
