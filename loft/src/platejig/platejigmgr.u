/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/platejig/platejig_mgr.u
 *
 * Description: Plate Jigs Implementation.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      08/02/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDchn.h"
#include "VDobj.h"
#include "vsplatedef.h"
#include "vlplatejig.h"
#include "vlpltjigset.h"
#include "ci_mac_def.h"

#define MACRO_NAME		"platejigmgr"
#define MAX_TEMP                23
#define MAX_FEET                100 
#define MAX_CHAR_FEET   	10

#define EXP_DOUBLE		0

GRobj		ci_mac_def1;
struct GRid	GRIDS[MAX_FEET], CI_MACRO_ID;

extern 	VSgetExternalContour(), VLpjGetNamedAttibute(), EXP_create_double(),
	VLevalPltCenterNormalDistance(), VD_bulkDeleteByGRids(),
	VD_bulkDisplayByGRids(), VDpms_findall_ancestryobjects();

extern GRclassid		OPP_nci_macro_class_id;

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{ 
   IGRint	i, msg, temp_types[MAX_TEMP];
   IGRchar	*temp_names[MAX_TEMP], *feet_names[MAX_FEET],
		temp_buffer[MAX_CHAR_FEET*MAX_TEMP], 
		feet_buffer[MAX_CHAR_FEET*MAX_FEET];

   temp_names[0] = "PrimaryFrame";    	   temp_types[0] = macro_generic;
   temp_names[1] = "SecondaryFrame";	   temp_types[1] = macro_generic;
   temp_names[2] = "Attributes";	   temp_types[2] = macro_generic;

   for (i=0; i<MAX_TEMP-3; i=i+1)
   {
        sprintf( &temp_buffer[i*MAX_CHAR_FEET], "Plate%d", i+1 );
        temp_names[i+3] = &temp_buffer[i*MAX_CHAR_FEET];
        temp_types[i+3] = macro_generic ;
   }

   for (i=0; i<MAX_FEET; i=i+1)
   {
        sprintf( &feet_buffer[i*MAX_CHAR_FEET], "Edge%d", i+1 );
        feet_names[i] = &feet_buffer[i*MAX_CHAR_FEET];
   }

   ci_mac_def1 = NULL_OBJID;

   ac$cimacdef( cimacdef          = ci_mac_def1,
		status            = &msg,
		name              = MACRO_NAME,
		temp_num	  = MAX_TEMP,
		temp_names	  = temp_names,
		temp_types	  = temp_types,
		extern_feet_num   = MAX_FEET,
		extern_feet_names = feet_names );

}

place ()
{
IGRlong		msg;

  construct_platejigmgr();

  if( GRIDS[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);
  return(1);
}


compute ()
{
IGRlong         msg;

  construct_platejigmgr();

  if( GRIDS[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);

  return(1);

}

construct_platejigmgr()
{
IGRlong                 sts, msg;
IGRint                  i, num_pl, num_bnd_edges, num_feet, edge_temp,
			base_pl, jig_side, inv_norm, *edge_dir;
IGRdouble		Bpln[6], max_dist;
IGRchar			side[40];
struct GRobj_env        plates[MAX_TEMP-3], *bnd_edges, csOE ;
struct GRmd_env         loc_env;
struct ACrg_coll	attr[7], pj_attr;

  num_pl        = 0;
  num_bnd_edges = 0;

  edge_dir  = NULL;
  bnd_edges = NULL;

  for( i=0; i<MAX_FEET; i=i+1 )  GRIDS[i].objid = NULL_OBJID;

  sts = vdchn$GetList(  objID   = &CI_MACRO_ID,
                        chnName = VDCHN_NAME_PARENT,
                        maxCnt  = MAX_TEMP-3,
                        cnt     = &num_pl );
  num_pl = num_pl - 3 ;
  for( i=0; i<num_pl; i=i+1 )
     vdobj$GetTemplate( objID      = &CI_MACRO_ID,
                        nth        = i+3,
                        templateOE = &plates[i] );

  ci$get_module_info( md_env = &loc_env);

  strcpy( pj_attr.name, NAM_PJS_BASEPLANE );
  VLpjGetNamedAttibute( &msg, &CI_MACRO_ID, &pj_attr );
  base_pl = (IGRint) pj_attr.desc.value.att_exp;

  strcpy( pj_attr.name, NAM_PJS_JIGSIDE );
  VLpjGetNamedAttibute( &msg, &CI_MACRO_ID, &pj_attr );
  jig_side = (IGRint)pj_attr.desc.value.att_exp;
  
  strcpy( pj_attr.name, NAM_PJS_SCD_EDGE_TEMP );
  VLpjGetNamedAttibute( &msg, &CI_MACRO_ID, &pj_attr );
  edge_temp = (IGRint)pj_attr.desc.value.att_exp;

  if( jig_side == IDX_PJS_INSIDE )
  {
     strcpy( side, VS_K_plTopSfPath );
     inv_norm =  1;
  }
  else 
  {
     strcpy( side, VS_K_plBotSfPath );
     inv_norm = -1;
  }

  if( base_pl != IDX_PJS_BASEPL )      inv_norm = 1;

  if( base_pl == IDX_PJS_BASEPL )              base_pl = IDX_J5;
  else if( base_pl == IDX_PJS_CENTERLINE )     base_pl = IDX_J4;
  else                                         base_pl = IDX_J3;

  VSgetExternalContour( &msg, num_pl, plates, &loc_env, side,
			&num_bnd_edges, &bnd_edges, NULL, &edge_dir );

  for( i=0; i<num_bnd_edges; i=i+1 )	GRIDS[i] = bnd_edges[i].obj_id ;

  num_feet = num_bnd_edges;

  VLevalPltCenterNormalDistance( plates, num_pl, side, base_pl,
                     inv_norm, TRUE, &Bpln[0], &Bpln[3], &max_dist, msg );

  strcpy( attr[0].name, NAM_PJS_COGX );
  attr[0].desc.type = AC_ATTRIB_DOUBLE;
  attr[0].desc.value.att_exp =  Bpln[0];

  strcpy( attr[1].name, NAM_PJS_COGY );
  attr[1].desc.type = AC_ATTRIB_DOUBLE;
  attr[1].desc.value.att_exp =  Bpln[1];

  strcpy( attr[2].name, NAM_PJS_COGZ );
  attr[2].desc.type = AC_ATTRIB_DOUBLE;
  attr[2].desc.value.att_exp =  Bpln[2];

  strcpy( attr[3].name, NAM_PJS_NRMX );
  attr[3].desc.type = AC_ATTRIB_DOUBLE;
  attr[3].desc.value.att_exp =  Bpln[3];

  strcpy( attr[4].name, NAM_PJS_NRMY );
  attr[4].desc.type = AC_ATTRIB_DOUBLE;
  attr[4].desc.value.att_exp =  Bpln[4];

  strcpy( attr[5].name, NAM_PJS_NRMZ );
  attr[5].desc.type = AC_ATTRIB_DOUBLE;
  attr[5].desc.value.att_exp =  Bpln[5];

  strcpy( attr[5].name, NAM_PJS_MAXD );
  attr[6].desc.type = AC_ATTRIB_DOUBLE;
  attr[6].desc.value.att_exp =  max_dist;

  GRIDS[num_feet].objid = NULL_OBJID;
  GRIDS[num_feet].osnum = loc_env.md_id.osnum;
  ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 7, attr ),
                targetid = GRIDS[num_feet].objid,
                targetos = GRIDS[num_feet].osnum );
  num_feet = num_feet + 1 ;

  if( jig_side == IDX_PJS_BOTH && edge_temp == 1 )
  {
      num_bnd_edges = 0;
      if( bnd_edges ) { free( bnd_edges ); bnd_edges = NULL; }
      if( edge_dir  ) { free( edge_dir  ); edge_dir  = NULL; }
      VSgetExternalContour( &msg, num_pl, plates, &loc_env, VS_K_plTopSfPath,
			    &num_bnd_edges, &bnd_edges, NULL, &edge_dir );

      for( i=0; i<num_bnd_edges; i=i+1 )GRIDS[num_feet+i] = bnd_edges[i].obj_id;
  }

wrapup:
  if( bnd_edges ) { free( bnd_edges ); bnd_edges = NULL; }
  if( edge_dir  ) { free( edge_dir  ); edge_dir  = NULL; }
  return 1;
}

/* ========================================================================= */
/* internal function NDdelete()
/* ========================================================================= */
NDdelete(md_env)
struct GRmd_env *md_env;
{
IGRint		i, nb_obj;
IGRlong		sts;
IGRchar		macName[128];
GRclassid	classid[1];
GRobjid		*obj_list;
struct GRid	object_id;
struct GRobj_env	parentOE;

   nb_obj     = 0;
   obj_list   = NULL;
   classid[0] = OPP_nci_macro_class_id ;

   sts = VDpms_findall_ancestryobjects (
                                        md_env->md_id.osnum,
                                        1,
                                        classid,
                                        &nb_obj,
                                        NULL);
   if( !(sts&1) || !nb_obj ) goto wrapup ;

   obj_list = ( GRobjid * ) malloc( nb_obj * sizeof( GRobjid ) );
   if( obj_list == NULL ) 
   {
	printf("Can not allocate memory\n" );
	goto wrapup;
   }

   sts = VDpms_findall_ancestryobjects(
                                        md_env->md_id.osnum,
                                        1,
                                        classid,
                                        &nb_obj,
                                        obj_list);
   if( !(sts&1) || !nb_obj ) goto wrapup ;

   for(i = 0; i < nb_obj; i=i+1 ) 
   {
      object_id.objid = obj_list[i];
      object_id.osnum = md_env->md_id.osnum;

      vdobj$Get( objID = &object_id, macName = macName );
      if( !strcmp( macName, "platejig" ) )
      {
	sts = vdobj$GetTemplate( objID = &object_id,
				 nth   = 0,
				 templateOE = &parentOE );
	if( parentOE.obj_id.objid == NULL_OBJID )
        {
           VD_bulkDisplayByGRids( md_env, GRbe, 1, &object_id  );
           VD_bulkDeleteByGRids( md_env, 1, &object_id  );
        }
      }
   }

wrapup:
   ci$send( msg      = message ov_ci_mac.NDdelete( md_env ),
                        targetid = CI_MACRO_ID.objid,
                        targetos = CI_MACRO_ID.osnum,
                        mode     = WRT_message );
   if( obj_list ) { free( obj_list ); obj_list = NULL; }
   return(1);
}
