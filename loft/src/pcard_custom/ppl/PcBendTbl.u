/***************************************************************************
 * INGR - PPL
 *
 * File:        PcBendTbl.u
 *
 * Description:	PPL macro for reporting a bending table on profile cards
 *
 * Dependencies:
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      02/17/00        mjablko         creation date
 *
 ***************************************************************************/
// DEBUG INFO
//***********

//#define DEBUG 

//INCLUDES
#include "VDppl.h"
#include "v_pplslc.h"
#include "v_slcdef.h"
#include "grwireframe.h"
#include "fontmacros.h"
#include "cotxmacros.h"

#include "vldbgmacros.h"

#include "PC_macros.h"

extern 		printf(), MAmulmx(), EX_get_oid_nodname(), GRretrieve_font(),
		GRdpb_get(), GRang_place_text();
extern  int     GRcreate_linestring();

struct GRid	GRid_list[100];
GRspacenum	cs_osnum;

#define INDEX		"Ind"
#define STEP		"Step"
#define HEIGHT		"Height"
#define MACRO_NAME	"Macro"

#define SLNO_DIST	10.0
#define STEP_DIST	20.0
#define HEIGHT_DIST	20.0
#define MACRO_DIST	20.0
#define ROW_HEIGHT	5.0

#define MAX_ROWS	33
#define COLUMN_GAP	10

#define TEXT_HEIGHT 	1.5
#define TEXT_WIDTH      1.5

//#define MAIDMX		0


/* ========================================================================== */

int placeLine( ip1, ip2, Count )
double ip1[3] , ip2[3];
int     *Count;
{
double myp[6];
        v_equal( ip1, myp );
        v_equal( ip2, &myp[3] );

        gr$place_linear_object(
                msg             = &msg,
                num_points      = 2,
                points          = myp,
                object_id       = &GRid_list[*Count] );

        *Count = *Count + 1;
}

/* ========================================================================== */

pl_symbol( Count , text_str, point, font, just, hscale, wscale, matrix)
char    text_str[132], font[20];
double  point[3], matrix[16], hscale, wscale;
IGRshort        just;
int     *Count;
{
    IGRshort                position,text_just,style;
    char                    text_string[132], font_name[20];
    double                  text_matrix[16], text_pos[3];
    struct GRid             TEXT, OBJS[10];
    GRobj                   OBJECT;
    int                     i, size, net, len;
    struct GRdpb_text_symb  text_symb;

    text_just = (just);
    strcpy(text_string,(text_str));
    for(i=0;i<16;i=i+1) text_matrix[i] = (matrix)[i];
    for(i=0;i<3;i=i+1) text_pos[i] = (point)[i];
    strcpy(font_name,(font));

    // get the font managers objid
#ifdef DEBUG
//    printf("I'm in pl_symbol(), Text = %s\n", text_str );
#endif

    ex$get_objid_from_NOD ( NODname   = "IGENOD",
                            objname   = "GRFONTMGR",
                            pobjid    = &OBJECT,
                            mod_osnum = cs_osnum);

#ifdef DEBUG
//    printf("ex$get_objid_from_NOD id[%d]\n", OBJECT);
#endif

    // get the position of the string in the font manager

    position = -1;

    ci$send(msg = message GRfm.GRvirt_search ( &msg, font_name, &position),
            targetid = OBJECT,
            targetos = cs_osnum);
#ifdef DEBUG
//    printf("GRfm.GRvirt_search msg=%d\n", msg);
#endif

    if(position == -1)
    {
        // if font not found then retrieve it

        font$retrieve(msg = &msg,
                      font = font_name,
                      local_font_name = font_name,
                      font_flags = 0x01,
                      font_position = &position);
#ifdef DEBUG
//       printf("font$retrieve msg=%d\n", msg );
#endif
    }

    // get the active text symbology

    size = sizeof( struct GRdpb_text_symb );
    gr$get_text_symb(msg     = &msg,
                     sizbuf  = &size,
                     buffer  = &text_symb,
                     nret    = &net);

#ifdef DEBUG
//    printf("gr$get_text_symb msg=%d\n", msg);
//    printf("txt height=%.3f, width=%.3f\n", text_symb.Active_height,text_symb.Active_width );
#endif

    if( strcmp(font_name,"active") != 0 )  text_symb.Active_font = position;
    text_symb.Active_just       = text_just;
    text_symb.Active_charspac   = 1;
    text_symb.Active_linespac   = 1;
    text_symb.Active_height = (text_symb.Active_height / text_symb.Active_height) * (hscale);
    text_symb.Active_width = (text_symb.Active_width / text_symb.Active_width) * (wscale);

    // place the text here

    len = strlen(text_string);
    co$place_text( msg = &msg,
                   text_string = text_string,
                   text_length = &len,
                   origin = text_pos,
                   rot_matrix = text_matrix,
                   ActiveDisplay=&dis,
                   TextSymb = &text_symb,
                   mode = 0,
                   buffer =&TEXT);

#ifdef DEBUG
//    printf("co$place_text msg =%d, ID[ %d , %d ]\n", msg , TEXT.objid , TEXT.osnum );
#endif


    GRid_list[*Count] = TEXT ;
    *Count = *Count + 1;
}

/* ========================================================================== */

int createBox( ip1, Xvec, Yvec, topLine, Count )
IGRdouble	*ip1, *Xvec, *Yvec;
IGRint		*Count, topLine;
{
    IGRint      i;
    IGRdouble   tmp_pt1[3], tmp_pt2[3], tmp_pt3[3];

    for( i=0; i<3; i=i+1 ) tmp_pt1[i] = ip1[i] + ROW_HEIGHT * Yvec[i] ;
    placeLine( ip1, tmp_pt1, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = ip1[i] + ( SLNO_DIST + STEP_DIST +
                                    HEIGHT_DIST + MACRO_DIST ) * Xvec[i] ;
    if( topLine ) placeLine( ip1, tmp_pt2, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt3[i] =  tmp_pt1[i] + ( SLNO_DIST + STEP_DIST +
                                        HEIGHT_DIST + MACRO_DIST ) * Xvec[i] ;
    placeLine( tmp_pt1, tmp_pt3, Count );
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = ip1[i] + SLNO_DIST * Xvec[i] ;
    for( i=0; i<3; i=i+1 ) tmp_pt3[i] = tmp_pt1[i] + SLNO_DIST * Xvec[i] ;
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = tmp_pt2[i] + STEP_DIST * Xvec[i] ;
    for( i=0; i<3; i=i+1 ) tmp_pt3[i] = tmp_pt3[i] + STEP_DIST * Xvec[i] ;
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = tmp_pt2[i] + HEIGHT_DIST * Xvec[i] ;
    for( i=0; i<3; i=i+1 ) tmp_pt3[i] = tmp_pt3[i] + HEIGHT_DIST * Xvec[i] ;
    placeLine( tmp_pt2, tmp_pt3, Count );
}

/* ========================================================================== */

int createTable( ip1, Xvec, Yvec, Count )
IGRdouble       *ip1, *Xvec, *Yvec;
IGRint          *Count;
{
    IGRint          i, j;
    IGRdouble       tmp_pt1[3], tmp_pt2[3], tmp_pt3[3];

    for( i=0; i<3; i=i+1 ) tmp_pt1[i] = ip1[i] +(ROW_HEIGHT*(MAX_ROWS+1))*Yvec[i];
    placeLine( ip1, tmp_pt1, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = ip1[i] + ( SLNO_DIST + STEP_DIST +
                                        HEIGHT_DIST + MACRO_DIST ) * Xvec[i] ;
    placeLine( ip1, tmp_pt2, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt3[i] =  tmp_pt1[i] + ( SLNO_DIST + STEP_DIST +
                                        HEIGHT_DIST + MACRO_DIST ) * Xvec[i] ;
    placeLine( tmp_pt1, tmp_pt3, Count );
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = ip1[i] + SLNO_DIST * Xvec[i] ;
    for( i=0; i<3; i=i+1 ) tmp_pt3[i] = tmp_pt1[i] + SLNO_DIST * Xvec[i] ;
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = tmp_pt2[i] + STEP_DIST * Xvec[i] ;
    for( i=0; i<3; i=i+1 ) tmp_pt3[i] = tmp_pt3[i] + STEP_DIST * Xvec[i] ;
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = tmp_pt2[i] + HEIGHT_DIST * Xvec[i] ;
    for( i=0; i<3; i=i+1 ) tmp_pt3[i] = tmp_pt3[i] + HEIGHT_DIST * Xvec[i] ;
    placeLine( tmp_pt2, tmp_pt3, Count );

    for( i=0; i<3; i=i+1 ) tmp_pt2[i] = ip1[i] + ROW_HEIGHT * Yvec[i] ;
    for( i=0; i<MAX_ROWS+1; i=i+1 )
    {
        for( j=0; j<3; j=j+1 ) tmp_pt3[j] = tmp_pt2[j] + ( SLNO_DIST + STEP_DIST +
                                        HEIGHT_DIST + MACRO_DIST ) * Xvec[j] ;
        placeLine( tmp_pt2, tmp_pt3, Count );
        for( j=0; j<3; j=j+1 ) tmp_pt2[j] = tmp_pt2[j] + ROW_HEIGHT * Yvec[j] ;
    }
}

/* ========================================================================== */

int createText( ip, Xvec, Yvec, txt_cs, slNo, Step, Height, MacroName, Count )
IGRdouble 	*ip, *Xvec, *Yvec, *txt_cs;
IGRint		*Count;
IGRchar		*slNo, *Step, *Height, *MacroName;
{
    IGRint      i;
    IGRdouble   tmp_pt[3];

    for( i=0; i<3; i=i+1 )
        tmp_pt[i] = ip[i] + SLNO_DIST / 2.0 * Xvec[i] ;
    for( i=0; i<3; i=i+1 )
        tmp_pt[i] = tmp_pt[i] + ROW_HEIGHT / 2.0 * Yvec[i] ;
    pl_symbol( Count ,  slNo , tmp_pt ,"active", 7 ,
               TEXT_HEIGHT , TEXT_WIDTH , txt_cs );

    for( i=0; i<3; i=i+1 )
        tmp_pt[i] = tmp_pt[i] + ( SLNO_DIST + STEP_DIST ) / 2.0 * Xvec[i] ;
    pl_symbol( Count , Step, tmp_pt , "active", 7 ,
               TEXT_HEIGHT , TEXT_WIDTH , txt_cs );

    for( i=0; i<3; i=i+1 )
        tmp_pt[i] = tmp_pt[i] + ( STEP_DIST + HEIGHT_DIST ) / 2.0 * Xvec[i] ;
    pl_symbol( Count , Height, tmp_pt , "active", 7 ,
               TEXT_HEIGHT , TEXT_WIDTH , txt_cs );

    if( MacroName[0] != '\0' )
    {
        for( i=0; i<3; i=i+1 )
            tmp_pt[i] = tmp_pt[i] + ( HEIGHT_DIST + MACRO_DIST ) / 2.0 * Xvec[i] ;
        pl_symbol( Count , MacroName, tmp_pt , "active", 7 ,
                   TEXT_HEIGHT , TEXT_WIDTH , txt_cs );
    }
}

/* ========================================================================== */

void header()
{
    IGRint              i, Count, four;
    IGRlong             msg;
    IGRdouble           CsOrigin[3], Xvec[3], Yvec[3], OrgMat[16], trfMat[16],
                        RefMat[16] ;
    struct GRobj_env    cs, tmp_obj;

    Count = 0;
    four  = 4;

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 0,
                            value      = &cs  );

    cs_osnum = cs.mod_env.md_id.osnum;
    /* Get the coordinate system matrix */
    ci$send ( msg = message GRgencs.GRgetmatrix( &msg, OrgMat ),
              targetid = cs.obj_id.objid,
              targetos = cs.obj_id.osnum );

    if( cs.mod_env.md_env.matrix_type != MAIDMX )
    {
        MAmulmx( &msg, &four, &four, &four, cs.mod_env.md_env.matrix,
                 OrgMat, trfMat );
        for( i=0; i<16; i=i+1 )
            RefMat[i] = trfMat[i];
    }
    else  for( i=0; i<16; i=i+1 )
        RefMat[i] = OrgMat[i];

    /* STore CS origin */
    CsOrigin[0] = RefMat[3];
    CsOrigin[1] = RefMat[7];
    CsOrigin[2] = RefMat[11];

    /* Store direction and orthogonal vectors */
    for ( i=0; i<3; i=i+1 )
    {
        Xvec[i] = RefMat[4*i];
        Yvec[i] = -1 * RefMat[4*i+1];
    }

    createTable( CsOrigin, Xvec, Yvec, &Count );
    createText( CsOrigin, Xvec, Yvec, RefMat, INDEX, STEP,
                HEIGHT, MACRO_NAME, &Count );

    vd$ppl_set_size(  which_info = OUTPUT_INFO,
                      size  = Count );
    for( i=0; i<Count; i=i+1 )
    {
        tmp_obj.obj_id = GRid_list[i];
        vd$ppl_setarg_at_index( which_info = OUTPUT_INFO,
                                index = i,
                                type  = VD_object,
                                value = &tmp_obj );
    }
}

/* ========================================================================== */

void row()
{
    IGRint                  i, Count, index, four, row_no, column_no;
    IGRdouble		    step, height, pt[3];
    IGRchar		    sInd[30], sStep[30], sHeight[30], MacName[30], Id[80];
    IGRlong                 msg, sts;
    IGRdouble               CsOrigin[3], Xvec[3], Yvec[3], OrgMat[16], trfMat[16],
                            RefMat[16] ;
    struct GRobj_env        cs, tmp_obj, MacObj;

    Count = 0;
    four  = 4;

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 0,
                            value      = &cs  );

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 1,
                            value      = &index  );
    sprintf(sInd, "%d", index );

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 2,
                            value      = &step  );
    sprintf(sStep, "%.1lf", fabs(step)  );

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 3,
                            value      = &height  );
    sprintf(sHeight, "%.1lf", fabs(height)  );

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 4,
                            value      = MacName  );

    vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                            index      = 5,
                            value      = &MacObj  );


	__DBGpr_obj("Got macro: ", MacObj.obj_id );
	__DBGpr_str("Macro Name: ", MacName );

    /* Get MFG id of a macro */
    sts = get_id( MacName, MacObj, Id );
    if( sts ) return;

//printf("Got id %s\n", Id );

    cs_osnum = cs.mod_env.md_id.osnum;

    /* Get the coordinate system matrix */
    ci$send ( msg = message GRgencs.GRgetmatrix
              ( &msg, OrgMat ),
              targetid = cs.obj_id.objid,
              targetos = cs.obj_id.osnum );

    if( cs.mod_env.md_env.matrix_type != MAIDMX ){
        MAmulmx( &msg, &four, &four, &four, cs.mod_env.md_env.matrix,
                 OrgMat, trfMat );
        for( i=0; i<16; i=i+1 )   RefMat[i] = trfMat[i];
    }
    else  for( i=0; i<16; i=i+1 )   RefMat[i] = OrgMat[i];

    /* Store direction and orthogonal vectors */
    for ( i=0; i<3; i=i+1 ) {
        Xvec[i] = RefMat[4*i];
        Yvec[i] = -1 * RefMat[4*i+1];
    }

    if( index > MAX_ROWS )
    {
        row_no = ( index - ( (int)( index/MAX_ROWS ) ) * MAX_ROWS );

        column_no = ( index - row_no ) / MAX_ROWS ;

        if( row_no == 0 ) 
        {
            column_no = column_no - 1 ;
            row_no = MAX_ROWS ;
        }

        for( i=0; i<3; i=i+1 ) 
            pt[i] = RefMat[i*4+3]  + (( SLNO_DIST + STEP_DIST + HEIGHT_DIST + 
                                        MACRO_DIST + COLUMN_GAP ) * column_no  ) * Xvec[i];
        if( row_no == 1 )
        {
            createTable( pt, Xvec, Yvec, &Count );

            createText( pt, Xvec, Yvec, RefMat, INDEX, STEP,
                        HEIGHT, MACRO_NAME, &Count );
        }
        for( i=0; i<3; i=i+1 ) pt[i] = pt[i] + row_no * ROW_HEIGHT * Yvec[i];
    }
    else
    {
        for( i=0; i<3; i=i+1 )
            pt[i] = RefMat[i*4+3] + index * ROW_HEIGHT * Yvec[i];
    }

    createText( pt, Xvec, Yvec, RefMat, sInd, sStep,
                sHeight, Id, &Count );

    vd$ppl_set_size(  which_info = OUTPUT_INFO,
                      size  = Count );
    for( i=0; i<Count; i=i+1 )
    {
        tmp_obj.obj_id = GRid_list[i];
        vd$ppl_setarg_at_index( which_info = OUTPUT_INFO,
                                index = i,
                                type  = VD_object,
                                value = &tmp_obj );
    }
}

/* ========================================================================== */

#define ID_NAME "id"
#define HOLE_ID_FOOT "ho_nr"
#define ET_ID_FOOT "et_type"


extern EX_get_modid_given_osnum();

/* ========================================================================== */

int get_id( macro_name, macro, symbol )
char       *macro_name, *symbol;
struct GRobj_env macro;
{
    struct GRobj_env	macro_def;
    IGRint		sts;

	if( macro.obj_id.objid == 0 ) {
		printf("Invalid macro\n" );
		return(1);
	}

	__DBGpr_obj("GET_ID: Macro: ", macro.obj_id );

        get_mod_env( macro, &macro_def );
        ex$get_modid( mod_osnum = macro_def.mod_env.md_id.osnum,
                      mod_id 	= &macro_def.mod_env.md_id.objid ) ;

	__DBGpr_str( "Name: ", macro_name );

	get_macro_symbol( &macro, &macro_def, macro_name, symbol );

	__DBGpr_str( "Symbol ", symbol );
}

get_mod_env( from_obj, to_obj )
struct GRobj_env	from_obj, *to_obj;
{

        to_obj->mod_env.md_id.osnum = from_obj.obj_id.osnum ;
        ex$get_modid( mod_osnum = from_obj.mod_env.md_id.osnum,
                      mod_id 	= &to_obj->mod_env.md_id.objid ) ;
}

/*==========================================================================*/

int find_id_foot( obj, pattern, name, index )
struct GRobj_env    	*obj;
IGRchar			*pattern;
IGRchar			*name;
IGRshort		*index;
{

	IGRint 		sts, msg, i, feet_num;
	struct myfeet	*myfeet;


	sts = ci$send ( msg = message ACcpx_defn.ACgive_feet_desc( &feet_num, &myfeet), 
                  targetid = obj->obj_id.objid,
                  targetos = obj->obj_id.osnum );

  	if( !( sts & 1 ) ) { 
    		printf( "GET_FOOT_STRUCT: ACcpx_defn.ACgive_feet_desc failed (%d[%d])\n", 
            			obj->obj_id.objid, obj->obj_id.osnum );
    		return(1);
  	}
	for( i=0; i<feet_num; i=i+1 ) {

printf("Looking at foot [%d] : %s\n", i, myfeet[i].name );
		if( strstr( myfeet[i].name, pattern ) ) {

printf("Found %s at %d\n", myfeet[i].name, i );
			strcpy( name, myfeet[i].name);
			*index = i;
			return(0);
		}
	}
}
	
/*==========================================================================*/

get_id_foot( obj, id_foot_name, id_name, macro_type )
struct GRobj_env	*obj;
IGRchar			*id_foot_name;
IGRchar			*id_name;
IGRchar			*macro_type;
{
	struct GRobj_env	param_macro;
	struct ret_struct 	attr;

  	get_macro_foot( id_foot_name, &param_macro.obj_id, obj->obj_id );

#ifdef DEBUG 
  	printf("Got param_macro %d[%d] from object %d[%d]\n", 
				param_macro.obj_id.objid, 
         			param_macro.obj_id.osnum, 
				obj->obj_id.objid, 
				obj->obj_id.osnum );
#endif

	get_mod_env( *obj, &param_macro );

        get_foot_struct( &attr, id_name, obj->mod_env, param_macro.obj_id );

#ifdef DEBUG
        printf( "Found: %s\n",  attr.var.text_st.text_string);
#endif
	
	strcpy( macro_type, attr.var.text_st.text_string);

  return;
}

/*==========================================================================*/

get_macro_symbol( obj, macro_def, macro_name, id_symbol)
struct GRobj_env    	*obj;
struct GRobj_env    	*macro_def;
IGRchar			*macro_name, *id_symbol;
{
  	IGRchar 		id_foot_name[20];
  	IGRshort 		i, index;
  
#ifdef DEBUG  
  printf("Checking macro %d[%d]\n", obj->obj_id.objid, obj->obj_id.osnum );
#endif

	if( strstr( macro_name, "iget" ) ) 
		get_id_foot( obj, ET_ID_FOOT, ID_NAME, id_symbol );
	if( strstr( macro_name, "avho_ho" ) ) 
		get_id_foot( obj, HOLE_ID_FOOT, ID_NAME, id_symbol );
		
	else {
		find_id_foot( macro_def, ID_NAME, id_foot_name, &index );
		get_id_foot( obj, id_foot_name, ID_NAME, id_symbol );
	}
	if( id_symbol == NULL || id_symbol[0] == 0 ) 
		strcpy( id_symbol, macro_name ); 
}
