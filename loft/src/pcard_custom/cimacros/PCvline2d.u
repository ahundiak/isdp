/***************************************************************************
 * INGR - PPL
 *
 * File:        PCvline2d.u
 *
 * Description:	PPL macro for placing an end with no end treatment on profile cards
 *
 * Dependencies:
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      12/11/00        krobinson     creation
 *
 *
 ***************************************************************************/

#define VD_PPL

// DEBUG INFO
//***********

//#define DEBUG

// INCLUDES
//***********
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "vd_ve.h"
#include "v_edgedef.h"
#include "v_edgemacros.h"
#include "vdparmacros.h"
#include "vdsetmacros.h"
#include "vldbgmacros.h"
#include "grwireframe.h"
#include "grdpb.h"
#include "grdpbmacros.h"
#include "fontmacros.h"
#include "cotxmacros.h"

// Macro constants
//******************
#define MAX_FEET      60
#define MAX_TEMP      9
#define MAX_CHA_TEMP  20

// CI_MACRO variables
//**********************
GRobj           ci_mac_def1;
int             stat, msg, grCount;
int             temp_types[MAX_TEMP];
char           *temp_names[MAX_TEMP], *feet_names[MAX_FEET];
char            txt[15], buff[MAX_FEET*MAX_CHA_TEMP];
struct GRmd_env MOD_ENV;

// Macro templates
//*******************
struct GRobj_env MacroCS;
double           FrameHeight, FrameWidth;
char             TopLabel[10], BottLabel[10];
int              BeamType, Flip;
int              ETType, Ttype, Btype;
double           TFlCut, BFlCut, TFlSn, BFlSn, FlCut, WebAngDist, 
                 Stock, CopeDepth, CopeRad, FlgDelta;
double           WebAngle, Thor, Tvert, Trad, Bhor, Bvert, Brad, BeamHeight;

// Auxilary global variables
//*****************************
struct ret_struct     expr;
struct GRid           CI_MACRO_ID,  GRid_list[MAX_FEET];
struct IGRdisplay     dis;
struct GRvg_construct cst;

// Global variables
//****************
double TopWebRatio, BotWebRatio;
int    Sim;

double dim_txt_ht ;
double lbl_txt_ht ;
double lbl_pnt[3] ;
double txt_cs[16] ;

int sign ;
int flip , sts ;
int count ;

char dmtxt[10] ;

int     mcsign;
//double vwcs[16], macs[16];
double mcxvec[3], mcyvec[3], mczvec[3], mcorigin[3];
double vwxvec[3], vwyvec[3], vwzvec[3], vworigin[3];

double p0[3], p1[3], p2[3], p3[3], p4[3], p5[3], p6[3];
double p7[3], p8[3], p9[3], p10[3], p11[3], p12[3];
double p13[3], p14[3], p15[3], p16[3], p17[3], p18[3];
double p19[3], p20[3], p21[3], p22[3], p23[3], p24[3];
double p25[3], p26[3], p27[3], p28[3], p29[3];
double p30[3], p31[3], p32[3], p33[3], p34[3], p35[3];
double p36[3], p37[3], p38[3], p39[3], p40[3], p41[3];
double p42[3], p43[3], p44[3], p45[3], p46[3], p47[3];
double p51[3], p52[3], p53[3], p54[3], p55[3], p56[3];
double p57[3], p58[3], p59[3], p60[3], p61[3], p62[3];

extern	char *strncpy ();
extern	char *strrchr ();
extern  free(), abs(), fasb();
extern 	int	init_cnst_list();
extern 	GRretrieve_font(), GRplace_text(),
	GRdpb_get(),
	GRang_place_text(),
	BSac2ptctvc(),
	BSellctaxrm(),
  	GRsymbology_options(),
        GRcreate_linestring(),
        GRcreate_conic_by_edge();
extern  EX_get_oid_nodname(), EX_get_modid_given_osnum();
extern  GRdisplay_object ();
extern  BSmdstptcv();
extern  BSactivsplt();

#include "SupMacros.h"
#include "PC2d.h"


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

    int i, j;

    temp_names[0]  = "FrameHeight";       temp_types[0]  = double_type;
    temp_names[1]  = "FrameWidth";        temp_types[1]  = double_type;
    temp_names[2]  = "TopLabel";          temp_types[2]  = text_type;
    temp_names[3]  = "BottLabel";         temp_types[3]  = text_type;
    temp_names[4]  = "BeamType";          temp_types[4] = double_type;
    temp_names[5]  = "BeamHeight";         temp_types[5] = double_type;
    temp_names[6]  = "Stock";              temp_types[6] = double_type;
    temp_names[7]  = "Flip";               temp_types[7] = double_type;
    temp_names[8]  = "MacroCS";            temp_types[8] = ref_generic;

    for ( i=0; i<MAX_FEET; i=i+1) {
        j = i * MAX_CHA_TEMP;
        sprintf(&buff[j],"pcvline_%d", i);
        feet_names[i] = &buff[j];
    }
    ci_mac_def1 = NULL_OBJID;

    ac$cimacdef( cimacdef =  ci_mac_def1,
                 status            = &stat,
                 name              = "PCvline2d",
                 temp_num          = MAX_TEMP,
                 temp_names        = temp_names,
                 temp_types        = temp_types,
                 extern_feet_num   = MAX_FEET,
                 extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{

    construct_comp();

    if( GRid_list[0].objid == NULL_OBJID )
        return(0);

    ci$send( msg = message  ci_macro.set_all_extern_feet( &stat,
                                                          MAX_FEET,
                                                          GRid_list,
                                                          &MOD_ENV ),
             targetid = CI_MACRO_ID.objid,
             targetos = CI_MACRO_ID.osnum);
    return(1) ;
}

/* ========================================================================= */

place ()
{
    construct_comp();

    if( GRid_list[0].objid == NULL_OBJID )
        return(0);

    ci$send( msg = message  ci_macro.set_all_extern_feet( &stat,
                                                          MAX_FEET,
                                                          GRid_list,
                                                          &MOD_ENV ),
             targetid = CI_MACRO_ID.objid,
             targetos = CI_MACRO_ID.osnum);
    return(1);
}

/* =========================================================================


 * ========================================================================= */

construct_comp()
{
    /* Initialize and get input data */
    initialize();

    /* start laying out the points */
    Construct_graphics();

#ifdef DEBUG
    printf("grCount: %d\n", grCount);
#endif

    /* null out the next id for some kind of checking later */
    GRid_list[grCount].objid = NULL_OBJID;
}


/* ========================================================================= */

int initialize()

{
    double angle;

#ifdef DEBUG
    printf("Initialization.\n");
#endif

    /* Collect input data */
    getinput();

#ifdef DEBUG
    printf("\tInput retrieved!\n");
#endif

    /* compute the web angle distance */
    angle = fabs( WebAngle - 90 ) * PI/180;
    WebAngDist = BeamHeight * tan( angle ) ;

    /* initialize the graphics counter */
    grCount = 0;

    /* set the dimension text height */
    dim_txt_ht = DIM;

    /* set the label text height */
    lbl_txt_ht = LABEL;
    dimension_text_height  = lbl_txt_ht;

    /* Get coordinate system matrices */
    compute_cs( MacroCS.obj_id, txt_cs, mcorigin, mcxvec, mcyvec, mczvec );

    /* Set orientation */
    if( Flip == 0)
        Flip = 1;
    else
        Flip = -1;

#ifdef DEBUG
    printf("Initialized!\n");
#endif
}


/* ========================================================================= */

int getinput()
{

#ifdef DEBUG
    printf("\tGetting input.\n");
#endif

    /* GET PARAMETER VALUES */
    getIntParm    ( CI_MACRO_ID, "Flip", &Flip );
    getDoubleParm ( CI_MACRO_ID, "FrameHeight", &FrameHeight );
    getDoubleParm ( CI_MACRO_ID, "FrameWidth", &FrameWidth );
    getIntParm    ( CI_MACRO_ID, "BeamType", &BeamType );
    getTextParm   ( CI_MACRO_ID, "TopLabel", TopLabel );
    getTextParm   ( CI_MACRO_ID, "BottLabel", BottLabel );
    getDoubleParm ( CI_MACRO_ID, "BeamHeight", &BeamHeight );
    getDoubleParm ( CI_MACRO_ID, "Stock", &Stock );

#ifdef DEBUG
    printf("\t\tParameters read.\n");
#endif

    /* Get MacroCS */
    msg = getobj( CI_MACRO_ID, MAX_TEMP - 1, &MacroCS );

#ifdef DEBUG
    printf("\t\tObjects read\n");
    printf( "Coord id[%d, %d]\n", MacroCS.obj_id.objid, MacroCS.obj_id.osnum );
#endif

    if( !( msg&1 ) ) return FALSE;

    if( BottLabel == "" )
        Sim = 0;
    else
        Sim = 1;
}

/* ========================================================================= */

double Feat_along_vector( FeatureSize, FrameHeight, FrameAngleDist )
double FeatureSize, FrameHeight, FrameAngleDist;
{
    double value;

    value = FeatureSize*sqrt(FrameHeight*FrameHeight+FrameAngleDist*FrameAngleDist)/FrameHeight;

#ifdef DEBUG
    printf ("Feature Projected Height %f\n", value);
    printf ("Feature Size %f\n", FeatureSize);
#endif

    return( value);
}

/* ========================================================================= */

Construct_graphics ()
{
    double tmp[3];
    double theight;
    char text_string[128];
    int len;
    struct GRid TEXT;

    /* If Web Angle == 0 then wrong parameters are read
       from the table or macro is simply not prepared
       for profile card extraction. Since the rest of
       features may be correct, do nothing and let
       the user sketch missing one manually */

    straight_cut();
}

/* ========================================================================= *
 *
 *     STRAIGHT CUT
 *
 * ========================================================================= */

straight_cut()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV, pm1[3], pm2[3];
    int dim_pos;
    char Ttxt[10], Btxt[10];

    sprintf( Ttxt, "%.0f", Trad );
    sprintf( Btxt, "%.0f", Brad );

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();

    construct_corner( p14, p21, p22 );
    construct_corner( p13, p23, p24 );

    placeLine( GRid_list, &grCount, p22, p24, 0, 0 );

    /* place top flange */
    if( BeamType == FLAT || BeamType == BTEE )
        placeLine( GRid_list, &grCount, p12, p21, 0, 0 );
    else
        construct_top_flange( p12, p21, FlCut );

    /* place bottom flange */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == TEE || BeamType == BULB )
        placeLine( GRid_list, &grCount, p11, p23, 0, 0 );
    else
        construct_bottom_flange( p11, p23, FlCut );

    /* If PIPE place the center line */
    if( BeamType == PIPE ) {

        /* Left mid point */
        varY = FrameHeight/2;
        v_scale( mcyvec, varY, tmp );
        v_add( p1, tmp, pm1  );

        /* Right bottom point */
        varX = FrameWidth*1.2;
        v_scale( mcxvec, varX*Flip, tmp );
        v_add( pm1, tmp, pm2);

        placeLine( GRid_list, &grCount, pm1, pm2, 4, 0 );
    }

    construct_label();

    /* Place stock line */
    //if(Stock > 0.1)
    //    drawstock();
}

/* ========================================================================= */ 

construct_corner( crnr_pt, opt1, opt2 )
double *crnr_pt, *opt1, *opt2;
{
    /* Connect the points for the top corner feature */
    v_equal( crnr_pt, opt1 );
    v_equal( crnr_pt, opt2 );
}

/* ========================================================================= */

construct_label()
{
    double varX, varY, tmp[3];
    char label[20];

    /* PLACE LABEL */

    /* p51 bottom label height point */
    varY = 0.25 * FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p11, tmp, p51 );

    /* p52 bottom label point */
    varX = Flip * 0.3 * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p51, tmp, p52 );

    /* p53 top label point */
    varY = 0.3 * FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p52, tmp, p53 );

    /* p54 bottom label point */
    varX = Flip * 0.25 * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p53, tmp, p54 );

    if(Stock > 0.1) {
        strcpy( label, BottLabel );
        strcat( label, " S" );
    }
    else
        strcpy( label, BottLabel );

    //place_label( GRid_list, &grCount, p53, TopLabel, dim_txt_ht, txt_cs );
    place_label( GRid_list, &grCount, p52, label, dim_txt_ht, txt_cs);

    return;
}


/* ========================================================================= */

construct_top_flange( lpt1, lpt2, cope )
double *lpt1, *lpt2, cope;
{
    double scale, tmp[3], varX, varY;
    char   txt[30];

    if( cope != 0.0 )
        scale = FLGCUT;
    else
        scale = 0;

#ifdef DEBUG
    printf("FLGCUT = %f\tSCALE = %f\tCOPE = %f\n", FLGCUT, scale, cope );
#endif

    /* p36 - bottom right point */
    varX = Flip * -FrameWidth * scale;
    v_scale( mcxvec, varX, tmp );
    v_add( lpt2, tmp, p36 );

    /* p37 - top right point */
    varY = FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( p36, tmp, p37 );

    /* p38 - top left point */
    varY = FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( lpt1, tmp, p38 );

    /* Connect points */
    placeLine( GRid_list, &grCount, p37, p38, 0, 0 );
    placeLine( GRid_list, &grCount, p36, lpt2, 0, 0 );

    if (FlgDelta == 0)
        placeLine( GRid_list, &grCount, p37, p36, 0, 0 );

    if( BeamType == TEE || BeamType == ITEE )
        placeLine( GRid_list, &grCount, lpt1, p36, 0, 0 );
    else
        placeLine( GRid_list, &grCount, lpt1, p36, 2, 0 );
        
    sprintf( txt, "%f", cope );
    

    /* ADD FLG CUT */
    if ( txt[0] == '-' ) 
    {
        /* p39 - bottom snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p36, tmp, p39 );

        /* p40 - top snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p37, tmp, p40 );

        placeLine( GRid_list, &grCount, p39, p40, 0, 0 );
    }

  if( Sim ) {
    /* PLACE DIMENSION */
    if( cope != 0.0 ) {
        sprintf( txt, "%.0f", fabs(cope) );
        place_linear_dim( GRid_list, &grCount, p37, p21, DIM_ABOVE, DIM_TXT_INSIDE, txt, 6.0 );
    }
  }
}

/* ========================================================================= */

construct_bottom_flange( lpt1, lpt2, cope )
double *lpt1, *lpt2, cope;
{
    double scale, tmp[3], varX, varY;
    char   txt[30];

    if( FlCut != 0.0 )
        scale = FLGCUT;
    else
        scale = 0;

#ifdef DEBUG
    printf("FLGCUT = %f\tSCALE = %f\n", FlCut, scale );
#endif

    /* p31 - bottom right point */
    varX = Flip * -FrameWidth * scale;
    v_scale( mcxvec, varX, tmp );
    v_add( lpt2, tmp, p31 );

    /* p32 - top right point */
    varY = -FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( p31, tmp, p32 );

    /* p33 - top left point */
    varY = -FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( lpt1, tmp, p33 );

    /* Connect points */
    placeLine( GRid_list, &grCount, p32, p33, 0, 0 );
    placeLine( GRid_list, &grCount, p31, lpt2, 0, 0 );

    if (FlgDelta == 0)
        placeLine( GRid_list, &grCount, p32, p31, 0, 0 );

    if( BeamType == ITEE )
        placeLine( GRid_list, &grCount, lpt1, p31, 0, 0 );
    else if( BeamType == PIPE )
        placeLine( GRid_list, &grCount, lpt1, p31, 2, 0 );

    sprintf( txt, "%f", cope );

    /* ADD FLG CUT */
    if ( txt[0] == '-' )
    {
        /* p34 - bottom snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p31, tmp, p34 );

        /* p35 - top snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p32, tmp, p35 );

        placeLine( GRid_list, &grCount, p34, p35, 0, 0 );
    }

}

/* ========================================================================= */

construct_frame_points()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;

    /* PLACE FRAME POINTS */

    /* Left bottom point */
    v_equal( mcorigin , p1 );

    /* Left top point */
    varY = FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p1, tmp, p2 );

    /* Right bottom point */
    varX = FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p1, tmp, p3 );

    /* Right top point */
    varX = FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p2, tmp, p4 );
}

/* ========================================================================= */

construct_boundary_points()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, top_fl_ratio, bot_fl_ratio;;

    /* PLACE BOUNDARY POINTS */

    /* p11 - origin */
    /* If no bottom flange put boundary on the origin */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == BULB || BeamType == TEE )
        bot_fl_ratio = 0;
    /* else raise it bt the FLGTHK */
    else
        bot_fl_ratio = FLGTHK;

    /* Place point */
    varY = FrameHeight * bot_fl_ratio;
    v_scale( mcyvec, varY, tmp );
    v_add( p1, tmp, p11 );

    /* p12 - left top point */
    /* If no top flange put boundary on the frame point */
    if( BeamType == FLAT || BeamType == BTEE )
        top_fl_ratio = 0;
    /* else raise it bt the FLGTHK */
    else
        top_fl_ratio = FLGTHK;

    /* Place point */
    varY = FrameHeight * top_fl_ratio;
    v_scale( mcyvec, varY, tmp );
    v_sub( p2, tmp, p12 );

    /* p14 - Top and p13 - Bottom right points */

    TopWebRatio = 1;
    BotWebRatio = 1;
    corner_points( Flip * TopWebRatio * FrameWidth, Flip * BotWebRatio * FrameWidth, p14, p13 );
}

/* ========================================================================= */

int corner_points( top_width, bottom_width, top_pt, bottom_pt )
double top_width, bottom_width, *top_pt, *bottom_pt;
{
    double tmp[3], varX;

    /* top right point */
    varX = top_width;
    v_scale( mcxvec, varX, tmp );
    v_add( p12, tmp, top_pt );

    /* bottom right point */
    varX = bottom_width;
    v_scale( mcxvec, varX, tmp );
    v_add( p11, tmp, bottom_pt );

    return;
}

/* ========================================================================= */
drawstock()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;

    /* top stock point */
    varX = Flip * STOCK * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p22, tmp, p52);

    /* bottom stock point */
    varX = Flip * STOCK * FrameWidth;
    v_scale( mcxvec, varX, tmp);
    v_add( p24, tmp, p53);

    placeLine ( GRid_list, &grCount, p52, p53, 2, 0 );
    placeLine ( GRid_list, &grCount, p52, p22, 2, 0 );
    placeLine ( GRid_list, &grCount, p53, p24, 2, 0 );

}

/* ========================================================================= */


drawTopFlgCut()
{
}
drawBotFlgCut()
{
}
drawTopCorner0()
{
}
drawBotCorner0()
{
}
drawBotCorner1()
{
}
drawBotCorner2()
{
}
