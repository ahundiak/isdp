# RULES

a * - b => - (a * b) when number( a ) && number( b );
a + - b => a - b;
-a + x => x - a when number( a ) && !number( x );
( a + b ) % c = d => a = ( c - b + d ) % c;

#ADDITION

#neutral_operation
a + 0 => a;
0 + a => a;


#SUBSTACTION

a - - b => a + b;

#neutral_operation
a - 0 => a ;

#symetric
x - x => 0;



#FACTOR

x + x => 2*x;
a*x + x   => (a + 1) * x when number( a );
a*x + b*x => ( a + b ) * x when number( a ) && number( b );
a*x - x   => (a - 1) * x when number( a );
a*x - b*x => ( a - b ) * x when number( a ) && number( b );
 


#MULTIPLICATION

a * x = b    => x = (1/a) * b when number( a )&& !number( x );

#neutral

a * 1 => a;
1 * a => a;
a * 0 => 0;
0 * a => 0;



#DISTRIBUTIVITY


t -(u + v) => t -u -v;
c -(-a -b) => c + a + b;
a - (b) => a - b when atom(b);
a - (b * c) => a - b * c when atom(b);
a - (b * c) => a - c * b when !atom(b) && atom(c);

#POWER

pow( a, 1 )=> a;



#SOLVING

x + y = a => x = -y + a  when number(a) && !number(x);
a = y => y = a when number(a) && !number(y);


#TRY

x - a = b => x = a + b  when number(a) && !number(x);
a - x = b => x = a - ( b ) when number(a) &&!number(x);
b + x => x + b when number(b) && !number(x);

a + b = c => a = c - b;
a - b = c => b = a - c;
a - b * - c => a + b * c;
a + - b => a - b;
-a + b => b - a;
x = y => y = x when number(x) && !number(y);

a * - b => - a * b when atom( a );
a * - b => - b * a when atom( b );


- - a => a when atom( a );

#AUTOFACT

deriv( x, y ) => 0 when free( x , y );
deriv( x, y ) => 0 when number( x );
deriv( x, x ) => 1;
deriv( -x, x ) => -1;

deriv( x + y, z ) => deriv( x, z ) + deriv( y, z );
deriv( a - b, c ) => deriv( a, c ) - deriv( b, c );
deriv( x * y, z ) => y * deriv( x, z ) + x * deriv( y, z );
deriv( x / y, z ) => ((y * deriv( x, z )) - (x * deriv( y, z)))/pow( y, 2 );
deriv( pow( x, y ), z ) => deriv( x, z ) * y * (pow( x, y - 1));

deriv( sqrt(x), y ) => deriv( x, y ) * 0.5 / sqrt(x);

deriv( sin( x ), x ) => cos( x );
deriv( sin( x ), y ) => 0 when atom( x );

deriv( cos( x ), x ) => -sin( x );
deriv( cos( x ), y ) => 0 when atom( x );

deriv( (x) , y ) => deriv ( x, y );
deriv( -(x) , y ) => - deriv ( x, y );
deriv( - x , y ) => - deriv ( x, y );
deriv( -x, z ) => - deriv( x, z );


