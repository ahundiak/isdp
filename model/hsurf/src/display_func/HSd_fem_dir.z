
/*
$Author: hans $
$Revision: 1.1.1.1 $
$Date: 2001/12/17 22:40:36 $
$Locker:  $
*/

/*		Apogee compliant		*/

#include "stdlib.h"
#include "igrtypedef.h"
#include "igr.h"

#include "hsmath.h"
#include "HStl_global.h"
#include "HStl_window.h"
#include "HStl_element.h"
#include "hsdisplay.h"
#include "HSd_fixedpt.h"
#include "HSd_macros.h"

#include "HSpr_display.h"


/*---GET_PIXEL_COLOR-----------------------------------------------------------*/

/* this will direct map but with psuedo-"solid" colors (the same color */
/* but made with a dither pattern).  It loses the solid color look, but helps */
/* match the 12 colors given especialy on machines with fewer bit planes*/
/* This will also make sure you have 12 "different" colors in case 2 of the*/
/* adjacent colors are within a closest match and get identical solid color*/
/*	((rsc >> 15) % 32) <= 16 ? 						\*/
/*		HRindex_rgb(x,y,						\*/
/*			    fem_column[rsc >> 20].red,				\*/
/*			    fem_column[rsc >> 20].green,			\*/
/*			    fem_column[rsc >> 20].blue)	   : 			\*/
/*		HRindex_rgb(x,y,						\*/
/*			    fem_column[(rsc >> 20)+1].red,			\*/
/*			    fem_column[(rsc >> 20)+1].green,			\*/
/*			    fem_column[(rsc >> 20)+1].blue)    			\*/

#if RAMP
#define GET_PIXEL_COLOR( x, y, rsc )					\
(										\
	((rsc >> 15) % 32) <= 16 ? 						\
		(tiling_parms.start_slot_fem + (rsc >> 20))   : 			\
		(tiling_parms.start_slot_fem + (rsc >> 20) + 1)				\
)
#else
/*give one of the best matched solid colors (stored in global fem_column array)*/
#define GET_PIXEL_COLOR( x, y, rsc )						\
(										\
	((rsc >> 15) % 32) <= 16 ? 	fem_column[rsc >> 20].slot	 : 	\
					fem_column[(rsc >> 20)+1].slot		\
)
#endif
/*---FILL_UP-------------------------------------------------------------------*/

#define FILL_UP( y )								\
										\
	{									\
	if( rxb < rxa && ((y)-1) != tile->ya )					\
		{								\
	 	if( (dxc = rxa - rxb) == 0 )					\
			{							\
			dsc = 0;						\
										\
			rzc.sign = 1;						\
			rzc.d_whole = 0;					\
			rzc.d_fract = 0;					\
			}							\
		else								\
			{							\
			dsc = ( rsa - rsc ) / dxc;				\
										\
			fixed_divide(	(rza.active - rzb.active),		\
					dxc,					\
					&rzc.sign,				\
					&rzc.d_whole,				\
					&rzc.d_fract );				\
			}							\
										\
		rzc.running = 0x40000000;					\
		rzc.active = rzb.active;					\
										\
		xleft = rxb >> 16;						\
		xright = rxa >> 16;						\
										\
		zb = active_window->zbuf +					\
			(offset = y * active_window->x_dits + xleft);		\
		cb = active_window->cbuf + offset;				\
		}								\
	}
	
#define	MARK									\
	{									\
	if (*zb >= rzc.active)							\
		{								\
		if (((*zb - rzc.active) > 1) || (*cb != fem_background))	\
			{							\
			*cb = fem_meshcolor;					\
			*zb = rzc.active;					\
			}							\
		}								\
	}

#define SHADE									\
	{  									\
	if (*zb >= rzc.active)							\
		{								\
		if (((*zb - rzc.active) > 1) || (*cb != fem_meshcolor)) 	\
			{							\
			*cb = GET_PIXEL_COLOR(x, y, rsc);			\
			*zb = rzc.active;					\
			}							\
		}								\
	}

#define TOP_FEM_SHADE								\
	{									\
	INIT_SHADE_VARIABLES_FEM     						\
	INIT_Z_VARIABLES							\
	INIT_X_VARIABLES							\
										\
	CALC_DZ_DX								\
	CALC_FEM_DX								\
										\
	CALC_BUFFER_ADDRESSES							\
										\
	if (tile->id & TOP_EDGE)						\
		{								\
		for (x = xleft; x <= xright; x++)				\
			{							\
			MARK							\
			MOVE_NEXT_PIXEL						\
			}							\
		}								\
	else									\
		{								\
		x = xleft;							\
										\
		if (tile->id & LEFT_EDGE)					\
			{							\
			MARK							\
			MOVE_NEXT_PIXEL_FEM					\
			x++;							\
			}							\
										\
		for (/*x=x*/; x < xright; x++)					\
			{							\
			SHADE							\
			MOVE_NEXT_PIXEL_FEM					\
			}							\
										\
		if (tile->id & RIGHT_EDGE)					\
			{							\
			MARK							\
			}							\
		else								\
			{							\
			SHADE							\
			}							\
		}								\
	}
	
#define BOTTOM_FEM_SHADE							\
	{									\
	INIT_SHADE_VARIABLES_FEM     						\
	INIT_Z_VARIABLES							\
	INIT_X_VARIABLES							\
										\
	CALC_DZ_DX								\
	CALC_FEM_DX								\
										\
	CALC_BUFFER_ADDRESSES							\
										\
	if (tile->id & BOTTOM_EDGE)						\
		{								\
		if (old_xleft < xleft)						\
			{							\
			x = old_xleft + 1;					\
			MOVE_BACKWARDS(xleft, x)				\
			}							\
		else								\
			x = xleft;						\
										\
		if (old_xright > xright)					\
			end_mesh_line = old_xright;				\
		else								\
			end_mesh_line = xright + 1;				\
										\
		for (/*x=x*/; x < end_mesh_line; x++)					\
			{							\
			MARK							\
			MOVE_NEXT_PIXEL						\
			}							\
		}								\
	else									\
		{								\
		if (tile->id & LEFT_EDGE)					\
			{							\
			if (old_xleft > xleft)					\
				{						\
				for (x=xleft; x < old_xleft; x++)		\
					{					\
					MARK					\
					MOVE_NEXT_PIXEL_FEM			\
					}					\
				}						\
			else if (old_xleft == xleft)				\
				{						\
				x = xleft;					\
				MARK						\
				MOVE_NEXT_PIXEL_FEM				\
				x++;						\
				}						\
			else							\
				{						\
				MOVE_BACKWARDS(xleft, old_xleft + 1)		\
				for(x = old_xleft + 1; x < xleft; x++)		\
					{					\
					MARK					\
					MOVE_NEXT_PIXEL				\
					}					\
				MARK						\
				MOVE_NEXT_PIXEL_FEM				\
				x++;						\
				}						\
			}							\
		else								\
			x = xleft;						\
										\
		if ((tile->id & RIGHT_EDGE) && (old_xright < xright))		\
			start_mesh_line = old_xright + 1;			\
		else								\
			start_mesh_line = xright;				\
										\
		for( /*x=x*/; x < start_mesh_line; x++ )				\
			{							\
			SHADE							\
			MOVE_NEXT_PIXEL_FEM					\
			}							\
										\
		if (tile->id & RIGHT_EDGE)					\
			{							\
			if (old_xright > xright)				\
				end_mesh_line = old_xright - 1;			\
			else							\
				end_mesh_line = xright;				\
										\
			for (/*x=x*/; x < end_mesh_line; x++ )			\
				{						\
				MARK						\
				MOVE_NEXT_PIXEL					\
				}						\
										\
			MARK							\
			}							\
		else								\
			{							\
			SHADE							\
			}							\
		}								\
	}
	

/*---HSfem_direct--------------------------------------------------------------*/

#if RAMP
	void HSfem_direct_ramp( struct hsfem_trapezoid *tile )
#else
	void HSfem_direct( struct hsfem_trapezoid *tile )
#endif

	{
	int			rxa, rxb, dxa, dxb;
	int			rsa, rsb;

	int			dxc;		
	int			rsc, rsd, dsc;	
	int			dx, dy;		
						
	int			offset;		
						
	struct HSfixedpt	rza, rzb, rzc;	
						
	register int		x, y;		
	register int		xleft, xright;	
						
	register HSzbuf		*zb;		
	register HScbuf		*cb;

	int			rua=0, rub=0, dua=0, dub=0, duc;	
	int			rva=0, rvb=0, dva=0, dvb=0, dvc;	
	int			fdx, fd2x, fdy=0, fd2y=0;

	register int	start_mesh_line, end_mesh_line;
	register int	old_xleft, old_xright;

	MIN_MAX_TEST

	/*
	 *  Scale the shade (divide by 255 and shift left 16).  
	 */

	rsa = (int)(((tile->shade2 * 65536.0 / 255.0) + 0.5) * tiling_parms.apparent_shades_fem);
	rsb = (int)(((tile->shade3 * 65536.0 / 255.0) + 0.5) * tiling_parms.apparent_shades_fem);
	rsc = (int)(((tile->shade0 * 65536.0 / 255.0) + 0.5) * tiling_parms.apparent_shades_fem);
	rsd = (int)(((tile->shade1 * 65536.0 / 255.0) + 0.5) * tiling_parms.apparent_shades_fem);
	
	CALC_DXDY_DZDY_FEMDY
	
	y = tile->yb;
	
	TOP_FEM_SHADE

	old_xleft = xleft;
	old_xright = xright;
	MOVE_TO_NEXT_ROW_FEM
	for( y++; y < tile->ya; y++ )
		{
	        INIT_SHADE_VARIABLES_FEM
		INIT_Z_VARIABLES
		INIT_X_VARIABLES

		CALC_DZ_DX
		CALC_FEM_DX

		CALC_BUFFER_ADDRESSES

		if (tile->id & LEFT_EDGE)
			{
			if (old_xleft > xleft)
				{
				for (x = xleft; x < old_xleft; x++)
					{
					MARK
					MOVE_NEXT_PIXEL_FEM
					}
				}
			else if (old_xleft == xleft)
				{
				x = xleft;
				MARK
				MOVE_NEXT_PIXEL_FEM
				x++;
				}
			else
				{
				MOVE_BACKWARDS(xleft, old_xleft + 1)
				for(x = old_xleft + 1; x < xleft; x++)
					{
					MARK
					MOVE_NEXT_PIXEL
					}
				MARK
				MOVE_NEXT_PIXEL_FEM
				x++;
				}
			}
		else
			{
			x = xleft;
			}


		if ((tile->id & RIGHT_EDGE) && (old_xright < xright))
			start_mesh_line = old_xright + 1;
		else
			start_mesh_line = xright;

		for( /*x=x*/; x < start_mesh_line; x++ )
			{
			SHADE
			MOVE_NEXT_PIXEL_FEM
			}

		if (tile->id & RIGHT_EDGE)
			{
			if (old_xright > xright)
				end_mesh_line = old_xright - 1;
			else
				end_mesh_line = xright;

			for (/*x=x*/; x < end_mesh_line; x++ )
				{
				MARK
				MOVE_NEXT_PIXEL
				}

			MARK
			}
		else 
			{
			SHADE
			}

		old_xleft = xleft;
		old_xright = xright;
		MOVE_TO_NEXT_ROW_FEM		
		}

	if( y <= tile->ya )	
		BOTTOM_FEM_SHADE
	}
