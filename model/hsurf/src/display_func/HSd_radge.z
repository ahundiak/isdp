
/*
$Author: hans $
$Revision: 1.1.1.1 $
$Date: 2001/12/17 22:40:36 $
$Locker:  $
*/

/*		Apogee compliant		*/


#include "stdio.h"
#if defined (ENV5)
#include "gpipe.h"
#endif
#include "OMminimum.h"
#include "igrtypedef.h"
#include "igr.h"
#include "wl.h"
#include "HStl_window.h"
#include "HStl_element.h"
#include "hsdisplay.h"
#include "HSd_fixedpt.h"
#include "hsmath.h"
#include "hsmacdef.h"
#include "HSd_macros.h"
#include "HStl_global.h"

#include "HSpr_display.h"

#define	BYTES_PER_PIXEL	5

/*
 *   Debugging stuff
 *
 *   What the different DEBUG's mean
 *
 *       DEBUG_T ------ Display readable formatted trapezoid
 *       DEBUG_P ------ Display readable formatted polyline
 *       DEBUG_TLOG --- Display trapezoid formatted for my display trap/line program.
 *       DEBUG_PLOG --- Display polyline formatted for my display trap/line program.
 *       DEBUG_TRAP --- Selectively process trapezoids (DTRAP)
 *       DEBUG_LINE --- Selectively process polylines (DLINE)
 *	 DEBUG_CTRAP -- Color the trap
 */

#define DEBUG_T		0
#define DEBUG_P		0
#define	DEBUG_TLOG	0
#define	DEBUG_PLOG	0
#define DEBUG_TRAP	0
#define DEBUG_LINE	0
#define	DEBUG_CTRAP	0
#define DEBUG_REGION	0

static HScbuf VCOLOR_ON;
static HScbuf VCOLOR_OFF;
static HScbuf HCOLOR_ON;
static HScbuf HCOLOR_OFF;

#define	yVCOLOR		0
#define	yHCOLOR_ON	0
#define	yHCOLOR_OFF	element_parms.color

#define	zVCOLOR		1
#define	zHCOLOR_ON	3
#define	zHCOLOR_OFF	3
#define	TEDGE		5
#define	TINT		7

extern IGRint   IGEgetabsclrindx(
   WLuint32   context_no,
   IGRshort   log_color,
   IGRshort   *abs_color);

extern int dtrap;

#define MAXC1   10

#define DTRAP	(c1 == 4)
#define DLINE	(c2 < 0)

#define IN_REGION(x,y)	( c2 == 8 || c2 == 12 )

static int c1 = 0;
static int c2 = 0;
static int c3 = 0;

/*
 *  Useful macros
 */

#define	HABS(x)	((x) < 0 ? -(x) : (x))

/*
 *  Handy constants
 */


#define	EDGE_EDGE	0x20000000
#define	BAD_Z		0x40000000
#define EDGE_MASK	0x60000000
#define TRAP_EDGE	0x80000000
#define	MARK_MASK	0xe0000000
#define ZMASK		0x1fffffff

#define	ABOUT_TO_JUMP	0x01
#define	JUST_JUMPED	0x02
#define	RESET		0x04
#define EDGE_END	0x08

#define	LEFT_SIDE	0x00
#define	RIGHT_SIDE	0x01
#define	LINE_SIDE	0x02

/*
 *  Weight stuff
 */

#define	ACTIVE_WEIGHT	((double)(5.08))
#define ACTIVE_WIDTH	(2)

static int VWIDTH = 1;
static int HWIDTH = 1;

static int wns;

static struct weight_pattern
   {
   char x, y;
   }              wp[512];

static int wxoff;
static int wyoff;
static int xdits, xdits2;

static void (*add_visible_weight) () = NULL;
static void (*add_hidden_weight) () = NULL;

/*
 *  something alot might use
 */

static int offset;

/*
 *  step stuff
 */

#define	xstep	1
#define ystep	(xdits)

#define	xstep2	1
#define ystep2	(xdits)

#define	ONE16	(65536)

/*
 *  edge processing structure
 */

struct edge_info
   {
   int    x1, y1, z1;
   int    xn, yn, zn;
   int    x2, y2, z2;
   int    dy, dxy, xjump, xdir, ydir, stop_mask, side;
   int    cb_xdir, cb_ydir;
   int    zb_xdir, zb_ydir;
   HScbuf *cb;
   HSzbuf *zb;

   struct HSfixedpt fz1, fz2;
   };

/*
 *  edge segment starting point
 */

static struct polyline_vertex current_vertex;

/*
 *  style stuff
 */

static int    vstyle_index = 0;
static double vstyle_length = 0.0;
static int    hstyle_index = 0;
static double hstyle_length = 0.0;
static int    xold, yold;

#define	PSIZE_D		3.59
#define	PSIZE_HV	2.54

static double pixel_size_diag = PSIZE_D;
static double pixel_size_hovt = PSIZE_HV;

static HSzbuf background;

/*
 *  Prototype declaration for static functions
 */

#if defined(__cplusplus)
extern "C"
   {
#endif


/* NOTE: How to prototype a function pointer
static void __((*add_visible_weight));*/

static void HPadd_visible_weight_east_west (struct edge_info *, int);
static void HPadd_visible_weight_north_south (struct edge_info *, int);
static void HPadd_hidden_weight_east_west (struct edge_info *, int);
static void HPadd_hidden_weight_north_south (struct edge_info *, int);

static void HPadd_weight (struct edge_info *, int);
static int  HPset_weight_steps (struct edge_info *, double);

static void HSedge_vis (struct edge_info *);
static void HPtrap_vis (struct edge_info *);

static void HPfill_trap (struct edge_info *, struct edge_info *);

static int  HPone_step (struct edge_info *);
static void HSset_display_colors (void);


#if defined(__cplusplus)
   }

#endif


/*
 *  TA DA...the code
 */

#if FILLED
#else

/*---HPadd_visible_weight_east_west-------------------------------------------------------*/

/*
 *  Add weight to the edge horizonally.  Since the edge is visible, we dont have to
 *  worry about replacing existing edge pixels
 */

static void HPadd_visible_weight_east_west (struct edge_info * edge, int color)

   {
   int    i;
   HScbuf *cb1, *cb2;
   HSzbuf *zb1, *zb2, z;
   HSzbuf mark;


   cb1 = cb2 = edge->cb;
   zb1 = zb2 = edge->zb;

   z = *edge->zb & ZMASK;
   mark = *edge->zb & MARK_MASK;


   /* Add ACTIVE_WIDTH pixels of weight */

   i = VWIDTH;
   while (--i)
      {
      cb1 += (xstep2);
      zb1 += (xstep);

      if (!(zb1 < active_window->zbuf || zb1 > (HSzbuf *) active_window->cbuf))
         {
         *cb1 = (color);

#        if DELETE
            *zb1 = background | mark;
#        else
            *zb1 = z | mark;
#        endif
         }

      /* Just in case the width is odd */

      if (!(--i))
         break;

      cb2 -= (xstep2);
      zb2 -= (xstep);

      if (!(zb2 < active_window->zbuf || zb2 > (HSzbuf *) active_window->cbuf))
         {
         *cb2 = (color);

#        if DELETE
            *zb2 = background | mark;
#        else
            *zb2 = z | mark;
#        endif
         }
      }
   }

/*---HPadd_visible_weight_north_south-------------------------------------------------------*/

static void HPadd_visible_weight_north_south (struct edge_info * edge, int color)

   {
   int    i;
   HScbuf *cb1, *cb2;
   HSzbuf *zb1, *zb2, z;
   HSzbuf mark;

   cb1 = cb2 = edge->cb;
   zb1 = zb2 = edge->zb;

   z = *edge->zb & ZMASK;
   mark = *edge->zb & MARK_MASK;

   /* Add ACTIVE_WIDTH pixels of weight */

   i = VWIDTH;
   while (--i)
      {
      cb1 += (ystep2);
      zb1 += (ystep);

      if (!(zb1 < active_window->zbuf || zb1 > (HSzbuf *) active_window->cbuf))
         {
         *cb1 = (color);

#        if DELETE
            *zb1 = background | mark;
#        else
            *zb1 = z | mark;
#        endif
         }

      /* Just in case the width is odd */

      if (!(--i))
         break;

      cb2 -= (ystep2);
      zb2 -= (ystep);

      if (!(zb2 < active_window->zbuf || zb2 > (HSzbuf *) active_window->cbuf))
         {
         *cb2 = (color);

#        if DELETE
            *zb2 = background | mark;
#        else
            *zb2 = z | mark;
#        endif
         }
      }
   }


/*---HPadd_hidden_weight_east_west-------------------------------------------------------*/

/*
 *  Add weight to the edge horizonally.  Since the centerline of the edge is hidden, then
 *  we can only replace those pixels owned by a trapezoid
 */

static void HPadd_hidden_weight_east_west (struct edge_info * edge, int color)

   {
   int    i;
   HScbuf *cb1, *cb2;
   HSzbuf *zb1, *zb2, z;

   HSzbuf mark;

   cb1 = cb2 = edge->cb;
   zb1 = zb2 = edge->zb;

   z = *edge->zb & ZMASK;
   mark = *edge->zb & MARK_MASK;

   /* add ACTIVE_WIDTH pixels of weight */

   i = HWIDTH;
   while (--i)
      {
      cb1 += (xstep2);
      zb1 += (xstep);

      /* Change the pixel only if the owner is a trapezoid */

      if ((*zb1 & MARK_MASK) == 0)
         {
         if (!(zb1 < active_window->zbuf ||
               zb1 > (HSzbuf *) active_window->cbuf))
            {
            *cb1 = (color);

#           if DELETE
               *zb1 = background | mark;
#           else
               *zb1 = z | mark;
#           endif
            }
         }

      /* just in case the width is odd */

      if (!(--i))
         break;

      cb2 -= (xstep2);
      zb2 -= (xstep);

      /* change the pixel only if the owner is a trapezoid */

      if ((*zb2 & MARK_MASK) == 0)
         {
         if (!(zb2 < active_window->zbuf ||
               zb2 > (HSzbuf *) active_window->cbuf))
            {
            *cb2 = (color);

#           if DELETE
               *zb2 = background | mark;
#           else
               *zb2 = z | mark;
#           endif
            }
         }
      }
   }

/*---HPadd_hidden_weight_north_south-------------------------------------------------------*/

/*
 *  Add weight to the edge vertically.  Since the centerline of the edge is hidden, then
 *  we can only replace those pixels owned by a trapezoid
 */

static void HPadd_hidden_weight_north_south (struct edge_info * edge, int color)

   {
   int    i;
   HScbuf *cb1, *cb2;
   HSzbuf *zb1, *zb2, z;
   HSzbuf mark;

   cb1 = cb2 = edge->cb;
   zb1 = zb2 = edge->zb;

   z = *edge->zb & ZMASK;
   mark = *edge->zb & MARK_MASK;

   /* add ACTIVE_WIDTH pixels of weight */

   i = HWIDTH;
   while (--i)
      {
      cb1 += (ystep2);
      zb1 += (ystep);

      /* Change the pixel only if the owner is a trapezoid */

      if ((*zb1 & MARK_MASK) == 0)
         {
         if( !(zb1 < active_window->zbuf ||
               zb1 > (HSzbuf *) active_window->cbuf) )
            {
            *cb1 = (color);

#           if DELETE
               *zb1 = background | mark;
#           else
               *zb1 = z | mark;
#           endif
            }
         }

      /* just in case the width is odd */

      if (!(--i))
         break;

      cb2 -= (ystep2);
      zb2 -= (ystep);

      /* Change the pixel only if the owner is a trapezoid */

      if ((*zb2 & MARK_MASK) == 0)
         {
         if (!(zb2 < active_window->zbuf ||
               zb2 > (HSzbuf *) active_window->cbuf))
            {
            *cb2 = (color);

#           if DELETE
               *zb2 = background | mark;
#           else
               *zb2 = z | mark;
#           endif
            }
         }
      }
   }

/*---HPadd_weight--------------------------------------------------------------*/

static void HPadd_weight (struct edge_info * edge, int color)

   {
   }

/*---HPset_weight_steps---------------------------------------------------*/

static int HPset_weight_steps (struct edge_info * edge, double weight)

   {
   int step;
   int dxy;
   static int active_width = 0;

   dxy = edge->dxy < 0 ? -edge->dxy : edge->dxy;
   if (dxy == 0)
      {
      if (edge->x1 == edge->xn)
         {
         wns = 0;
         add_visible_weight = HPadd_visible_weight_east_west;
         add_hidden_weight = HPadd_hidden_weight_east_west;
         }
      else
         {
         wns = 1;
         add_visible_weight = HPadd_visible_weight_north_south;
         add_hidden_weight = HPadd_hidden_weight_north_south;
         }
      }
   else
      {
      if (dxy < 65535)
         {
         wns = 0;
         step = (int) ((65535.0 / ((double) dxy)) + 0.5);
         add_visible_weight = step <= active_width ? HPadd_weight : HPadd_visible_weight_east_west;
         add_hidden_weight = step <= active_width ? HPadd_weight : HPadd_hidden_weight_east_west;
         }
      else
         {
         wns = 1;
         step = (int) ((((double) dxy) / 65535.0) + 0.5);
         add_visible_weight = step <= active_width ? HPadd_weight : HPadd_visible_weight_north_south;
         add_hidden_weight = step <= active_width ? HPadd_weight : HPadd_hidden_weight_north_south;
         }
      }

   if (HWIDTH <= 1) add_hidden_weight = HPadd_weight;
   if (VWIDTH <= 1) add_visible_weight = HPadd_weight;
   return (0);
   }

/*---NEIGHBOR_VIS-----------------------------------------------------*/

#define	NEIGHBOR_VIS( z, zb, cb )							  \
											  \
(											  \
( (*(zb+xstep) & ZMASK) >= z       && (*(zb+xstep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb-xstep) & ZMASK) >= z       && (*(zb-xstep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb+ystep) & ZMASK) >= z       && (*(zb+ystep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb-ystep) & ZMASK) >= z       && (*(zb-ystep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb+ystep+xstep) & ZMASK) >= z && (*(zb+ystep2+xstep2) & MARK_MASK) != EDGE_MASK ) || \
( (*(zb+ystep-xstep) & ZMASK) >= z && (*(zb+ystep2-xstep2) & MARK_MASK) != EDGE_MASK ) || \
( (*(zb-ystep+xstep) & ZMASK) >= z && (*(zb-ystep2+xstep2) & MARK_MASK) != EDGE_MASK ) || \
( (*(zb-ystep-xstep) & ZMASK) >= z && (*(zb-ystep2-xstep2) & MARK_MASK) != EDGE_MASK )    \
)

/*---DUMP_NEIGHBOR--------------------------------------------------------*/

#define	DUMP_NEIGHBOR( zb, cb )								\
											\
{											\
fprintf( stderr, "\n" );								\
fprintf( stderr, "east ------ %x %x\n", *(zb+xstep) & ZMASK, *(zb+xstep2) & MARK_MASK );	\
fprintf( stderr, "west ------ %x %x\n", *(zb-xstep) & ZMASK, *(zb-xstep2) & MARK_MASK );	\
fprintf( stderr, "north ----- %x %x\n", *(zb+ystep) & ZMASK, *(zb+ystep2) & MARK_MASK );	\
fprintf( stderr, "south ----- %x %x\n", *(zb-ystep) & ZMASK, *(zb-ystep2) & MARK_MASK );	\
fprintf( stderr, "northeast - %x %x\n", *(zb+ystep+xstep) & ZMASK, *(zb+ystep2+xstep2) & MARK_MASK );	\
fprintf( stderr, "northwest - %x %x\n", *(zb+ystep-xstep) & ZMASK, *(zb+ystep2-xstep2) & MARK_MASK );	\
fprintf( stderr, "southeast - %x %x\n", *(zb-ystep+xstep) & ZMASK, *(zb-ystep2+xstep2) & MARK_MASK );	\
fprintf( stderr, "southwest - %x %x\n", *(zb-ystep-xstep) & ZMASK, *(zb-ystep2-xstep2) & MARK_MASK );	\
}

/*---HSset_style---------------------------------------------------------*/

#define	HSset_style( x, y )                                       \
                                                                  \
   {                                                              \
   if( xold != ROUND16(x) && yold != (y) )                        \
      {                                                           \
      vstyle_length += pixel_size_diag;                           \
      hstyle_length += pixel_size_diag;                           \
      }                                                           \
   else                                                           \
      {                                                           \
      vstyle_length += pixel_size_hovt;                           \
      hstyle_length += pixel_size_hovt;                           \
      }                                                           \
                                                                  \
   if( vstyle_length >= element_parms.v_pattern[vstyle_index] )   \
      {                                                           \
      vstyle_length -= element_parms.v_pattern[vstyle_index++];   \
      if( element_parms.v_pattern[vstyle_index] == 0.0 )          \
         vstyle_index = 0;                                        \
      }                                                           \
                                                                  \
   if( hstyle_length >= element_parms.h_pattern[hstyle_index] )   \
      {                                                           \
      hstyle_length -= element_parms.h_pattern[hstyle_index++];   \
      if( element_parms.h_pattern[hstyle_index] == 0.0 )          \
         hstyle_index = 0;                                        \
      }                                                           \
                                                                  \
   xold = ROUND16(x);                                             \
   yold = (y);                                                    \
   }

/*---HSedge_vis----------------------------------------------------------*/

static void HSedge_vis (struct edge_info * edge)

   {
   HSzbuf badz;

#  if DEBUG_REGION
   if (IN_REGION (ROUND16 (edge->x1), edge->y1))
      fprintf (stderr, "HSedge_vis(%1d:%1d): x1, y1, z1, cb -- %3d %3d %x %x %x %x --",
               c2, c3, ROUND16 (edge->x1), edge->y1, edge->z1,
               *edge->zb & ZMASK, edge->zb, *edge->zb & MARK_MASK);
#  endif

   if ((*edge->zb & ZMASK) >= edge->z1)
      {

      /* Outright winner.  mark the edge in visible color, mark the edge
       * EDGE_EDGE (owned by an edge).  OR because the bad_z  bit might be
       * set. Once you set that you can never clear it.  Reasoning:  Say we
       * are looking  at object A now, and object B is  in the buffer,  and
       * is the  cause of  the bad_z bit getting set.   When object B was
       * processed object C was really closer to the viewer but object B
       * replaced object C because of the nearest neighbor test, causing the
       * bad_z bit to get set.   Now, we have no way of knowing if object A
       * hides object C or not so the bad_z bit must remain set. */

#     if DEBUG_REGION
      if (IN_REGION (ROUND16 (edge->x1), edge->y1))
         fprintf (stderr, "outright winner\n");
#     endif

      badz = *edge->zb & BAD_Z;
      *edge->zb = edge->z1 | EDGE_EDGE | badz;
      if ((vstyle_index & 1) != element_parms.v_pat_on_off)
         {
         *edge->cb = VCOLOR_ON;

         (*add_visible_weight) (edge, VCOLOR_ON);
         }
      }
   else
      {

      /* Was not the outright winner.  If the pixel is not owned by an EDGE,
       * then perform the nearest neighbor test. */

      if (!(*edge->zb & EDGE_MASK))
         {
#        if DEBUG_REGION
         if (IN_REGION (ROUND16 (edge->x1), edge->y1))
            DUMP_NEIGHBOR (edge->zb, edge->cb)
#        endif

               if (NEIGHBOR_VIS (edge->z1, edge->zb, edge->cb))
               {

               /* Winner because of nearest neighbor test.  Replace the z
                * (ever if it is closer), set the EDGE owner and bad_z bits,
                * save active color, add weight */

#              if DEBUG_REGION
               if (IN_REGION (ROUND16 (edge->x1), edge->y1))
                  fprintf (stderr, "winner by nearest neighbor\n");
#              endif


               *edge->zb = edge->z1 | EDGE_EDGE | BAD_Z;
               if ((vstyle_index & 1) != element_parms.v_pat_on_off)
                  {
                  *edge->cb = VCOLOR_ON;

                  (*add_visible_weight) (edge, VCOLOR_ON);
                  }
               }
            else
               {

               /* Loser.  display the edge with style.  If the style index is
                * odd then display the "off color" which normally will be the
                * background color.  If the style index is even then display
                * the "on color", which normally will be the active color. In
                * either case, dont change the mark or z.  Add weight */

#              if DEBUG_REGION
               if (IN_REGION (ROUND16 (edge->x1), edge->y1))
                  fprintf (stderr, "lost nearest neighbor\n");
#              endif

               if (tiling_parms.processing_mode & HS_PMODE_DISPLAY_HIDDEN_LINES)
                  if ((hstyle_index & 1) != element_parms.h_pat_on_off)
                     {
                     *edge->cb = HCOLOR_ON;

                     (*add_hidden_weight) (edge, HCOLOR_ON);
                     }
               }
         }
      else
         {

         /* this is a special case.  We could not set the centerline pixel
          * because it was owned by an edge, but this does not mean that the
          * weight pixels are also owned by and edge, so we have to add
          * weight so as to not get any gaps. */

#        if DEBUG_REGION
         if (IN_REGION (ROUND16 (edge->x1), edge->y1))
            fprintf (stderr, "lost\n");
#        endif


         if (tiling_parms.processing_mode & HS_PMODE_DISPLAY_HIDDEN_LINES)
            if ((hstyle_index & 1) != element_parms.h_pat_on_off)
               (*add_hidden_weight) (edge, HCOLOR_ON);
         }
      }
   }
#endif /* if FILLED */

/*---HPtrap_vis--------------------------------------------------------*/

/*
 *  visibility test for a pixel owned by a trapezoid and being replaced
 *  by a trapezoid
 */

static void HPtrap_vis (struct edge_info * edge)

   {
#  if DEBUG_REGION
   if (IN_REGION (ROUND16 (edge->x1), edge->y1))
      fprintf (stderr, "HStrap_vis(%1d): x1, y1, z1 -- %3d %3d %x %x %x\n",
               c1, ROUND16 (edge->x1), edge->y1, edge->z1, *edge->zb & ZMASK, edge->zb);
#  endif

   if ((*edge->zb & ZMASK) >= edge->z1)
      {
      *edge->zb = edge->z1 | TRAP_EDGE;

#     if FILLED
      *edge->cb = HCOLOR_OFF;
#     endif
      }
   }

/*---HPfill_trap-------------------------------------------------------*/

/*
 *  When processing a trap, for a given scanline, we have the z's at
 *  the sides of the trap, so we have to interpolate between the two to
 *  get z's for the interior of the trap
 */

static void HPfill_trap (struct edge_info * left_edge,
                              struct edge_info * right_edge)

   {
   int              dx;
   struct HSfixedpt z;
   int              xleft, xright;
   HSzbuf           *zb;

#  if FILLED
   HScbuf *cb;
#  endif

   /* Get the x values at the sides of the trap */

   xleft = ROUND16 (left_edge->x1);
   xright = ROUND16 (right_edge->x1);

   /* get a dz/dx */

   if ((dx = xright - xleft) == 0)
      {
      z.sign = 1;
      z.d_whole = 0;
      z.d_fract = 0;
      z.running = 0;
      }
   else
      {
      fixed_divide ((right_edge->z1 - left_edge->z1),
                    dx,
                    &z.sign,
                    &z.d_whole,
                    &z.d_fract);

      z.running = 0x40000000;
      }

   z.active = left_edge->z1;

   /* Skip past the first pixel, processing the edges set that one */

   zb = left_edge->zb;
   zb++;

#  if FILLED
   cb = left_edge->cb;
   cb++;
#  endif

   xleft++;
   Fixed_add (z);

   /* Fill the trap scanline */

   while (xleft < xright)
      {
#     if DEBUG_REGION
      if (IN_REGION (ROUND16 (edge->x1), edge->y1))
         fprintf (stderr, "HSfill_trap(%1d): x1, y1, z1 -- %3d %3d %x %x %x\n",
                  c1, xleft, left_edge->y1, z.active, *zb & ZMASK, zb);
#     endif

      if ((*zb & ZMASK) >= z.active)
         {
         if (!(zb < active_window->zbuf ||
               zb > (HSzbuf *) active_window->cbuf))
            {
#           if DELETE
               *zb = background;
#           else
               *zb = z.active;
#           endif

#           if FILLED
               *cb = HCOLOR_OFF;
#           endif
            }
         }

      zb++;
      xleft++;
      Fixed_add (z);

#     if FILLED
      cb++;
#     endif
      }
   }

/*---HPone_step----------------------------------------------------------*/

/*
 *  Processing an edge, bressenham the edge until you have made one
 *  step in the y direction
 */

static int HPone_step (struct edge_info * edge)

   {
   int dx, dy;
   int adx;
   int status;

   status = 0;

   /* compute the next values for x and y (at least one will change) */

   if (ROUND16 (edge->x1) == ROUND16 (edge->xn) && edge->y1 == edge->yn)
      return (status = EDGE_END);

   dx = edge->xn - edge->x1;

   if ((edge->xdir > 0 && dx < edge->xdir) ||
       (edge->xdir < 0 && dx > edge->xdir))
      edge->xdir = dx;

   edge->x1 += edge->xdir;
   edge->zb += edge->zb_xdir;
   edge->cb += edge->cb_xdir;

   if (edge->xjump == 1)
      {
      status |= ABOUT_TO_JUMP;
      }
   else
      {
      if (edge->xjump == 0)
         {
         status |= JUST_JUMPED;

         edge->dy--;
         edge->y1 += edge->ydir;
         edge->zb += edge->zb_ydir;
         edge->cb += edge->cb_ydir;
         }
      }

   edge->xjump--;

   Fixed_add (edge->fz1);
   edge->z1 = edge->fz1.active;


   if((ROUND16 (edge->x1) == ROUND16 (edge->x2)) && ((edge->y1) == (edge->y2)))
      {
      status |= RESET;

      edge->x1 = edge->x2;
      edge->y1 = edge->y2;
      edge->z1 = edge->z2;

      edge->x2 = edge->x1 + edge->dxy;
      edge->y2 = edge->y1 + edge->ydir;

      Fixed_add (edge->fz2);
      edge->z2 = edge->fz2.active;

      dx = ROUND16 (edge->x2) - ROUND16 (edge->x1);
      dy = (edge->y2) - (edge->y1);

      if (dy == 0)
         {
         edge->ydir = 0;
         edge->zb_ydir = 0;
         edge->cb_ydir = 0;
         }
      else
         {
         if (dy < 0)
            {
            edge->ydir = -1;
            edge->zb_ydir = -ystep;
            edge->cb_ydir = -ystep2;
            }
         else
            {
            edge->ydir = 1;
            edge->zb_ydir = ystep;
            edge->cb_ydir = ystep2;
            }
         }

      if (dx == 0)
         {
         adx = dx;

         edge->xdir = 0;
         edge->zb_xdir = 0;
         edge->cb_xdir = 0;

         edge->fz1.sign = 1;
         edge->fz1.d_whole = 0;
         edge->fz1.d_fract = 0;
         edge->fz1.running = 0;
         }
      else
         {
         if (dx < 0)
            {
            adx = -dx;
            edge->xdir = -ONE16;
            edge->zb_xdir = -xstep;
            edge->cb_xdir = -xstep2;
            }
         else
            {
            adx = dx;
            edge->xdir = ONE16;
            edge->zb_xdir = xstep;
            edge->cb_xdir = xstep2;
            }

         fixed_divide ((edge->z2 - edge->z1),
                       adx,
                       &edge->fz1.sign,
                       &edge->fz1.d_whole,
                       &edge->fz1.d_fract);

         edge->fz1.running = 0x40000000;
         }

      edge->fz1.active = edge->z1;
      edge->xjump = adx >> 1;

      if (edge->xjump == 0)
         {
         status |= ABOUT_TO_JUMP;
         }

      if (edge->side == LEFT_SIDE)
         edge->stop_mask = dx <= 1 ? JUST_JUMPED : ABOUT_TO_JUMP;
      else
         edge->stop_mask = dx >= -1 ? JUST_JUMPED : ABOUT_TO_JUMP;
      }

   return (status);
   }

/*---HPone_step_trap----------------------------------------------------------*/

/*
 *  Processing an edge, bressenham the edge until you have made one
 *  step in the y direction
 */

static int HPone_step_trap (struct edge_info * edge)

   {
   int dx, dy;
   int adx;
   int status;

   status = 0;

   /* compute the next values for x and y (at least one will change) */

   if (ROUND16 (edge->x1) == ROUND16 (edge->xn) && edge->y1 == edge->yn)
      return (status = EDGE_END);

   dx = edge->xn - edge->x1;

   if ((edge->xdir > 0 && dx < edge->xdir) ||
       (edge->xdir < 0 && dx > edge->xdir))
      edge->xdir = dx;

   edge->x1 += edge->xdir;
   edge->zb += edge->zb_xdir;

   if (edge->xjump == 1)
      {
      status |= ABOUT_TO_JUMP;
      }
   else
      {
      if (edge->xjump == 0)
         {
         status |= JUST_JUMPED;

         edge->dy--;
         edge->y1 += edge->ydir;
         edge->zb += edge->zb_ydir;
         }
      }

   edge->xjump--;

   Fixed_add (edge->fz1);
   edge->z1 = edge->fz1.active;


   if ((ROUND16 (edge->x1) == ROUND16 (edge->x2)) && ((edge->y1) == (edge->y2)))
      {
      status |= RESET;

      edge->x1 = edge->x2;
      edge->y1 = edge->y2;
      edge->z1 = edge->z2;

      edge->x2 = edge->x1 + edge->dxy;
      edge->y2 = edge->y1 + edge->ydir;

      Fixed_add (edge->fz2);
      edge->z2 = edge->fz2.active;

      dx = ROUND16 (edge->x2) - ROUND16 (edge->x1);
      dy = (edge->y2) - (edge->y1);

      if (dy == 0)
         {
         edge->ydir = 0;
         edge->zb_ydir = 0;
         }
      else
         {
         if (dy < 0)
            {
            edge->ydir = -1;
            edge->zb_ydir = -ystep;
            }
         else
            {
            edge->ydir = 1;
            edge->zb_ydir = ystep;
            }
         }

      if (dx == 0)
         {
         adx = dx;

         edge->xdir = 0;
         edge->zb_xdir = 0;

         edge->fz1.sign = 1;
         edge->fz1.d_whole = 0;
         edge->fz1.d_fract = 0;
         edge->fz1.running = 0;
         }
      else
         {
         if (dx < 0)
            {
            adx = -dx;
            edge->xdir = -ONE16;
            edge->zb_xdir = -xstep;
            }
         else
            {
            adx = dx;
            edge->xdir = ONE16;
            edge->zb_xdir = xstep;
            }

         fixed_divide ((edge->z2 - edge->z1),
                       adx,
                       &edge->fz1.sign,
                       &edge->fz1.d_whole,
                       &edge->fz1.d_fract);

         edge->fz1.running = 0x40000000;
         }

      edge->fz1.active = edge->z1;
      edge->xjump = adx >> 1;

      if (edge->xjump == 0)
         {
         status |= ABOUT_TO_JUMP;
         }

      if (edge->side == LEFT_SIDE)
         edge->stop_mask = dx <= 1 ? JUST_JUMPED : ABOUT_TO_JUMP;
      else
         edge->stop_mask = dx >= -1 ? JUST_JUMPED : ABOUT_TO_JUMP;
      }

   return (status);
   }

/*---HSset_display_colors-------------------------------------------------*/

static void HSset_display_colors (void)

   {
   WLuint16 bg_color;

#  if defined (XGL)

      /*  In XGL we have to use the forms 8bit context to convert our  */
      /*  logical color index to a physical index because the active  */
      /*  context is 24 bit and will return a bad value for the  */
      /*  physical index  */

      WLuint32 context_no;

      CMget_exnuc_forms_context( active_window->vs_no, &context_no );

      IGEgetabsclrindx (context_no, 
                        (short) HS_BACKGROUND_COLOR, 
                        (short *) (&bg_color));
#  else
      IGEgetabsclrindx (active_window->context_no, 
                        (short) HS_BACKGROUND_COLOR, 
                        (short *) (&bg_color));
#  endif

#  if DELETE
   VCOLOR_ON = bg_color;
   VCOLOR_OFF = bg_color;
   HCOLOR_ON = bg_color;
   HCOLOR_OFF = bg_color;
#  else
   if (active_window->shading_style == HS_STYLE_RASTER)
      {
      VCOLOR_ON = element_parms.color;
      VCOLOR_OFF = bg_color;
      HCOLOR_ON = element_parms.hidden_color;
      HCOLOR_OFF = bg_color;
      }
   else
      {
      if (tiling_parms.processing_mode & HS_PMODE_EDGE_OBJECT)
         {
         VCOLOR_ON = bg_color;
         VCOLOR_OFF = element_parms.color;
         }
      else
         {
         VCOLOR_ON = element_parms.color;
         VCOLOR_OFF = bg_color;
         }

      HCOLOR_ON = bg_color;
      HCOLOR_OFF = element_parms.color;
      }
#  endif
   }

#if FILLED
#else

/*---HSstart_pline_radge--------------------------------------------------*/

#if DELETE
void HSstart_pline_radge_delete (struct polyline_vertex * start_point)
#else
void HSstart_pline_radge        (struct polyline_vertex * start_point)
#endif

   {
   xdits = active_window->x_dits;
   xdits2 = xdits << 1;

   HSset_display_colors ();

   VWIDTH = (int) element_parms.visible_weight;
   HWIDTH = (int) element_parms.hidden_weight;

   if (HWIDTH < 1)  HWIDTH = 1;

   vstyle_index = 0;
   vstyle_length = 0.0;
   hstyle_index = 0;
   hstyle_length = 0.0;

   current_vertex = *start_point;

   if (current_vertex.x < active_window->x_min) active_window->x_min = current_vertex.x;
   if (current_vertex.x > active_window->x_max) active_window->x_max = current_vertex.x;

   if (current_vertex.y < active_window->y_min) active_window->y_min = current_vertex.y;
   if (current_vertex.y > active_window->y_max) active_window->y_max = current_vertex.y;

#  if DELETE
   background = (HSzbuf) tiling_parms.maximum_z;
#  endif
   }

/*---HScontinue_pline_radge--------------------------------------------------------------*/

#if DELETE
void HScontinue_pline_radge_delete (struct polyline_vertex * next_vertex)
#else
void HScontinue_pline_radge (struct polyline_vertex * next_vertex)
#endif

   {
   struct edge_info e;
   int dy, dx, stat;
   int adx, ady;


   c3++;
#  if DEBUG_LINE
   if (!(DLINE)) goto fini;
#  endif

#  if DEBUG_PLOG
   fprintf (stderr, "2 %1d %1d\n", c2, c3);
   fprintf (stderr, "  %3d %3d %d\n",
            ROUND16 (current_vertex.x), current_vertex.y, current_vertex.z);
   fprintf (stderr, "  %3d %3d %d\n",
            ROUND16 (next_vertex->x), next_vertex->y, next_vertex->z);
#  endif

#  if DEBUG_P
   fprintf (stderr, "HSstart_pline_radge #%1d %1d\n", c2, c3);
   fprintf (stderr, "   start_point --- %10.6lf %10.6lf %x\n",
            (double) (current_vertex.x / 65535.0), (double) (current_vertex.y), current_vertex.z);
   fprintf (stderr, "   next_vertex --- %10.6lf %10.6lf %x\n",
            (double) (next_vertex->x / 65535.0), (double) (next_vertex->y), next_vertex->z);
#  endif


   if (next_vertex->x < active_window->x_min) active_window->x_min = next_vertex->x;
   if (next_vertex->x > active_window->x_max) active_window->x_max = next_vertex->x;

   if (next_vertex->y < active_window->y_min) active_window->y_min = next_vertex->y;
   if (next_vertex->y > active_window->y_max) active_window->y_max = next_vertex->y;

   e.x1 = current_vertex.x;
   e.y1 = current_vertex.y;
   e.z1 = current_vertex.z;

   e.xn = next_vertex->x;
   e.yn = next_vertex->y;
   e.zn = next_vertex->z;

   dx = ROUND16 (e.xn) - ROUND16 (e.x1);
   dy = (e.yn) - (e.y1);

   if (dy == 0)
      {
      e.ydir = 0;
      e.dxy = 0;

      e.x2 = e.xn;
      e.y2 = e.yn;
      e.z2 = e.zn;

      e.xjump = e.x2 - e.x1;

      e.fz2.sign = 1;
      e.fz2.d_whole = 0;
      e.fz2.d_fract = 0;
      e.fz2.running = 0;
      e.fz2.active = e.z1;
      }
   else
      {
      ady = HABS (dy);

      e.dxy = (e.xn - e.x1) / ady;
      e.ydir = dy < 0 ? -1 : 1;

      e.x2 = e.x1 + e.dxy;
      e.y2 = e.y1 + e.ydir;

      fixed_divide ((e.zn - e.z1),
                    ady,
                    &e.fz2.sign,
                    &e.fz2.d_whole,
                    &e.fz2.d_fract);

      e.fz2.running = 0x40000000;

      e.fz2.active = e.z1;

      Fixed_add (e.fz2);
      e.z2 = e.fz2.active;
      }


   /* Set steps */

   dx = ROUND16 (e.x2) - ROUND16 (e.x1);
   dy = (e.y2) - (e.y1);

   if (dy == 0)
      {
      e.ydir = 0;
      e.zb_ydir = 0;
      e.cb_ydir = 0;
      }
   else
      {
      if (dy < 0)
         {
         e.ydir = -1;
         e.zb_ydir = -ystep;
         e.cb_ydir = -ystep2;
         }
      else
         {
         e.ydir = 1;
         e.zb_ydir = ystep;
         e.cb_ydir = ystep2;
         }
      }

   if (dx == 0)
      {
      adx = dx;

      e.xdir = 0;
      e.zb_xdir = 0;
      e.cb_xdir = 0;

      e.fz1.sign = 1;
      e.fz1.d_whole = 0;
      e.fz1.d_fract = 0;
      e.fz1.running = 0;
      }
   else
      {
      if (dx < 0)
         {
         adx = -dx;
         e.xdir = -ONE16;
         e.zb_xdir = -xstep;
         e.cb_xdir = -xstep2;
         }
      else
         {
         adx = dx;
         e.xdir = ONE16;
         e.zb_xdir = xstep;
         e.cb_xdir = xstep2;
         }

      fixed_divide ((e.z2 - e.z1),
                    (adx),
                    &e.fz1.sign,
                    &e.fz1.d_whole,
                    &e.fz1.d_fract);

      e.fz1.running = 0x40000000;
      }

   e.xjump = adx >> 1;
   e.fz1.active = e.z1;

   e.zb = active_window->zbuf +
      (offset = e.y1 * active_window->x_dits + ROUND16 (e.x1) + 1);

   e.cb = active_window->cbuf + (offset);

   e.side = LINE_SIDE;

   HPset_weight_steps (&e, ACTIVE_WEIGHT);

   wxoff = wp[0].x;
   wyoff = wp[0].y;

   HSedge_vis (&e);

   xold = ROUND16 (e.x1);
   yold = (e.y1);

   if ((e.y1) == (e.yn))
      {
      if (e.x1 != e.xn)
         do
            {
            stat = HPone_step (&e);
            HSset_style (e.x1, e.y1);
            HSedge_vis (&e);
            }

         while (!(stat & RESET) && !(stat & EDGE_END));
      }
   else
      while (((ROUND16 (e.x1) != ROUND16 (e.xn)) ||
              ((e.y1) != (e.yn))) &&
             ((e.y1) != (e.yn + e.ydir)))
         {
         HPone_step (&e);
         HSset_style (e.x1, e.y1);
         HSedge_vis (&e);
         }

#if DEBUG_LINE
fini:
#endif
   /* Move second vertice to first */

   current_vertex = *next_vertex;
   }
#endif /* ifndef FILLED  */

/*---HStrap_radge-----------------------------------------------*/

#if DELETE
void HStrap_radge_delete (struct trapezoid * tile)
#elif FILLED
void HStrap_radge_filled (struct trapezoid * tile)
#else
void HStrap_radge (struct trapezoid * tile)
#endif

   {
   struct edge_info el, er;
   int dy, dxl, dxr;
   int adxl, adxr;
   int statl, statr;

   c1++;

#  if DELETE
   background = (HSzbuf) tiling_parms.maximum_z;
#  endif

   HSset_display_colors ();

   xdits = active_window->x_dits;
   xdits2 = xdits << 1;

#  if DEBUG_TRAP
   if (!(DTRAP))
      return (0);
#  endif

#  if DEBUG_TLOG
   fprintf (stderr, "1 %1d %d\n", c1, tile->id);
   fprintf (stderr, " %10.6f %10.6f %12d %2d\n",
            (double) (tile->x0 / 65535.0), (double) (tile->ya), tile->z0, tile->shade0);
   fprintf (stderr, " %10.6f %10.6f %12d %2d\n",
            (double) (tile->x1 / 65535.0), (double) (tile->ya), tile->z1, tile->shade1);
   fprintf (stderr, " %10.6f %10.6f %12d %2d\n",
            (double) (tile->x2 / 65535.0), (double) (tile->yb), tile->z2, tile->shade2);
   fprintf (stderr, " %10.6f %10.6f %12d %2d\n",
            (double) (tile->x3 / 65535.0), (double) (tile->yb), tile->z3, tile->shade3);
#  endif

#  if DEBUG_T
   if( c1 <= MAXC1 )
      {
#     if DELETE
      fprintf (stderr, "\nHStrap_radge_delete --- %1d %x\n", c1, tile->id);
#     elif FILLED
      fprintf (stderr, "\nHStrap_radge_filled --- %1d %x\n", c1, tile->id);
#     else
      fprintf (stderr, "\nHStrap_radge --- %1d %x\n", c1, tile->id);
#     endif

      fprintf (stderr, "p0 -- %10.6f %10.6f %x %x\n",
               (double) (tile->x0 / 65535.0), (double) (tile->ya /* /65535.0 */ ), tile->z0, tile->shade0);
      fprintf (stderr, "p1 -- %10.6f %10.6f %x %x\n",
               (double) (tile->x1 / 65535.0), (double) (tile->ya /* /65535.0 */ ), tile->z1, tile->shade1);
      fprintf (stderr, "p2 -- %10.6f %10.6f %x %x\n",
               (double) (tile->x2 / 65535.0), (double) (tile->yb /* /65535.0 */ ), tile->z2, tile->shade2);
      fprintf (stderr, "p3 -- %10.6f %10.6f %x %x\n",
               (double) (tile->x3 / 65535.0), (double) (tile->yb /* /65535.0 */ ), tile->z3, tile->shade3);
      }               
#  endif

#  if FILLED
   MIN_MAX_TEST
#  endif

   /* START */

   el.x1 = tile->x2;
   el.y1 = tile->yb;
   el.z1 = tile->z2;

   el.xn = tile->x0;
   el.yn = tile->ya;
   el.zn = tile->z0;

   er.x1 = tile->x3;
   er.y1 = tile->yb;
   er.z1 = tile->z3;

   er.xn = tile->x1;
   er.yn = tile->ya;
   er.zn = tile->z1;

   dxl = ROUND16 (el.xn) - ROUND16 (el.x1);
   dxr = ROUND16 (er.xn) - ROUND16 (er.x1);
   dy = el.dy = (el.yn) - (el.y1);

   if (dy == 0)
      {
      el.ydir = 0;
      el.x2 = el.xn;
      el.y2 = el.yn;
      el.z2 = el.zn;

      el.fz2.sign = 1;
      el.fz2.d_whole = 0;
      el.fz2.d_fract = 0;
      el.fz2.running = 0;
      el.fz2.active = el.z1;

      er.ydir = 0;
      er.x2 = er.xn;
      er.y2 = er.yn;
      er.z2 = er.zn;

      er.fz2.sign = 1;
      er.fz2.d_whole = 0;
      er.fz2.d_fract = 0;
      er.fz2.running = 0;
      er.fz2.active = er.z1;
      }
   else
      {
      el.ydir = 1;
      el.dxy = (el.xn - el.x1) / dy;

      el.x2 = el.x1 + el.dxy;
      el.y2 = el.y1 + 1;

      fixed_divide ((el.zn - el.z1),
                    dy,
                    &el.fz2.sign,
                    &el.fz2.d_whole,
                    &el.fz2.d_fract);

      el.fz2.running = 0x40000000;


      er.ydir = 1;
      er.dxy = (er.xn - er.x1) / dy;

      er.x2 = er.x1 + er.dxy;
      er.y2 = er.y1 + 1;

      fixed_divide ((er.zn - er.z1),
                    dy,
                    &er.fz2.sign,
                    &er.fz2.d_whole,
                    &er.fz2.d_fract);

      er.fz2.running = 0x40000000;

      el.fz2.active = el.z1;
      er.fz2.active = er.z1;

      Fixed_add (el.fz2);
      el.z2 = el.fz2.active;

      Fixed_add (er.fz2);
      er.z2 = er.fz2.active;
      }

   dxl = ROUND16 (el.x2) - ROUND16 (el.x1);
   dy = (el.y2) - (el.y1);

   if (dy == 0)
      {
      el.ydir = 0;
      el.zb_ydir = 0;
#     if FILLED
      el.cb_ydir = 0;
#     endif
      }
   else
      {
      if (dy < 0)
         {
         el.ydir = -1;
         el.zb_ydir = -ystep;
#        if FILLED
         el.cb_ydir = -ystep2;
#        endif
         }
      else
         {
         el.ydir = 1;
         el.zb_ydir = ystep;
#        if FILLED
         el.cb_ydir = ystep2;
#        endif
         }
      }

   if (dxl == 0)
      {
      adxl = 0;

      el.xdir = 0;
      el.zb_xdir = 0;
#     if FILLED
      el.cb_xdir = 0;
#     endif

      el.fz1.sign = 1;
      el.fz1.d_whole = 0;
      el.fz1.d_fract = 0;
      el.fz1.running = 0;
      }
   else
      {
      if (dxl < 0)
         {
         adxl = -dxl;

         el.xdir = -ONE16;
         el.zb_xdir = -xstep;
#        if FILLED
         el.cb_xdir = -xstep2;
#        endif
         }
      else
         {
         adxl = dxl;

         el.xdir = ONE16;
         el.zb_xdir = xstep;
#        if FILLED
         el.cb_xdir = xstep2;
#        endif
         }

      fixed_divide ((el.z2 - el.z1),
                    adxl,
                    &el.fz1.sign,
                    &el.fz1.d_whole,
                    &el.fz1.d_fract);

      el.fz1.running = 0x40000000;
      }

   el.fz1.active = el.z1;
   el.stop_mask = dxl <= 1 ? JUST_JUMPED : ABOUT_TO_JUMP;
   el.stop_mask |= EDGE_END;
   el.side = LEFT_SIDE;

   el.xjump = adxl >> 1;

#  if FILLED
   el.zb = active_window->zbuf +
      (offset = el.y1 * active_window->x_dits + ROUND16 (el.x1) + 1);

   el.cb = active_window->cbuf + (offset);
#  else
   el.zb = active_window->zbuf +
      (el.y1 * active_window->x_dits + ROUND16 (el.x1) + 1);
#  endif


   dxr = ROUND16 (er.x2) - ROUND16 (er.x1);

   if (dy == 0)
      {
      er.ydir = 0;
      er.zb_ydir = 0;
#     if FILLED
      er.cb_ydir = 0;
#     endif
      }
   else
      {
      if (dy < 0)
         {
         er.ydir = -1;
         er.zb_ydir = -ystep;
#        if FILLED
         er.cb_ydir = -ystep2;
#        endif
         }
      else
         {
         er.ydir = 1;
         er.zb_ydir = ystep;
#        if FILLED
         er.cb_ydir = ystep2;
#        endif
         }
      }

   if (dxr == 0)
      {
      adxr = dxr;

      er.xdir = 0;
      er.zb_xdir = 0;
#     if FILLED
      er.cb_xdir = 0;
#     endif

      er.fz1.sign = 1;
      er.fz1.d_whole = 0;
      er.fz1.d_fract = 0;
      er.fz1.running = 0;
      }
   else
      {
      if (dxr < 0)
         {
         adxr = -dxr;

         er.xdir = -ONE16;
         er.zb_xdir = -xstep;
#        if FILLED
         er.cb_xdir = -xstep2;
#        endif
         }
      else
         {
         adxr = dxr;

         er.xdir = ONE16;
         er.zb_xdir = xstep;
#        if FILLED
         er.cb_xdir = xstep2;
#        endif
         }

      fixed_divide ((er.z2 - er.z1),
                    adxr,
                    &er.fz1.sign,
                    &er.fz1.d_whole,
                    &er.fz1.d_fract);

      er.fz1.running = 0x40000000;
      }

   er.stop_mask = dxr >= -1 ? JUST_JUMPED : ABOUT_TO_JUMP;
   er.stop_mask |= EDGE_END;
   er.side = RIGHT_SIDE;

   er.xjump = adxr >> 1;

#  if FILLED
   er.zb = active_window->zbuf +
      (offset = er.y1 * active_window->x_dits + ROUND16 (er.x1) + 1);

   er.cb = active_window->cbuf + (offset);
#  else
   er.zb = active_window->zbuf +
      (er.y1 * active_window->x_dits + ROUND16 (er.x1) + 1);
#  endif

   er.fz1.active = er.z1;

   HPtrap_vis (&el);
   HPtrap_vis (&er);

   if (el.y1 != el.yn)
      {
      statl = statr = 0;
      while ((!(statl & EDGE_END) || !(statr & EDGE_END)) && el.dy > 0)
         {

         /* Fill the edges for the scanline unless, for the left edge, x in
          * decreasing and it's about to jump to the next scanline, and, for
          * the right edge x in increasing and it's about to jump to the next
          * scanline */

         if (dxl > 1 && el.xjump != 0)
            do
               {
#              if FILLED
                  statl = HPone_step (&el);
#              else
                  statl = HPone_step_trap (&el);
#              endif

               HPtrap_vis (&el);
               }

            while (!(statl & ABOUT_TO_JUMP) && !(statl & EDGE_END));

         if (dxr <= -1 && er.xjump != 0)
            do
               {
#              if FILLED
                  statr = HPone_step (&er);
#              else
                  statr = HPone_step_trap (&er);
#              endif

               HPtrap_vis (&er);
               }

            while (!(statr & ABOUT_TO_JUMP) && !(statr & EDGE_END));

         /* Fill the trapezoid between the two edges */

         HPfill_trap (&el, &er);

         /* process the edge until it jumps down to the next scanline */

         do
            {
#           if FILLED
               statl = HPone_step (&el);
#           else
               statl = HPone_step_trap (&el);
#           endif

            HPtrap_vis (&el);
            }

         while (!(statl & JUST_JUMPED) && !(statl & EDGE_END));

         do
            {
#           if FILLED
               statr = HPone_step (&er);
#           else
               statr = HPone_step_trap (&er);
#           endif

            HPtrap_vis (&er);
            }

         while (!(statr & JUST_JUMPED) && !(statr & EDGE_END));
         }
      }

   HPfill_trap (&el, &er);
   }
