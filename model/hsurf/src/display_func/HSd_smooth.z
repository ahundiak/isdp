
/*
$Author: hans $
$Revision: 1.1.1.1 $
$Date: 2001/12/17 22:40:36 $
$Locker:  $
*/

/*		Apogee com[pliant		*/

#define TIMING_ON	0

#include "stdio.h"
#include "igrtypedef.h"
#include "igr.h"

#include "hsmath.h"
#include "HStl_global.h"
#include "HStl_window.h"
#include "HStl_element.h"
#include "hsdisplay.h"
#include "HSd_fixedpt.h"
#include "HSd_macros.h"
#include "igecolor.h"
#include "wl.h"

#include "HSpr_display.h"

#if TIMING_ON
/*#include "/usr2/mike/timing/HStiming.h"*/
#endif

#if defined( TRANSPARENT )
extern unsigned char trans_pat6[6][6];
#endif

extern short *IGErgb_table;
extern struct WLcmap_entry       IGEphys_vlt[512]; 

static int	*dither_row;
static int	dither_mat[16] = {  0,  8,  2, 10,
                                   12,  4, 14,  6,
                                    3, 11,  1,  9,
                                   15,  7, 13,  5 };

/*---GET_PIXEL_COLOR---------------------  --------------------------------*/

/*
NAME
	GET_PIXEL_COLOR (Local Macro)
	
DESCRIPTION
	Given the RGB color of the trapezoid, the intensity of the trapezoid
	at the given pixel and the coordinates of the given pixel, get the
	colortable index for the pixel
	
HISTORY
	??/??/??	J. Underwood
		Created
*/

#define zGET_PIXEL_COLOR( x, y, shade, cb )			\
	(cb) = (HScbuf)IGErgb_to_index( 				\
	                      active_window->context_no, x, y, 		\
			      ((element_parms.red*shade)>>24),		\
			      ((element_parms.green*shade)>>24),	\
			      ((element_parms.blue*shade)>>24));

#define GET_PIXEL_COLOR( x, y, r, g, b, cb )	\
	{					\
	HSRGB_TO_INDEX( (cb),			\
			 x, y, 			\
			 ((r)>>24),	\
			 ((g)>>24),	\
			 ((b)>>24) ); \
	}

#define yGET_PIXEL_COLOR( x, y, shade, cb )	\
	{					\
	(cb) = 1;	\
	}

/*---FILL_UP------------------------------------------------------------*/

/*
NAME
	FILL_UP (Local Macro)
	
DESCRIPTION
	The Macro clears up a problem that occurs when the step in x
	is large enough that the new xleft is greater that the old
	xright.  The nature of the problem is a "saw tooth" effect
	along the edge of the trapezoid
	
HISTORY
	??/??/??	M. Lanier
		Create
*/

#define FILL_UP( y )						\
								\
    {								\
    if( rxb < rxa && ((y)-1) != tile->ya )			\
        {							\
         if( (dxc = rxa - rxb) == 0 )				\
            {							\
            drc = 0;						\
            dgc = 0;						\
            dbc = 0;						\
								\
            rzc.sign = 1;					\
            rzc.d_whole = 0;					\
            rzc.d_fract = 0;					\
            }							\
        else							\
            {							\
            dbc = ( rsa - rsb ) / dxc;				\
            drc = red * dbc;					\
            dgc = green * dbc;					\
            dbc = blue * dbc;					\
								\
            fixed_divide(    (rza.active - rzb.active),		\
                    dxc,					\
                    &rzc.sign,					\
                    &rzc.d_whole,				\
                    &rzc.d_fract );				\
            }							\
								\
        rzc.running = 0x40000000;				\
        rzc.active = rzb.active;				\
								\
        xleft = rxb >> 16;					\
        xright = rxa >> 16;					\
								\
        zb = active_window->zbuf +				\
            (offset = (y) * active_window->x_dits + xleft);	\
        cb = active_window->cbuf + offset;			\
								\
        rrc = red * rsb;					\
        rgc = green * rsb;					\
        rbc = blue * rsb;					\
								\
        for( x=xleft; x<=xright; x++ )				\
            {							\
            TRANSLUCENT( x, y )					\
            if( *zb >= rzc.active )				\
                {						\
                *zb = rzc.active;				\
                GET_PIXEL_COLOR( x, y, rrc, rgc, rbc, *cb )	\
                }						\
								\
            MOVE_NEXT_PIXEL_SHADE				\
            }							\
        }							\
    }

		
/*---HSsmooth_shade_(trans)(opaque)----------------------------*/

#if defined( TRANSPARENT )
	void HSsmooth_shade_trans( struct trapezoid *tile )
#else
	void HSsmooth_shade_opaque( struct trapezoid *tile )
#endif

/*
NAME
	HSsmooth_shade_trans
	HSsmooth_shade_opaque
	
DESCRIPTION
	Smooth shading rasterizer.  Given a trapezoid,  processes
	pixel by pixel, interpolating a z and intensity.  Will use
	the z to determine visibility based on data current in the
	zbuffer.  Will use the intensity to determine a color table
	index.  If visible will update the z and image buffers
	
ARGUMENTS
	tile	: pointer to a trapezoid structure
	
HISTORY
	??/??/??	M. Lanier
		Created
*/


    {
    int			rxa, rxb, dxa, dxb;
    int			rsa, rsb, dsa, dsb;

    int			dxc;		
    int			rsc, rsd;	
    int			rrc, drc;
    int			rgc, dgc;
    int			rbc, dbc;
    int			dx, dy;	

    int			offset;		

    struct HSfixedpt	rza, rzb, rzc;	

    register int	x, y;
    register int	xleft, xright;	

    register HSzbuf	*zb;		
    register HScbuf	*cb;

    IGRuint		red, green, blue;
    IGRuint		re, gr, bl;

    register int        dither_val;

#   if TIMING_ON
#   if defined( TRANSPARENT )
        HPtiming_start(2);
#   else
        HPtiming_start(1);
#   endif
#   endif

    MIN_MAX_TEST

    /*  Shift the shade so that we can keep it integer */
    /*  and retain some precision.		       */

    /*  Get the context information and compute the number of intensities  */

    	    
    /*
    IGEload_context( active_window->context_no, &IGEcontext_info );
    tiling_parms.apparent_shades = ((IGEcontext_info.cube_size-1)*16)+1;
    */
      
    red   = (element_parms.red   * tiling_parms.apparent_shades) >> 8;
    green = (element_parms.green * tiling_parms.apparent_shades) >> 8;
    blue  = (element_parms.blue  * tiling_parms.apparent_shades) >> 8;

    rsa = (tile->shade2)<<16;
    rsb = (tile->shade3)<<16;
    rsc = (tile->shade0)<<16;
    rsd = (tile->shade1)<<16;

    CALC_DXDY_DZDY_DSDY

    y = tile->yb;
    dither_row = dither_mat + ((y & 3) << 2);

    /*  BRIGHT EDGES:  Because we are using integer arithmetic (for speed), there	*/
    /*     is an error incured when computing the z of a pixel.  Sometime around the	*/
    /*     edges of the surface, a hidden pixel will compute a nearer z than the 	*/
    /*     hiding pixel.   When that hidden pixel has a brighter intensity than 	*/
    /*     the hiding pixel, then the anomoly "bright edges" occurs.  To solve this	*/
    /*     we says that when two trapezoids are compeating for a given pixel and	*/
    /*     their z's for that pixel are within tolerance of each other, then the	*/
    /*     darker pixel wins								*/

    /*  For bright edges, we always special case the first and last pixel of a row	*/
    /*  but for the first and last row, we have to special case all the pixels, ie we	*/
    /*  are running the bright edge test on the pixels that border the trapezoid	*/
        
    CHECK_BRIGHT_TOP_BOTTOM_SHADE
    MOVE_TO_NEXT_ROW_SHADING

    for( y++; y < tile->ya; y++ )
        {
        dither_row = dither_mat + ((y & 3) << 2);
    
        INIT_SHADE_VARIABLES
        INIT_Z_VARIABLES
        INIT_X_VARIABLES

        CALC_DZ_DX
        CALC_DSHADE_DX

        CALC_BUFFER_ADDRESSES

        CHECK_BRIGHT_EDGES( xleft )

        MOVE_NEXT_PIXEL_SHADE

        for( x = xleft+1; x < xright; x++ )
            {

            /*  If the z of the pixel stored in the z		*/
            /*  buffer is greater than or equal to the z	*/
            /*  of the new pixel then the new pixel		*/
            /*  replaces the old pixel in then z buffer 	*/
            /*  and color buffer				*/
            
            TRANSLUCENT( x, y )
            if( *zb >= rzc.active )
                {
                *zb = rzc.active;
                GET_PIXEL_COLOR( x, y, rrc, rgc, rbc, *cb )
                }
    
            MOVE_NEXT_PIXEL_SHADE
            }

        if( x == xright ) CHECK_BRIGHT_EDGES( x )
    
        MOVE_TO_NEXT_ROW_SHADING        
        }
        
    dither_row = dither_mat + ((y & 3) << 2);
    if( y <= tile->ya )    
        CHECK_BRIGHT_TOP_BOTTOM_SHADE

#   if TIMING_ON
#   if defined( TRANSPARENT )
        HPtiming_stop(2);
#   else
        HPtiming_stop(1);
#   endif
#   endif
    }
