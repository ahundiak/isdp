/*
Name
        RevAssly.u

Description
        This ppl is invoked in the pre-processing stage of the revise
        assembly command. It first reads the assembly file name from
        the shared memory location and attaches that file to the master
        file. Then it gets the module environment of the attached assembly
        file and checks if a part definition is available in it. It then
        builds the reference file tree giving this module environment.
        If the individual file does not have a part definition, the op_type
        member of the nodes is set to "UpdateOperation". The node info
        of each node in the tree is then sent across to the external 
        process, by writing it into the shared memory. After the
        END_OF_TREE is transmitted, this EMS process waits until its
        semaphore again becomes 1(after the revasm form is accepted).
        This EMS process then starts receiving the node info from the
        external process and rebuilds the tree.

        Finally, the updated assembly tree is processed and the assembly
        updated.

History
        dkk     06/21/94        creation
*/
#include "ciminimum.h"
#include "OMindex.h"
#include "OMminimum.h"
#include "OMerrordef.h"
#include <exdef.h>
#include <ex.h>
#include <exmacros.h>
#include "DIdef.h"
#include "igetypedef.h"
#include "igrtypedef.h"
#include <gr.h>
#include <grdpbdef.h>
#include <grdpbmacros.h>
#include <refdef.h>
#include <ref.h>
#include <refmacros.h>
#include "cimacros.h"

#include "assemdef.h"
#include "assem.h"
#include "assemmacros.h"

#include "asmrevdef.h"
#include "revasmipc.h"

extern DIstmocpy();
extern EMgenerate_revasm_tree();
extern EMprint_revasm_tree();
extern EMfree_revasm_tree();
extern send_tree_thru_shm();
extern build_tree_from_shm();
extern get_ipcsetup();

main()
{
int      sts, fileno;
long     msg, type;
int      shmid, emssem, extsem;
NodeInfo *nodeptr;
char     assyfilename[DI_PATH_MAX];
struct   GRmd_env env, modenv;
char     path[DI_PATH_MAX];
struct   GRid mod_id, id, pid;
int      part_found;
REVASM_TREE *asm_tree, *tree_ptr;

    part_found = FALSE;
    asm_tree = NULL;

    /* Get the setup of the shared memory, wait till emssem is 1 */
    if( get_ipc_setup(&nodeptr, &shmid, &emssem, &extsem) < 0 )
    {
	write("EMS:Could not get ipc setup\n");
	goto quit;
    }

    /* Read the assembly filename in shm */
    strcpy(assyfilename, nodeptr->o_part.filename);    

    gr$attach_reffile( msg = &msg,
                       filename = assyfilename,
		       ref_properties = 0,
                       ref_grid = &id );

    if( msg & 1 )
    {
        /* Get the module environment of the attached reffile */
        sts = ci$send (msg = message GRreffile.GRgetenvironment
                                               (&msg, &modenv, &env),
                          targetid = id.objid,
                          targetos = id.osnum);
            
        if (!(sts & msg & 1))
        {
            write("EMS:Failed to get assembly module env\n");
	    goto quit;
        }
	sts = asm$get_file_part( msg = &msg,
				 mod_env = &env,
				 part_id = &pid );
	if( sts & msg & 1 )
    	    part_found = TRUE;
    }
    else
    {
        write("EMS:Could not attach assembly file\n");
        goto quit;
    }

    /* build the ref file tree of the assembly */
    sts = EMgenerate_revasm_tree( &msg, NULL, &asm_tree);

    if(msg & 1) 
    {
	if(asm_tree == NULL)
        /*	EMprint_revasm_tree(asm_tree);
	else*/
    	{
        	write("EMS: Could not build reference file tree 1\n");
                goto quit;
    	}
    }
    else
    {
        write("EMS: Could not build reference file tree 2\n");
        goto quit;
    }

    /* Send the tree info to the external process and wait 
       IMP NOTE: Not sending the top node since it is a dummy file.
       (Tree generation is working only if we send the master env)
       Also decrementing the nest level of all files by 1.
     */
    tree_ptr = asm_tree;
    while(tree_ptr)
    {
		if (tree_ptr->info.op_type == UpdateOperation)
			part_found = FALSE;
        tree_ptr->info.depth = tree_ptr->info.depth - 1;
        tree_ptr = tree_ptr->next;
    }

    send_tree_thru_shm( asm_tree->next, nodeptr, emssem, extsem );

    /* Free up the local tree */
    EMrevasm_free_tree(asm_tree);

    asm_tree = NULL;
    /* Receive the updated tree info from the external process */
    build_tree_from_shm(&asm_tree, nodeptr, extsem, emssem);

    if(asm_tree)
    {
      /* 	EMprint_revasm_tree(asm_tree);*/

        /* Update the assembly */
        EMrevise_assembly( &msg, asm_tree);

	if (part_found == FALSE) 
	{
            type = 1;
            sts = ci$send (msg = message GRreffile.GRrfclose
                                               (&msg, &type),
                          targetid = id.objid,
                          targetos = id.osnum);
	}
    }

quit:
    if(asm_tree == NULL)
        nodeptr->op_type = END_OF_TREE;

    sem_signal(extsem);

    EMclose_ipc(nodeptr, emssem, extsem);
}
