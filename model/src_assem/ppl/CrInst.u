#include "ciminimum.h"
#include "cimacros.h"
#include "cieveryone.h"
#include "FI.h"
#include "CIforms.h"
#include "msdef.h"
#include "growner.h"
#include "grgsdef.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "grsymdef.h"
#include "grsym.h"
#include <grerr.h>
#include "grsymmacros.h"
#include "nddef.h"
#include "ndmacros.h"
#include "dpdef.h"
#include "dp.h"
#include "dpmacros.h"
#include "refdef.h"
#include <sys/types.h>
#include <sys/dir.h>
#include <dirent.h>
#include "assemdef.h"
#include "assem.h"
#include "assemmacros.h"

#define FINISHED       -1
#define START           0
#define GET_PART        1
#define GET_ORIGIN      2
#define GET_GRAPHIC     3
#define CREATE_INSTANCE 4
#define CLEANUP         5

#define PART_FORM   2

#define PART_TYPE   26

#define ATTACHED    32
#define ATTRS_GROUP 34

#define FIELD1      18
#define FIELD2      25
#define FIELD3      28

#define FIELD1_TEXT 16
#define FIELD2_TEXT 24
#define FIELD3_TEXT 31

#define DIRECTORY   FIELD1
#define FILENM      FIELD2
#define VIEW        FIELD3
#define PART        FIELD3
#define DATABASE    FIELD1
#define CATALOG     FIELD2
#define LIBRARY     FIELD2

#define PART_ATTRS  12
#define INST_ATTRS  15
#define MESSAGE     10
#define DELETE      24
#define ACCEPT      1
#define EXECUTE     2
#define CANCEL      4
#define TITLE       11

#define GRAPHIC_DISP    29
#define HANDLE_DISP     35
#define IN_BOM          36
#define FILE_IN_BOM     37
#define WRITABLE        39
#define FILE_ATTACHED   40
#define BACKGROUND_REF  38

IGRint                  om_msg, msg, ok;
struct GRevent          event;
struct GRmd_env         mod_env, lc_mod_env, env_path, part_mod_env;
struct GRid             part_id, instance_id, graphic_id, window_id, temp_id;
struct GRid             ref_id, temp_ref_id, file_part_id, * p_id;
struct var_list         var[2];
struct GRid             sv_ids[20];
IGRlong                 num_sv_ids;
IGRint                  state, response;
IGRdouble               origin[3];
IGRint                  num_attrs, num_part_attrs, num_inst_attrs;
EMattr                * attrs, attr;
IGRint                  attrs_buffer_size;
struct CIform_st        form_st;
char                  * form_ptr;
int                     form_displayed;
IGRchar                 buffer[256];
IGRint                  sel, pos, i, j, size, mode, count;
IGRint                  delete_state, part_row, inst_row, delete_row, num_rows;
IGRint                  batch_mode;
IGRint                  gadget_mask;
IGRint                  part_type, tmp_part_type;
IGRboolean              part_created, inst_created, attr_found, attached;
IGRboolean              part_type_changed, attached_changed, part_changed;
IGRchar                 directory[256], filename[20], view[20];
IGRchar                 number[40], revision[20];
char                  * cp;
IGRuint                 props;
IGRint                  row, gadget_state;
struct dirent         * entry;
DIR                   * dp;
IGRchar                 path[1024];

extern IGRboolean EMis_om_file();
extern char * strcpy();
extern char * strcat();
extern char * strchr();
extern int GRdpb_get();
extern int FIf_new();
extern int FIfld_set_text();
extern int FIfld_get_text();
extern int FIfld_set_cmd_oid_os();
extern int FIf_display();
extern int FIf_erase();
extern int FIfld_get_num_rows();
extern int FIf_delete();
extern int Wait_timer();
extern int ci_notification();
extern int FIf_set_cmd_oid_os();
extern int FIf_reset();
extern int FIfld_set_list_default_text();
extern int FIf_is_displayed();
extern int FIfld_get_mode();
extern int FIfld_set_mode();
extern int FIfld_get_active_row();
extern int FIg_get_state();
extern int FIg_display();
extern int printf();
extern int sprintf();
extern long EXgetcwd();

get_file_part ()
{
    if (temp_ref_id.objid != NULL_OBJID)
    {
        ci$send (msg = message GRgraphics.GRdelete (&msg, &mod_env),
                 targetid = temp_ref_id.objid,
                 targetos = temp_ref_id.osnum);
        temp_ref_id.objid = NULL_OBJID;
        part_id.objid = NULL_OBJID;
    }
    
    if (attached)
    {
        sprintf (path, "%s/%s", directory, filename);

        if (EMis_om_file(path))
        {
            om_msg = EMconstruct_reffile (&msg,
                                          &mod_env,
                                          path,
                                          NULL,
                                          GRIS_NEW | GRNOT_IN_RTREE,
                                          GRIS_TEMPORARY,
                                          NULL, NULL, NULL,
                                          &temp_ref_id);
            if (om_msg & msg & 1)
            {
                om_msg = ci$send (msg = message GRreffile.GRgetenvironment
                                  (&msg, &env_path, &part_mod_env),
                                  targetid = temp_ref_id.objid,
                                  targetos = temp_ref_id.osnum);
                
                if (om_msg & msg & 1)
                {
                    om_msg = asm$get_file_part (msg = &msg,
                                                mod_env = &part_mod_env,
                                                part_id = &file_part_id);
                    
                    if (om_msg & msg & 1)
                    {
                        part_id.objid = file_part_id.objid;
                        part_id.osnum = file_part_id.osnum;
                    }
                }
            }
        }
        else
        {
            msg = MSFAIL;
        }
    }

    if (!(om_msg & msg & 1) && (temp_ref_id.objid != NULL_OBJID))
    {
        ci$send (msg = message GRgraphics.GRdelete (&msg, &mod_env),
                 targetid = temp_ref_id.objid,
                 targetos = temp_ref_id.osnum);
        temp_ref_id.objid = NULL_OBJID;
    }
}

update_filenames ()
{
    if (dp = (DIR *)opendir(directory))
    {
        row=0;
        
        while (entry = (struct dirent *)readdir(dp))
        {
            strncpy (buffer, entry->d_name, DIRSIZ);
            buffer[DIRSIZ] = '\0';
            
            sprintf (path, "%s/%s", directory, buffer);
            
            if (EMis_om_file(path))
            {
                FIfld_set_list_text (form_ptr, 
                                     FILENM, 
                                     row, 0, 
                                     buffer,
                                     FALSE);
                row = row + 1;
            }
        }

        closedir(dp);
    }
}

update_saved_views ()
{
    if (attached && (temp_ref_id.objid != NULL_OBJID))
    {
        count = 0;
        
        dp$total_num_saved_vw (msg = &msg,
                               total_num = &count,
                               osnum = &part_mod_env.md_id.osnum);

        if (count <= 20)
        {
            num_sv_ids = 20;
            
            dp$get_saved_vw_id(msg = &msg, 
                               osnum = part_mod_env.md_id.osnum,
                               name = "*",
                               numberofids = (IGRlong *)&count,
                               found_GRids = sv_ids,
                               array_size = num_sv_ids, 
                               total_num = &num_sv_ids);
            
            var[0].var = SAV_VW_NAME;
            var[0].num_bytes = sizeof(char) * DI_PATH_MAX;
            var[0].var_ptr = buffer;
            var[0].bytes_returned = &count;
            var[1].var = END_PARAM;

            row = 0;
            
            for (i=0; i<num_sv_ids; i=i+1)
            {
                buffer[0] = '\0';
                
                dp$inq_set_saved_view (msg = &msg,
                                       inq0_set1 = 0,
                                       osnum = part_mod_env.md_id.osnum,
                                       vw_objid = sv_ids[i].objid,
                                       which_error = &msg,
                                       var_list = var);
                
                if (buffer[0] != '\0')
                {
                    FIfld_set_list_text (form_ptr,
                                         VIEW,
                                         row, 0,
                                         buffer,
                                         FALSE);
                }
            }
        }
    }
}

form_attached_changed ()
{
    FIg_reset (form_ptr, PART_ATTRS);
    FIg_reset (form_ptr, INST_ATTRS);

    if ((part_type == EM_REFERENCE_PART) && 
        (attached == FALSE))
    {
        FIg_disable (form_ptr, ATTRS_GROUP);
    }
    else if ((part_type == EM_REFERENCE_PART) &&
             (attached == TRUE))
    {   
        FIg_enable (form_ptr, ATTRS_GROUP);
        update_saved_views ();
    }
    else
    {
        FIg_enable (form_ptr, ATTRS_GROUP);
    }

    attached_changed = FALSE;
}
    
form_part_changed ()
{
    if (part_id.objid != NULL_OBJID)
    {
        /*
         * Update the saved view list.
         */
        update_saved_views ();

        /*
         * Initialize the number of attributes to 0 and name 
         * to NULL.
         */
        num_attrs = 0;

        /*
         * Get all the attributes.
         */
        om_msg = asm$attribute_count (msg = &msg,
                                      id = &part_id,
                                      count = &num_attrs);
        
        if (!(om_msg & msg & 1))
        {
            status ("Couldn't get the number of part attributes");
        }
        else
        {
            /*
             * Get some memory.
             */
            if (attrs == NULL)
            {
                attrs = (EMattr *)om$malloc(size = num_attrs * sizeof(EMattr));
            }
            else if (attrs_buffer_size < num_attrs)
            {
                attrs = (EMattr *)om$realloc(ptr = attrs, 
                                             size = num_attrs * sizeof(EMattr));
            }
            
            if (attrs != NULL)
            {
                attrs_buffer_size = num_attrs;
                
                part_row = 0;
                inst_row = 0;
                
                for (i=0; i<num_attrs; i=i+1)
                {
                    om_msg = asm$get_attribute (msg = &msg,
                                                index = i,
                                                id = &part_id,
                                                attribute = &attrs[i]);
                    if (om_msg & msg & 1)
                    {
                        if ((attrs[i].info.type & EM_PART_ATTR) ||
                            (attrs[i].info.type & EM_COMMON_ATTR))
                        {
                            FIfld_set_text (form_ptr, 
                                            PART_ATTRS, 
                                            part_row, 0, 
                                            attrs[i].info.name,
                                            FALSE);
                            FIfld_set_text (form_ptr, 
                                            PART_ATTRS, 
                                            part_row, 1, 
                                            attrs[i].value.syntax,
                                            FALSE);
                            FIfld_set_text (form_ptr, 
                                            PART_ATTRS, 
                                            part_row, 2, 
                                            attrs[i].info.desc,
                                            FALSE);
                            part_row = part_row + 1;
                        }
                        else if (attrs[i].info.type & EM_INSTANCE_ATTR)
                        {
                            FIfld_set_text (form_ptr, 
                                            INST_ATTRS, 
                                            inst_row, 0, 
                                            attrs[i].info.name,
                                            FALSE);
                            FIfld_set_text (form_ptr, 
                                            INST_ATTRS, 
                                            inst_row, 1, 
                                            attrs[i].value.syntax,
                                            FALSE);
                            FIfld_set_text (form_ptr, 
                                            INST_ATTRS, 
                                            inst_row, 2, 
                                            attrs[i].info.desc,
                                            FALSE);
                            inst_row = inst_row + 1;
                        }
                    }
                }

                state = GET_PART;
            }
            else
            {
                attrs_buffer_size = 0;
                msg = MSFAIL;
                status ("Out of memory!");
            }
        }
    }
    else
    {
        FIg_reset (form_ptr, PART_ATTRS);
        FIg_reset (form_ptr, INST_ATTRS);
    }

    part_changed = FALSE;
}

form_part_type_changed ()
{
    switch (part_type)
    {
    case EM_REFERENCE_PART:
        props = EM_REFERENCE_PART | EM_GRAPHIC_DISPLAYED | 
                EM_HANDLE_DISPLAYED | EM_IN_BOM | EM_FILE_IN_BOM;
                

        FIg_set_state (form_ptr, GRAPHIC_DISP, TRUE);
        FIg_set_state (form_ptr, HANDLE_DISP, TRUE);
        FIg_set_state (form_ptr, IN_BOM, TRUE);
        FIg_display (form_ptr, FILE_IN_BOM);
        FIg_set_state (form_ptr, FILE_IN_BOM, TRUE);
        FIg_display (form_ptr, WRITABLE);
        FIg_set_state (form_ptr, WRITABLE, TRUE);
        FIg_display (form_ptr, FILE_ATTACHED);
        FIg_set_state (form_ptr, FILE_ATTACHED, TRUE);
        FIg_display (form_ptr, BACKGROUND_REF);
        FIg_set_state (form_ptr, BACKGROUND_REF, FALSE);
        
        FIg_set_state (form_ptr, ATTACHED, attached);
        FIg_display (form_ptr, ATTACHED);

        FIg_reset (form_ptr, DIRECTORY);
        FIg_set_text (form_ptr, DIRECTORY, directory);
        FIg_display (form_ptr, DIRECTORY);
        FIg_get_text (form_ptr, FIELD1_TEXT, buffer);
        if (strcmp(buffer, "Directory"))
        {
            FIg_erase(form_ptr, FIELD1_TEXT);
            FIg_set_text (form_ptr, FIELD1_TEXT, "Directory");
        }
        FIg_display (form_ptr, FIELD1_TEXT);
        
        FIg_reset (form_ptr, FILENM);
        FIg_set_text (form_ptr, FILENM, filename);

        update_filenames ();
        
        FIg_display (form_ptr, FILENM);
        FIg_get_text (form_ptr, FIELD2_TEXT, buffer);
        if (strcmp(buffer, "Filename"))
        {
            FIg_erase(form_ptr, FIELD2_TEXT);
            FIg_set_text (form_ptr, FIELD2_TEXT, "Filename");
        }
        FIg_display (form_ptr, FIELD2_TEXT);
        
        FIg_reset (form_ptr, VIEW);
        FIg_set_text (form_ptr, VIEW, view);

        update_saved_views ();
        
        FIfld_set_mode (form_ptr, VIEW, 0, FI_INSERT);
        FIg_display (form_ptr, VIEW);
        FIg_get_text (form_ptr, FIELD3_TEXT, buffer);
        if (strcmp(buffer, "View"))
        {
            FIg_erase(form_ptr, FIELD3_TEXT);
            FIg_set_text (form_ptr, FIELD3_TEXT, "View");
        }
        FIg_display (form_ptr, FIELD3_TEXT);
        break;
        
    case EM_GRAPHIC_PART:
    case EM_NONGRAPHIC_PART:
        props = part_type | EM_GRAPHIC_DISPLAYED | EM_HANDLE_DISPLAYED |
                EM_IN_BOM;

        FIg_erase (form_ptr, FILE_IN_BOM);
        FIg_erase (form_ptr, WRITABLE);
        FIg_erase (form_ptr, FILE_ATTACHED);
        FIg_erase (form_ptr, BACKGROUND_REF);
        
        FIg_set_state (form_ptr, GRAPHIC_DISP, TRUE);
        FIg_set_state (form_ptr, HANDLE_DISP, TRUE);
        FIg_set_state (form_ptr, IN_BOM, TRUE);
        
        FIg_erase (form_ptr, ATTACHED);
        FIg_erase (form_ptr, FIELD1);
        FIg_erase (form_ptr, FIELD2);
        FIg_erase (form_ptr, FIELD1_TEXT);
        FIg_erase (form_ptr, FIELD2_TEXT);
        
        /*
         * Update the available parts.
         */
        FIg_reset (form_ptr, PART);
        count = 0;
        asm$part_count (msg = &msg, 
                        mod_env = &mod_env, 
                        count = &count);
        
        if (count && (msg & 1))
        {
            FIfld_set_list_num_rows (form_ptr, PART, 0, count);

            row = 0;
            
            for (i=0; i<count; i=i+1)
            {
                asm$get_part (msg = &msg,
                              mod_env = &mod_env,
                              index = i,
                              part_id = &temp_id);

                asm$get_part_type (msg = &msg,
                                   part_id = &temp_id,
                                   type = &tmp_part_type);
                
                if (tmp_part_type == part_type)
                {
                    asm$get_attribute (msg = &msg,
                                       id = &temp_id,
                                       name = "number",
                                       attribute = &attr);

                    strcpy (buffer, attr.value.data.s);
                
                    asm$get_attribute (msg = &msg,
                                       id = &temp_id,
                                       name = "revision",
                                       attribute = &attr);

                    strcat (buffer, " ");
                    strcat (buffer, attr.value.data.s);
                
                    if (temp_id.objid == part_id.objid)
                    {
                        FIfld_set_text (form_ptr, PART, 0, 0, buffer, FALSE);
                        FIfld_set_list_text (form_ptr, PART, row, 0, buffer, TRUE);
                    }
                    else
                    {
                        FIfld_set_list_text (form_ptr, PART, row, 0, buffer, FALSE);
                    }
                    
                    row = row + 1;
                }
            }
        }
        FIg_display (form_ptr, PART);
        FIg_get_text (form_ptr, FIELD3_TEXT, buffer);
        if (strcmp(buffer, "Part"))
        {
            FIg_erase(form_ptr, FIELD3_TEXT);
            FIg_set_text (form_ptr, FIELD3_TEXT, "Part");
        }
        FIg_display (form_ptr, FIELD3_TEXT);
        break;
        
    default:
        break;
    }

    form_attached_changed ();
    
    part_type_changed = FALSE;
}

form_update()
{
    if (part_type_changed)
    {
        form_part_type_changed ();
    }    

    if (attached_changed)
    {
        form_attached_changed ();
    }

    if (part_changed)
    {
        form_part_changed ();
    }
}

main ()
{
    om_msg = OM_S_SUCCESS;
    msg = MSSUCC;
    attrs = NULL;
    attrs_buffer_size = 0;
    part_type = EM_REFERENCE_PART;
    
    message("Create Instance");

    /*
     * Get the current module environment.
     */	
    ci$get_module_info( md_env = &mod_env );
    ci$get_module_info( md_env = &part_mod_env );

    /*
     * Read in the form. PlPart must reside in one of the product
     * "config/english/forms" directories to be found.
     */
    form_ptr = NULL;
    FIf_new( PART_FORM, "CrInst", ci_notification, &form_ptr);

    if (!(int)form_ptr)
    {
        status ("Could not create the form CrInst");
        msg = MSFAIL;
    }
    else
    {
        /*
         * Associate the form with this command object.
         */
        FIf_set_cmd_oid_os( form_ptr, MY_ID, OM_Gw_current_OS );
        state = START;
    }

    /*
     * Loop until the state is set to FINISHED.
     */
    while (state != FINISHED)
    {
        /*
         * Goto the appropriate state.
         */                
        switch (state)
        {
            /*
             * (Re)initialize the command.
             */
        case START:
            part_created = FALSE;
            inst_created = FALSE;
            attached = FALSE;
            part_id.objid = NULL_OBJID;
            file_part_id.objid = NULL_OBJID;
            temp_ref_id.objid = NULL_OBJID;
            instance_id.objid = NULL_OBJID;
            part_type_changed = TRUE;
            attached_changed = TRUE;
            part_changed = TRUE;
            
            strcpy (directory, ".");
            EXgetcwd (directory, 1024);
            filename[0] = '\0';
            strcpy (view, "front");
            
            number[0] = '\0';
            revision[0] = '\0';
            
            /*
             * Reset all gadgets on the form. This will clear out
             * all fields.
             */
            FIf_reset(form_ptr);

            state = GET_PART;

            break;

        case GET_PART:

            form_update ();

            if (!(om_msg & msg & 1))
            {
                state = CLEANUP;
            }
            else
            {
                /*                
                 * (Re)display the form.
                 */
                FIf_is_displayed (form_ptr, &form_displayed);
                
                if (!(int)form_displayed) FIf_display( form_ptr );
            }

            /*
             * Wait for the user to input the part
             * attributes on the form.
             */
            while (state == GET_PART)
            {
                ci$getevent(response = &response, 
                            prompt = "Select part on form" );

                if (!(om_msg & msg & 1))
                {
                    state = CLEANUP;
                }
            }
            break;

        case GET_ORIGIN:
            ci$getevent (prompt = "Enter placement point",
                         event = &event,
                         response = &response,
                         stackable = 1,
                         window_id = &window_id.objid,
                         window_osnum = &window_id.osnum);
            
            switch (response)
            {
            case EX_DATA:
                origin[0] = event.event.button.x;
                origin[1] = event.event.button.y;
                origin[2] = event.event.button.z;
                state = CREATE_INSTANCE;
                break;
                
            case EX_BACK_UP:
                state = GET_PART;
                break;
            }
            break;
            
        case GET_GRAPHIC:
            /*
             * Locate graphics ...
             */
            ci$locate (obj = &graphic_id.objid,
                       osnum = &graphic_id.osnum,
                       prompt = "Identify part graphic",
                       acc_prompt = "Accept with part origin or Reject",
                       relocate_prompt = "Element not found",
                       classes = "GRvg",
                       md_env = &lc_mod_env,
                       accept_point = origin,
                       window_id = &window_id.objid,
                       window_osnum = &window_id.osnum,
                       stackable = 1,
                       owner_action = LC_GEOM_MOD | LC_NO_REF_HEADER |
                                      LC_NO_REF_OBJECTS,
                       response = &response );

            switch (response)
            {
            case EX_DATA:
                state = CREATE_INSTANCE;
                break;
                
            case EX_RJT_MOVEON:
                part_type = EM_NONGRAPHIC_PART;

                status ("Creating non-graphic part.");
                state = CREATE_INSTANCE;
                break;

            case EX_BACK_UP:
                state = GET_PART;
                break;
            }
            break;
            
        case CREATE_INSTANCE:
            switch (part_type)
            {
            case EM_REFERENCE_PART:
                sprintf (buffer, "%s/%s", directory, filename);
                
                status ("Creating Instance");
                
                /*
                 * Create the instance.
                 */
                om_msg = asm$create_instance (msg = &msg,
                                              mod_env = &mod_env,
                                              type = props & EM_PART_TYPES,
                                              display = props & EM_DISPLAY_PROPS,
                                              behavior = props & EM_BEHAVIOR_PROPS,
                                              origin = origin,
                                              window_id = &window_id,
                                              filename = buffer,
                                              view = view,
                                              instance_id = &instance_id);
                
                if (!(om_msg & msg & 1))
                {
                    status ("Could not place part.");
                }
                else
                {
                    status ("Created Instance");
                    
                    dp$display (msg = &msg,
                                osnum = mod_env.md_id.osnum,
                                oids = &instance_id);

                    if (temp_ref_id.objid != NULL_OBJID)
                    {
                        ci$send (msg = message GRgraphics.GRdelete (&msg, 
                                                                    &mod_env),
                                 targetid = temp_ref_id.objid,
                                 targetos = temp_ref_id.osnum);
                    }
                }
                
                state = START;
                break;
                
            case EM_GRAPHIC_PART:
            case EM_NONGRAPHIC_PART:
                if (part_id.objid != NULL_OBJID)
                {
                    if (part_type == EM_GRAPHIC_PART)
                    {
                        p_id = &graphic_id;
                    }
                    else
                    {
                        p_id = NULL;
                    }
                    
                    om_msg = asm$create_instance (msg = &msg,
                                                  mod_env = &mod_env,
                                                  type = props & EM_PART_TYPES,
                                                  display = props & EM_DISPLAY_PROPS,
                                                  behavior = props & EM_BEHAVIOR_PROPS,
                                                  part_id = &part_id,
                                                  num_graphics = 1,
                                                  graphic_ids = p_id,
                                                  origin = origin,
                                                  window_id = &window_id,
                                                  instance_id = &instance_id);

                    if (!(om_msg & msg & 1))
                    {
                        status ("Couldn't create instance.");
                    }
                    else
                    {
                        dp$display (msg = &msg,
                                    osnum = mod_env.md_id.osnum,
                                    oids = &instance_id);
                    }
                }
                else
                {
                    status ("Couldn't create part.");
                }
                
                state = START;
                break;

            default:
                status ("Don't support placement of parts of that type yet!");
                state = START;
                break;
            }
                
            break;
            
        case CLEANUP:
            if ( form_ptr ) 
            {
                FIf_delete( form_ptr );
                form_ptr = NULL;
            }
    
            if (part_created)
            {
                ci$send (msg = message GRgraphics.GRdelete (&msg, &mod_env),
                         targetid = part_id.objid,
                         targetos = part_id.osnum);
                part_created = FALSE;
            }

            if (inst_created)
            {
                ci$send (msg = message GRgraphics.GRdelete (&msg, &mod_env),
                         targetid = instance_id.objid,
                         targetos = instance_id.osnum);
                inst_created = FALSE;
            }
            
            if (attrs)
            {
                free (attrs);
                
                attrs = NULL;
            }

            state = FINISHED;
            break;
        }
    }
}

form_notification()
{
    switch ( form_st.gadget_label )
    {
    case ATTACHED:
        FIg_get_state (form_ptr, ATTACHED, &gadget_mask);
        attached_changed = TRUE;
        attached = gadget_mask;
        
        if (attached)
        {
            FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                            "Checking file, please wait ...", FALSE);
            get_file_part ();

            FIfld_set_text (form_ptr, MESSAGE, 0, 0, "", FALSE);
                                
            if (!(om_msg & msg & 1))
            {
                part_id.objid = NULL_OBJID;
                
                FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                                "File is not a part", FALSE);

                filename[0] = '\0';
                    
                FIfld_set_text (form_ptr, FILENM, 0, 0, "", FALSE);
            }
        }
        else if (temp_ref_id.objid != NULL_OBJID)
        {
            om_msg = ci$send (msg = message GRgraphics.GRdelete (&msg,
                                                                 &mod_env),
                              targetid = temp_ref_id.objid,
                              targetos = temp_ref_id.osnum);
            part_id.objid = NULL_OBJID;
            file_part_id.objid = NULL_OBJID;
            temp_ref_id.objid = NULL_OBJID;
        }
        
        if (om_msg & msg & 1)
        {
            part_changed = TRUE;
            form_update ();
        }
        break;
        
    case PART_TYPE:
        FIfld_get_text (form_ptr,
                        PART_TYPE,
                        0, 0, MAX_VALUE,
                        buffer,
                        &sel, &pos);
        
        part_id.objid = NULL_OBJID;
        
        if ((part_type == EM_REFERENCE_PART) && 
            (temp_ref_id.objid != NULL_OBJID))
        {
            ci$send (msg = message GRgraphics.GRdelete(&msg, &mod_env),
                     targetid = temp_ref_id.objid,
                     targetos = temp_ref_id.osnum);

            temp_ref_id.objid = NULL_OBJID;
        }
        
        if (!strcmp(buffer, "File"))
        {
            part_type = EM_REFERENCE_PART;
        }
        else if (!strcmp(buffer, "Graphic"))
        {
            part_type = EM_GRAPHIC_PART;
        }
        else
        {
            part_type = EM_NONGRAPHIC_PART;
        }

        if ((part_type == EM_REFERENCE_PART) &&
            (attached == TRUE))
        {
            get_file_part ();
        }
        else if ((number[0] != '\0') && (revision[0] != '\0'))
        {
            om_msg = asm$get_part (msg = &msg,
                                   mod_env = &mod_env,
                                   number = number,
                                   revision = revision,
                                   part_id = &part_id);
        }

        part_type_changed = TRUE;
        part_changed = TRUE;
        form_update();
        break;
        
    case FIELD1:
        FIfld_get_text (form_ptr,
                        FIELD1,
                        0, 0, MAX_VALUE,
                        buffer,
                        &sel, &pos);

        if (part_type == EM_REFERENCE_PART)
        {
            strcpy (directory, buffer);

            if (temp_ref_id.objid != NULL_OBJID)
            {
                ci$send (msg = message GRgraphics.GRdelete(&msg, &mod_env),
                         targetid = temp_ref_id.objid,
                         targetos = temp_ref_id.osnum);

                temp_ref_id.objid = NULL_OBJID;
                part_id.objid = NULL_OBJID;
            }
            
            update_filenames ();
            
            if (attached)
            {
                get_file_part ();

                if (!(om_msg & msg & 1))
                {
                    part_id.objid = NULL_OBJID;
                    
                    FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                                    "File is not a part", FALSE);
                    filename[0] = '\0';
                    
                    FIfld_set_text (form_ptr, FILENM, 0, 0, "", FALSE);
                }
            }

            part_changed = TRUE;
            form_update ();
        }
        break;
        
    case FIELD2:
        FIfld_get_text (form_ptr,
                        FIELD2,
                        0, 0, MAX_VALUE,
                        buffer,
                        &sel, &pos);

        if (part_type == EM_REFERENCE_PART)
        {
            strcpy (filename, buffer);

            if (temp_ref_id.objid != NULL_OBJID)
            {
                ci$send (msg = message GRgraphics.GRdelete(&msg, &mod_env),
                         targetid = temp_ref_id.objid,
                         targetos = temp_ref_id.osnum);

                temp_ref_id.objid = NULL_OBJID;
                part_id.objid = NULL_OBJID;
            }
            
            if (attached && (filename[0] != '\0'))
            {
                FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                                "Checking file, please wait ...", FALSE);
                get_file_part ();

                FIfld_set_text (form_ptr, MESSAGE, 0, 0, "", FALSE);
                                
                if (!(om_msg & msg & 1))
                {
                    part_id.objid = NULL_OBJID;
                    
                    FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                                    "File is not a part", FALSE);

                    filename[0] = '\0';
                    
                    FIfld_set_text (form_ptr, FILENM, 0, 0, "", FALSE);
                }
            }

            part_changed = TRUE;
            form_update ();
        }
        break;
        
    case FIELD3:
        FIfld_get_text (form_ptr,
                        FIELD3,
                        0, 0, 256,
                        buffer,
                        &sel, &pos);

        if ((part_type == EM_GRAPHIC_PART) || 
            (part_type == EM_NONGRAPHIC_PART))

        {
            /*
             * Get the number and revision.
             */
            if ((cp = strchr(buffer, ' ')) != NULL)
            {
                *cp = '\0';
                
                strcpy (number, buffer);
                strcpy (revision, cp + 1);
            }
            else
            {
                strcpy (number, buffer);
                revision[0] = '\0';
            }

            /*
             * Get the part id.
             */
            om_msg = asm$get_part (msg = &msg,
                                   mod_env = &mod_env,
                                   number = number,
                                   revision = revision,
                                   part_id = &part_id);

            if (!(om_msg & msg & 1))
            {
                part_id.objid = NULL_OBJID;
            }
            
            /*
             * Set the part id changed and update form.
             */
            part_changed = TRUE;
            
            form_update();
        }
        else if (part_type == EM_REFERENCE_PART)
        {
            strcpy (view, buffer);
        }
        break;

    case GRAPHIC_DISP:
        FIg_get_state (form_ptr, form_st.gadget_label, &gadget_state);
        
        if (gadget_state)
        {
            props = props | EM_GRAPHIC_DISPLAYED;
        }
        else
        {
            props = props & ~EM_GRAPHIC_DISPLAYED;
        }
        
        break;

    case HANDLE_DISP:
        FIg_get_state (form_ptr, form_st.gadget_label, &gadget_state);
        
        if (gadget_state)
        {
            props = props | EM_HANDLE_DISPLAYED;
        }
        else
        {
            props = props & ~EM_HANDLE_DISPLAYED;
        }
        
        break;

    case IN_BOM:
        FIg_get_state (form_ptr, form_st.gadget_label, &gadget_state);
        
        if (gadget_state)
        {
            props = props | EM_IN_BOM;
        }
        else
        {
            props = props & ~EM_IN_BOM;
        }
        
        break;

    case FILE_IN_BOM:
        FIg_get_state (form_ptr, form_st.gadget_label, &gadget_state);
        
        if (gadget_state)
        {
            props = props | EM_FILE_IN_BOM;
        }
        else
        {
            props = props & ~EM_FILE_IN_BOM;
        }
        
        break;

    case WRITABLE:
        FIg_get_state (form_ptr, form_st.gadget_label, &gadget_state);
        
        if (gadget_state)
        {
            props = props & ~EM_READONLY;
        }
        else
        {
            props = props | EM_READONLY;
        }
        
        break;

    case FILE_ATTACHED:
        FIg_get_state (form_ptr, form_st.gadget_label, &gadget_state);
        
        if (gadget_state)
        {
            props = props & ~EM_DETACHED;
        }
        else
        {
            props = props | EM_DETACHED;
        }
        
        break;
        
    case EXECUTE:
        part_changed = TRUE;
        form_update();
        break;
    
    case ACCEPT:
        switch (part_type)
        {
        case EM_REFERENCE_PART:
            if ((filename[0] != '\0') && (directory[0] != '\0'))
            {
                state = GET_ORIGIN;
            }
            else
            {
                FIfld_set_text (form_ptr, 0, 0, 
                                "Filename not specified", sel);
            }
            break;
        case EM_GRAPHIC_PART:
        case EM_NONGRAPHIC_PART:
            if (part_id.objid != NULL_OBJID)
            {
                if (part_type == EM_GRAPHIC_PART)
                {
                    state = GET_GRAPHIC;
                }
                else
                {
                    state = CREATE_INSTANCE;
                }
            }
            else
            {
                FIfld_set_text (form_ptr, 0, 0, 
                                "Part not specified", sel);
            }
            break;
        }

        if (state != GET_PART)
        {
            FIf_erase (form_ptr);
            FIf_reset (form_ptr);
            ci$put( response = EX_RJT_MOVEON );
        }
        break;

    case CANCEL:
        state = FINISHED;
        FIf_erase (form_ptr);
        FIf_reset (form_ptr);
        ci$put( response = EX_FORM_FINISHED );
        break;

    case PART_ATTRS:
    case INST_ATTRS:
        break;
    }
}

init ()
{
    form_ptr = NULL;
}

wakeup()
{
    if ( form_ptr )
    {
        if (form_displayed == 1) FIf_display( form_ptr );
    }
}

sleep()
{
    if ( form_ptr )
    {
        FIf_is_displayed (form_ptr, &form_displayed);
        if (form_displayed == 1) FIf_erase( form_ptr );
    }
}

delete()
{
    if ( form_ptr ) 
    {
        FIf_delete( form_ptr );
    }
    
    if ( attrs ) 
    {
        free (attrs);
    }

    if (temp_ref_id.objid != NULL_OBJID)
    {
        ci$send (msg = message GRgraphics.GRdelete(&msg, &mod_env),
                 targetid = temp_ref_id.objid,
                 targetos = temp_ref_id.osnum);
    }
}

