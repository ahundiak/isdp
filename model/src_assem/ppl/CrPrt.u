#include "ciminimum.h"
#include "cimacros.h"
#include "cieveryone.h"
#include "FI.h"
#include "CIforms.h"
#include "msdef.h"
#include "growner.h"
#include "grgsdef.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "grsymdef.h"
#include "grsym.h"
#include <grerr.h>
#include "grsymmacros.h"
#include "nddef.h"
#include "ndmacros.h"
#include "assemdef.h"
#include "assem.h"
#include "assemmacros.h"

#define FINISHED       -1
#define START           0
#define GET_PART_INFO   1
#define CLEANUP         5

#define PART_FORM   2

#define PART_TYPE   26

#define FIELD1      18
#define FIELD2      25
#define FIELD3      29
#define FIELD4      31

#define FIELD1_TEXT 16
#define FIELD2_TEXT 24
#define FIELD3_TEXT 28
#define FIELD4_TEXT 30

#define NUMBER      FIELD1
#define REVISION    FIELD2
#define FILENAME    FIELD3
#define LIBRARY     FIELD3
#define ENTRY       FIELD4

#define ATTRS_GROUP 34
#define PART_ATTRS  12
#define INST_ATTRS  15
#define MESSAGE     10
#define ACCEPT      1
#define EXECUTE     2
#define CANCEL      4
#define TITLE       11

IGRint                  om_msg, msg, ok;
struct GRevent          event;
struct GRmd_env         mod_env;
struct GRid             part_id, temp_id;
struct GRid             ref_id;
IGRint                  state, response;
IGRint                  num_attrs, num_part_attrs, num_inst_attrs;
EMattr                * attrs, attr;
IGRint                  attrs_buffer_size;
struct CIform_st        form_st;
char                  * form_ptr;
int                     form_displayed;
IGRchar                 buffer[256];
IGRint                  sel, pos, i, j, size, mode, count;
IGRint                  delete_state, part_row, inst_row, delete_row, num_rows;
IGRint                  gadget_mask;
IGRint                  part_type;
IGRboolean              part_created, attr_found;
IGRboolean              part_type_changed, part_changed;
IGRchar                 directory[256], filename[20];
IGRchar                 number[40], revision[20];
IGRchar                 catalog[40], library[256], entry[20];

extern int GRdpb_get();
extern int FIf_new();
extern int FIfld_set_text();
extern int FIfld_get_text();
extern int FIfld_set_cmd_oid_os();
extern int FIf_display();
extern int FIf_erase();
extern int FIfld_get_num_rows();
extern int FIf_delete();
extern int Wait_timer();
extern int ci_notification();
extern int FIf_set_cmd_oid_os();
extern int FIf_reset();
extern int FIfld_set_list_default_text();
extern int FIf_is_displayed();
extern int FIfld_get_mode();
extern int FIfld_set_mode();
extern int FIfld_get_active_row();
extern int FIg_get_state();
extern int FIg_display();
extern int printf();
extern int sprintf();
extern long EXgetcwd();

form_update()
{
    switch (part_type)
    {
    case EM_REFERENCE_PART:
        FIg_disable (form_ptr, ATTRS_GROUP);
        FIg_reset (form_ptr, FILENAME);
        FIg_set_text (form_ptr, FILENAME, filename);
        FIg_display (form_ptr, FILENAME);
        FIg_get_text (form_ptr, FIELD3_TEXT, buffer);
        if (strcmp(buffer, "Filename"))
        {
            FIg_erase(form_ptr, FIELD3_TEXT);
            FIg_set_text (form_ptr, FIELD3_TEXT, "Filename");
        }
        FIg_display (form_ptr, FIELD3_TEXT);
        
        FIg_erase (form_ptr, FIELD4);
        FIg_erase (form_ptr, FIELD4_TEXT);
        break;
            
    case EM_GRAPHIC_PART:
    case EM_NONGRAPHIC_PART:
        FIg_enable(form_ptr, ATTRS_GROUP);
        FIg_erase (form_ptr, FIELD3);
        FIg_erase (form_ptr, FIELD4);
        FIg_erase (form_ptr, FIELD3_TEXT);
        FIg_erase (form_ptr, FIELD4_TEXT);
        break;
        
    default:
        break;
    }
}

main ()
{
    attrs = NULL;
    attrs_buffer_size = 0;
    num_attrs = 0;
    
    message("Create Part");

    /*
     * Get the current module enviroment.
     */	
    ci$get_module_info( md_env = &mod_env );

    /*
     * Read in the form. CrPrt must reside in one of the product
     * "config/english/forms" directories to be found.
     */
    form_ptr = NULL;
    FIf_new( PART_FORM, "CrPrt", ci_notification, &form_ptr);

    if (!(int)form_ptr)
    {
        status ("Could not create the form CrPrt");
        msg = MSFAIL;
    }
    else
    {
        /*
         * Associate the form with this command object.
         */
        FIf_set_cmd_oid_os( form_ptr, MY_ID, OM_Gw_current_OS );
        state = START;
    }

    /*
     * Loop until the state is set to FINISHED.
     */
    while (state != FINISHED)
    {
        /*
         * Goto the appropriate state.
         */                
        switch (state)
        {
            /*
             * (Re)initialize the command.
             */
        case START:
            om_msg = OM_S_SUCCESS;
            msg = MSSUCC;
            part_created = FALSE;
            part_type = EM_GRAPHIC_PART;
            part_id.objid = NULL_OBJID;
            
            number[0] = '\0';
            revision[0] = '\0';
            filename[0] = '\0';
            library[0] = '\0';
            entry[0] = '\0';
            
            /*
             * Reset all gadgets on the form. This will clear out
             * all fields.
             */
            FIf_reset(form_ptr);

            state = GET_PART_INFO;

            break;

        case GET_PART_INFO:

            form_update ();

            if (!(om_msg & msg & 1))
            {
                state = CLEANUP;
            }
            else
            {
                /*                
                 * (Re)display the form.
                 */
                FIf_is_displayed (form_ptr, &form_displayed);
                
                if (!(int)form_displayed) FIf_display( form_ptr );
            }

            /*
             * Wait for the user to input the part
             * attributes on the form.
             */
            while (state == GET_PART_INFO)
            {
                ci$getevent(response = &response, 
                            prompt = "Entry part info on form" );

                if (!(om_msg & msg & 1))
                {
                    state = CLEANUP;
                }
            }
            break;

        case CLEANUP:
            if ( form_ptr ) 
            {
                FIf_delete( form_ptr );
                form_ptr = NULL;
            }
    
            if (part_created)
            {
                ci$send (msg = message GRgraphics.GRdelete (&msg, &mod_env),
                         targetid = part_id.objid,
                         targetos = part_id.osnum);
                part_created = FALSE;
            }

            if (attrs)
            {
                free (attrs);
                
                attrs = NULL;
            }

            state = FINISHED;
            break;
        }
    }
}

form_notification()
{
    switch ( form_st.gadget_label )
    {
    case PART_TYPE:
        FIfld_get_text (form_ptr,
                        PART_TYPE,
                        0, 0, MAX_VALUE,
                        buffer,
                        &sel, &pos);
        
        if (!strcmp(buffer, "Reference"))
        {
            part_type = EM_REFERENCE_PART;
        }
        else if (!strcmp(buffer, "Graphic"))
        {
            part_type = EM_GRAPHIC_PART;
        }
        else if (!strcmp(buffer, "Non-Graphic"))
        {
            part_type = EM_NONGRAPHIC_PART;
        }
        else 
        {
            printf ("Error: Illegal part type set!\n");
        }

        form_update();
        
        break;
        
    case NUMBER:
        FIfld_get_text (form_ptr,
                        NUMBER,
                        0, 0, 256,
                        buffer,
                        &sel, &pos);

        om_msg = asm$get_part (msg = &msg,
                               mod_env = &mod_env,
                               number = number,
                               revision = revision,
                               part_id = &temp_id);
        
        if (!(om_msg & msg & 1))
        {
            strcpy (number, buffer);
            om_msg = OM_S_SUCCESS;
            msg = MSSUCC;
        }
        else
        {
            FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                            "Part already exists", FALSE);

            FIfld_set_text (form_ptr, NUMBER, 0, 0, number, FALSE);
        }
        break;
        
    case FIELD2:
        FIfld_get_text (form_ptr,
                        REVISION,
                        0, 0, 256,
                        buffer,
                        &sel, &pos);

        om_msg = asm$get_part (msg = &msg,
                               mod_env = &mod_env,
                               number = number,
                               revision = revision,
                               part_id = &temp_id);
        
        if (!(om_msg & msg & 1))
        {
            strcpy (revision, buffer);
            om_msg = OM_S_SUCCESS;
            msg = MSSUCC;
        }
        else
        {
            FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                            "Part already exists", FALSE);

            FIfld_set_text (form_ptr, NUMBER, 0, 0, number, FALSE);
        }
        break;
        
    case FIELD3:
        FIfld_get_text (form_ptr,
                        FIELD3,
                        0, 0, 256,
                        buffer,
                        &sel, &pos);

        switch (part_type)
        {
        case EM_REFERENCE_PART:
            strcpy (filename, buffer);
            break;
        }
        break;

    case FIELD3:
        FIfld_get_text (form_ptr,
                        FIELD3,
                        0, 0, 256,
                        buffer,
                        &sel, &pos);

        strcpy (entry, buffer);
        break;

    case EXECUTE:
    case ACCEPT:
        msg = MSSUCC;
        
        switch (part_type)
        {
        case EM_GRAPHIC_PART:
        case EM_NONGRAPHIC_PART:
        case EM_REFERENCE_PART:
            buffer[0] = '\0';
            
            if ((part_type == EM_REFERENCE_PART) && (filename[0] == '\0'))
            {
                strcpy (buffer, "Filename must be specified");
            }
            else if (number[0] == '\0')
            {
                strcpy (buffer, "Part number must be specified");
            }
            else if (revision[0] == '\0')
            {
                strcpy (buffer, "Part revision must be specified");
            }
            
            if (buffer[0] != '\0')
            {
                FIfld_set_text (form_ptr, 0, 0, buffer, FALSE);
                msg = MSFAIL;
            }
            break;
        }

        if (msg & 1)
        {
            /*
             * Get the number of attributes.
             */
            FIfld_get_num_rows( form_ptr, PART_ATTRS,  &num_part_attrs );
            FIfld_get_num_rows( form_ptr, INST_ATTRS, &num_inst_attrs );
            num_attrs = num_part_attrs + num_inst_attrs; 
           
            if (attrs == NULL)
            {
                /*
                 * Malloc some space for the attributes.
                 */
                attrs = (EMattr *)om$malloc (size = num_attrs * sizeof(EMattr));
                attrs_buffer_size = num_attrs;
            }
            else if (attrs_buffer_size < num_attrs)
            {
                attrs = (EMattr *)om$realloc(ptr = attrs, 
                                             size = num_attrs * sizeof(EMattr));
                attrs_buffer_size = num_attrs;                
            }

            /*
             * Get all the part attributes.
             */
            num_attrs = 0;

            for (i=0; i<num_part_attrs; i=i+1)
            {
                attrs[num_attrs].info.type = EM_PART_ATTR;
                
                FIfld_get_text (form_ptr,
                                PART_ATTRS,
                                i, 0, MAX_VALUE,
                                attrs[num_attrs].info.name,
                                &sel, &pos);

                if ((attrs[num_attrs].info.name[0] != '\0')         &&
                    strcmp(attrs[num_attrs].info.name, "number")    &&
                    strcmp(attrs[num_attrs].info.name, "revision")  &&
                    strcmp(attrs[num_attrs].info.name, "count")     &&
                    strcmp(attrs[num_attrs].info.name, "filename")  &&
                    strcmp(attrs[num_attrs].info.name, "library")   &&
                    strcmp(attrs[num_attrs].info.name, "catalog")   &&
                    strcmp(attrs[num_attrs].info.name, "database")  &&
                    strcmp(attrs[num_attrs].info.name, "entry"))
                {
                    FIfld_get_text (form_ptr,
                                    PART_ATTRS,
                                    i, 1, MAX_VALUE,
                                    attrs[num_attrs].value.syntax,
                                    &sel, &pos);
                
                    FIfld_get_text (form_ptr,
                                    PART_ATTRS,
                                    i, 2, MAX_VALUE,
                                    attrs[num_attrs].info.desc,
                                    &sel, &pos);

                    num_attrs = num_attrs + 1;
                }
                else if (attrs[num_attrs].info.name[0] != '\0')
                {
                    sprintf (buffer, "Can't add attribute %s", attrs[num_attrs].info.name);
                    FIfld_set_text (form_ptr, MESSAGE, 0, 0, buffer, FALSE);
                    break;
                }
            }

            /*  
             * Get all the instance attributes.
             */
            for (i=0; i<num_inst_attrs; i=i+1)
            {
                attrs[num_attrs].info.type = EM_INSTANCE_ATTR;
                
                FIfld_get_text (form_ptr,
                                INST_ATTRS,
                                i, 0, MAX_VALUE,
                                attrs[num_attrs].info.name,
                                &sel, &pos);

                if ((attrs[num_attrs].info.name[0] != '\0')         &&
                    strcmp(attrs[num_attrs].info.name, "number")    &&
                    strcmp(attrs[num_attrs].info.name, "revision")  &&
                    strcmp(attrs[num_attrs].info.name, "count")     &&
                    strcmp(attrs[num_attrs].info.name, "filename")  &&
                    strcmp(attrs[num_attrs].info.name, "library")   &&
                    strcmp(attrs[num_attrs].info.name, "catalog")   &&
                    strcmp(attrs[num_attrs].info.name, "database")  &&
                    strcmp(attrs[num_attrs].info.name, "entry"))
                {
                    FIfld_get_text (form_ptr,
                                    INST_ATTRS,
                                    i, 1, MAX_VALUE,
                                    attrs[num_attrs].value.syntax,
                                    &sel, &pos);
                
                    FIfld_get_text (form_ptr,
                                    INST_ATTRS,
                                    i, 2, MAX_VALUE,
                                    attrs[num_attrs].info.desc,
                                    &sel, &pos);

                    num_attrs = num_attrs + 1;
                }
                else if (attrs[num_attrs].info.name[0] != '\0')
                {
                    sprintf (buffer, "Can't add attribute %s", attrs[num_attrs].info.name);
                    FIfld_set_text (form_ptr, MESSAGE, 0, 0, buffer, FALSE);
                    msg = MSSUCC;
                }
            }

            if (msg & 1)
            {
                /*
                 * Create the part.
                 */
                if (part_type == EM_REFERENCE_PART)
                {
                    om_msg = asm$create_cached_part (msg = &msg,
                                                     mod_env = &mod_env,
                                                     type = part_type,
                                                     filename = filename,
                                                     part_id = &part_id);
                }
                else
                {
                    om_msg = asm$create_cached_part (msg = &msg,
                                                     mod_env = &mod_env,
                                                     type = part_type,
                                                     number = number,
                                                     revision = revision,
                                                     num_attributes = num_attrs,
                                                     attributes = attrs,
                                                     part_id = &part_id);
                }
            }

            if (om_msg & msg & 1)
            {
                if (form_st.gadget_label == ACCEPT)
                {
                    state = FINISHED;
                    FIf_erase (form_ptr);
                    FIf_reset (form_ptr);
                    ci$put( response = EX_RJT_MOVEON );
                }
                else
                {
                    number[0] = '\0';
                    FIfld_set_text (form_ptr, NUMBER, 0, 0, number, FALSE);
                    
                    revision[0] = '\0';
                    FIfld_set_text (form_ptr, REVISION, 0, 0, revision, FALSE);

                    filename[0] = '\0';
                    FIfld_set_text (form_ptr, FILENAME, 0, 0, filename, FALSE);

                    entry[0] = '\0';
                    FIfld_set_text (form_ptr, ENTRY, 0, 0, entry, FALSE);

                    library[0] = '\0';
                    FIfld_set_text (form_ptr, LIBRARY, 0, 0, library, FALSE);

                    FIg_reset (form_ptr, PART_ATTRS);
                    FIg_reset (form_ptr, INST_ATTRS);
                }

                FIfld_set_text (form_ptr, MESSAGE, 0, 0, "Part created", FALSE);
            }
            else
            {
                FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                                "Couldn't create part", FALSE);
            }
        }

        msg = MSSUCC;
        break;

    case CANCEL:
        state = FINISHED;
        FIf_erase (form_ptr);
        FIf_reset (form_ptr);
        ci$put( response = EX_FORM_FINISHED );
        break;

    case PART_ATTRS:
    case INST_ATTRS:
        break;
    }
}

init ()
{
    form_ptr = NULL;
}

wakeup()
{
    if ( form_ptr )
    {
        if (form_displayed == 1) FIf_display( form_ptr );
    }
}

sleep()
{
    if ( form_ptr )
    {
        FIf_is_displayed (form_ptr, &form_displayed);
        if (form_displayed == 1) FIf_erase( form_ptr );
    }
}

delete()
{
    if ( form_ptr ) 
    {
        FIf_delete( form_ptr );
    }
    
    if ( attrs ) 
    {
        free (attrs);
    }
}

