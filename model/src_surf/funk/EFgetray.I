/* ###################   APOGEE COMPILED   ################## */
class implementation EMSsubbs;

#include "EMS.h"
#define CUTOFF 0.01
#define MAX_ATTEMPTS 3

#include "EMSdef.h" /* For EMparms */
#include "EMSbstrim.h" /* for ZERO */
#include "bserr.h" /* for BSERROR ... */
#include "bsparameters.h" /* for BSTOLCOLLINVEC */
#include "bsptlngen.h"
#include "bsnorvec.h"
#include "bsmkvec.h"

EFget_ray (EMmsg, solid_GRid, env,range, point,attempt_no,line)

IGRlong *EMmsg;
struct GRid *solid_GRid;
struct GRmd_env *env;
IGRpoint range[2];
IGRpoint point;
IGRuint *attempt_no;
struct IGRbsp_curve *line;

/* *************************************************************************
Description
  This function generates a line passing through the point supplied and 
  the solid. The extents of the line are based on the range box of the
  solid.

  Input
    solid_GRid - object id and the object space of the solid
    env - module environment of the solid
    range - range of the solid if known. Otherwise this argument should
            be set to NULL.
    point - the input point
    attempt_no - the number of times the caller has tried so far to get
                 a ray. It is guaranteed that, the rays generated by
                 having different attempt numbers will be markedly different.
                 This number may increase within this function based on
                 whether the ray and the normal to the sample point on surface 
                 are nearly collinear.

  Output
    line - the definition of the ray

Notes
  Memory for the line should be allocated, for storing 2 poles, 4 knots and
  0 weights. Upon exit the completion code will be one of the following:
   EMS_S_Success : if successful
   EMS_E_Fail : if there is failure in one of the following
                Getting a point on the surface
                Getting the range of the solid
                Getting a better line
   EMS_E_BSerror : if the math returns an error

History
   07/06/93 	 Sudha 	     Modified for BSprototypes ansification
   08/27/92      NP          Modified for ANSI compliance.
   02/16/88      PP          Added a cutoff tolerance to detecting
                             tangency.
   12/12/87      PP          Creation
**************************************************************************** */
{
 IGRpoint range_buff[2];
 IGRdouble *range_ptr;
 IGRboolean status, bssts;
 IGRpoint extended_line[2];
 IGRboolean world = TRUE;
 BSrc rc;
 IGRint type_of_line;
 IGRint sign,max_no_tries;
 struct IGRline ray;
 struct EMparms parms;
 IGRvector dir_vec;
 IGRboolean found_point = FALSE;
 IGRdouble dot_product_value,colintol;
 IGRpoint point_on_surface;
 IGRboolean rlw_get_better_line ();

 status = OM_S_SUCCESS;
 *EMmsg = EMS_S_Success;

/*
 bssts = BSEXTRACTPAR (&rc, BSTOLCOLLINVEC, colintol);
 colintol = colintol * TANGENCY_FACTOR;
*/

/*
 if (colintol < CUTOFF)
*/

/*
 * I am using an absolute tolerance here since we do not have any
 * provision for an angular tolerance. I consider two vectors
 * to be not good when the angle between them is less than acos(0.01)
 * This is just a value obtained from gut feeling.
 */

 colintol = CUTOFF;

 found_point = FALSE;
 max_no_tries = 0;

 while (!found_point && (max_no_tries < MAX_ATTEMPTS))
 {
  status = om$send (msg = message EMSsurface.EMget_point_on_surface (EMmsg,
                         env, *attempt_no, 1, point_on_surface,
                         &parms),
                   senderid = NULL_OBJID,
                   targetid = solid_GRid->objid,
                   targetos = solid_GRid->osnum);
  EMerr_hndlr (!(1&status&*EMmsg), *EMmsg, EMS_E_Fail, wrapup);

  bssts = BSmkvec (&rc, dir_vec, &point[0], &point_on_surface[0]);
  EMerr_hndlr (BSERROR(rc), *EMmsg, EMS_E_BSerror, wrapup);

  bssts = BSnorvec (&rc, dir_vec);
  EMerr_hndlr (BSERROR(rc), *EMmsg, EMS_E_BSerror, wrapup);

  dot_product_value = parms.normal[0]*dir_vec[0] +
                      parms.normal[1]*dir_vec[1] +
                      parms.normal[2]*dir_vec[2];

  if ((dot_product_value > colintol) || (dot_product_value < -colintol))
    found_point = TRUE;
  else
  {
   ++(*attempt_no);
   ++max_no_tries;
  }
 }

 if (!found_point)
 {
  *EMmsg = EMS_E_Fail;
  goto wrapup;
 }

 ray.point1 = &point[0];
 ray.point2 = &point_on_surface[0];

 if (range)
  range_ptr = (IGRdouble *)range;
 else
  {
    status = om$send (msg = message GRvg.GRgetrang (EMmsg, 
                      &env->md_env.matrix_type, env->md_env.matrix, &world,
                      (IGRdouble *)range_buff),
                      senderid = NULL_OBJID,
                      targetid = solid_GRid->objid,
                      targetos = solid_GRid->osnum);
    EMerr_hndlr (!(1&status&*EMmsg), *EMmsg, EMS_E_Fail, wrapup);
    range_ptr = (IGRdouble *)range_buff;
  }

 bssts = rlw_get_better_line (range_ptr, &ray, extended_line, EMmsg);
 EMerr_hndlr (!(1&bssts&*EMmsg), *EMmsg, EMS_E_Fail, wrapup);

 bssts = BSptlngen (&rc, &extended_line[0][0], &extended_line[1][0],
                     line, &type_of_line);
 EMerr_hndlr (BSERROR(rc), *EMmsg, EMS_E_BSerror, wrapup);

wrapup:
 EMWRAPUP (*EMmsg,status,"In EFget_ray error");
 return;
}

end implementation EMSsubbs;
