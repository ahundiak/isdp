#include "stdio.h"
#if defined (CLIX)
#include "gpipe.h"
#endif
#include "OMminimum.h"
#include "igrtypedef.h"
#include "igr.h"
#include "HStl_window.h"
#include "HStl_element.h"
#include "HStl_global.h"
#include "HPglobal.h"
#include "HPr_macros.h"
#include "hsdisplay.h"
#include "HSd_fixedpt.h"
#include "HPdef.h"
#include "hsmath.h"
#include "hsmacdef.h"

#undef __

#include "HPpr_hplot_f.h"


/*-----------------------
 *
 *   for function
 *      fixed_divid
 */
 
#include "HSpr_display.h"

/*----------------------*/




/*
 *   Debugging stuff
 *
 *   What the different DEBUG's mean
 *
 *       DEBUG_T ------ Display readable formatted trapezoid
 *       DEBUG_P ------ Display readable formatted polyline
 *       DEBUG_TLOG --- Display trapezoid formatted for my display trap/line program.
 *       DEBUG_PLOG --- Display polyline formatted for my display trap/line program.
 *       DEBUG_TRAP --- Selectively process trapezoids (DTRAP)
 *       DEBUG_LINE --- Selectively process polylines (DLINE)
 *	 DEBUG_CTRAP -- Color the trap
 */

#define DEBUG_T		0
#define DEBUG_P		0
#define	DEBUG_TLOG	0
#define	DEBUG_PLOG	0
#define DEBUG_TRAP	0
#define DEBUG_LINE	0
#define	DEBUG_CTRAP	0
#define DEBUG_REGION	0

static HScbuf	VCOLOR_ON;
static HScbuf	VCOLOR_OFF;
static HScbuf	HCOLOR_ON;
static HScbuf	HCOLOR_OFF;

#define	zVCOLOR		1
#define	zHCOLOR_ON	3
#define	zHCOLOR_OFF	3
#define	TEDGE		5
#define	TINT		7

extern int dtrap;

#define DTRAP	((c1 == 38))
#define DLINE	(c2 >= 0)

#define IN_REGION(x,y)	( c2 == 1 )
#define yIN_REGION(x,y)	( ((x) >= 343 && (x) <= 345) && ((y) >= 353 && (y) <= 355) )
#define zIN_REGION(x,y)	( (x) > -1 )

static int c1 = 0;
static int c2 = 0;
static int c3 = 0;

/*
 *  Useful macros
 */
 
#define	HABS(x)	((x) < 0 ? -(x) : (x))

/*
 *  Handy constants
 */


#if BYTES_PER_PIXEL == 5

#define	EDGE_EDGE	0x20000000
#define	BAD_Z		0x40000000
#define EDGE_MASK	0x60000000
#define TRAP_EDGE	0x80000000
#define	MARK_MASK	0xe0000000
#define ZMASK		0x1fffffff

#else

#define	EDGE_EDGE	0x0001
#define	BAD_Z		0x0002
#define EDGE_MASK	0x0003
#define TRAP_EDGE	0x0004
#define MARK_MASK	0x0007
#define ZMASK		0x7fffffff

#endif

#define	ABOUT_TO_JUMP	0x01
#define	JUST_JUMPED	0x02    
#define	RESET		0x04
#define EDGE_END	0x08

#define	LEFT_SIDE	0x00
#define	RIGHT_SIDE	0x01
#define	LINE_SIDE	0x02

/*
 *  Weight stuff
 */
 
#define	ACTIVE_WEIGHT	((double)(5.08))
#define ACTIVE_WIDTH	(2)

static int	VWIDTH = 1;
static int	HWIDTH = 1;

static	int	wns;

static	struct	weight_pattern
		{
		char	x, y;
		} wp[512];
		
static	int	wxoff;
static	int	wyoff;
static	int	xdits, xdits2;

static void	(*add_visible_weight)() = NULL;
static void	(*add_hidden_weight)() = NULL;

/*
 *  something alot might use
 */
 
static 	int	offset;

/*
 *  step stuff
 */
 
#define	xstep	1
#define ystep	(xdits)


#if BYTES_PER_PIXEL == 5

#define	xstep2	1
#define ystep2	(xdits)

#else

#define	xstep2	2
#define ystep2	(xdits2)

#endif

#define	ONE16	(65536)

/*
 *  edge processing structure
 */
 
struct edge_info
	{
	int	x1, y1, z1;
	int	xn, yn, zn;
	int	x2, y2, z2;
	int	dy, dxy, xjump, xdir, ydir, stop_mask, side;
	int	cb_xdir, cb_ydir;
	int	zb_xdir, zb_ydir;
	HScbuf	*cb;
	HSzbuf	*zb;
	
	struct HSfixedpt	fz1, fz2;	
	};

/*
 *  edge segment starting point
 */
 		
static struct	polyline_vertex		current_vertex;

/*
 *  style stuff
 */
 
static	int	vstyle_index = 0;
static	double	vstyle_length = 0.0;
static	int	hstyle_index = 0;
static	double	hstyle_length = 0.0;
static	int	xold, yold;
static	int	vdebug;

#define	PSIZE_D		3.59
#define	PSIZE_HV	2.54

static double	pixel_size_diag	= PSIZE_D;
static double	pixel_size_hovt	= PSIZE_HV;


/*
 *  Prototype declaration for static functions
 */


/* NOTE: How to prototype a function pointer
static void __((*add_visible_weight)); */

static void HPadd_visible_weight_east_west (struct edge_info *, int ); 
static void HPadd_visible_weight_north_south (struct edge_info *, int );
static void HPadd_hidden_weight_north_south (struct edge_info *, int );
static void HPadd_weight (struct edge_info *, int);
static int HPset_weight_steps (struct edge_info * );
static HSedge_vis (struct edge_info *);
static HPtrap_vis (struct edge_info *);
static HPfill_trap (struct edge_info *, struct edge_info * );
static int HPone_step (struct edge_info *);
static void HPset_display_colors (void);
static void CLIP (int *, int *, int *, int *, int *, int *, int );

/* 
 *  TA DA...the code
 */
	
/*---HPadd_visible_weight_east_west-------------------------------------------------------*/

/*
NAME
	HPadd_visible_weight_east_west:  Static
	
KEYWORDS	
	HSplot
	rasterizer
	RHL
	visible edge
	weight
	static
	
DESCRIPTION
	Add weight to the edge in the +/- x direction.

PARAMETERS
	edge	:(IN) :  structure containing information about the edges
	color	:(IN) :  Active color inwhich to draw the edge
	
GLOBALS USED
	VWIDTH		: visible width, in pixels of the edges
	xstep2		: number of pixels to cross when making a single step
			  in x.  Will be 1 for 5 byte/pixel case and 2 for
			  the 6 byte/pixel case
	xstep		: number of pixels to cross when making a single step
			  in x.  Will be 1 for all cases
	active_window	: global structure
		zbuf, 
		cbug	: Address of the z/image buffer. Used to make sure that
			  by adding weight, we don't write outside of the
			  allocated memory.
		
HISTORY
	??/??/??	M. Lanier
		Created
		
*/
 
static void HPadd_visible_weight_east_west (struct edge_info *edge, int color)

	{
	int		i;
	HScbuf		*cb1, *cb2;
	HSzbuf		*zb1, *zb2, z;

#	if BYTES_PER_PIXEL == 5
		HSzbuf	mark;
#	else
		HScbuf	mark;
#	endif


	cb1 = cb2 = edge->cb;
	zb1 = zb2 = edge->zb;
	
#	if BYTES_PER_PIXEL == 5
		z = *edge->zb & ZMASK;	
		mark = *edge->zb & MARK_MASK;
#	else
		z = *edge->zb;
		mark = edge->cb[1];
#	endif

		
	/*
	 *  Add ACTIVE_WIDTH pixels of weight
	 */
	 
	i = VWIDTH;
	while( --i )
		{
		cb1 += (xstep2);
		zb1 += (xstep);
		
		if( !(zb1 < active_window->zbuf || zb1 > (HSzbuf *)active_window->cbuf) )
			{
#			if BYTES_PER_PIXEL == 5
				*cb1 = (color);
				*zb1 = z | mark;
#			else
				*cb1 = (color);
				cb1[1] = mark;
				*zb1 = z;
#			endif
			}

		/*
		 *  Just in case the width is odd
		 */
		 
		if( !(--i) ) break;

		cb2 -= (xstep2);
		zb2 -= (xstep);

		if( !(zb2 < active_window->zbuf || zb2 > (HSzbuf *)active_window->cbuf) )
			{
#			if BYTES_PER_PIXEL == 5
				*cb2 = (color);
				*zb2 = z | mark;
#			else
				*cb2 = (color);
				cb2[1] = mark;
				*zb2 = z;
#			endif
			}
		}
	}
	
/*---HPadd_visible_weight_north_south-------------------------------------------------------*/

/*
NAME
	HPadd_visible_weight_north_south:  Static
	
KEYWORDS	
	HSplot
	rasterizer
	RHL
	visible edge
	weight
	static
	
DESCRIPTION
	Add weight to the edge in the +/- y direction.

PARAMETERS
	edge	:(IN) :  structure containing information about the edges
	color	:(IN) :  Active color inwhich to draw the edge
	
GLOBALS USED
	VWIDTH		: visible width, in pixels of the edges
	xstep2		: number of pixels to cross when making a single step
			  in x.  Will be 1 for 5 byte/pixel case and 2 for
			  the 6 byte/pixel case
	xstep		: number of pixels to cross when making a single step
			  in x.  Will be 1 for all cases
	active_window	: global structure
		zbuf, 
		cbug	: Address of the z/image buffer. Used to make sure that
			  by adding weight, we don't write outside of the
			  allocated memory.
		
HISTORY
	??/??/??	M. Lanier
		Created
		
*/

static void HPadd_visible_weight_north_south (struct edge_info *edge, int color)

	{
	int		i;
	HScbuf		*cb1, *cb2;
	HSzbuf		*zb1, *zb2, z;
	
#	if BYTES_PER_PIXEL == 5
		HSzbuf	mark;
#	else
		HScbuf	mark;
#	endif

	cb1 = cb2 = edge->cb;
	zb1 = zb2 = edge->zb;
	
#	if BYTES_PER_PIXEL == 5
		z = *edge->zb & ZMASK;	
		mark = *edge->zb & MARK_MASK;
#	else
		z = *edge->zb;
		mark = edge->cb[1];
#	endif

	/*
	 *  Add ACTIVE_WIDTH pixels of weight
	 */
	 
	i = VWIDTH;
	while( --i )
		{
		cb1 += (ystep2);
		zb1 += (ystep);
		
		if( !(zb1 < active_window->zbuf || zb1 > (HSzbuf *)active_window->cbuf) )
			{
#			if BYTES_PER_PIXEL == 5
				*cb1 = (color);
				*zb1 = z | mark;
#			else
				*cb1 = (color);
				cb1[1] = mark;
				*zb1 = z;
#			endif
			}

		/*
		 *  Just in case the width is odd
		 */
		 
		if( !(--i) ) break;

		cb2 -= (ystep2);
		zb2 -= (ystep);

		if( !(zb2 < active_window->zbuf || zb2 > (HSzbuf *)active_window->cbuf) )
			{
#			if BYTES_PER_PIXEL == 5
				*cb2 = (color);
				*zb2 = z | mark;
#			else
				*cb2 = (color);
				cb2[1] = mark;
				*zb2 = z;
#			endif
			}
		}
	}
	
	
/*---HPadd_hidden_weight_east_west-------------------------------------------------------*/

/*
NAME
	HPadd_hidden_weight_east_west:  Static
	
KEYWORDS	
	HSplot
	rasterizer
	RHL
	visible edge
	weight
	static
	
DESCRIPTION
	Add weight to the edge in the +/- x direction.  In this case, we are
	adding weight to an edge that is hidden, therefore we have to make
	sure that the pixel we might mark for this edge is not already owned
	by an edge that was visible.

PARAMETERS
	edge	:(IN) :  structure containing information about the edges
	color	:(IN) :  Active color inwhich to draw the edge
	
GLOBALS USED
	HWIDTH		: hidden width, in pixels of the edges
	xstep2		: number of pixels to cross when making a single step
			  in x.  Will be 1 for 5 byte/pixel case and 2 for
			  the 6 byte/pixel case
	xstep		: number of pixels to cross when making a single step
			  in x.  Will be 1 for all cases
	active_window	: global structure
		zbuf, 
		cbug	: Address of the z/image buffer. Used to make sure that
			  by adding weight, we don't write outside of the
			  allocated memory.
		
HISTORY
	??/??/??	M. Lanier
		Created
		
*/
 
static void HPadd_hidden_weight_east_west (struct edge_info *edge, int color)

	{
	int		i;
	HScbuf		*cb1, *cb2;
	HSzbuf		*zb1, *zb2, z;

#	if BYTES_PER_PIXEL == 5
		HSzbuf	mark;
#	else
		HScbuf	mark;
#	endif

	cb1 = cb2 = edge->cb;
	zb1 = zb2 = edge->zb;

#	if BYTES_PER_PIXEL == 5
		z = *edge->zb & ZMASK;
		mark = *edge->zb & MARK_MASK;
#	else
		z = *edge->zb;
		mark = edge->cb[1];
#	endif
		
	/*
	 *  add ACTIVE_WIDTH pixels of weight
	 */
	 
	i = HWIDTH;
	while( --i )
		{
		cb1 += (xstep2);
		zb1 += (xstep);
		
		/*
		 *  Change the pixel only if the owner is a trapezoid
		 */

#		if BYTES_PER_PIXEL == 5
			if( (*zb1 & MARK_MASK) == 0 )
				{
				if( !(zb1 < active_window->zbuf || 
				      zb1 > (HSzbuf *)active_window->cbuf) )
					{
					*cb1 = (color);
					*zb1 = z | mark;
					}
				}
#		else
			if( cb1[1] == 0 )
				{
				if( !(zb1 < active_window->zbuf || 
				      zb1 > (HSzbuf *)active_window->cbuf) )
					{
					*cb1 = (color);
					cb1[1] = mark;
					*zb1 = z;
					}
				}
#		endif

		/*
		 *  just in case the width is odd
		 */
		 
		if( !(--i) ) break;

		cb2 -= (xstep2);
		zb2 -= (xstep);
		
		/*
		 *  change the pixel only if the owner is a trapezoid
		 */

#		if BYTES_PER_PIXEL == 5
			if( (*zb2 & MARK_MASK) == 0 )
				{
				if( !(zb2 < active_window->zbuf || 
				      zb2 > (HSzbuf *)active_window->cbuf) )
					{
					*cb2 = (color);
					*zb2 = z | mark;
					}
				}
#		else
			if( cb2[1] == 0 )
				{
				if( !(zb2 < active_window->zbuf || 
				      zb2 > (HSzbuf *)active_window->cbuf) )
					{
					*cb2 = (color);
					cb2[1] = mark;
					*zb2 = z;
					}
				}
#		endif
		}
	}
	
/*---HPadd_hidden_weight_north_south-------------------------------------------------------*/

/*
NAME
	HPadd_hidden_weight_north_south:  Static
	
KEYWORDS	
	HSplot
	rasterizer
	RHL
	visible edge
	weight
	static
	
DESCRIPTION
	Add weight to the edge in the +/- y direction.  In this case, we are
	adding weight to an edge that is hidden, therefore we have to make
	sure that the pixel we might mark for this edge is not already owned
	by an edge that was visible.

PARAMETERS
	edge	:(IN) :  structure containing information about the edges
	color	:(IN) :  Active color inwhich to draw the edge
	
GLOBALS USED
	HWIDTH		: hidden width, in pixels of the edges
	xstep2		: number of pixels to cross when making a single step
			  in x.  Will be 1 for 5 byte/pixel case and 2 for
			  the 6 byte/pixel case
	xstep		: number of pixels to cross when making a single step
			  in x.  Will be 1 for all cases
	active_window	: global structure
		zbuf, 
		cbug	: Address of the z/image buffer. Used to make sure that
			  by adding weight, we don't write outside of the
			  allocated memory.
		
HISTORY
	??/??/??	M. Lanier
		Created
		
*/
 
static void HPadd_hidden_weight_north_south (struct edge_info *edge, int color)

	{
	int		i;
	HScbuf		*cb1, *cb2;
	HSzbuf		*zb1, *zb2, z;
	
#	if BYTES_PER_PIXEL == 5
		HSzbuf	mark;
#	else
		HScbuf	mark;
#	endif

	cb1 = cb2 = edge->cb;
	zb1 = zb2 = edge->zb;

#	if BYTES_PER_PIXEL == 5
		z = *edge->zb & ZMASK;
		mark = *edge->zb & MARK_MASK;
#	else
		z = *edge->zb;
		mark = edge->cb[1];
#	endif

	/*
	 *  add ACTIVE_WIDTH pixels of weight
	 */
	 
	i = HWIDTH;
	while( --i )
		{
		cb1 += (ystep2);
		zb1 += (ystep);
		
		/*
		 *  Change the pixel only if the owner is a trapezoid
		 */

#		if BYTES_PER_PIXEL == 5
			if( (*zb1 & MARK_MASK) == 0 )
				{
				if( !(zb1 < active_window->zbuf || 
				      zb1 > (HSzbuf *)active_window->cbuf) )
					{
					*cb1 = (color);
					*zb1 = z | mark;
					}
				}
#		else
			if( cb1[1] == 0 )
				{
				if( !(zb1 < active_window->zbuf || 
				      zb1 > (HSzbuf *)active_window->cbuf) )
					{
					*cb1 = (color);
					cb1[1] = mark;
					*zb1 = z;
					}
				}
#		endif

		/*
		 *  just in case the width is odd
		 */
		 
		if( !(--i) ) break;

		cb2 -= (ystep2);
		zb2 -= (ystep);
		
		/*
		 *  Change the pixel only if the owner is a trapezoid
		 */
		 
#		if BYTES_PER_PIXEL == 5
			if( (*zb2 & MARK_MASK) == 0 )
				{
				if( !(zb2 < active_window->zbuf || 
				      zb2 > (HSzbuf *)active_window->cbuf) )
					{
					*cb2 = (color);
					*zb2 = z | mark;
					}
				}
#		else
			if( cb2[1] == 0 )
				{
				if( !(zb2 < active_window->zbuf || 
				      zb2 > (HSzbuf *)active_window->cbuf) )
					{
					*cb2 = (color);
					cb2[1] = mark;
					*zb2 = z;
					}
				}
#		endif
		}
	}
	
/*---HPadd_weight--------------------------------------------------------------*/

/*
NAME
	HPadd_weight: static
	
KEYWORDS
	HSplot
	weight
	static
	RHL
	rasterizer
	
DESCRIPTION
	Stub called when adding weight to an edge is not needed.
	
PARAMETERS
	edge:   These are here just to satisfy the 
	color:  argument list of the function variable.
	
HISTORY
	??/??/??	M. Lanier
		Created
*/

static void HPadd_weight (struct edge_info *edge, int color)

	{
	color = 0;
        edge = NULL;
	}
		
/*---HPset_weight_steps---------------------------------------------------*/

/*
NAME
	HPset_weight_steps: static

KEYWORDS
	HSplot
	rasterizer
	static
	RHL
	weight
	question coding
		
DESCRIPTION
	This function sets the function pointers that will add weight
	to hidden and visible edges.
	
PARMETERS
	edge	:(IN) :  Information about the edge.  This is needed here
			 so to determine if the weight should be added
			 in the north/south or east/west direction

GLOBALS USED
	add_visible_weight	:  function pointer for adding weight to visible edges
	add_hidden_weight	:  function pointer for adding weight to hidden edges
	HWIDTH, VWIDTH		:  Hidden/Visible line width in pixels
	
NOTES
	QUESTION:  Remove the weight argument??
	
HISTORY
	??/??/??	M. Lanier
		Created
*/
 
static int HPset_weight_steps (struct edge_info *edge)

	{
	int	step;
	int	dxy;
	static int	active_width = 0;
	
	dxy = edge->dxy < 0 ? -edge->dxy : edge->dxy;
	if( dxy == 0 )
		{
		if( edge->x1 == edge->xn )
			{
			wns = 0;
			add_visible_weight = HPadd_visible_weight_east_west;
			add_hidden_weight = HPadd_hidden_weight_east_west;
			}
		else
			{
			wns = 1;
			add_visible_weight = HPadd_visible_weight_north_south;
			add_hidden_weight = HPadd_hidden_weight_north_south;
			}
		}
	else
		{
		if( dxy < 65535 )
			{
			wns = 0;
			step = (int)((65535.0 / ((double)dxy))+0.5);
			add_visible_weight = step <= active_width ? HPadd_weight : HPadd_visible_weight_east_west;
			add_hidden_weight = step <= active_width ? HPadd_weight : HPadd_hidden_weight_east_west;
			}
		else
			{
			wns = 1;
			step = (int)((((double)dxy) / 65535.0)+0.5);
			add_visible_weight = step <= active_width ? HPadd_weight : HPadd_visible_weight_north_south;
			add_hidden_weight = step <= active_width ? HPadd_weight : HPadd_hidden_weight_north_south;
			}
		}

	if( HWIDTH <= 1 )
		add_hidden_weight = HPadd_weight;
		
	if( VWIDTH <= 1 )
		add_visible_weight = HPadd_weight;
	return(0);
	}

#if BYTES_PER_PIXEL == 5
/*---NEIGHBOR_VIS-----------------------------------------------------*/

/*
NAME
	NEIGHBOR_VIS: Macro
	
KEYWORDS
	HSplot
	neighbor
	RHL
	marks
	
DESCRIPTION
	Returns true if the current pixel is visible due to the nearest
	neighbor test.  This is for the 5 byte/pixel case

GLOBALS USED
	xstep, xstep2	:  Number of pixels to offset when making a single step
			   in the x direction.
	ystep, ystep2	:  Number of pixels to offset when making a single step
			   in the y direction

ALGORITHM
	Nearest Neighbor Test:   This test says, if the current pixels z is
	in front of one of its eight neighbors, and that neighbor is not an
	edge pixel, then the current pixels is visible.
				   
HISTORY
	??/??/??	M. Lanier
		Created
*/

#define	NEIGHBOR_VIS( z, zb, cb )							  \
											  \
(											  \
( (*(zb+xstep) & ZMASK) >= z       && (*(zb+xstep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb-xstep) & ZMASK) >= z       && (*(zb-xstep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb+ystep) & ZMASK) >= z       && (*(zb+ystep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb-ystep) & ZMASK) >= z       && (*(zb-ystep2) & MARK_MASK) != EDGE_MASK ) ||	  \
( (*(zb+ystep+xstep) & ZMASK) >= z && (*(zb+ystep2+xstep2) & MARK_MASK) != EDGE_MASK ) || \
( (*(zb+ystep-xstep) & ZMASK) >= z && (*(zb+ystep2-xstep2) & MARK_MASK) != EDGE_MASK ) || \
( (*(zb-ystep+xstep) & ZMASK) >= z && (*(zb-ystep2+xstep2) & MARK_MASK) != EDGE_MASK ) || \
( (*(zb-ystep-xstep) & ZMASK) >= z && (*(zb-ystep2-xstep2) & MARK_MASK) != EDGE_MASK )    \
)

/*---DUMP_NEIGHBOR--------------------------------------------------------*/

/*
NAME
	DUMP_NEIGHBOR: Macro
	
KEYWORDS
	HSplot
	neighbor
	RHL
	marks
	debug
	
DESCRIPTION
	Display information about the current pixel and its neighbors.  This
	is for the 5 byte/pixel case

GLOBALS USED
	xstep, xstep2	:  Number of pixels to offset when making a single step
			   in the x direction.
	ystep, ystep2	:  Number of pixels to offset when making a single step
			   in the y direction
			   
HISTORY
	??/??/??	M. Lanier
		Created
*/

#define	DUMP_NEIGHBOR( zb, cb )								\
											\
{											\
fprintf( stderr, "\n" );								\
fprintf( stderr, "east ------ %x %x\n", *(zb+xstep) & ZMASK, *(zb+xstep2) & MARK_MASK );	\
fprintf( stderr, "west ------ %x %x\n", *(zb-xstep) & ZMASK, *(zb-xstep2) & MARK_MASK );	\
fprintf( stderr, "north ----- %x %x\n", *(zb+ystep) & ZMASK, *(zb+ystep2) & MARK_MASK );	\
fprintf( stderr, "south ----- %x %x\n", *(zb-ystep) & ZMASK, *(zb-ystep2) & MARK_MASK );	\
fprintf( stderr, "northeast - %x %x\n", *(zb+ystep+xstep) & ZMASK, *(zb+ystep2+xstep2) & MARK_MASK );	\
fprintf( stderr, "northwest - %x %x\n", *(zb+ystep-xstep) & ZMASK, *(zb+ystep2-xstep2) & MARK_MASK );	\
fprintf( stderr, "southeast - %x %x\n", *(zb-ystep+xstep) & ZMASK, *(zb-ystep2+xstep2) & MARK_MASK );	\
fprintf( stderr, "southwest - %x %x\n", *(zb-ystep-xstep) & ZMASK, *(zb-ystep2-xstep2) & MARK_MASK );	\
}
#else
/*---NEIGHBOR_VIS-----------------------------------------------------*/

/*
NAME
	NEIGHBOR_VIS: Macro
	
KEYWORDS
	HSplot
	neighbor
	RHL
	marks
	
DESCRIPTION
	Returns true if the current pixel is visible due to the nearest
	neighbor test.  This is for the 6 byte/pixel case

GLOBALS USED
	xstep, xstep2	:  Number of pixels to offset when making a single step
			   in the x direction.
	ystep, ystep2	:  Number of pixels to offset when making a single step
			   in the y direction

ALGORITHM
	Nearest Neighbor Test:   This test says, if the current pixels z is
	in front of one of its eight neighbors, and that neighbor is not an
	edge pixel, then the current pixels is visible.
				   
HISTORY
	??/??/??	M. Lanier
		Created
*/

#define	NEIGHBOR_VIS( z, zb, cb )				\
								\
(								\
( *(zb+xstep) >= z       && ((cb+xstep2)[1] != 3) ) ||		\
( *(zb-xstep) >= z       && ((cb-xstep2)[1] != 3) ) ||		\
( *(zb+ystep) >= z       && ((cb+ystep2)[1] != 3) ) ||		\
( *(zb-ystep) >= z       && ((cb-ystep2)[1] != 3) ) ||		\
( *(zb+ystep+xstep) >= z && ((cb+ystep2+xstep2)[1] != 3) ) ||	\
( *(zb+ystep-xstep) >= z && ((cb+ystep2-xstep2)[1] != 3) ) ||	\
( *(zb-ystep+xstep) >= z && ((cb-ystep2+xstep2)[1] != 3) ) ||	\
( *(zb-ystep-xstep) >= z && ((cb-ystep2-xstep2)[1] != 3) ) 	\
)

/*---DUMP_NEIGHBOR--------------------------------------------------------*/

/*
NAME
	DUMP_NEIGHBOR: Macro
	
KEYWORDS
	HSplot
	neighbor
	RHL
	marks
	debug
	
DESCRIPTION
	Display information about the current pixel and its neighbors.  This
	is for the 6 byte/pixel case

GLOBALS USED
	xstep, xstep2	:  Number of pixels to offset when making a single step
			   in the x direction.
	ystep, ystep2	:  Number of pixels to offset when making a single step
			   in the y direction
			   
HISTORY
	??/??/??	M. Lanier
		Created
*/

#define	DUMP_NEIGHBOR( zb, cb )							\
										\
{										\
fprintf( stderr, "\n" );							\
fprintf( stderr, "east ------ %x %x\n", *(zb+xstep), (cb+xstep2)[1] );	\
fprintf( stderr, "west ------ %x %x\n", *(zb-xstep), (cb-xstep2)[1] );	\
fprintf( stderr, "north ----- %x %x\n", *(zb+ystep), (cb+ystep2)[1] );	\
fprintf( stderr, "south ----- %x %x\n", *(zb-ystep), (cb-ystep2)[1] );	\
fprintf( stderr, "northeast - %x %x\n", *(zb+ystep+xstep), (cb+ystep2+xstep2)[1] );	\
fprintf( stderr, "northwest - %x %x\n", *(zb+ystep-xstep), (cb+ystep2-xstep2)[1] );	\
fprintf( stderr, "southeast - %x %x\n", *(zb-ystep+xstep), (cb-ystep2+xstep2)[1] );	\
fprintf( stderr, "southwest - %x %x\n", *(zb-ystep-xstep), (cb-ystep2-xstep2)[1] );	\
}
#endif

/*---HSset_style---------------------------------------------------------*/

/*
NAME
	HSset_style: Local macro

KEYWORD
	HSplot
	style
	RHL
	visible edge
	hidden edge
	
DESCRIPTION
	Move the hidden/visible line style marks to the next pixel
	
PARAMETERS USED
	x, y	:(IN) :  coordinates of the current pixel.
	
GLOBALS USED
	vstyle_length,		:  Amount of distanced covered for the
	hstyle_length		:  current visible/hidden style run.
	pixel_size_diag		:  Length of a move in the diagonal
				   direction
	pixel_size_hovt		:  Length of a move in either the
				   horizonal or vertical direction
	vstyle_index,		:  Index into the visible/hidden style
	hstyle_index		:  buffers
	element_parms		:  global structure
		h_pattern	:  Hidden style pattern buffer
		v_pattern	:  Visible style pattern buffer
ALGORITHM
	A shading style is stored as a collection of runs, whose
	length is specified in meters.  The run's state alternate
	between on and off (or off and on, depending on the 
	initial state).  A style run will remain active until
	the style_length accumulates enough length to exceed the
	length of the run.  Once the end of the array of style
	run's has been reached, all is reset back to the beginning.
	
HISTORY
	??/??/??	M. Lanier
		Created
*/

#define	HSset_style( x, y )						\
									\
	{								\
	if( xold != ROUND16(x) && yold != (y) )				\
		{							\
		vstyle_length += pixel_size_diag;			\
		hstyle_length += pixel_size_diag;			\
		}							\
	else								\
		{							\
		vstyle_length += pixel_size_hovt;			\
		hstyle_length += pixel_size_hovt;			\
		}							\
									\
	if( vstyle_length >= element_parms.v_pattern[vstyle_index] )			\
		{							\
		vstyle_length -= element_parms.v_pattern[vstyle_index++];		\
		if( element_parms.v_pattern[vstyle_index] == 0.0 ) vstyle_index = 0;	\
		}							\
									\
	if( hstyle_length >= element_parms.h_pattern[hstyle_index] )			\
		{							\
		hstyle_length -= element_parms.h_pattern[hstyle_index++];			\
		if( element_parms.h_pattern[hstyle_index] == 0.0 ) hstyle_index = 0;	\
		}							\
									\
	xold = ROUND16(x);						\
	yold = (y);							\
	}

/*---HSedge_vis----------------------------------------------------------*/

/*
NAME
	HSedge_vis: static
	
KEYWORDS
	HSplot
	edge
	RHL
	static
	rasterizer
	
DESCRIPTION
	Perform visibility test on the edge segment for the current
	pixel
	
PARAMETERS
	edge	:(IN) :  Information about the edge
	
GLOBALS USED
	vstyle_index,	: Index into the visible/hidden style buffer.  Used
	hstyle_index	: to determine if the edge should be displayed on or off.
	element_parms	: global structure
		v_pat_on_off,	:  mark that tells if the first run in visible/hidden
		h_pat_on_off	:  pattern buffer if on or off.
	VCOLOR_ON,		:  Visible/Hidden color for the edge in the on state.
	HCOLOR_ON		:
	
ALGORITHM
	Perform the visiblity test of the current state of the edge at the
	current pixel against the stored state of the current pixels.  If this
	fails, perform the nearest neighbor test for the current state of the
	edges.  If the pixel is found to be visible, mark the pixel in the 
	vislble/on color according to the visible pattern.  If the pixel is found
	to be hidden, mark the pixel in the hidden/on color according to the
	hidden pattern.
	
FUNCTIONS CALLED
	NEIGHBOR_VIS
	DUMP_NEIGHBOR
	add_visible_weight	:  function pointer
	add_hidden_weight	:  function pointer
	
HISTORY
	??/??/??	M. Lanier
		Created
*/

static HSedge_vis (struct edge_info *edge)

	{
#	if BYTES_PER_PIXEL == 5
		HSzbuf		badz;
#	else
		HScbuf		badz;
#	endif

#	if DEBUG_REGION
	if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
	  fprintf( stderr, "HSedge_vis(%1d:%1d): x1, y1, z1, cb -- %3d %3d %x %x %x %x --", 
			c2, c3, ROUND16(edge->x1), edge->y1, edge->z1, 
			*edge->zb & ZMASK, edge->zb, *edge->zb & MARK_MASK );
#	endif
	
	if( (*edge->zb & ZMASK) >= edge->z1 )
		{
			
		/*
		 *  Outright winner.  mark the edge in visible color, mark the edge EDGE_EDGE 
		 *  (owned by an edge).  OR because the bad_z  bit might be set. Once you set 
		 *  that you can never clear it.  Reasoning:  Say we are looking  at object A 
		 *  now, and object B is  in the buffer,  and is the  cause of  the bad_z bit 
		 *  getting set.   When object B was  processed object C was really closer to 
		 *  the viewer but object B replaced object C because of the nearest neighbor 
		 *  test, causing the  bad_z bit to get set.   Now, we have no way of knowing 
		 *  if object A hides object C or not so the bad_z bit must remain set.
		 */

#		if DEBUG_REGION
		if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
			fprintf( stderr, "outright winner\n" );
#		endif

#		if BYTES_PER_PIXEL == 5
			badz = *edge->zb & BAD_Z;
			*edge->zb = edge->z1 | EDGE_EDGE | badz;
#		else
			*edge->zb = edge->z1;
			badz = *edge->cb & BAD_Z;
			edge->cb[1] |= EDGE_EDGE | badz;
#		endif
		
		if( (vstyle_index & 1) != element_parms.v_pat_on_off )
			{
			*edge->cb = VCOLOR_ON;
		
			(*add_visible_weight)( edge, VCOLOR_ON );
			}
		}
	else
		{
			
		/*
		 *  Was not the outright winner.  If the pixel is not owned by an EDGE, then 
		 *  perform the nearest neighbor test.
		 */

#		if BYTES_PER_PIXEL == 5
		if( !(*edge->zb & EDGE_MASK) )
#		else
		if( !(edge->cb[1] & EDGE_MASK) )
#		endif
			{
#			if DEBUG_REGION
			if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
				DUMP_NEIGHBOR( edge->zb, edge->cb )
#			endif

			if( NEIGHBOR_VIS( edge->z1, edge->zb, edge->cb ) )
				{
					
				/*
				 *  Winner because of nearest neighbor test.  Replace the z (ever if it is
				 *  closer), set the EDGE owner and bad_z bits, save active color, add weight
				 */

#				if DEBUG_REGION
				if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
					fprintf( stderr, "winner by nearest neighbor\n" );
#				endif


#				if BYTES_PER_PIXEL == 5
					*edge->zb = edge->z1 | EDGE_EDGE | BAD_Z;
#				else
					*edge->zb = edge->z1;
					edge->cb[1] |= EDGE_EDGE | BAD_Z;
#				endif
				
				if( (vstyle_index & 1) != element_parms.v_pat_on_off )
					{
					*edge->cb = VCOLOR_ON;
				
					(*add_visible_weight)( edge, VCOLOR_ON );
					}
				}
			else
				{
					
				/*
				 *  Loser.  display the edge with style.  If the style index is odd then display
				 *  the "off color" which normally will be the background color.  If the style index
				 *  is even then display the "on color", which normally will be the active color.
				 *  In either case, dont change the mark or z.  Add weight
				 */
				 
#				if DEBUG_REGION
				if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
					fprintf( stderr, "lost nearest neighbor\n" );
#				endif

				if( tiling_parms.processing_mode & HS_PMODE_DISPLAY_HIDDEN_LINES )
				if( (hstyle_index & 1) != element_parms.h_pat_on_off )
					{
					*edge->cb = HCOLOR_ON;
					
					(*add_hidden_weight)( edge, HCOLOR_ON );
					}
				}
			}
		else
			{
				
			/*
			 *  this is a special case.  We could not set the centerline pixel
			 *  because it was owned by an edge, but this does not mean that the
			 *  weight pixels are also owned by and edge, so we have to add weight
			 *  so as to not get any gaps.
			 */
			 
#			if DEBUG_REGION
			if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
				fprintf( stderr, "lost\n" );
#			endif

			if( tiling_parms.processing_mode & HS_PMODE_DISPLAY_HIDDEN_LINES )
			if( (hstyle_index & 1) != element_parms.h_pat_on_off )
				{
				(*add_hidden_weight)( edge, HCOLOR_ON );
				}
			}
		}
	}


/*---HPtrap_vis--------------------------------------------------------*/

/*
NAME
	HPtrap_vis: static
	
KEYWORDS
	HSplot
	rasterizer
	RHL
	trapezoid
	static
	
DESCRIPTION
	Perform the visiblity test for pixel on the edge of the trapezoid
	
PARAMETERS
	edge	:(IN) :  Contains information about either the left
			 or right edge of the trapezoid
			 
GLOBALS USED
	HCOLOR_OFF:  Color index to initialize the image buffer to.
	
HISTORY
	??/??/??	M. Lanier
		Created	
*/
 
static HPtrap_vis (struct edge_info *edge)

	{
#	if DEBUG_REGION
	if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
		fprintf( stderr, "HStrap_vis(%1d): x1, y1, z1 -- %3d %3d %x %x %x\n", 
			c1, ROUND16(edge->x1), edge->y1, edge->z1, *edge->zb & ZMASK, edge->zb );
#	endif	
 
#	if BYTES_PER_PIXEL == 5	
		if( (*edge->zb & ZMASK) >= edge->z1 )
			{
			*edge->zb = edge->z1 | TRAP_EDGE;
			*edge->cb = HCOLOR_OFF;
			}
#	else
		if( *edge->zb >= edge->z1 )
			{
			*edge->zb = edge->z1;
			*edge->cb = HCOLOR_OFF;
			edge->cb[1] = TRAP_EDGE;
			}
#	endif
	
#	if DEBUG_REGION
	if( IN_REGION( ROUND16(edge->x1), edge->y1 ) )
		fprintf( stderr, "HStrap_vis(%1d): x1, y1, z1 -- %3d %3d %x %x\n", 
			c1, ROUND16(edge->x1), edge->y1, edge->z1, *edge->zb & ZMASK );
#	endif	
	}

/*---HPfill_trap-------------------------------------------------------*/

/*
NAME
	HPfill_trap: static
	
KEYWORDS
	HSplot
	RHL
	trapezoid
	rasterizer
	static
	
DESCRIPTION
	Using the state of the interior pixels of the two edges of
	the trapezoid, fill the pixels on the scanline between the two
	edges using linear interpolation
	
PARAMETERS
	left_edge,	:(IN) :  Information about the left and right
	right_edge	:(IN) :  edges of the trapezoid
	
GLOBALS USED
	active_window	: global structure
		cbuf,	: Address of the z/image buffer.  Used to make
		zbuf	: sure we don't write outside the allocated memory
	HCOLOR_OFF	: Color to mark the interior of the trapezoid with
	
HISTORY
	??/??/??	M. Lanier
		Created
*/

static HPfill_trap (struct edge_info *left_edge, 
		    struct edge_info *right_edge)

	{
	int			dx;
	struct HSfixedpt	z;
	int			xleft, xright;
	HSzbuf			*zb;
	HScbuf			*cb;

	/*
	 *  Get the x values at the sides of the trap
	 */

	xleft  = ROUND16(left_edge->x1);
	xright = ROUND16(right_edge->x1);
	
	/*
	 *  get a dz/dx
	 */

	if( (dx = xright - xleft) == 0 )
		{
		z.sign = 1;
		z.d_whole = 0;
		z.d_fract = 0;
		z.running = 0;
		}
	else
		{
		fixed_divide(	(right_edge->z1 - left_edge->z1),
				 dx,
				 &z.sign,
				 &z.d_whole,
				 &z.d_fract);

		z.running = 0x40000000;
		}

	z.active = left_edge->z1;

	/*
	 *  Skip past the first pixel, processing the edges set
	 *  that one
	 */

	zb = left_edge->zb;
	zb++;
	cb = left_edge->cb;

#	if BYTES_PER_PIXEL == 5
		cb++;
#	else
		cb += 2;
#	endif

	xleft++;
	Fixed_add( z );

	/*
	 *  Fill the trap scanline
	 */

	while( xleft < xright )
		{
#		if DEBUG_REGION
		if( IN_REGION( xleft, left_edge->y1 ) )
			fprintf( stderr, "HSfill_vis(%1d): x1, y1, z1 -- %3d %3d %x %x\n", 
				c1, xleft, left_edge->y1, z.active, *zb & ZMASK );
#		endif	
	
#		if BYTES_PER_PIXEL == 5
			if( (*zb & ZMASK) >= z.active )
				{
				if( !(zb < active_window->zbuf || 
				      zb > (HSzbuf *)active_window->cbuf) )
					{
					*zb = z.active;
					*cb = HCOLOR_OFF;
#		if DEBUG_REGION
		if( IN_REGION( xleft, left_edge->y1 ) )
			*cb = (HCOLOR_OFF + 1);
#		endif	
					}
				}
#		else
			if( *zb >= z.active )
				{
				if( !(zb < active_window->zbuf || 
				      zb > (HSzbuf *)active_window->cbuf) )
					{
					*zb = z.active;
					*cb = HCOLOR_OFF;
					cb[1] = 0;
					}
				}
#		endif

		zb++;

#		if BYTES_PER_PIXEL == 5
			cb++;
#		else
			cb += 2;
#		endif

		xleft++;
		Fixed_add( z );
		}
	}
	
/*---HPone_step----------------------------------------------------------*/

/*
NAME
	HPone_step: static
	
KEYWORDS
	HSplot
	rasterizer
	edge
	
DESCRIPTION
	Updates the edge information for a single step along the edge.
	
PARAMETERS
	edge	:(IN) :  Information about the edge
	
GLOBALS USED
	-none-
	
FUNCTIONS CALLED
	Fixed_add
	Fixed_divide
	
HISTORY
	??/??/??	M. Lanier
		Created
*/
 
static int HPone_step (struct edge_info *edge)

	{
	int	dx, dy;
	int	adx;
	int	status;
	
	status = 0;

	/*
	 *  compute the next values for x and y (at least one will change)
	 */
	 
	if( ROUND16(edge->x1) == ROUND16(edge->xn) &&
	    edge->y1 == edge->yn ) 
		return( status=EDGE_END );
	
	dx = edge->xn - edge->x1;

	if( (edge->xdir > 0 && dx < edge->xdir) ||
	    (edge->xdir < 0 && dx > edge->xdir) )
		edge->xdir = dx;

	edge->x1 += edge->xdir;
	edge->zb += edge->zb_xdir;
	edge->cb += edge->cb_xdir;

	if( edge->xjump == 1 )
		{
		status |= ABOUT_TO_JUMP;
		}
	else
		{
		if( edge->xjump == 0 )
			{
			status |= JUST_JUMPED;
			
			/*
			 *  the edge dy will equal the height of the trapezoid.  Each time
			 *  we step down, decrement by one.  This will allow the calling loop
			 *  to know when to stop (if all other test fail)
			 */
			 
			edge->dy--;
			edge->y1 += edge->ydir;
			edge->zb += edge->zb_ydir;
			edge->cb += edge->cb_ydir;
			}
		}
		
	edge->xjump--;

	Fixed_add( edge->fz1 );
	edge->z1 = edge->fz1.active;

	
	if( (ROUND16(edge->x1) == ROUND16(edge->x2)) && 
	    ((edge->y1) == (edge->y2)) )
		{
		status |= RESET;

		edge->x1 = edge->x2;
		edge->y1 = edge->y2;
		edge->z1 = edge->z2;

		edge->x2 = edge->x1 + edge->dxy;
		edge->y2 = edge->y1 + edge->ydir;

		Fixed_add( edge->fz2 );
		edge->z2 = edge->fz2.active;

		dx = ROUND16(edge->x2) - ROUND16(edge->x1);
		dy = (edge->y2) - (edge->y1);

		if( dy == 0 )
			{
			edge->ydir = 0;
			edge->zb_ydir = 0;
			edge->cb_ydir = 0;
			}
		else
			{
			if( dy < 0 )
				{
				edge->ydir = -1;
				edge->zb_ydir = -ystep;
				edge->cb_ydir = -ystep2;
				}
			else
				{
				edge->ydir = 1;
				edge->zb_ydir = ystep;
				edge->cb_ydir = ystep2;
				}
			}

		if( dx == 0 )
			{
			adx = dx;
			
			edge->xdir = 0;
			edge->zb_xdir =0;
			edge->cb_xdir = 0;
			
			edge->fz1.sign = 1;
			edge->fz1.d_whole = 0;
			edge->fz1.d_fract = 0;
			edge->fz1.running = 0;
			}
		else
			{
			if( dx < 0 )
				{
				adx = -dx;
				edge->xdir = -ONE16;
				edge->zb_xdir = -xstep;
				edge->cb_xdir = -xstep2;
				}
			else
				{
				adx = dx;
				edge->xdir = ONE16;
				edge->zb_xdir = xstep;
				edge->cb_xdir = xstep2;
				}
				
			fixed_divide(	(edge->z2 - edge->z1),
					 adx,
					 &edge->fz1.sign,
					 &edge->fz1.d_whole,
					 &edge->fz1.d_fract);

			edge->fz1.running = 0x40000000;
			}
			
		edge->fz1.active = edge->z1;
		edge->xjump = adx >> 1;

		if( edge->xjump == 0 )
			{
			status |= ABOUT_TO_JUMP;
			}
		
		if( edge->side == LEFT_SIDE )
			edge->stop_mask = dx <=  1 ? JUST_JUMPED : ABOUT_TO_JUMP;
		else
			edge->stop_mask = dx >= -1 ? JUST_JUMPED : ABOUT_TO_JUMP;
		}

	return( status );
	}
	
/*---HPset_display_colors-------------------------------------------------*/

/*
NAME
	HPset_display_color: static
	
KEYWORDS
	HSplot
	hidden color
	visible color
	RHL
	static

DESCRIPTION
	Set the Hidden/Visible On/Off color, according to the shading style.
	
GLOBALS USED
	VCOLOR_ON,		:  The active color index for the visible
	VCOLOR_OFF,		:  hidden color in the on and off states
	HCOLOR_ON,		:
	HCOLOR_OFF		:
	element_parms		:  global information
		color		:  visible color for the edge
		hidden_color	:  Hidden color for the edge
	tiling_parms		:  global information
		processing_mode	:  To tell if this is an edge or polyline, it makes
				   a difference
	active_window		:  global information
		shading_style	:  What is the active shading style RHL, FRHL...
		
HISTORY
	??/??/??	M. Lanier
		Created
*/

static void HPset_display_colors (void)

	{
	if( active_window->shading_style == HS_STYLE_RASTER )
		{
		VCOLOR_ON  = element_parms.color;
		VCOLOR_OFF = 0;
		HCOLOR_ON  = element_parms.hidden_color;
		HCOLOR_OFF = 0;
		}
	else
		{
		if( tiling_parms.processing_mode & HS_PMODE_EDGE_OBJECT )
			{
			VCOLOR_ON  = 240;
			VCOLOR_OFF = element_parms.color;
			}
		else
			{
			VCOLOR_ON  = element_parms.color;
			VCOLOR_OFF = 0;
			}
			
		HCOLOR_ON  = 240;
		HCOLOR_OFF = element_parms.color;
		}
	}

/*---HPstart_pline_radge5/6--------------------------------------------------*/

/*
NAME
	HPstart_pline_radge5
	HPstart_pline_radge6
	
KEYWORDS
	HSplot
	edge
	rasterizer
	
DESCRIPTION
	Given the starting point of the polyline/edge, save until the
	next vertex arrives.  This supports both 5 and 6 bytes/pixel
	modes
	
PARAMETERS
	start_point	:(IN) :  Coordinates of the first vertex of the polyline
	
GLOBALS USED
	pixel_size_diag,		:  Length in meters of a single step in 
	pixel_size_hovt			:  the diagonal, or horizonal/vertical
					:  directions
	HLglobal			:  global information
		resolution		:  Pixel resolution of the output device
		replication_factor	:  Replication factor at which the raster
					   data is being produced
	xdits, xdits2			:  Number of pixels to offset for a single
					   step in the x direction, xdits is always
					   the width of the viewport where xdits2
					   is either the width or twice the width
					   depending on the number of bytes/pixel
	VWIDTH, HWIDTH			:  Visible/Hidden line width in pixels
	element_parms			:  global information
		visible_weight,		:  The active visible/hidden weight
		hidden_weight		:  of the edge/polyline
	current_vertex			:  where the first or previous vertex is stored
	HPband_info			:  global information
		org_y			:  Used to translate the edge to the band viewport
		
HISTORY
	??/??/??	M. Lanier
		Created
*/

#if BYTES_PER_PIXEL == 5
	void HPstart_pline_radge5 (struct polyline_vertex *start_point)
#else
	void HPstart_pline_radge6 (struct polyline_vertex *start_point)
#endif

	{

	if( c2++ == 0 )
		{
		xdits = active_window->x_dits;
		xdits2 = xdits << 1;

		pixel_size_diag *= ((100.0/HPglobal.resolution));
		pixel_size_hovt *= ((100.0/HPglobal.resolution));

		}
	
	HPset_display_colors();

	VWIDTH = (int)(element_parms.visible_weight / HPglobal.replication_factor);
	HWIDTH = (int)(element_parms.hidden_weight  / HPglobal.replication_factor);
	if( HWIDTH < 1 ) HWIDTH = 1;
	
	vstyle_index = 0;
	vstyle_length = 0.0;
	hstyle_index = 0;
	hstyle_length = 0.0;

	current_vertex = *start_point;	
	
	/*
	 *  Translate point to the zbuffer origin
	 */
	 
	current_vertex.y -= HPband_info.org_y;
	}

/*---CLIP----------------------------------------------------------------------*/

/*
NAME
	CLIP: static
	
KEYWORDS
	HSplot
	RHL
	rasterizer
	clip
	static
	
DESCRIPTION
	Given the coordinates of the start/end vertices of the polyline/edge
	segment, and the y of the viewport edge, compute the x and z at the
	viewport edge.  Store the results back in xa, ya, za;
	
PARAMETERS
	xa, ya, za	:(IN/OUT) :  The coordinates of the start vertice of the
				     polyline/edge segment
	xb, yb, zb	:(IN)     :  The coordinates of the end vertice of the
				     polyline/edge segment
	y		:(IN)     :  The y coordinate of the viewport edge.

HISTORY
	??/??/??	M. Lanier
		Created	
*/

static void CLIP (int *xa, 
		  int *ya, 
		  int *za, 
		  int *xb, 
		  int *yb, 
		  int *zb, 
		  int y)		  

	{
	double	fxa, fya, fza;
	double	fxb, fyb, fzb;
	double	fy;
	
	fxa = (double)(*xa);
	fya = (double)(*ya);
	fza = (double)(*za);
	
	fxb = (double)(*xb);
	fyb = (double)(*yb);
	fzb = (double)(*zb);
	
	fy = (double)(y);
	
	fxa = fxa + (fy - fya) * (fxb - fxa) / (fyb - fya);
	fza = fza + (fy - fya) * (fzb - fza) / (fyb - fya);
	
	*xa = (int)fxa;
	*ya = y;
	*za = (int)fza;
	}

/*---HPcontinue_pline_radge5/6--------------------------------------------------------------*/

/*
NAME
	HPcontinue_pline_radge5
	HPcontinue_pline_radge6
	
KEYWORDS
	HSplot
	rasterizer
	polyline
	RHL
	edge
	
DESCRIPTION
	Interpolate between the current and previous vertice of the polyline/edge
	segment for RHL processing
	
PARAMETERS
	next_vertex	:(IN) : The current vertex of the polyline/edge
	
GLOBALS USED
	HPband_info		:  global information
		org_y		:  Used to translate the edge/polyline segment to
				   the band viewport
		y_dits		:  Used in clipping the edge/polyline segment
	vdebug			:  set to 1 (???)
	current_vertex		:  coordinates of the previous vertex
	active_window		:  global information
		zbuf, cbuf	:  address of the z/image buffers
		x_dits		:  height of the viewport

FUNCTIONS CALLED
	Fixed_add
	fixed_divide
	ROUND16
	HPset_weight_steps
	HPedge_vis
	HPone_step
	HSset_style
	
HISTORY
	??/??/??	M. Lanier
		Created	
*/

#if BYTES_PER_PIXEL == 5
	void HPcontinue_pline_radge5 (struct polyline_vertex *next_vertex)
#else
	void HPcontinue_pline_radge6 (struct polyline_vertex *next_vertex)
#endif

	{
	struct edge_info	e;
	int			dy, dx, stat;
	int			adx, ady;


	/*
	 *  Translate point to the zbuffer origin
	 */
	 
	next_vertex->y -= HPband_info.org_y;
	
	vdebug = 1;
	c3++;		
#	if DEBUG_LINE
	if( !(DLINE) ) goto fini;
#	endif

#	if DEBUG_PLOG
	fprintf( stderr, "2 %1d %1d\n", c2, c3 );
	fprintf( stderr, "  %3d %3d %d\n", 
		ROUND16(current_vertex.x), current_vertex.y, current_vertex.z );
	fprintf( stderr, "  %3d %3d %d\n", 
		ROUND16(next_vertex->x), next_vertex->y, next_vertex->z );
#	endif

#	if DEBUG_P

#	if BYTES_PER_PIXEL == 5
	fprintf( stderr, "HPstart_pline_radge5 #%1d %1d\n", c2, c3 );
#	else
	fprintf( stderr, "HPstart_pline_radge6 #%1d %1d\n", c2, c3 );
#	endif

	fprintf( stderr, "   start_point --- %10.6lf %10.6lf %x\n", 
		(double)(current_vertex.x/65535.0), (double)(current_vertex.y), current_vertex.z );
	fprintf( stderr, "   next_vertex --- %10.6lf %10.6lf %x\n", 
		(double)(next_vertex->x/65535.0), (double)(next_vertex->y), next_vertex->z );
#	endif


	e.x1 = current_vertex.x;
	e.y1 = current_vertex.y;
	e.z1 = current_vertex.z;
	
	e.xn = next_vertex->x;
	e.yn = next_vertex->y;
	e.zn = next_vertex->z;

	if( e.y1 < 0 && e.yn < 0 ) goto fini;
	if( e.y1 > HPband_info.y_dits && e.yn > HPband_info.y_dits ) goto fini;
	
	if( e.y1 < 0 )			CLIP( &e.x1, &e.y1, &e.z1, &e.xn, &e.yn, &e.zn, 0 );
	if( e.y1 > HPband_info.y_dits ) CLIP( &e.x1, &e.y1, &e.z1, &e.xn, &e.yn, &e.zn, HPband_info.y_dits );
	if( e.yn < 0 )			CLIP( &e.xn, &e.yn, &e.zn, &e.x1, &e.y1, &e.z1, 0 );
	if( e.yn > HPband_info.y_dits ) CLIP( &e.xn, &e.yn, &e.zn, &e.x1, &e.y1, &e.z1, HPband_info.y_dits );
	
#	if DEBUG_P

#	if BYTES_PER_PIXEL == 5
	fprintf( stderr, "HPstart_pline_radge5 #%1d %1d\n", c2, c3 );
#	else
	fprintf( stderr, "HPstart_pline_radge6 #%1d %1d\n", c2, c3 );
#	endif

	fprintf( stderr, "   start_point --- %10.6lf %10.6lf %x\n", 
		(double)(current_vertex.x/65535.0), (double)(current_vertex.y), current_vertex.z );
	fprintf( stderr, "   next_vertex --- %10.6lf %10.6lf %x\n", 
		(double)(next_vertex->x/65535.0), (double)(next_vertex->y), next_vertex->z );
#	endif

	dx = ROUND16(e.xn) - ROUND16(e.x1);
	dy = (e.yn) - (e.y1);
	
	if( dy == 0 )
		{
		e.ydir = 0;		
		e.dxy = 0;
		
		e.x2 = e.xn;
		e.y2 = e.yn;
		e.z2 = e.zn;
		
		e.xjump = e.x2 - e.x1;
		
		e.fz2.sign = 1;
		e.fz2.d_whole = 0;
		e.fz2.d_fract = 0;
		e.fz2.running = 0;
		e.fz2.active = e.z1;
		}
	else
		{
		ady = HABS(dy);
		
		e.dxy = (e.xn - e.x1) / ady;
		e.ydir = dy < 0 ? -1 : 1;
		
		e.x2 = e.x1 + e.dxy;
		e.y2 = e.y1 + e.ydir;
		
		fixed_divide(	(e.zn - e.z1),
				 ady,
				 &e.fz2.sign,
				 &e.fz2.d_whole,
				 &e.fz2.d_fract);
							 
		e.fz2.running = 0x40000000;
		
		e.fz2.active = e.z1;
	
		Fixed_add( e.fz2 );
		e.z2 = e.fz2.active;
		}


	/*
	 *  Set steps
	 */
	 
	dx = ROUND16(e.x2) - ROUND16(e.x1);
	dy = (e.y2) - (e.y1);
	
	if( dy == 0 )
		{
		e.ydir = 0;
		e.zb_ydir = 0;
		e.cb_ydir = 0;
		}
	else
		{
		if( dy < 0 )
			{
			e.ydir = -1;
			e.zb_ydir = -ystep;
			e.cb_ydir = -ystep2;
			}
		else
			{
			e.ydir = 1;
			e.zb_ydir = ystep;
			e.cb_ydir = ystep2;
			}
		}
		
	if( dx == 0 )
		{
		adx = dx;
		
		e.xdir = 0;
		e.zb_xdir = 0;
		e.cb_xdir = 0;
		
		e.fz1.sign = 1;
		e.fz1.d_whole = 0;
		e.fz1.d_fract = 0;
		e.fz1.running = 0;
		}
	else
		{
		if( dx < 0 )
			{
			adx = -dx;
			e.xdir = -ONE16;
			e.zb_xdir = -xstep;
			e.cb_xdir = -xstep2;
			}
		else
			{
			adx = dx;
			e.xdir = ONE16;
			e.zb_xdir = xstep;
			e.cb_xdir = xstep2;
			}
			
		fixed_divide(	(e.z2 - e.z1),
				 (adx),
				 &e.fz1.sign,
				 &e.fz1.d_whole,
				 &e.fz1.d_fract);
				 
		e.fz1.running = 0x40000000;
		}
		
	e.xjump = adx >> 1;
	e.fz1.active = e.z1;

	e.zb = active_window->zbuf + 
			(offset = e.y1 * active_window->x_dits + ROUND16(e.x1) + 1);	
			
#	if BYTES_PER_PIXEL == 5
		e.cb = active_window->cbuf + (offset);
#	else
		e.cb = active_window->cbuf + (offset << 1);
#	endif
	
	e.side = LINE_SIDE;
	
	HPset_weight_steps( &e );

	wxoff = wp[0].x;
	wyoff = wp[0].y;
	
	HSedge_vis( &e );
	
	
	xold = ROUND16(e.x1);
	yold = (e.y1);
	
	if( (e.y1) == (e.yn) )
		{
		if( e.x1 != e.xn )
		do	{
			stat = HPone_step( &e );
			HSset_style( e.x1, e.y1 );
			HSedge_vis( &e );
			}
		while( !(stat & RESET) && !(stat & EDGE_END) );
		}
	else
		while( ((ROUND16(e.x1) != ROUND16(e.xn)) || 
		       ((e.y1) != (e.yn))) &&
		       ((e.y1) != (e.yn + e.ydir)) )
			{
			HPone_step( &e );
			HSset_style( e.x1, e.y1 );
			HSedge_vis( &e );
			}

fini:;

	/*
	 *  Move second vertice to first
	 */
			 
	current_vertex = *next_vertex;
	}
	
 
/*---HPtrap_radge5-----------------------------------------------*/

/*
NAME
	HPtrap_radge5
	HPtrap_radge6
	
KEYWORDS
	HSplot
	RHL
	rasterizer
	trapezoid
	
DESCRIPTION
	Rasterizes the trapezoid for RHL display
	
PARAMETERES
	tile	:(IN) :  Information about the trapezoid
	
GLOBALS USED
	HPband_info		:  global information
		org_y		:  Used to translate the edge/polyline segment to
				   the band viewport
		y_dits		:  Used in clipping the edge/polyline segment
	vdebug			:  set to 1 (???)
	current_vertex		:  coordinates of the previous vertex
	active_window		:  global information
		zbuf, cbuf	:  address of the z/image buffers
		x_dits		:  height of the viewport

FUNCTIONS CALLED
	Fixed_add
	fixed_divide
	ROUND16
	HPset_weight_steps
	HPtrap_vis
	HPfill_trap
	HPone_step
	HSset_style

HISTORY
	??/??/??	M. Lanier
		Created
*/

#if BYTES_PER_PIXEL == 5
	void HPtrap_radge5 (struct trapezoid *tile)
#else
	void HPtrap_radge6 (struct trapezoid *tile)
#endif

	{
	struct edge_info	el, er;
	int			dy, dxl, dxr;
	int			adxl, adxr;
	int			statl, statr;

	
	/*
	 *  Translate trap to the zbuffer origin
	 */
	 
	tile->ya -= HPband_info.org_y;
	tile->yb -= HPband_info.org_y;

	if( tile->ya < 0 && tile->yb < 0 ) return;
	if( tile->ya > HPband_info.y_dits && tile->yb > HPband_info.y_dits ) return;
	
	c1++;
	vdebug = 0;
	
	HPset_display_colors();
		
	xdits = active_window->x_dits;
	xdits2 = xdits << 1;

/*	
if( tile->yb <= 347 && tile->ya >= 347 )
if( ((tile->x0 >> 16) <= 336 && (tile->x1 >> 16) >= 336) ||
    ((tile->x2 >> 16) <= 336 && (tile->x3 >> 16) >= 336))
{
fprintf( stderr, "HIT\n" );
}
*/

#	if DEBUG_TRAP
	if( !(DTRAP) ) return(0);
#	endif

#	if DEBUG_TLOG
	fprintf( stderr, "1 %1d %d\n", c1, tile->id );
	fprintf( stderr, " %10.6f %10.6f %12d %2d\n",
		(double)(tile->x0/65535.0), (double)(tile->ya), tile->z0, tile->shade0 );
	fprintf( stderr, " %10.6f %10.6f %12d %2d\n",
		(double)(tile->x1/65535.0), (double)(tile->ya), tile->z1, tile->shade1 );
	fprintf( stderr, " %10.6f %10.6f %12d %2d\n",
		(double)(tile->x2/65535.0), (double)(tile->yb), tile->z2, tile->shade2 );
	fprintf( stderr, " %10.6f %10.6f %12d %2d\n",
		(double)(tile->x3/65535.0), (double)(tile->yb), tile->z3, tile->shade3 );
#	endif

#	if DEBUG_T
 	fprintf( stderr, "\nHSdraw_trapezoid --- %1d %x\n", c1, tile->id );
	fprintf( stderr, "p0 -- %10.6f %10.6f %x %x\n",
		(double)(tile->x0/65535.0), (double)(tile->ya/*/65535.0*/), tile->z0, tile->shade0 );
	fprintf( stderr, "p1 -- %10.6f %10.6f %x %x\n",
		(double)(tile->x1/65535.0), (double)(tile->ya/*/65535.0*/), tile->z1, tile->shade1 );
	fprintf( stderr, "p2 -- %10.6f %10.6f %x %x\n",
		(double)(tile->x2/65535.0), (double)(tile->yb/*/65535.0*/), tile->z2, tile->shade2 );
	fprintf( stderr, "p3 -- %10.6f %10.6f %x %x\n",
		(double)(tile->x3/65535.0), (double)(tile->yb/*/65535.0*/), tile->z3, tile->shade3 );
#	endif


	/*
	 *  START
	 */
	 
	el.x1 = tile->x2;
	el.y1 = tile->yb;
	el.z1 = tile->z2;
	
	el.xn = tile->x0;
	el.yn = tile->ya;
	el.zn = tile->z0;
	
	er.x1 = tile->x3;
	er.y1 = tile->yb;
	er.z1 = tile->z3;
	
	er.xn = tile->x1;
	er.yn = tile->ya;
	er.zn = tile->z1;
	
	if( tile->yb < 0 )
		{
		CLIP( &el.x1, &el.y1, &el.z1, &el.xn, &el.yn, &el.zn, 0 );
		CLIP( &er.x1, &er.y1, &er.z1, &er.xn, &er.yn, &er.zn, 0 );
		}

	if( tile->ya > HPband_info.y_dits )
		{
		CLIP( &el.xn, &el.yn, &el.zn, &el.x1, &el.y1, &el.z1, HPband_info.y_dits );
		CLIP( &er.xn, &er.yn, &er.zn, &er.x1, &er.y1, &er.z1, HPband_info.y_dits );
		}

	dxl = ROUND16(el.xn) - ROUND16(el.x1);
	dxr = ROUND16(er.xn) - ROUND16(er.x1);
	dy  = el.dy = (el.yn) - (el.y1);
	
	if( dy == 0 )
		{
		el.ydir = 0;
		el.x2 = el.xn;
		el.y2 = el.yn;
		el.z2 = el.zn;
		
		el.fz2.sign = 1;
		el.fz2.d_whole = 0;
		el.fz2.d_fract = 0;
		el.fz2.running = 0;
		el.fz2.active = el.z1;

		er.ydir = 0;		
		er.x2 = er.xn;
		er.y2 = er.yn;
		er.z2 = er.zn;
		
		er.fz2.sign = 1;
		er.fz2.d_whole = 0;
		er.fz2.d_fract = 0;
		er.fz2.running = 0;
		er.fz2.active = er.z1;
		}
	else
		{
		el.ydir = 1;
		el.dxy = (el.xn - el.x1) / dy;
		
		el.x2 = el.x1 + el.dxy;
		el.y2 = el.y1 + 1;
		
		fixed_divide(	(el.zn - el.z1),
				 dy,
				 &el.fz2.sign,
				 &el.fz2.d_whole,
				 &el.fz2.d_fract);
				 
		el.fz2.running = 0x40000000;


		er.ydir = 1;			
		er.dxy = (er.xn - er.x1) / dy;
		
		er.x2 = er.x1 + er.dxy;
		er.y2 = er.y1 + 1;
		
		fixed_divide(	(er.zn - er.z1),
				 dy,
				 &er.fz2.sign,
				 &er.fz2.d_whole,
				 &er.fz2.d_fract);
				 
		er.fz2.running = 0x40000000;
		
		el.fz2.active = el.z1;
		er.fz2.active = er.z1;
	
		Fixed_add( el.fz2 );
		el.z2 = el.fz2.active;
	
		Fixed_add( er.fz2 );
		er.z2 = er.fz2.active;
		}

	dxl = ROUND16(el.x2) - ROUND16(el.x1);
	dy  = (el.y2) - (el.y1);
	
	if( dy == 0 )
		{
		el.ydir = 0;
		el.zb_ydir = 0;
		el.cb_ydir = 0;
		}
	else
		{
		if( dy < 0 )
			{
			el.ydir = -1;
			el.zb_ydir = -ystep;
			el.cb_ydir = -ystep2;
			}
		else
			{
			el.ydir = 1;
			el.zb_ydir = ystep;
			el.cb_ydir = ystep2;
			}
		}
		
	if( dxl == 0 )
		{
		adxl = 0;
		
		el.xdir = 0;
		el.zb_xdir = 0;
		el.cb_xdir = 0;
		
		el.fz1.sign = 1;
		el.fz1.d_whole = 0;
		el.fz1.d_fract = 0;
		el.fz1.running = 0;
		}
	else
		{
		if( dxl < 0 )
			{
			adxl = -dxl;
			
			el.xdir = -ONE16;
			el.zb_xdir = -xstep;
			el.cb_xdir = -xstep2;
			}
		else
			{
			adxl = dxl;
			
			el.xdir = ONE16;
			el.zb_xdir = xstep;
			el.cb_xdir = xstep2;
			}
			
		fixed_divide(	(el.z2 - el.z1),
				 adxl,
				 &el.fz1.sign,
				 &el.fz1.d_whole,
				 &el.fz1.d_fract);
				 
		el.fz1.running = 0x40000000;
		}
		
	el.fz1.active = el.z1;
	
	/*
	 *  In rasterizing a scanline, I will fill a horizonal run of pixels then drop down to
	 *  the next scanline.  To fill the interior region of the trapezoid I will interpolate
	 *  between the interior pixels of the two edges.  I have a loop later that will fill
	 *  the horizonal run of pixels.  The interior pixel of the left edge is the first pixel
	 *  if x is decreasing and the last pixel if x is increasing.  Therefore I need a different
	 *  stop mask for either case (x increasing or decreasing).  If decreasing I want to
	 *  fill the trap before processing the run.  If increasing I want to fill the trap after
	 *  processing the run.  This is so that the current x is the interior pixel.  In either
	 *  case, stop if you hit the end of the edge
	 */
	 
	el.stop_mask = dxl <= 1 ? JUST_JUMPED : ABOUT_TO_JUMP;
	el.stop_mask |= EDGE_END;
	el.side = LEFT_SIDE;
	
	el.xjump = adxl >> 1;

	el.zb = active_window->zbuf + 
			(offset = el.y1 * active_window->x_dits + ROUND16(el.x1) + 1);	
			
#	if BYTES_PER_PIXEL == 5
		el.cb = active_window->cbuf + (offset);
#	else
		el.cb = active_window->cbuf + (offset << 1);
#	endif
		
	dxr = ROUND16(er.x2) - ROUND16(er.x1);

	if( dy == 0 )
		{
		er.ydir = 0;
		er.zb_ydir = 0;
		er.cb_ydir = 0;
		}
	else
		{
		if( dy < 0 )
			{
			er.ydir = -1;
			er.zb_ydir = -ystep;
			er.cb_ydir = -ystep2;
			}
		else
			{
			er.ydir = 1;
			er.zb_ydir = ystep;
			er.cb_ydir = ystep2;
			}
		}
		
	if( dxr == 0 )
		{
		adxr = dxr;
		
		er.xdir = 0;
		er.zb_xdir = 0;
		er.cb_xdir = 0;
		
		er.fz1.sign = 1;
		er.fz1.d_whole = 0;
		er.fz1.d_fract = 0;
		er.fz1.running = 0;
		}
	else
		{
		if( dxr < 0 )
			{
			adxr = -dxr;
			
			er.xdir = -ONE16;
			er.zb_xdir = -xstep;
			er.cb_xdir = -xstep2;
			}
		else
			{
			adxr = dxr;
			
			er.xdir = ONE16;
			er.zb_xdir = xstep;
			er.cb_xdir = xstep2;
			}
			
		fixed_divide(	(er.z2 - er.z1),
				 adxr,
				 &er.fz1.sign,
				 &er.fz1.d_whole,
				 &er.fz1.d_fract);
				 
		er.fz1.running = 0x40000000;
		}
		
	/*
	 *  This stop mask is the same for the right edge as it was for the left edge
	 *  except  that the interior pixel is on the opposite side of the run, which
	 *  reverses the stop mask
	 */
	 
	er.stop_mask = dxr >= -1 ? JUST_JUMPED : ABOUT_TO_JUMP;
	er.stop_mask |= EDGE_END;
	er.side = RIGHT_SIDE;
		
	er.xjump = adxr >> 1;

	er.zb = active_window->zbuf + 
			(offset = er.y1 * active_window->x_dits + ROUND16(er.x1) + 1);	
			
#	if BYTES_PER_PIXEL == 5
		er.cb = active_window->cbuf + (offset);
#	else
		er.cb = active_window->cbuf + (offset << 1);
#	endif
			
	er.fz1.active = er.z1;
	
	HPtrap_vis( &el );
	HPtrap_vis( &er );

	if( el.y1 == el.yn )
		{
		HPfill_trap( &el, &er );
		}
	else
		{
		statl = statr = 0;
		while( (!(statl & EDGE_END) || !(statr & EDGE_END)) && el.dy > 0 )
			{
				
			/*
			 *  Fill the edges for the scanline unless, for the left edge, x in decreasing
			 *  and it's about to jump to the next scanline, and, for the right edge
			 *  x in increasing and it's about to jump to the next scanline
			 */
			 
			if( dxl > 1 && el.xjump != 0 )
				do
					{
					statl = HPone_step( &el );
					HPtrap_vis( &el );
					}
				while( !(statl & ABOUT_TO_JUMP) && !(statl & EDGE_END) );

			if( dxr <= -1 && er.xjump != 0 )
				do
					{
					statr = HPone_step( &er );
					HPtrap_vis( &er );
					}
				while( !(statr & ABOUT_TO_JUMP) && !(statr & EDGE_END) );
		
			/*
			 *  Fill the trapezoid between the two edges
			 */
			 
			HPfill_trap( &el, &er );

			/* 
			 *  process the edge until it jumps down to the next scanline
			 */
			 		
			do
				{
				statl = HPone_step( &el );
				HPtrap_vis( &el );
				}
			while( !(statl & JUST_JUMPED) && !(statl & EDGE_END) );

			do
				{
				statr = HPone_step( &er );
				HPtrap_vis( &er );
				}
			while( !(statr & JUST_JUMPED) && !(statr & EDGE_END) );
			}
		}
	}
