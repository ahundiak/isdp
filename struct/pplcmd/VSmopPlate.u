/* $Id: VSmopPlate.u,v 1.2 2001/01/17 15:06:47 ramarao Exp $  */

/* --------------------------------------------------------------------
 * I/STRUCT
 *
 * File:       /pplcmd/VSmopPlate.u
 *
 * Description:
 *      A ppl command file which is applied to modify operators.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: VSmopPlate.u,v $
 *      Revision 1.2  2001/01/17 15:06:47  ramarao
 *      *** empty log message ***
 *
# Revision 1.3  2000/06/01  19:24:18  pinnacle
# Replaced: struct/pplcmd/VSmopPlate.u for:  by mdong for Service Pack
#
# Revision 1.2  2000/06/01  15:26:46  pinnacle
# Replaced: struct/pplcmd/VSmopPlate.u for:  by mdong for Service Pack
#
# Revision 1.1  2000/05/03  15:19:50  pinnacle
# initial revision
#
# Revision 1.5  2000/01/26  14:06:52  pinnacle
# ah
#
# Revision 1.4  1999/07/27  20:16:52  pinnacle
# (No comment)
#
# Revision 1.3  1999/06/16  15:56:40  pinnacle
# (No comment)
#
# Revision 1.2  1999/05/06  21:47:02  pinnacle
# (No comment)
#
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 03/30/99  ah      Created
 * 04/30/99  Ming    Created
 * 01/26/00  ah      Opened the operator filter to allow selecting GRvg
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDfrm.h"

#include "VSmop.h"
#include "VSmopCmd.h"

#include "coparamac.h"

extern ASstart_var_fence();
extern ASend_fence();
extern calloc();

#define theCommand "Modify Plate Operator"
#define thePrompt  "Modify form, accept when done"
#define theForm    "VSmop.F"

TVSmopCmdInfo cmdInfo;

struct CIform_st form_st;

IGRint locateFlag;
IGRint sleepFlag;
IGRint traceFlag;
IGRint inittedFlag;

/* ------------------------------------------------
 * Waiting to pick an operator
 */
IGRstat locateOps()
{
  IGRstat sts;
  IGRstat response;

  TGRobj_env opOE;
  
  // Init
  sts = 0;
  locateFlag = 1;
  VSmopCmd_SetFormState(0);

  while(1) {
    
    response = 0;

    UI_message(theCommand);
    
    sts = ci$locate(prompt  = "Select Operator, move on when done",
		    classes = "GRvg",
		    owner_action = 
		    LC_RIGID_OWNER | 
		    LC_RIGID_COMP  |
		    LC_FLEX_COMP   | 
		    LC_FLEX_OWNER  |
		    LC_REF_OBJECTS,

		    stackable = 1,
		    response  = &response,
		    md_env    = &opOE.mod_env,
		    obj       = &opOE.obj_id.objid,
		    osnum     = &opOE.obj_id.osnum);

    if (!(sts & 1)) response = 0;

    switch(response) {
      
    case EX_OBJID:   // Object Set
      break;
      
    case EX_DATA:    // Single Object
      VSmopCmd_LocatedOp(&opOE);
      break;
    
    case 0:  
    case MOVE_ON:
    case TERMINATE:
      goto wrapup;
      

      //default: //printf("Response %d\n",response);
      
    } // Switch
  
  }

wrapup:
  locateFlag = 0;
  VSmopCmd_SetFormState(1);
  return sts;
}
  
/* ------------------------------------------------
 * Waiting to pick plate
 * form processing will be disabled here
 */
IGRstat locatePlate()
{
  IGRlong sts;
  IGRint  response;
  TGRobj_env  locOE;
  TGRobj_env *locOEs;
  IGRint      locNum;
  IGRint      i;
  

  // Init
  sts = 0;
  locateFlag = 1;
  VSmopCmd_SetFormState(0);

  if (traceFlag) {  
    printf(">>> VSmopCmdPPL_locatePlate\n");
  }
  
  while(1) {
    
    response = 0;

    UI_message(theCommand);
    
    sts = ci$locate(prompt  = "Select Plate(s)",
		    classes = "VSplate",
		    owner_action = 
		    LC_RIGID_OWNER | 
		    LC_RIGID_COMP  |
		    LC_FLEX_COMP   | 
		    LC_FLEX_OWNER  |
		    LC_REF_OBJECTS,

		    stackable = 1,
		    response  = &response,
		    md_env    = &locOE.mod_env,
		    obj       = &locOE.obj_id.objid,
		    osnum     = &locOE.obj_id.osnum);

    if (!(sts & 1)) response = 0;

    // printf("Response %d\n",response);
    
    switch(response) {
      
    case EX_OBJID:   // Object Set

      /* Grab Located Objects */
      as$start_fence(
      set       = &locOE.obj_id,
      set_env   = &locOE.mod_env,
      nb_obj    = &locNum,
      p_obj_env = &locOEs);

      for(i = 0; i < locNum; i = i + 1) {
        VSmopCmd_LocatedPlate(&locOEs[i]);
      }

      ASend_fence();
      sts = 1;
      goto wrapup;
      
    case EX_DATA:    // Single Object
      VSmopCmd_LocatedPlate(&locOE);
      sts = 1;
      goto wrapup;
      
    case TERMINATE:
      goto wrapup;
      

    } // Switch
  
  }

wrapup:
  locateFlag = 0;
  VSmopCmd_SetFormState(1);

  if (traceFlag) {  
    printf("** VSmopCmdPPL_locatePlate\n");
  }
  
  return sts;
}
  

/* ------------------------------------------------
 * Main routine
 */
main()
{
  IGRstat sts,msg;
  IGRstat response;

  TGRobj_env plateOE;

  // Make sure everyting got initted
  if (!(cmdInfo.initFlag & 1)) {
    return 0;
  }
  inittedFlag = 1;
  
  // Init
  locateFlag = 0;
  
  // Create the form  
  sts = init_form();
  if (!(sts & 1)) goto wrapup;

  // Get the first plate
  locatePlate();
  
  // Fill it in
  // vdobj$Print(objOE = &cmdInfo.plateOE);
  vdfrm$DisplayForm(form = cmdInfo.form);
  cmdInfo.displayForm = 1;
  
  /*
  FIg_disable( cmdInfo.form, VSMOP_FORM_B_INSERT_PLATE );
  */

  while(1) {

    UI_message(theCommand);

    cmdInfo.gadget = 0;
    
    ci$get(prompt   = thePrompt, 
           response = &response);

    /*
    FIg_disable( cmdInfo.form, VSMOP_FORM_B_INSERT_PLATE );
    */

    switch(response) {

    case MOVE_ON:

      // Might be better to deal with locates here
      switch(cmdInfo.gadget) {

      case VSMOP_FORM_B_LOCATE_OPS:
	locateOps();
	VIg_set_state(cmdInfo.form,VSMOP_FORM_B_LOCATE_OPS,0);
	goto the_loop;

      case FI_CANCEL:
      case FI_ACCEPT:
        VSmopCmd_FormNotify();
        goto wrapup;

      case VSMOP_FORM_B_LOCATE_PLATE:
	locatePlate();
	VIg_set_state( cmdInfo.form, VSMOP_FORM_B_LOCATE_PLATE, 0);
	goto the_loop;
	
      default:
	VSmopCmd_FormNotify();
	goto the_loop;
      }
      
    case TERMINATE:
      goto wrapup;
    }
the_loop:
    response = 0;
  }

wrapup:
  return 1;
}


/* ---------------------------------------------------
 * Form notification routine
 */
IGRstat form_notification()
{
  // Init
  cmdInfo.gadget = form_st.gadget_label;

  // printf("Gadget %d\n",gadget);

  // A few always get's handled
  switch (cmdInfo.gadget) {

  case FI_CANCEL:
    ci$put(response = TERMINATE);
    goto wrapup;
  }
  
  // Disable form during locates and sleep
  if (locateFlag) goto wrapup;
  if ( sleepFlag) goto wrapup;

  // Break out of wait loop and process
  ci$put(response = MOVE_ON);
   
wrapup:
  return 1;

}

/* --------------------------------------------------------
 * Get the form started
 */
init_form()
{
  IGRstat retFlag;
  IGRstat sts;
  Form    existingForm;
  
  retFlag = 0;

  // Already running?
  sts = vdfrm$GetFormByName(name = theForm, form = &existingForm);
  if (existingForm) {
    UI_status("Modify Plate Operator - Already Running");
    goto wrapup;
  }

  // Create it
  vdfrm$CreateForm(label  = 100,
                   name   = theForm,
                   notify = ci_notification,
                   objid  = MY_ID,
                   form   = &cmdInfo.form);

  if (cmdInfo.form == 0) {
    UI_status("Could not init Modify Plate Operator form");
    goto wrapup;
  }
  
  // Position it
  vdfrm$LoadFormPosition(form = cmdInfo.form);

  // Done
  retFlag = 1;

wrapup:
  return retFlag;
}

/* ------------------------------------------
 * Usual command object messages
 */
init()
{
  inittedFlag = 0;
  traceFlag = 0;
  
/*-----------dong-----------
  memset(&cmdInfo,0,sizeof(cmdInfo));
-------------end-------------*/
  VSmopCmd_Init(&cmdInfo);

  if (traceFlag) printf("*** VSmopCmdPPL_init\n");
  
}
sleep() 
{
  if (inittedFlag == 0) return 0;
  
  VSmopCmd_Sleep();
  VSmopCmd_SetFormState(0);
  sleepFlag = 1;
  if (traceFlag) printf("*** VSmopCmdPPL_sleep\n");
}
wakeup()
{
  // Ignore the very first wakeup
  if (inittedFlag == 0) return 0;

  VSmopCmd_Wakeup();
  VSmopCmd_SetFormState(1);
  sleepFlag = 0;

  if (cmdInfo.displayForm) vdfrm$DisplayForm(form = cmdInfo.form);
  
  UI_message(theCommand);
  UI_prompt (thePrompt);
  cmdInfo.gadget = 0;

  ci$put(response = MOVE_ON);

  if (traceFlag) printf("*** VSmopCmdPPL_wakeup\n");

}
delete()
{
  VSmopCmd_Delete();
  
  if (cmdInfo.form) {
    vdfrm$SaveFormPosition(form = cmdInfo.form);
    vdfrm$DeleteForm      (form = cmdInfo.form);
  }
  cmdInfo.form = NULL;
  if (traceFlag) printf("*** VSmopCmdPPL_delete\n");
}


