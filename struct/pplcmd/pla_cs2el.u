/* $Id: pla_cs2el.u,v 1.5 2001/07/13 16:33:03 jayadev Exp $  */

/***************************************************************************
 * I/STRUCT
 *
 * File:	pplcmd/pla_cs2el.u	
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: pla_cs2el.u,v $
 *	Revision 1.5  2001/07/13 16:33:03  jayadev
 *	fix for TR#MP5386
 *	
 *	Revision 1.4  2001/07/03 22:51:04  jayadev
 *	fix for etl#9134
 *	
 *	Revision 1.3  2001/06/11 19:40:09  jayadev
 *	*** empty log message ***
 *	
 *	Revision 1.2  2001/06/08 21:23:44  ad
 *	fix for TR# MP5292
 *	
 *	Revision 1.1.1.1  2001/01/04 21:10:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.3  2000/02/23  22:19:06  pinnacle
# ah
#
# Revision 1.2  2000/02/17  16:52:08  pinnacle
# (No comment)
#
# Revision 1.1  1998/04/30  10:08:06  pinnacle
# STRUCT 2.5.1
#
# Revision 1.4  1998/02/08  14:52:10  pinnacle
# ah
#
# Revision 1.3  1998/02/03  19:23:48  pinnacle
# TR179702554
#
# Revision 1.2  1997/06/16  15:22:46  pinnacle
# TR179701071
#
# Revision 1.6  1997/05/28  12:28:18  pinnacle
# Replaced: pplcmd/pla_cs2el.u for:  by mfournie for struct
#
# Revision 1.5  1997/05/22  17:03:44  pinnacle
# Replaced: pplcmd/pla_cs2el.u for: change call of VSfind_origin(). by mfournie for struct
#
# Revision 1.4  1997/04/01  15:19:20  pinnacle
# Replaced: pplcmd/pla_cs2el.u for:  by jwfrosch for struct
#
# Revision 1.3  1996/11/22  11:49:04  pinnacle
# Replaced: pplcmd/pla_cs2el.u for:  by svkadamb for struct
#
# Revision 1.2  1996/10/22  05:51:34  pinnacle
# Replaced: pplcmd/pla_cs2el.u for:  by svkadamb for struct
#
# Revision 1.1  1996/09/06  10:04:42  pinnacle
# Created: pplcmd/pla_cs2el.u by svkadamb for struct
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *			suresh		Creation	
 *	05/22/97	mf		Change call of VSfind_origin().
 *	05/28/97	mf		Clean up and __DBGpr_xxx().
 *      06/16/97        ah              TR179701071 Checkin
 *      02/03/98        ah              TR179702554 Would not compile under Solaris
 *                                      Cleaned up the header files
 *      02/08/98        ah              Left debug on
 *      07/03/01        Jayadev         fix for etl#9134 
 ***************************************************************************/
/*
	------------------------------------------------------------------

	File Name :		pla_cs2el.u

	Creation  :		Suresh

	Description :

		This macro constructs a coordinate system 
		between a beam and a beam or plate.
		The coordinate system will be later used to place an
		end cut macro.

	History :
	
	July 29, 1996  : creation date.

	------------------------------------------------------------------
*/
#include "VDppl.h"
#include "msdef.h"
#include "msmacros.h"
#include "bsvalues.h"

#include "ci_mac_def.h"
#include "acrepdef.h"
#include "bserr.h"
#include "gr.h"
#include "csdef.h"
#include "grdpbmacros.h"
#include "grcoordsys.h"

#include "vs.h"
#include "vsmiscpplmac.h"
/*
#define vsDEBUG 1
#define vserrDEBUG 1
*/
#include "vsdbgmacros.h"
#include "vsgeommacros.h"

#include "vscsby2el.h"
#include "vsgadgetCS.h"
#include "VSmsg.h"

#include "vsbeamdef.h"
#include "vsbeam.h"
#include "vsplatedef.h"
#include "vssectiondef.h"

#include "AS_status.h"
#include "vsdpb.h"
#include "vdAPImacros.h"

#if 0
#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "godef.h"
#include "exmacros.h"
#include "macro.h"
#include "nddef.h"
#include "macro.h"
#include "msdef.h"
#include "bserr.h"
#include "bstypes.h"
#include "msdef.h"
#include "EMSdpb.h"
#include "growner.h"
#include "igrdp.h"
#include "grmacros.h"
#include "parametric.h"
#include "acrepdef.h"

#include "cotxmacros.h"
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "DImacros.h"
#include "grcoordsys.h"
#include "madef.h"
#include "expmacros.h"
#include "csdef.h"

#include "grdpbmacros.h"
#include "vdAPImacros.h"
#endif

#define EXP_DOUBLE	0

struct 	GRid		CI_MACRO_ID;
struct 	GRid		GRidList;

GRobj 			ci_mac_def1;
IGRchar	 		*temp_names[MAX_TEMP], *feet_names[1];
IGRchar	 		tempBuff[MAX_TEMP*MAX_CHAR_FEET];
IGRint			temp_types[MAX_TEMP], j, k;

IGRint                  options[OPTIONS_NUMBER];
struct GRid             GR_OBJ;
IGRlong			sts;

extern 			MAmulmx(), MAtypemx(),
			EX_get_modid_given_osnum();

extern	IGRlong		VSfind_longer_u_v_iso(), VSgetBeamCenter(), 
			VSfind_surf_to_intersect(), VSfind_botu0_web(),
			VSfind_origin(), VSfind_xaxis(), VSfind_yaxis(),
			VSgetDetailedRepBeam();

extern	IGRlong		EXP_create_double();
extern			GRdelete_object(), GRdpb_get();
extern	double		fabs();


extern  GRclassid       OPP_VSplate_class_id;
extern  GRclassid       OPP_VSbeam_class_id;
extern  GRclassid       OPP_VSsrcBeam_class_id;
extern  GRclassid       OPP_VSimgFeature_class_id;

/* ========================================================================= */
main ()
{
	/* Templates definition */
	temp_names[IDX_CS_ELEM1] = NAM_CS_ELEM1;
	temp_types[IDX_CS_ELEM1] = other_generic | macro_generic;
	temp_names[IDX_CS_ELEM2] = NAM_CS_ELEM2;
	temp_types[IDX_CS_ELEM2] = other_generic | macro_generic;
	for ( k=IDX_CS_OPT; k<MAX_TEMP; k=k+1 ) {
		j = k * MAX_CHAR_FEET;
		sprintf(&tempBuff[j],"option%d",(k-2));
		temp_names[k] = &tempBuff[j];
		temp_types[k] = parameter_generic | double_type;
	}

	/* Feet definition */
	feet_names[0] = "ref";

	/* CImacro definition creation */
	ci_mac_def1 = NULL_OBJID;
	ac$cimacdef ( cimacdef          = ci_mac_def1,
		      status		= &msg, 	
		      name              = "pla_cs2el",
		      temp_num          = MAX_TEMP, 	
		      temp_names        = temp_names,
		      temp_types        = temp_types,
		      extern_feet_num   = 1, 	
		      extern_feet_names = feet_names );
	__CheckRC ( 1, msg, "ac$cimacdef()", wrapup ) ;

wrapup:
	return 1;
}
/* ========================================================================= */
place ()
{
	getcs();
	if (GRidList.objid == NULL_OBJID)	return 0;
 
	sts = ci$send ( msg = message ci_macro.set_all_extern_feet
        	        	( &msg, 1, &GRidList, &MOD_ENV ),
	           	targetid = CI_MACRO_ID.objid,
        	   	targetos = CI_MACRO_ID.osnum );
	__CheckRC ( sts, msg, "ci_macro.set_all_extern_feet", wrapup ) ;

wrapup:
	return 1;
}
/* ========================================================================= */
compute ()
{
	getcs();
	if (GRidList.objid == NULL_OBJID)	return 0;
 
	sts = ci$send ( msg = message ci_macro.set_all_extern_feet
        	        	( &msg, 1, &GRidList, &MOD_ENV ),
	           	targetid = CI_MACRO_ID.objid,
        	   	targetos = CI_MACRO_ID.osnum );
	__CheckRC ( sts, msg, "ci_macro.set_all_extern_feet", wrapup ) ;

wrapup:
	return 1;
}
/* ========================================================================= */
getcs()
{
	IGRchar		srfName[DI_PATH_MAX];
	VSdspRep	rep;
	IGRboolean	isBeam, DeadBook[2];
	IGRint		i, j, k, indx_surf, web, u_is_longer;
struct	ret_struct	str[5];
struct	GRobj_env	beam, plate_or_beam, srf_to_int, Object[2];
struct	IGRdisplay	dis;
	IGRlong		loc_msg, sts;
struct	IGRbsp_surface	*ext_srf_to_int;
	IGRpoint	beam_center, origin;
	VSsuppList	supports;
	IGRvector	xaxis, x1axis, yaxis, zaxis;
struct	GRparms		beam_parms, srf_parms;
struct	IGRlbsys	cs_sys;
	BSrc		bsrc;
struct	GRcs_construct  cs_args;	/* Specific default attribute for cs */
struct	GRobj_env	bot_srf, sup_srf, *bot_or_sup_surf, *ptr_sup_srf;
struct	GRmd_env	CurEnv;
	IGRint		siz, ret, is_planar;
	IGRdouble	dValue;

	/* Get current environment */
	siz = sizeof(struct GRmd_env);
	gr$get_module_env ( msg    = &msg,
                            sizbuf = &siz,
                            buffer = &CurEnv,
                            nret   = &ret );

	/* Initialize */
	ext_srf_to_int = NULL;
	ptr_sup_srf    = NULL;
	GRidList.objid = NULL_OBJID;
	for ( i=0; i<2; i=i+1 )	DeadBook[i] = FALSE;
	isBeam = FALSE;
	is_planar = 0;

	/* Find template 0 */
	sts = ci$send ( msg = message ACcpx.ACfind_exp_temp_obj
						( &msg, 0, &GR_OBJ ),
			targetid = CI_MACRO_ID.objid,
			targetos = CI_MACRO_ID.osnum ); 
	__CheckRC ( sts, msg, "ACcpx.ACfind_exp_temp_obj 0", wrapup ) ;

	/* Return beam foot */
	sts = vd_$return_foot ( msg     = &msg,
				objId	= &GR_OBJ,
				objEnv	= &CurEnv,
				footId	= &Object[0].obj_id,
				footEnv	= &Object[0].mod_env );
	__CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;

	/* Find template 1 */
	sts = ci$send ( msg = message ACcpx.ACfind_exp_temp_obj
						( &msg, 1, &GR_OBJ ),
			targetid = CI_MACRO_ID.objid,
			targetos = CI_MACRO_ID.osnum ); 
	__CheckRC ( sts, msg, "ACcpx.ACfind_exp_temp_obj 1", wrapup ) ;

	/* Return plate|beam foot */
	sts = vd_$return_foot ( msg     = &msg,
				objId	= &GR_OBJ,
				objEnv	= &CurEnv,
				footId	= &Object[1].obj_id,
				footEnv	= &Object[1].mod_env );
	__CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;

	/* Get other templates */
	for ( i=IDX_CS_OPT; i<MAX_TEMP; i=i+1) {
		sts = ci$send ( msg = message ACcpx.ACfind_exp_temp_struct
			( &msg, i, (IGRchar *) &str[i-IDX_CS_OPT], &CurEnv ),
				targetid = CI_MACRO_ID.objid,
				targetos = CI_MACRO_ID.osnum ); 
		__CheckRC ( sts, msg, "ACcpx.ACfind_exp_temp_obj", wrapup ) ;
		options[i-IDX_CS_OPT] = str[i-IDX_CS_OPT].var.root_pm_st.value;
	}

	/* Build construction list */
        init_cnst_list();
        get_symb();
        dis.color       = cnst_list.color;
        dis.weight      = cnst_list.weight;
        dis.style       = cnst_list.style;

        cst.msg         = &msg;
        cst.properties  = GRIS_LOCATABLE | GRIS_DISPLAYABLE | GRIS_NEW ;
        cst.display     = &dis;
        cst.env_info    = &CurEnv;
        cst.newflag     = FALSE;
        cst.level       = cnst_list.level;
        cst.name        = 0;

        cst.class_attr  = (IGRchar *)NULL;
	cst.geometry 	= (IGRchar *)NULL;

	/* Get beam representation */
	sts = ci$send ( msg = message ACncpx.ACget_NV_rep ( &rep ),
                   	targetid= Object[0].obj_id.objid,
                   	targetos= Object[0].obj_id.osnum ) ;
	__CheckRC ( sts, msg, "ACncpx.ACget_NV_rep 0", wrapup ) ;

	/* Get graphic object according to representation */
 	if (!(rep & AC_3D_REP)) {
        	sts = VSgetDetailedRepBeam ( &msg,
					     &Object[0].mod_env,
					     &Object[0].obj_id,
					     &beam.obj_id ) ;
		__CheckRC ( sts, msg, "VSgetDetailedRepBeam()", wrapup ) ;
		beam = Object[0];
		DeadBook[0] = TRUE;
	}
	else {	sts = vd_$return_foot ( msg     = &msg,
					objId	= &Object[0].obj_id,
					objEnv	= &Object[0].mod_env,
					footId	= &beam.obj_id,
					footEnv	= &beam.mod_env );
		__CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;
    	}

	/* Get plate|beam representation */
	sts = ci$send ( msg = message ACncpx.ACget_NV_rep ( &rep ),
                   	targetid= Object[1].obj_id.objid,
                   	targetos= Object[1].obj_id.osnum ) ;
	__CheckRC ( sts, msg, "ACncpx.ACget_NV_rep 1", wrapup ) ;

	/* Check if the object is a subclass of VSsrcBeam */
       	if ( vs$is_ancestry_valid ( object  = &Object[1].obj_id,
               	                    classid = OPP_VSsrcBeam_class_id ) )
		isBeam  = TRUE ;

	/* Get graphic object according to representation */
 	if ( (!(rep & AC_3D_REP)) && (isBeam) ) {
		sts = VSgetDetailedRepBeam ( &msg,
					     &Object[1].mod_env,
					     &Object[1].obj_id,
					     &plate_or_beam.obj_id ) ;
		__CheckRC ( sts, msg, "VSgetDetailedRepBeam()", wrapup ) ;
		plate_or_beam = Object[1];
		DeadBook[1] = TRUE;
	}
	else {	sts = vd_$return_foot ( msg     = &msg,
					objId	= &Object[1].obj_id,
					objEnv	= &Object[1].mod_env,
					footId	= &plate_or_beam.obj_id,
					footEnv	= &plate_or_beam.mod_env );
		__CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;
    	}

	/* Find bottom inferior flange */
	sprintf ( srfName, "%s:%s:%s",
		  VS_K_bmGrCmpName, VS_K_bmBody, VS_K_nmFlgInfE );
	sts = vd_$return_foot ( msg     = &msg,
				name	= srfName,
				objId	= &beam.obj_id,
				objEnv	= &beam.mod_env,
				footId	= &bot_srf.obj_id,
				footEnv	= &bot_srf.mod_env );
	__CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;
	bot_or_sup_surf = &bot_srf;

	/* Find bottom superior flange (if needed) */
	if (options[1] >= 3) {  	// origin is on the top superior flange
		                        // find top superior flange
	        sprintf ( srfName, "%s:%s:%s",
			  VS_K_bmGrCmpName, VS_K_bmBody, VS_K_nmFlgSupE );
		sts = vd_$return_foot ( msg     = &msg,
					name	= srfName,
					objId	= &beam.obj_id,
					objEnv	= &beam.mod_env,
					footId	= &sup_srf.obj_id,
					footEnv	= &sup_srf.mod_env );
		__CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;
	        ptr_sup_srf     = &sup_srf;
        	bot_or_sup_surf = &sup_srf;
	}
 
    	/* Find between the iso in u and the iso in v which is longer */
	sts = VSfind_longer_u_v_iso ( &bot_srf, &cst, &u_is_longer );
	__CheckRC ( sts, msg, "VSfind_longer_u_v_iso()", wrapup ) ;
	__DBGpr_obj ( "VSfind_longer_u_v_iso", bot_srf.obj_id );
	__DBGpr_int ( "\tu_is_longer", u_is_longer );
	
	/* Find the geometric center */
	sts = VSgetBeamCenter ( &beam, beam_center ); 
	__CheckRC ( sts, msg, "VSgetBeamCenter()", wrapup ) ;
	__DBGpr_obj ( "VSgetBeamCenter", beam.obj_id );
	__DBGpr_vec ( "\tcenter", beam_center );
     	
	/* Get stiffener axis */
	sts = ci$send ( msg = message VSstfBeam.VSgetSupports
			( &msg, &beam.mod_env, &i, supports ),
			targetid = beam.obj_id.objid,
			targetos = beam.obj_id.osnum );
	__CheckRC ( sts, msg, "VSstfBeam.VSgetSupports", wrapup ) ;
	
        __DBGpr_obj("beam ",beam.obj_id);
        __DBGpr_obj("SUPPORTS[0] ",supports[0].obj_id);
        __DBGpr_obj("SUPPORTS[1] ",supports[1].obj_id);
	
        is_planar = vs$is_surface_planar( msg     = &msg,
					  surfId  = &supports[0].obj_id,
					  surfEnv = &supports[0].mod_env ) ;
        if(!(msg&1))
        {
          __DBGpr_com("Planarity test for support surface failed");
          is_planar = 0;
        }
        __DBGpr_int("is_planar ",is_planar);
	
	/* Find the surface to intersect with the first beam */
	sts = VSfind_surf_to_intersect ( &plate_or_beam, beam_center, 
					 options, &supports[1],
					 &indx_surf, &srf_to_int,
					 &ext_srf_to_int );
	__CheckRC ( sts, msg, "VSfind_surf_to_intersect()", wrapup ) ;
	__DBGpr_int ( "VSfind_surf_to_intersect() option", options[0] );
	__DBGpr_int ( "VSfind_surf_to_intersect() index ", indx_surf );

	/* Find if the iso curve u==0 is closest to web left or web right */
	sts = VSfind_botu0_web ( &beam, &bot_srf, &web );
	__CheckRC ( sts, msg, "VSfind_botu0_web()", wrapup ) ;
	__DBGpr_obj ( "VSfind_botu0_web", beam.obj_id );
	__DBGpr_int ( "web ", web );

	/* Find the origin of the coordinate system */
	sts = VSfind_origin ( &beam, &plate_or_beam,  &bot_srf, ptr_sup_srf,
			      &srf_to_int, &cst, options[1], u_is_longer,
			      origin, &beam_parms, &srf_parms );
	__CheckRC ( sts, msg, "VSfind_origin()", wrapup ) ;
	__DBGpr_int ( "VSfind_origin() option", options[0] );
	__DBGpr_vec ( "VSfind_origin() origin", origin );

	/* Find the xaxis of the coordinate system */
	sts = VSfind_xaxis ( bot_or_sup_surf, ext_srf_to_int, &cst,
			     options, web, u_is_longer, &beam_parms,
			     &srf_parms, xaxis );
	__CheckRC ( sts, msg, "VSfind_xaxis()", wrapup ) ;
	__DBGpr_int ( "VSfind_xaxis() option 0", options[0] );
	__DBGpr_int ( "VSfind_xaxis() option 1", options[1] );
	__DBGpr_int ( "VSfind_xaxis() option 2", options[2] );
	__DBGpr_int ( "VSfind_xaxis() option 3", options[3] );
	__DBGpr_vec ( "\txaxis", xaxis );
	/* Find the yaxis of the coordinate system */
	sts = VSfind_yaxis ( bot_or_sup_surf, ext_srf_to_int, xaxis,
			     beam_center, &cst, options, web, 
			     u_is_longer, &beam_parms, &srf_parms, yaxis );
	__CheckRC ( sts, msg, "VSfind_yaxis()", wrapup ) ;
	__DBGpr_vec ( "\tyaxis", yaxis );

	/*
	 * The following section has been added as result of an customer problem.
	 * were the direction of the bottom flange and top flange are not parallel 
	 * at an intersection. 
	 * This macro should always align the macro parallel to the web and the top
	 * is more accurrate then the bottom flange.
	 * Process
	 *	get the top flange for option (0,1,2) for optioon[1].
	 *	get the axis and compare existing xaxis of bottom.
	 *	when invalid, set the new x-axis, 
	 *	compute the z-axis and recaculate the y-axis.
	 */
	
	if(( options[1] < 3) && !(is_planar)){
	  
	  /* Get the top flange to validate the axis of the bottom */
	  __DBGpr_com("Top Flange direction trusted ");
	  sprintf ( srfName, "%s:%s:%s",
		    VS_K_bmGrCmpName, VS_K_bmBody, VS_K_nmFlgSupE );
	  sts = vd_$return_foot ( msg     = &msg,
				  name	  = srfName,
				  objId	  = &beam.obj_id,
				  objEnv  = &beam.mod_env,
				  footId  = &sup_srf.obj_id,
				  footEnv = &sup_srf.mod_env );
	  __CheckRC ( sts, msg, "vd_$return_foot()", wrapup ) ;
	  bot_or_sup_surf = &sup_srf;
	  ptr_sup_srf     = &sup_srf;
	  
	  sts = VSfind_xaxis ( bot_or_sup_surf, ext_srf_to_int, &cst,
			       options, web, u_is_longer, &beam_parms,
			       &srf_parms, x1axis );
	  __CheckRC ( sts, msg, "VSfind_xaxis()", wrapup ) ;
	  
	  BSnorvec ( &bsrc, xaxis ); 
	  BSnorvec ( &bsrc, x1axis ); 
	  __DBGpr_vec ( "\txaxis", xaxis );
	  __DBGpr_vec ( "\tx1axis", x1axis );
	  
	  for( i=0 ; i<3 ; i=i+1 ) x1axis[i] = x1axis[i] * -1.0 ;
	  __DBGpr_vec ( "\tx1axis", x1axis );
	  
	  dValue = BSdotp( &bsrc, xaxis, x1axis );
	  __DBGpr_dbl( "\tdValue ", dValue );

          /* 
           * etl#9134 -
           * 0.5 degrees is the tolerance angle of deviation
           * b/w the top and bottom flange directions for
           * taking the top flange as the new reference
           */

	  if ( fabs( dValue ) < cos((0.5*M_PI)/180.0) ) { 
	    __DBGpr_com(" Accept Sup flange as reference ");
	    xaxis[0] = x1axis[0];
	    xaxis[1] = x1axis[1];
	    xaxis[2] = x1axis[2];
	    
	    BSnorvec ( &bsrc, xaxis ); 
	    BSnorvec ( &bsrc, yaxis ); 
	    msg = MSFAIL; BScrossp ( &bsrc, xaxis, yaxis, zaxis ); 
	    if (bsrc != BSSUCC) goto wrapup;
	    BSnorvec ( &bsrc, zaxis ); 
	    msg = MSFAIL; BScrossp ( &bsrc, zaxis, xaxis, yaxis ); 
	    if (bsrc != BSSUCC) goto wrapup;
	  }
	
	}	
	/* Find zaxis */
	msg = MSFAIL;
	BScrossp ( &bsrc, xaxis, yaxis, zaxis );
	if (bsrc != BSSUCC) goto wrapup;
	BSnorvec ( &bsrc, zaxis );
	if (bsrc != BSSUCC) goto wrapup;
	__DBGpr_vec ( "\tzaxis", zaxis );
	
	/* Construct coordinate system */
	for ( i=0; i<3; i=i+1) {
	        j = 4 * i;
		cs_sys.matrix[j]   = xaxis[i];
		cs_sys.matrix[j+1] = yaxis[i];
		cs_sys.matrix[j+2] = zaxis[i];
		cs_sys.matrix[j+3] = origin[i];
	}
	cs_sys.matrix[12] = cs_sys.matrix[13] = cs_sys.matrix[14] = 0.0;
	cs_sys.matrix[15] = 1.0;

	cs_sys.diag_pt1[0] = cs_sys.diag_pt1[1] = cs_sys.diag_pt1[2] =0;
	cs_sys.diag_pt2[0] = cs_sys.diag_pt2[1] = cs_sys.diag_pt2[2] =0;

	cs_args.desc    = NULL;
	cs_args.flag    = CS_CONNECT_TO_MGR | CS_NO_MAKE_ACTIVE;


	cst.class_attr = (IGRchar *)&cs_args;
	cst.geometry = (IGRchar *) &cs_sys;

	GRidList.osnum = MOD_ENV.md_id.osnum;
	ci$send ( msg = message GRgencs.GRconstruct ( &cst ),
			targetid = GRidList.objid,
			targetos = GRidList.osnum );

wrapup :
	/* Delete detailed representation beam */
	for ( i=0; i<2; i=i+1 ) {
		if (DeadBook[i])
			gr$delete_object ( msg	     = &loc_msg,
					   object_id = &Object[i].obj_id,
					   md_env    = &Object[i].mod_env );
	}

	/* Deallocate memory */
	if (ext_srf_to_int) {
		om$dealloc ( ptr = ext_srf_to_int );
		ext_srf_to_int = NULL;
	}

	/* Return completion code */
	if (sts & 0x00000001 & msg)	return OM_S_SUCCESS;
	else				return OM_E_ABORT;
}
/* ========================================================================= */
init()
{
	return OM_S_SUCCESS;
}
/* ========================================================================= */
wakeup()
{
	return OM_S_SUCCESS;
}
/* ========================================================================= */
