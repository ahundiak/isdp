________________________________________________________________________________

		Syntax of the program of the Structural Selector
		( Command "Place Structural Selector", VSPlStSl )
________________________________________________________________________________

		A Structural Selector is an object allowing to insert some
	decision-making when creating an end-treatment. That is an end-
	treatment may behave differently at placement and recompute time
	depending upon its context : if beams or plates are involved, depending
	upon the beam type ( tee, channel, etc. ).

		To this purpose a Structural Selector allows the user to
	specify tests upon a list of input objects and to output objects
	which are results of the decision making-process (the "program").

	1) Input
		A Structural Selector accepts up to ten (10) input objects
	which may be:

		- plates
		- beams
		- expressions (text or real value)
		- any macro occurrence

	2) Output
		A Structural Selector may generate up to ten (10) output
	objects which may be

		- expressions (text or real value)
		- graphics

		The number of outputs may vary between 0 and 10, ie.
	it may be 2 in some circumstances and then be 5 in others.

	3) The program
	a) Assigning aliases to the input objects.

		One firstly must assign names (aliases) to the incoming
	objects, so that they can be subsequently referred to in the program
	body.
		The assignment syntax is as follows:

		input <n> = <name>

		where :	<n> is an integer value ( 0 through 9 )
			<name> is an identifier of at most 63 characters
			       made of alphanumeric character ( 'a' through
			       'z', 'A' through 'Z', '0' through '9' ),
			       or '_' (underscore) , and starting with a
			       letter or '_'.

		Eg.
			input 0 = horizontalbeam
			input 1 = verticalbeam
			input 2 = connexiontype

		or
			input 0 = structobject
			input 1 = construction

		The different inputs may then be referred to as
		'horizontalbeam', 'verticalbeam', etc. in the program body

	b) Creating the program body

		A program body is essentially made of test instructions,
	generating a different output at each tests.

	i) Syntax of a test instruction

			if <condition> then
				<action 1>
			endif

	or		if <condition> then
				<action 1>
			else
				<action 2>
			endif

	An action may be another test (nested if's) :

			if <condition 1> then
				if <condition 2> then
					<action 1>
				else
					<action 2>
				endif
			else
				<action 3>
			endif

	One may also have sequences of else-if's

			if <condition 1> then
				<action 1>
			else 
				if <condition 2> then
					<action 2>
				else
					if <condition 3> then
						<action 3>
					else
						<action 4>
					endif
				endif
			endif

	NOTE: the indentations and newlines above are put for readability:
	the program has a free format, eg.

		if <condition> then <action 1> else <action 2> endif

	is also perfectly valid. In other words, blanks, tabs and newlines
	are all treated as spaces.				

	The conditions above are logical (boolean) expressions of which
	the syntax is described below.

	ii) Conditions

		A condition may be

		- a test of a value with a relational operator
		- a test of the type of an object with a test-type function
		- a complex expression made of simple tests and logical
		operators.

	The available relational operators are the usual ones:

		=	equal
		!=	not equal
		<	less than
		<=	less than or equal to
		>	greater than
		>=	greater than equal to

	The available logical operators are the usual ones:

		| or "or"	( | = vertical bar )
		& or "and"	( & = ampersand )
		! or "not"	( ! = exclamation mark or "bang" )

	The test-types functions are

		beam( <input arg> )
		plate( <input arg> )
		%<macro name>%( <input arg> )

	where :	<input arg> is the alias of an input object
		<macro name> is the name of a macro definition

	Eg.
	(A)	input 0 = object

		if beam( object ) then
			...	# 'object' is a beam
		else
			if plate( object ) then
				...	# 'object' is a plate
			else
				if %box%( object ) then
					... # 'object' is an occurrence of a
					    # macro of name "box"
				endif
			endif
		endif

	(B)	input 0 = object
		input 1 = expr1
		input 2 = expr2

		if beam( object ) then
			if expr1 < 3 | expr1 > 5. then
				...
			else
				if expr2 = 4 or expr2 = 7 then
					...
				endif
			endif
		else
			...
		endif
				
	iii) Accessing internal values ( "attributes" ) of objects

		In order to test, say, the family of a beam or
	plate, one proceeds as follows:

		input 0 = in_beam
		if in_beam:family_name = "wtee" then
			...
		else if in_beam:family_name = "wshape" then
			etc.

		The attribute "family_name" may be found in the Directory
		Form. All listed attributes in this form are usable.
		The "Place Structural Selector" command allows in
		conjunction with the "Review Structural Part Definition"
		to visualize and get those attributes more easily
		( see 4)3. below ).

	iv) Retrieving the display representation of an object

		The function "representation" returns the display representation
	of an object which supports it, and returns it as a character string :

			"representation" ( <object> )

	 Possible values :
			"2d"	: 2d (symbolic) representation
			"3d"	: 3d representation
			"env"	: envelop representation
			""	: no representation or object does not support
				  display representation.

	  Beams, plates and some associative complexes ( also named associative
	  constructions or macros ) support the display representation.

	Example
			input 0 = hbeam

			if representation( hbeam ) = "2d" then
				...
			else
				...
			endif
 
	v) Finding the distance between graphic objects

		The function "distance" returns the distance between two
	objects (among point, curve or surface) as a double floating point
	value:
			"distance" ( object1, object2 )

	Example:

	input 0 = element
	input 1 = point

	if beam(element) then
		# if input element is a beam, then output web side closest
		# to input point
		if    distance(point,element:beam:body:web_____l)
       		    < distance(point,element:beam:body:web_____r) then
			output element:beam:body:web_____l
    		else
			output element:beam:body:web_____r
	        endif
	 else if plate(element) then
		# if input element is a plate, then output plate side closest
		# to input point
	        if   distance(point,element:plate:base)
		   < distance(point,element:plate:offset) then
			output element:plate:base
		else
			output element:plate:offset
	        endif
	       else 
		# else output input element itself.
		output element
	       endif
	endif

	Note that this function does not consider line segments and planes
	as infinite.

	vi) Generating output

		As has been said before, the outputs generated may either be
	graphics or expressions. Those outputs are to be used by other
	constructions.

		If it is an expression, it may either be text or double
		floating points.
		The graphics produced are graphics extracted from the
		input, that is one may extract the left web surface from
		a beam or the top surface of a plate or some graphic foot
		of any macro.

		The syntax for outputting something is

			output <something>

	Eg.
		output "text"
		--> outputs a text expression whose value is text

		output 3
		--> outputs a DFP expression whose value is 3

		output in_beam:x_Width
		--> outputs a DFP expression whose value is width of the
		    beam's cross-section

		output in_beam:body:flg_sup_e
		--> extracts the exterior superior flange (a surface) of the
		    beam

	The different outputs are labeled by the Structural Selector as
	"output0", "output1", "output2", etc.

	Thus a program needing to extract either a beam face of a plate face
	(to be used later by another construction) would be

		input 0 = structPart
		if beam( structPart ) then
			output structPart:body:flg_sup_e
		else
			if plate( structPart )  then
				output structPart:base
			endif
		endif

		And "output0" will either be exterior superior flange if
	"structPart" is a beam or the bottom surface if "structPart" is
	a plate.

	vii) Extended syntax of the test-type function %<macro name>%()

		To test the type of a input objects one often wishes to
	cover several similar macros, eg. if we allow "a" to be an occurrence
	of either "MAC1", "MAC2", "MAC3", ..., "MACn" which are all almost
	the same kind of macros (that is having the same kind of attributes
	for our purposes) one may code:

		if %MAC1%( a ) or %MAC2%( a ) or %MAC3%( a ) then ...

	which may be tedious. The "%<macro name>%()" syntax allows the
	use of meta-characters in the <macro name>, thus the above test
	may be rewritten:

		if %MAC*%( a ) then ...
	or	if %MAC[1-3]%( a ) then ...

	The possible meta-characters are the following:

		?	: matches one character
		*	: matches 0 or more characters
		[]	: matches one character among the list between [ and ]
		-	: inside [] : [a-z] matches one character between 'a'
			  and 'z'.
		\	: removes meaning of the following meta-character:
			  "\*" matches '*'.
	Example :

		%cpx[AB][1-3]%( object )

	will be TRUE if "object" is of type cpxA1, cpxA2, cpxA3, cpxB1, cpxB2,
	cpxB3, else FALSE.

	4) The "Place Structural Selector" command
	
	5) Notes
	i)
		The keywords
			"if"
			"then"
			"else"
			"endif"
			"not"
			"and"
			"or"
			"output"
			"input"
			"beam"
			"plate"
			"representation"
			"distance"

		are local language-independent since they are read from
		a message file. Hence a German version of I/STRUCT would
		recognize their German counterparts.

	ii) Comments may be specified anywhere in the program by a "#"
	(sharp sign, pound sign), after a "#" the characters are disregarded
	until the end of the line (as in the "shell").
