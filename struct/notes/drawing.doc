
	Automatic Process For Extracting eLements :
	STRUcture's Drawing Extraction Language (APFEL-STRUDEL) Manual
	--------------------------------------------------------------

			--- TABLE OF CONTENTS ---

	I   Introduction

	II  Name and location of the STRUDEL file

	III Organization of a STRUDEL file
	     A) View types
	     B) Syntax for selection on element type
	     C) Transfer of attributes to drawn element
	     D) Syntax for selection on view type
	     E) Example
	     F) View types for constructions
	     G) Tuning the view cone angle

	IV  Specification of element representation in drawing sheet
	     A) Beam and stiffener
	     B) Plate
	     C) Joint
	     D) Construction
	     E) Syntax
	     F) Display attributes
		i )  Color
		ii)  Style
		iii) Weight
		iv)  Level
		v)  Hidden style
		vi)   Filled display
		vii)  Scale
		viii) Offset
	    G) Examples

	V   Specification of symbol to be placed next to drawn element
	    A) Syntax
	    B) Display attributes
	    C) Justification
	    D) Width
	    E) Height
	    F) Size
	    G) Position
		i)   "top", "bottom", "left", "right"
		ii)  "center", "middle", "innermost"
		iii) "at-first-end", "at-second-end"
		iv)  "above", "below", "to-the-left", "to-the-right",
		     "offset"
		v)   "parallel", "orthogonal", "horizontal"
		vi)  "upside-down", "right-to-left", "not-reversed"
	    H) Font
	    I) Format
	    J) Available global text values
	    K) Use of an anchor point or an anchor curve
	    L) Examples

	VI  Expressions and operations

	VII Constant values

	VIII Functions
	    A) Accessing attributes of the element
	    B) Finding the direction of the profile and beam
	    C) Formatting numbers for text output
	    D) Finding whether a plate or a beam is hidden by another
	    E) Finding on which side of the plate the matter is
	    F) Finding the elements joined by a weld
	    G) Finding the type of an element
	    H) Finding if two plates are parallel
	    I) Finding if the element is clipped by the view plane
	    J) Retrieving the scale of the element
	    K) Retrieving the type of a construction
	    L) Finding an input element from which an element was
	       constructed
	    M) Finding a member of an element
	    N) Matching a string against a regular expression
	    O) Projecting a curve onto the drawing sheet
	    P) Finding the end point of a curve closest to an element
	    Q) String manipulation functions
	     - Duplicating a character string
	     - Concatenating strings
	     - Computing the length of a character string
	     - Getting the count of word in a string
	     - Getting a word in a string
	     - Extracting a sub-string from a string
	     - Substituting a sub-string by another
	     - Getting the time and date
	    R) Intersection a curve with the view plane
	    S) Getting the basename of an element
	    T) Mapping ship locations to drawing sheet
	    U) Obtaining information from the relational data base

	IX  Conditionals
	    A) Syntax
	    B) Example

	X   Variables

	XI  Manipulating the relational data base

	XII Debugging

	XIII File inclusion

	XIV Definition of the language
	   A) List of keywords
	   B) Syntax

	XV Hints
	   A) How to annotate a plate according to the matter side
	   B) How to have subscripts and superscripts in text
	   C) How to underline text
	   D) How to annotate a construction for a hole
	   E) How to represent a construction by a symbol


                                           //
                                          //
                                 @ @@@    ||  @@@ 
                              @@@@ @  @@      @   @  
                             @   @ @   @ @@@@ @@@ @   
                            @@@@@@ @@@@  @    @   @    
                           @     @ @     @@   @   @
                          @      @ @     @    @@@ @@@@@
                           *****=====*** |  |*** ===*   
                            *     |  *  *|  |*  *|  *  
                             ***  |  *  *|  |*  *|= **
                               *  |  *** |  |*  *|   
                              **  |  * * |  |*  *===
                                  |  *  * == *  * 
                                     *       ***


	I Introduction
	--------------

		STRUDEL is a simple language allowing the user to specify
	how structural elements should be extracted from the model to be
	drawn in the drawing file ( referred to as `drawing sheet' ).

		For each structural entity (plate, beam, stiffener, joint)
	and depending how the entity is viewed, STRUDEL proposes a set of
	representations for these entities to be output to the drawing sheet.

		STRUDEL also allows to output "constructions", that is
	occurrences of macros to the drawing sheet.

		Moreover, STRUDEL contains tools to place text (this en-
	compasses symbols, as long as they are in a font) next to the drawn
	elements.

		As each entity is being extracted, it will interpret the
	STRUDEL file to take the ad hoc actions.

		The syntax of STRUDEL is format-free: spaces, newlines and
	tabulations may be inserted anywhere between syntactic entities.
	Comments start with a `#' (sharp sign/pound sign); when a '#' is
	encountered, what follows is ignored up to the end of the line.

	In what follows the following vocabulary will be used

	Drawing sheet : the (active) file where elements are drawn
	Top, bottom, left, right, horizontal, vertical (of drawing sheet):
	directions on the drawing sheet considered as a sheet of paper on a
	table.

	Construction: an occurrence of a macro.

	II Name and location of the STRUDEL file
	----------------------------------------

		The STRUDEL file shall have the name "setup" and shall be
	either in any of the config/drawing directories of the product path
	or in the current directory.

		When run from I/STRUCT, the search order will be

			./setup
			<user-path>/config/drawing/setup
			$STRUCT/config/drawing/setup
			$VDS/config/drawing/setup
			...
	the first setup file found will be interpreted.

	III Organization of a STRUDEL file
	----------------------------------

		A STRUDEL is organized as follows :

	Selection on element type 1

		Selection on view type 1
			Actions
		Selection on view type 2
			Actions
		etc.

	Selection on element type 2

		Selection on view type 1

		etc.
	etc.

	Where element type <n> is any among plate, beam, stiffener, joint,
	construction (not all types need to be selected) and view type <n>
	is any among (seen from) top, bottom, side, end-on, unknown-view,
	any-view ( not all view types need to be specified).

	Actions have to be separated by a `;' (semi-colon) :

		<action> ; <action> ; <action>

	A) View types

		View types are not referring to window views but are
	relative to the elements, e.g. for a beam or a stiffener

		  TOP                               TOP
		   |                                 |
		   v                                 v
		+-----+			   +--------------------+
		| +---+			   +--------------------+
	SIDE -> | |	<- SIDE  END-ON -> |                    | <- END-ON
		| |			   |                    |
		| |			   |                    |
		+-+			   +--------------------+
                   ^                                 ^
                   |                                 |
	        BOTTOM                            BOTTOM

	TOP    is when its support surface is behind it
	BOTTOM is when its support surface is before it
	SIDE   is when viewed parallel to its support
	END-ON is when viewed parallel to its axis

	B) Syntax for selection on element type

	<element type> : { ... }

	where <element type> : "plate" or "beam" or "stiffener" or "joint"
	                       or "const( <args> )"

	"const" needs two arguments: one to specify the type of the macro
	occurrence for which the subsequent code must be executed, and one
	to specify what to use inside the construction as a view criterion
	since STRUDEL does know what the construction is made of. The type
	of the macro is the name of the macro definition from which the
	construction was placed. The view criterion is a graphic member of
	the construction ( an "output" ) which will be used to determine
	the view type. The selection on a "const" must thus be specified as
	follows :

	const ( definition = <name of macro definition> ,
		view-criterion = <(path)name of an output> ) : { ... }

	Examples :
		For a macro whose definition name is "hole" and whose output
		to use as a view criterion is "curve" :
	
		const ( definition = "hole", view-criterion = "curve" ) : {
			...
		}

		If the macro is made of nested macros, the pathname down the
	nesting must be used for the view criterion :

		const ( definition = "hole",
			view-criterion = "mac1:mac2:curve" ) : {
			...
		}

		The logic for setting view types for constructions is ex-
	plained in III E).

		To catch families of constructions which are alike, regular
	expressions are allowed for the keyword "definition", e.g. to catch
	all the constructions of type "hole1", "hole2", etc. it may be
	specified :

		const ( definition = "hole*", view-criterion = "curve" ) : {
			...
		}

	The regular expressions have the same syntax as those of the UNIX
	shell. Beware that if you use regular expressions, all the
	constructions which will be selected must have the same view
	criterion. Also beware that you may catch more constructions than
	you intend to.

	One may wish to catch a family of construction with a regular ex-
	pression but have members to be used as view criteria which are
	different for each construction in the family. For example, in the
	family "hole*" we could have member "curve" which should be the view
	criterion for "hole1", "hole2", "hole3"; "crv" for "hole4", "hole6",
	"crv1" for "hole5" and "result:curve" for "hole7", "hole8". Instead
	of writing the same code multiple times :

	const ( definition = "hole[1-3]", view-criterion = "curve" ) : {
			...
	}
	const ( definition = "hole[46]", view-criterion = "crv" ) : {
			...
	}
	const ( definition = "hole5", view-criterion = "crv1" ) : {
			...
	}
	const ( definition     = "hole[78]",
		view-criterion = "result:curve" ) : {
			...
	}

	this can be condensed in :

	const ( definition	= "hole*",
		view-criteria	= "hole[1-3]" / "curve",
				  "hole[46]"  / "crv"
				  "hole5"     / "crv1"
				  "hole[78]   / "result:curve" ) : {
			...
	}

	in which the definition "hole*" will catch all constructions begin-
	ning with "hole", then for each sub-type a different member will
	be used as a view criterion.

	If a regular expression has been used to specify the definition, the
	function "const-type()" may be used to know exactly what is the type
	of the construction being processed [see VIII K].

	C) Transfer of attributes to drawn element

	When an element in the model is extracted to a drawing sheet an
	associative complex is created in the drawing sheet file which
		- will depend upon the element in the 3d model
		- will own all the graphics generated to represent the
		  3d element on the drawing sheet.

	The type of this associative complex must be defined just after
	the selection on element type; the type is just a name which the
	system will assign to all complexes representing 3d elements of
	the same type.
 
	Additionally some information may be transferred from the 3d element
	to its drawing sheet representation (parameters), the name of the
	parameters to transferred are then specified at the same time as
	the type for the associative complex.

	Example :

	If you want beams to be represented by a complex of type "drw_beam" :

		beam : {
			extract as "drw_beam" ;
			...
		}

	If you want some beam attributes to be available in the drawing
	sheet, e.g. the family name and part number of the beam :

		beam : {
			extract as "drw_beam" with "family_name",
						   "part_num" ;
			...
		}

	Extracting a construction and transferring its radius :

		const ( definition = "hole*", view-criterion = "curve" ) : {

			extract as "drw_hole" with "radius" ;
			...
		}

	The type name following "extract as" must not exceed 15 characters.
	If no "extract as ... with ..." statement is present, the VDS
	command "Extract Drawing" will try to find and read a "DrawingTable"
	file in a config directory as it used to do.
	Note that if no "extract" statement is present for an element type
	and that element type is not specified in the "DrawingTable" file
	then the command "Extract Drawing" will not accept elements of that
	type.
	
	D) Syntax for selection on view type

	<view types> : { ... }

	
	where	<view types> :  <view type>
			     or <view type>, <view type>, ...

		<view type> : "top", "bottom", "side", "end-on",
		              "unknown-view", "any-view"

	If actions are the same for several views, they may be grouped,
	as in

	top, bottom : { ... }

	"unknown-view" catches anything that is not standard (top, bottom,
	etc.).

	"any-view" catches all views.

	E) Example

	beam :
	{
		top, bottom : # Same actions for top and bottom.
		{
			...
		}
		end-on :
		{
			...
		}
	}

	F) View types for constructions

		If the view criterion is a point the view type will be set
	to be "end-on".

		If the view criterion is a line segment the view type will be
	set to "end-on" if the line segment is parallel to the view vector,
	otherwise it will be set to "side".

		If the view criterion is a planar curve or a plane the view
	type will be set to "bottom" if the view vector is parallel to the
	normal of the plane, "top" if the view vector is anti-parallel to
	the normal of the plane, "side" if the view vector is orthogonal to
	the normal of the plane, "unknown-view" in all the other cases.

		If the view criterion is a non-linear non-planar curve the
	view type will be set to "side".

		If the view criterion is a non-planar surface the view
	type will be set to "bottom" if the view vector is parallel to the
	normal of the surface at u = v = 0.5, "top" if the view vector is
	anti-parallel to the normal of the surface at u = v = 0.5, and
	"unknown-view" in all the other cases.

	G) Tuning the view cone angle

		In order to catch free-form surfaces more easily, STRUDEL
	allows to set the view cone angle :
	 
	         /					.free-form surface
	        /\					.
	  eye <)  ) angle  -- view vector -->          .\
	        \/					.\
	         \					. \ normal at u=v=0.5
	          view cone

	With a view cone angle of 0 degrees, the normal of the surface is
	not parallel to the view vector. STRUDEL considers a vector to be
	parallel to the view vector if it is within a cone around the view
	vector. Setting the view cone angle large enough above will cause
	STRUDEL to consider normal of the surface to be parallel to the view
	vector and set the view to "bottom".

	The statement for setting the view cone angle is :

		set view-cone-angle <angle in degrees>

	and may be placed before a selection on the element type.

	Example :

		set view-cone-angle 10 ;
		beam : {
			...
		}

		set view-cone-angle 20 ;
		const ( definition = "cut_out", view-criterion = "surf" ) {
			...
		}

	By default (that is unless a "set view-cone-angle" statement has
	been put in the file) STRUDEL uses a view cone angle of 40 degrees.
	Several "set view-cone-angle" statements may appear in the STRUDEL
	file to redefine the angle in different locations.

	IV Specification of element representation in drawing sheet
	-----------------------------------------------------------

	A) Beam and stiffener

	"projection"	: project beam onto drawing.
	"axis"		: draw axis of element onto drawing.
	"profile"	: draw profile of beam onto drawing.
	"intersection"	: as "profile" above

	B) Plate

	"projection"	: project plate onto drawing. 
	"intersection"	: intersect plate and plane of view then project
	                  intersection onto drawing.
	"contour"	: draw contour of plate onto drawing (will not
			  output inside holes)
	"edge"		: draw edge of plate onto drawing

	C) Joint

	"weldline"	: draw weld line onto drawing(may amount to
			  a point if seen end-on)

	D) Construction

	"member" ( <(path)name of an output> ) : projects the output onto
						 the drawing.

	E) Syntax

	   <representation>
	or <representation> [ <display-attributes> ]

	<display-attributes> :  <display-attribute>
			     or <display-attribute> , <display-attribute>, ...

	<display-attribute>  :  <attribute>
			     or <attribute> = <value>

	where	<representation> is among those specified in A), B) and C).
		<display-attributes> are attributes for the display of
		the drawn element in the drawing sheet.
		
	F) Display attributes

	<attribute> is one among "color", "style", "weight", "level",
				 "filled-display", "hidden-style",
				 "scale" (for "profile" only),
				 "offset" (for "axis" only )

	i) Color

		May be specified by name (red, green, blue, yellow, cyan,
	etc.) or by number:

		color = "red"
		color = 3

		If "color" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid name or number (not between 0 and 511) is specified.

	ii) Style

		Specifies the style for the visible lines of the drawn
	element and is an integer:

		style = 1

		If "style" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid number (not between 0 and 255, system styles being from
	0 to 7 and user-defined styles from 8 up) is specified.

	iii) Weight

		Must be specified as an integer :

		weight = 2

		If "weight" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid number (not between 0 and 31) is specified.

	iv) Level

		Must be specified as an integer :

		level = 3

		If "level" is not specified, that of the element in the model
	which is being extracted will be used, it will also be the case if
	an invalid number (not between 0 and 1023) is specified.

	v) Hidden style

		Specifies the style for the hidden lines of the drawn element.

		See ii) for values.

	vi) Filled display

		Specifies that element should have its display filled :

		filled-display (no value)

	This will only be taken into account if the element is a closed curve.

	vii) Scale

		When output the beam profile may be scaled to make it stand
		out on the Drawing Sheet :

		profile [ scale = 2, ... ]

	viii) Offset

		When drawing the axis of a beam, allow to specify an offset
	distance: the axis will be translated by this distance along the
	x-direction of the profile, for instance to translate the axis by
	half the width of the beam :

			<---width--->
			+-----------+
			|           |
			+---+   +---+
			    |   |
			    |   |
			    |   |       ^y
			    |   |       |
			.   +---+	+-->x
			axis

	Set
			axis [ offset = attribute( "x_Width" ) * 0.5, ... ]

	A negative offset will translate the axis in the other direction.
	Note that if the beam is in a reference file ith has been attached
	with a scale different from one, the value of the offset will be
	scaled too.

	G) Examples

		beam :
		{
			end-on :
			{
				profile [filled-display]
			}
		}
	or
		beam :
		{
			end-on :
			{
				profile [weight=2,color="blue"]
			}
		}

		const ( definition = "hole", view-criterion = "curve" ) :
		{
			top, bottom :
			{
				member( "curve" ) [
					style = 1,
					weight= 1
				]
			}
		}

	V Specification of symbol to be placed next to drawn element
	------------------------------------------------------------

		By symbol we mean text, a radius symbol being a character
	in a special font.

	A) Syntax

	<symbol-placement> : "symbol" [ <symbol-attributes> ]

	<symbol-attributes> :  <symbol-attribute>
			    or <symbol-attribute> , <symbol-attribute> , ...

	<symbol-attribute>  :      <display-attribute>
			    and/or <text-attribute>

	<text-attribute> : <format>
                           <font>
                           <justification>
			   <size>
			   <width>
			   <height>
			   <position>

	B) Display attributes

		"color", "weight", "style" whose logics are the same as those
	developed in IV E) i), ii) and iii).

	C) Justification

		If not specified, a justification will be chosen by the sys-
	tem according to the context (element being drawn, text position,
	etc.). If specified the system's choice will be overridden.

	<justification> : "justification" = <value>
	<value> : "LEFT-BOTTOM"		(1)
		  "LEFT-BASE"		(2)
		  "LEFT-CENTER"		(3)
		  "LEFT-CAP"		(4)
		  "LEFT-TOP"		(5)
		  "CENTER-BOTTOM"	(6)
		  "CENTER-BASE"		(7)
		  "CENTER-CENTER"	(8)
		  "CENTER-CAP"		(9)
		  "CENTER-TOP"		(10)
		  "RIGHT-BOTTOM"	(11)
		  "RIGHT-BASE"		(12)
		  "RIGHT-CENTER"	(13)
		  "RIGHT-CAP"		(14)
		  "RIGHT-TOP"		(15)

	These values are exactly those of the text in I/EMS :


		5------------10----------15
		4------------9-----------14
		3 textextext 8 textextex 13
		2------------7-----------12
		1------------6-----------11

	D) Width

		Specifies the width of the text (floating-point value) :

		width = 2
		width = 4.5

	If not specified the Active Text Width will be used.

	E) Height

		Specifies the height of the text (floating-point value) :

		height = 2
		height = 4.5

	If not specified the Active Text Height will be used.

	F) Size

		Sets the width and height at the same time (floating-point
	value) :

		size = 2
		size = 4.5

	G) Position

	<position> : "position" ( <pos-attributes> )
	<position-attribute> :   <pos-attribute>
			      or <pos-attribute> , <pos-attributes> , ...

	<pos-attribute> : "top"					(A)
			  "bottom"				(A)
			  "left"				(A)
			  "right"				(A)
			  "at-first-end"			(A)
			  "at-second-end"			(A)
			  "center"				(A)
			  "middle"				(A)
			  "innermost"				(A)
			  "above" ( <value> )		
			  "below" ( <value> )
			  "to-the-left" ( <value> )
			  "to-the-right" ( <value> )
			  "offset" ( <direction> , <value> )
			  "horizontal"				(B)
			  "parallel"				(B)
			  "orthogonal"				(B)
			  "not-reversed"
			  "upside-down"
			  "right-to-left"

	All (A)'s and all (B)'s are mutually exclusive.

	i) "top", "bottom", "left", "right"

		At the top, bottom, left, right of the drawn element (these
	directions are understood from the drawing sheet point of view) :

		           TOP				TOP
		LEFT --------------- RIGHT               |
		          BOTTOM                    LEFT | RIGHT
							 |
                                                       BOTTOM

	ii) "center", "middle", "innermost"

		If the drawn element is an open curve, "center" and "middle"
	both coincide with the midpoint; if it is a closed curve, "center"
	is the center of the curve and middle its midpoint (wherever it is)

		-----CENTER-----	+-MIDDLE--------+
					|		|
		-----MIDDLE-----	|    CENTER	|
					|		|
					+---------------+

		"innermost" is the most interior point to a curve, that is
	the point surrounded by as much area as possible; "innermost" is
	different from "center" in that in lies always inside the closed
	planar curve whereas "center" may be outside.

	iii) "at-first-end", "at-second-end"

		The first and second end of drawn element are

	        | Element is horizontal | Element is vertical
	--------|-----------------------|------------------
	1st end	| leftmost end          | uppermost end
	2nd end | rightmost end         | lowermost end

		FIRST END --------------- SECOND END	FIRST END
							    |
							    |
							SECOND END

		If none of "top", "bottom", "left", "right", "center",
	"middle", "innermost", "at-first-end", "at-second-end" is specified,
	then "center" will be used.

	iv) "above", "below", "to-the-left", "to-the-right", "offset"

		Specifies an additional offset distance from the position:

				       ABOVE
                                         +
			TO THE LEFT + position + TO THE LEFT
					 +
                                       BELOW

	A value ( floating-point value) must be specified :

		above( 1 )
		to-the-left( 3.4 )

	"offset" groups "above", "below", "to-the-left" and "to-the-right"
	together :

	offset( top   , <value> ) is equivalent to above( <value> )
	offset( bottom, <value> ) is equivalent to below( <value> )
	offset( left  , <value> ) is equivalent to to-the-left( <value> )
	offset( right , <value> ) is equivalent to to-the-right( <value> )

	By default, no offsetting is performed.

	v) "parallel", "orthogonal", "horizontal"

		Specifies the direction of the text with respect to the
	element it is placed nearby:

						^
		PARALLEL --->		        | ORTHOGONAL
		------------------	------------------

	If neither "parallel" or "orthogonal" is specified, the text will
	be placed horizontal.

	vi) "upside-down", "right-to-left", "not-reversed"

		Will reverse the text either upside down :

		xxxxxxx                   x
                x                         xxxx
                xxxx      -upside down->  x
                x                         xxxxxxx

	or right to left

		xxxxxxx                     xxxxxxx
                x                                 x
                xxxx      -right to left->     xxxx
                x                                 x

		By default, text is written left to right and top down,
	that is "not-reversed".

	H) Font

		Specifies the font to be used for text: a character string
	containing the name of a physical font :

		font = "myfont"
		font = "102"

		If not specified, the default font (whose name is "default")
	will be used.

	I) Format

		The format attributes allow to specify the text string to
	be output, but also to embed text commands for a more sophisticated
	text.

	<format> : "format" = ( <commands-or-strings> )
	<commands-or-strings> :  <command-or-string>
			      or <command-or-string>,
			         <command-or-string> , ...

	<command-or-string> : <command>
			      <string>

	To output "ABC" :
			format = ( "ABC" )

	Note that empty text will not be placed, i.e.

			format = ( "" )

	will not construct a text.

	Commands allow to move the cursor inside the text, change font,
	define fields, move to those fields :

	<command> : "UP" ( <value> )
		    "DOWN" ( <value> )
		    "RIGHT" ( <value> )
		    "LEFT" ( <value> )
		    "SCALE" ( <value> )
		    "FONT" ( <physical-font-name> )
		    "START-FIELD"( <field-number> )
		    "END-FIELD"
		    "MOVE-TO-FIELD"( <field-number>, <justification-point> )

	UP     : moves cursor up    by <value> (floating-point value)
	DOWN   : moves cursor down  by <value> (floating-point value)
	RIGHT  : moves cursor right by <value> (floating-point value)
	LEFT   : moves cursor left  by <value> (floating-point value)
	SCALE  : scales following text by <value> (floating-point value)
	FONT   : changes font for the following text
	START-FIELD   : starts field number <field-number> (integer 0-255)
	END-FIELD     : ends last-started field
	MOVE-TO-FIELD : moves cursor to field <field-number> ( supposed
			previously defined by a START-FIELD/END-FIELD
			sequence ) and positions cursor at
			<justification-point> (one among LEFT-BOTTOM, etc.
			defined at V C) ).

	For instance, to output :

		      I am upstairs
		Hello
		      I am downstairs

	Use
	format	= (
		    START-FIELD( 0 ),		      # Start field 0
		    "Hello",			      # Fill it with "Hello"
		    END-FIELD,			      # End field 0
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ), # Go back to field
		    UP( 0.5 ),			      # Move up
		    "I am upstairs",		      # Say "I am upstairs"
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ), # Go back to field
		    DOWN( 0.5 ),		      # Move down
		    "I am downstairs"		      z# Say "I am downstairs"
		   )

	Which amounts to the following cursor movement :

			 ^ UP I am upstairs ----->-----------+
		+-------+|				     v
		| Hello |<- MOVE TO FIELD 0, RIGHT CENTER <--+
                +-------+|
		^       ^v DOWN I am downstairs
		|       |
		|       END FIELD 0
		START FIELD 0

	J) Available global text values

		WIDTH, HEIGHT : always set to the current text width and
	height

		LEFT-BOTTOM	: 1
		LEFT-BASE	: 2
		LEFT-CENTER	: 3
		LEFT-CAP	: 4
		LEFT-TOP	: 5
		CENTER-BOTTOM	: 6
		CENTER-BASE	: 7
		CENTER-CENTER	: 8
		CENTER-CAP	: 9
		CENTER-TOP	: 10
		RIGHT-BOTTOM	: 11
		RIGHT-BASE	: 12
		RIGHT-CENTER	: 13
		RIGHT-CAP	: 14
		RIGHT-TOP	: 15

	The example in i) may be rewritten so as to make it text-height
	dependent :

	format	= (
		    START-FIELD( 0 ),
		    "Hello",
		    END-FIELD,
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
		    UP( 0.5 * HEIGHT ),
		    "I am upstairs",
		    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
		    DOWN( 0.5 * HEIGHT ),
		    "I am downstairs"
		   )

	K) Use of an anchor point or an anchor curve

		There may be cases when a macro occurrence is to be repre-
	sented on the drawing sheet by a symbol and nothing else. In this
	case a point is needed to position the symbol, which must be relative
	to the macro occurrence. The statement "anchor-point" is available
	for extraction of macro occurrences and is evaluated with the help
	of an output (a "member"):

	const ( definition = "hole*", view-criterion = "curve" ) : {

		top : {
			# Use the center of member "curve" for subsequent
			# symbol placement.

			anchor-point( "curve", center ) ;

			symbol [ ... ]

			...
		}
		...
	}

		The syntax of the "anchor-point" statement is :

			anchor-point( <member>, <which-point> )
		or	anchor-point( <member> )

	Where <member>	    : a member of the macro occurrence.
	      <which-point> : specifies which point to use.

	There are currently 3 possible values for <which-point> :

		center
		center-of-gravity
		average-point

	anchor-point( <member> ) is equivalent to
	anchor-point( <member>, average-point )

	The following logic is used to evaluate the anchor point :

	a) If which-point is not specified or is 'average-point' the fol-
	   lowing will be done :
	- the range of the member will be computed
	- the center of the range box will be projected onto the
	  drawing sheet and will be taken as the anchor point

	This behavior above will of course give the expected result if the
	member is a point or a coordinate system since their range boxes
	are reduced to a point.

	b) If which-point is 'center' :
	- if member is a closed curve, its center will be computed and then
	  projected onto the drawing sheet, if it is not closed its mid-point
	  will be used.
	- if member is a point (or a coordinate system) the point (or the
	  origin) will be projected onto the drawing sheet.
	- if member is a surface, the point at u=0.5, v=0.5 will be projected
	  onto the drawing sheet.
	- if member is a solid or a composite surface, the center of the
	  range box will be used as in a)

	c) If which-point is 'center-of-gravity'
	- member is a point : use point as in a)
	- member is a coordinate system : use origin as in a)
	- member is a curve : use center as in b)
	- member is a surface or a solid : use center of gravity.

		There may be other cases when the symbol must be positioned
	with respect to a curve that will not be output to the drawing sheet.
	In this case the "anchor-curve" statement allows to specify a curve
	which will be used to position the text :

		The syntax of the "anchor-curve" statement is :

			"anchor-curve" ( <curve> )

	where <curve> is a curve obtained by means of the functions
	"get-input()", "get-member()" and then projected to the drawing
	sheet with the function "project-curve()" [see chapter VIII].

	Note: when outputting several members of a construction and asso-
	ciating a symbol with them, it is necessary to specify anchor-curve
	or anchor-point for each symbol output: if not anchor is specified,
	the symbol will by default try to position itself with respect to
	all the curves which have been previously output:

		member( "m1" ) [ weight = 1 ] ;
		anchor-curve( get-member( "m1" ) ) ;
		symbol [ ... ] ;

		member( "m2" ) [ weight = 1 ] ;
		anchor-curve( get-member( "m2" ) ) ;
		symbol [ ... ] ;

	L) Examples

	- Outputting text parallel to element

		symbol [	format	= ( "Hello" )
				position= (at-first-end,parallel),
				color	= "green",
				weight	= 1,
				size	= 3
			]

	- Outputting arrows at both ends of element
 	  The arrowhead symbol ( ">" ) is character "A" of font "102"; this
	  font does not provide the reverse arrowhead ( "<" ), hence we must
	  include the reversal as a position modifier.

		# Output ">"
		# - At 1st end of element
		# - // to element
		# - right to left (reversal)
		symbol	[
				format		= ("A"),
				font		= "102",
				position	= (at-first-end,
						   parallel,
						   right-to-left)
			] ;
		# Output ">"
		# - At 2nd end of element
		# - // to element
		symbol	[
				format		= ("A"),
				font		= "102",
				position	= (at-second-end,parallel)
			] ;

	VI Expressions and operations
	-----------------------------

		STRUDEL provides for expressions and operations between
	them ( as has been seen in "HEIGHT * 0.5" in IV J ).

	The operators are
		"+"
		"-"
		"*"
		"/"
		"**"		(exponentiation)
		"&" "and"	logical AND
		"|" "or"	logical OR
		"!" "not"	logical NOT
		"="		equal
		"!="		not equal
		"<"		less than
		"<="		less than or equal to
		">"		greater than
		">="		greater than or equal to
		"(" ")"		priority modifiers

	Note :
		In <operand1> "and" <operand2>
		<operand2> is not evaluated if <operand1> is FALSE.

		In <operand1> "or" <operand2>
		<operand2> is evaluated only if <operand1> is TRUE.
		
	VII Constant values
	-------------------

		They exist in four types
			- integers
			- floating point numbers
			- character strings (delimited by double quotes)
			- units

	Units are specified as

			<value> <unit-type>

		E.g.	2 mm, 1.3 in, 3 m, 0.32 ft

	and are systematically converted to system units :

			1 m + 100 mm -> 1100 (if system unit is "mm")

	Example
		symbol	[
				format		= ("HELLO"),
				size		= 3 mm
			] ;

	Strings must have at most 63 characters, bigger strings will be
	truncated.

	When a value is an operand of a logical operator (and, or, not) it
	is taken to be true if it is a non-zero number or a non-empty string
	and false if it is zero or an empty string.

	VIII Functions
	--------------

	A) Accessing attributes of the element : "attribute()"

		The "attribute()" function returns the value of an attribute
	an element. It takes one or two arguments :

		1) the name of the attribute
		2) the element whose attribute is wanted (optional)

	If no second argument is specified then the element being extracted
	will be used.

		attribute( "memb_cut_len" ) returns the length of a beam.

	For example, to output the following text next to a beam:

		      wtee
		BEAM14
		      W10x20x30

	symbol [
		format	= (
			    START-FIELD( 0 ),
			    attribute( "memb_name" ),
			    END-FIELD,
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    UP( 0.5 * HEIGHT ),
			    attribute( "family_name" ),
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    DOWN( 0.5 * HEIGHT ),
			    attribute( "part_num" )
			   ),
		position = ( right )
		]

		On error (e.g. invalid number of arguments, unknown attribute)
	the function returns the value 0.

	B) Finding the direction of the profile and beam:
					"profile-direction()"
					"web-orientation()"
					"flange-orientation()"
					"beam-orientation()"

	profile-direction()
	-------------------

		This function finds the direction of a beam profile with
	respect of the axes of the drawing sheet :

				^ y
				|
				--> x
			       /
			      z

		The direction of a profile is its local x-axis (with respect
	to the beam axis and the supporting surface) :

			+-----+		+-----+
			| +---+		+---+ |
			| |		    | |
			| |		    | |
			+-+		    +-+
			---> x           x <---

		The values returned by this function allow for deciding
	(via a "select" statement, [see IX]) on which side of the beam a
	text must be placed.

		This function has no argument and returns :

			"+x" : along positive x-axis of drawing sheet
			"-x" : along negative x-axis of drawing sheet
			"+y" : along positive y-axis of drawing sheet
			"-y" : along negative y-axis of drawing sheet
			"+z" : along positive z-axis of drawing sheet
			"-z" : along negative z-axis of drawing sheet

		On error (e.g. invalid number of arguments, element being
	extracted is not a beam or a stiffener) the function returns the
	value 0.

	Sample usage :

		beam : {
		  top : {
		    $dir := profile-direction() ;
		    select
		    	when $dir = "+x" : $where := right ;
			when $dir = "-x" : $where := left ;
		    	when $dir = "+y" : $where := top ;
		    	when $dir = "-y" : $where := bottom ;
		    end
		    symbol [ ...
			    position = ( $where, ... ),
			    ...
			   ] ;
		  }
		}

	flange-orientation()
	--------------------

		Same as profile-direction() but with respect to the
	coordinate system in the model:

		---------> flange orientation
		+--------+
		|        |
		|  +-----+
		|  |
		|  |
		|  |
		|  |
		|  |
		+--+

		"+x" : towards fore
		"-x" : towards aft
		"+y" : towards starboard
		"-y" : towards portside
		"+z" : towards the top
		"-z" : towards the bottom

	web-orientation()
	-----------------

		Same result values as for flange-orientation() - also with
	respect to the coordinate system in the model, only concerning
	the web this time.


		+--------+	^
		|        |	|
		|  +-----+	|
		|  |		| web orientation
		|  |		|
		|  |		|
		|  |		|
		|  |		|
		+--+		|

	beam-orientation()
	------------------


		Returns the direction of the beam in the model (not on the
	drawing sheet).

		"x" : beam along fore-aft axis
		"z" : beam along vertical axis
		"+y": beam along transverse (starboard/portside) axis, to the
		      left of the centerline
		"-y": beam along transverse (starboard/portside) axis, to the
		      right of the centerline
		"y" : beam along transverse (starboard/portside) axis,
		      crossing the centerline

	C) Formatting numbers for text output : "format-number()"

		This functions format a number to be inserted in a text
	format:

		"format-number" ( <format> , <value> )
	
	where  <format> : character string specifying the format :
				<integer><delimiter><integer>
	       <value>  : the value to be formatted

	<delimiter> can be any character (in particular "." or ",").

	Examples
		format-number( "5.3", 123.45 ) -> "123.450"
		format-number( "5,1", 123.45 ) -> "123,5" (rounded)
		format-number( "5 1", 123.45 ) -> "123 5" (rounded)

	D) Finding whether a plate or a beam is hidden by another :
							"is-plate-hidden()"
							"is-beam-hidden()"

		These functions find whether the plate or the beam being
	drawn are hidden by another plate which is among the elements sel-
	ected for the drawing extraction :

		"is-plate-hidden" ()
		"is-beame-hidden" ()

		These functions have no argument, they will return 1 if the
	plate or the beam being drawn are hidden by another plate and 0 if
	they are not hidden or if the element being drawn is not a plate or
	a beam.

	Example

		plate : {
			side : {
				select
					when is-plate-hidden() : $style = 1 
					otherwise	       : $style = 0 
				end ;
				edge [ style = $style ]
			}
			...
		}

	E) Finding on which side of the plate the matter is :
							"plate-direction()"

		This function finds on which side of the plate the matter is
	with respect of the axes of the drawing sheet :

				^ y
				|
				--> x
			       /
			      z

		This function has no argument. Its usage and purpose are the
	same as for "profile-direction()" [see VIII B].
		When a plate is drawn onto the drawing sheet one either
	sees trace curves representing its bottom side (when seen from the
	side) or its contour with or without the holes (when seen from top
	or bottom).

		When seen from the side, "plate-direction" will return :

		"+x" : if the matter is towards the positive x-axis of drawing
		       sheet
		"-x" : if the matter is towards the negative x-axis of drawing
		       sheet
		"+y" : if the matter is towards the positive y-axis of drawing
		       sheet
		"-y" : if the matter is towards the negative y-axis of drawing
		       sheet

	Model			Drawing sheet		plate-direction()

	+----------------+
	|                |				"+y"
	+-bottom---------+	------------------


	+-bottom---------+	------------------
	|                |				"-y"
	+----------------+

	+--+			|
	bot|			|
	|  |			|
	|  |			|			"+x"
	|  |			|
	+--+			|

	+--+			   |
	|  bottom		   |
	|  |			   |
	|  |			   |			"-x"
	|  |			   |
	+--+			   |

		When seen from top or bottom, "plate-direction" will return :

		"+z" : if the matter is towards the front of the drawing sheet
		"-z" : if the matter is towards the back  of the drawing sheet

	Model			Drawing sheet		plate-direction()

	 __bottom___________
	/__________________/|	+-----------------+
	|                  ||	|		  |
	|                  ||	|		  |
	|                  ||	|		  |	"+z"
	|                  ||	|		  |
	|                  ||	|		  |
	|                  ||	|		  |
	|__________________|/	+-----------------+
	
	 ___________________
	/__bottom__________/|	+-----------------+
	|                  ||	|		  |
	|                  ||	|		  |
	|                  ||	|		  |	"-z"
	|                  ||	|		  |
	|                  ||	|		  |
	|                  ||	|		  |
	|__________________|/	+-----------------+

	
		On error (e.g. invalid number of arguments, element being
	extracted is not a plate) the function returns the value 0.

	F) Finding the elements joined by a weld : "first-welded-element()"
						   "second-welded-element()"

		These two functions, called when processing a weld. return the
	first and second element joined by that weld. They have no argument:

		$w1 := first-welded-element() ;
		$w2 := second-welded-element() ;

		If the argument being processed is not a weld, they both
	return 0.

	G) Finding the type of an element : "is-a-beam()"
					    "is-a-stiffener()"
					    "is-a-plate()"

		These three functions test the type of an element (if it is
	a beam, a stiffener, or a plate. They have one argument which is the
	element to test. They return 1 (TRUE) if the element is of the tested
	type otherwise 0 (FALSE).

	Example :
			is-a-beam( first-welded-element() )

	H) Finding if two plates are parallel : "parallel-plates()"

		This function returns 1 (TRUE) or 0 (FALSE) if the two plates
	passed as arguments are parallel. It will return FALSE if one of the
	element is not a plate.

	Example : (this example uses features described in following chapters)
		
		$w1 := first-welded-element() ;
		$w2 := second-welded-element() ;

		select
			when parallel-plates( $w1, $w2 ) :
			 ...
		end

	I) Finding if the element is clipped by the view plane:
		    				       "is-element-clipped()"

		This function returns 1 (TRUE) or 0 (FALSE) if the element
	being extracted is clipped by the view plane, i.e. if it crosses it.
	This function has no argument :

		is-element-clipped()

	J) Retrieving the scale of the element : "drawing-scale()"

		If the element being extracted is in a reference file,
	the function "drawing-scale()" (no argument) will return the scale
	that was used when the file was attached (a double floating point
	value). For example, if the reference file was attached with scale
	1:100, drawing-scale() will return 0.01.

		If the element being extracted is not in a reference file,
	drawing-scale() will return 1.
	

	K) Retrieving the type of a construction : "const-type()"

		The function "const-type()" returns the type of the
	construction being processed (no argument) or of some specified
	element (one argument). It is useful when the definition of the macro
	has been specified with a regular expression to know exactly which
	kind of construction is being processed :

		const ( definition = "hole*", view-criterion = "curve" ) : {

			top, bottom : {
				$constType := const-type() ;
				select
					when $constType = "hole10" :
						...
					when $constType = "hole20" :
						...
			}
			...
		}

	L) Finding an input element from which an element was constructed :
								"get-input()"

		The function "get-input()" returns the input element (parent)
	from which an element was constructed. It takes one or two arguments :

		1) the name of the input element (parent)
		2) the element constructed from the input (optional)

	If the second argument is not specified, then the element being
	processed will be used.

		Suppose we are in the code for extracting a construction
	which is an end-treatment "et" for a beam, and this construction has
	been defined such that "beam" is the name of the parent beam of
	the occurrences, and we need the parent beam for some purpose (for
	instance to access the value of one of its attributes ) :

		const ( definition = "et", view-criterion = "curve" ) : {

			top, bottom : {
			  $beam   := get-input( "beam" ) ;
			  $length := attribute( "memb_cut_len", $beam ) ;
			}
			...
		}

		Suppose furthermore that we needed the beam because we
	needed its axis :

		const ( definition = "et", view-criterion = "curve" ) : {

			...
			$beam := get-input( "beam" ) ;
			$axis := get-input( "curve", $beam ) ;
			# NOTE
			# The two calls above can be made in one go :
			# $axis := get-input( "curve", get-input( "beam" ) ) ;
			...
		}

		The first call to "get-input()" had no second argument,
	therefore the input "beam" of the const "et" was returned. The
	second call had an argument, therefore the input "curve" of
	the beam was returned.

	M) Finding a member of an element : "get-member()"

		The function "get-member()" returns a member of an
	element. It takes one or two arguments :

		1) the name of the member
		2) the element whose member is wanted

	If the second argument is not specified, then the element being
	processed will be used.

	Suppose we want the member "coordsys" of const "et" :

		const ( definition = "et", view-criterion = "curve" ) : {
			...
			$coordsys := get-member( "coordsys" ) ;
			...
		}

	Or we want member "line" of input "axis" of const "et" :

		const ( definition = "et", view-criterion = "curve" ) : {
			...
			$axis := get-input( "axis" ) ;
			$coordsys := get-member( "line", "axis" ) ;
			# NOTE
			# The two calls above can be made in one go :
			# $axis := get-member( "line", get-input( "axis" ) ) ;
			...
		}

	N) Matching a string against a regular expression : "match-regexp()"

		The function "match-regexp()" allows to match a character
	string against a regular expression, it	returns 1 (TRUE ) if the
	string matches the regular expression else 0 (FALSE) :


		"match-regexp" ( <regular expression>, <character string> )

	where : <regular expression> has the same syntax as those of the UNIX
	        shell
	        <character string> is a character string.

	For example :

		const ( definition = "et*", view-criterion = "curve" ) : {

			...
			$type := const-type() ;
			#
			# Same treatment for (et1,et2,et3).
			# Same treatment for (et4,et7,et7).
			# Treat et6 alone.
			select
				when match-regexp( "et[1-3]", $type ) :
				...
				when match-regexp( "et[457]", $type ) :
				...
				when $type = "et6" :
				...
			...
		}

	 O) Projecting a curve onto the drawing sheet : "project-curve()"

		The function "project-curve()" projects a curve onto the
	drawing sheet along the view vector and returns the projected curve :

		"project-curve" ( <curve> )

	Example :
		$proj := project-curve( $curve ) ;

	P) Finding the end point of a curve closest to an element :
							"nearest-end-point()"

		The function "nearest-end-point()" allows to find the end
	point of a curve which is closest to another element :

		"nearest-end-point" ( <curve>, <other-element> )

	and returns two values :
		at-first-end	: <other-element> closest to 1st end
		at-second-end	: <other-element> closest to 2nd end

	Example :

		const ( definition = "et", view-criterion = "cutcv" ) : {

			...
			$beam	 := get-input( "beam" ) ;
			$axis	 := get-input( "curve", $beam ) ;
			$cutcv	 := get-member( "cutcv" ) ;
			#
			# Find which end point of beam's axis is closest to
			# member "cutcv" of const "et".
			#
			$whichPt := nearest-end-point( $axis, $cutcv ) ;

			select
				when $whichPt = at-first-point :
				...
				when $whichPt = at-second-point :
			end ;
			...
		}

	Q) String manipulation functions

	 - Duplicating a character string : "dup-string()"

		The function "dup-string", given a string and a count n,
	will duplicate it n times :

		dup-string( "-", 5 ) will return "-----".

	 - Concatenating strings

		The function "catenate-strings" catenates n strings:

			catenate-strings( "abc", "def", 123 )

	will return "abcdef123".

	 - Computing the length of a character string : "string-length"

		
	characters in a character string :

		string-length( "Hello" ) will return 5.

	- Getting the count of word in a string : "word-count()"

		The function "word-count" will return the number of words
	in a string; a word is a sequence of characters separated by spaces
	(blanks, tabs or newlines):

		word-count( "Hello world" ) will return 2.

	- Getting a word in a string : "get-word()"

		The function "get-word" will return the n-th word of a string;
	words are numbered from 0 to number-of-words - 1:

		get-word( "Hello world", 0 ) will return "Hello".
		get-word( "Hello world", 1 ) will return "world".
		get-word( $s, word-count( $s ) - 1 ) will return the last
		word of string $s.

	- Extracting a sub-string from a string : "sub-string()"

		The function "sub-string" will extract the characters from
	a string given the starting end ending position; characters are
	numbered for 0 to length-of-string - 1:

		sub-string( "Hello world", 0, 2 ) will return "Hel".
		sub-string( "Hello world", 4, 4 ) will return "o".
		sub-string( $s, 1, string-length( $s ) - 1 ) will
		returns string $s with its first character removed.

	- Substituting a sub-string by another : "substitute-string()"

		The function "substitute-string" replaces n occurrences of
	a sub-string withing a string by another:

		substitute-string(	<input string>,
					<sub-string to replace>,
					<replacement sub-string>,
					<number of replacements wanted> )

	and returns a string with the substitutions.

		substitute-string( "abcdef", "cd", "123", 1 )
			will return "ab123ef"
		substitute-string( "abcdefcd", "cd", "123", 1 )
			will return "ab123efcd"
		substitute-string( "abcdefcd", "cd", "123", 2 )
			will return "ab123ef123"
		substitute-string( "abcdefcd", "cd", "123", 5 )
			will return "ab123ef123"
		substitute-string( "abcdefcd", "cd", "123", 0 )
			will return "abcdefcd"

	To have all occurrences replaced set the number of replacements wanted
	to some big number.

	- Getting the time and date
		The function "time" returns the date and the time of day in
	various formats
			time( <format> )

	where format is a character string in which the special controls
	listed below will be interpreted

	%%   Same as %.
	%a   Abbreviated weekday name (e.g. Mon).
	%A   Full weekday name (e.g. Monday).
	%b   Abbreviated month name (e.g. Apr).
	%B   Full month name (e.g. April).
	%d   Day of month (01 - 31).
	%D   Date as %m/%d/%y
	%e   Day of month (1 - 31).  Single digits are preceded by a blank.
	%H   Hour (00 - 23).
	%I   Hour (00 - 12).
	%j   Day number of year (001 - 366).
	%m   Month number (01 - 12).
	%M   Minute (00 - 59).
	%p   Ante meridian or post meridian.
	%r   Time as %I:%M:%S %p.
	%R   Time as %H:%M.
	%S   Seconds (00 - 59).
	%T   Time as %H:%M:%S.
	%U   Week number of year (00 - 53).  Sunday is the first day of week.
	%w   Weekday number.  Sunday = 0.
	%W   Week number of year (00 - 53).  Monday is the first day of week.
	%y   Year within century (00 - 99).
	%Y   Year as ccyy (e.g. 1994).
	%Z   Time zone name (e.g. EUR, CDT)

	Examples:
		time( "%A %d %B" ) will return "Friday 13 April"
		time( "Today is %B %dth" ) will return "Today is Apr 13th"

	R) Intersection a curve with the view plane :
						"intersect-curve-with-view()"

		The function "intersect-curve-with-view" is intended to obtain
	a point when intersecting a curve traversing the view plane so as to
	position a symbol afterwards. This function is input an object, which
	may be obtained via functions returning objects, such as "get-input"
	and "get-member"; this object supposed to be a curve is intersected
	with the view plane to yield a point, this point is then projected
	onto the drawing sheet along the view vector.

	Example:

		$line  := get-member( "line" ) ;
		$point := intersect-curve-with-view( $line ) ;
		anchor-curve( $point ) ;
		symbol [ format = ( "Hello" ) ] ;

		This function will fail if the input object is not a curve or
	if the curve does not intersect the view plane.

	S) Getting the basename of an element : "basename()"

		The function "basename" returns the name of an element: the
	base name is the last part of the element's name (if it has one):

		the basename of a:b:c:d is "d"

		If it is called with no argument, "basename" will return the
	basename of the element being processed:

		$n := basename() ;

		But it may be called with an element ( as returned, say, by
	"get-input" ) ;

		$element := get-input( "curve" ) ;
		$n	 := basename( $element ) ;

		If the element is not named, then "basename" returns an empty
	string ("").

	T) Mapping ship location to drawing sheet: "where-is"
	-----------------------------------------------------

		The function "where-is" maps the locations "fore" (or "+x"),
	"aft" (or "-x"), "portside" (or "+y"), "starboard" (or "-y"), "top"
	(or "+z"), "bottom" (or "-z") and "centerline" to the drawing sheet
	by returning

			"+x" (right),
			"-x" (left),
			"+y" (top),
			"-y" (bottom),
			"+z" (front),
			"-z" (back).

	Example:
		$location := where-is( "fore" ) ; # or where-is( "+x" )
		select
			when $location = "+x" ...

	U) Obtaining information from the relational data base
	------------------------------------------------------

		The function "query-database" can be used to retrieve infor-
	mation from the relation data base thanks to an RIS query statement:

		$result := query-database( "<RIS statement>" ) ;

		The value returned is an array of strings which can be
	accessed by	$result[0]
			$result[1]
			...
			$result[size-of-array( $result )-1]
	Example
		query-database( "SELECT item FROM sometable WHERE a < 1" ) ;

	This call will fail if one is not logged into the database or if
	the RIS statement is incorrect.

	IX Conditionals
	---------------
		select, when, otherwise, end

		select    : introduces a conditional (possibly with multiple
		            branches)
		when      : introduces a condition
		otherwise : introduces the action when all when's were not
		            satisfied
		end	  : terminates conditional

	A) Syntax

		"select"
			"when" <condition 1 is satisfied> :
				<action 1>
			"when" <condition 2 is satisfied> :
				<action 2>
			"otherwise" :
				<default action>
		"end"

		<condition> is one or several elementary conditions ORed,
		ANDed or negated such as :

		- when attribute( "composite" )
		- when attribute( "part_num" ) = "W10x20x30"
		       and not attribute( "composite" )

		The above conditional exists in degenerated forms :

		No "otherwise" : nothing done if no "when" is satisfied :

		"select"
			"when" ... :
			"when" ... :
		"end"

		One "when" only with or without "otherwise" :

		"select" "when" <condition> : <action>
			 "otherwise"        : <default> "end"
		"select" "when" <condition> : <action> "end"

		Conditionals may be nested.

	B) Example
		select
			when attribute( "plate_type" ) = "water_tight" :
				select when $certification :
					edge [style=1]
				otherwise :
					edge [style=2]
				end ;
			when attribute( "plate_type" ) = "gas_tight" :
				# do something
			otherwise
				# do something
		end

	X Variables
	-----------

		STRUDEL provides for variables to allow for global flags to
	be defined or to improve readability.
		A variable must start with a `$' (dollar sign) followed by an
	identifier :
			$a
			$abc
			$_1
			$a1b2

	Variable names must have at most 63 characters, bigger names will be
	truncated.

		The assignment operator is `:=' :

			$a := "Hello"
			$a := 1.2
			$a := 13 ft
			$a := HEIGHT * 2 + WIDTH
			$a := $b - 0.3 * $c ** 2

	All variables are initialized to their name, hence if "$a" has not
	been assigned a value and we have $b := $a then $b's value will be
	"$a".

	Variable assignment may appear anywhere an action may appear but
	also at the top of the STRUDEL file, before all selections on
	element types :

	$a := 1 ;
	$name := attribute( "part_num" ) ;

	plate : {
		...
	}

	For example, to have a global file allowing to differentiate between
	a fabrication drawing or a certification drawing, one may define
	at the top of the file :

	$fabrication := 1	# Taken to be "true"

	...
	select when $fabrication : ...
	end

	Or

	$mode := "fabrication" ;

	...
	select when $mode = "fabrication" : ...
	end

	Our text examples may be yet rewritten using variables

	$delta		:= 0.5 * HEIGHT ;
	$name		:= attribute( "memb_name" ) ;
	$type		:= attribute( "family_name" ) ;
	$profile	:= attribute( "part_num" ) ;
	$textColor	:= "yellow" ;
	$textWeight	:= 1 ;
	symbol [
		format	= (
			    START-FIELD( 0 ),
			    $name,
			    END-FIELD,
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    UP( $delta ),
			    $type,
			    MOVE-TO-FIELD( 0, RIGHT-CENTER ),
			    DOWN( $delta ),
			    $profile
			   )
		color = $textColor,
		weight= $textWeight
		]

	Variables may be assigned the following text position values:
			"top"
			"bottom"
			"left"
			"right"
			"at-first-end"
			"at-second-end"
			"center"
			"middle"
			"innermost"
			"horizontal"
			"parallel"
			"orthogonal"
			"not-reversed"
			"upside-down"
			"right-to-left"

	and the be used inside a "position" list :

		$where	:= at-first-end ;
		$how	:= parallel ;
		symbol [ position = ( $where, $how ), ... ]

	Some functions which generate more than one item return an array.
	The elements of an array of n elements are numbered from 0 to n-1.
	The i-th array of an arrray $a is accessed by

				$a[<index>]

	The number of elements in array $a is obtained by

				size-of-array( $a )

	XI  Manipulating the relational data base
	-----------------------------------------

		It is sometimes desriable to report in the relational
	database the elements which have been processed. This can be done
	with the "updata-database" instruction:

		updata-database[ statement = <RIS update statement> ]

	For instance, to update the beam being processed using its base
	name as a selection criterion:


  update-database[
    statement = catenate-strings(
	         "UPDATE struct_bm_dynamic SET chg_no = 1 WHERE memb_name = '",
	         basename(),
	         "' AND chg_no = 0"
	        )
  ]

	An update-database instruction will fail if one is not logged into
	the database or if the RIS statement is incorrect.

	XIII Debugging
	--------------

		To allow for fine tuning of STRUDEL file and discovering
	errors a trace facility is implemented :

		"verbose" : turns on verbose mode
		"silent"  : turns off verbose mode

	By default, STRUDEL does not output any errors. If verbose is on,
	the execution trace is output to the terminal (standard output).

	You may choose to have the trace of the execution to be written to
	a file by putting the statement :

		set logfile <filename> ;

	in your STRUDEL file :

		set logfile "drawing.log" ;
	or	set logfile "/usr/tmp/drwlog" ;

	"verbose" and "silent" may appear at the same locations as variable
	assignments :

	beam : {
		top : {
			axis [ style = 1 ] ;
			verbose ;
			symbol [ ... ] ;
			silent
		}
	}

	The following portion of STRUDEL file :

	verbose ;
	$fabrication := 1 ;

	stiffener : {
		top : {

			symbol	[
				format	= (
					    START-FIELD( 0 ),
					    "Hello",
					    END-FIELD,
					    MOVE-TO-FIELD( 0, RIGHT-BASE ),
					    UP( HEIGHT * 0.5 ),
					    "I'm upstairs",
					    MOVE-TO-FIELD( 0, RIGHT-BASE ),
					    DOWN( HEIGHT * 0.5 ),
					    "I'm downstairs",
					    FONT( 102 ),
					    "ABC"
					   ),
				position= (parallel),
				color	= "green",
				weight	= 0,
				style	= 0,
				size	= 3 inch
			]
		}

	Will output the following trace :

 Line number in STRUDEL file
   |
   V
>> Object 2, 171
   2 *-* Variable setting $fabrication <- 1
   4 *-* Element type 'stiffener' : Yes
   5 *-* View top
   7 *-* Output symbol with
         > format =
         > START-FIELD = 0
         > string = 'Hello'
         > END-FIELD =
         > MOVE-TO-FIELD = 0
  13 OP 3 * 0.5 -> 1.5
         > UP = 1.5
         > string = 'I'm upstairs'
         > MOVE-TO-FIELD = 0
  16 OP 3 * 0.5 -> 1.5
         > DOWN = 1.5
         > string = 'I'm downstairs'
         > FONT = '102'
         > string = 'ABC'
  20 *-* End (format at 8)
         > position =
         > parallel
  21 *-* End (position at 21)
         > color = 'green'
         > weight = 0
         > style = 0
  25 *-* Unit conversion: 3 inch -> 3
         > size = 3
  26 *-* End (symbol at 7)
  59 *-* Element type 'beam' : No
  70 *-* Element type 'plate' : No
  80 *-* Element type 'joint' : No
>> End object 2, 171

	XVI File inclusion
	------------------

		The setup file may be split up in several files which are
	included via the "include" statement :

		include "<file name>" ;

	Included files may themselves include files, the level of nesting
	being limited to 10.

	The search for the included files follows the following rules:

	  - if an absolute path is specified ( e.g. "/usr/me/mysetup" )
	    then only the directory specified in the path is explored.

	  - if a relative path is specified ( e.g. "setups/setup_1" )
	    then the directory where the last search was successful
	    is tried first, then the directories "config/drawing" in the
	    product paths:

		1 <last-directory>/setups/setup_1
		2 <user-path>/config/drawing/setups/setup_1
		3 <struct-dir>/config/drawing/setups/setup_1
		4 <vds-dir>/config/drawing/setups/setup_1
		etc.

	    (2) is available if I/STRUCT is started with the option -S

			struct -cf myfile -S <user-path>

	    The <last-directory> in (1) is defined as follows

 FILE SCANNED			FIRST SEARCHED IN	LAST-DIRECTORY SET TO

 "setup"			"."            		<D>
 | include "setups/setup_1"	<D>			<D>/setups
 | | include "../a/setupA"	<D>/setups		<D>/setups/a
 | | include "../b/setupB"	<D>/setups		<D>/setups/b
 | include "setups/setup_2"	<D>    	


	XV  Definition of the language
	------------------------------

	A) List of keywords

	Keyword			| Related topic
	_______________________________________________________________
	CENTER-BASE		| Justification point of text
	CENTER-BOTTOM		| Justification point of text
	CENTER-CAP		| Justification point of text
	CENTER-CENTER		| Justification point of text
	CENTER-TOP		| Justification point of text
	DOWN			| Cursor movement inside of text
	END-FIELD		| End-of-field marker inside of text
	FONT			| Change-font statement inside of text
	HEIGHT			| Change-height statement inside of text
	LEFT			| Cursor movement inside of text
	LEFT-BASE		| Justification point of text
	LEFT-BOTTOM		| Justification point of text
	LEFT-CAP		| Justification point of text
	LEFT-CENTER		| Justification point of text
	LEFT-TOP		| Justification point of text
	MOVE-TO-FIELD		| Cursor movement inside of text
	RIGHT			| Justification point of text
	RIGHT-BASE		| Justification point of text
	RIGHT-BOTTOM		| Justification point of text
	RIGHT-CAP		| Justification point of text
	RIGHT-CENTER		| Justification point of text
	RIGHT-TOP		| Justification point of text
	SCALE			| Change-scale statement inside of text
	START-FIELD		| Beginning-of-field marker inside of text
	UP			| Cursor movement inside of text
	WIDTH			| Change-width statement inside of text
	above			| Text position
	anchor-curve		| Text position
	anchor-point		| Text position
	and			| Relational operator
	any-view		| View selector
	as			| Part of 'extract' introducing output type
	average-point		| Text position/anchor point
	at-first-end		| Text position
	at-second-end		| Text position
	attribute		| Function
	axis			| Graphic output
	basename		| Function
	beam			| Element type
	beam-orientation	| Function
	below			| Text position
	bottom			| Text position
	catenate-strings	| Function
	center			| Text position/anchor point
	center-of-gravity	| Text position/anchor point
	color			| Symbology for output
	const			| Element type
	const-type		| Function
	contour			| Graphic output
	definition		| Selection of construction type
	drawing-scale		| Function
	dup-string		| Function
	edge			| Graphic output
	end			| End of conditional
	end-on			| View type
	extract			| Definition of output and transferred values
	filled-display		| Symbology for output
	first-welded-element	| Function
	font			| Font for text output
	format			| Format for text output
	format-number		| Function
	get-input		| Function
	get-member		| Function
	get-word		| Function
	height			| Height for text output
	hidden-style		| Symbology for output
	horizontal		| Text position
	innermost		| Text position
	intersection		| Graphic output
	intersect-curve-with-view Function
	is-a-beam		| Function
	is-a-plate		| Function
	is-a-stiffener		| Function
	is-element-clipped	| Function
	is-plate-hidden		| Function
	joint			| Element type
	justification		| Justification for text output
	left			| Text position
	level			| Symbology for output
	logfile			| Debugging
	match-regexp		| Function
	middle			| Text position
	nearest-end-point	| Function
	not			| Relational operator
	not-reversed		| Text position
	offset			| Text position/Axis translation
	or			| Relational operator
	orthogonal		| Text position
	otherwise		| Conditional
	parallel		| Text position
	plate			| Element type
	parallel-plates		| Function
	plate-direction		| Function
	position		| Text position
	profile			| Graphic output
	profile-direction	| Function
	profile-orientation	| Function
	project-curve		| Function
	projection		| Graphic output
	query-database		| Function
	right			| Text position
	right-to-left		| Text position
	scale			| Scale for profile output
	second-welded-element	| Function
	select			| Conditional
	set			| Global setting
	side			| View type
	silent			| Debugging
	size			| Size for text output
	statement		| Database update
	stiffener		| Element type
	string-length		| Function
	style			| Symbology for output
	sub-string		| Function
	substitute-string	| Function
	symbol			| Text output
	time			| Function
	to-the-left		| Text position
	to-the-right		| Text position
	top			| Text position
	unknown-view		| View type
	update-database		| Database update
	upside-down		| Text position
	verbose			| Debugging
	view-criteria		| View selection for constructions
	view-criterion		| View selection for constructions
	view-cone-angle		| View type
	weight			| Symbology for output
	weldline		| Graphic output
	when			| Conditional
	where-is		| Function
	width			| Width for text output
	with			| Part of 'extract' introducing attributes
	word-count		| Function

	B) Syntax

	In the description of the syntax below, keywords are surrounded by
	simple quotes to differentiate them from non-terminal symbols.
	Operators will be surrounded by simple quotes to differentiate them
	from the symbols of the Backus-Naur form :

	- [ pattern ] means that pattern is optional.
	- { pattern } means that pattern may be repeated zero or more times.
	- pattern1 | pattern2 means that pattern1 or pattern2 can fit.
	- ( and ) are used to group sentenced when an | is involved :
				( pattern1 pattern2 ) | pattern3
	  is different from	pattern1 pattern2 | pattern3
	  which means		pattern1 ( pattern2 | pattern3 )
	- <> denotes the empty token

	program		::= [settings] type-selection
				{ [settings] type-selection }

	settings	::= setting { ; setting }

	setting		::= global_setting | assignment

	global_setting	::= 'verbose'
			  | 'silent'
			  | 'set' 'view-cone-angle' exp
			  | 'set' 'logfile' exp

	assignment	::= variable ':=' exp-or-unit

	type-selection	::= element-type ':' '{' [extract] directives '}'

	element-type	::= 'beam'
			  | 'stiffener'
			  | 'plate'
			  | 'joint'
			  | construction


	construction	::= 'const' '(' 'definition' '=' string ','
					view_criterion
				    ')'

	view_criterion	::= ( 'view-criterion'	'=' string )
			  | ( 'view-criteria'	'=' string '/' string
	       					{ ',' string '/' string } )

	extract		::= 'extract' 'as' string
					[ with string {',' string } ] ';'

	directives	::= view-selection { view-selection }

	view-selection	::= view-type { ',' view-type } ':' '{' actions '}'

	view-type	::= 'top'
			  | 'bottom'
			  | 'side'
			  | 'end-on'
			  | 'unknown-view'
			  | 'any-view'

	actions		::= action { ';' action }

	action		::= output
			  | anchor_point
			  | assignment
			  | conditional
			  | global_setting
			  | <>

	output		::= graphic
			  | symbol
			  | database-update

	anchor_point	::= 'anchor-point' '(' exp { ',' which-point ')' }

	which-point	::= 'center'
			  | 'center-of-gravity'
			  | 'average-point'


	graphic		::= graphic-type [ arglist ] [ graphic-setup ]

	graphic-type	::= 'profile'
			  | 'projection'
			  | 'axis'
			  | 'contour'
			  | 'edge'
			  | 'intersection'
			  | 'weldline'
			  | 'member' '(' exp ')'

	graphic-setup	::= '[' graphic-attr { ','  graphic-attr } ']'

	graphic-attr	::= 'color'		'=' exp
			  | 'style'		'=' exp
			  | 'weight'		'=' exp
			  | 'level'		'=' exp
			  | 'scale'		'=' exp
			  | 'offset'		'=' exp-or-unit
			  | 'hidden-style'	'=' exp
			  | 'filled-display'

	symbol		::= 'symbol' [ symbol-setup ]

	symbol-setup	::= '[' symbol-attr { ','  symbol-attr } ']'

	symbol-attr	::= 'color'		'=' exp
			  | 'style'		'=' exp
			  | 'weight'		'=' exp
			  | 'level'		'=' exp
			  | 'font'		'=' exp
			  | 'format'		'=' '(' format-specs ')'
			  | 'justification'	'=' exp
			  | 'size'		'=' exp
			  | 'width'		'=' exp
			  | 'height'		'=' exp
			  | 'position'		'=' '(' positions ')'

	database-update	::= 'update-database' '[' 'statement '=' exp ']'

	format-specs	::= format-spec { ',' format-spec }

	format-spec	::= exp
			  | format-command

	format-command	::= 'UP'		'(' exp-or-unit ')'
			  | 'DOWN'		'(' exp-or-unit ')'
			  | 'LEFT'		'(' exp-or-unit ')'
			  | 'RIGHT'		'(' exp-or-unit ')'
			  | 'SCALE'		'(' exp ')'
			  | 'START-FIELD'	'(' exp ')'
			  | 'END-FIELD'
			  | 'MOVE-TO-FIELD'	'(' exp ',' exp ')'
			  | 'FONT'		'(' exp ')'

	positions	::= position { ',' position }

	position	::= exp
			  | 'offset'		'(' exp ',' exp-or-unit ')'
			  | 'above'		'(' exp-or-unit ')'
			  | 'below'		'(' exp-or-unit ')'
			  | 'to-the-left'	'(' exp-or-unit ')'
			  | 'to-the-right'	'(' exp-or-unit ')'

	exp-or-unit	::= exp [ unit ]

	exp		::=
			  | exp '<=' exp
			  | exp '<'  exp
			  | exp '>=' exp
			  | exp '>'  exp
			  | exp '='  exp
			  | exp '|'  exp
			  | exp '&'  exp
			  | exp '+'  exp
			  | exp '-'  exp
			  | exp '/'  exp
			  | exp '**' exp
			  | '-' exp
			  | '!' exp
			  | '(' exp ')'
			  | function '(' arglist ')'
			  | variable
			  | variable '[' exp ']'
			  | constant


	arglist		::= [ exp { ',' exp } ]

	constant	::= integer
			  | real
			  | string
			  | 'HEIGHT'
			  | 'WIDTH'
			  | text-just
			  | text-position

	text-just	::= 'LEFT-BOTTOM'
			  | 'LEFT-BASE'
			  | 'LEFT-CENTER'
			  | 'LEFT-CAP'
			  | 'LEFT-TOP'
			  | 'CENTER-BOTTOM'
			  | 'CENTER-BASE'
			  | 'CENTER-CENTER'
			  | 'CENTER-CAP'
			  | 'CENTER-TOP'
			  | 'RIGHT-BOTTOM'
			  | 'RIGHT-BASE'
			  | 'RIGHT-CENTER'
			  | 'RIGHT-CAP'
			  | 'RIGHT-TOP'

	text-position	::= 'top'
			  | 'bottom'
			  | 'right'
			  | 'left'
			  | 'at-first-end'
			  | 'at-second-end'
			  | 'center'
			  | 'middle'
			  | 'innermost'
			  | 'horizontal'
			  | 'vertical'
			  | 'parallel'
			  | 'orthogonal'
			  | 'not-reversed'
			  | 'upside-down'
			  | 'right-to-left'

	function	::= 'attribute'
			  | 'basename'
			  | 'beam-orientation'
			  | 'catenate-strings'
			  | 'const-type'
			  | 'drawing-scale'
			  | 'dup-string'
			  | 'first-welded-element'
			  | 'format-number'
			  | 'get-input'
			  | 'get-member'
			  | 'get-word'
			  | 'intersect-curve-with-view'
			  | 'is-a-beam'
			  | 'is-a-stiffener'
			  | 'is-a-plate'
			  | 'is-element-clipped'
			  | 'is-plate-hidden'
			  | 'match-regexp'
			  | 'nearest-end-point'
			  | 'parallel-plates'
			  | 'plate-direction'
			  | 'profile-direction'
			  | 'profile-orientation'
			  | 'project-curve'
			  | 'query-database'
			  | 'second-welded-element'
			  | 'string-length'
			  | 'sub-string'
			  | 'substitute-string'
			  | 'time'
			  | 'where-is'
			  | 'word-count'

	conditional	::= 'select' selectors 'end'

	selectors	::= when-clause { , when-clause } otherwise-clause

	when-clause	::= 'when' exp ':' actions

	otherwise-clause::= 'otherwise'  ':' actions

	integer		::= digit { digit }

	real		::= integer '.' [ integer ] [ exponent ]
			  | [ integer ] '.' integer [ exponent ]
			  | integer exponent

	exponent	::= ( 'E' | 'e' ) { '+' | '-' } integer

	string		::= '"' [ character { character } ] '"'

	digit		::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

	character	::= 'any character from the ASCII set'

	variable	::= '$' ( letter | '_' ) [ { letter | '_' | digit } ]

	unit		::= 'any unit from the UOM table surrounded by "'


	XVI Hints
	---------

	A) How to annotate a plate according to the matter side

		The following piece of code outputs as text the part number
	of a plate on the side of the matter. The text is placed orthogonal
	to the trace curve representing the plate on the drawing sheet.

	The following parameters will be set according to the value returned
	by "plate-direction()" :

	Plate on drawing sheet			plate-direction()
	__________________________________________________________

			T ^	
			E |
			X offset above		"+y"
			T < left center
		--------x---------
		      middle
	__________________________________________________________

		      middle
		--------x---------
			T < right center	"-y"
			E offset below
			X |
			T V
	__________________________________________________________

		|
		|
		|
	middle	x TEXT				"+x"
		| ^
		| left center
		| -> offset to the right

	__________________________________________________________

			|
			|
			|
		   TEXT	x middle		"-x"
		      ^	|
	   right center	|
 <- offset to the left	|
	__________________________________________________________
	
	plate : {
		# ...

		side : {
			edge [ weight = 2, hidden-style = 1 ] ;

			$plateDir := plate-direction() ;

			select
			  when $plateDir = "+x" : $where := right ;
					          $just	 := LEFT-CENTER ;
			  when $plateDir = "-x" : $where := left ;
						  $just	 := RIGHT-CENTER;
			  when $plateDir = "+y" : $where := top ;
						  $just	 := RIGHT-CENTER;
			  when $plateDir = "-y" : $where := bottom ;
						  $just	 := LEFT-CENTER ;
			end ;

			$txsize := 1 inch ;

			symbol [
			  format	= ( attribute( "part_num" ) ),
			  position	= ( middle,
					    orthogonal,
					    offset( $where,
						    $txsize * 0.5 )
					  ),
			  justification	= $just,
			  color		= "red",
			  weight	= 0,
			  style		= 0,
			  level		= 12,
			  size		= $txsize
			] # end "symbol"
		}
	# ...

	B) How to have subscripts and superscripts in text

		The following piece of code will output the following text:

						     X  X XXX
						     X  X X  X
		X     X	XXXXXX X      X	      XXXXX  X  X XXX
		X     X	X      X      X	     X     X  XX  X
		X     X	X      X      X	     X     X
		XXXXXXX	XXX    X      X	     X     X
		X     X	X      X      X	     X     X
		X     X	X      X      X	     X     X XXX   XX  X   X XX  X
		X     X	XXXXXX XXXXXX XXXXXX  XXXXX  X  X X  X X X X X X X
						     X  X X  X X X X X  XX
						     XXX   XX   XXX  X   X

	symbol	[
		format	= (
	# Start a field so we can position with respect to it later, give it
	# the number 0.

			    START-FIELD( 0 ),

	# Write "HELLO"

			    "HELLO",

	# End "HELLO" field

			    END-FIELD,

	# Move to the right base of field number 0 (the "HELLO" field)
	# RIGHT-BASE is below the right bottom corner of the text in the
	# field.

			    MOVE-TO-FIELD( 0, RIGHT-BASE ),


	# Go up 70 % of the active text height

			    UP( HEIGHT * 0.7 ),

	# Go right 50 % of the active text height

			    RIGHT( HEIGHT * 0.5 ),

	# We are now where we want to write the superscript, since we want
	# the superscript smaller than the main text we scale it. Here the
	# superscript will have a size 50 % of the size of the main text.

			    SCALE( 0.5 ),

	# Write "UP"
			    "UP",

	# Since now all cursor movement are based on the current text size,
	# (which has been scaled), we unscale so has to move back to field #0.

			    SCALE( 2 ),

	# Move to the right base of field number 0 (the "HELLO" field)

			    MOVE-TO-FIELD( 0, RIGHT-BASE ),

	# Go down 70 % of the active text height

			    DOWN( HEIGHT * 0.7 ),

	# Go right 50 % of the active text height

			    RIGHT( HEIGHT * 0.5 ),

	# We are now where we want to write the subscript, since we want
	# the subscript smaller that the main text we scale it. Here the
	# subscript will have a size 50 % of the size of the main text.

			    SCALE( 0.5 ),

	# Write "DOWN"

			    "DOWN",

			   ),
			color	= "red"
		]

	C) How to underline text

		The following piece of code will output the following text:


		X     X	XXXXXX X      X	      XXXXX
		X     X	X      X      X	     X     X
		X     X	X      X      X	     X     X
		XXXXXXX	XXX    X      X	     X     X
		X     X	X      X      X	     X     X
		X     X	X      X      X	     X     X
		X     X	XXXXXX XXXXXX XXXXXX  XXXXX

		XXXXXXX XXXXXX XXXXXX XXXXXX XXXXXXX

		symbol	[
			format	= (
				    START-FIELD( 0 ),
				    "HELLO",
				    END-FIELD,
				    MOVE-TO-FIELD( 0, LEFT-BOTTOM ),
				    DOWN( HEIGHT * 0.5 ),
				    "-----"
				   )
			]

	   D) How to annotate a construction for a hole

		Suppose we have extraction statements for a family of
	constructions "hole1", "hole2", etc. and we want to annotate them
	specifying their type and diameter. We suppose that each construction
	has an attribute (a numerical member) called "radius" corresponding
	to the value of the radius of the hole.

	# "hole*" will catch "hole1", "hole2", etc.

	const ( definition = "hole*", view-criterion = "curve" ) : {

		# ...
		symbol	[
			format	= (
		# "const-type()" will return the exact type, e.g. "hole2"

				    const-type(),

		# Add a space
				    " ",

		# Character "n" of font number 100 is the diameter symbol

				    FONT( 100 ),
				    "n",

		# Go back to default font

				    FONT( "default" ),

		# Write diameter

				    2 * attribute( "radius" )

				   )
		]
	}

	This will output something like :
	                                            X
	X     X	 XXXXX  X      XXXXXX	      XXXXXX       XXXXXX    XXXXX
	X     X	X     X X      X	     X    XX       X              X
	X     X	X     X X      X	     X   X X       XXXXX          X
	XXXXXXX	X     X X      XXX	     X  X  X            X       XX
	X     X	X     X X      X	     X X   X            X         X
	X     X	X     X X      X	     XX    X            X         X
	X     X	 XXXXX  XXXXXX XXXXXX        XXXXXX        XXXXX  X  XXXXX 
	                                    X

	   E) How to represent a construction by a symbol

		Suppose we have a construction whose member is a curve
	which is used to cut out beams, say that this end-treatment has
	type "et", knows its parent beam by the name "bmToCut", and knows
	its member curve by the name "cuttingCv"  :

	const "et"
	.................
	.	+-------.-------------------------------+
	.	|	.				|	FRONT VIEW
	.	|      .				|
	.	|    .					|
	..........					|
		+---------------------------------------+
		|					|
		+-beam----------------------------------+


		When seen from top we want to extract the beam as an axis
	and the end treatment "et" as an arrowhead at the end of the axis:

		+--- "etDRAWING"
		|
		<---------------------------------------- "bmDRAWING"

	beam : {

		extract as "bmDRAWING" ;

		...
		top, bottom : {
			axis [ weight = 1 ]
		}
		...

	} # end beam

	const ( definition = "et", view-criterion = "cuttingCv" ) : {

	extract as "etDRAWING" ;

	top, bottom : {

		# Retrieve input of macro whose name is "bmToCut"

		$beam		:= get-input( "beam" ) ;

		# Retrieve beam axis : input with name "curve"

		$axis		:= get-input( "curve", $beam ) ;

		# Retrieve member of macro whose name is "cuttingCv"
		# Note that in this example it is also the member used as a
		# view criterion but it need not be so.

		$cuttingCv	:= get-member( "cuttingCv" ) ;

		# Find which end point of axis is closer to "cuttingCv"

		$proximity	:= nearest-end-point( $axis, $cuttingCv ) ;

		# Project beam axis onto drawing sheet

		$pjOfAxis  	:= project-curve( $axis ) ;

		# ... and use it as an anchor curve

		anchor-curve( $pjOfAxis ) ;

		# Place arrow using projection of axis according to
		# proximity.

		select
			when $proximity = at-first-end :
				symbol	[
					format		= ("A"),
					font		= "102",
					position	= (at-first-end,
						  	   parallel,
							   right-to-left),
					color		= "green",
					weight		= 0,
					style		= 0,
					size		= 1 inch
			] ;
			when $proximity = at-second-end :
				symbol	[
					format		= ("A"),
					font		= "102",
					position	= (at-second-end,
							   parallel),
					color		= "red",
					weight		= 0,
					style		= 0,
					size		= 1 inch
				] ;
		end ;
	}
	} # end const "et"

