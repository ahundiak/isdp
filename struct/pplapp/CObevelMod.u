/* $Id: CObevelMod.u,v 1.5 2001/06/07 22:58:17 ramarao Exp $  */
/* --------------------------------------------------------------------
 * I/STRUCT
 *
 * File:        struct/pplapp/CObevelMod.u
 *
 * Description: command for modifying bevel macros
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: CObevelMod.u,v $
 *      Revision 1.5  2001/06/07 22:58:17  ramarao
 *      Fixed a modify bevel problem, where the bevel is flipped during modification.
 *
 *      Revision 1.4  2001/05/25 16:44:28  ramarao
 *      Fixed TR# 5255.
 *
 *      Revision 1.3  2001/04/12 18:26:00  ramarao
 *      Fixed TR# 5015.
 *
 *      Revision 1.2  2001/01/17 14:58:22  ramarao
 *      *** empty log message ***
 *
# Revision 1.6  2000/05/03  17:49:22  pinnacle
# Replaced: struct/pplapp/CObevelMod.u for:  by rchennup for Service Pack
#
# Revision 1.3  2000/04/25  17:24:36  pinnacle
# Replaced: struct/pplapp/CObevelMod.u for:  by rchennup for Service Pack
#
# Revision 1.2  2000/04/24  21:32:56  pinnacle
# ylong
#
# Revision 1.1  2000/04/21  22:35:28  pinnacle
# Created: struct/pplapp/CObevelMod.u by rchennup for Service Pack
#
# Revision 1.12  2000/04/05  21:36:22  pinnacle
# ylong
#
# Revision 1.11  2000/04/05  12:59:30  pinnacle
# Replaced: pplapp for:  by impd252 for struct
#
# Revision 1.9  2000/04/02  20:39:40  pinnacle
# Replaced: pplapp/CObevelMod.u for:  by impd252 for struct
#
# Revision 1.8  2000/03/31  19:41:58  pinnacle
# ylong
#
# Revision 1.7  2000/03/23  23:28:02  pinnacle
# ylong
#
# Revision 1.3  2000/02/29  16:38:08  pinnacle
# ylong
#
# Revision 1.2  2000/02/18  14:41:10  pinnacle
# ylong
#
# Revision 1.1  2000/02/11  00:24:16  pinnacle
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *	02/04/00	ylong		Creation
 *	02/18/00	ylong		modified for EJ_Bevel & VA_Bevel
 *	02/29/00	ylong		added funcionality for Fab_Stock
 *	03/23/00	ylong		added some features and fixes
 *	04/04/00	ylong		check all curves by CheckCurve()
 *      04/05/00        ylong           crashed at form pointer in wakeup
 * -------------------------------------------------------------------*/

/*
#define  DEBUG	1
#define  vsDEBUG	1
*/
#include "FI.h"
#include "VDppl.h"
#include "VSbevel.h"
#include "VDmem_ppl.h"
#include "VDobj.h"
#include "VDsa.h"
#include "VDgeom.h"
#include "VDfrm.h"
#include "vsgeommacros.h"
#include "v_miscmacros.h"
#include "vdAPImacros.h"
#include "asmacros.h"

#include "vsdbgmacros.h"

/************************************************************
  Define Constants.
 ************************************************************/
/*
 * Define constants for form 
 */
#define FORM_LABEL	100		// Arbitrary Number for Form
#define FORM_NAME	"VSbevel.frm"	// Form File
#define TITLE_STRING	"Modify Bevel"

/************************************************************
  External functions.
 ************************************************************/
extern	ci_notification();	/* The forms system automatically calls    */
				/* this function, which in turn calls your */
				/* form_notification function              */

extern	FIf_set_cmd_oid_os();	/* This function tells the forms system */
				/* to notify this command file when the */
				/* user manipulates the form */

extern	FIf_reset() ;
extern	FIf_new();		/* Creates the form              */
extern	FIf_display();		/* Draws the form                */
extern	FIf_erase();		/* Erases the form               */
extern	FIf_delete();		/* Removes the form              */
extern	FIg_get_value();	/* Retrieves values from gadgets */
extern	FIg_set_value();	/* Retrieves values from gadgets */
extern	FIg_reset() ;
extern	FIg_unhilite() ;
extern	FIfld_set_select() ;
extern  FIg_is_valid();
extern  FIg_get_attr();

extern	BSfreecv() ;

extern	isdigit() ;
extern	GRcopyobject() ;
extern	GRdpb_get();
extern	GRdisplay_object() ;
extern	EX_get_global() ;
extern	CheckEJcurve() ;
extern	CheckCurve() ;
extern	GetNeatPlate() ;
extern	DisplayGadgets() ;
extern	CheckForProperName() ;
extern	GetMacroName();
extern	CreateInputCollector() ;
extern	GetLabelPoint() ;
extern	ObjsIdentical() ;
extern	GetNeatEdges() ;
extern	GetBevelEdges() ;
extern	ConstructBevel() ;
extern	UpdateMacro() ;
extern	FillInFormForEJ_Bevel();
extern	FillInFormForBevel();
extern	FillInFormForVariable_Bevel();
extern	ShowBevel() ;
extern  VSbvl_set_bevel_type() ;
extern  VSbvl_get_bevel_type() ;
extern  VSbvl_set_font_size() ;
extern  VSbvl_get_font_size() ;
extern  VSsetGlobalFontSize() ;
extern VSbevelCheckForPartialCurve() ;

/************************************************************
  Global variables.
 ************************************************************/
int	test_wakeup;	// The wakeup function uses this flag to
			// test if the main function has started yet.

int	form_exists,	// The delete function uses this flag
			// to test if the form exists 
	form_displayed,	// The sleep function uses this flag
			// to test if the form is displayed
	form_labels[60],
	not_done;		// This value is set to 0 when the user
			// selects the cancel or exit & save buttons

Form	form;		// Use this variable for the forms functions. 

struct	CIform_st form_st;	// This structure contains information on
				// which form and gadget was manipulated. 

TGRobj_env	adjPltOE;		// adjacent plate for "1 plate" case
TGRobj_env	neatPltOE1;		// objEO of neat plate 1
TGRobj_env	neatPltOE2;		// objEO of neat plate 2
TGRobj_env	bvlMacOE;		// bevel macro OE
TGRobj_env	objOEs[MAX_TEMPS];	// new parent OEs of bvlMac
TGRobj_env	oldOEs[MAX_TEMPS];	// old parent OEs of bvlMac
TGRid           newTempIDs[MAX_TEMPS];	// new template IDs of bvlMac
TGRid           oldTempIDs[MAX_TEMPS];	// old template IDs of bvlMac
IGRint		objCnt ;
IGRint		attCnt ;



IGRchar		pltStr1[80];
IGRchar		pltStr2[80];
IGRchar		edgStr1[80];
IGRchar		edgStr2[80];
IGRchar         oldPntFlag[4] ;
IGRchar         newPntFlag[4] ;

IGRchar		EJpltStr[80];
IGRchar		EJcrvStr[80];
IGRdouble       EJthickness;

IGRchar		VApltStr[80];
IGRchar		VAbCrvStr[80];
IGRchar		VAoCrvStr[80];

IGRchar		bvlMacName[80];
IGRchar		macStr[80];
IGRchar		btStr[80];
IGRchar		ptStr[80];
IGRdouble       offsetVal;
IGRdouble	stockVal;

enum GRdpmode   dpBvlMode ;
enum GRdpmode   hilitMode ;
TGRid           hilitObj ;
IGRint          hilitGadget ;

struct	ACrg_coll	oldAttrs[MAX_ATTRS] ;
struct	ACrg_coll	newAttrs[MAX_ATTRS] ;

IGRint          fontSize ;
IGRchar         fontStr[80] ;

IGRchar		msgStr[128];
enum GRdpmode	dpMode ;

void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  __DBGpr_com("return_error");
  status("");		/* Clear the status field  */
  message("");		/* Clear the message field */
  exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  int error;
  
  SetProc(CObevelMod - form_init); Begin
 /*************************
   Create (load) the form.
  *************************/
  __DBGpr_str("Form name",FORM_NAME);
  error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &form );
  if ( form == NULL ) 
    {
      write( "Could not create the form.\n",
             "Error code = ",  error,  "\n"  );
      return_error();
    }

  form_exists = TRUE;  /* Flag for delete function */

 /**********************************************
   Tell the Forms System to notify this command
   file when the user manipulates the form.
  **********************************************/
  error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
  if ( error )
    {
      write( "Could not link to the Forms System.\n",
             "Error code = ",    error,         "\n"  );
      form_exists = FALSE;
      return_error();
    }

  /* Set the title on the form */
  FIg_set_text( form, FORM_TITLE, TITLE_STRING);

 /*******************
   Display the form.
  *******************/
  
  error = FIf_display( form );
  if ( error ) {
      write( "Could not display the form.\n",
             "Error code = ",  error,   "\n"  );
      return_error();
  }

  form_displayed = TRUE;  /* Flag for sleep function */

  End
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  char outString[80];
  SetProc(CObevel - form_notification); Begin
  
  ci$put( response = MOVE_ON );  /* Give control to the main function */
  End
}

DisableAllExceptCancel()
{
   IGRint       i, attr ;

   for( i=0; i<60; i=i+1 )
   {
       form_labels[i] = 0 ;
       if( i == FI_CANCEL ) continue;
       if( ! ( FIg_is_valid( form, i )) )
       {
          FIg_get_attr( form, i, &attr ) ;
          if( !( attr & FI_NOT_DISPLAYED ) )
          {
             FIg_disable( form, i );
             form_labels[i] = 1 ;
          }
       }
    }
}

EnableAllExceptCancel()
{
   IGRint       i;

   for( i=0; i<60; i=i+1 )
   {
       if( i == FI_CANCEL ) continue;
       if( form_labels[i] ) FIg_enable( form, i );
    }
}

IGRchar*        GetNumber( type )
IGRchar  *type;
{
IGRint          i;
IGRchar         copy_str[200];

   strcpy( copy_str, type );

   for( i=0; i<strlen(type); i=i+1 )
   {
      if( !isdigit(type[i]) )
      {
         copy_str[i] = '\0';
         break;
      }
   }
   return (copy_str);
}

wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  SetProc( CObevelMod - wakeup); Begin
  /* Display the form unless the command file is just starting */
  __DBGpr_int("CObevelMod waking up, test_wakeup",test_wakeup);
  __DBGpr_int("CObevelMod waking up, not_done", not_done);
  if ( test_wakeup == 1 && not_done ) {
      if( form ) 
      {
	// FIf_display ( form );  /* Redisplay the form */
	EnableAllExceptCancel();
      	form_displayed = TRUE; /* Set flag for sleep function */
      }
  }
  End
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  SetProc(CObevelMod - sleep ); Begin

  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
  {
    // FIf_erase ( form );
    DisableAllExceptCancel();
    form_displayed = FALSE;
  }
  End
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
   SetProc(CObevelMod - delete); Begin
	__DBGpr_int("form_displayed", form_displayed);
	__DBGpr_int("form_exists", form_exists);
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE ) {
      FIf_erase ( form );
      form_displayed = FALSE;
  }

  /* Delete the form if it exists */
  if ( form_exists ) {
      if( form ) {
	FIf_delete( form );
 	form = NULL ;
      }
  }

  End
}


/**********************************************************/
IGRstat LocateOE( inType, inPrompt, selOE, objName, check)
IGRchar		*inType;
IGRchar		*inPrompt;
TGRobj_env	*selOE;
IGRchar		*objName;
IGRint		check;
{
	IGRint	i, attr, response, labels[60] ;

	if( selOE->obj_id.objid != NULL_OBJID ) {
		gr$display_object (     object_id = &selOE->obj_id ,
					md_env    = &selOE->mod_env ,
					mode      = GRhd ) ;
	}

        for( i=0; i<60; i=i+1 )
        {
           labels[i] = 0 ;
           if( ! ( FIg_is_valid( form, i )) )
           {
              FIg_get_attr( form, i, &attr ) ;
              if( !( attr & FI_NOT_DISPLAYED ) )
              {
                 FIg_disable( form, i );
                 labels[i] = 1 ;
              }
           }
        }

 	ci$locate(
		obj		= &selOE->obj_id.objid,
     		osnum		= &selOE->obj_id.osnum,
		md_env		= &selOE->mod_env,
		response	= &response,
		classes		= inType,
		prompt		= inPrompt, 
		stackable	= TRUE ,
		properties	= LC_LC_ONLY | LC_DP_ONLY | LC_RW,
		owner_action	= LC_RIGID_COMP  | LC_RIGID_OWNER | 
				  LC_FLEX_COMP   | LC_FLEX_OWNER  | 
				  LC_REF_OBJECTS );

        for( i=0; i<60; i=i+1 )
        {
           if( labels[i] ) FIg_enable( form, i );
        }
            
	__DBGpr_int("Locate response", response ) ;
	if( response == RESET && strstr( inPrompt, "Edge") != NULL ) {
		strcpy( objName, "Default" ) ;
		selOE->obj_id.objid = NULL_OBJID ;
		goto wrapup ;
	}

	if( response == RESET && strstr( inPrompt, "Point") != NULL ) {
		strcpy( objName, "Auto" ) ;
		selOE->obj_id.objid = NULL_OBJID ;
		goto wrapup ;
	}

	if( selOE->obj_id.objid != NULL_OBJID ) {
		if (CheckForProperName( selOE, check, objName, msgStr ) ){
                	__DBGpr_str("Returned name is ",objName);
        	}
	}

wrapup:
   return TRUE;
}

/***********************************************************************/
IGRstat	SetNewAttributeCollector( form, attCnt, newAttrs, attOE )
	Form		form ;
	IGRint		attCnt ;
struct	ACrg_coll	*newAttrs ;
	TGRobj_env	*attOE ;
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRlong		msg ;
	TGRobj_env	tmpOE ;

	sts = CreateInputCollector (form, attCnt, "", newPntFlag, &tmpOE ) ;
	if( !(sts&1) ) {
		strcpy( msgStr, "CreateInputCollector failed");
		goto wrapup ;
	}

        sts = ci$send ( msg      = message  ACrg_collect.AClist_attribute(
                                                &msg ,
                                                MAX_ATTRS ,
                                                newAttrs ,
                                                &attCnt ) ,
                        targetid = tmpOE.obj_id.objid ,
                        targetos = tmpOE.obj_id.osnum ) ;
        if( !(sts&msg&1) ) {
                strcpy( msgStr,"ACrg_collect.AClist_attribute failed");
                goto wrapup ;
        }

	vdobj$Delete( objOE = &tmpOE ) ;

	sts = ci$send( msg = message ACrg_collect.ACset_list_attribute(
					&msg ,
					attCnt,
					newAttrs ),
			targetid = attOE->obj_id.objid ,
			targetos = attOE->obj_id.osnum ) ;
	if( !(sts&msg&1) ) {
		strcpy(msgStr,"ACrg_collect.ACset_list_attribute failed");
		goto wrapup ;
	}

	retFlag = 1 ;
wrapup:
	return retFlag ;
}



/*********************************************************************/
IGRstat ModifyEJ_BevelObjs ( objOEs )
TGRobj_env	*objOEs ;
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRlong		msg ;
	TGRid		crvID ;
	TGRobj_env	tmpOE ;
	TGRobj_env	bvlCrvOE;	// bevel curve OE
	TGRbsp_curve	*bvlCrv ;	// bevel crv

SetProc(CObevelMod - ModifyEJ_BevelObjs); Begin

	retFlag = 0;
	bvlCrv	= NULL ;

	// get new attribute collector
	sts = SetNewAttributeCollector(form, attCnt, newAttrs, &objOEs[E_ATTR]);
	if( !sts ) {
		__DBGpr_com("SetNewAttributeCollector failed");
	}

	// Check input
        if( objOEs[E_PLATE].obj_id.objid == NULL_OBJID ) {
		objOEs[E_PLATE] = oldOEs[E_PLATE] ;
        }

        if( objOEs[E_CURVE].obj_id.objid == NULL_OBJID ) {
		objOEs[E_CURVE] = oldOEs[E_CURVE] ;
        }

	if( newPntFlag[0] == '0' ) {
	        // get curve geometry
                vs$get_geometry(msg      = &msg ,
                                grobjId  = &objOEs[E_CURVE].obj_id ,
                                grobjEnv = &objOEs[E_CURVE].mod_env ,
                                geometry = &bvlCrv ) ;
                if( !(msg&1) ) {
                        printf("vs$get_geometry failed\n") ;
                        strcpy(msgStr,"Can't get geometry of bevel curve") ;
                        goto wrapup ;
                }

                VSbevelCheckForPartialCurve( objOEs[E_CURVE],
                                bvlCrv, objOEs[E_CURVE].mod_env, &crvID );
                _FREE( bvlCrv ) ;

                vs$get_geometry(msg      = &msg ,
                                grobjId  = &crvID,
                                grobjEnv = &objOEs[E_CURVE].mod_env,
                                geometry = &bvlCrv ) ;

                vd_$bulk_delete( grids  = &crvID,
                                 theEnv = &bvlMacOE.mod_env  );

                sts = GetLabelPoint (   &objOEs[E_PLATE],
                                        bvlCrv,
                                        offsetVal,
                                        &objOEs[E_POINT] ) ;
                if( !sts ) {
                        printf("GetLabelPoint failed to get E_POINT\n") ;
                        strcpy(msgStr,"GetLabelPoint failed") ;
                        goto wrapup ;
                }
                __DBGpr_obj("objOEs[E_POINT]", objOEs[E_POINT].obj_id);
	}

	if( oldPntFlag[0] == '0' ) vdobj$Delete( objOE = &oldOEs[E_POINT] ) ;

	msgStr[0] = '\0' ;
	retFlag = 1 ;
wrapup:
        if( bvlCrv )  _FREE( bvlCrv ) ;
End
	return retFlag ;
}

/*********************************************************************/
IGRstat ModifyBevelObjs ( objOEs )
TGRobj_env	*objOEs ;
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRlong		msg ;
	TGRobj_env	tmpOE ;
	TGRobj_env	bvlCrvOE;	// bevel curve OE
	TGRbsp_curve	*bvlCrv ;	// bevel crv
	TGRobj_env	*edgOEs1,	*edgOEs2 ;
        IGRint          edgCnt1,        edgCnt2 ;
        IGRint          attrCnt ;
        BSrc            rc ;

SetProc(CObevelMod - ModifyBevelObjs); Begin

	retFlag = 0;
	edgOEs1 = NULL ;
	edgOEs2 = NULL ;
	bvlCrv	= NULL ;

	// get new attribute collector
	sts = SetNewAttributeCollector(form, attCnt, newAttrs, &objOEs[ATTRIN]);
	if( !sts ) {
		__DBGpr_com("SetNewAttributeCollector failed");
	}

	// Check input
	if( objOEs[PLATE1].obj_id.objid == NULL_OBJID ) {
                strcpy( msgStr, "Plate 1 not input yet" ) ;
                goto wrapup ;
        }

        if( objOEs[PLATE2].obj_id.objid == NULL_OBJID ) {
                strcpy( msgStr, "Plate 2 not input yet" ) ;
                goto wrapup ;
        }

        if( ObjsIdentical (     objOEs[PLATE1].obj_id,
                                objOEs[PLATE2].obj_id ) ) {
                strcpy( msgStr, "2 identical plates not allowed." ) ;
                goto wrapup ;
        }

        // Get neat edges  if needed
	if( neatPltOE1.obj_id.objid == NULL_OBJID ) {
		GetNeatPlate( &objOEs[PLATE1], &neatPltOE1) ;
	}
        if( objOEs[EDGE1].obj_id.objid == NULL_OBJID ) {
                sts = GetNeatEdges( &neatPltOE1, &edgOEs1, &edgCnt1 ) ;
                if( !sts )  {
                        strcpy(msgStr, "GetNeatEdges failed");
                        goto wrapup ;
                }
        }
        else {
		edgOEs1 = _CALLOC( 1, TGRobj_env ) ;
		if( edgOEs1 == NULL ) goto wrapup ;
                edgOEs1[0] = objOEs[EDGE1] ;
                edgCnt1 = 1 ;
        }

	if( neatPltOE2.obj_id.objid == NULL_OBJID ) {
		GetNeatPlate( &objOEs[PLATE2], &neatPltOE2) ;
	}
        if( objOEs[EDGE2].obj_id.objid == NULL_OBJID ) {
                sts = GetNeatEdges( &neatPltOE2, &edgOEs2, &edgCnt2 ) ;
                if( !sts )  {
                        strcpy( msgStr, "GetNeatEdges failed");
                        goto wrapup ;
                }
        }
        else {
		edgOEs2 = _CALLOC( 1, TGRobj_env ) ;
		if( edgOEs2 == NULL ) goto wrapup ;
                edgOEs2[0] = objOEs[EDGE2] ;
                edgCnt2 = 1 ;
        }

        // Get bevel edges if not input from user
        if( edgCnt1 > 1 || edgCnt2 > 1 ) {
                sts = GetBevelEdges(    edgOEs1, edgCnt1,
                                        edgOEs2, edgCnt2,
                                        &objOEs[EDGE1], &objOEs[EDGE2] ) ;
                if( !sts ) {
                        printf("GetBevelEdges failed\n") ;
                        strcpy(msgStr, 
			"No overlap found between edges or plates") ;
                        objOEs[EDGE1].obj_id.objid = NULL_OBJID ;
                        objOEs[EDGE2].obj_id.objid = NULL_OBJID ;
                        goto wrapup ;
                }
        }
        __DBGpr_obj("objOEs[EDGE1]", objOEs[EDGE1].obj_id) ;
        __DBGpr_obj("objOEs[EDGE2]", objOEs[EDGE2].obj_id) ;
	if( ObjsIdentical( objOEs[EDGE1].obj_id, objOEs[EDGE2].obj_id) ) {
		gr$copy_object(	msg	= &msg ,
				object_id= &objOEs[EDGE1].obj_id ,
				md_env	= &objOEs[EDGE1].mod_env ,
				new_env	= &objOEs[EDGE2].mod_env ,
				new_id	= &objOEs[EDGE2].obj_id ) ;
		if( !(msg&1) ) {
			printf("vd_$grCopy failed\n") ;
			goto wrapup ;
		}
	}
 

        // Get bevel curve to compute label points if user not input point
        if ( newPntFlag[0] == '0' || newPntFlag[1] == '0' ) {
                sts = ConstructBevel (  &objOEs[EDGE1],
                                        &objOEs[EDGE2],
                                        &bvlCrvOE,
                                        &bvlCrv ) ;
                if( !sts || bvlCrvOE.obj_id.objid == NULL_OBJID) {
                        printf("ConstructBevel failed\n") ;
                        strcpy(msgStr,
			"Edges or plates may not adjoin within tolerance") ;

                        objOEs[EDGE1].obj_id.objid = NULL_OBJID ;
                        objOEs[EDGE2].obj_id.objid = NULL_OBJID ;
                        goto wrapup ;
                }
                // Delete bvlCrvOE, since we only need bvCrv so far and
                // bvlCrvOE will be built in macro as macro input
                vdobj$Delete( objOE = &bvlCrvOE ) ;
                bvlCrvOE.obj_id.objid  = NULL_OBJID ;
        }

        if( newPntFlag[0] == '0' ) {
                sts = GetLabelPoint (   &objOEs[PLATE1],
                                        bvlCrv,
                                        offsetVal,
                                        &objOEs[POINT1] ) ;
                if( !sts ) {
                        strcpy(msgStr,"GetLabelPoint failed") ;
                        goto wrapup ;
                }
                __DBGpr_obj("objOEs[POINT1]", objOEs[POINT1].obj_id);

        }

        if( newPntFlag[1] == '0' ) {
                sts = GetLabelPoint (   &objOEs[PLATE2],
                                        bvlCrv,
                                        -offsetVal,
                                        &objOEs[POINT2] ) ;
                if( !sts ) {
                        strcpy(msgStr,"GetLabelPoint failed") ;
                        goto wrapup ;
                }
                __DBGpr_obj("objOEs[POINT2]", objOEs[POINT2].obj_id);
        }

	if( oldPntFlag[0] == '0' ) vdobj$Delete( objOE = &oldOEs[POINT1] ) ;
	if( oldPntFlag[1] == '0' ) vdobj$Delete( objOE = &oldOEs[POINT2] ) ;

	msgStr[0] = '\0' ;
        retFlag = 1 ;
wrapup:
        if( bvlCrv )  _FREE( bvlCrv  ) ;
	if( edgOEs1 ) _FREE( edgOEs1 ) ;
	if( edgOEs2 ) _FREE( edgOEs2 ) ;
End
        return retFlag ;
}


/*********************************************************************/
IGRstat ModifyVariable_BevelObjs ( objOEs )
TGRobj_env	*objOEs ;
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRlong		msg ;
	TGRobj_env	tmpOE ;
	TGRobj_env	bvlCrvOE;	// bevel curve OE
	TGRbsp_curve	*bvlCrv ;	// bevel crv

SetProc(CObevelMod - ModifyVariable_BevelObjs); Begin

	retFlag = 0;
	bvlCrv	= NULL ;

	// set new attribute collector
	sts = SetNewAttributeCollector(form, attCnt, newAttrs, &objOEs[V_ATTR]);
	if( !sts ) {
		__DBGpr_com("SetNewAttributeCollector failed");
	}

	// Check input
        if( objOEs[V_PLATE].obj_id.objid == NULL_OBJID ) {
		objOEs[V_PLATE] = oldOEs[V_PLATE] ;
        }

	if( objOEs[V_BASE_CRV].obj_id.objid == NULL_OBJID ) {
		objOEs[V_BASE_CRV] = oldOEs[V_BASE_CRV] ;
	}

	if( objOEs[V_OFF_CRV].obj_id.objid == NULL_OBJID ) {
		objOEs[V_OFF_CRV] = oldOEs[V_OFF_CRV] ;
	}

	if( newPntFlag[0] == '0' ) {
	        // get curve geometry
                vs$get_geometry(msg      = &msg ,
                                grobjId  = &objOEs[V_BASE_CRV].obj_id ,
                                grobjEnv = &objOEs[V_BASE_CRV].mod_env ,
                                geometry = &bvlCrv ) ;
                if( !(msg&1) ) {
			strcpy( msgStr, "Can't get bevel curve");
			goto wrapup ;
		}

                sts = GetLabelPoint (   &objOEs[V_PLATE],
                                        bvlCrv,
                                        offsetVal,
                                        &objOEs[V_POINT] ) ;
                if( !sts ) {
                        strcpy( msgStr, "GetLabelPoint failed") ;
                        goto wrapup ;
                }
                __DBGpr_obj("objOEs[V_POINT]", objOEs[V_POINT].obj_id);
	}
	
	if( oldPntFlag[0] == '0' ) vdobj$Delete( objOE = &oldOEs[V_POINT] ) ;

	msgStr[0] = '\0' ;
	retFlag = 1 ;
wrapup:
        if( bvlCrv )  _FREE( bvlCrv ) ;
End
	return retFlag ;
}
/*****************************************************************/
IGRstat ModifyMacro() 
{
	IGRstat		retFlag ;
	IGRstat		sts ;

SetProc( CObevelMod - ModifyMacro); Begin

	retFlag = 0 ;

	__DBGpr_str("macStr", macStr);
	switch( macStr[0] ) {
	
	case 'F' :
	case '1' :
		sts = ModifyEJ_BevelObjs ( objOEs ) ;
		break ;
	case '2' :
		sts = ModifyBevelObjs ( objOEs ) ;
		break ;
	case 'V' :
	case 'v' :
		sts = ModifyVariable_BevelObjs(	objOEs ) ;
		break ;
	}

	if( !sts ) {
		printf("Modification failed\n") ;
		goto wrapup ;
	}

	sts = UpdateMacro( &bvlMacOE, objOEs, objCnt, newPntFlag ) ;
	if( !sts ) {
		printf("UpdateMacro() failed\n") ;
		strcpy(msgStr, "UpdateMacro() failed") ;
		goto wrapup ;
	}

	retFlag = 1 ;
wrapup:
End
	return retFlag ;
}

/************************************************************************/
FillInForm() 
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRint		i ;

SetProc(CObevelMod - FillInForm); Begin

	retFlag = 1 ;

	switch( bvlMacName[0] ) {
	
	   case 'F' :
	   case 'E' :
		sts = FillInFormForEJ_Bevel(
					form, 
					&bvlMacOE, 
					oldAttrs,
					oldOEs, 
					oldPntFlag ) ;
		objCnt = MAX_TEMP1 ;
		attCnt = MAX_ATTR1 ;
		if(bvlMacName[0] == 'E' ) strcpy( macStr, "1 Plate" );
		if(bvlMacName[0] == 'F' ) strcpy( macStr, "Fabrication Stock");
		break ;
	
	   case 'B' :
		sts = FillInFormForBevel(
					form, 
					&bvlMacOE, 
					oldAttrs,
					oldOEs, 
					oldPntFlag ) ;
		objCnt = MAX_TEMP2 ;
		attCnt = MAX_ATTR2 ;
		strcpy( macStr,   "2 Plates" ) ;

		break ;

	   case 'V' :
	   case 'V' :
		sts = FillInFormForVariable_Bevel(
					form, 
					&bvlMacOE, 
					oldAttrs,
					oldOEs, 
					oldPntFlag ) ;
		objCnt = MAX_TEMPv ;
		attCnt = MAX_ATTRv ;
		strcpy( macStr,   "Variable Plate" ) ;

		break ;
	}
	__DBGpr_str("oldPntFlag", oldPntFlag);

	for( i = 0; i < objCnt; i = i+1 ) {
		objOEs[i] = oldOEs[i] ;
	}
	for( i = 0; i < attCnt; i = i+1 ) {
	  strcpy( newAttrs[i].name, oldAttrs[i].name ) ;
	  newAttrs[i].desc.type = oldAttrs[i].desc.type ;
	  if(oldAttrs[i].desc.type == 1) {
	     strcpy(	newAttrs[i].desc.value.att_txt ,
			oldAttrs[i].desc.value.att_txt ) ;
	  }
	  else {
	     newAttrs[i].desc.value.att_exp = oldAttrs[i].desc.value.att_exp ;
	  }

	  if( !strcmp( oldAttrs[i].name, "label_flag" ) ) {
	     strcpy( oldPntFlag, oldAttrs[i].desc.value.att_txt ) ; 
	     strcpy( newPntFlag, oldPntFlag ) ; 
		__DBGpr_str("oldPntFlag", oldPntFlag);
	  }

	  if( !strcmp( oldAttrs[i].name, "offset_value" ) ) {
		offsetVal = oldAttrs[i].desc.value.att_exp ;
	  }

	  if( !strcmp( oldAttrs[i].name, "macro_type" ) ) {
	     strcpy( macStr, oldAttrs[i].desc.value.att_txt ) ;
	  }
	}
	DisplayGadgets( form, macStr ) ;

	if( !sts ) {
		retFlag = 0 ;
	}
wrapup:
End
	return retFlag ;
}

/***************************************************************************/
IGRstat HiliteObjByClickField ( gadget )
IGRint  gadget ;
{
        IGRint          retFlag;
        TGRid           objID ;
        IGRchar         text[128] ;

        retFlag         = 1 ;
        text[0]         = '\0' ;
        objID.objid     = NULL_OBJID ;

	if( gadget <= 0 ) goto wrapup ;

        if( dpBvlMode == GRhe ) dpBvlMode = GRhd ;
        else                    dpBvlMode = GRhe ;

        FIg_get_text( form, gadget, text );
        if( text[0] == '\0' ) goto wrapup ;
        __DBGpr_str("Field text", text);

        switch( gadget ) {
                case EJ_PLATE_FLD:
                        objID = objOEs[E_PLATE].obj_id ;
                        break ;
                case EJ_CURVE_FLD:
                        objID = objOEs[E_CURVE].obj_id ;
                        break ;
                case PLATE1_FLD:
                        objID = objOEs[PLATE1].obj_id ;
                        break ;
                case PLATE2_FLD:
                        objID = objOEs[PLATE2].obj_id ;
                        break ;
                case EDGE1_FLD:
                        objID = objOEs[EDGE1].obj_id ;
                        break ;
                case EDGE2_FLD:
                        objID = objOEs[EDGE2].obj_id ;
                        break ;
                case VA_PLATE_FLD:
                        objID = objOEs[V_PLATE].obj_id ;
                        break ;
                case VA_BASE_CRV_FLD:
                        objID = objOEs[V_BASE_CRV].obj_id ;
                        break ;
                case VA_OFF_CRV_FLD:
                        objID = objOEs[V_OFF_CRV].obj_id ;
                default:
                        goto wrapup ;
        }
        if( objID.objid == NULL_OBJID) goto wrapup ;

        if( hilitObj.objid == objID.objid ) {
                if( hilitMode == GRhe ) hilitMode = GRhd ;
                else                    hilitMode = GRhe ;
        }
        else {
                gr$display_object (     object_id = &hilitObj ,
                                        md_env    = &MOD_ENV ,
                                        mode      = GRhe ) ;
                hilitMode = GRhd ;
                hilitObj = objID ;
        }

        if( hilitGadget > 0 && hilitGadget != gadget ) {
                FIg_get_text( form, hilitGadget, text ) ;
                FIfld_set_select( form, hilitGadget, 0, 0, FALSE ) ;
                FIg_set_text( form, hilitGadget, text ) ;
        }

        hilitGadget = gadget ;
        gr$display_object (     object_id = &hilitObj ,
                                md_env    = &MOD_ENV ,
                                mode      = hilitMode ) ;
wrapup:
        return retFlag ;
}


/*****************************************************************/
Initiate()
{
	IGRint		i ;
	IGRint          txtLen, txtBytes, bytesRet ;
struct  GRdpb_text_symb txtSymb ;

SetProc(CObevelMod - Initiate); Begin

	pltStr1[0]	= '\0' ;
	pltStr2[0]	= '\0' ;
	edgStr1[0]	= '\0' ;
	edgStr2[0]	= '\0' ;
	btStr[0]	= '\0' ;
	ptStr[0]	= '\0' ;
	stockVal	= 0 ;
	offsetVal	= 0 ;

        dpBvlMode       = GRhe ;
        hilitMode       = GRhe ;
        hilitObj.objid  = NULL_OBJID ;
        hilitGadget     = -1 ;

	for( i = 0; i < MAX_TEMPS; i = i+1 ) {
		objOEs[i].obj_id.objid	= NULL_OBJID;
		oldOEs[i].obj_id.objid  = NULL_OBJID ;
		newTempIDs[i].objid     = NULL_OBJID ;
		oldTempIDs[i].objid     = NULL_OBJID ;
	}
	neatPltOE1.obj_id.objid = NULL_OBJID;
	neatPltOE2.obj_id.objid = NULL_OBJID;
/*
        gr$get_text_symb( msg   = &msg ,
                        sizbuf  = &txtBytes ,
                        buffer  = &txtSymb ,
                        nret    = &bytesRet ) ;
        if( !(msg&1) ) {
                fontSize = 25 ;
        }
        else {
                fontSize = txtSymb.Active_width ;
        }

        __DBGpr_int("fontSize 1", fontSize);
        VSbvl_set_font_size(fontSize) ;
        fontSize = VSbvl_get_font_size() ;
        sprintf(fontStr, "%d", fontSize);
        FIg_set_text( form, FONT_SIZE, fontStr);
*/

	/*
         * Get information from the bevel_setup file.
         */
        VSbev_ReadSetupFile( form );

	End
	return ;
}


main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/
{

  IGRint	response;     
  IGRint	i;
  IGRint	m;
  IGRint	msg;
  IGRint	pos, toggle;
  IGRint	selFlag;
  IGRint	exitFlag;
  IGRint	numAttrs, num_rows;
  IGRint	sts;
  IGRint 	error;
  IGRchar	tmpStr[80], typeStr[80] ;
  TGRobj_env	offsetSrfOE, tmpOE ;
  BSrc		rc ;

  /* initialize some parameters before we start */
  test_wakeup = 1;		/* flag for wakeup function */
  form_exists = FALSE;		/* flag for delete function */
  form_displayed = FALSE;	/* flag for sleep  function */
  not_done = TRUE;		/* Set this to FALSE when done with form */
  exitFlag = 1;
  tmpStr[0]  = '\0' ;
  form_st.gadget_label = -1 ;

again:
  message("Bevel/Stock Macro Modification");

  if( form_st.gadget_label == FI_EXECUTE ) {
        LocateOE( "nci_macro", "Identify Bevel/Fab_Stock or hit F1 to quit",
                        &bvlMacOE, tmpStr, FALSE);
  }
  else {
        LocateOE( "nci_macro", "Identify Bevel/Fab_Stock",
                        &bvlMacOE, tmpStr, FALSE);
  }

reset:

  if( GetMacroName( bvlMacOE.obj_id, bvlMacName, msgStr ) != TRUE ) {
	UI_status(msgStr) ;
        goto again;
  }
  else {
	if (	!strcmp( bvlMacName, "Fab_Stock" ) || 
		!strcmp( bvlMacName, "EJ_Bevel"  ) ||
		!strcmp( bvlMacName, "Bevel"     ) ||
		!strcmp( bvlMacName, "VA_Bevel" ) ) {
		sprintf( tmpStr, "Modify Macro %s", bvlMacName) ;
		message(tmpStr);
	}
	else {
		sprintf( msgStr, "%s is not a bevel macro", bvlMacName);
		UI_status( msgStr ) ;
        	goto again;
	}
  }


  if( !form_exists ) { 
	form_init();      
  }
  message(TITLE_STRING);

  Initiate() ;

  get_current_file_name_and_mod_env();

  FillInForm() ; 
  VSsetGlobalFontSize( &bvlMacOE );
  fontSize = VSbvl_get_font_size() ;
  sprintf(fontStr, "%d", fontSize);
  FIg_set_text( form, FONT_SIZE, fontStr);

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/
  while (not_done )
  {
      __DBGpr_int("case", form_st.gadget_label);

      /* Suspend the command file and wait for the form */
      ci$get (	prompt   = "Fill in the form",
		response = &response );
              
      UI_status("");
      strcpy( msgStr, "" ) ;
      FIg_set_text( form, MESSAGE_BAR, "\n\n" ) ;
      __DBGpr_int("case", form_st.gadget_label);
      HiliteObjByClickField ( form_st.gadget_label ) ;
	
      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){

        case FI_CANCEL:		// Quit Button 
          not_done = 0;		// Stop the loop
	  exitFlag = 0;		// exit the program
          FIf_erase ( form );	// Erase the form 
          break;

        case MACRO_TYPE:	// Get Macro Type
  	  FIg_get_text( form, MACRO_TYPE, macStr );
	  DisplayGadgets( form, macStr ) ;
	  __DBGpr_str("Macro Type", macStr);
          break;

        case EJ_PLATE_BTN:	// Get Plate for "1 plate" case
 	  LocateOE( "VSplate", "Identify Plate/Move on", 
		     &objOEs[E_PLATE], EJpltStr, FALSE);
  	  FIg_set_text( form, EJ_PLATE_FLD, EJpltStr ); 
	  sts = GetNeatPlate(&objOEs[E_PLATE], &neatPltOE1);
	  if( !sts )  break;
	  FIg_enable( form, EJ_CURVE_BTN ) ;
	  FIg_enable( form, EJ_POINT_BTN ) ;
	  if( objOEs[E_CURVE].obj_id.objid != NULL_OBJID ) {
	  	//CheckEJcurve( &neatPltOE1, &objOEs[E_CURVE], msgStr ) ;
		CheckCurve (    "plate:base",
				&objOEs[E_PLATE],
				&objOEs[E_CURVE],
				msgStr) ;
	  }
	  if( !ObjsIdentical(objOEs[E_PLATE].obj_id,oldOEs[E_PLATE].obj_id)) {
		objOEs[E_POINT].obj_id.objid = NULL_OBJID ;
		objOEs[E_CURVE].obj_id.objid = NULL_OBJID ;
		FIg_set_text( form, EJ_CURVE_FLD, "" ); 
	  }
          break;

        case EJ_CURVE_BTN:	// Get CURVE for "1 plate" case
 	  LocateOE( "GRcurve", "Identify Curve (a neat edge of plate)/Move on", 
		     &objOEs[E_CURVE], EJcrvStr, FALSE) ;
	  if(neatPltOE1.obj_id.objid == NULL_OBJID) {
		GetNeatPlate( &objOEs[E_PLATE], &neatPltOE1) ;
	  }
	  if( CheckCurve (    "plate:base",
                                &objOEs[E_PLATE],
                                &objOEs[E_CURVE],
                                msgStr) ) {
		FIg_set_text( form, EJ_CURVE_FLD, EJcrvStr ) ;
		if(!ObjsIdentical( objOEs[E_CURVE].obj_id, 
				   oldOEs[E_CURVE].obj_id)) {
			ModifyMacro();
		}
	  }
          break;

	case EJ_POINT_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point/move on for auto", 
			&objOEs[E_POINT], tmpStr, FALSE);
	  if( objOEs[E_POINT].obj_id.objid == NULL_OBJID ) {
		newPntFlag[0] = '0' ;
	  }
	  else {
		newPntFlag[0] = '1' ;
	  }
	  ModifyMacro() ;
          break;

        case EJ_TOGGLE_INPUT:
	  FIg_get_state( form, EJ_TOGGLE_INPUT, &toggle ) ;
	  if( toggle ) {
		FIg_erase  ( form, EJ_ADJPLATE_BTN ) ;
		FIg_erase  ( form, EJ_PLATE_IN ) ;
		FIg_display( form, EJ_THICK_IN ) ;
	  }
	  else {
		FIg_erase  ( form, EJ_THICK_IN ) ;
		FIg_display( form, EJ_ADJPLATE_BTN ) ;
		FIg_display( form, EJ_PLATE_IN ) ;
	  }
	  break ;

        case EJ_THICK_IN:
	  FIg_get_value( form, EJ_THICK_IN, &EJthickness ) ;
	  break ;

        case EJ_ADJPLATE_BTN:
	  LocateOE( "VSplate", "Identify Adjacent Plate/Move on", 
			&adjPltOE, tmpStr, FALSE);
	  if( adjPltOE.obj_id.objid == NULL_OBJID ) break ;
	  vdsa$GetStruct(	objOE = &adjPltOE,
				name  = "plate_thk",
				dbl   = &EJthickness);
	  FIg_set_value( form, EJ_PLATE_IN, EJthickness ); 
          break;

        case VA_PLATE_BTN:	// Get Plate for "1 plate" case
 	  LocateOE( "VSplate", "Identify Deck/Bulkhead plate / Move on", 
		     &objOEs[V_PLATE], VApltStr, FALSE);
  	  FIg_set_text( form, VA_PLATE_FLD, VApltStr ); 
	  if( !ObjsIdentical(objOEs[V_PLATE].obj_id,oldOEs[V_PLATE].obj_id)) {
		objOEs[V_POINT   ].obj_id.objid = NULL_OBJID ;
		objOEs[V_BASE_CRV].obj_id.objid = NULL_OBJID ;
		objOEs[V_OFF_CRV ].obj_id.objid = NULL_OBJID ;
		FIg_set_text( form, VA_BASE_CRV_FLD, "" ); 
		FIg_set_text( form, VA_OFF_CRV_FLD, "" ); 
	  }

          break;

	case VA_BASE_CRV_BTN:
 	  LocateOE(	"GRcurve", "Identify Base Curve/Move on", 
			&objOEs[V_BASE_CRV], VAbCrvStr, FALSE);
	  if( CheckCurve("plate:base", 
			&objOEs[V_PLATE], 
			&objOEs[V_BASE_CRV], 
			msgStr))
	  {
		FIg_set_text( form, VA_BASE_CRV_FLD, VAbCrvStr ); 
		if(!ObjsIdentical( objOEs[V_BASE_CRV].obj_id, 
				   oldOEs[V_BASE_CRV].obj_id)) {
			ModifyMacro();
		}
	  }
          break;

	case VA_OFF_CRV_BTN:
 	  LocateOE(	"GRcurve", "Identify offset Curve/Move on", 
			&objOEs[V_OFF_CRV], VAoCrvStr, FALSE);
	  if( CheckCurve("plate:offset", 
			&objOEs[V_PLATE], 
			&objOEs[V_OFF_CRV], 
			msgStr) )
	  {
		FIg_set_text( form, VA_OFF_CRV_FLD, VAoCrvStr ); 
	  }
          break;

	case VA_POINT_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point/move on for auto", 
			&objOEs[V_POINT], tmpStr, FALSE);
	  if( objOEs[V_POINT].obj_id.objid == NULL_OBJID ) {
		newPntFlag[0] = '0' ;
	  }
	  else {
		newPntFlag[0] = '1' ;
	  }
	  ModifyMacro() ;
          break;

        case PLATE1_BTN:	// Get Plate 1
 	  LocateOE( "VSplate", "Identify Plate 1/Move on", 
		     &objOEs[PLATE1], pltStr1, FALSE);
  	  FIg_set_text( form, PLATE1_FLD, pltStr1 ); 
	  sts = GetNeatPlate(&objOEs[PLATE1], &neatPltOE1);
	  if( !sts ) break ;
	  if( !ObjsIdentical(objOEs[PLATE1].obj_id,oldOEs[PLATE1].obj_id)) {
		objOEs[POINT1].obj_id.objid = NULL_OBJID ;
		objOEs[EDGE1].obj_id.objid = NULL_OBJID ;
		FIg_set_text( form, EDGE1_FLD, "Default" ); 
	  }
          break;

        case PLATE2_BTN:	// Get Plate 2
 	  LocateOE("VSplate", "Identify Plate 2/Move on", 
		    &objOEs[PLATE2], pltStr2, FALSE);
  	  FIg_set_text( form, PLATE2_FLD, pltStr2 ); 
	  sts = GetNeatPlate(&objOEs[PLATE2], &neatPltOE2);
	  if( !sts ) break ;
	  if( !ObjsIdentical(objOEs[PLATE2].obj_id,oldOEs[PLATE2].obj_id)) {
		objOEs[POINT2].obj_id.objid = NULL_OBJID ;
		objOEs[EDGE2].obj_id.objid = NULL_OBJID ;
		FIg_set_text( form, EDGE2_FLD, "Default" ); 
	  }
          break;

        case EDGE1_BTN:		// Get Edge 1
 	  LocateOE(	"GRcurve", "Identify Edge 1/move on for default", 
			&objOEs[EDGE1], edgStr1, FALSE);
  	  FIg_set_text( form, EDGE1_FLD, edgStr1 ); 
	  ModifyMacro() ;
          break;

        case EDGE2_BTN:		// Get Edge 2
 	  LocateOE(	"GRcurve", "Identify Edge 2/move on for default", 
			&objOEs[EDGE2], edgStr2, FALSE);
  	  FIg_set_text( form, EDGE2_FLD, edgStr2 ); 
	  ModifyMacro() ;
          break;

	case BEVEL_TYPE:
          FIg_get_text( form, BEVEL_TYPE, btStr );
          strcpy( typeStr, GetNumber(btStr) );

          vdfrm$GetListNumRows( form = form, gadget = PROCESS_TYPE,
                                rows = &num_rows );

          for( i=0; i<num_rows; i=i+1 )
          {
            vdfrm$GetListText(  form = form, gadget = PROCESS_TYPE,
                                row = i, txt = tmpStr );
            if( !strncmp( typeStr, tmpStr, strlen(typeStr) ) )
            {
               vdfrm$SetText( form = form, gadget = PROCESS_TYPE,
                              txt = tmpStr );   
               break;
            }
          }
          __DBGpr_str("Bevel Type", btStr);

	case PROCESS_TYPE:
  	  FIg_get_text( form, PROCESS_TYPE, ptStr );
	  __DBGpr_str("Process Type", ptStr);
	  break ;

	case OFFSET_VALUE:
	  FIg_get_value( form, OFFSET_VALUE, &offsetVal);
	  __DBGpr_int("Offset Value", offsetVal);
	  break ;

	case STOCK_VALUE:
	  FIg_get_value( form, STOCK_VALUE, &stockVal);
	  __DBGpr_int("StockValue", stockVal);
	  break ;

        case FONT_SIZE:
          FIg_get_text( form, FONT_SIZE, fontStr);
          fontSize = atoi( fontStr );
          VSbvl_set_font_size(fontSize) ;
          break ;

	case POINT1_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point 1/move on for auto", 
			&objOEs[POINT1], tmpStr, FALSE);
	  if( objOEs[POINT1].obj_id.objid == NULL_OBJID ) {
		newPntFlag[0] = '0' ;
	  }
	  else {
		newPntFlag[0] = '1' ;
	  }
	  ModifyMacro() ;
          break;


	case POINT2_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point 2/move on for auto", 
			&objOEs[POINT2], tmpStr, FALSE);
	  if( objOEs[POINT2].obj_id.objid == NULL_OBJID ) {
		newPntFlag[1] = '0' ;
	  }
	  else {
		newPntFlag[1] = '1' ;
	  }
	  ModifyMacro() ;
	  break ;

	case SHOW_BEVEL_BTN:
	  if( bvlMacOE.obj_id.objid == NULL_OBJID ) {
		ShowBevel( macStr, objOEs, msgStr ) ;
	  }
	  else {
		gr$display_object (     object_id = &bvlMacOE.obj_id ,
					md_env    = &bvlMacOE.mod_env ,
					mode      = GRhd ) ;
	  }
	  break ;

        case FI_RESET:
	  not_done = TRUE ;
/*
	  tmpStr[0] = VSbvl_get_bevel_type();
	  FIf_reset( form ) ;
	  Initiate() ;
	  DisplayGadgets( form, tmpStr ) ;
	  FIf_reset( form ) ;
	  goto reset ;
*/
          tmpStr[0] = VSbvl_get_bevel_type();
          FIf_reset( form ) ;
          Initiate() ;
          DisplayGadgets( form, tmpStr ) ;
	  goto again ; 
	  break ;

        case FI_EXECUTE:
	  not_done = TRUE ;
	  if( ModifyMacro() ) {
		tmpStr[0] = VSbvl_get_bevel_type();
		FIf_reset( form ) ;
		Initiate() ;
		DisplayGadgets( form, tmpStr ) ;
		goto again ;
	  }
	  break;

        case FI_ACCEPT:
          if( ModifyMacro() ) {
		not_done = FALSE;
		FIf_erase ( form ); 
	  }
	  else {
		not_done = TRUE ;
	  }
          break;

        } /* END switch ( g_label ) */

	FIg_set_text( form, MESSAGE_BAR, msgStr ) ;
	UI_status( msgStr ) ;

    }     /* END while ( not done ) */

wrapup:

    status("") ;
    prompt("") ;
    message("") ;
    if ( exitFlag == 0 ) exit;

}

/********************************************************/

get_current_file_name_and_mod_env()
{
	IGRchar filename[132];
	IGRint  var_size[3];
	IGRint  bad_var;
	struct  EX_var_list      ex_var[4];


// GET THE CURRENT FILE NAME

	var_size[0] = sizeof(filename);
	ex_var[0].var = EX_CUR_FILENAME;
	ex_var[0].var_value = &filename[0];
	ex_var[0].num_bytes = &var_size[0];
	var_size[1] = NULL;

	msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

	__DBGpr_str("filename",filename);

 	ci$get_module_info( md_env = &MOD_ENV);

}
