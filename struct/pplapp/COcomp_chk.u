/* $Id: COcomp_chk.u,v 1.3 2001/03/09 17:45:34 ramarao Exp $  */
/* --------------------------------------------------------------------
 * I/STRUCT
 *
 * File:        struct/pplapp/COcomp_chk.u
 *
 * Description: PPL to recompute all the "Invalid" Chick plates.
 *		These plates are typically placed in post-placement.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COcomp_chk.u,v $
 *      Revision 1.3  2001/03/09 17:45:34  ramarao
 *      Prinited the computing plate information in the back screen.
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/18/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "nddef.h"
#include "ndmacros.h"
#include "vsplatedef.h"
#include "vsdbgmacros.h"

#define vdsDEBUG	1
#define vdserrDEBUG	1

extern GRclassid	OPP_VSsrcPlate_class_id, OPP_EMSplane_class_id,
			OPP_EMSgenbs_class_id ;

extern int VDpms_findall_ancestryobjects(), VSis_ancestry_valid();

extern 	EX_get_modid_given_osnum(), NDwait_batch(), NDget_mod_batch(),
	NDexec_batch(), printf();

main()
{
IGRlong			sts, msg;
IGRint			i, count, isConsumed, is_off_planar, is_base_genbs,
			cmp_count, cn_type, b_mod;
GRclassid		classid;
OM_S_OBJID		*list;
struct GRid		plate;
struct GRobj_env	base_surface_id, off_surface_id;

  count = 0;
  list  = NULL;
  cmp_count = 0;
  cn_type   = ND_COMP;

  message( "Recompute Invalid Chocks" );
  
  ci$get_module_info( md_env = &MOD_ENV);
  classid = OPP_VSsrcPlate_class_id ;

  VDpms_findall_ancestryobjects( MOD_ENV.md_id.osnum, 1, &classid,
				 &count, NULL );

  list = ( OM_S_OBJID * )malloc( count*sizeof(OM_S_OBJID) );
  if( list == NULL ) goto wrapup;

  VDpms_findall_ancestryobjects( MOD_ENV.md_id.osnum, 1, &classid,
				 &count, list );
  __DBGpr_int("Number Source Plates in Current OS ", count );

  for( i=0; i<count; i=i+1 )
  {
     isConsumed    = 0;
     is_off_planar = 0;
     is_base_genbs = 0;
     plate.objid = list[i];
     plate.osnum = MOD_ENV.md_id.osnum;

     __DBGpr_int("Checking ", i+1 );
     __DBGpr_obj("Plate Object ", plate );
     sts = ci$send(  msg     = message NDmacro.ACtest_consumed( &isConsumed ),
		     targetid = plate.objid,
		     targetos = plate.osnum );
     __DBGpr_int("Is Consumed? ", isConsumed );
     if( !(sts&1) || isConsumed ) continue;

     sts = ci$send( msg = message NDmacro.ACreturn_foot( &msg, VS_K_plBotSfPath,
                        &base_surface_id.obj_id, 
			&base_surface_id.mod_env.md_env.matrix_type,
                        base_surface_id.mod_env.md_env.matrix ),
                       targetid = plate.objid,
                       targetos = plate.osnum ) ;
     __CheckRC( sts, msg, "NDmacro.ACreturn_foot:Base", wrapup ) ;
     base_surface_id.mod_env.md_id.osnum = base_surface_id.obj_id.osnum;
     sts = ex$get_modid( mod_osnum = base_surface_id.mod_env.md_id.osnum,
                         mod_id    = &base_surface_id.mod_env.md_id.objid);
     __DBGpr_obj("Base Surface Id ", base_surface_id.obj_id );

     sts = ci$send( msg = message NDmacro.ACreturn_foot( &msg, VS_K_plTopSfPath,
                        &off_surface_id.obj_id, 
			&off_surface_id.mod_env.md_env.matrix_type,
                        off_surface_id.mod_env.md_env.matrix ),
                       targetid = plate.objid,
                       targetos = plate.osnum ) ;
     __CheckRC( sts, msg, "NDmacro.ACreturn_foot:Offset", wrapup ) ;
     off_surface_id.mod_env.md_id.osnum = off_surface_id.obj_id.osnum;
     sts = ex$get_modid( mod_osnum = off_surface_id.mod_env.md_id.osnum,
                         mod_id    = &off_surface_id.mod_env.md_id.objid);
     __DBGpr_obj("Offset Surface Id ", off_surface_id.obj_id );

     is_off_planar = VSis_ancestry_valid( &off_surface_id.obj_id,
					  OPP_EMSplane_class_id ) ;
     __DBGpr_int("Is Offset Planar? ", is_off_planar );

     is_base_genbs = VSis_ancestry_valid( &base_surface_id.obj_id,
					  OPP_EMSgenbs_class_id ) ;
     __DBGpr_int("Is Base B-Spline? ", is_base_genbs );

     if( is_off_planar && is_base_genbs )
     {
	cmp_count = cmp_count+1;
	sts = nd$wait_batch( type	= GR_GEOM_POSTED,
			     nb_obj	= 1,
			     l_object	= &plate,
			     l_obj_info = &cn_type );
	__DBGpr_com("YES. Need to recompute this plate");
	vdobj$Print( objID = &plate );
     }
     else __DBGpr_com("NO recompute for this plate" );
  }
  __DBGpr_int("Total Number of plates to recompute ", cmp_count );
  printf("Total Number of Plates to Recompute = %d\n", cmp_count );

  if( cmp_count )
  {
      nd$mod_batch(request     = ND_INQ,
                   p_ret_mode  = &b_mod );
      if( b_mod != ND_DEFER ) nd$exec_batch();
  }

wrapup:
  if( list ) free( list );
  return 1;
}
