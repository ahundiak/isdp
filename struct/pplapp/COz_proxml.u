/* -----------------------------------------------
 * 15 Apr 2002 - Art Hundiak
 * This is just a sample file for converting
 * a beam profile to xml
 *
 * Just keep it around to ducument the api calls
 */
#include "VDppl.h"
#include "VDobj.h"
#include "VDobj2.h"
#include "VDrisc.h"
#include "vsRDBmacros.h"
#include "vssectiondef.h"
#include "VDctx.h"
#include "VDgeom.h"
#include "VDval.h"

/* -----------------------------------------------
 * Process a single rep segment
 */
processPartRepSeg(repNodeID,repID,segNum)
  TGRid  *repNodeID;
  TGRid  *repID;
  IGRint *segNum;

{
  IGRstat retFlag;
  IGRstat msg,sts;

  TGRid   segID,segNodeID;

  IGRchar segName[32];

  TGRbsp_curve *segBsp;
  IGRchar      *segTxt;
  
  // Init
  retFlag = 0;

  // Get the segment, ok if it fails
  sts = ci$send(msg = message VSxscurve.
		VStransCmpToUsrNm(&msg,segNum,NULL,segName),
		targetid = repID->objid,
		targetos = repID->osnum);
  if (!(sts & msg & 1)) goto wrapup;
  
  // Get the actual id
  segID.objid = NULL_OBJID;
  sts = ci$send(msg = message VSxscurve.
		VStransUsrNmToCmp(&msg,segName,NULL,&segID),
		targetid = repID->objid,
		targetos = repID->osnum);
  if (segID.objid == NULL_OBJID) {
    printf("Part rep segment object not found\n");
  }

  // Grab the geometry
  vdgeom$Get2(objID = &segID, crv = &segBsp);
  if (segBsp == NULL) {
    printf("Unable to obtain geometry from segment\n");
    goto wrapup;
  }
  VDvalConvertBspCurveToText(segBsp,&segTxt);
  if (segTxt == NULL) {
    printf("Unable to convert segment geometry to text\n");
    free(segBsp);
    goto wrapup;
  }
  
  // Create the node
  VDctxCreateNode(repNodeID,"segment",NULL,&segNodeID);
  VDctxAppTxtAtr(&segNodeID,"name", segName);
  VDctxAppIntAtr(&segNodeID,"index",segNum);
  VDctxAppTxtAtr(&segNodeID,"curve",segTxt);

  free(segTxt);
  free(segBsp);
  
  printf("%d %s\n",segNum,segName);

  
  // Done
  retFlag = 1;
  
 wrapup:
  return retFlag;
}

/* -----------------------------------------------
 * Process a single rep
 */
processPartRep(partNodeID,partID,repName)
  TGRid   *partNodeID;
  TGRid   *partID;
  IGRchar *repName;
{
  IGRstat retFlag;
  IGRstat msg,sts;

  TGRid   repID,repNodeID;

  IGRint  i;

  // Init
  retFlag = 0;

  // Find the rep VSxscurve
  repID.objid = NULL_OBJID;
  ci$send(msg	= message NDmacro.
	  ACreturn_foot(&msg,repName,&repID,NULL,NULL),
	  targetid = partID->objid,
	  targetos = partID->osnum ) ;
  if (repID.objid == NULL_OBJID) {
    UI_status("Part rep curve not found");
    goto wrapup;
  }
  vdobj$Print(objID = &repID);

  // Add it
  VDctxCreateNode(partNodeID,"rep",NULL,&repNodeID);
  VDctxAppTxtAtr( &repNodeID,"rep",repName);
  
  // Cycle through segments
  for(i = 0; processPartRepSeg(&repNodeID,&repID,i); i = i + 1);
   
  // Done
  retFlag = 1;
  
 wrapup:
  return retFlag;
}

/* -----------------------------------------------
 * Process a single part 
 */
processPart(treeID,material,family,part)
  TGRid   *treeID;
  IGRchar *material;
  IGRchar *family;
  IGRchar *part;

{
  IGRstat msg,sts;

  TGRid   partID;

  TGRid familyNodeID;
  TGRid partNodeID;

  /* ---------------------------------------------
   * Cheat for now on making the family node
   */
  VDctxCreateNode(treeID,"family",NULL,&familyNodeID);
  VDctxAppTxtAtr(&familyNodeID,"family",  family);
  VDctxAppTxtAtr(&familyNodeID,"material",material);
  
  // Get a part
  partID.objid = NULL_OBJID;
  vs$load_part_from_RDB(msg = &msg,
			material = "STEEL",
			family   = "I_T_met",
			part     = "W-T 250 X 30",
			osnum    = 2,
			object   = &partID);
  if (partID.objid == NULL_OBJID) {
    UI_status("Macro part not found");
    goto wrapup;
  }
  vdobj$Print(objID = &partID);

  // Add to tree
  VDctxCreateNode(&familyNodeID,"part",NULL,&partNodeID);
  VDctxAppTxtAtr(&partNodeID,"part",part);

  // Process the reps
  processPartRep(&partNodeID,&partID,VS_K_WoFilletCv);
  /*
  processPartRep(&partNodeID,&partID,VS_K_EnvelopeCv);
  processPartRep(&partNodeID,&partID,VS_K_SchematicCv);
  */
  processPartRep(&partNodeID,&partID,VS_K_WFilletCv);

 wrapup:
  return 1;
  
}

/* -----------------------------------------------
 * Add macro information to the family node
 */
addPartMacro(familyNodeID,macroID)
  TGRid *familyNodeID;
  TGRid *macroID;
{
  IGRchar className[32];
  IGRchar macroName[32];

  IGRchar macroClassName[32];
  IGRchar macroMacroName[32];
  
  TGRid childNodeID;
  IGRint i;

  // Get the basic info
  VDobjGetClassName(NULL,macroID,macroClassName);
  VDobjGetMacroName(NULL,macroID,macroMacroName);

  if (*macroClassName == 0) {
    printf("No class name for %d,%d\n",macroID->osnum,macroID->objid);
    goto wrapup;
  }

  // Toss out dups
  for(i = 0; VDctxGetNthTreeChild(familyNodeID,i,&childNodeID); i = i + 1) {
    VDctxGetTxtAtr(&childNodeID,"class_name",className);
    if (!strcmp(className,macroClassName)) {
      VDctxGetTxtAtr(&childNodeID,"macro_name",macroName);
      if (!strcmp(macroName,macroMacroName)) {
        goto wrapup;
      }
    }
  }

  printf("%d,%d %s %s\n",
         macroID->osnum,
         macroID->objid,
         macroClassName,
         macroMacroName);

  // Make new node
  VDctxCreateNode(familyNodeID,"macro",NULL,&childNodeID);
  VDctxAppTxtAtr(&childNodeID,"class_name",macroClassName);
  if (*macroMacroName) {
    VDctxAppTxtAtr(&childNodeID,"macro_name",macroMacroName);
  }

wrapup:
  return 1;
}

/* -----------------------------------------------
 * Dumo info about a single part 
 */
dumpPart(treeID,material,family,part)
  TGRid   *treeID;
  IGRchar *material;
  IGRchar *family;
  IGRchar *part;

{
  IGRstat msg,sts;

  TGRid   defID;
  TGRid   realID;
  TGRid   partID;

  TGRid familyNodeID;
  TGRid partNodeID;

  struct myfeet *feetInfos;
  struct myfeet *feetInfo;
  int            feetCnt;
  int  i;

  OM_S_OBJID *otherIDs;
  TGRid       otherID;
  IGRint      otherCnt;

  /* ---------------------------------------------
   * Cheat for now on making the family node
   */
  VDctxCreateNode(treeID,"family",NULL,&familyNodeID);
  VDctxAppTxtAtr(&familyNodeID,"family",  family);
  VDctxAppTxtAtr(&familyNodeID,"material",material);
   
  // Get a part
  partID.objid = NULL_OBJID;
  vs$load_part_from_RDB(msg = &msg,
			material = material,
			family   = family,
			part     = part,
			osnum    = 2,
			object   = &partID);
  if (partID.objid == NULL_OBJID) {
    UI_status("Macro part not found");
    goto wrapup;
  }
  vdobj$Print(objID = &partID);

  // Get the def
  defID.objid = NULL_OBJID;
  ci$send(msg = message ACconst.find_macro(&defID),
	  targetid = partID.objid,
	  targetos = partID.osnum);
  if (defID.objid == NULL_OBJID) {
    UI_status("Macro def not found");
    goto wrapup;
  }
  vdobj$Print(objID = &defID);

  // Real def
  realID.objid = NULL_OBJID;
  ci$send(msg = message ACcpx_defn.ACreturn_real_def(&realID,NULL),
	  targetid = defID.objid,
	  targetos = defID.osnum);
  if (realID.objid == NULL_OBJID) {
    UI_status("Macro real not found");
    goto wrapup;
  }
  if (realID.objid != defID.objid) {  
    vdobj$Print(objID = &realID);
  }
  
  // Get the feet
  ci$send(msg = message ACcpx_defn.ACgive_feet_desc(&feetCnt,&feetInfos),
	  targetid = realID.objid,
	  targetos = realID.osnum);

  for(i = 0; i < feetCnt; i = i + 1) {
    feetInfo = &feetInfos[i];
    printf("%2d %-15s %d %d %d\n",i,
	   feetInfo->name,
	   feetInfo->chan,
	   feetInfo->prop,
	   feetInfo->pos);
  }

  // List of objects used by the macro
  ci$send(msg = message ACcomplex.ACget_other(&msg,&otherCnt,&otherIDs),
	  targetid = realID.objid,
	  targetos = realID.osnum);

  otherID.osnum = realID.osnum;
  for(i = 0; i < otherCnt; i = i + 1) {
    otherID.objid = otherIDs[i];
    addPartMacro(&familyNodeID,&otherID);
    // vdobj$Print(objID = &otherID);
  }
  
 wrapup:
  return 1;
  
}

/* -----------------------------------------------
 * Process a family
 */
processFamily(treeID,familyID)
  TGRid *treeID;
  TGRid *familyID;
{
  IGRchar family[32];
  IGRchar familyx[32];
  IGRchar material[32];
  IGRchar part_num[32];
  IGRchar type[32];

  TGRid  childID;
  IGRint i;

  // Only do cross sections
  VDctxGetTxtAtr(familyID,"type",type);
  if (strcmp(type,"cross_section")) goto wrapup;

  // Need some attributes
  VDctxGetTxtAtr(familyID,"family",family);
  if (*family == 0) goto wrapup;

  VDctxGetTxtAtr(familyID,"material",material);
  if (*material == 0) goto wrapup;

  // See if family already processed
  for(i = 0; VDctxGetNthTreeChild(treeID,i,&childID); i = i + 1) {
    VDctxGetTxtAtr(&childID,"family",familyx);
    if (!strcmp(family,familyx)) goto wrapup;
  }

  // Process first part
  VDctxGetNthTreeChild(familyID,0,&childID);
  if (childID.objid == NULL_OBJID) goto wrapup;
  VDctxGetTxtAtr(&childID,"part_num",part_num);
  if (*part_num == 0) goto wrapup;

  dumpPart(treeID,material,family,part_num);

wrapup:
  return 1;
}
 
/* -----------------------------------------------
 * Make a little tree of cross sections
 */
createTree()
{
  TGRid treeID;
  TGRid familysID;
  TGRid familyID;

  IGRint i;

  // Init
  treeID.objid = NULL_OBJID;

  // Want master list of families and parts
  VDvalGetFamilys(&familysID);
  if (familysID.objid == NULL_OBJID) {
    printf("*** Unable to get list of families and parts\n");
    goto wrapup;
  }
    
  // Create result tree
  VDctxCreateXdomTree("macros",NULL,&treeID);

  // Cycle through families
  for(i = 0; VDctxGetNthTreeChild(&familysID,i,&familyID); i = i + 1) {
    processFamily(&treeID,&familyID);
  }

  // Process parts
  // processPart(&treeID,"STEEL","I_T_met","W-T 250 X 30");
  // dumpPart(&treeID,"STEEL","I_T_met","W-T 250 X 30");
   
  // Write out
  VDctxSaveTreeToXmlFile(&treeID,"macros.xml");
  
  // Done
  VDctxDeleteNode(&treeID);
  
 wrapup:
  return 1;
}
extern VDvalCreateFamilyXmlFile();

/* -----------------------------------------------
 * Make a little tree of cross sections
 */
main()
{
  TGRid familysID;

  // Check for login
  if (!VDrisIsSchemaOpen()) {
    UI_status("Not logged in");
    goto wrapup;
  }

  // Get the master list of part families
  // VDvalGetFamilys(&familysID);
  // VDctxSaveTreeToXmlFile(&familysID,"familys.xml");
  // VDvalCreateFamilyXmlFile();
 
  // The tree
  createTree();
  
  // Dump info
  // dumpPart(NULL,"STEEL","I_T_met","W-T 250 X 30");
    
 wrapup:
  return 1;
}
