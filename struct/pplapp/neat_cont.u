/* $Id $  */

/*************************************************************************
 * I/STRUCT
 *
 * File:        pplapp/neat_cont.u
 *
 * Description: neat_cont macro definition.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY   AUTHOR       DESCRIPTION
 *      07/18/00   Rama Rao     File Creation
 *************************************************************************/

#include "VDppl.h"
#include "VDchn.h"
#include "VDobj.h"
#include "vsplatedef.h"
#include "ci_mac_def.h"

#define MACRO_NAME	"neat_cont"
#define MAX_TEMP	31
#define MAX_FEET	200
#define MAX_NEAT_CHAR	10

#define EXP_DOUBLE      0

GRobj           ci_mac_def1;
struct GRid     CI_MACRO_ID, GRIDS[MAX_FEET];

extern 	EXP_create_double(), VSgetExternalContour(), VD_bulkDisplayByGRids(),
	VD_bulkDeleteByGRids(), VDpms_findall_ancestryobjects();

extern GRclassid	OPP_nci_macro_class_id;
extern OM_S_CHANSELECT 	AS_to_owner;

main()
{
   IGRint       i, msg, temp_types[MAX_TEMP];
   IGRchar      *temp_names[MAX_TEMP], *feet_names[MAX_FEET],
                buffer_temp[MAX_TEMP* MAX_NEAT_CHAR], 
		buffer_feet[MAX_FEET* MAX_NEAT_CHAR];

   temp_names[0] = "cs" ;	temp_types[0] = ref_generic ;
 
   for (i=0; i<MAX_TEMP-1; i=i+1)
   {
        sprintf( &buffer_temp[i*MAX_NEAT_CHAR], "Plate%d", i+1 );
        temp_names[i+1] = &buffer_temp[i*MAX_NEAT_CHAR];
        temp_types[i+1] = macro_generic ;
   }

   for (i=0; i<MAX_FEET; i=i+2)
   {
        sprintf( &buffer_feet[i*MAX_NEAT_CHAR], "Curve%d", i/2+1 );
        feet_names[i] = &buffer_feet[i*MAX_NEAT_CHAR];
        sprintf( &buffer_feet[(i+1)*MAX_NEAT_CHAR], "Dir%d", (i+3)/2 );
        feet_names[i+1] = &buffer_feet[(i+1)*MAX_NEAT_CHAR];
   }

   ci_mac_def1 = NULL_OBJID;

   ac$cimacdef( cimacdef          = ci_mac_def1,
                status            = &msg,
                name              = MACRO_NAME,
                temp_num          = MAX_TEMP,
                temp_names        = temp_names,
                temp_types        = temp_types,
                extern_feet_num   = MAX_FEET,
                extern_feet_names = feet_names );
   
}

place ()
{
IGRlong         msg;

  construct_neatcurves();

  if( GRIDS[0].objid == NULL_OBJID ||
      GRIDS[1].objid == NULL_OBJID     ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);
  return(1);
}

compute ()
{
IGRlong         msg;

  construct_neatcurves();

  if( GRIDS[0].objid == NULL_OBJID ||
      GRIDS[1].objid == NULL_OBJID     ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);

  return(1);

}

construct_neatcurves()
{
IGRlong			sts, msg;
IGRint			i, num_pl, num_bnd_edges, *edge_dir;
IGRdouble		pt[3];
IGRuchar                weight;
struct GRobj_env	plates[MAX_TEMP], *bnd_edges, csOE ;
struct GRmd_env		loc_env;

  num_pl        = 0;
  num_bnd_edges = 0;
  weight        = 1;

  edge_dir  = NULL;
  bnd_edges = NULL;

  for( i=0; i<MAX_FEET; i=i+1 )  GRIDS[i].objid = NULL_OBJID;

  sts = vdchn$GetList( 	objID	= &CI_MACRO_ID,
			chnName = VDCHN_NAME_PARENT,
			maxCnt  = MAX_TEMP,
		        cnt     = &num_pl );

  vdobj$GetTemplate( objID      = &CI_MACRO_ID,
		     nth        = 0,
		     templateOE = &csOE );

  for( i=0; i<num_pl-1; i=i+1 )
     vdobj$GetTemplate( objID      = &CI_MACRO_ID,
			nth        = i+1,
			templateOE = &plates[i] );

  ci$get_module_info( md_env = &loc_env);
  VSgetExternalContour( &msg, num_pl-1, plates, &loc_env, VS_K_plBotSfPath,
			&num_bnd_edges, &bnd_edges, &csOE, &edge_dir );

  for( i=0; i<num_bnd_edges; i=i+1 )
  {
     sts = ci$send(  msg      = message GRvg.GRchgweight( &msg, &weight ),
		      targetid = bnd_edges[i].obj_id.objid,
		      targetos = bnd_edges[i].obj_id.osnum );
     GRIDS[2*i] = bnd_edges[i].obj_id ;

     sts = exp$create( exp_value  = (IGRdouble) edge_dir[i],
                       osnum      = loc_env.md_id.osnum,
                       p_exp_id   = &GRIDS[2*i+1].objid,
                       p_osnum    = &GRIDS[2*i+1].osnum   );
  }

wrapup:
  if( bnd_edges ) { free( bnd_edges ); bnd_edges = NULL; }
  if( edge_dir  ) { free( edge_dir  ); edge_dir  = NULL; }
  return 1;
}

/* ========================================================================= */
/* internal function NDdelete()
/* ========================================================================= */
NDdelete(md_env)
struct GRmd_env *md_env;
{
IGRint          i, nb_obj;
IGRlong         sts;
IGRchar         macName[128];
GRclassid       classid[1];
GRobjid         *obj_list;
struct GRid     owner, object_id;
struct GRobj_env        parentOE;

   nb_obj     = 0;
   obj_list   = NULL;
   classid[0] = OPP_nci_macro_class_id ;

   sts = VDpms_findall_ancestryobjects (
                                        md_env->md_id.osnum,
                                        1,
                                        classid,
                                        &nb_obj,
                                        NULL);
   if( !(sts&1) || !nb_obj ) goto wrapup ;

   obj_list = ( GRobjid * ) malloc( nb_obj * sizeof( GRobjid ) );
   if( obj_list == NULL )
   {
        printf("Can not allocate memory\n" );
        goto wrapup;
   }

   sts = VDpms_findall_ancestryobjects(
                                        md_env->md_id.osnum,
                                        1,
                                        classid,
                                        &nb_obj,
                                        obj_list);
   if( !(sts&1) || !nb_obj ) goto wrapup ;

   for(i = 0; i < nb_obj; i=i+1 )
   {
      object_id.objid = obj_list[i];
      object_id.osnum = md_env->md_id.osnum;

      vdobj$Get( objID = &object_id, macName = macName );
      if( !strcmp( macName, "steel_band" ) )
      {
        sts = vdobj$GetTemplate( objID = &object_id,
                                 nth   = 0,
                                 templateOE = &parentOE );

        // get owner
        sts = om$get_objid_at_index( objid           = parentOE.obj_id.objid,
                                     osnum           = parentOE.obj_id.osnum,
                                     p_chanselect    = &AS_to_owner,
                                     index           = 0,
                                     objidaddr       = &owner.objid,
                                     osnumaddr       = &owner.osnum );
        if( !(sts&1) || owner.objid == NULL_OBJID ||
	    ( owner.objid == CI_MACRO_ID.objid && 
	      owner.osnum == CI_MACRO_ID.osnum ) )
        {
           VD_bulkDisplayByGRids( md_env, GRbe, 1, &object_id  );
           VD_bulkDeleteByGRids( md_env, 1, &object_id  );
        }
      }
   }

wrapup:
   ci$send( msg      = message ov_ci_mac.NDdelete( md_env ),
                        targetid = CI_MACRO_ID.objid,
                        targetos = CI_MACRO_ID.osnum,
                        mode     = WRT_message );
   if( obj_list ) { free( obj_list ); obj_list = NULL; }
   return(1);
}
