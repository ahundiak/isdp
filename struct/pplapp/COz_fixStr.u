/* $Id: COz_fixStr.u,v 1.5 2002/06/04 21:22:04 ylong Exp $  */
/* --------------------------------------------------------------------
 * I/STRUCT
 *
 * File:        pplapp/COz_fixStr.u
 *
 * Description: PPL to Fix the corrupted plates/beams shared data
 *		attribute collectors.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COz_fixStr.u,v $
 *      Revision 1.5  2002/06/04 21:22:04  ylong
 *      fix for TR#5822
 *
 *      Revision 1.4  2002/02/19 23:06:19  ylong
 *      restoring back to r1.2 with minor changes
 *
 *      Revision 1.2  2001/10/13 17:11:39  ramarao
 *      Fixed TR# 5606.
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      10/05/00        Rama Rao        File Creation.
 *	10/13/01	Rama Rao	Removed ACrg_collectior check before 
 *					calling NDchnage_connect.
 *      06/04/02        Jayadev         Fix for TR#5822
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "vsdef.h"
#include "vsqryrdbdef.h"
#include "vsdpb.h"
#include "vsdpbmacros.h"
#include "vsdata.h"
#include "vsplatedef.h"
#include "vsbeamdef.h"
#include "vsdatamacros.h"

extern 			VDpms_findall_ancestryobjects(), VD_is_ancestry_valid(),
			VSdpb_loaded_with_plate(), VSdpb_loaded_with_beam(),
			VDopenFile(), VSgetSharedData(), GRconfirm_box(),
                        VSgetFinalChild();
extern                  sleep();

extern struct GRid	NULL_GRID;

extern GRclassid	OPP_VSplate_class_id, OPP_VSbeam_class_id,
			OPP_VSsharedData_class_id, OPP_VSdivFeature_class_id;

main()
{
IGRlong               msg, sts;
IGRint                i, nb_class, loc_cnt, bad_cnt, got_data, orientation,
		      nb_plates, nb_stiffs, item2index[VS_K_bmMAXDATA],
		      card_pt, symmetry;
IGRdouble	      thickness,  fpthickness, offset, cut_off, x_offset,
		      y_offset, rotation;
IGRchar		      exp_txt[1024], *actAttr, actSource[VS_K_MAXDBNAME], 
		      actNotes[VS_K_MAXDBNAME], actStock[VS_K_MAXDBNAME],
		      actMat[VS_K_MAXDBNAME], actGrd[VS_K_MAXDBNAME], 
		      actAppSts[VS_K_MAXDBNAME], actConSts[VS_K_MAXDBNAME],
		      actFam[VS_K_MAXDBNAME], actPrt[VS_K_MAXDBNAME],
		      clsName[80] , mesg[128];
GRclassid	      classid[2];
OM_S_OBJID            *loc_list;
struct GRid	      obj_chk, coll, good_plate_coll;
struct GRid           good_beam_coll, sharedObj; 
struct GRobj_env      parEnv, childEnv;
struct GRmd_env       cur_env;
VSdataDesc	      data[VS_K_bmMAXDATA];
FILE                  *file;
IGRboolean            isPlate;

   message( "Check Structural Elements" );

   loc_cnt    = 0;
   bad_cnt    = 0;
   nb_class   = 2;
   nb_plates  = 0;
   nb_stiffs  = 0;
   loc_list   = NULL;
   isPlate    = FALSE;
 
   good_plate_coll.objid = NULL_OBJID;
   good_beam_coll.objid = NULL_OBJID;

   sts = MSSUCC;
   msg = MSSUCC;

   ci$get( string = exp_txt,
           prompt = "Enter Report File Name" );
   file = VDopenFile( &msg, exp_txt, "w" );
   if( !(msg&1) )  file = stdout;

   classid[0] = OPP_VSplate_class_id;
   classid[1] = OPP_VSbeam_class_id;

   ci$get_module_info( md_env = &cur_env );
   UI_status(" Grabbing all the Plates and Beams ");
   sleep(1);

   loc_cnt = 0;
   VDpms_findall_ancestryobjects( cur_env.md_id.osnum, nb_class, 
				  classid, &loc_cnt, NULL );
   if( !loc_cnt ) goto wrapup;

   loc_list = ( OM_S_OBJID * ) malloc( sizeof(OM_S_OBJID)*loc_cnt );
   VDpms_findall_ancestryobjects(  cur_env.md_id.osnum, nb_class,
                                   classid, &loc_cnt, loc_list );

   for( i=0; i<loc_cnt; i=i+1 )
   {
       obj_chk.objid = loc_list[i];
       obj_chk.osnum = cur_env.md_id.osnum;

       if( VD_is_ancestry_valid( &obj_chk, 
			OPP_VSdivFeature_class_id ) )	continue;
       coll.objid = NULL_OBJID ;
       sts = ci$send(msg = message VSfeature.VSfindCollection( 
			  &msg, VS_K_prPrvAttr, &coll ),
			targetid = obj_chk.objid,
			targetos = obj_chk.osnum );
       if( !(sts&1&msg) || coll.objid == NULL_OBJID ||
	   !VD_is_ancestry_valid( &coll, OPP_VSsharedData_class_id ) )
       {
         vdobj$Get( objID = &obj_chk, className = clsName );
         /*
          *
         if( !strcmp( clsName, "VSsrcPlate" ) ||
 	     !strcmp( clsName, "VSsrcBeam"  ) ||
	     !strcmp( clsName, "VSstfBeam"  )    )
          *
          */
         {
           parEnv.obj_id  = obj_chk;
           parEnv.mod_env = cur_env;
           if( VD_is_ancestry_valid( &obj_chk, OPP_VSplate_class_id ) )
             isPlate = TRUE;
           else
             isPlate = FALSE;

           VSgetFinalChild(&parEnv, &childEnv, isPlate);
           if(bad_cnt == 0)
           {
             fprintf( file, "------------------------------------------\n" );
             fprintf( file, "      BAD STRUCTURAL ELEMENTS LIST	       \n" );
             fprintf( file, "      LOST THEIR SHARED DATA COLLECTOR    \n" );
             fprintf( file, "------------------------------------------\n" );
           }
	   fprintf( file, "\n[%d] --- ", bad_cnt+1);
	   vdobj$Print( objID = &obj_chk, file = file );
	   fprintf( file, "Consuming Child ---");
	   vdobj$Print( objID = &childEnv.obj_id, file = file );
	   loc_list[bad_cnt] = loc_list[i];
	   bad_cnt = bad_cnt + 1 ;
         }
       }
       else if( good_plate_coll.objid == NULL_OBJID &&
	        VD_is_ancestry_valid( &obj_chk, OPP_VSplate_class_id ) )
       {
	   good_plate_coll = coll;
       }
       else if( good_beam_coll.objid == NULL_OBJID &&
                VD_is_ancestry_valid( &obj_chk, OPP_VSbeam_class_id ) )
       {
           good_beam_coll = coll;
       }

   }
   fprintf( file, "---------------------------------------------------\n\n" );
   fprintf( file, "Bad Structural Elements Count = %d\n", bad_cnt );
   fprintf( file, "---------------------------------------------------\n\n" );
   if( !bad_cnt )
   {
     UI_status(" No bad elements found ");
     sleep(1);
     goto wrapup;
   }
   sprintf(mesg," %d bad elements found", bad_cnt); 
   UI_status(mesg);
   sleep(1);

   for( i=0; i<bad_cnt; i=i+1 )
   {
      obj_chk.objid = loc_list[i];
      obj_chk.osnum = cur_env.md_id.osnum;

      if( VD_is_ancestry_valid( &obj_chk, OPP_VSplate_class_id ) )
	nb_plates = nb_plates + 1 ;
      else if( VD_is_ancestry_valid( &obj_chk, OPP_VSbeam_class_id ) )
	nb_stiffs = nb_stiffs + 1 ;
	
   }
   fprintf( file, "Number of bad plates = %d\n", nb_plates );
   fprintf( file, "Number of bad beams = %d\n\n", nb_stiffs );

   sprintf(mesg,"Want to repair -> attach the shared data object?");
   if (GRconfirm_box(mesg) != 1) goto wrapup; 
 
   if( nb_plates == 0 ) goto reapir_beams;

   if( good_plate_coll.objid != NULL_OBJID ) 
   {
      sharedObj = good_plate_coll;
      goto use_good_plate;
   }

   VSdpb_loaded_with_plate( &got_data ) ;

   for( i = 0 ; i < VS_K_plMAXDATA ; i=i+1 ) item2index[i] = i ;

   if( got_data )
   {
      /* Material from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_material,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actMat, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plMatType]].index = VS_K_plMatType;
      data[item2index[VS_K_plMatType]].type = VSstring;
      data[item2index[VS_K_plMatType]].value.s = actMat;

      /* Grade from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_grade,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actGrd, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plMatGrade]].index = VS_K_plMatGrade;
      data[item2index[VS_K_plMatGrade]].type = VSstring;
      data[item2index[VS_K_plMatGrade]].value.s = actGrd;

      /* Family from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_type,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actFam, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plPartFam]].index = VS_K_plPartFam;
      data[item2index[VS_K_plPartFam]].type = VSstring;
      data[item2index[VS_K_plPartFam]].value.s = actFam;

      /* Thickness from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_thkname,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actPrt, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plThickness]].index = VS_K_plThickness;
      data[item2index[VS_K_plThickness]].type = VSstring;
      data[item2index[VS_K_plThickness]].value.s = actPrt;

      /* Notes from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_notes,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actNotes, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plNotes]].index = VS_K_plNotes;
      data[item2index[VS_K_plNotes]].type = VSstring;
      data[item2index[VS_K_plNotes]].value.s = actNotes;

      /* Source from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_source,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actSource, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plMtoSrc]].index = VS_K_plMtoSrc;
      data[item2index[VS_K_plMtoSrc]].type = VSstring;
      data[item2index[VS_K_plMtoSrc]].value.s = actSource;

      /* Stock from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_stock,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actStock, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plMtoStk]].index = VS_K_plMtoStk;
      data[item2index[VS_K_plMtoStk]].type = VSstring;
      data[item2index[VS_K_plMtoStk]].value.s = actStock;

      /* FireProofing from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_fireproofing_thk,
                      p_arg   = &fpthickness ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_plFpThck]].index = VS_K_plFpThck;
      data[item2index[VS_K_plFpThck]].type = VSdouble;
      data[item2index[VS_K_plFpThck]].value.d = fpthickness;

      /* Approval Status from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_apprv_status,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actAppSts, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plApprSts]].index = VS_K_plApprSts;
      data[item2index[VS_K_plApprSts]].type = VSstring;
      data[item2index[VS_K_plApprSts]].value.s = actAppSts;

      /* Construction Status from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_const_status,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actConSts, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_plCnstSts]].index = VS_K_plCnstSts;
      data[item2index[VS_K_plCnstSts]].type = VSstring;
      data[item2index[VS_K_plCnstSts]].value.s = actConSts;

      /* Orientation from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_orientation,
                      p_arg   = &orientation ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_plOrientation]].index = VS_K_plOrientation;
      data[item2index[VS_K_plOrientation]].type = VSint;
      data[item2index[VS_K_plOrientation]].value.i = orientation;

      /* Offset from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_offset,
                      p_arg   = &offset ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_plOffset]].index = VS_K_plOffset;
      data[item2index[VS_K_plOffset]].type = VSdouble;
      data[item2index[VS_K_plOffset]].value.d = offset;

      /* Cut_off from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_cut_off,
                      p_arg   = &cut_off ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_plCutOff]].index = VS_K_plCutOff;
      data[item2index[VS_K_plCutOff]].type = VSdouble;
      data[item2index[VS_K_plCutOff]].value.d = cut_off;
   }
   else
   {
      strcpy( actMat, "STEEL" );
      data[item2index[VS_K_plMatType]].index = VS_K_plMatType;
      data[item2index[VS_K_plMatType]].type = VSstring;
      data[item2index[VS_K_plMatType]].value.s = actMat;

      strcpy( actGrd, "EH-36" );
      data[item2index[VS_K_plMatGrade]].index = VS_K_plMatGrade;
      data[item2index[VS_K_plMatGrade]].type = VSstring;
      data[item2index[VS_K_plMatGrade]].value.s = actGrd;

      strcpy( actFam, "steel_plate" );
      data[item2index[VS_K_plPartFam]].index = VS_K_plPartFam;
      data[item2index[VS_K_plPartFam]].type = VSstring;
      data[item2index[VS_K_plPartFam]].value.s = actFam;

      thickness = 19.0;
      data[item2index[VS_K_plThickness]].index = VS_K_plThickness;
      data[item2index[VS_K_plThickness]].type = VSdouble;
      data[item2index[VS_K_plThickness]].value.d = thickness;

      strcpy( actNotes, "" );
      data[item2index[VS_K_plNotes]].index = VS_K_plNotes;
      data[item2index[VS_K_plNotes]].type = VSstring;
      data[item2index[VS_K_plNotes]].value.s = actNotes;

      strcpy( actSource, "" );
      data[item2index[VS_K_plMtoSrc]].index = VS_K_plMtoSrc;
      data[item2index[VS_K_plMtoSrc]].type = VSstring;
      data[item2index[VS_K_plMtoSrc]].value.s = actSource;

      strcpy( actStock, "" );
      data[item2index[VS_K_plMtoStk]].index = VS_K_plMtoStk;
      data[item2index[VS_K_plMtoStk]].type = VSstring;
      data[item2index[VS_K_plMtoStk]].value.s = actStock;

      fpthickness = 0.0;
      data[item2index[VS_K_plFpThck]].index = VS_K_plFpThck;
      data[item2index[VS_K_plFpThck]].type = VSdouble;
      data[item2index[VS_K_plFpThck]].value.d = fpthickness;

      strcpy( actAppSts, "-" );
      data[item2index[VS_K_plApprSts]].index = VS_K_plApprSts;
      data[item2index[VS_K_plApprSts]].type = VSstring;
      data[item2index[VS_K_plApprSts]].value.s = actAppSts;

      strcpy( actConSts, "N" );
      data[item2index[VS_K_plCnstSts]].index = VS_K_plCnstSts;
      data[item2index[VS_K_plCnstSts]].type = VSstring;
      data[item2index[VS_K_plCnstSts]].value.s = actConSts;

      orientation = VS_K_USE_NAT_NORM ;
      data[item2index[VS_K_plOrientation]].index = VS_K_plOrientation;
      data[item2index[VS_K_plOrientation]].type = VSint;
      data[item2index[VS_K_plOrientation]].value.i = orientation;

      offset = 0.0;
      data[item2index[VS_K_plOffset]].index = VS_K_plOffset;
      data[item2index[VS_K_plOffset]].type = VSdouble;
      data[item2index[VS_K_plOffset]].value.d = offset;

      cut_off = 19;
      data[item2index[VS_K_plCutOff]].index = VS_K_plCutOff;
      data[item2index[VS_K_plCutOff]].type = VSdouble;
      data[item2index[VS_K_plCutOff]].value.d = cut_off;
   }

   sharedObj.osnum = cur_env.md_id.osnum;
   sts = vs$getSharedData( msg     = &msg,
                           osnum   = sharedObj.osnum,
                           count   = VS_K_plMAXDATA,
                           data    = data,
                           p_objid = &sharedObj.objid ) ;
   if( !(sts&1&msg) ) goto wrapup;

use_good_plate:
   for( i=0; i<bad_cnt; i=i+1 )
   {
      obj_chk.objid = loc_list[i];
      obj_chk.osnum = cur_env.md_id.osnum;

      if( VD_is_ancestry_valid( &obj_chk, OPP_VSplate_class_id ) )
      {
         sts = ci$send(msg = message VSfeature.VSfindCollection(
                          		&msg, VS_K_prPrvAttr, &coll ),
                      	targetid = obj_chk.objid,
                       	targetos = obj_chk.osnum );
	 if( (sts&1) && (coll.objid != NULL_OBJID) )
	 {
	    sts = ci$send(  msg     = message NDnode.NDchange_connect(
						1, &coll, &sharedObj ),
			targetid = obj_chk.objid,
                        targetos = obj_chk.osnum ) ;

	    sts = ci$send(  msg     = message NDnode.NDconnect(
                                        1, &coll, NULL_GRID, ND_ADD ),
                        targetid = obj_chk.objid,
                        targetos = obj_chk.osnum ) ;
	 }
	 else
	 {
	     sts = ci$send(  msg     = message NDnode.NDconnect(
                                         1, &sharedObj, NULL_GRID, ND_ADD ),
                       	targetid = obj_chk.objid,
	     		targetos = obj_chk.osnum ) ;
	 }
       }
   }

   if( nb_stiffs == 0 ) goto end_of_process;

reapir_beams:

   if( good_beam_coll.objid != NULL_OBJID ) 
   {
      sharedObj = good_beam_coll;
      goto use_good_beam;
   }

   VSdpb_loaded_with_beam( &got_data ) ;

   for( i = 0 ; i < VS_K_bmMAXDATA ; i=i+1 ) item2index[i] = i ;

   if( got_data )
   {
      /* Material from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_material,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actMat, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmMatType]].index = VS_K_bmMatType;
      data[item2index[VS_K_bmMatType]].type = VSstring;
      data[item2index[VS_K_bmMatType]].value.s = actMat;

      /* Grade from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_grade,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actGrd, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmMatGrade]].index = VS_K_bmMatGrade;
      data[item2index[VS_K_bmMatGrade]].type = VSstring;
      data[item2index[VS_K_bmMatGrade]].value.s = actGrd;

      /* Family from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_type,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actFam, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmPartFam]].index = VS_K_bmPartFam;
      data[item2index[VS_K_bmPartFam]].type = VSstring;
      data[item2index[VS_K_bmPartFam]].value.s = actFam;

      /* Thickness from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_shape,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actPrt, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmPartNum]].index = VS_K_bmPartNum;
      data[item2index[VS_K_bmPartNum]].type = VSstring;
      data[item2index[VS_K_bmPartNum]].value.s = actPrt;

      /* Notes from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_notes,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actNotes, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmNotes]].index = VS_K_bmNotes;
      data[item2index[VS_K_bmNotes]].type = VSstring;
      data[item2index[VS_K_bmNotes]].value.s = actNotes;

      /* Source from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_source,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actSource, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmMtoSrc]].index = VS_K_bmMtoSrc;
      data[item2index[VS_K_bmMtoSrc]].type = VSstring;
      data[item2index[VS_K_bmMtoSrc]].value.s = actSource;

      /* Stock from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_P_stock,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actStock, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmMtoStk]].index = VS_K_bmMtoStk;
      data[item2index[VS_K_bmMtoStk]].type = VSstring;
      data[item2index[VS_K_bmMtoStk]].value.s = actStock;

      /* FireProofing from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_fireproofing_thk,
                      p_arg   = &fpthickness ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_bmFpThck]].index = VS_K_bmFpThck;
      data[item2index[VS_K_bmFpThck]].type = VSdouble;
      data[item2index[VS_K_bmFpThck]].value.d = fpthickness;

      /* Approval Status from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_apprv_status,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actAppSts, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmApprSts]].index = VS_K_bmApprSts;
      data[item2index[VS_K_bmApprSts]].type = VSstring;
      data[item2index[VS_K_bmApprSts]].value.s = actAppSts;

      /* Construction Status from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_const_status,
                      p_arg   = &actAttr ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      strncpy( actConSts, actAttr, VS_K_MAXDBNAME-1 )[VS_K_MAXDBNAME-1] = '\0';
      data[item2index[VS_K_bmCnstSts]].index = VS_K_bmCnstSts;
      data[item2index[VS_K_bmCnstSts]].type = VSstring;
      data[item2index[VS_K_bmCnstSts]].value.s = actConSts;

      /* X-offset from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_x_offset,
                      p_arg   = &x_offset ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_bmXOffset]].index = VS_K_bmXOffset;
      data[item2index[VS_K_bmXOffset]].type = VSdouble;
      data[item2index[VS_K_bmXOffset]].value.d = x_offset;

      /* Y-offset from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_y_offset,
                      p_arg   = &y_offset ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_bmYOffset]].index = VS_K_bmYOffset;
      data[item2index[VS_K_bmYOffset]].type = VSdouble;
      data[item2index[VS_K_bmYOffset]].value.d = y_offset;

      /* Rotation from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_rotation,
                      p_arg   = &rotation ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_bmRotAngle]].index = VS_K_bmRotAngle;
      data[item2index[VS_K_bmRotAngle]].type = VSdouble;
      data[item2index[VS_K_bmRotAngle]].value.d = rotation;

      /* Cardinal Point from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_cardinal_point,
                      p_arg   = &card_pt ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_bmCardPnt]].index = VS_K_bmCardPnt;
      data[item2index[VS_K_bmCardPnt]].type = VSint ;
      data[item2index[VS_K_bmCardPnt]].value.i = card_pt;

      /* Symmetry from DPB */
      vs$get_act_pm(  msg     = &msg,
                      param   = VS_e_dpb_B_symmetry,
                      p_arg   = &symmetry ) ;
      if( !( msg & 1 ) ) goto wrapup ;
      data[item2index[VS_K_bmSymmetry]].index = VS_K_bmSymmetry;
      data[item2index[VS_K_bmSymmetry]].type = VSint ;
      data[item2index[VS_K_bmSymmetry]].value.i = symmetry;
   }
   else
   {
      strcpy( actMat, "STEEL" );
      data[item2index[VS_K_bmMatType]].index = VS_K_bmMatType;
      data[item2index[VS_K_bmMatType]].type = VSstring;
      data[item2index[VS_K_bmMatType]].value.s = actMat;

      strcpy( actGrd, "EH-36" );
      data[item2index[VS_K_bmMatGrade]].index = VS_K_bmMatGrade;
      data[item2index[VS_K_bmMatGrade]].type = VSstring;
      data[item2index[VS_K_bmMatGrade]].value.s = actGrd;

      strcpy( actFam, "I_T_met" );
      data[item2index[VS_K_bmPartFam]].index = VS_K_bmPartFam;
      data[item2index[VS_K_bmPartFam]].type = VSstring;
      data[item2index[VS_K_bmPartFam]].value.s = actFam;

      strcpy( actPrt, "W-T 310 X 30" );
      data[item2index[VS_K_bmPartNum]].index = VS_K_bmPartNum;
      data[item2index[VS_K_bmPartNum]].type = VSstring;
      data[item2index[VS_K_bmPartNum]].value.s = actPrt;

      strcpy( actNotes, "" );
      data[item2index[VS_K_bmNotes]].index = VS_K_bmNotes;
      data[item2index[VS_K_bmNotes]].type = VSstring;
      data[item2index[VS_K_bmNotes]].value.s = actNotes;

      strcpy( actSource, "" );
      data[item2index[VS_K_bmMtoSrc]].index = VS_K_bmMtoSrc;
      data[item2index[VS_K_bmMtoSrc]].type = VSstring;
      data[item2index[VS_K_bmMtoSrc]].value.s = actSource;

      strcpy( actStock, "" );
      data[item2index[VS_K_bmMtoStk]].index = VS_K_bmMtoStk;
      data[item2index[VS_K_bmMtoStk]].type = VSstring;
      data[item2index[VS_K_bmMtoStk]].value.s = actStock;

      fpthickness = 0.0;
      data[item2index[VS_K_bmFpThck]].index = VS_K_bmFpThck;
      data[item2index[VS_K_bmFpThck]].type = VSdouble;
      data[item2index[VS_K_bmFpThck]].value.d = fpthickness;

      strcpy( actAppSts, "-" );
      data[item2index[VS_K_bmApprSts]].index = VS_K_bmApprSts;
      data[item2index[VS_K_bmApprSts]].type = VSstring;
      data[item2index[VS_K_bmApprSts]].value.s = actAppSts;

      strcpy( actConSts, "N" );
      data[item2index[VS_K_bmCnstSts]].index = VS_K_bmCnstSts;
      data[item2index[VS_K_bmCnstSts]].type = VSstring;
      data[item2index[VS_K_bmCnstSts]].value.s = actConSts;

      x_offset = 0.0;
      data[item2index[VS_K_bmXOffset]].index = VS_K_bmXOffset;
      data[item2index[VS_K_bmXOffset]].type = VSdouble;
      data[item2index[VS_K_bmXOffset]].value.d = x_offset;

      y_offset = 0.0;
      data[item2index[VS_K_bmYOffset]].index = VS_K_bmYOffset;
      data[item2index[VS_K_bmYOffset]].type = VSdouble;
      data[item2index[VS_K_bmYOffset]].value.d = y_offset;

      rotation = 0.0;
      data[item2index[VS_K_bmRotAngle]].index = VS_K_bmRotAngle;
      data[item2index[VS_K_bmRotAngle]].type = VSdouble;
      data[item2index[VS_K_bmRotAngle]].value.d = rotation;

      card_pt = VS_e_UPP_LEFT ;
      data[item2index[VS_K_bmCardPnt]].index = VS_K_bmCardPnt;
      data[item2index[VS_K_bmCardPnt]].type = VSint ;
      data[item2index[VS_K_bmCardPnt]].value.i = card_pt;

      symmetry = VS_e_No_Symm ;
      data[item2index[VS_K_bmSymmetry]].index = VS_K_bmSymmetry;
      data[item2index[VS_K_bmSymmetry]].type = VSint ;
      data[item2index[VS_K_bmSymmetry]].value.i = symmetry;
   }

   sharedObj.osnum = cur_env.md_id.osnum;
   sts = vs$getSharedData( msg     = &msg,
                           osnum   = sharedObj.osnum,
                           count   = VS_K_bmMAXDATA,
                           data    = data,
                           p_objid = &sharedObj.objid ) ;
   if( !(sts&1&msg) ) goto wrapup;

use_good_beam:
   for( i=0; i<bad_cnt; i=i+1 )
   {
      obj_chk.objid = loc_list[i];
      obj_chk.osnum = cur_env.md_id.osnum;

      if( VD_is_ancestry_valid( &obj_chk, OPP_VSbeam_class_id ) )
      {
         sts = ci$send(msg = message VSfeature.VSfindCollection(
                          		&msg, VS_K_prPrvAttr, &coll ),
                      	targetid = obj_chk.objid,
                       	targetos = obj_chk.osnum );
	 if( (sts&1) && (coll.objid != NULL_OBJID) )
	 {
	    sts = ci$send(  msg     = message NDnode.NDchange_connect(
						1, &coll, &sharedObj ),
			targetid = obj_chk.objid,
                        targetos = obj_chk.osnum ) ;

	    sts = ci$send(  msg     = message NDnode.NDconnect(
                                        1, &coll, NULL_GRID, ND_ADD ),
                        targetid = obj_chk.objid,
                        targetos = obj_chk.osnum ) ;
	 }
	 else
	 {
	     sts = ci$send(  msg     = message NDnode.NDconnect(
                                         1, &sharedObj, NULL_GRID, ND_ADD ),
                       	targetid = obj_chk.objid,
	     		targetos = obj_chk.osnum ) ;
	 }
       }
   }
end_of_process:

   fprintf( file, "------------------------------------------------------\n" );
   fprintf( file, "         SOURCE ELEMENTS MODIFIED               \n" );
   fprintf( file, "------------------------------------------------------\n" );

   loc_cnt = 0;
   for( i=0; i<bad_cnt; i=i+1 )
   {
      obj_chk.objid = loc_list[i];
      obj_chk.osnum = cur_env.md_id.osnum;
      vdobj$Get( objID = &obj_chk, className = clsName );
      if( !strcmp( clsName, "VSsrcPlate" ) ||
 	  !strcmp( clsName, "VSsrcBeam"  ) ||
	  !strcmp( clsName, "VSstfBeam"  )    )
      {
           fprintf( file, "[%d] --- ", loc_cnt+1 );
           vdobj$Print( objID = &obj_chk, file = file );
	   loc_cnt = loc_cnt + 1 ;
      }
   }

wrapup:
   UI_status("Done"); 
   if( loc_list       ) { free( loc_list   ); loc_list   = NULL; }
   if( file != stdout ) { fclose( file     ); file       = NULL; }
   return 1;
}
