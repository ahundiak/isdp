/* $Id: CObevel.u,v 1.5 2001/04/25 19:08:40 ramarao Exp $  */
/* --------------------------------------------------------------------
 * I/STRUCT
 *
 * File:        struct/pplapp/CObevel.u
 *
 * Description: command for placing bevel macros
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: CObevel.u,v $
 *      Revision 1.5  2001/04/25 19:08:40  ramarao
 *      Don't check if the curve for a one-plate bevel is in on the neat-plate. - TR# 5113.
 *
 *      Revision 1.4  2001/04/12 18:25:58  ramarao
 *      Fixed TR# 5015.
 *
 *      Revision 1.3  2001/03/20 20:56:31  ramarao
 *      Warn the user in case of one plate bevel, if he select different edge which is not on the neat plate.
 *
 *      Revision 1.2  2001/01/17 14:58:20  ramarao
 *      *** empty log message ***
 *
# Revision 1.5  2000/05/03  17:48:34  pinnacle
# Replaced: struct/pplapp/CObevel.u for:  by rchennup for Service Pack
#
# Revision 1.2  2000/04/24  21:32:56  pinnacle
# ylong
#
# Revision 1.1  2000/04/21  22:35:20  pinnacle
# Created: struct/pplapp/CObevel.u by rchennup for Service Pack
#
# Revision 1.10  2000/04/05  21:36:22  pinnacle
# ylong
#
# Revision 1.9  2000/04/05  12:59:20  pinnacle
# Replaced: pplapp/CObevel.u for:  by impd252 for struct
#
# Revision 1.6  2000/03/23  23:28:02  pinnacle
# ylong
#
# Revision 1.3  2000/02/29  16:38:08  pinnacle
# ylong
#
# Revision 1.2  2000/02/18  14:41:10  pinnacle
# ylong
#
# Revision 1.1  2000/02/11  00:24:16  pinnacle
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *	02/04/00	ylong		Creation
 *	02/18/00	ylong		modified for EJ_Bevel & VA_Bevel
 *	02/29/00	ylong		added functionality for Fab_Stock
 *      03/23/00        ylong           added some features and fixes
 *      04/04/00        ylong           check all curves by CheckCurve()
 *      04/05/00        ylong           crashed at form pointer in wakeup
 * -------------------------------------------------------------------*/

/*
#define  DEBUG	1
#define  vsDEBUG	1
*/
#include "FI.h"
#include "VDppl.h"
#include "VSbevel.h"
#include "VDmem_ppl.h"
#include "VDobj.h"
#include "VDsa.h"
#include "VDfrm.h"
#include "VDgeom.h"
#include "vsgeommacros.h"
#include "vdAPImacros.h"
#include "asmacros.h"

#include "vsdbgmacros.h"

/************************************************************
  Define Constants.
 ************************************************************/
/*
 * Define constants for form 
 */
#define FORM_LABEL	100		// Arbitrary Number for Form
#define FORM_NAME	"VSbevel.frm"	// Form File
#define TITLE_STRING	"Place Bevel"

/************************************************************
  External functions.
 ************************************************************/
extern ci_notification();  /* The forms system automatically calls    */
                           /* this function, which in turn calls your */
                           /* form_notification function              */

extern FIf_set_cmd_oid_os();  /* This function tells the forms system */
                              /* to notify this command file when the */
                              /* user manipulates the form */

extern FIf_reset();
extern FIf_new();		/* Creates the form              */
extern FIf_display();		/* Draws the form                */
extern FIf_erase();		/* Erases the form               */
extern FIf_delete();		/* Removes the form              */
extern FIg_get_value();		/* Retrieves values from gadgets */
extern FIg_set_value();		/* Retrieves values from gadgets */
extern FIfld_set_select() ;
extern FIg_is_valid();
extern FIg_get_attr();
extern GRdpb_get();
extern isdigit();

extern	GRdisplay_object() ;
extern	EX_get_global() ;
extern	CheckForProperName() ;
extern	GetNeatPlate() ;
extern	DisplayGadgets() ;
extern	CheckEJcurve() ;
extern	CheckCurve() ;
extern	PlaceEJ_BevelMacro() ;
extern	PlaceBevelMacro() ;
extern	PlaceVariable_BevelMacro() ; 
extern	ShowBevel() ;
extern	VSbvl_set_bevel_type() ;
extern	VSbvl_get_bevel_type() ;
extern	VSbvl_set_font_size() ;
extern	VSbvl_get_font_size() ;
extern  CheckIfCurveBelongsToNeatPlate();

/************************************************************
  Global variables.
 ************************************************************/
int	test_wakeup;	// The wakeup function uses this flag to
			// test if the main function has started yet.

int	form_exists,	// The delete function uses this flag
			// to test if the form exists 
	form_displayed,	// The sleep function uses this flag
			// to test if the form is displayed
	form_labels[60],
	not_done;		// This value is set to 0 when the user
			// selects the cancel or exit & save buttons

Form	form;		// Use this variable for the forms functions. 

struct	CIform_st form_st;	// This structure contains information on
				// which form and gadget was manipulated. 

TGRobj_env	adjPltOE;		// adjacent plate for "1 plate" case
TGRobj_env	neatPltOE1;		// objEO of neat plate 1
TGRobj_env	neatPltOE2;		// objEO of neat plate 2
TGRobj_env	bvlCrvOE;		// bevel curve OE
TGRobj_env	bvlMacOE;		// bevel macro OE
TGRobj_env	objOEs[MAX_TEMPS];	// parent OEs of bvlMac


TGRbsp_curve	*bvlCrv ;	// bevel crv

IGRchar		pltStr1[80];
IGRchar		pltStr2[80];
IGRchar		edgStr1[80];
IGRchar		edgStr2[80];
IGRchar		lblPntFlag[4];

IGRchar		EJpltStr[80];
IGRchar		EJcrvStr[80];
IGRdouble       EJthickness;

IGRchar		VApltStr[80];
IGRchar		VAbCrvStr[80];
IGRchar		VAoCrvStr[80];

IGRchar		macStr[80];
IGRchar		btStr[80];
IGRchar		ptStr[80];
IGRdouble       offsetVal;
IGRdouble	stockVal;


IGRchar		msgStr[128];
enum GRdpmode	dpBvlMode ;
enum GRdpmode	hilitMode ;
TGRid		hilitObj ;
IGRint		hilitGadget ;

IGRint		fontSize ;
IGRchar		fontStr[80] ;

void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
	__DBGpr_com("return_error");
	status("");		/* Clear the status field  */
	message("");		/* Clear the message field */
	exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
	int error;
	int macro_type;

	SetProc(CObevel - form_init); Begin

	/*************************
	 Create (load) the form.
	*************************/
	__DBGpr_str("Form name",FORM_NAME);
	form = NULL ;
	FI_get_form_by_name( FORM_NAME, &form ) ;
	if( form == NULL ) {
		error = FIf_new(FORM_LABEL, FORM_NAME, 
				ci_notification, &form );
		if ( form == NULL ) {
			write (	"Could not create the form.\n",
				"Error code = ",  error,  "\n"  );
			return_error();
		}
  	}

	form_exists = TRUE;  /* Flag for delete function */

	/**********************************************
	Tell the Forms System to notify this command
	file when the user manipulates the form.
	**********************************************/
	error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
	if ( error )
	{
		write(	"Could not link to the Forms System.\n",
			"Error code = ",    error,         "\n"  );
		form_exists = FALSE;
		return_error();
	}

	/* Set the title on the form */
	FIg_set_text( form, FORM_TITLE, TITLE_STRING);

	/*******************
	Display the form.
	*******************/

	macro_type = VSbvl_get_bevel_type();
	switch (macro_type ){
	case '1' : 
		strcpy( macStr,   "1 Plate" ) ;
		break;
	case '2' :
		strcpy( macStr,   "2 Plates" ) ;
		break;
	case 'F' : 
	case 'f' : 
		strcpy( macStr,   "Fabrication Stock" ) ;
		break;
	case 'V' :
	case 'v' :
		strcpy( macStr,   "Variable Plate" ) ;
		break;
	default: 
		strcpy( macStr,   "2 Plates" ) ;
	}
	FIg_set_text( form, MACRO_TYPE, macStr ) ;
	DisplayGadgets( form, macStr ) ;
  
	error = FIf_display( form );
 	if ( error ) {
		write (	"Could not display the form.\n",
			"Error code = ",  error,   "\n"  );
		return_error();
	}

	form_displayed = TRUE;  /* Flag for sleep function */

	End
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
	char outString[80];
  
SetProc(CObevel - form_notification); Begin

	ci$put( response = MOVE_ON );  /* Give control to the main function */
End
	return 1 ;
}

DisableAllExceptCancel()
{
   IGRint	i, attr ;

   for( i=0; i<60; i=i+1 )
   {
       form_labels[i] = 0 ;
       if( i == FI_CANCEL ) continue;
       if( ! ( FIg_is_valid( form, i )) )
       {
          FIg_get_attr( form, i, &attr ) ;
          if( !( attr & FI_NOT_DISPLAYED ) )
          {
             FIg_disable( form, i );
             form_labels[i] = 1 ;
          }
       }
    }
}

EnableAllExceptCancel()
{
   IGRint	i;

   for( i=0; i<60; i=i+1 )
   {
       if( i == FI_CANCEL ) continue;
       if( form_labels[i] ) FIg_enable( form, i );
    }
}

IGRchar*	GetNumber( type )
IGRchar  *type;
{
IGRint		i;
IGRchar		copy_str[200];

   strcpy( copy_str, type );

   for( i=0; i<strlen(type); i=i+1 )
   {
      if( !isdigit(type[i]) )
      {
	 copy_str[i] = '\0';
	 break;
      }
   }
   return (copy_str);
}

wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
	/* Display the form unless the command file is just starting */
	__DBGpr_int("I'm now waking up, test_wakeup",test_wakeup);
	if ( test_wakeup == 1 && not_done ) {
	    if( form )
	    {
		// FIf_display ( form );  /* Redisplay the form */
		EnableAllExceptCancel();
		form_displayed = TRUE; /* Set flag for sleep function */
	    }
	}
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
SetProc(CObevel - sleep); Begin

	/* Erase the form if it is displayed */
	if ( form_displayed == TRUE ) {
		DisableAllExceptCancel();
		// FIf_erase ( form );
		form_displayed = FALSE;
	}
End
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
	int	i ;

	SetProc(CObevel - delete); Begin

	__DBGpr_int("form_displayed", form_displayed);
	__DBGpr_int("form_exists", form_exists);
	/* Erase the form if it is displayed */
	if ( form_displayed == TRUE ) {
		FIf_erase ( form );
		form_displayed = FALSE;
	}

	/* Delete the form if it exists */
	if ( form_exists ) {
	  	if( form ) {
			FIf_delete( form );
			form = NULL ;
		}
	}
	not_done = 0 ;

        for( i = 0; i < MAX_TEMPS; i = i+1 ) {
                objOEs[i].obj_id.objid  = NULL_OBJID;
        }
End
}


/**********************************************************/
IGRstat LocateOE( inType, inPrompt, selOE, objName, check)
IGRchar		*inType;
IGRchar		*inPrompt;
TGRobj_env	*selOE;
IGRchar		*objName;
IGRint		check;
{
	IGRint	i, attr, response, labels[60] ;
 
SetProc(CObevel - LocateOE); Begin

	if( selOE->obj_id.objid != NULL_OBJID ) {
		gr$display_object (	object_id = &selOE->obj_id ,
					md_env    = &selOE->mod_env ,
					mode      = GRhd ) ;
	}

        for( i=0; i<60; i=i+1 )
        {
	   labels[i] = 0 ;
           if( ! ( FIg_is_valid( form, i )) )
           {
              FIg_get_attr( form, i, &attr ) ;
              if( !( attr & FI_NOT_DISPLAYED ) )
              {
                 FIg_disable( form, i );
		 labels[i] = 1 ;
              }
           }
        }

 	ci$locate(
		obj		= &selOE->obj_id.objid,
     		osnum		= &selOE->obj_id.osnum,
		md_env		= &selOE->mod_env,
		response	= &response,
		classes		= inType,
		prompt		= inPrompt, 
		stackable	= TRUE ,
		properties	= LC_LC_ONLY | LC_DP_ONLY | LC_RW,
		owner_action	= LC_RIGID_COMP  | LC_RIGID_OWNER | 
				  LC_FLEX_COMP   | LC_FLEX_OWNER  | 
				  LC_REF_OBJECTS );

        for( i=0; i<60; i=i+1 )
        {
	   if( labels[i] ) FIg_enable( form, i );
	}
            
	__DBGpr_int("Locate response", response ) ;
	__DBGpr_int("RESET", RESET ) ;
	__DBGpr_int("FI_RESET", FI_RESET ) ;
	if( response == RESET && strstr( inPrompt, "Edge") != NULL ) {
		strcpy( objName, "Default" ) ;
		selOE->obj_id.objid = NULL_OBJID ;
		goto wrapup ;
	}

	if( response == RESET && strstr( inPrompt, "Point") != NULL ) {
		strcpy( objName, "Auto" ) ;
		selOE->obj_id.objid = NULL_OBJID ;
		goto wrapup ;
	}

	msgStr[0] = '\0' ;
	if( selOE->obj_id.objid != NULL_OBJID ) {
		if (CheckForProperName( selOE, check, objName, msgStr ) ){
                	__DBGpr_str("Returned name is ",objName);
        	}
	}

wrapup:
End
   return TRUE;
}

IGRstat	HiliteObjByClickField ( gadget )
IGRint	gadget ;
{
	IGRint		retFlag;
	TGRid		objID ;
	IGRchar		text[128] ;

	retFlag		= 1 ;
	text[0]		= '\0' ;
	objID.objid	= NULL_OBJID ;

	if( gadget <= 0 ) goto wrapup ;

	if( dpBvlMode == GRhe )	dpBvlMode = GRhd ;
	else			dpBvlMode = GRhe ;

	FIg_get_text( form, gadget, text );
	if( text[0] == '\0' ) goto wrapup ;
	__DBGpr_str("Field text", text);

	switch( gadget ) {
		case EJ_PLATE_FLD:
			objID = objOEs[E_PLATE].obj_id ;
			break ;
		case EJ_CURVE_FLD:
			objID = objOEs[E_CURVE].obj_id ;
			break ;
		case PLATE1_FLD:
			objID = objOEs[PLATE1].obj_id ;
			break ;
		case PLATE2_FLD:
			objID = objOEs[PLATE2].obj_id ;
			break ;
		case EDGE1_FLD:
			objID = objOEs[EDGE1].obj_id ;
			break ;
		case EDGE2_FLD:
			objID = objOEs[EDGE2].obj_id ;
			break ;
		case VA_PLATE_FLD:
			objID = objOEs[V_PLATE].obj_id ;
			break ;
		case VA_BASE_CRV_FLD:
			objID = objOEs[V_BASE_CRV].obj_id ;
			break ;
		case VA_OFF_CRV_FLD:
			objID = objOEs[V_OFF_CRV].obj_id ;
		default: 
			goto wrapup ;
	}

	if( objID.objid == NULL_OBJID) goto wrapup ;

	if( hilitObj.objid == objID.objid ) {
		if( hilitMode == GRhe )	hilitMode = GRhd ;
		else			hilitMode = GRhe ;
	}
	else {
		gr$display_object (	object_id = &hilitObj ,
					md_env    = &MOD_ENV ,
					mode      = GRhe ) ;
		hilitMode = GRhd ;
		hilitObj = objID ;	
	}

	if( hilitGadget > 0 && hilitGadget != gadget ) {
		FIg_get_text( form, hilitGadget, text ) ;
		FIfld_set_select( form, hilitGadget, 0, 0, FALSE ) ;
		FIg_set_text( form, hilitGadget, text ) ;
	}

	hilitGadget = gadget ;
	gr$display_object (	object_id = &hilitObj ,
				md_env    = &MOD_ENV ,
				mode      = hilitMode ) ;
wrapup:
	return retFlag ;
}

/*****************************************************************/
IGRstat PlaceMacro() 
{
	IGRstat		retFlag ;
	IGRstat		sts ;

SetProc(CObevel - PlaceMacro); Begin

	retFlag = 0 ;

	FIg_get_text( form, MACRO_TYPE, macStr ) ;
	__DBGpr_str("macStr", macStr);

	switch( macStr[0] ) {
	
	case '1' :
	case 'F' :
		sts = PlaceEJ_BevelMacro (	form, 
						objOEs, 
						lblPntFlag, 
						&bvlMacOE,
						msgStr) ;
		break ;
	case '2' :
		sts = PlaceBevelMacro (		form,
						objOEs, 
						lblPntFlag, 
						&bvlMacOE,
						msgStr) ;
		break ;
	case 'V' :
	case 'v' :
		sts = PlaceVariable_BevelMacro(	form, 
						objOEs, 
						lblPntFlag, 
						&bvlMacOE ,
						msgStr) ;
		break ;
	}

	__DBGpr_str("msgStr", msgStr);

	if( sts ) retFlag = 1 ;
wrapup:
End
	return retFlag ;
}


/*****************************************************************/
Initiate()
{
	IGRlong		msg ;
	IGRint		i ;
	IGRint          txtLen, txtBytes, bytesRet ;
struct	GRdpb_text_symb	txtSymb ;

	SetProc(CObevel - Initiate); Begin

	pltStr1[0]	= '\0' ;
	pltStr2[0]	= '\0' ;
	edgStr1[0]	= '\0' ;
	edgStr2[0]	= '\0' ;
	btStr[0]	= '\0' ;
	ptStr[0]	= '\0' ;
	//macStr[0]	= '\0' ;
	stockVal	= 0 ;
	offsetVal	= 0 ;
	strcpy( lblPntFlag, "00" ) ;

	dpBvlMode	= GRhe ;
	hilitMode	= GRhe ;
	hilitObj.objid	= NULL_OBJID ;
	hilitGadget	= -1 ;

	for( i = 0; i < MAX_TEMPS; i = i+1 ) {
		objOEs[i].obj_id.objid	= NULL_OBJID;
	}
	bvlCrvOE.obj_id.objid   = NULL_OBJID;
	bvlMacOE.obj_id.objid   = NULL_OBJID;
	neatPltOE1.obj_id.objid = NULL_OBJID;
	neatPltOE2.obj_id.objid = NULL_OBJID;

	FIg_disable( form, EJ_CURVE_BTN ) ;
	FIg_disable( form, EJ_POINT_BTN ) ;
	FIg_set_text( form, EDGE1_FLD, "Default"); 
	FIg_set_text( form, EDGE2_FLD, "Default"); 

	fontSize = VSbvl_get_font_size();
	if( !fontSize )
	{
	   gr$get_text_symb( msg     = &msg ,
			     sizbuf  = &txtBytes ,
			     buffer  = &txtSymb ,
			     nret    = &bytesRet ) ;
	   if( !(msg&1) ) {
		fontSize = 25 ;
	   }
	   else {
		fontSize = txtSymb.Active_width ;
	   }
	}
	__DBGpr_int("fontSize 1", fontSize);
	VSbvl_set_font_size(fontSize) ;
	sprintf(fontStr, "%d", fontSize);
	FIg_set_text( form, FONT_SIZE, fontStr); 

        /*
         * Get information from the bevel_setup file.
         */
	__DBGpr_com(" Call VSbev_ReadSetupProcessSpec ");
	VSbev_ReadSetupFile( form );

wrapup: 
End
	return ;
}


main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/
{

  IGRint	response;     
  IGRint	i;
  IGRint	m;
  IGRint	msg;
  IGRint	pos, toggle;
  IGRint	selFlag;
  IGRint	exitFlag;
  IGRint	numAttrs, num_rows;
  IGRint	sts;
  IGRint 	error;
  IGRchar	tmpStr[80], typeStr[80] ;
  TGRobj_env	offsetSrfOE, tmpOE ;
  BSrc		rc ;

 
  /* initialize some parameters before we start */
  test_wakeup = 1;		/* flag for wakeup function */
  form_exists = FALSE;		/* flag for delete function */
  form_displayed = FALSE;	/* flag for sleep  function */
  not_done = TRUE;		/* Set this to FALSE when done with form */

  exitFlag   = 1;
  tmpStr[0]  = '\0' ;
  macStr[0]  = '\0' ;

  if( !form_exists ) { 
	form_init();      
  }
  message(TITLE_STRING);

  Initiate() ;

  get_current_file_name_and_mod_env();

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/
  while (not_done )
  {
      __DBGpr_int("case", form_st.gadget_label);

      /* Suspend the command file and wait for the form */
      ci$get (	prompt   = "Fill in the form",
		response = &response );
              
      UI_status(""); /* clear the status field*/
      strcpy( msgStr, "" ) ;
      FIg_set_text( form, MESSAGE_BAR, "\n\n" ) ;
	
      HiliteObjByClickField ( form_st.gadget_label ) ;

      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){

        case FI_CANCEL:		// Quit Button 
          not_done = 0;		// Stop the loop
	  exitFlag = 0;		// exit the program
          FIf_erase ( form );	// Erase the form 
          break;

        case MACRO_TYPE:	// Get Macro Type
  	  FIg_get_text( form, MACRO_TYPE, macStr );
	  VSbvl_set_bevel_type( macStr[0] ) ;
	  DisplayGadgets( form, macStr ) ;
	  __DBGpr_str("Macro Type", macStr);
          break;

        case EJ_PLATE_BTN:	// Get Plate for "1 plate" case
 	  LocateOE( "VSplate", "Identify Plate/Move on", 
		     &objOEs[E_PLATE], EJpltStr, FALSE);
  	  FIg_set_text( form, EJ_PLATE_FLD, EJpltStr ); 
	  sts = GetNeatPlate(&objOEs[E_PLATE], &neatPltOE1);
	  if( !sts ) break ;
	  FIg_enable( form, EJ_CURVE_BTN ) ;
	  FIg_enable( form, EJ_POINT_BTN ) ;
	  if( objOEs[E_CURVE].obj_id.objid != NULL_OBJID ) {
	  	//CheckEJcurve( &neatPltOE1, &objOEs[E_CURVE], msgStr ) ;
	  	CheckCurve (	"plate:base", 
				&objOEs[E_PLATE], 
				&objOEs[E_CURVE],
				msgStr) ;
	  }
          break;

        case EJ_CURVE_BTN:	// Get CURVE for "1 plate" case
 	  LocateOE( "GRcurve", "Identify Curve (a neat edge of plate)/Move on", 
		     &objOEs[E_CURVE], EJcrvStr, FALSE) ;

          //if( CheckIfCurveBelongsToNeatPlate( &objOEs[E_CURVE], &neatPltOE1) )
	  if( 1 )
	  {
	      if( CheckCurve (	"plate:base", 
				&objOEs[E_PLATE], 
				&objOEs[E_CURVE],
				msgStr) ) {
		FIg_set_text( form, EJ_CURVE_FLD, EJcrvStr ) ;
	      }
	  }
          else
          {
             objOEs[E_CURVE].obj_id.objid = NULL_OBJID;
             FIg_set_text( form, MESSAGE_BAR, "Locate Correct Edge" ) ;
          }
          break;

	case EJ_POINT_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point/move on for auto", 
			&objOEs[E_POINT], tmpStr, FALSE);
	  if( objOEs[E_POINT].obj_id.objid == NULL_OBJID ) {
		lblPntFlag[0] = '0' ;
	  }
	  else {
		lblPntFlag[0] = '1' ;
	  }
          break;

        case EJ_TOGGLE_INPUT:
	  FIg_get_state( form, EJ_TOGGLE_INPUT, &toggle ) ;
	  if( toggle ) {
		FIg_erase  ( form, EJ_ADJPLATE_BTN ) ;
		FIg_erase  ( form, EJ_PLATE_IN ) ;
		FIg_display( form, EJ_THICK_IN ) ;
	  }
	  else {
		FIg_erase  ( form, EJ_THICK_IN ) ;
		FIg_display( form, EJ_ADJPLATE_BTN ) ;
		FIg_display( form, EJ_PLATE_IN ) ;
	  }
	  break ;

        case EJ_THICK_IN:
	  FIg_get_value( form, EJ_THICK_IN, &EJthickness ) ;
	  break ;

        case EJ_ADJPLATE_BTN:
	  LocateOE( "VSplate", "Identify Adjacent Plate/Move on", 
			&adjPltOE, tmpStr, FALSE);
	  if( adjPltOE.obj_id.objid != NULL_OBJID ) {
	 	 vdsa$GetStruct(	objOE = &adjPltOE,
					name  = "plate_thk",
					dbl   = &EJthickness);
		  FIg_set_value( form, EJ_PLATE_IN, EJthickness ); 
	  }
          break;

        case VA_PLATE_BTN:	// Get Plate for "1 plate" case
 	  LocateOE( "VSplate", "Identify Deck/Bulkhead plate/Move on", 
		     &objOEs[V_PLATE], VApltStr, FALSE);
  	  FIg_set_text( form, VA_PLATE_FLD, VApltStr ); 

          break;

	case VA_BASE_CRV_BTN:
 	  LocateOE(	"GRcurve", "Identify Base Curve/Move on", 
			&objOEs[V_BASE_CRV], VAbCrvStr, FALSE);
	  if( CheckCurve("plate:base", 
			&objOEs[V_PLATE], 
			&objOEs[V_BASE_CRV],
			msgStr ))
	  {
		FIg_set_text( form, VA_BASE_CRV_FLD, VAbCrvStr ); 
	  }
          break;

	case VA_OFF_CRV_BTN:
 	  LocateOE(	"GRcurve", "Identify offset Curve/Move on", 
			&objOEs[V_OFF_CRV], VAoCrvStr, FALSE);
	  if( CheckCurve("plate:offset", 
			&objOEs[V_PLATE], 
			&objOEs[V_OFF_CRV],
			msgStr ))
	  {
		FIg_set_text( form, VA_OFF_CRV_FLD, VAoCrvStr ); 
	  }
          break;

	case VA_POINT_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point/move on for auto", 
			&objOEs[V_POINT], tmpStr, FALSE);
	  if( objOEs[V_POINT].obj_id.objid == NULL_OBJID ) {
		lblPntFlag[0] = '0' ;
	  }
	  else {
		lblPntFlag[0] = '1' ;
	  }
          break;

        case PLATE1_BTN:	// Get Plate 1
 	  LocateOE( "VSplate", "Identify Plate 1/Move on", 
		     &objOEs[PLATE1], pltStr1, FALSE);
  	  FIg_set_text( form, PLATE1_FLD, pltStr1 ); 
	  sts = GetNeatPlate(&objOEs[PLATE1], &neatPltOE1);
          break;

        case PLATE2_BTN:	// Get Plate 2
 	  LocateOE("VSplate", "Identify Plate 2/Move on", 
		    &objOEs[PLATE2], pltStr2, FALSE);
  	  FIg_set_text( form, PLATE2_FLD, pltStr2 ); 
	  sts = GetNeatPlate(&objOEs[PLATE2], &neatPltOE2);
          break;

        case EDGE1_BTN:		// Get Edge 1
 	  LocateOE(	"GRcurve", "Identify Edge 1/move on for default", 
			&objOEs[EDGE1], edgStr1, FALSE);
  	  if( CheckIfCurveBelongsToNeatPlate( &objOEs[EDGE1], &neatPltOE1) )
		FIg_set_text( form, EDGE1_FLD, edgStr1 ); 
	  else
	  {
	     objOEs[EDGE1].obj_id.objid = NULL_OBJID;
	     FIg_set_text( form, MESSAGE_BAR, "Locate Correct Edge" ) ;
  	  }
          break;

        case EDGE2_BTN:		// Get Edge 2
 	  LocateOE(	"GRcurve", "Identify Edge 2/move on for default", 
			&objOEs[EDGE2], edgStr2, FALSE);
	  if( CheckIfCurveBelongsToNeatPlate( &objOEs[EDGE2], &neatPltOE2) )
  	  	FIg_set_text( form, EDGE2_FLD, edgStr2 ); 
          else
          {
             objOEs[EDGE2].obj_id.objid = NULL_OBJID;
             FIg_set_text( form, MESSAGE_BAR, "Locate Correct Edge" ) ;
          }
          break;

	case BEVEL_TYPE:
  	  FIg_get_text( form, BEVEL_TYPE, btStr );
	  strcpy( typeStr, GetNumber(btStr) );

	  vdfrm$GetListNumRows( form = form, gadget = PROCESS_TYPE,
				rows = &num_rows );

	  for( i=0; i<num_rows; i=i+1 )
	  {
	    vdfrm$GetListText( 	form = form, gadget = PROCESS_TYPE,
				row = i, txt = tmpStr );
	    if( !strncmp( typeStr, tmpStr, strlen(typeStr) ) )
	    {
	       vdfrm$SetText( form = form, gadget = PROCESS_TYPE,
			      txt = tmpStr );	
	       break;
	    }
	  }
	  __DBGpr_str("Bevel Type", btStr);

	case PROCESS_TYPE:
  	  FIg_get_text( form, PROCESS_TYPE, ptStr );
	  __DBGpr_str("Process Type", ptStr);
	  break ;

	case OFFSET_VALUE:
	  FIg_get_value( form, OFFSET_VALUE, &offsetVal);
	  __DBGpr_int("Offset Value", offsetVal);
	  break ;

	case STOCK_VALUE:
	  FIg_get_value( form, STOCK_VALUE, &stockVal);
	  __DBGpr_int("StockValue", stockVal);
	  break ;

	case FONT_SIZE:
	  FIg_get_text( form, FONT_SIZE, fontStr);
	  fontSize = atoi( fontStr ); 
	  VSbvl_set_font_size(fontSize) ;
	  break ;

	case POINT1_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point 1/move on for auto", 
			&objOEs[POINT1], tmpStr, FALSE);
	  if( objOEs[POINT1].obj_id.objid == NULL_OBJID ) {
		lblPntFlag[0] = '0' ;
	  }
	  else {
		lblPntFlag[0] = '1' ;
	  }
          break;


	case POINT2_BTN:
 	  LocateOE(	"GR3dpoint", "Identify Point 2/move on for auto", 
			&objOEs[POINT2], tmpStr, FALSE);
	  if( objOEs[POINT2].obj_id.objid == NULL_OBJID ) {
		lblPntFlag[1] = '0' ;
	  }
	  else {
		lblPntFlag[1] = '1' ;
	  }
	  break ;

	case SHOW_BEVEL_BTN:
	  if( bvlMacOE.obj_id.objid == NULL_OBJID ) {
		FIg_get_text( form, MACRO_TYPE, macStr ) ;
		ShowBevel( macStr, objOEs, msgStr ) ;
	  }
	  else {
		gr$display_object (	object_id = &bvlMacOE.obj_id ,
					md_env    = &bvlMacOE.mod_env ,
					mode      = GRhd ) ;
	  }
	  break ;

        case FI_RESET:
	  not_done = TRUE ;
	  tmpStr[0] = VSbvl_get_bevel_type();
	  Initiate() ;
	  DisplayGadgets( form, tmpStr ) ;
	  break ;

        case FI_EXECUTE:
	  not_done = TRUE ;
	  if( PlaceMacro() ) {
		tmpStr[0] = VSbvl_get_bevel_type();
		FIf_reset( form ) ;
		Initiate() ;
		DisplayGadgets( form, tmpStr ) ;
	  }
	  break;

        case FI_ACCEPT:
          if( PlaceMacro() ) {
		not_done = FALSE;
		FIf_erase ( form ); 
	  }
	  else {
		not_done = TRUE ;
	  }
          break;

        } /* END switch ( g_label ) */

	__DBGpr_str("main: msgStr", msgStr);
	if( strcmp( msgStr, "" ) ) {
		FIg_set_text( form, MESSAGE_BAR, msgStr ) ;
		UI_status( msgStr ) ;
	}
	__DBGpr_int("At end of loop, case", form_st.gadget_label);
	__DBGpr_int("not_done", not_done);

	
    }     /* END while ( not done ) */

wrapup:

    UI_status("") ;
    prompt("") ;
    message("") ;
    if ( exitFlag == 0 ) exit;

}

/********************************************************/

get_current_file_name_and_mod_env()
{
	IGRchar filename[132];
	IGRint  var_size[3];
	IGRint  bad_var;
	struct  EX_var_list      ex_var[4];


// GET THE CURRENT FILE NAME

	var_size[0] = sizeof(filename);
	ex_var[0].var = EX_CUR_FILENAME;
	ex_var[0].var_value = &filename[0];
	ex_var[0].num_bytes = &var_size[0];
	var_size[1] = NULL;

	msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

	__DBGpr_str("filename",filename);

 	ci$get_module_info( md_env = &MOD_ENV);
}
