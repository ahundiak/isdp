#	I/STRUCT
#	Chain-opping of a directory
#	Usage: bigopp <.S and .I files>
#

DEBUG=""
PRINT=""
integer k
while getopts gDS c ; do
	case $c in
		g) echo "\n\tCompiling for DEBUGGER" ; DEBUG="-g" ;;
		D) echo "\n\tCompiling with printouts";
			PRINT="-DvserrDEBUG -DvsDEBUG" ;;
		S) ;;
		\?) echo "Invalid option -$c"; exit 2;;
	esac
done
k=${OPTIND}-1
shift ${k}

opp=${EXNUC}/bin/opp

OPPFLAGS="\
	-I${EXNUC}/include \
	-I${GRNUC}/include \
	-I${MODEL}/include \
	-I${EMS}/include \
	-I${BS}/include \
	-I${BS}/include/prototypes \
	-I${VDS}/include \
	-I${STRUCT}/include \
	-I${STRUCT}/include/prototypes \
	-I${EXNUC}/spec \
	-I${GRNUC}/spec \
	-I${MODEL}/spec \
	-I${EMS}/spec \
	-I${VDS}/spec \
	-I${STRUCT}/spec"

IPATH="\
	-I${EXNUC}/include \
	-I${GRNUC}/include \
	-I${MODEL}/include \
	-I${EMS}/include \
	-I${BS}/include \
	-I${BS}/include/prototypes \
	-I${VDS}/include \
	-I${STRUCT}/include
	-I${STRUCT}/include/prototypes"
CC="acc -knr -O3"

OPPOPT="-k -DENV5 -DCLIX -Dclipper=1 -D__clipper__=1"

if [ -n "${DEBUG}" ] ; then
	OPPOPT="$OPPOPT -l"
fi

if [ -n "${PRINT}" ] ; then
	OPPOPT="${OPPOPT} ${PRINT}"
fi

COPT=""
RC=0

function _opp {
	integer u
	integer m
	integer	count

	SOURCE=
	for f in $* ; do
		if [ -r ${f} ] ; then
			SOURCE="${SOURCE} ${f}"
		else
			echo "${f} not found"
		fi
	done
	echo "\n***" Big OPP of :"\n"${SOURCE}"\n"

	let count=0
	for f in ${SOURCE} ; do
		toOpp[${count}]=${f}
		if [ blob${f%.I} = blob${f} ] ; then
			# .S file
			toCC[${count}]=${f%.S}.c
		else	# .I file
			toCC[${count}]=${f%.I}.c
		fi
		let count=count+1
	done

	# Opp everybody
	oppList=""
	ccList=""
	k=0
	while [ ${k} -lt ${count} ] ; do
		oppList="${oppList} ${toOpp[${k}]}"
		ccList="${ccList} ${toCC[${k}]}"
		let k=k+1
	done

	echo ${opp} ${OPPOPT} ${OPPFLAGS} ${oppList}
	if ${opp} ${OPPOPT} ${OPPFLAGS} ${oppList} ; then
		:
	else
		RC=1
	fi
		
	echo ${CC} -c ${COPT} ${DOPT} ${IPATH} ${ccList}

	if ${CC} -c ${COPT} ${DOPT} ${IPATH} ${ccList} ; then
		:
	else
		RC=1
	fi

	echo

	if [ -z "${DEBUG}" ] ; then
	let u=0
	let m=0
	for U in ${ccList} ; do
		if /bin/rm ${U} > /dev/null 2>&1 ; then
			echo "\tremoved ${U}"
			:
		else
			case ${m} in
				0)	let m=100000;;
				100000) let m=1
					missed=${toOpp[${u}]};;
				*)	let m=m+1
					missed="${missed} ${toOpp[${u}]}";;
			esac
		fi
		let u=u+1
	done
	else
		echo "\tLeaving .c files"
	fi
}

# Beware of one argument being like "*.[IS]" with no .I's or .S's
if [ $# -eq 1 ] && [ ! -r $1 ] ; then
	echo "$1 not found"
	exit 0
fi
_opp $*
if [ "blob${missed}" != blob ] ; then

		/usr/bin/tput bel
		echo "\nFiles not processed: ${missed}"
		_opp ${missed}
fi	

exit $RC
