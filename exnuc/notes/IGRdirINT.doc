

1.     GOAL
        Statement
        Class Structure Diagram

2.     INTRODUCTION
        Statement
2.1.    STORAGE
2.1.1.   DIstorage
2.1.2.   DIbtree
2.1.3.   DIbst
2.1.4.   DIbobpt
2.1.5.   DIbstgr
2.1.6.   DIbstob

2.2.    DIRECTORIES
2.2.1.   IGRdir
2.2.2.   DIrectory
2.2.3.   DImaster
2.2.4.   DIroot
2.2.5.   DIlink

2.3.    PROTECTION/PRIVILEGES
         Statement

3.     DIRECTORY SUB-SYSTEM
3.1.    Initialization
3.2.    Overview
         Statement
3.2.1.   Master Directory Table
3.2.2.   Reverse Access Table
3.2.3.   Creating a Link
3.2.4.   Mounting an Object Space
3.2.5.   Unmounting an Object Space
3.3.    Files of the DIrectory Class
3.3.1.   DIrectori.I
3.3.2.   DIboot.I
3.3.3.   DIconfig.I
3.3.4.   DIlib.I
3.3.5.   DImaci.I

-------------------------------------------------------------------------------
                           1.    GOAL
-------------------------------------------------------------------------------

     The goals for the design of the Directory Sub-system can be viewed in three
     major sections.
	
	To provide :

	1) Naming capability (for indexing)
	2) Hierarchical structure
	3) Access to different object spaces
     
     Completion of these goals has yielded a type of database management system
     known as the Directory Sub-system.  This document will attempt to describe
     how these goals were achieved along with details necessary to properly
     maintain and manipulate the Directory Sub-system to its fullest intent.



                                      Root
                   ____________________/\____________________
                  /           /                  \           \
                 /           /                    \           \
              GRoups      IGRdir               DIstorage     GRoup
                |           |\                    /
                |           | \                  /
                |           |  \             DIbtree
                |           |   \              / \
                |           |    \            /   \
                |           |     \          /     \
                |           |   DIlink    DIbst  DIbobpt
                |           |              / \
                |           |             /   \
                |           |            /     \
                 \          |\          /       \
                  \         | \     DIbstgr  DIbstob
                   \        |  \      /         /
                    \       |   \    /         /
                     \      |    \  /         /
                      \     |     \/         /
                       \    |  DImaster     /
                        \   |              /
                         \  |  ___________/
                          \ | /
                           \|/
                        DIrectory
                            |
                            |
                            |
                          DIroot


       ------------------------------------------------------
       Figure 1   Class Structure of the Directory Sub-system
       ------------------------------------------------------

-------------------------------------------------------------------------------
                           2.    INTRODUCTION
-------------------------------------------------------------------------------

       The DIrectory Sub-system is divided into three major sections based on
     functionality which are the responsibilities of the different classes :

			  Functionality     Class
			  -------------     -----

                          Storage       ->  DIstorage
                          Directories   ->  IGRdir
                          Protection/   ->  GRoup(s)
			  Privileges     


          *******************************************************
          **********          2.1.    STORAGE          **********
          *******************************************************


2.1.1. DIstorage ---> private and abstract class
----------------
  This class provides a way to store the Directory Sub-system on disk. The
messages defined at this level are the general messages needed for any type of
storage that may be implemented.  There is no implementation of these messages
at this level, just class definition.  Different types of storage may be
implemented in the system, where each type of storage would be defined as a
subclass of DIstorage.  At the present time only a B-tree storage exists.

2.1.2.DIbtree ---> private and abstract class
-------------
  This class establishes a B-tree storage for the Directory Sub-system based on
the Unix B-tree implemention.  Methods defined in this class and its sub-classes
use the generic functions located in DIbasic.C to perform the operations.  These
generic functions receive/return packages (nodes) of information from/to the
caller.
  An empty B-tree requires a pointer and a variable array (vla) descriptor.  The
pointer is used to point to the B-tree in memory (awake) and the vla is used to
store the B-tree on disk (asleep).  The process of saving (sleep) and restoring
(wakeup) the B-tree transfers the information from memory to the vla or from the
vla to memory, respectively.  A NULL B-tree pointer indicates that that node of
the tree is stored on disk (asleep).
  This is the only type of storage implemented for the Directory Sub-system at
this time.  The instance data for the B-tree is located in this class.

2.1.3. DIbst ---> private and abstract class
------------
  This class implements a B-tree storage where the key is a string and the
information is either an objid or a grid.  The methods of this class call the
generic functions in DIbasic.C which actually do the requested operations.

2.1.4. DIbobpt ---> private class
--------------
  This class implements a B-tree where the key is an objid and the information
is an array of structures of two pointers.  This design provides the information
for the reverse access table that is used during an untranslate operation.  The
methods in this class call the generic functions found in DIbasic.C to actually
do the requested operation.
  One pointer points to the master directory table to retrieve the directory
pathname of the object while the other one points to an internal table inside
the actual directory object's instance data.  Each directory object created in
the system has an internal table that lists the objects located within that
directory.  From this internal table the object name is retrieved (Figure 4).
  Synonyms are allowed for an object in the system and are recorded in the
reverse access table.  The dual pointers to the synonym's directory pathname and
the object name are dynamically added to the reverse access table when the
synonym is created.  A counter is also managed for each entry in the table that
maintains the number of dual pointer combinations (synonyms) for the entry.
  The osnums of the objects are managed by a global table called DIR_G_untree.
This table is referenced by osnums and each osnum entry contains a pointer to
that particular object space's reverse access table (which contains all the
objects of that object space).  The DIR_G_untree table is created during system
initialization and updated during each mount and unmount.
  A separate reverse access table exists for each object space attachment in
the system.  These tables are created during mounts and deleted during unmounts.
Updates are made to the table as objects are added and/or deleted within that
particular object space.
  During a mount the link directory (DIlink) and the root of the object space
(DIroot) are entered into the table.  All objects resulting from a find starting
at DIroot are then added to the table.
  During an unmount a find starting at DIroot is performed and the resulting
objects are removed from the reverse access table.  DIlink and DIroot are then
removed from the table.  An empty table at this point represents a successful
unmount which means DIlink and the reverse access table can be deleted.  If the 
table is not empty, then other object space attachments still exist.  This is
the reason objects are removed from the table one at a time instead of deleting
the reverse access table all at once.

2.1.5. DIbstgr ---> private and abstract class
--------------
  This class implements a B-tree storage where the key is a string and the
information is a grid.  A package of information is either sent from or received
by the methods of this class in relation to the DIbst methods.
  The class information may not be saved since the osnum is not required to be
the same each time the object space is loaded.

2.1.6. DIbstob ---> private and abstract class
--------------
  This class implements a B-tree storage where the key is a string and the
information is an objid.  The osnum of an object space is assigned when it is
entered into the DIR_G_untree table.  This table is constructed during system
initialization and updated during each mount and unmount.  The DIR_G_untree
table is referenced by osnum and each entry contains a pointer to the reverse
access table (DIbobpt) of that particular object space.  Because the node
information no longer contains the osnum, it may be saved on disk.

  To save a B-tree structure, a find is executed starting from the root of the
object space.  All directory objects found are sent a sleep message which dumps
the B-tree node contents from memory into a vla (the B-tree pointers are set to 
NULL).  To load a B-tree structure into memory, a find starting from the root of
the object space is executed.  This find (i_find) checks for NULL pointers in
the structure (which represent a sleeping node).  A wakeup message is sent to
the sleeping node which causes the vla information to be dumped into memory.
The B-tree pointer is then adjusted to point to the information in memory.
  A package of information is either sent from or received by the methods of
this class in relation to the DIbst methods.  This is the first B-tree class to
deal with sleep and wakeup messages since it's the first class that can be
stored on disk.


          **********************************************************
          **********          2.2.   DIRECTORIES          **********
	  **********************************************************

2.2.1. IGRdir
-------------
  The IGRdir.doc document should be referenced for the IGRdir information.

2.2.2. DIrectory
----------------
  This class is a union of IGRdir, DIbstob, and GRoups.  Each directory object
that is entered into the system is recorded in the master directory table.
Every single object (including directory objects) is recorded in the reverse
access table.
  An internal find routine (i_find) is implemented at this level that is used to
wakeup directory objects that are asleep (btree pointer is NULL) when they are
found.  The IGRdir.init method is enhanced to not only initialize IGRdir but
also to initialize DIstorage and GRoups.
  Un-named objects are handled in the Directory Sub-system by using index and
unindex methods at the IGRdir level.  The index method is used to make a
conversion of (directory + index -> grid) and the unindex method is used to make
a (directory + objname -> index) conversion.  These indexing methods may also be
used with named objects, if desired.

2.2.3. DImaster ---> private class
---------------
  This class provides the master directory table which stores a string key and a
grid information.  The osnum is not required to be the same each time an object
space is loaded; therefore, the master directory table can not be saved on disk.
Instead, it is constructed and initialized during system initialization and
updated during each mount and unmount (Figure 3).
  Updating the master directory table is accomplished by doing a find starting
at the root (DIroot) of the object space.  If the object space is being mounted,
a wakeup message is sent to each directory object found and they are entered
into the master directory table.  If the object space is being unmounted, then
the directory objects found are sent sleep messages and removed from the master
directory table.  (In both cases of mounting and unmounting, all objects are
also added or removed from the reverse access table, respectively).
  The IGRdir.init method is enhanced at this level to not only initialize IGRdir
but also DIstorage.  The DIbstgr.retrieve_info method is enhanced to check if
the current directory matches the key.  If it matches, then the information is
returned; otherwise, the command is completed as before.
  Note: only one master directory table exists for the directory structure.

2.2.4. DIroot ---> private class
-------------
  This class provides the necessary functionality to locate the root directory
of an object space.  Each object space has one root directory (DIroot) which
has an identify message that will return its objid.  The root directory is used
when attaching an object space to the current directory structure.  The DIroot
directory has a channel that is used to connect it to the object space object.
This allows DIroot to be sent an identify message to return its objid.

2.2.5. DIlink
-------------
  This class provides the functionality to create a link between directories.
The DIlink directory is constructed and placed in the current directory
structure at the point where the link should be made.  The set_target method is
used to specify a "target" directory to create the link between.  The DIlink
directory then intercepts all the messages sent to it and diverts them to the
"target" directory.  This is the concept used for the attachment of object
spaces.
  There is no instance data for the DIlink class, so links in the Directory
Sub-system are not saved by the system (this is done at another level).
  While unmounting an object space, message interception is stopped and the
DIlink directory is deleted.  Now that the object space no longer exists, there
is no need for the reverse access table for this object space; so it is deleted.
This is handled by the delete method provided within this class.

          **********************************************************
          *****          2.3.    PROTECTION/PRIVILEGES         *****
          **********************************************************

  The purpose of the GRoup(s) classes is to handle a group protection/privileges
mechanism for its objects.  Each group has three qualities defined by the
instance data : type, password, and index.  There are three group types :

       o public
          -- anybody outside the group can read/write objects of this group.

       o read only
          -- anybody outside the group can read objects of this group.

       o private
          -- nobody outside the group can read/write objects of this group.

The group to which an object belongs is the current group at the time that the
object was constructed.  The GRchange_group function can be used to change the
owning group of an object.
  The protection/privileges scheme uses the concept of a current group.  When a
group is current, all the objects of this group are read/write; otherwise, the
principles listed above apply for determining a valid operation.  A password may
be attached to a group in order to restrict it from becoming the current group.
The password is encrypted by the system through the GRpasswd function and the
GRmatch function determines if a given password matches the encrypted version.
  The index of a group is assigned at the time the group is created.  Indexing
starts at 0, which is assigned during initialization to the "sys" (super-user)
group.
  GRvalidate is called before every command involving objects with the GRoup
protection to determine if the operation is valid.  This is done by first
checking if the validation if turned ON or OFF.  If it is OFF, then the command 
is valid automatically (this is used to prevent multiple checking).  If the
validation is ON, the operation is checked.  The first check is to see if the
current group is equal to the group specified in the operation or the "sys"
group (super-user).  If it is equal to one of these, then the command is valid;
otherwise, the tests outlined above are performed.
  Within the GRcg function there are a few details that need to be mentioned.  A
flag argument is used to specify whether or not to update the previous current
group.  This is important when preparing to execute a "cg -" command.  If the
flag is not set (default setting), the previous current group is updated;
otherwise, it is not updated.
  For the "cg -" in particular, this command will activate the previous current
group for most cases.  If the previous current group was "sys", then a "cg -"
will actually change groups to the current group (no change).
  Executing the GRcg function when the current group is "sys" does not check the
password of the requested group.  In other words, if you are currently in "sys"
group, then you can change groups into any group in the system without giving
the new group's password.
  The GRchange_group function is used to change the group ownership of an object
from the current owner to the specified group.

-------------------------------------------------------------------------------
                           3.    DIRECTORY SUB-SYSTEM
-------------------------------------------------------------------------------

	  ***********************************************************
          **********          3.1. Initialization          **********
          ***********************************************************

       The Directory Sub-system is initialized by the Object Manager.  If a
     configuration file exists then it is read; otherwise, DIboot is executed.
     DIboot performs the following:

		 1) initializes global variables
		 2) creates root (:) and master (master) directories
		 3) initializes master directory table
		 4) attaches transient object space
		    (creates and initializes reverse access table (DIbobpt) )
		 5) executes initialization of GRoup protection/priveleges
		    (executes gr$init).



       Transient OS                                        DIR_G_untree
             --------------------------------          --------------------
             |                   :          |     OS=0 |                  |
             |  master          / \         |          |                  |
             |                 /   \        |          |------------------|
             |                /     \       |     OS=1 |                  |
             |          transient  groups   |          |   untree_id      |---
             |           (DIlink)    /\     |          |------------------|  |
             |             //       /  \    |     OS=2 |                  |  |
             |            //       /    \   |          |                  |  |
             |           //     "sys"  "usr"|          |------------------|  |
             -----------//-------------------     OS=3 |                  |  |
                       //                              |                  |  |
       Transient OS   //                               |------------------|  |
             --------//-----------------               :        :         :  |
             |      //                 |                                     |
             |   DIroot     DIbobpt <-----------------------------------------
             |                         |
             |                         |
             ---------------------------


                ----------------------------------------------------
                Figure 2   Directory Sub-system After Initialization
                ----------------------------------------------------


       The root (:), master, and groups directories are in the "sys" group.  The
     transient directory is in the "usr" group.  The root directory object
     information is entered into the master directory table and into transient's
     reverse access table (DIbobpt).  Transient is also added to the master
     directory table and the reverse access table.

          ********************************************************
          **********          3.2.    Overview          **********
          ********************************************************

       The Directory Sub-system has a root (:) directory as the top of its
     hierarchy structure.  There is one root directory (DIroot) associated with
     each object space.  There is also one reverse access table associated with
     each object space.  There is one master directory table associated with the
     entire Directory Sub-system.

     3.2.1. MASTER DIRECTORY TABLE
     -----------------------------
       The master (master) directory is used for storing the directory names,
     objids, and osnums of each directory object in the entire Directory
     Sub-system.  Further access to the directory pathname of an object is
     achieved by pointing to the entry in the master directory table.  When a
     translate conversion is executed (objname -> osnum + objid), the master
     directory table is searched for the directory pathname of the object.  If
     located, then the objid and osnum for that object are returned as the
     result of the translate.
       The master directory table is created and initialized during the system
     initialization.  Only one master directory table exists for the entire
     directory structure.  Updates are achieved by doing a find starting at the
     root of the object space being mounted or unmounted.  If mounting, then the
     directory objects found are sent wakeup messages and entered in the table.
     If unmounting, each directory object is sent a sleep message and removed
     from the table.
       This table of information is not stored on disk (because of the osnum).


           Directory Structure                Master Directory Table

                                       -------------------------------------
                  :                    |     directory     | osnum | objid |
                 / \                   |===================|=======|=======|
                /   \                  |                   |       |       |
         transient  groups             |        ""         |   #   |   #   |
          (DIlink)    /\               |                   |       |       |
            //       /  \              |   ":transient"    |   #   |   #   |
           //       /    \             |                   |       |       |
          //     "sys"  "usr"          |":transient:DIroot"|   #   |   #   |
         //                            |                   |       |       |
      DIroot                           |     ":groups"     |   #   |   #   |
                                       |                   |       |       |
                                       |-------------------|-------|-------|
                                       :                   :       :       :


	             -------------------------------------------
                     Figure 3   Master Directory Table Structure
	             -------------------------------------------

     3.2.2. REVERSE ACCESS TABLE
     ---------------------------
       Each entry in the Directory Sub-system also has some object information
     stored in a reverse access table (DIbobpt).  An untranslate operation
     performs a conversion of (osnum + objid -> objname).  The objid is stored
     in the reverse access table and the osnum is assigned in the DIR_G_untree
     table during the mount.  This untree table is accessed by osnum and each
     entry points to the reverse access table of that specific object space
     (see Figure 1).  A separate reverse access table is created and initialized
     for each object space during a mount.
       Pointers are used to retrieve the object name.  Each directory object
     contains a directory table within its instance data.  This internal table
     stores the object names of the entries in that directory.  So the reverse
     access table stores two pointers to retrieve the object name.  One pointer
     to the master directory table retrieves the directory pathname where the
     object is located and a second pointer to that directory object's internal
     table retrieves the name of the object.  One exception to this rule is that
     the root directory is stored with pointers to NULL strings.
       This implementation provides for synonyms to be used during the naming of
     an object.  All that has to be done is to add an extra pair of pointers to
     the reverse access table.  The synonym may be different in directory path,
     object name, or both directory path and object name.  A count is also used
     to quickly tell how many synonyms are present for an object.


        Directory Structure                Master Directory Table

         |-----------------|          -------------------------------------
         |     :           |          |      dirname      | osnum | objid |
         |    / \          |          |===================|=======|=======|
         |   /   \         |          |        ""         |   #   |   !   |
         V  /     \        |       -->|   ":transient"    |   #   |   @   |
      transient  groups    |       |  |":transient:DIroot"|   #   |   $   |
          //       /\      |       |  |     ":groups"     |   #   |   %   |
         //       /  \     |       |  |-------------------|-------|-------|
        //       /    \    |       |  :                   :       :       :
       //     "sys"  "usr" |       |         
      //                   |       |--- 
   DIroot                  |          |               
                           |          |             Dynamically Added As
                           |          |             Synonyms Are Declared
                -----------|----------|--------- .. --------------------- ..
                | objid  | |objname | |dirname |    | objname | dirname |
                |--------|-|--------|-|------- | .. |---------|---------| ..
                |   !    | | *->NULL| | *->NULL|    |         |         |
      Reverse   |--------|-|--------|-|--------| .. |         |         | ..
       Access   |   @    | |---*    | |---*    |    |         |         |
        Table   |--------|----------|----------| .. |---------|---------| ..
                |   $    |     *    |     *    |    |    *    |    *    |
                |--------|----------|----------| .. |---------|---------| ..
                |   %    |     *    |     *    |    |         |         |
                |--------|----------|----------| .. |         |         | ..
                :        :          :          :    :         :         :   


		       -----------------------------------------
		       Figure 4   Reverse Access Table Structure
		       -----------------------------------------

     3.2.3. CREATING A LINK
     ----------------------
       Creating a link allows an object to be accessed by more than one full
     pathname (synonym).  Links may be created between objects or directories
     and are recorded in the reverse access table by a counter and pairs of
     pointers.  Links between objects simply involve naming an object by more
     than one object name.  Links between directories involves creating a link
     directory, specifying a "target" directory, and diverting all received
     messages to the "target" directory.  The diversion is performed by
     intercepting the received messages and passing them on to the linked
     directory.
       Links can be made anywhere in the directory structure.


     3.2.4. MOUNTING AN OBJECT SPACE
     -------------------------------
       A mount is performed in the Directory Sub-system to attach an object
     space to the current directory structure.  The master directory table is
     searched to prevent an attachment from occurring with a link directory that
     might already exist.  If this is attempted, then the attachment is made
     with the target directory of the link.
       A link directory is constructed in the current directory structure at the
     position where the mount should be made.  The root of the object space
     being mounted is located by sending an identify message to DIroot.  If
     DIroot does not exist, then it is created.  The DIlink.set_target function
     is executed to establish the link between DIlink and DIroot.  Now the
     om$set_intercept message is sent to DIlink to divert all messages received
     by DIlink to its target directory, DIroot. 
       Once the link is made, the reverse access table for the attached object
     space is created and initialized by entering DIlink and DIroot into the
     table.  A find is executed starting at DIroot.  Each result of the find is
     added to the reverse access table and the directories are added to the
     master directory table.


     3.2.5. UNMOUNTING AN OBJECT SPACE
     ---------------------------------
       To execute an unmount, the DIlink directory corresponding to the object
     space being unmounted is located by its logical name in the master
     directory table (objname -> osnum + objid).  The osnum is retrieved from
     the master directory table which allows a look-up to be performed in the
     DIR_G_untree table.  This access yields a pointer to the reverse access
     table of the object space being unmounted.
       A find starting at DIroot of this object space is then executed.  All of
     the directories found are sent sleep messages, removed from the master
     directory table, and then removed from the reverse access table.  All the
     other objects found are removed from the reverse access table.
       The interception of messages is stopped and the DIlink directory is
     deleted from the directory structure.  The last step is to delete the
     reverse access table if no further attachments exist (if it is empty).

          ******************************************************************
          *****          3.3.    Files of the DIrectory class          *****
          ******************************************************************

     There are four files found within the DIrectory class structure :

              DIboot.I  |  DIconfig.I  |  DIlib.I  |  DImaci.I

     These files contain methods and functions used within the DIrectory objects
     that are created in the Directory Sub-system.  Following is a brief look at
     each one of these files.


     3.3.1. DIrectori.I
     ------------------

       1. DIcheck_class ----------> tests if an object (grid) is in class_list 

       2. DInew_trailer ----------> sets a new trailer

       3. DIget_trailer ----------> gets the current trailer by name

       4. DIget_trailer_with_id --> gets the current trailer by objid

       5. method untranslate -----> (osnum + objid -> objname) conversion

       6. method i_find ----------> locates objects by name within me and
                                    my subdirectories

       7. method init   ----------> initializes IGRdir, DIstorage, and GRoups

     3.3.2. DIboot.I
     ---------------

       1. DIchar mot --> builds (and hides) the sys group password

       2. DIboot ------> initializes the Directory Sub-system

       3. DIsu --------> changes to sys group, saving the original group

       4. DIback_su ---> returns to original group from sys group

       5. DImount -----> mounts the object space (osnum) with a logical name

       6. DIumount ----> unmounts an object space (osnum) by its logical name

     3.3.3. DIconfig.I
     -----------------

       1. DIget_choice ------> returns the command number of the first command

       2. char DIread_line --> reads a line from a specified file

       3. DIexec_config -----> executes the specified config file

       4. DIload ------------> loads an object space (osnum) with the
                               logical name

       5. DIinit ------------> executes a config file (if specified);
                               otherwise, executes DIboot

     3.3.4. DIlib.I
     --------------

       1. DIfree ---------------> frees the memory allocated during a
                                  memory-based ls operation

       2. DIexpand -------------> suppresses "." and ".." in the given string
 
       3. DIstrcmp -------------> compares name1 and name2

       4. DIstrcpy -------------> copies string2 into string1

       5. DIstrcat -------------> attaches name2 to the end of name1

       6. DIfrtcat -------------> attaches name2 to the front of name1

       7. DIadd_pwd ------------> attaches pwd to the front of string

       8. DIexpanse ------------> transforms a logical directory name into a
                                  full pathname

       9. DIterminator ---------> removes the trailing directory separator
                                  from a string

      10. DIget_level ----------> returns the number of directory separators
                                  in a string

      11. DIparse_dir ----------> parses a directory name into each of its
                                  individual components

      12. DIobjid DIconstruct --> constructs a subclass of DIbtree in osnum
                                  and returns the objid

      13. DIcreate_dir ---------> creates a directory, places it in its parent
                                  directory, adds it to the master directory
				  table, and adds it to the reverse access table

      14. DIadd_grid_line ------> fills out grids and lines if not NULL

      15. DIancestry_valid -----> checks that an object (grid) is an instance
                                  of a subclass of class_id (including class_id)

      16. DIclean --------------> removes the blanks from a string

     3.3.5. DImaci.I
     ---------------

       1. DIcheck_link -----> returns the intercept of a link

       2. DImain -----------> processes regular expressions and can make
			      multiple calls to the appropriate routines
			      to complete the requested operations

       3. DIadd_name -------> adds a name to the Directory Sub-system

       4. DItranslate ------> performs a (objname -> osnum + objid) conversion

       5. DIrename ---------> renames a named object (not a directory)

       6. DImkdir ----------> make a directory

       7. DIrmdir ----------> remove a directory (NOT current or non-empty)

       8. DIrm_name --------> removes a name from a named object

       9. DIuntranslate ----> performs a (osnum + objid -> objname) conversion

      10. DIpwd ------------> returns the current directory, objid, and osnum

      11. DIcd -------------> changes the current directory

      12. DIsplit ----------> splits a full pathname into a directory name
                              and a name within the IGRdir

      13. DIis_regexp ------> checks if string is a regular expression

      14. DIreport_error ---> prints a message corresponding to the error status

      15. DIstart_dump -----> performs a dump but stores the results in a buffer

      16. DIfetch_dump -----> retrieves the results of a start_dump

      17. DIfind -----------> locates all objects whose name matches the
                              regular expression

      18. DIstart_find -----> performs a find but stores the results in a buffer

      19. DIfetch_find -----> retrieves the results of a start_find

      20. DIpass -----------> sends a message (with flags) to all objects that
                              match the regular expression

      21. DImkpath ---------> adds a name to the Directory Sub-system, creating
                              the directories in the pathname that don't exist

      22. DIrm_objid -------> removes an object (by specifying its objid)

      23. DIgive_osnum -----> returns the osnum of a pathname

      24. DIgive_pathname --> returns a pathname to an osnum

      25. DIindex ----------> performs a (directory + index -> objid) conversion

      26. DIunindex --------> performs (directory + objname -> index) conversion
