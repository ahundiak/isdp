/*****************************

	file f2_getobjs.u

*****************************/

/*
 * This file contains the get_objects function.  That function retrieves
 * objects of a certain type for interrogation and display.
 */

/* TGM 5/5/92 modified to use message subsystem */
 
/*
$Log: f2_getobjs.u,v $
Revision 1.1.1.1  2001/12/17 22:39:36  hans
Initial import to CVS

# Revision 340.0  1997/05/27  23:16:52  root
# COMMENT : Initial checkin to 3.4.0 RCS from 3.3.0 src
#
# Revision 330.0  1996/01/11  21:31:12  root
# COMMENT : Initial checkin to 3.3.0 RCS from 3.2.0 src
#
# Revision 320.0  1994/12/12  18:00:01  root
# COMMENT : Initial checkin to 3.2 RCS from 3.1 src
#
# Revision 240.1  1993/03/01  19:41:45  mikel
# COMMENT : remove ms.h or change it to msmacros.h
#
# Revision 240.0  1992/12/07  00:04:19  tim
# COMMENT : Initial checkin to 2.4 RCS
#
# Revision 220.0  1992/08/29  06:40:30  root
# COMMENT : Corresponds to Rel201.2 in 2.0.1 RCS
#
Revision 201.2  1992/07/13  20:42:55  tim
COMMENT : added Log variable
  
*/

#include "ciminimum.h"
#include "cimacros.h"
#include "grgsmacros.h"
#include "dpdef.h"
#include "dp.h"
#include "igr.h"
#include "igrdp.h"
#include "godef.h"
#include "go.h"
#include "exdef.h"
#include "ex.h"
#include "griodef.h"
#include "grio.h"
#include "lcdef.h"
#include "lc.h"
#include "OMerrordef.h"
#include "msdef.h"
#include "msmacros.h"
#include "growner.h"
#include "OMindex.h"
#include "refdef.h"
#include "ref.h"
#include "DIdef.h"
#include "DItypedef.h"
#include "DIglob.h"
#include "DImacros.h"
#include "detaildef.h"
#include "dsdef.h"
#include "ds.h"
#include "dsmacros.h"
#include "OMprimitives.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"

#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"

#include <stdio.h>
/*extern char * free(); */



/*
 * Declare this different drawing sheet structure because PPL doesn't allow
 * the use of the true structure.  However, this declaration allows a 
 * workaround for that problem.
 */
struct my_sheet {
     IGRchar             name[MAX_SHEET_LEN];
     IGRchar 	         standard[MAX_STANDARD_LEN];
     IGRchar             file[MAX_FILE_LEN]; /* Cell Library or Ref File */
     IGRchar             view[MAX_CELL_LEN]; /* Cell Name or Saved View Name */
     unsigned IGRint     dummy;  
     IGRdouble           width;              /* Stored in internal units */
     IGRdouble           height;             /* Stored in internal units */
};

struct GRid 	my_grid;






/***********************************

	function get_objects

***********************************/
int get_objects ( ret_msg, mod_env, fileptr, mode, object_type)
int * 		ret_msg;
struct GRmd_env mod_env;	/* current module info */
FILE		*fileptr;	/* output file pointer */
int 		mode;		/* output mode */
int 		object_type;	/* object type to get */
{
  IGRint	 	om_msg;
  IGRint 		properties;  
  struct GRid		sv_id;
  GRclassid		classid, classid_list[4];
  struct GRlc_locate	attributes;
  OM_S_CLASSLIST	locate_eligible;
  struct GRlc_classes	classinfo;
  struct EX_button	button;
  struct GRid		args[100];

  IGRchar		classname[80];
  int			print_to_screen;
  char                  loc_buff[80];


  extern 		GRgs_locate_action();
  extern 		GRgsinit();
  extern 		printf();
  extern 		sprintf();
/*  extern char *		malloc();   */
  extern		GRgsquery_all();
/*  extern char *		free(); */
  extern 		GRgs_fun();
  extern		_ds_do();



   print_to_screen = mode & SCREEN_OUTPUT;





   /*
    *  Create a graphics set.
    */

   om_msg = gr$gsinit (msg = &ret_msg, flag = 2,
	    senderid = NULL_OBJID, p_objid = &my_grid.objid, 
            osnum = mod_env.md_id.osnum);


   if (om_msg != OM_S_SUCCESS || ret_msg != MSSUCC)
   { 
     ex$message(msgnumb=GR_E_NotAvail,buff=loc_buff);
     if (print_to_screen)
     {
	write("\t!!!   ",loc_buff,"   !!!\n");
     }
     fprintf(fileptr, "\t!!!   %s   !!!\n",loc_buff);
     return;
   }

   /* set up GRid for saveset */
   my_grid.osnum = mod_env.md_id.osnum;



   /*
    *  Start a transition for the graphics set. 
    */
   properties = 0;
   om_msg = ci$send (
            msg = message GRgrset.GSstart_transition 
            (&ret_msg, &mod_env, &properties, NULL, &sv_id),
            targetid = my_grid.objid,
            targetos = my_grid.osnum );


   if (om_msg != OM_S_SUCCESS || ret_msg != MSSUCC)
   {
     ex$message(msgnumb=GR_E_NotAvail,buff=loc_buff);
     if (print_to_screen)
     {
	write("\t!!!   ",loc_buff,"   !!!\n");
     }
     fprintf(fileptr, "\t!!!   %s   !!!\n",loc_buff);
     return;
   }

   /*
    *  Build the attributes structure.
    */

/*
 * for GRdrawview and GRdrawsheets : LC_FLEX_OWNER
 */

/*
 * for GRlbsys and GRcurve : LC_RIGID_COMP | LC_FLEX_COMP
 */


   switch (object_type)
   {
     case 1:  /* GRdrawsheet */
	attributes.owner_action =  LC_FLEX_COMP;

	attributes.properties = IGN_RW_BIT |
                           LC_DP_ONLY |  
                           IGN_MOD_BIT |
                           IGN_PLANAR_BIT;

	strcpy(classname, "GRdrawsheet");
	break;

     case 2:   /* GRowner, for composite graphic items and their components */
	attributes.owner_action =  LC_FLEX_COMP | 
                              LC_RIGID_COMP | 
                              LC_NO_FLEX_OWNER | 
                              LC_NO_RIGID_OWNER; 

	attributes.properties = IGN_RW_BIT |
			   IGN_LC_BIT |
			   IGN_DP_BIT |
                           IGN_MOD_BIT |
                           IGN_PLANAR_BIT;

	strcpy(classname, "GRowner");
	break;


     case 3:   /* GRtext, for text items */
	attributes.owner_action =  LC_FLEX_COMP | 
                              LC_RIGID_COMP | 
                              LC_NO_FLEX_OWNER | 
                              LC_NO_RIGID_OWNER; 

	attributes.properties = IGN_RW_BIT |
                           LC_DP_INVIS |  
                           IGN_MOD_BIT |
                           IGN_PLANAR_BIT;

	strcpy(classname, "GRtext");
	break;


     case 4:   /* GRcurve, for individual graphic items with no owners */
	attributes.owner_action =  LC_NO_FLEX_COMP | 
                              LC_NO_RIGID_COMP | 
                              LC_NO_FLEX_OWNER | 
                              LC_NO_RIGID_OWNER; 

	attributes.properties = IGN_RW_BIT |
			   LC_DP_INVIS |
                           IGN_MOD_BIT |
                           IGN_PLANAR_BIT;

	strcpy(classname, "GRcurve");
	break;


     default:
	break;
   }  /* end switch on object_type */


   /*
    *  Build class list.
    */

   if (object_type == 4)
   {
     om_msg = om$get_classid (classname = "GRcurve",
            p_classid = &(classid_list[0]));
     om_msg = om$get_classid (classname = "EMSsubbs",
            p_classid = &(classid_list[1]));

     locate_eligible.w_count = 2;
     locate_eligible.p_classes = classid_list;
   }
   else
   {
     om_msg = om$get_classid (classname = classname,
            p_classid = &classid);
     locate_eligible.w_count = 1;
     locate_eligible.p_classes = &classid;
   }





   switch (object_type)
   {
     case 1:
	locate_eligible.w_flags = 0;
	break;

     case 2:
     case 3:
     case 4:
	locate_eligible.w_flags = OM_CLST_subclass;
	break;

     default:
	break;
   }

   classinfo.rtree_classes = NULL;
   classinfo.eligible_classes = &locate_eligible;

   button.objid = NULL_OBJID;
   button.osnum = mod_env.md_id.osnum;


   /*
    *  Query all objects looking for appropriate elements.
    */

   args[0] = my_grid;
   args[1] = sv_id;
   om_msg = GRgsquery_all(&ret_msg, &mod_env, &attributes, &classinfo, 
            NULL, &button, GRgs_locate_action, args);

   /*
    *  Send the GSend_transition message.
    */
      
   om_msg = ci$send (msg = message GRgrset.GSend_transition (&ret_msg, 
            NULL),
            targetid = my_grid.objid,
            targetos = my_grid.osnum);

   /* graphic set id is global variable my_grid */
  return (om_msg);
}
