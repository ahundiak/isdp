/*************************

	file f2_pgi.u

*************************/

/*
 * This file contains functions used to print out information about
 * graphic elements.  This information is printed when the user requests
 * info about graphic elements, zero_size elements, and entities on 
 * layers.
 */

/* TGM 5/05/92 modified to use message subsystem */
/* TGM 2/11/92 converted element_type to lower case for comparison purposes */
/* rlw 02/25/92  Removed the print statement when unknown elements are hit */

/*
$Log: f2_pgi.u,v $
Revision 1.1.1.1  2001/12/17 22:39:36  hans
Initial import to CVS

# Revision 340.0  1997/05/27  23:16:57  root
# COMMENT : Initial checkin to 3.4.0 RCS from 3.3.0 src
#
# Revision 330.0  1996/01/11  21:31:18  root
# COMMENT : Initial checkin to 3.3.0 RCS from 3.2.0 src
#
# Revision 320.0  1994/12/12  18:00:05  root
# COMMENT : Initial checkin to 3.2 RCS from 3.1 src
#
# Revision 240.0  1992/12/07  00:04:36  tim
# COMMENT : Initial checkin to 2.4 RCS
#
# Revision 220.0  1992/08/29  06:40:46  root
# COMMENT : Corresponds to Rel201.5 in 2.0.1 RCS
#
Revision 201.5  1992/07/13  20:43:06  tim
COMMENT : added Log variable

*/


#include "f2_type.h"





/***********************************

	function substr1

**********************************/

/*
 * See if s2 is a substring, starting at first character, of s1
 */

int substr1(s1, s2)
char s1[80], s2[80];
{
  int i, j, ret_val, len1, len2, t;





  len1 = strlen(s1);
  len2 = strlen(s2);

  if (len2 > len1)
  {
    return(0);
  }
  for (j = 0; j < len2; j = j+1)
  {
    if (s1[j] != s2[j])
    {
      return(0);
    }
  }

  /* 
   * return true because you got through the loop
   */
  return(1);

}








/*************************************

	function indent

*************************************/

/*
 * This function indents the next line of output x times.
 */

void indent(x)
int x;			/* number of times to indent */
{
int m;


  for (m = 0; m < x; m = m+1)
    write("   ");
}










/******************************************

	function fileindent

*****************************************/

/*
 * This function indents output to the file x times.
 */

void fileindent(x, fileptr)
int x;			/* number of times to indent */
FILE *fileptr;
{
int m;


  for (m = 0; m < x; m = m+1)
    fprintf(fileptr, "   ");
}










/******************************************

	function get_type_num

******************************************/

/* 
 * This function returns the numeric type of the element.  A list of
 * types is in f2_type.h.
 */


int get_type_num(element_type)
char element_type[80];		/* type whose counter to increment */
{
  char lower_element_type[80];	/*  converted tolower element type */
  int  i;

    i=0;
    while (element_type[i] != '\0')  /* convert to lower case */
     {
      lower_element_type[i]=(char)(tolower((int)(element_type[i])));
      i=i+1;
     }
    lower_element_type[i]='\0';

    if (!strcmp(lower_element_type, "line segment"))
      return(LINE_SEGMENT);

    else if (!strcmp(lower_element_type, "circle"))
      return(CIRCLE);

    else if (!strcmp(lower_element_type, "point"))
      return(POINT);

    else if (!strcmp(lower_element_type, "circular arc"))
      return(CIRCULAR_ARC);

    else if (!strcmp(lower_element_type, "ellipse"))
      return(ELLIPSE);

    else if (!strcmp(lower_element_type, "line string"))
      return(LINESTRING);

    else if (!strcmp(lower_element_type, "planar line string"))
      return(PLANAR_LINESTRING);

    else if (!strcmp(lower_element_type, "infinite line"))
      return(INFINITE_LINE);

    else if (!strcmp(lower_element_type, "orthogonal line string"))
      return(ORTH_LINESTRING);

    else if (!strcmp(lower_element_type, "orthogonal polygon"))
      return(ORTH_POLYGON);

    else if (!strcmp(lower_element_type, "elliptical arc"))
      return(ELLIPTICAL_ARC);

    else if (!strcmp(lower_element_type, "polygon"))
      return(POLYGON);

    else if (substr1(lower_element_type, "cell:"))
      return(CELL);

    else if (substr1(lower_element_type, "symbol:"))
      return(SYMBOL);

    else if (!strcmp(lower_element_type, "crosshatching graphics group"))
      return(CROSSHATCH);

    else if (!strcmp(lower_element_type, "graphic group"))
      return(GRAPHIC_GROUP);

    else if (!strcmp(lower_element_type, "solid-cylinder"))
      return(SOLID_CYLINDER);

    else if (!strcmp(lower_element_type, "cylinder"))
      return(CYLINDER);

    else if (!strcmp(lower_element_type, "composite curve"))
      return(COMPOSITE_CURVE);

    else if (!strcmp(lower_element_type, "b-spline curve"))
      return(B_SPLINE_CURVE);

    else if (!strcmp(lower_element_type, "solid-comp. surf. of proj."))
      return(SOLID_COMP_SURFACE);

    else if (!strcmp(lower_element_type, "comp. surf. of proj."))
      return(COMPOSITE_SURFACE);

    else if (!strcmp(lower_element_type, "surface of projection"))
      return(SURFACE_OF_PROJ);

    else if (!strcmp(lower_element_type, "plane"))
      return(PLANE);

    else if (!strcmp(lower_element_type, "solid block"))
      return(SOLID_BLOCK);

    else if (!strcmp(lower_element_type, "solid-sphere"))
      return(SOLID_SPHERE);

    else if (!strcmp(lower_element_type, "sphere"))
      return(SPHERE);

    else if (!strcmp(lower_element_type, "solid-cone"))
      return(SOLID_CONE);

    else if (!strcmp(lower_element_type, "cone"))
      return(CONE);

    else if (!strcmp(lower_element_type, "solid-ellipsoid"))
      return(SOLID_ELLIPSOID);

    else if (!strcmp(lower_element_type, "ellipsoid"))
      return(ELLIPSOID);

    else if (!strcmp(lower_element_type, "solid-torus"))
      return(SOLID_TORUS);

    else if (!strcmp(lower_element_type, "torus"))
      return(TORUS);

    else if (!strcmp(lower_element_type, "fence"))
      return(FENCE);

    else if (!strcmp(lower_element_type, "solid right angle wedge"))
      return(SOLID_RIGHT_ANGLE_WEDGE);

    else if (!strcmp(lower_element_type, "general surface"))
      return(GENERAL_SURFACE);

    else if (!strcmp(lower_element_type, "solid polyhedron"))
      return(SOLID_POLYHEDRON);

    else if (!strcmp(lower_element_type, "solid-elliptical cylinder"))
      return(SOLID_ELLIP_CYLINDER);

    else if (!strcmp(lower_element_type, "elliptical cylinder"))
      return(ELLIPTICAL_CYLINDER);

    else if (!strcmp(lower_element_type, "solid-elliptical cone"))
      return(SOLID_ELLIP_CONE);

    else if (!strcmp(lower_element_type, "elliptical cone"))
      return(ELLIPTICAL_CONE);

    else if (!strcmp(lower_element_type, "solid-general surface"))
      return(SOLID_GEN_SURFACE);

    else if (!strcmp(lower_element_type, "solid-surface of revolution"))
      return(SOLID_SURF_OF_REV);

    else if (!strcmp(lower_element_type, "surface of revolution"))
      return(SURFACE_OF_REVOLUTION);

    else if (!strcmp(lower_element_type, "locally modified solid"))
      return(LOCALLY_MOD_SOLID);

    else if (!strcmp(lower_element_type, "solid-surface of projection"))
      return(SOLID_SURF_OF_PROJ);

    else if (!strcmp(lower_element_type, "globally modified solid"))
      return(GLOBALLY_MOD_SOLID);

    else if (!strcmp(lower_element_type, "general solid"))
      return(GENERAL_SOLID);

    else
    {
/* write("UNKNOWN ELEMENT TYPE:  ", lower_element_type, "\n"); */
      return(-1);
    }
}










/*****************************************

	function zero_size_element

*****************************************/

/*
 * This function checks for zero-sized elements and deletes them if
 * found.
 */

int zero_size_element(cur_id, cur_os, aptr, element_type, mode, fileptr)
GRobj cur_id;			/* id of element */
short cur_os;			/* osnum of element */
struct IGRbsp_curve *aptr;	/* ptr to geometry of element */
char element_type[80];		/* type of element */
int mode;			/* output mode */
FILE *fileptr;			/* output file ptr */
{
  int 		ret_val;
  IGRdouble 	bas_tol, 		/* the basis tolerance */
		dist;			/* distance between poles */
  IGRdouble 	*mypoles;

  int 		print_to_screen;
  int 		verbose_mode;

  int 		ret_msg;
  int 		i,j;

  int 		sizbuf, nret;
  char          loc_buff[80];


  extern 	GRdpb_get();
  extern 	IGRboolean MA2ptdis();




  ret_val = 0;

  print_to_screen = mode & SCREEN_OUTPUT;
  verbose_mode = mode & VERBOSE_OUTPUT;


  /*
   * Process 0-sized elements, e.g., 0-length curves and
   * 0-radius circles, that are not points.
   */

  if (aptr->num_poles > 0 && (strcmp(element_type, "point")))
  {

    sizbuf = sizeof(IGRdouble);
    gr$get_basis_tolerance(msg = &ret_msg, 
				sizbuf = &sizbuf, 
				buffer = &bas_tol, 
				nret = &nret);

    /*
     * If the curve is rational, you need to unweight the poles for
     * for accurate check of the distance between poles with the
     * basis tolerance.
     */

    if (aptr->rational)
    {

      /*
       * copy the poles to a temporary spot
       */
 
      mypoles = (IGRdouble *)malloc(sizeof(IGRdouble) *
			aptr->num_poles * 3);

      /*
       * Unweight the poles.
       */

      for (j = 0; j < aptr->num_poles; j = j+1)
      {
	mypoles[3*j] = aptr->poles[3*j] / aptr->weights[j];
	mypoles[3*j+1] = aptr->poles[3*j+1] / aptr->weights[j];
	mypoles[3*j+2] = aptr->poles[3*j+2] / aptr->weights[j];
      }


      /* 
       * Compare basis tolerance to distance between poles.  Quit this
       * routine if the distance is greater than the basis tolerance, 
       * i.e., two poles are different.
       */

      for (j = 0; j < aptr->num_poles; j = j+1)
      {
	if (j > 0) 	/* if after zero-th pole */
	{
	  MA2ptdis(&ret_msg, 
		mypoles + (3*j),
		mypoles + (3*(j-1)), 
		&dist);
	    
	  if (dist > bas_tol)
	  {
	    return(0);
	  }
	  /*
	   * If at the last iteration of loop here, you have zero-sized
	   * element.  So delete it, increment zero element counter, 
	   * set flag to save this changed file now.
	   */
	  if (j == aptr->num_poles-1) 
	  {
	    num_zero_elements = num_zero_elements+1;

	    ci$send(msg = message Root.delete(0), 
			targetid = cur_id, 
			targetos = cur_os);

            ex$message(msgnumb=GR_I_RemZSzEle,buff=loc_buff,var=element_type);
	    fprintf(fileptr, "\t!!!   %s   !!!\n", 
			loc_buff);

	    if (print_to_screen)
		    printf("\t!!!   %s   !!!\n", 
			loc_buff);

 	    save_flag = 1;

	    free(mypoles);

	    return(1);

	  } /* end of if j is number of poles */
	}  /* end of if j > 0, for testing dist between this and last pt */
      }  /* end of for loop for number of poles */
    }  /* end of if rational */		  



    /*
     * Else if the curve is not rational, simply look at its poles
     * without unweighting them.
     */

    else /* if (!aptr->rational) */
    {
      /* 
       * Compare basis tolerance to distance between poles.  Quit this
       * routine if the distance is greater than the basis tolerance, 
       * i.e., two poles are different.
       */

      for (j = 0; j < aptr->num_poles; j = j+1)
      {
	if (j > 0) 	/* if after zero-th pole */
	{
	  MA2ptdis(&ret_msg, 
			aptr->poles + (3*j),
			aptr->poles + (3*(j-1)), 
			&dist);
	    
	  if (dist > bas_tol)
  	    return(0);

	  /*
	   * If at the last iteration of loop here, you have zero-sized
	   * element.  So delete it, increment zero element counter, 
	   * set flag to save this changed file now.
	   */
	  if (j == aptr->num_poles-1) 
	  {	
	    num_zero_elements = num_zero_elements+1;

	    ci$send(msg = message Root.delete(0), 
			targetid = cur_id, 
			targetos = cur_os);

            ex$message(msgnumb=GR_I_RemZSzEle,buff=loc_buff,var=element_type);
	    fprintf(fileptr, "\n\n\t!!!   %s   !!!\n\n\n", 
			loc_buff);

	    if (print_to_screen)
	      printf("\n\n\t!!!   %s   !!!\n\n\n", 
			loc_buff);

	    save_flag = 1;

 	    return(1);
	  } /* end of if j is number of poles */
	}  /* end of if j > 0, for testing dist between this and last pt */
      }  /* end of for loop for number of poles */
    }  /* end of if rational */		  
  }  /* end of if num_poles > 0 and not a point */

}











/***************************************

	function print_graphic_info

***************************************/

/*
 * This function prints out information on graphic elements.  It is
 * called for processing graphic elements and processing layers (what elements
 * are on what layers).
 */

void print_graphic_info(cur_id, cur_os, mode, fileptr, owner_id, owner_os)
GRobj cur_id;		/* object id of object */
short cur_os;		/* osnum of object */
int mode;		/* output mode */
FILE *fileptr;		/* output file pointer */
GRobj owner_id;		/* object id of owner of this object */
short owner_os;		/* osnum of owner of this object */
{
  int sts;
  IGRchar		name[256];
  struct GRmd_env	cur_mod;

  struct GRid		ret_grid;
  struct IGRbsp_curve	*bsp_ptr;
  struct GRobj_info	element_type;
  IGRlong		ret_msg, om_msg;
  int j;

  int print_to_screen, verbose_mode;
  struct GRsymbology	symb;

  OM_S_CHANSELECT 	notify_chan, toowners;
  int			notify_count;

  struct GRobj_info	owner_type;
  char			classname[80];
  char			loc_buff[80], loc_buff2[80];
  char			display_Yes[20], display_No[20];
  char			display_X[20], display_Y[20], display_Z[20];

  int			type_num, owner_type_num;




  ex$message(msgnumb=GR_I_Yes,buff=display_Yes);
  ex$message(msgnumb=GR_I_No,buff=display_No);
  ex$message(msgnumb=GR_I_X,buff=display_X);
  ex$message(msgnumb=GR_I_Y,buff=display_Y);
  ex$message(msgnumb=GR_I_Z,buff=display_Z);

  print_to_screen = mode & SCREEN_OUTPUT;
  verbose_mode = mode & VERBOSE_OUTPUT;

  /* 
   * Set up channel variable before later loop.  This variable will
   * be used to test if an element has any connections on its notification
   * channel.  If so, that element will not be checked for zero size.
   */

  notify_chan.type = OM_e_name;
  notify_chan.u_sel.name = "GRnotify.notification";

  ci$get_module_info(md_env = &cur_mod);
    

  /*
   * Get information on the element 
   */
  ci$send(msg=message GRgraphics.GRgetobjinfo(&ret_msg, &element_type), 
         targetid = cur_id,
         targetos = cur_os );

  type_num = get_type_num(element_type.type);

  /* 
   * If it's not a graphic element, ignore it.
   */
  if (type_num == -1 || type_num == TEXT)
  {
    goto bottom;
  }


  if (do_graphic_elements || do_layer_graphics)
    ci$send(msg = message GRvg.GRgetname(&ret_msg, name), 
		targetid = cur_id, 
		targetos = cur_os);

  sts = ci$send(msg = message GRvg.GRgenabsg(&ret_msg, 
		&cur_mod.md_env.matrix_type, cur_mod.md_env.matrix, &bsp_ptr), 
		targetid = cur_id, 
		targetos = cur_os);

  sts = ci$send(msg = message GRvg.GRgetsymb(&cur_mod, &symb),
		targetid = cur_id,
		targetos = cur_os);



  /*
   * Check for zero size and subsequent deletion if a proper element.
   * Also check if this function is called by the graphics processing
   * selection and not the layer processing selection (using
   * zero_check).
   */
  if (do_zero_elements && zero_check)
  {
    switch(type_num)
    {
      case TEXT:
      case CELL:
      case CROSSHATCH:
      case GRAPHIC_GROUP:
      case SYMBOL:
      case SOLID_CYLINDER:
      case CYLINDER:
      case COMPOSITE_CURVE:
/*      case B_SPLINE_CURVE:  */
      case SOLID_COMP_SURFACE:
      case COMPOSITE_SURFACE:
      case SURFACE_OF_PROJ:
      case PLANE:  
      case SOLID_BLOCK:
      case SOLID_SPHERE:
      case SPHERE:
      case SOLID_CONE:
      case CONE:
      case SOLID_ELLIPSOID:
      case ELLIPSOID:
      case SOLID_TORUS:
      case TORUS:
      case GLOBALLY_MOD_SOLID:
      case FENCE:
      case PATTERN:
      case SOLID_RIGHT_ANGLE_WEDGE:
      case GENERAL_SURFACE:
      case SOLID_POLYHEDRON:
      case SOLID_ELLIP_CYLINDER:
      case ELLIPTICAL_CYLINDER:
      case SOLID_ELLIP_CONE:
      case ELLIPTICAL_CONE:
      case SOLID_GEN_SURFACE:
      case SOLID_SURF_OF_REV:
      case SURFACE_OF_REVOLUTION:
      case LOCALLY_MOD_SOLID:
      case SOLID_SURF_OF_PROJ:
      case GLOBALLY_MOD_SOLID:
      case GENERAL_SOLID:

/*
 	 * do nothing
	 */
	break;

      default:  /* have a geometric entity */
        /*
         * Check if this object has anyone listening on his notification
         * channel.  If so, you don't want to delete him so don't invoke
         * the zero_size_element routine
         */
        om$get_channel_count(osnum = cur_os, 
			 objid = cur_id, 
			 p_chanselect = &notify_chan, 
			 count = &notify_count);

        if (notify_count == 0)
          if (zero_size_element(cur_id, cur_os, bsp_ptr, element_type.type, 
		mode, fileptr))
            goto bottom;

        break;
    } /* end switch on type_num */
  }

  
  ci$send(msg=message GRgraphics.GRgetobjinfo(&ret_msg, &owner_type), 
		targetid = owner_id, 
		targetos = owner_os );

  /*
   * Don't count symbol header object as a symbol.
   */


  if (type_num == SYMBOL)
  {

    owner_type_num = get_type_num(owner_type.type);

    if ((type_num == owner_type_num) && 
	(!(strcmp(element_type.type, owner_type.type))))
      goto bottom;

  }



  if (!do_layer_graphics)
  {
    if (pat_type)
      fprintf(geptr, "%d %d\n", PATTERN, (int)cur_id);
    else
      fprintf(geptr, "%d %d\n", type_num, (int)cur_id);
  }

  else /* if you are doing layers */
  {
    if (pat_type)
      fprintf(leptr, "%d %d %d\n", symb.level, PATTERN, (int)cur_id);
    else
      fprintf(leptr, "%d %d %d\n", symb.level, type_num, (int)cur_id);
  }






  /*
   * Output the information to the screen if required.
   */
  if ((do_graphic_elements || do_layer_graphics) 
	&& print_to_screen 
	&& verbose_mode)
  {
    indent(indentation);
    writedashes2();
    
    indent(indentation);
    ex$message(msgnumb=GR_I_ElementID,buff=loc_buff);
    write(loc_buff," ...................... ", cur_id, "\n");

    indent(indentation+1);
    ex$message(msgnumb=GR_I_ElementID,buff=loc_buff);
    if (!pat_type)
      write(loc_buff, " ......................... ", element_type.type, "\n");
    else
    {
      ex$message(msgnumb=GR_I_Pattern,buff=loc_buff2);
      write(loc_buff,"......................... ",loc_buff2,"\n");
    }

    indent(indentation+1);
    ex$message(msgnumb=GR_I_Nme,buff=loc_buff2);
    write(loc_buff, " ......................... ");
    if (strcmp(name, ""))
      write(name, "\n");
    else 
     {
      ex$message(msgnumb=GR_E_NoNmeGiven,buff=loc_buff);
      write("!!!   ",loc_buff,"   !!!\n");
     }

    indent(indentation+1);
    ex$message(msgnumb=GR_I_Layers,buff=loc_buff);
    write(loc_buff, " ........................ ", symb.level, "\n");


    /* 
     * need to avoid symbols, cells, and the like here 
     */
    switch(type_num)
    {
      case TEXT:
      case CELL:
      case CROSSHATCH:
      case GRAPHIC_GROUP:
      case SYMBOL:
      case SOLID_CYLINDER:
      case CYLINDER:
      case COMPOSITE_CURVE:
/*      case B_SPLINE_CURVE:  */
      case SOLID_COMP_SURFACE:
      case COMPOSITE_SURFACE:
      case SURFACE_OF_PROJ:
      case PLANE:  
      case SOLID_BLOCK:
      case SOLID_SPHERE:
      case SPHERE:
      case SOLID_CONE:
      case CONE:
      case SOLID_ELLIPSOID:
      case ELLIPSOID:
      case SOLID_TORUS:
      case TORUS:
      case GLOBALLY_MOD_SOLID:
      case FENCE:
      case PATTERN:

      case SOLID_RIGHT_ANGLE_WEDGE:
      case GENERAL_SURFACE:
      case SOLID_POLYHEDRON:
      case SOLID_ELLIP_CYLINDER:
      case ELLIPTICAL_CYLINDER:
      case SOLID_ELLIP_CONE:
      case ELLIPTICAL_CONE:
      case SOLID_GEN_SURFACE:

      case SOLID_SURF_OF_REV:
      case SURFACE_OF_REVOLUTION:
      case LOCALLY_MOD_SOLID:
      case SOLID_SURF_OF_PROJ:
      case GLOBALLY_MOD_SOLID:
      case GENERAL_SOLID:

	/*
	 * do nothing
	 */
	break;

      default:		/* have a geometric element */
        indent(indentation+1);
        ex$message(msgnumb=GR_I_Geometry,buff=loc_buff);
        write(loc_buff,"\n");
  
        indent(indentation+2);
        ex$message(msgnumb=GR_I_Order,buff=loc_buff);
        write(loc_buff," ..................... ", bsp_ptr->order, "\n");

        indent(indentation+2);
        ex$message(msgnumb=GR_I_Periodic,buff=loc_buff);
        write(loc_buff, " .................. ");
        if (bsp_ptr->periodic)
          write(display_Yes,"\n");
        else
  	  write(display_No,"\n");

        indent(indentation+2);
        ex$message(msgnumb=GR_I_NonUniform,buff=loc_buff);
        write(loc_buff,"............... ");
        if (bsp_ptr->non_uniform)
  	  write(display_Yes,"\n");
        else
 	  write(display_No,"\n");

        indent(indentation+2);
        ex$message(msgnumb=GR_I_NumPoles,buff=loc_buff);
        write(loc_buff," ........... ", bsp_ptr->num_poles, "\n");
/*goto bottom; */
        if (bsp_ptr->num_poles > 0)
        {
          indent(indentation+2);
          ex$message(msgnumb=GR_I_Poles,buff=loc_buff);
          write(loc_buff," ..................... ");
          for (j = 0; j < bsp_ptr->num_poles; j = j+1)
  	  {
	    if ( j == 0)
	      printf("%s = %.3lf\n", display_X, *(bsp_ptr->poles + (3*j)));
	    else
	    {
              indent(indentation+2);
	      printf("                            %s = %.3lf\n",  display_X,
		*(bsp_ptr->poles + (3*j)));
	    }

	    indent(indentation+2);
            printf("                            %s = %.3lf\n", display_Y,
		*(bsp_ptr->poles + (3*j+1)));

  	    indent(indentation+2);
	    printf("                            %s = %.3lf\n\n", display_Z,
		*(bsp_ptr->poles + (3*j+2)));
	  }
        }

        indent(indentation+2);
        ex$message(msgnumb=GR_I_NumKnots,buff=loc_buff);
        write(loc_buff," ........... ", bsp_ptr->num_knots, "\n");

        if (bsp_ptr->num_knots > 0)
        {
          indent(indentation+2);
     	  write(loc_buff," ..................... ");
          for (j = 0; j < bsp_ptr->num_knots; j = j+1)
	  {
	    if (j == 0)
	      printf("%.3lf\n", *(bsp_ptr->knots + (j)));
	    else
	    {
              indent(indentation+2);
	      printf("                            %.3lf\n", 
		*(bsp_ptr->knots + (j)));
	    }
  	  }
        }

        indent(indentation+2);
        ex$message(msgnumb=GR_I_Rational,buff=loc_buff);
        write(loc_buff," .................. ");
        if (bsp_ptr->rational)
	  write(display_Yes,"\n");
        else
	  write(display_No,"\n");

        if (bsp_ptr->rational)
        {
          indent(indentation+2);
          ex$message(msgnumb=GR_I_Weights,buff=loc_buff);
	  write(loc_buff," ................... ");
          for (j = 0; j < bsp_ptr->num_poles; j = j+1)
	  {
	    if (j == 0)
              printf("%.3lf\n", bsp_ptr->weights[j]);
	    else
	    {
	      indent(indentation+2);
  	      printf("                            %.3lf\n", 
		    bsp_ptr->weights[j]);		
	    }
	  }
        }

        indent(indentation+2);
        ex$message(msgnumb=GR_I_Planar,buff=loc_buff);
        write(loc_buff," .................... ");
        if (bsp_ptr->planar)
	  write(display_Yes,"\n");
        else
	  write(display_No,"\n");

        indent(indentation+2);
        ex$message(msgnumb=GR_I_PhyClosed,buff=loc_buff);
        write(loc_buff," ......... ");
        if (bsp_ptr->phy_closed)
  	  write(display_Yes,"\n");
        else
	  write(display_No,"\n");

        indent(indentation+2);
        ex$message(msgnumb=GR_I_NumBound,buff=loc_buff);
        write(loc_buff," ...... ", bsp_ptr->num_boundaries, "\n");
        if (bsp_ptr->num_boundaries)
        {
          indent(indentation+2);
          ex$message(msgnumb=GR_I_Boundries,buff=loc_buff);
          write(loc_buff, " ................ ");
	  for (j = 0; j < bsp_ptr->num_boundaries; j = j+1)
	  {
	    if (j == 0)
 	      write(*(bsp_ptr->bdrys + j), "\n");
	    else
	    {
	      indent(indentation+2);
              write("                            ", 
		*(bsp_ptr->bdrys + j), "\n");
	    }
 	  }
        }
        break; /* for default case */

    } /* end switch statement */

  }  /* end if print_to_screen and verbose_mode */






  /*
   * Output the information to the output file, if required.
   */
  if ((do_graphic_elements || do_layer_graphics) && verbose_mode)
  {
    fileindent(indentation, fileptr);
    filedashes2(fileptr);

    fileindent(indentation, fileptr);
    ex$message(msgnumb=GR_I_ElementID,buff=loc_buff);
    fprintf(fileptr, "%s .................... %d\n", loc_buff,
		cur_id);

    fileindent(indentation+1, fileptr);
    if (!strcmp(name, ""))
     {
      ex$message(msgnumb=GR_E_NoNmeGiven,buff=loc_buff);
      strcpy(name, "!!!      ");
      strcat(name,loc_buff);
      strcat(name,"      !!!");
     }
    ex$message(msgnumb=GR_I_Nme,buff=loc_buff);
    fprintf(fileptr, "%s ....................... %s\n", loc_buff,
      name);

    fileindent(indentation+1, fileptr);
    ex$message(msgnumb=GR_I_Type,buff=loc_buff);
    if (!pat_type)
      fprintf(fileptr, "%s ....................... %s\n", loc_buff,
	element_type.type);
    else
    {
      ex$message(msgnumb=GR_I_Pattern,buff=loc_buff2);
      fprintf(fileptr, "%s ....................... %s\n",
             loc_buff, loc_buff2); 
      pat_type = 0;
    }

    fileindent(indentation+1, fileptr);
    ex$message(msgnumb=GR_I_Layer,buff=loc_buff);
    fprintf(fileptr, "%s ...................... %d\n", loc_buff, symb.level);


    /* 
     * need to avoid symbols, cells, and the like here 
     */

/*goto bottom; */
    switch(type_num)
    {
      case TEXT:
      case CELL:
      case CROSSHATCH:
      case GRAPHIC_GROUP:
      case SYMBOL:
      case SOLID_CYLINDER:
      case CYLINDER:
      case COMPOSITE_CURVE:
/*      case B_SPLINE_CURVE: */
      case SOLID_COMP_SURFACE:
      case COMPOSITE_SURFACE:
      case SURFACE_OF_PROJ:
      case PLANE:  
      case SOLID_BLOCK:
      case SOLID_SPHERE:
      case SPHERE:
      case SOLID_CONE:
      case CONE:
      case SOLID_ELLIPSOID:
      case ELLIPSOID:
      case SOLID_TORUS:
      case TORUS:
      case GLOBALLY_MOD_SOLID:
      case FENCE:
      case PATTERN:

      case SOLID_RIGHT_ANGLE_WEDGE:
      case GENERAL_SURFACE:
      case SOLID_POLYHEDRON:
      case SOLID_ELLIP_CYLINDER:
      case ELLIPTICAL_CYLINDER:
      case SOLID_ELLIP_CONE:
      case ELLIPTICAL_CONE:
      case SOLID_GEN_SURFACE:

      case SOLID_SURF_OF_REV:
      case SURFACE_OF_REVOLUTION:
      case LOCALLY_MOD_SOLID:
      case SOLID_SURF_OF_PROJ:
      case GLOBALLY_MOD_SOLID:
      case GENERAL_SOLID:

	/*
 	 * do nothing
	 */
	break;

      default:
        fileindent(indentation+1, fileptr);
        ex$message(msgnumb=GR_I_Geometry,buff=loc_buff);
        fprintf(fileptr, "%s\n",loc_buff);

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_Order,buff=loc_buff);
        fprintf(fileptr, "%s ................... %d\n", 
		loc_buff, bsp_ptr->order);

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_Periodic,buff=loc_buff);
        fprintf(fileptr, "%s ................ ",loc_buff); 
        if (bsp_ptr->periodic)
	  fprintf(fileptr, "%s\n",display_Yes);
        else
       	  fprintf(fileptr, "%s\n",display_No);

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_NonUniform,buff=loc_buff);
        fprintf(fileptr, "%s ............. ",loc_buff);
        if (bsp_ptr->non_uniform)
	  fprintf(fileptr, "%s\n",display_Yes);
        else
       	  fprintf(fileptr, "%s\n",display_No);

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_NumPoles,buff=loc_buff);
        fprintf(fileptr, "%s ......... %d\n", loc_buff,
	  bsp_ptr->num_poles);

        if (bsp_ptr->num_poles > 0)
        {
          fileindent(indentation+2, fileptr);
          ex$message(msgnumb=GR_I_Poles,buff=loc_buff);
          fprintf(fileptr, "%s ................... ",loc_buff);
          for (j = 0; j < bsp_ptr->num_poles; j = j+1)
          {
            if (j == 0)
            {
              fprintf(fileptr, "x = %.3lf\n", 
		*(bsp_ptr->poles + (3*j)));
            }
            else
            {
              fileindent(indentation+2, fileptr);
              fprintf(fileptr, "                          %s = %.3lf\n", 
	        display_X, *(bsp_ptr->poles + (3*j)));
	    }
 
            fileindent(indentation+2, fileptr);
            fprintf(fileptr, "                          %s = %.3lf\n", 
	      display_Y, *(bsp_ptr->poles + (3*j+1)));

            fileindent(indentation+2, fileptr);
            fprintf(fileptr, "                          %s = %.3lf\n", 
	      display_Z, *(bsp_ptr->poles + (3*j+2)));
      
          }  /* end for number of poles */
        }  /* end if num poles > 0 */

 
        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_NumKnots,buff=loc_buff);
        fprintf(fileptr, "%s ......... %d\n",  loc_buff, 
	  bsp_ptr->num_knots);

        if (bsp_ptr->num_knots > 0)
        {
  	  fileindent(indentation+2, fileptr);
          ex$message(msgnumb=GR_I_Knots,buff=loc_buff);
          fprintf(fileptr, "%s ................... ", loc_buff);
          for (j = 0; j < bsp_ptr->num_knots; j = j+1)
          {
            if (j == 0)
              fprintf(fileptr, "%.3lf\n", bsp_ptr->knots[j]);
	    else
       	    {
    	      fileindent(indentation+2, fileptr);
	      fprintf(fileptr, "                          %.3lf\n", 
	        bsp_ptr->knots[j]);
	    }
          }
        }

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_Rational,buff=loc_buff);
        fprintf(fileptr, "%s ................ ",loc_buff);
        if (bsp_ptr->rational)
	  fprintf(fileptr, "%s\n",display_Yes);
        else
          fprintf(fileptr, "%s\n",display_No);


        if (bsp_ptr->rational)
        {
          fileindent(indentation+2, fileptr);
          ex$message(msgnumb=GR_I_Weights,buff=loc_buff);
          fprintf(fileptr, "%s ................. ",loc_buff);
          for (j = 0; j < bsp_ptr->num_poles; j = j+1)
          {
            if (j == 0)
              fprintf(fileptr, "%.3lf\n", bsp_ptr->weights[j]);
            else
 	    {
	      fileindent(indentation+2, fileptr);
              fprintf(fileptr, "                          %.3lf\n", 
	        bsp_ptr->weights[j]);
	    }
          }
        }

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_Planar,buff=loc_buff);
        fprintf(fileptr, "%s .................. ",loc_buff);
        if (bsp_ptr->planar)
	  fprintf(fileptr, "%s\n",display_Yes);
        else
          fprintf(fileptr, "%s\n",display_No);

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_PhyClosed,buff=loc_buff);
        fprintf(fileptr, "%s ....... ",loc_buff);
        if (bsp_ptr->phy_closed)
	  fprintf(fileptr, "%s\n",display_Yes);
        else
       	  fprintf(fileptr, "%s\n",display_No);

        fileindent(indentation+2, fileptr);
        ex$message(msgnumb=GR_I_NumBound,buff=loc_buff);
        fprintf(fileptr, "%s .... %d\n",loc_buff,
	  bsp_ptr->num_boundaries);


        if (bsp_ptr->num_boundaries)
        {
          fileindent(indentation+2, fileptr);
          ex$message(msgnumb=GR_I_Boundries,buff=loc_buff);
          fprintf(fileptr, "%s ............. ",loc_buff);
          for (j = 0; j < bsp_ptr->num_boundaries; j = j+1)
          {
            if (j == 0)
              fprintf(fileptr, "%.3lf\n", *(bsp_ptr->bdrys + j));
            else
	    {
	      fileindent(indentation+2, fileptr);
              fprintf(fileptr, "                      %.3lf\n", 
	        *(bsp_ptr->bdrys + j));
	    }
          }
        }

	break; /* end default case */
    } /* end switch statement */	

  }  /* end if verbose mode */



/* 
 * The label "bottom" is a place holder to go to if the element is 
 * zero-sized.  No need to print out information on deleted items.
 */
bottom:
/* if not verbose mode and you just did a pattern */
  if (pat_type == 1)  
   {
    pat_type = 0;
   }
}



/*********************************************

	function examine_channel_objects

**********************************************/

/* 
 * This function checks if the current object has a toowners channel.
 * If it does, then the object information is not printed out.  If the
 * object does not have a toowners channel, its information is printed 
 * out.  Then the function will look at that object's to_components
 * channel and print its components recursively.
 */
examine_channel_objects(cur_id, cur_os, mode, fileptr)
GRobj cur_id;		/* object id of object */
short cur_os;  		/* osnum of object */
int mode;		/* output mode */
FILE *fileptr;  	/* output file pointer */
{

  IGRlong		om_msg;
  IGRlong		ret_msg;
  IGRint                i, j, count, array_size;
  struct GRmd_env       mod_env;
  struct GRid           ret_grid, ref_id;
  struct GRobj_env *    objects;
  OM_S_CHANSELECT       tocomp, toowners, tosym;

  struct GRidplus	*tempst;
  struct indexptr	*tempind;
  int 			symcount, sts;
  
  /* 
   * set up variable to check the object's to_components channel
   */
  tocomp.type = OM_e_name;
  tocomp.u_sel.name = "GRcmpowner.to_components";

  /*
   * Don't check for zero size elements here.  You don't want to delete
   * zero-sized owners that may have constituents under them and you 
   * don't want to delete zero-sized components that are used by their
   * owners.
   */
  zero_check = 0;




  tosym.type = OM_e_name;
  tosym.u_sel.name = "GRpa.to_sym";
  sts = om$get_channel_count(osnum = cur_os, 
				objid = cur_id, 
				p_chanselect = &tosym, 
				count = &symcount);
  if (sts == OM_S_SUCCESS)
  {
    is_pattern = indentation;
    pat_type = 1;
  }

  /* 
   * print out info
   */
/*
  fprintf(fileptr, "is_pattern is %d\n", is_pattern);
*/
  if ((is_pattern != 0) && (rec_stack != NULL))
    print_graphic_info(cur_id, cur_os, mode, fileptr, 
		rec_stack->objid, rec_stack->osnum);
	/* 0, 0); */
  else if (rec_stack)
  {

    print_graphic_info(cur_id, cur_os, mode, fileptr, 
		rec_stack->objid, rec_stack->osnum);
  }
  else
    print_graphic_info(cur_id, cur_os, mode, fileptr, 0, 0);


  /*
   * tempst is a local pointer to a structure of type GRidplus (GRid's with
   * a next pointer).  This is a in-program mechanism to simulate a 
   * recursion stack of these structures.
   *
   * tempst's node is set to current id and osnum and attached to top
   * of recursion stack pointed to by global pointer variable called
   * rec_stack.
   */
  tempst = (struct GRidplus *)malloc(sizeof(struct GRidplus));

  tempst->objid = cur_id;
  tempst->osnum = cur_os;
  tempst->next = rec_stack;
  rec_stack = tempst;



  /*
   * Keep track of the current index, using an in-program simulation
   * of a recursion stack.  The current index is put on top of the stack
   * (pointed to by indexlist) using temporary variable tempind;
   */
  tempind = (struct indexptr *)malloc(sizeof(struct indexptr));
  tempind->cur_index = 0;
  tempind->next = indexlist;
  indexlist = tempind;

  /* 
   * Set up the level of indentation for output purposes.
   */
  indentation = indentation + 1;


  for ( j=0; j<OM_K_MAXINT; j=j+1)
  {

    /*
     * Get component at index j.
     */
    om_msg = om$get_objid_at_index ( osnum = cur_os,
                                       objid = cur_id,
                                       p_chanselect = &tocomp,
                                       index = j,
                                       objidaddr = &ret_grid.objid,
                                       osnumaddr = &ret_grid.osnum );

    /*
     * If no component, break out of loop.
     */
    if ( !(om_msg & 1) ) 
    {
      break;
    }

    /* 
     * Otherwise you have a valid component you need to check.
     * Make a recursive call.
     */
    indexlist->cur_index = j;
    examine_channel_objects(ret_grid.objid, ret_grid.osnum, mode, fileptr);

  } /* end j-for loop for all objects on the tocomp channel */



  /*
   * Reset indentation level and recursion stacks back before exiting 
   * to calling level of recursion.
   */
  indentation = indentation - 1;

  if (rec_stack)        
  {
    tempst = rec_stack;
    rec_stack = rec_stack->next;
    free(tempst);

    if (rec_stack)
    {
      cur_id = rec_stack->objid;
      cur_os = rec_stack->osnum;
    }
  }
  else
  {
    write("recursion stack screwed up\n");
    return;
  }

  if (indexlist)
  {
    tempind = indexlist;
    indexlist = indexlist->next;
    free(tempind);
   
    if (indexlist)
    {
      j = indexlist->cur_index;
    }
  }


  if (is_pattern == indentation)
    is_pattern = 0;
}
