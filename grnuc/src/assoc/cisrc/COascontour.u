// contour with composite jla 26 may 88

#include "cieveryone.h"
#include "cimacros.h"
#include "asmacros.h"
#include "codef.h"
#include "ASmessages.h"
#include "grmsg.h"
#include "msmacros.h"
#include "msdef.h"
#include "nddef.h"
#include "dpmacros.h"
#include "bserr.h"
#include "dpdef.h"
#include "dp.h"
#include "OMmacros.h"
#include "bsparameters.h"


#define ND_NG_ROOT          1
#define ND_NG_IN_BUF        4
#define LOCATE 1000

double  p0[3], p1[3], p2[3], old_p2[3];
OM_S_OBJID   OBJ_INT[2],OBJ_BSP[3],OBJ_COMP[500],
	COMP_CV,FIRST,FIRST_INT,INT,PREV_INT,TARGET,INDPT,BSP;


int 			num_comp,i_comp,finish,nb_roots,k, nIndex;
int 			rt,msg,point_req;
int 			sts;
short  			set,display_props;
struct GRsymbology      symb;
struct GRid 		roots[3];
struct GRprops 		props;
char 			sup_state;
GRclassid 		classid;


extern int GRfindcontext();
extern int MSmessage(), UI_prompt(), UI_status();
extern ASmake_source(), ASget_active_symb(), ASany_give_struct();
extern BSmdistcvcv(), BScvcvint(), BSalloccv(), BScv_copy(), free(), DPsetinqgragad();
extern v_sub(),v_add(),v_scale();
extern double v_dot();
extern int DPerase_hilite();

/* global data used by the different functions */

OM_S_CLASSLIST		clist;         /* eligible classes for locate         */
GRclassid 		curve_classid; /* idem			              */
struct GRmd_env 	c_md_env;      /* md env used to construct element    */


/*------------------------------------------------------------------------------
   This function creates a view vector knowing a point ant the window id
------------------------------------------------------------------------------*/

view_vect(window,data,p1,p2)
struct GRid *window;
double *data,*p1,*p2;
{
 int status,msg,which_error;
 double view_rot[60];
 double origin[60];
 double vol[60];
 double tmp[3];
 double cc;
 struct var_list var_list[4];
 int bt;

 var_list[0].var=VIEW_ORIGIN;
 var_list[0].var_ptr = (IGRchar *) origin; 
 var_list[0].num_bytes =  3 *sizeof(double); 
 var_list[0].bytes_returned = &bt ; 
  

 var_list[1].var=VIEW_ROTATION;
 var_list[1].var_ptr =  (IGRchar *) view_rot;
 var_list[1].num_bytes = 16 *sizeof(double); 
 var_list[1].bytes_returned = &bt ; 

 var_list[2].var=VW_VOLUME;
 var_list[2].var_ptr = (IGRchar *) vol;
 var_list[2].num_bytes =  6 *sizeof(double); 
 var_list[2].bytes_returned = &bt ; 

 var_list[3].var=END_PARAM;
 var_list[3].bytes_returned = &bt ; 

 dp$inq_set_gragad(msg = &msg,
		   which_error = &which_error,
		   osnum = window->osnum,
		   gragad_objid = window->objid,
		   var_list = var_list);

 v_sub(data,origin,tmp);
 cc = v_dot(tmp,view_rot+8);
 v_scale(view_rot+8,vol[2]-cc,tmp);
 v_add(data,tmp,p1);
 v_scale(view_rot+8,vol[5]-cc,tmp);
 v_add(data,tmp,p2);

 }

/*-----------------------------------------------------------------------------
   This function creates an index point at the end point of curve
   on the same side of data from inter
   The function is used for the first and last segment of open composite
------------------------------------------------------------------------------*/

index_open(curve,inter,data,window,index)
  OM_S_OBJID curve,inter,*index;
  struct GRid *window;
  double data[3];
 {
  struct ret_struct intp;
  double data_u,intp_u,index_bar[4];
  struct IGRbsp_curve *ptr;
  int rc,rc1,msg,status;
  double data_pj[3], length;
  struct GRid go;
  double matrix[16];
  short mat_type;
  double view_pt[6],view_knots[6];
  struct IGRbsp_curve view;
  double *par1,*par2,*pt1,*pt2,dist,tmp[3];
  int num;

  /* get geometry of curve and intersection point */

     status = ci$send(msg = message NDnode.NDgive_structure(&msg,&intp,
							    &c_md_env ),
                     targetid = inter);
     if(!(status&1)) return(OM_W_ABORT);

     status = ci$send(msg = message NDnode.ASreturn_go(&go,&mat_type,matrix),
                      targetid = curve);
     if(!(status&1)) return(OM_W_ABORT);

     status = ci$send(msg = message GRvg.GRgenabsg(&msg, &mat_type, matrix,
						   &ptr),
                      targetid = go.objid,
		      targetos = go.osnum);
     if(!(status&1)) return(OM_W_ABORT);

  
  /* get view vector and project intersection point and data point on curve */ 

     if(!ptr->phy_closed)
       {
          view_vect(window,data,view_pt,view_pt+3);
	  view.num_poles = 2;
	  view.order = 2;
	  view.periodic = 0;
	  view.non_uniform = 0;
	  view.poles = view_pt;
	  view.num_knots = 4;
	  view.knots = view_knots;
	  view_knots[0] = 0;
	  view_knots[1] = 0;
	  view_knots[2] = 1;
	  view_knots[3] = 1;
	  
       BSmdistcvcv(ptr, &view, &num, &par1, &par2, &pt1, &pt2, &dist, &rc);
	  if(rc == BSSUCC && num >0)
	   {data_u = par1[0];
            free(par1); free(par2); free(pt1); free(pt2);
           }
       
       v_sub(intp.var.point_st.pt,data,tmp);
       v_add(view_pt,tmp,view_pt);
       v_add(view_pt+3,tmp,view_pt+3);
       BSmdistcvcv(ptr, &view, &num, &par1, &par2, &pt1, &pt2, &dist, &rc);
	  if(rc == BSSUCC && num >0)
	   {intp_u = par1[0];
            free(par1); free(par2); free(pt1); free(pt2);
           }

        /* create the index point */
        if(data_u < intp_u) index_bar[0] = 0;
        else                index_bar[0] = 1;
       }
     else
       {
	index_bar[0] = 1.e+12;
        index_bar[1] = intp.var.point_st.pt[0];
        index_bar[2] = intp.var.point_st.pt[1];
        index_bar[3] = intp.var.point_st.pt[2];
       }

    *index = NULL_OBJID;
    send ASindexpt.place(1,&curve,index_bar) to *index;
 }

/*----------------------------------------------------------------------------
  Update my symbology in construction list
---------------------------------------------------------------------------- */

set_my_symb(locatable,displayable,incr_weight)
int locatable,displayable,incr_weight;
{
 short active_level;
 struct IGRdisplay active_display;

 ASget_active_symb(&active_level,&active_display);
 cnst_list.locatable = locatable;
 cnst_list.displayable = displayable;
 cnst_list.level = active_level;
 cnst_list.color = active_display.color;
 cnst_list.weight = active_display.weight + incr_weight;
 cnst_list.style = active_display.style;

 set_symb();
}

/*-----------------------------------------------------------------------------
   display an element
----------------------------------------------------------------------------- */

display_elem(obj,md_id,disp_mode,incr_weight) 
OM_S_OBJID obj;
struct GRid md_id;
int disp_mode;
int incr_weight;
{
double matrix[16];
IGRshort mat_type;
int status,stat_symb,msg;
struct GRid go;
enum GRdpmode dp_mode;
struct GRsymbology go_symb;
char unsigned weight;

dp_mode = disp_mode;
status = ci$send(msg = message NDnode.ASreturn_go(&go,&mat_type,matrix),
		 targetid = obj);
if(!(status&1)) return;
if(incr_weight != 0)
 {
  stat_symb = ci$send(msg = message GRvg.GRgetsymb(&msg,&go_symb),
		      targetid = go.objid,
		      targetos = go.osnum);
  if(stat_symb&1)
   {
    weight = go_symb.display_attr.weight+incr_weight;
    status = ci$send(msg = message GRvg.GRchgweight(&msg,&weight),
		      targetid = go.objid,
		      targetos = go.osnum);
   }

 }

#ifdef DEBUG
printf ("\nDisplay sent to %d, display mode = %d",go.objid,dp_mode);
#endif
status = ci$send(msg = message GRgraphics.GRdisplay(&msg,&mat_type,matrix,
					&dp_mode,&md_id),
		 targetid = go.objid,
		 targetos = go.osnum);

if(incr_weight != 0 && stat_symb&1)
 {
  weight = go_symb.display_attr.weight;
  status = ci$send(msg = message GRvg.GRchgweight(&msg,&weight),
		   targetid = go.objid,
		   targetos = go.osnum);
 }

if(!(status&1)) return;
}


/*-----------------------------------------------------------------------------
   Locate an element. Control its geometry and construct if necessary
   a source element.
----------------------------------------------------------------------------- */

locate_element (loc_num,
                acc_num,
                last_component,
                response,
                p_loc,
                p_acc,
                p_window,
                source)
int loc_num, acc_num;   /* prompt number for locate and accept		     */
OM_S_OBJID last_component;
int *response;          /* response type 				     */
double *p_loc,*p_acc;   /* locate and accept point			     */
struct GRid *p_window;  /* Grid of the window where the element has been     */
			/* located					     */
OM_S_OBJID *source;
{

 char loc_prompt[MAX_PROMPT_SIZE],
      acc_prompt[MAX_PROMPT_SIZE];
 struct GRid context_id,go,src_id;
 struct ret_struct rst;
 struct GRmd_env md_env;
 int rt,status;
 
 ex$message(buff =  loc_prompt, msgnumb = loc_num);
 ex$message(buff =  acc_prompt, msgnumb = acc_num);

 while (1)
 {
   /* get the element */
   rt = ci$locate(response = response,
 		obj = &go.objid, osnum = &go.osnum,
                owner_action = LC_RIGID_COMP | LC_RIGID_OWNER |
                               LC_FLEX_COMP  | LC_REF_OBJECTS,
		eligible_classes = &clist,
  		prompt=loc_prompt,
  		acc_prompt=acc_prompt,
		data_point = p_loc,
		accept_point = p_acc,
		window_id = &p_window->objid,
		window_osnum = &p_window->osnum,
		md_env = &md_env);

   /*
      If something located control its type
      If the type is correct, construct a source element and return
   */

   if(!(rt&1)) break; 
   else
   {
     status = as$any_give_structure(go_grid = go,
                                    inst = &rst,
                                    mod_env = &md_env);
     if(rst.type&point_generic)
     {
       ex$message ( msgnumb = AS_S_IllEleLoc );
       /*UI_status("Illegal element located");*/
       continue;
     }
     else
     {
        context_id.objid = NULL_OBJID;
        sts= GRfindcontext(&msg,&md_env.md_env.matrix_type,md_env.md_env.matrix,
                      &md_env.md_id.osnum,&context_id);
        if(sts != OM_S_SUCCESS || msg != MSSUCC ) context_id.objid = NULL_OBJID;

        
        as$make_source( go_grid      = go,
                        context_grid = context_id,
                        as_os        = c_md_env.md_id.osnum,
                        as_grid      = &src_id);
	if(src_id.objid == last_component)
        {
          ex$message( msgnumb = AS_S_LcElLstElCon );
          /* UI_status("Located element is the last element of the contour"); */
          continue;
        }
        *source = src_id.objid;
	break;
     }
   }
 }
 return (rt);
}


main()
{
 int dp_mode,i;
 int response,previous_response;
 struct GRevent event;
 double index_bar;
 struct GRid window;

 /* this used to force last */
 int first_response, force_last;
 double first_p0[3],first_p2[3];
 struct GRid first_window;
 OM_S_OBJID FIRST_OBJ_INT;
 OM_S_OBJID FIRST_LAST;
 /* end of this used to force last */
 
 ex$message(msgnumb = AC_M_COMP0);
 sts = om$get_classid(classname = "AScompcurve",
                      p_classid = &classid);


/* class filter for locate */

 sts = om$get_classid(classname = "GRcurve",
                      p_classid = &curve_classid);
 clist.w_count=1;
 clist.w_flags=OM_CLST_subclass;
 clist.p_classes=&curve_classid;

/* node state for support element */

 sup_state = ND_SUP_ONLY;

 while(1)
 {
   
  // Initialization 

  num_comp = 0;
  point_req = 0;
  
  dp$erase_hilite (msg = &msg);


  /*
     Get the first component
  */

  do
   {
    rt = locate_element (
	  GR_P_Id1stEle,
	  AS_P_COMP3,
	  NULL_OBJID,
	  &response,
	  p2,
	  p0,
	  &window,
	  &OBJ_INT[0]);
   first_response = response;
   for (i=0; i<3; i = i + 1) {
     first_p0[i] = p0[i];
     first_p2[i] = p2[i];
     };
   first_window.objid = window.objid;
   first_window.osnum = window.osnum;
   FIRST_OBJ_INT = OBJ_INT[0];
   } while (!rt);

#ifdef DEBUG
  printf ("LAST after locate_element in line %d is %d",__LINE__,LAST);
#endif
  FIRST = OBJ_INT[0];
  OBJ_BSP[0] = OBJ_INT[0];
  set_my_symb(0,0,0);
  index_bar = 0;
  send ASindexpt.place(1,OBJ_INT,&index_bar) to OBJ_BSP[1];
  ci$send(msg = message NDnode.NDchg_state( sup_state,sup_state ),
          targetid =  OBJ_BSP[1]);

  index_bar = 1;
  send ASindexpt.place(1,OBJ_INT,&index_bar) to OBJ_BSP[2];
  ci$send(msg = message NDnode.NDchg_state( sup_state,sup_state ),
          targetid =  OBJ_BSP[2]);
  set_my_symb(0,1,0/*3*/);
  send ASextbsp.place(3,OBJ_BSP,old_p2) to BSP;
  dp_mode = GRhd/*GRbd*/;
  display_elem(BSP,c_md_env.md_id,dp_mode,0);
  OBJ_COMP[0] = BSP;
  num_comp = 1;


  // Loop to get following components
  /** The finish flag should be initialized to zero otherwise when we want
      to place more than one contour it will fail to select more than one
      component  -- TR# 119308728 -- Satya ***/

  finish = 0; 
  do
  {
   // get data point or locate element 
   previous_response = response;
   if(point_req == 0)
    {
       rt = locate_element
	 (AS_P_COMP6,
	  AS_P_COMP5,
	  OBJ_INT[0],
	  &response,
	  p1,
	  p2,
	  &window,
	  &OBJ_INT[1]);
     if(response == DATA) response = LOCATE;
    }
   else
    {
     dp_mode = GRhd;
     display_elem(OBJ_BSP[0],c_md_env.md_id,dp_mode,0/*3*/);
     rt = ci$getevent(event = &event,
		 response = &response,
		 msgnum = AS_P_COMP5);
     dp_mode = GRhd/*GRhe*/;
     display_elem(OBJ_BSP[0],c_md_env.md_id,dp_mode,0/*3*/);
     point_req = 0;
     if(response == DATA){ p2[0]=  event.event.button.x;
                           p2[1]=  event.event.button.y;
                           p2[2]=  event.event.button.z;
			   window.objid = event.event.button.objid;
			   window.osnum = event.event.button.osnum;
                         }
    }
  
  switch (response)
   {
    case D_RESET :

	/* suppress last component */

	if(previous_response != D_RESET)
         {
	  num_comp = num_comp -1;
	  ci$send(msg = message NDnode.NDget_objects(ND_NG_ROOT,roots,3,
						(char *)NULL, 0,2,&nb_roots) ,
		  targetid = OBJ_COMP[num_comp]);
          dp_mode = GRhe/*GRbe*/;
          display_elem(OBJ_COMP[num_comp],c_md_env.md_id,dp_mode,0);
          dp_mode = GRhd/*GRbd*/;
          display_elem(roots[0].objid,c_md_env.md_id,dp_mode,0);
	  ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                  targetid =  OBJ_COMP[num_comp]);
         }

	/* Reinitialize last state of the command */

	if(num_comp == 0) 
	 {
	  /* command restart */
	  ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                     targetid =  roots[1].objid);
	  ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                     targetid =  roots[2].objid);
	  finish = 1;
 	  break;
	 }
	
        /* Modify last extracted curve */
	     
	num_comp = num_comp -1;
	ci$send(msg = message NDnode.NDget_objects(ND_NG_ROOT,roots,3,
						(char *)NULL, 0,2,&nb_roots) ,
		targetid = OBJ_COMP[num_comp]);
        dp_mode = GRhe/*GRbe*/;
        display_elem(OBJ_COMP[num_comp],c_md_env.md_id,dp_mode,0);
        dp_mode = GRhd/*GRbd*/;
        display_elem(roots[0].objid,c_md_env.md_id,dp_mode,0);
	ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                targetid =  OBJ_COMP[num_comp]);

	if(INT == roots[2].objid) PREV_INT = roots[1].objid;
			     else   PREV_INT = roots[2].objid;
  	OBJ_BSP[0] = roots[0].objid;
  	OBJ_BSP[1] = PREV_INT;

	ci$send(msg = message NDnode.NDget_objects(ND_NG_ROOT,roots,0,
						(char *)roots,0,1,&nb_roots),
                targetid =  INT);
  	OBJ_INT[0]   = roots[0].objid;

	/* delete last intersection */
	ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                targetid =  INT);
	INT  = PREV_INT;
	point_req = 1;
 
 	break;

    case RESET :
	    /* end of an open contour */
            finish = 1;            
 	    break;

    case LOCATE :

          // create a new intersection point

          set_my_symb(0,0,0);
          send ASintpt.place(2,OBJ_INT,p1) to INT;

          // set the state to delete the point if the contour is deleted
          ci$send(msg = message NDnode.NDchg_state( sup_state,sup_state ),
                     targetid =  INT);

          /*
 	     For the first component store information to know when the 
             contour is closed and place an index point at an end point of
             the component
          */
          if(num_comp==1)
            {
             FIRST = OBJ_INT[0];
	     FIRST_INT = INT;

             set_my_symb(0,0,0);
             index_open(OBJ_INT[0],INT,p0,&window,&INDPT);

             // set the state to delete the point if the contour is deleted
             ci$send(msg = message NDnode.NDchg_state( sup_state,sup_state ),
                     targetid =  INDPT);

             OBJ_BSP[0] = OBJ_INT[0];
             OBJ_BSP[1] = INDPT;
             OBJ_BSP[2] = INT;
            }
          else
            {
             OBJ_BSP[2] = INT;
            }
       
          // replace previous component extended to end point by component
          // extended to intersection point.

          dp_mode = GRhd/*GRbe*/;
          display_elem(OBJ_COMP[num_comp-1],c_md_env.md_id,dp_mode,0);
          dp_mode = GRhd/*GRbd*/;
          display_elem(OBJ_BSP[0],c_md_env.md_id,dp_mode,0);
          ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                  targetid =  OBJ_COMP[num_comp-1]);

	  dp$erase_hilite (msg = &msg);

          set_my_symb(0,1,0/*3*/);
          send ASextbsp.place(3,OBJ_BSP,old_p2) to BSP;
          dp_mode = GRhd/*GRbd*/;
          display_elem(BSP,c_md_env.md_id,dp_mode,0);
	  OBJ_COMP[num_comp-1] = BSP;

          if (num_comp >= 2)
          {
#ifdef DEBUG
	    printf ( "It is time to half-hilite...\n" );            
#endif
            /*
             * Half-hilite the elements located so far
             */
            dp_mode = GRhhd;
            for (nIndex = 0; nIndex < num_comp; nIndex = nIndex + 1)
            {
              display_elem ( OBJ_COMP [nIndex], c_md_env.md_id, dp_mode, 0 );
            }
          }
 

          if (OBJ_INT[1] == FIRST)
            {
             /* delete previous first segment and replace by new component */
             dp_mode = GRhe/*GRbe*/;
             display_elem(OBJ_COMP[0],c_md_env.md_id,dp_mode,0);
             ci$send(msg = message  NDnode.NDdelete(&c_md_env),
                     targetid =  OBJ_COMP[0]);
             set_my_symb(0,1,0/*3*/);
             OBJ_BSP[0]   = OBJ_INT[1];
             OBJ_BSP[1]   = INT;
             OBJ_BSP[2]   = FIRST_INT;
             send ASextbsp.place(3,OBJ_BSP,p2) to BSP;
             dp_mode = GRhd/*GRbd*/;
             display_elem(BSP,c_md_env.md_id,dp_mode,0);
             OBJ_COMP[0] = BSP;
             finish = 1;
	     break;
            }

	  else
	    {
             // store information for next component

             OBJ_INT[0]   = OBJ_INT[1];
             OBJ_BSP[0]   = OBJ_INT[1];
             OBJ_BSP[1]   = INT;
	    }
	  

    case DATA :

	  /*
 	    create a temporary component from the intersection point to the
	    end point of the curve 
	  */
          set_my_symb(0,0,0);
          index_open(OBJ_BSP[0],INT,p2,&window,&INDPT);

          // set the state to delete the point if the contour is deleted
          ci$send(msg = message NDnode.NDchg_state( sup_state,sup_state),
                  targetid = INDPT);

          OBJ_BSP[2] = INDPT;
          set_my_symb(0,1,0/*3*/);
          send ASextbsp.place(3,OBJ_BSP,p2) to BSP;
          dp_mode = GRhd/*GRbd*/;
          display_elem(BSP,c_md_env.md_id,dp_mode,0);

          OBJ_COMP[num_comp] = BSP;
          num_comp = num_comp + 1;

          for(k=0; k<3; k=k+1) old_p2[k] = p2[k];
          break;
    }
#ifdef DEBUG
  printf ("\n");
#endif
  } while(!finish);
 
/*
   change properties of components to locatable/displayable or non 
   and support only
   restore cnst_list
   make composite 
*/

 if(num_comp>0)
 {
  set = 0;
  display_props = GRIS_DISPLAYABLE | GRIS_LOCATABLE;

  for(i_comp = 0; i_comp<num_comp ; i_comp = i_comp+1)
   {
    TARGET = OBJ_COMP[i_comp];
    dp_mode = GRhe/*GRbe*/;
    display_elem(TARGET,c_md_env.md_id,dp_mode,0);
    ci$send(msg = message GRvg.GRgetsymb(&msg, &symb),
	    targetid=TARGET);
    symb.display_attr.weight = 0;/*symb.display_attr.weight - 3;*/
    ci$send(msg = message GRvg.GRputsymb(&msg, &symb),
	    targetid=TARGET);

    ci$send(msg = message GRgraphics.GRchgprops(&msg, &set, &display_props),
            targetid =  TARGET);
      ci$send(msg = message NDnode.NDchg_state( sup_state, sup_state ),
              targetid =  TARGET);
   } 

   // create and  display the composite curve

    set_my_symb(1,1,0);
    send AScompcurve.place(num_comp,OBJ_COMP,NULL) to COMP_CV;
    dp_mode = GRbd;
    if(COMP_CV != NULL_OBJID)
      {
       display_elem(COMP_CV,c_md_env.md_id,dp_mode,0);
       ex$message(msgnumb = AS_S_ToutBon);
      }
    else
      {
       delete();
       ex$message(msgnumb = AS_E_InvDefRest);
      }
  }
 }
}

/* Initialise the number of component */

init()
{
 num_comp = 0;
 OBJ_INT[0] = NULL_OBJID;
}
 

/* Redisplay the previous component if it exists */

wakeup()
{
 int dp_mode;
 struct GRid roots[3];
 int nb_roots;

 message(AC_M_COMP0);
 get_symb();
 ci$get_module_info( md_env = &c_md_env );


 for(i_comp = 0; i_comp<num_comp ; i_comp = i_comp+1)
  {
   TARGET = OBJ_COMP[i_comp];
   ci$send(msg = message NDnode.NDget_objects(ND_NG_ROOT,roots,3,
					      (char *)NULL, 0,2,&nb_roots) ,
	  targetid = TARGET);

   dp_mode = GRhd;
   display_elem(OBJ_COMP[i_comp],c_md_env.md_id,dp_mode,0);
  }
}

/*
   Delete created componant if the command is deleted or if error during
   contour creation
*/

delete()
{
 int dp_mode;
 struct GRid roots[3];
 int nb_roots;

 for(i_comp = 0; i_comp<num_comp ; i_comp = i_comp+1)
  {
   TARGET = OBJ_COMP[i_comp];
   ci$send(msg = message NDnode.NDget_objects(ND_NG_ROOT,roots,3,
					      (char *)NULL, 0,2,&nb_roots) ,
	  targetid = TARGET);

   dp_mode = GRhe/*GRbe*/;
   display_elem(OBJ_COMP[i_comp],c_md_env.md_id,dp_mode,0);

   ci$send(msg = message NDnode.NDdelete(&c_md_env),
           targetid =  TARGET);
   ci$send(msg = message NDnode.NDdelete(&c_md_env),
           targetid =  roots[1].objid);
   ci$send(msg = message NDnode.NDdelete(&c_md_env),
           targetid =  roots[2].objid);
  }
  
}


sleep()
{
long msg;
dp$erase_hilite (msg = &msg);
}
