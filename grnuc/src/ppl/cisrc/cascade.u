/*
Name
        cascade.u

Description
        This file resizes the graphic windows on each screen to
        appear in a cascade of identically-sized windows.  Some
        layout decisions are arbitrary.

Algorithm
        All windows are found by checking the exec's hw_win channel.
        Two lists are formed based on each window's virtual screen.
        The windows on each screen are then rearranged to cascade.
        At most 4 windows will be adjusted.  Some assumptions are
        made about menu and message window positions.

History
        mrm     07/26/91    creation
                11/08/91    fixed to work on the Sun
        jjm     03/06/92    ifdef's out some EnvironV calls for the Sun
	jdu	10/02/92    changed X11 version to work with borders on 
			    Messages strip and menus like the default.
			    The window will be a little smaller than
			    necessary when borders aren't used.
        elp     02/10/93    integrate WL
*/

#include <FI.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "OMminimum.h"
#include "OMprimitives.h"
#include "igetypedef.h"
#include "igrtypedef.h"
#include "ex.h"
#include "exmacros.h"
#include "igr.h"
#include "igewindef.h"
#include "igewinmacros.h"
#include "gr.h"
#include "igrdp.h"
#include "godef.h"
#include "go.h"
#include "griodef.h"
#include "grio.h"
#include "msdef.h"
#include "msmacros.h"
#include "grmessage.h"
#include "dpgraphics.h"
#include "grdpbmacros.h"
#include "grdpbdef.h"
#include "dp.h"
#include "dpmacros.h"
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "griodef.h"
#include "grio.h"
#include "dpdef.h"
#include "wl.h"

WLuint32 context_no;
struct WLnative_info native_info;

#define MAX_WINDOWS     64

#ifdef X11    /* assume MOTIF Window Manager */
#define S1_TOP_BUFFER           100     /* allow for msg and menu strips */
#define S1_RIGHT_BUFFER         187     /* allow for menu panel */
#define S1_BOTTOM_BUFFER        0       /* keep border on screen */
#define S1_LEFT_BUFFER          0       /* keep border on screen */
#else
#define S1_TOP_BUFFER           135     /* allow for msg and menu strips */
#define S1_RIGHT_BUFFER         194     /* allow for menu panel */
#define S1_BOTTOM_BUFFER        6       /* keep border on screen */
#define S1_LEFT_BUFFER          5       /* keep border on screen */
#endif

#define S2_TOP_BUFFER           90      /* allow for message strip */
#define S2_BOTTOM_BUFFER        6       /* keep border on screen */
#define S2_LEFT_BUFFER          5       /* keep border on screen */
#define S2_RIGHT_BUFFER         8       /* keep border on screen */

#ifdef X11
#define VERTICAL_FUDGE          26      /* vertical spacing between windows */
#define HORIZONTAL_FUDGE        26      /* horiz spacing between windows */
#else
#define VERTICAL_FUDGE          24      /* vertical spacing between windows */
#define HORIZONTAL_FUDGE        32      /* horiz spacing between windows */
#endif

#define CHNDX_TO_WIN_NUM(i)     (i - 20)

#define PRINT_RANGE(xl,yl,xh,yh)                        \
        printf("%4d, %4d; %4d, %4d; [%d, %d]\n",        \
               (int)xl, (int)yl, (int)xh, (int)yh,      \
               (int)(xh - xl), (int)(yh - yl));         \

/*
  Note: VALIDATE ignores rc because of a X11 bug in EXNUC;
  IGEwindow.change_gadget_size doesn't set the return code.  Reported to
  rme 11/8/91, should be fixed ~2.17?
*/

#if defined (DEBUG)
#define VALIDATE(sts,rc,string)                                 \
        if (!(sts & rc & 1))                                    \
        {                                                       \
            status(string);                                     \
            printf("%s [%#x, %#x]\n", string, sts, rc);         \
            return(FALSE);                                           \
        }
#else
#define VALIDATE(sts,rc,string)                                 \
        if (!(sts & rc & 1))                                    \
        {                                                       \
            return(FALSE);                                           \
        }
#endif

struct window_info
{
    OMuword window_os;
    OM_S_OBJID window_id;
    int vs_number;
};

#ifdef X11

IGRint x_decor, y_decor;
IGRint x_offset, y_offset;

IGRint GRget_window_decor(xdecor, ydecor)
IGRint *xdecor, *ydecor;
{
    IGRint sts, msg;
    IGRint i, j, x, y;
    IGRint window_number;
    IGRint dep_extents[6];
    Window w;
    OM_S_CHANSELECT chansel;
    OM_S_OBJECT_LINKAGE list;
    struct var_list vlist[3];
    struct GRid window;
    struct GRmd_env mod;

    /* grab a window */

    gr$get_module_env(buffer = &mod);

    sts = dp$get_gragad_id (msg = &msg,
                            mod_GRid = &mod,
                            name = "*",
                            array_size = 1,
                            total_num = &i,
                            numberofids = &j,
                            found_GRids = &window,
                            type_gragad = IGE_GG | ACTIVE_GG);

    VALIDATE(sts, msg, "dp$get_gragad_id");

#ifdef DEBUG
    printf("GRget_window_decor: ");
    printf("dp$get_gragad_id: window = %d, %d\n", window.osnum, window.objid);
#endif

    /* get the window's id and its idea of its position */

    sts = om$make_chanselect(channame = "IGEgadget.to_parent",
                             p_chanselect = &chansel);

    VALIDATE(sts, 1, "om$make_chanselect");

    sts = om$get_channel_objects(osnum = window.osnum,
                                 objid = window.objid,
                                 p_chanselect = &chansel,
                                 list = &list,
                                 size = 1,
                                 count = &i);

    VALIDATE(sts, (i > 0), "om$get_channel_objects");

    vlist[0].var = HW_WIN_NO;
    vlist[0].var_ptr =  (IGRchar *) &window_number;
    vlist[0].num_bytes = sizeof(window_number);
    vlist[0].bytes_returned = &j;
    vlist[1].var = WINDOW_DEP;
    vlist[1].var_ptr = (IGRchar *)dep_extents;
    vlist[1].num_bytes = sizeof(IGRint)*4;
    vlist[1].bytes_returned = &j;
    vlist[2].var = END_PARAM;

    sts = ige$inq_set_window(msg = &msg,
                             osnum = list.osnum,
                             window_objid = list.S_objid,
                             which_error = &i,
                             var_list = vlist);

    VALIDATE(sts, msg, "ige$inq_set_window");

    WLget_window_base_context( window_number, &context_no );
    WLget_native_info( window_number, context_no, &native_info );

    w = native_info.base_win;
    x = dep_extents[0];
    y = dep_extents[1];

#ifdef DEBUG
    printf("GRget_window_decor: w = %#x, ", w);
    printf("x = %d, y = %d\n", x, y);
#endif

    /* get the decoration and offset sizes */
    sts = GRget_decoration(w, x, y,
                           &x_decor, &y_decor,
                           &x_offset, &y_offset);

    VALIDATE(sts, 1, "GRget_window_decoration: GRget_decoration");

#ifdef DEBUG
    printf("GRget_window_decor: ");
    printf("x_decor = %d, y_decor = %d\n", x_decor, y_decor);
    printf("                    x_offset = %d, y_offset = %d\n",
           x_offset, y_offset);
#endif

    *xdecor = x_decor-1;/*xdecor was sending back the wrong value by 1.
			  This will now return the value stored for 
			  resize handle size.  The default is 5.*/
    *ydecor = y_decor;

    return(sts);
}

#endif

int COcascade_screen(screen_num, top_buffer, bottom_buffer, left_buffer,
                     right_buffer, count, wi)
int screen_num, top_buffer, bottom_buffer , right_buffer, left_buffer, count;
struct window_info *wi;
{
    int sts, rc, i, j;
    int width, height;
    int screen_xmin, screen_ymin, screen_xmax, screen_ymax;
    int xdecor,ydecor;
    double xmin, ymin, xmax, ymax;
#ifdef X11
    char *frame_position ;
#endif


    /* get screen limits, allowing buffer areas as specified */

    screen_xmin = 0 + left_buffer;
    screen_ymin = 0 + top_buffer;

    ige$inq_term_info(x_extent = &screen_xmax, y_extent = &screen_ymax);

#ifdef DEBUG
    printf("screen dimensions: %d, %d\n", screen_xmax, screen_ymax);
    printf("buffer dimensions: top=%d bottom=%d left=%d right=%d\n",
      top_buffer,bottom_buffer,left_buffer,right_buffer);
#endif

    screen_xmax = screen_xmax - right_buffer;
    screen_ymax = screen_ymax - bottom_buffer;

#ifdef X11

    GRget_window_decor(&xdecor, &ydecor);
#ifdef DEBUG
    printf("window decor: x=%d y=%d\n",xdecor,ydecor);
#endif
#ifndef IRIX
    frame_position = XGetDefault( EXdisplay,"Mwm","positionIsFrame");
    if(frame_position != NULL )
    {
#ifdef DEBUG
       printf("frame_position=*%s*\n",frame_position);
#endif
 
       if (!(strcmp(frame_position,"True")))
          {
             screen_ymax = screen_ymax - ydecor - xdecor;
          }
       else
          {
             screen_ymax = screen_ymax - xdecor;
             screen_ymin = screen_ymin + ydecor;
          }
    }
#else
/*   for SGI, this bottom line and the comment above */
             screen_ymax = screen_ymax - ydecor;
#endif
 
    screen_xmax = screen_xmax - 2 * xdecor;
#else
    screen_ymax = screen_ymax - bottom_buffer;
    xdecor = VERTICAL_FUDGE / 2;
    ydecor = HORIZONTAL_FUDGE / 2;
    screen_ymin = screen_ymin + xdecor;
 
#endif
#ifdef DEBUG
       printf("xmin=%d,xmax=%d,ymin=%d,ymax=%d, count=%d\n",screen_xmin,
               screen_xmax, screen_ymin, screen_ymax, count);
#endif

#ifdef X11
    width = screen_xmax - screen_xmin - ( ydecor * (count - 1));
    height = screen_ymax - screen_ymin - ( ydecor * (count - 1));
#else
    width = screen_xmax - screen_xmin - (VERTICAL_FUDGE * (count - 1));
    height = screen_ymax - screen_ymin - (HORIZONTAL_FUDGE * (count - 1));
#endif



    j = 0;
    for (i = count - 1; i >= 0; i = i - 1)
    {
#ifdef X11
        xmin = (double)(screen_xmin + ( ydecor * j));
        ymin = (double)(screen_ymin + ( ydecor * i));
#else
        xmin = (double)(screen_xmin + (VERTICAL_FUDGE * j));
        ymin = (double)(screen_ymin + (HORIZONTAL_FUDGE * i));
#endif

        xmax = (double)(xmin + width);
        ymax = (double)(ymin + height);
#ifdef DEBUG
        PRINT_RANGE(xmin, ymin, xmax, ymax);
#endif
        sts = ci$send(msg = message IGEgadget.change_gadget_size
                           (&rc, IGE_DEPENDENT, xmin, ymin, xmax, ymax),
                      targetid = wi[j].window_id,
                      targetos = wi[j].window_os);

        VALIDATE(sts, rc, "change_gadget_size");
        j = j + 1;
    }
    return(TRUE);
}

int COcascade_windows()
{
    OMuword exec_os, window_os;
    int i,j,msg, window_count, vs1_count, vs2_count, win_num, vs_num, *count;
    long sts;
    OM_S_OBJID exec_id, window_id;
    OM_S_CHANSELECT chan;
    struct window_info vs1[MAX_WINDOWS], vs2[MAX_WINDOWS], *wi;
    int phy_screens, wno, vs_1, vs_2;
    Form panel_form;
    int top, right, bottom, left, x_w_decor, y_w_decor,n, display_stat,type;
    int x_f_decor, y_f_decor;
    int msg_strip_ht, msg_strip_width;
    int bar_menu_ht, bar_menu_width;
    int panel_menu_ht, panel_menu_width;
    Form msg_strip, bar_menu;
    Form *forms;
    WLuint32 lwin_no, lscreen;
    int screen_type;
    struct var_list vlist[2];
    IGRint error;


if (  ex$is_batch() )
{
  return(FALSE);
}

    ex$message(field =MESSAGE_FIELD, msgnumb = GRC_M_CscdWn);

    vs1_count = 0;
    vs2_count = 0;
    window_count = 0;
    phy_screens = 1;

    /* get the exec object id and osnum */

    sts = ex$get_exec_id(id = &exec_id, osnum = &exec_os);
    VALIDATE(sts, 1, "ex$get_cur_mod")

    /* get the window ids from the exec.hw_win channel */

    sts = om$make_chanselect(channame = "exec.hw_win",
                             p_chanselect = &chan);
    VALIDATE(sts, 1, "om$make_chanselect exec.hw_win")

#ifdef X11
    phy_screens = 0;
#else
    /* check if there is more than one physical screen */

    ige$get_num_phy_screens(num_phy_screens = &phy_screens);

    phy_screens= phy_screens-1;
#endif

    for (i = 0; i < MAX_WINDOWS; i = i + 1)
    {
        sts = om$get_objid_at_index(osnum = exec_os,
                                    objid = exec_id,
                                    p_chanselect = &chan,
                                    index = i,
                                    objidaddr = &window_id,
                                    osnumaddr = &window_os);

        if (sts & 1)
        {
            win_num = CHNDX_TO_WIN_NUM(i);
            vlist[0].var = HW_WIN_NO;
            vlist[0].var_ptr =  (IGRchar *) &lwin_no;
            vlist[0].num_bytes = sizeof(lwin_no);
            vlist[0].bytes_returned = &j;
            vlist[1].var = END_PARAM;

            sts = ige$inq_set_window(msg = &msg,
                             osnum = window_os,
                             window_objid = window_id,
                             which_error = &error,
                             var_list = vlist);
 
    VALIDATE(sts, msg, "ige$inq_set_window");
 
            sts = WLget_window_screen( lwin_no, &lscreen );
 
            if (sts != WL_SUCCESS)
            {
#ifdef DEBUG
                printf("WLget_window_screen failed: %d\n", sts);
#endif

                /*
                    skip this window & continue (this gets hit when a
                    paper menu is attached)
                */
                continue;
            }
            sts = WLget_screen_type( lscreen, &screen_type );
 
            if (sts != WL_SUCCESS)
            {
#ifdef DEBUG
                printf("WLget_screen_type failed: %d\n", sts);
#endif
                /*
                    skip this window & continue (this gets hit when a
                    paper menu is attached)
                */
                continue;
            }

            if ( screen_type == WL_SCREEN_PRIMARY )
            {
                wi = vs1;
                count = &vs1_count;
            }
            else
            {
                wi = vs2;
                count = &vs2_count;
            }

            wi[*count].window_id = window_id;
            wi[*count].window_os = window_os;
            wi[*count].vs_number = vs_num;
            *count = *count + 1;
#ifdef DEBUG
            printf("object = %d, %d; window number %d, screen %d\n",
                   window_os, window_id, win_num, vs_num);
#endif
        }
    }
    if ((vs1_count < 1) && (vs2_count < 1))
    {
        ex$message(msgnumb = GR_E_WinNotFound);
        return(FALSE);
    }
#ifdef DEBUG
    printf("vs1_count = %d, vs2_count = %d\n", vs1_count, vs2_count);
#endif

    GRget_form_decoration(&x_f_decor, &y_f_decor);
 
#ifdef DEBUG
    printf("x_f_decor = %d, y_f_decor = %d\n", x_f_decor, y_f_decor);
#endif
 
    sts = FI_get_form_by_name("EX_msg_strip", &msg_strip);
    if (sts != FI_SUCCESS )
      {
#ifdef DEBUG
                printf("MSG_STRIP FI_get_form_by_name failed: %d\n", sts);
#endif
       return(FALSE);
      }
 
    FI_get_num_forms_menus(&n);
    forms = (Form *)malloc(n * sizeof(Form));
    FI_get_forms_menus(forms, &n);
    for(i=0;i<n;i=i+1)
    {
        FIf_is_displayed( forms[i], &display_stat );
        if ( display_stat )
        {
           FI_get_form_menu_type(forms[i], &type);
           if (type == FI_BAR_MENU_TYPE ||
               type == FI_TEAR_OFF_BAR_MENU_TYPE)
                bar_menu = forms[i];
           else if (type == FI_PANEL_MENU_TYPE ||
                    type == FI_TEAR_OFF_PANEL_MENU_TYPE)
                panel_form = forms[i];
        }
     }
     free(forms);
    sts = FIf_get_size( msg_strip, &msg_strip_width, &msg_strip_ht);
    if (sts != FI_SUCCESS )
      {
#ifdef DEBUG
                printf("FIf_get_size for msg_strip failed: %d\n", sts);
#endif
       return(FALSE);
      }
 
    sts = FIf_get_size( bar_menu, &bar_menu_width, &bar_menu_ht);
    if (sts != FI_SUCCESS )
      {
#ifdef DEBUG
                printf("FIf_get_size for bar_menu failed: %d\n", sts);
#endif
       return(FALSE);
      }
    sts = FIf_get_size( panel_form, &panel_menu_width, &panel_menu_ht);
    if (sts != FI_SUCCESS )
      {
#ifdef DEBUG
                printf("FIf_get_size for panel_menu failed: %d\n", sts);
#endif
      }
 
#ifdef DEBUG
      printf("msg_ht = %d,bar_ht=%d,panel_wd=%d\n", msg_strip_ht, bar_menu_ht,panel_menu_width);
#endif

#ifndef X11
   x_f_decor = S1_LEFT_BUFFER;
   y_f_decor = S1_BOTTOM_BUFFER;
#endif


    top = msg_strip_ht + bar_menu_ht + (4 * y_f_decor);
    bottom = y_f_decor;
    right = panel_menu_width + (2 * x_f_decor);
    left = 0;
 
#ifndef X11
    left = x_f_decor;
    top  = top+x_f_decor;
#endif

#ifdef DEBUG
     printf("top = %d,bottom=%d,right=%d,left=%d\n", top,bottom,right ,left);
#endif


    if (vs1_count)
    {
        if (phy_screens==0)
           COcascade_screen(1, top, bottom, left, right, vs1_count, vs1);

/*
         COcascade_screen(1, S1_TOP_BUFFER, S1_BOTTOM_BUFFER,
                      S1_LEFT_BUFFER,
                      S1_RIGHT_BUFFER, vs1_count, vs1);
*/
        else
        {
            FIf_get_window(panel_form, &wno);
/*	
            Inq_win_vs(wno, &vs_1);
*/
            ige$inq_term_info(screen_no = IGE_RIGHT_SCREEN, vs_no = &vs_2);
            if (vs_1==vs_2) COcascade_screen(1, S1_TOP_BUFFER,
                                    S1_BOTTOM_BUFFER, S1_LEFT_BUFFER,
                                    S1_RIGHT_BUFFER, vs1_count, vs1);
            else COcascade_screen(1, S2_TOP_BUFFER, S2_BOTTOM_BUFFER,
                    S2_LEFT_BUFFER, S2_RIGHT_BUFFER, vs1_count, vs1);
        }
    }

    if (vs2_count)
    {
        FIf_get_window(panel_form, &wno);
/*	
        Inq_win_vs(wno, &vs_1);
*/
        ige$inq_term_info(screen_no = IGE_LEFT_SCREEN, vs_no = &vs_2);
        if (vs_1==vs_2) COcascade_screen(2, S1_TOP_BUFFER,
                                S1_BOTTOM_BUFFER, S1_LEFT_BUFFER,
                                S1_RIGHT_BUFFER, vs2_count, vs2);
        else COcascade_screen(2, S2_TOP_BUFFER, S2_BOTTOM_BUFFER,
                S2_LEFT_BUFFER, S2_RIGHT_BUFFER, vs2_count, vs2);
    }

    return(TRUE);
}

main()
{
    COcascade_windows();
}





