/************************************************************************/
/*									*/
/*	Program: getwinrange.u		Macro:plot$create_plotfile()	*/
/*					      plot$get_window_range()	*/
/*									*/
/*	Defined in: plotmacros.h					*/
/*									*/
/*	Comments: plot file name is hardcoded 				*/
/*									*/
/************************************************************************/

#include "ciminimum.h"
#include "cimacros.h"
#include "igrdp.h"
#include "go.h"
#include "ex.h"
#include "griodef.h"
#include "grio.h"
#include "plotdef.h"
#include "plotmacros.h"			/* defined */
#include "msdef.h"

#define  ARSIZ	5

extern int COplot_get_window_range(), COcreate_plotfile(), DPgetggid();

main()
{
   char buffer[64], plotfile[128], color_table[128];
   int sts, msg, flag;
   double range[12],pt[3];
   struct GRmd_env module_info;
   struct GRid window;
   struct GRevent event;


   plotfile[0] = NULL;
   color_table[0] = NULL;
   buffer[0] = NULL;
   flag = FALSE;
   ci$get_module_info( md_env = &module_info );

/* Get window to plot */

   ci$getevent( prompt = "Identify the window to be plotted",
		event  = &event );

/* Get info about the window */
   sts = plot$get_window_range( msg    = &msg,
                             event  = &event,
                             window = &window,
                             world  = range,
                             view   = &range[6] );

   if (msg == MSSUCC)
   {
	strcpy( buffer, "Window identified" );
	status ( buffer );
   }
   else
	if (msg == PI_F_NOWINDOW )
	{
	   strcpy( buffer, "No window found" );
	   status ( buffer );
	}
   	else 
	{
		strcpy( buffer, "Error in window identification" );
		status ( buffer );
	}
	
/* Call macro to create a plotfile */
   plot$create_plotfile( msg         = &msg,
                      module      = &module_info,
                      dbtype      = "3d",
                      range       = range,
                      window      = &window,
                      plotfile    = "/usr/tmp/plot.plt",
                      color_table = color_table,
                      status      = buffer );

   status (buffer);
}
