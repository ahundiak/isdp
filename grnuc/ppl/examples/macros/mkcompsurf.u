/************************************************************************/
/*                                                                      */
/*  Program: mkcompsurf.u         Macro: ems$make_comp_surf		*/
/*                                                                      */
/*  Defined in: EMSascmacros.h                                          */
/*                                                                      */
/*  Comments  : Creates an associative composite surface when the input */
/*		surfaces abet each other. Fails when surfaces intersect.*/
/*              Does not work for Solids.				*/
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "ci_easy.h"
#include "go.h"
#include "grdpbmacros.h"
#include "dpmacros.h"
#include "lcdef.h"
#include "exdef.h"

#include "EMSascmacros.h"
#include "EMSasnuc.h"
#include "EMSasopts.h"

extern	int	GRdpb_get();
extern	int	DPmacupdate();

main ()
{
  /* Declare variables here : */
     struct GRvg_construct    const_list;
     struct GRmd_env          surf_env;
     struct IGRdisplay        disp_buffer;

     OM_S_OBJID               surfaces[30];
     OM_S_OBJID               comp_surface;
     OM_S_OBJID               tmp_surface;
     IGRshort                 disp_level;
     IGRboolean               assoc_placement;
     IGRushort                options;
     IGRint                   sts,num_bytes,surf_count,res;
     IGRint                   num_surfaces;
     IGRlong                  msg_loc, nbytes_ret;
     IGRchar                  prompt_str[30];

  /* End of variable declarations */
    
    message (" Make Composite Surface/Solid ") ;

    /*Get the object */

        ci$locate ( obj            = &surfaces[0],
		    md_env         = &surf_env,
	            prompt         = "Identify surface/set",
	            acc_prompt     = "Accept/Reject ",
	            relocate_prompt= "Element not Found",
		    classes        = "EMSsubbs",
		    owner_action   = LC_RIGID_COMP | LC_FLEX_COMP,
                    response       = &res
	          );
        if (res == EX_RJT_MOVEON)
            exit;
        surf_count = 1;
        while (1)
        {
	   if ( surf_count == 1)
	        strcpy ( prompt_str,"Identify next surface/Reject");
           else
	        strcpy ( prompt_str,"Identify next surface/Moveon");

           ci$locate ( obj            = &tmp_surface,
	               prompt         = prompt_str,
	               acc_prompt     = "Accept/Reject ",
	               relocate_prompt= "Identify surface/solid/set",
		       classes        = "EMSsubbs",
		       owner_action   = LC_RIGID_COMP | LC_FLEX_COMP,
                       response       = &res
	             );
           if( res == EX_DATA) 
           {
	       surfaces[surf_count]= tmp_surface;
               surf_count = surf_count + 1;
           }
	   else if ( res == EX_RJT_MOVEON )
		break;
        }
	num_surfaces = surf_count;
	if ( num_surfaces < 2 )
	     exit;

    num_bytes = sizeof(struct IGRdisplay);
    gr$get_active_display ( msg = &msg_loc, sizbuf = &num_bytes,
			    nret= &nbytes_ret, buffer = &disp_buffer );
    gr$get_active_level   ( buffer = &disp_level );
    
    const_list.msg        = &msg_loc;
    const_list.env_info   = &surf_env;
    const_list.display    = &disp_buffer;
    const_list.properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    const_list.newflag    = FALSE;
    const_list.level      = disp_level;
    const_list.class_attr = NULL;
    const_list.name       = NULL;
    const_list.geometry   = NULL;

    gr$get_associative_flag ( buffer = &assoc_placement );
    
    if ( ! assoc_placement )
         options = EMSasconst_notassociative;
    else
         options = NULL;

    sts = ems$make_comp_surf( msg               = &msg_loc,
                              num_surfs         = num_surfaces,
                              surfaces          = &surfaces[0],
		              options           = options,
                              construction_list = &const_list,
                              comp_surface      = &comp_surface);
    if (!(sts & msg_loc & 1)) goto wrapup;

    dp$update ( msg   = &msg_loc);
    exit;
wrapup:
       status(" Make Composite Operation failed ");
       exit;
}
