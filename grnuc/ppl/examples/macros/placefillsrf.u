/************************************************************************/
/*									*/
/*  Program: placefillsrf.u	    Macro: ems$place_fillet		*/
/*									*/
/*  Defined in: EMSascmacros.h						*/
/*									*/
/*  Comments  : For placing a round fillet between two surfaces		*/
/*		the radius of curvature is the only input.		*/
/*									*/
/************************************************************************/
#include <stdio.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "ci_surface.h"
#include "cievent.h"
#include "go.h"
#include "grdpbmacros.h"
#include "dpmacros.h"
#include "lcdef.h"

#include "EMSascmacros.h"
#include "EMSasnuc.h"
#include "EMSasopts.h"


extern	int	GRdpb_get();
extern	int	DPmacupdate();

main ()
{
    /* Declare variables here */
    struct GRvg_construct    const_list;
    struct IGRdisplay        disp_buffer;

    struct EMSobject_info    surface1;
    struct EMSobject_info    surface2;
    struct EMSpoint_info     start_point;
    struct EMSpoint_info     end_point;
    struct EMSvalue_info     start_radius;
    struct EMSvalue_info     end_radius;
    struct GRevent           my_event;
    struct GRid              surf1;
    struct GRid              surf2;
    
    IGRboolean               nat_norm1;
    IGRboolean               nat_norm2;
    IGRchar                  *var_curve;
    IGRdouble                rho_value;
    IGRboolean               is_chamfer;
    GRobjid                  fillet_obj;

    IGRshort                 disp_level;
    IGRdouble                tmp_radius;
    IGRboolean               assoc_placement;
    IGRushort                options;
    IGRpoint                 start_pt;
    IGRpoint                 mid_pt;
    IGRpoint                 end_pt;
    IGRint                   res,tmp,sts, num_bytes;
    IGRlong                  msg_loc, nbytes_ret;

    /* End of variable declarations */

    message (" Place Fillet Surface ") ;

    /* Locate the first surface */

    ci$locate ( obj=&surface1.grid.objid,
		osnum = &surface1.grid.osnum,
	        md_env=&surface1.env,
	        prompt="Identify surface 1",
	        acc_prompt="Accept/Reject ",
                accept_point = start_pt,
	        relocate_prompt="Surface not Found",
		classes = "EMSsubbs",
		owner_action = LC_RIGID_COMP | LC_FLEX_COMP
	      );

    surf1.objid = surface1.grid.objid;
    surf1.osnum = surface1.grid.osnum;

    prompt (" Accept displayed direction/Reject ");

    /* Show the selected surface normal */
    md$show_normals( GRid_in = surf1, disp = HILITE );

    ci$getevent ( response = &res,
                  event = &my_event,
                  mask = GRm_DATA | GRm_RESET | GRm_BACK_UP |
                  GRm_RESTART | GRm_MOVE_ON ) ;

    md$show_normals( GRid_in = surf1, disp = ERASEHILITE );

    if (res == EX_DATA)
         nat_norm1 = TRUE;
    else if (res == EX_RJT_MOVEON)
         nat_norm1 = FALSE;

    /* Locate the second surface */

    ci$locate ( obj=&surface2.grid.objid,
		osnum = &surface2.grid.osnum,
	        md_env=&surface2.env,
	        prompt="Identify surface 2",
	        acc_prompt="Accept/Reject ",
                accept_point = end_pt,
	        relocate_prompt="Surface not Found",
		classes = "EMSsubbs",
		owner_action = LC_RIGID_COMP | LC_FLEX_COMP
	      );

    if ( surface2.grid.objid == surface1.grid.objid )
    {
      status ( " This element has alrady been selected " );
      ci$locate ( obj=&surface2.grid.objid,
		  osnum = &surface2.grid.osnum,
	          md_env=&surface2.env,
	          prompt="Identify surface 2",
	          acc_prompt="Accept/Reject ",
	          relocate_prompt="Surface not Found",
		  classes = "EMSsubbs",
		  owner_action = LC_RIGID_COMP | LC_FLEX_COMP
	        );
    }

    surf2.objid = surface2.grid.objid;
    surf2.osnum = surface2.grid.osnum;
    prompt (" Accept displayed direction/Reject ");

    /* Show the selected surface normal */
    md$show_normals( GRid_in = surf2, disp = HILITE );

    ci$getevent ( response = &res,
                  event = &my_event,
                  mask = GRm_DATA | GRm_RESET | GRm_BACK_UP |
                  GRm_RESTART | GRm_MOVE_ON ) ;

    md$show_normals( GRid_in = surf2, disp = ERASEHILITE );

    if (res == EX_DATA)
         nat_norm2 = TRUE;
    else if (res == EX_RJT_MOVEON)
         nat_norm2 = FALSE;

    ci$get ( value = tmp_radius,
	     prompt = "Radius for fillet surface"
	   );
    start_radius.val = tmp_radius;
    start_radius.type = EMSdatainfo_numeric;

    end_radius.val = tmp_radius;
    end_radius.type = EMSdatainfo_numeric;

    start_point.pt[0] = start_pt[0];
    start_point.pt[1] = start_pt[1];
    start_point.pt[2] = start_pt[2];
    start_point.type  = EMSdatainfo_numeric;

    end_point.pt[0] = end_pt[0];
    end_point.pt[1] = end_pt[1];
    end_point.pt[2] = end_pt[2];
    end_point.type  = EMSdatainfo_numeric;

    rho_value = 0.4142135623730950488;

    is_chamfer = FALSE;

    num_bytes = sizeof(struct IGRdisplay);
    gr$get_active_display ( msg = &msg_loc, sizbuf = &num_bytes,
			    nret= &nbytes_ret, buffer = &disp_buffer );
    gr$get_active_level   ( buffer = &disp_level );
    
    const_list.msg        = &msg_loc;
    const_list.env_info   = &surface1.env;
    const_list.display    = &disp_buffer;
    const_list.properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    const_list.newflag    = FALSE;
    const_list.level      = disp_level;
    const_list.class_attr = NULL;
    const_list.name       = NULL;
    const_list.geometry   = NULL;

    gr$get_associative_flag ( buffer = &assoc_placement );
    
    if ( ! assoc_placement )
         options = EMSasconst_notassociative;
    else
         options = NULL;

    sts = ems$place_fillet(msg              = &msg_loc,
                           surface1         = &surface1,
                           natural_normal1  = nat_norm1,
                           surface2         = &surface2,
                           natural_normal2  = nat_norm2,
                           start_point      = &start_point,
                           start_radius     = &start_radius,
                           end_point        = &end_point,
                           end_radius       = &end_radius,
                           variation_curve  = NULL,
                           rho_value        = rho_value,
                           is_chamfer       = is_chamfer,
                           ext_ind          = 0,
                           cnv_ind          = 1,
                           cnc_ind          = 0,
                           options          = options,
                           construction_list= &const_list,
                           fillet_object    = &fillet_obj
                          );

    if (!(sts & msg_loc & 1)) goto wrapup;

    dp$update ( msg   = &msg_loc );
    exit;
wrapup:
            status(" Severe Failure ");
}
