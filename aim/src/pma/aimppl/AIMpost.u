/**************************************************************************
st
* AIMpost
*
* File:	/pma/post/AIMpost.u
*
* Description:
*
* Dependencies:
*
* Revision History:
*	$Log: AIMpost.u,v $
*	Revision 1.1  2002/05/31 16:28:32  tlstalli
*	Backup of PMA process from EXTR
*	
*	Revision 1.2  2001/02/15 16:45:08  build
*	Replaced v_dbgmacros.h file with vedbgmacros.h file.
*	
*	Revision 1.1.1.1  2001/01/04 21:13:22  cvs
*	Initial import to CVS
*	
# Revision 1.2  1998/12/17  20:49:46  pinnacle
# Change the file to work with SIR.
#
# Revision 1.1  1998/04/30  10:43:50  pinnacle
# EXTR 2.5.1
#
# Revision 1.2  1997/11/13  19:42:32  pinnacle
# rename the post commands. TLS.
#
# Revision 1.1  1997/11/04  18:53:50  pinnacle
# e4r 2.5
#
# Revision 1.1  1997/10/17  15:16:44  pinnacle
# Extract For Review 2.5
#
# Revision 1.2  1997/06/09  19:39:26  pinnacle
# update file .
#
# Revision 1.1  1996/05/29  13:43:36  pinnacle
# getting files from PDU and invoking Extract for Review.
#
*
* History:
*	MM/DD/YY	AUTHOR		DESCRIPTION
*
***************************************************************************/

#define vdsDEBUG
#define vdserrDEBUG

/*
#include "PostCmd.h"
*/

#include "ciminimum.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "exdef.h"
#include "exmacros.h"
#include "refdef.h"
#include "refmacros.h"
#include "vedbgmacros.h"
#include "stdio.h"
#include "string.h"
/*#include <sys/types.h>*/

/* Includes for the delete_local_file function */
#include "MEMerrordef.h"
#include "NFMerrordef.h"
#include "MEMstruct.h" 
#include "PDUintdef.h"
#include "PDUfile_def.h"
#include "PDUppl_hdr.h"
#include "ACrg_collect.h"
#include "exproto.h"
#include "exdef.h"
#include "exmacros.h"

#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"

/* defines for Postman */
#define CLIX_CONNECT    -1
#define CLIX_DISCONNECT -2
#define SIZE 4096
#define SM_SIZE 128
#define SUCCESS	0
#define FAILURE 1

#define PME     0
#define SIR     1

#define SIR_GLOBAL_DIR          ":IGENOD:SIRGlobal"
#define SIR_REQ_DATA            ":SRReqData"
#define SIR_CNTX_ID              "Context Id"

/*
extern		ACget_named_attribute();
extern		ACmod_list_attribute();
*/


/* External function for the PME process */
extern  int     POSTMAN_REQUEST_ON_CLIX();


/* Externals for the delete_local_file function ONLY */
extern 	int 	change_mode;
extern  	MEMbuild_array();
extern		MEMclose();
extern		MEMwrite();
extern		MEMprint_buffer();
extern	void	PDUsetup_buffer();
extern	int	PDUget_buffer_col();
extern	int	PDUformat_buffer();
extern 	int	PDUadd_buffer_string();
extern		_pdm_status(); 
extern	int	EXR_getProdInfo();
extern	int	EXRgen_filename();
extern  int     EX_filename1 __((char *result, int len));
extern  int	PDMi_find_cofilename();
extern  int	EX_get_working_dir();
extern  int	IsPmeEnabled();
extern	int	VDgetVdCollId();
extern	int	PDMGetPartInfoGivenFileName();
extern  int	WhichAim();
extern 	int	VDgetDiagCtlPar();
extern 		VDPGetAimName();



/* externals for the others functions */
extern	char	*malloc();
extern	char	*realloc();
extern	void	free();
extern		printf();
extern  FILE	*fopen();
extern		fprintf();
extern		PDUfill_in_string();
extern		PDUdebug_on();
extern		PDUdebug_off();
extern		_pdm_debug();
extern	char	*PDUtranslate_message();
extern  int	atoi();
extern  int 	strncmp();
extern  int	stat();
extern  int	system();
extern	char	*strcpy();

/* the posting commands */
extern	int	VDP_send_post_cmd();
extern	int	VDP_send_verify_cmd();
extern	int	VDP_copy_cmd();
extern	int	VDP_remove_cmd();
extern	int	VDP_connect_status();

extern	int	PDM_debug_on ;

struct	EX_s_FileInfo 
{

char		filename[SM_SIZE];
char		server[SM_SIZE];
char		catalog[SM_SIZE];
char		partno[SM_SIZE];
char		revision[SM_SIZE];
char		ctxid[SM_SIZE];

};
typedef struct  EX_s_FileInfo   EX_FileInfo;


/*
* Global variables in files.
*/

EX_FileInfo		E4R_FileInfo;
char			*errPDM ;
FILE			*ptr;


/**************************************************************************/

/*****************************************************
* Verify the connection to AIVerify the connection to AIM.
*
*****************************************************/

verify_connect_postman( retCode )
int	*retCode;
{
int		i, status ;

int		conn_status;
int		stat;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;

conn_status	= 0;
stat		= 0;

fprintf(ptr,"verify_connect_postman: \n");

if( IsPmeEnabled() == FALSE )
{
	UI_status("AIM server connection required");
	fprintf(ptr,"\tAIM server connection required.\n");
      	status = OM_E_ERROR;
        goto quit;
}

fprintf(ptr,"\tAIM server connection is established.\n");

quit:
  return status ;
}

/*****************************************************
* Find out what AIM are we using.
*
*****************************************************/

determine_AIM( retCode )
int	*retCode;
{
int			status ;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;

fprintf(ptr,"\ndetermine_AIM: \n");

if( WhichAim() == PME)
{
	UI_status("This process does not support PME.");
	fprintf(ptr,"\tThis process does not support PME.\n");
      	status = OM_E_ERROR;
        goto quit;
}

if( WhichAim() == SIR)
{
	UI_status("AIM server is SIR");
	fprintf(ptr,"\tAIM server is SIR\n");
      	status = OM_S_SUCCESS;
        goto quit;
}


quit:

  return status ;
}

/*****************************************************
* get the context id from the file collector.
*
*****************************************************/

get_ctx_id( retCode )
int	*retCode;
{
int			status ;
OMuword         	curOs;
IGRchar         	DirName[DI_PATH_MAX];
IGRchar         	CollName[DI_PATH_MAX];
struct GRid     	CollId;
struct ACrg_coll	coll;
IGRlong         	*msg;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;


fprintf(ptr,"\nget_ctx_id: \n");

ex$get_cur_mod( osnum = &curOs );

/* get directory path name */
status = di$give_pathname(	osnum           = curOs,
                                pathname        = DirName );

sprintf( CollName,"%s%s%s", DirName, SIR_GLOBAL_DIR, SIR_REQ_DATA );

CollId.objid = NULL_OBJID;

status = VDgetVdCollId ( &msg, CollName, TRUE, FALSE, &CollId );

if (CollId.objid == NULL_OBJID )
{
	UI_status("SIR Required Data not set...");
	fprintf(ptr,"\tSIR Required Data not set. \n");
      	status = OM_E_ERROR;
   	return status;
}

strcpy( coll.name, SIR_CNTX_ID  );

ci$send ( msg = message ACrg_collect.ACget_named_attribute(
		 msg,
		 &coll ),
		 targetid = CollId.objid,
		 targetos = CollId.osnum);

strcpy( E4R_FileInfo.ctxid, coll.desc.value.att_txt );
fprintf(ptr,"\tContext ID: %s \n", E4R_FileInfo.ctxid);

quit:

  return status ;
}


/*******************************************************
*
* Get the filename, catalog, part number, and revision information 
* about the file. 
*
*******************************************************/

get_file_info( retCode )
int	*retCode ;
{
int           	i, status, ch ;
IGRchar		dgnFile[256];
char		*temp,*tmpfile, temp1[128]; 
char            cur_filedescr[OM_K_MAXOSNAME_LEN];


*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;
temp		= NULL;
tmpfile         = NULL;
ch              = '/';


fprintf(ptr,"\nget_file_info: \n");

/* Get current filename */
ex$filename( name=cur_filedescr, len=OM_K_MAXOSNAME_LEN );
fprintf(ptr, "\tlocal file: %s\n", cur_filedescr);

temp = strrchr(cur_filedescr, ch);
sprintf(temp1,"%s", temp);
tmpfile = strtok(temp1, "/");
sprintf(cur_filedescr,"%s", tmpfile);


sprintf(E4R_FileInfo.filename, "%s", cur_filedescr);


/* get the pdm catalog, part number and revision */
status = PDMGetPartInfoGivenFileName(	E4R_FileInfo.filename, 
					E4R_FileInfo.catalog, 
					E4R_FileInfo.partno, 
					E4R_FileInfo.revision);
 
fprintf(ptr,"\tPDM filename: %s \n", E4R_FileInfo.filename);
fprintf(ptr,"\tPDM catalog: %s \n", E4R_FileInfo.catalog);
fprintf(ptr,"\tPDM partno: %s \n", E4R_FileInfo.partno);
fprintf(ptr,"\tPDM revision: %s \n", E4R_FileInfo.revision);
/*
if( ! E4R_FileInfo.filename) || ( ! E4R_FileInfo.catalog) || ( ! E4R_FileInfo.partno ) || ( ! E4R_FileInfo.revision)
{
      	status = OM_E_ERROR;
        goto quit;
}
*/

quit:

  return status ;
}

/*******************************************************
*
* Get the AIM server name that we are connected to.
*
*******************************************************/

get_server_name( retCode )
int	*retCode ;
{
int           	i, status, ch ;
char		servername[30];

*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;

fprintf(ptr, "\nget_server_name:\n");

/*sprintf(E4R_FileInfo.server, "%s", "mahogany");
*/
VDPGetAimName(servername);
fprintf(ptr,"\tAIM Server: %s\n", servername);

sprintf(E4R_FileInfo.server, "%s", servername);
fprintf(ptr,"\tAIM Server: %s\n", E4R_FileInfo.server);

quit:

  return status ;
}

/*********************************************************
* extract_files:
* extract the dummy file with the local files attached. 
*********************************************************/

extract_files(  retCode )
int	* retCode ;
{
int		i, status, filetype; 
long            msg;
IGRint		EXRcre_loaded,
		EXR_mode,
		all_or_evgen ;
IGRchar		dgnFile[256];
IGRchar		tmpFile[256];
IGRchar		outFile[256];
IGRchar		prdPath[256];

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;

fprintf(ptr, "\nextract_files:\n");

EXRcre_loaded = 1;
EXR_mode	= 0 ;
all_or_evgen	= 0 ;
filetype 	= 0 ;

/*determine the file type */
fprintf(ptr,"\tdetermine_filetype: \n");

status = VDgetDiagCtlPar(&msg, &filetype );

if( filetype == 1)   /* file type 2D */
{
	fprintf(ptr,"\t\t\tfiletype: 2D \n");
	UI_status("Processing Plot Drawning Extraction...");
	fprintf(ptr,"\t\tProcessing Plot Drawning Extraction.\n");
	status = OM_S_SUCCESS;
}
else if (filetype == 0 ) /* file type 3D */
{
	fprintf(ptr,"\t\t\tfiletype: 3D \n");
	UI_status("Processing E4R Extraction.");
	fprintf(ptr,"\t\tProcessing E4R Extraction.\n");
  	status = EXR_getProdInfo( "Extr4rvw", NULL, prdPath );
  	if (status != OM_S_SUCCESS)
  	{
		UI_status("Error finding Extract for Review product...."); 
		fprintf(ptr,"\tError finding Extract for Review product.\n"); 
		goto quit;
  	}

  	ex$filename (name = dgnFile, len = 256);
  	EXRgen_filename( dgnFile, outFile, ".dgn");
	fprintf(ptr,"\t\tDesign File: %s \n", outFile);

  	fprintf(ptr,"\t\tCalling Extract for Review. \n");
  	push  EXR_mode, dgnFile, all_or_evgen, prdPath, outFile, NULL ;
  	ci$exec(      	file_name       = "EXRcre_dgn",
                	entry           = "EXRcre_dgn" );
  	if( status != CI_S_SUCCESS )
  	{
		UI_status(" Error during Extraction Process...");
		fprintf(ptr,"\t\t\tError during Extraction Process.\n");
  	}
	else
	{
		UI_status("Extraction Process Complete...");
                fprintf(ptr,"\t\t\tExtraction Process Complete.\n");
	}

}
else if (filetype == -1 ) /* file type 3D */
{
	UI_status("File Type is not Set.");
	fprintf(ptr,"\tFile Type is not Set.\n");
      	status = OM_E_ERROR;
        goto quit;
}

quit:
  return status;

}

/*******************************************************
*
* ftp the extracted files to the exported work location.
*
*******************************************************/

ftp_files_to_aim_wl( retCode )
int     *retCode ;
{
int           	status;
FILE		*ftpptr;
char		txt[256];
char		*temp;

*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;             
ftpptr		= NULL ;
temp		= NULL ;
  
fprintf(ptr,"\nftp_files_to_aim_wl:\n");

ftpptr = fopen("AIMftp.sh", "w+");
if(ftpptr == NULL)
{
	UI_status("Can not open ftp shell file for writing...");
	fprintf(ptr,"\tCan not open ftp shell file for writing.\n"); 
      	status = OM_E_ERROR;
        goto quit;
}



/* remove the ext on the filename */
temp = strtok(E4R_FileInfo.filename, ".");

fprintf( ftpptr, "if ( \techo user anonymous blank\n");
fprintf(ftpptr, "\techo ascii\n");
fprintf(ftpptr, "\techo send %s.dri\n",temp);
fprintf(ftpptr, "\techo send %s.dgn\n",temp);
fprintf(ftpptr, "\techo send %s.tbl\n",temp);
fprintf(ftpptr, "\techo send %s.drv\n",temp);
fprintf(ftpptr, "\techo send %s.dst\n",temp);
fprintf(ftpptr, "\techo send %s.log\n",temp);
fprintf(ftpptr, "\techo quit\n");
fprintf(ftpptr, " ) | ftp -ni %s ; then\n", E4R_FileInfo.server);
fprintf(ftpptr, "\techo ftp to AIM work location was SUCCESSFUL.\n");
fprintf(ftpptr, "else\n");
fprintf(ftpptr, "\techo Ftp to AIM work location FAILED.\n");
fprintf(ftpptr, "fi\n");
fclose(ftpptr);
status =  system ("chmod 777 AIMftp.sh");
status =  system ("AIMftp.sh");
if( status != 0 )
{
	UI_status("Can not execute ftp shell file...");
	fprintf(ptr,"\tCan not execute ftp shell file.\n"); 
      	status = OM_E_ERROR;
        goto quit;
}
else
{
	status = OM_S_SUCCESS;
}


fprintf(ptr,"\tExiting ftp_files_to_aim_wl.\n"); 

quit:

  return status ;

}   



/*******************************************************
*
* send a command to AIM through postman. 
* post the extracted files to AIM.
*
*******************************************************/

post_files( retCode )
int	*retCode ;
{
int           i, status ;

*retCode      = OM_S_SUCCESS  ;
status        = OM_S_SUCCESS ;


/*
 * Send Cmd to AIM through Postman to:
 *      1. post the extracted files into the AIM. 
 */

UI_status("Sending post command to AIM....................");
fprintf(ptr,"Sending post command to AIM....................\n");

status = VDP_send_post_cmd(	E4R_FileInfo.filename,
				E4R_FileInfo.server, 
				E4R_FileInfo.catalog, 
				E4R_FileInfo.partno, 
				E4R_FileInfo.revision, 
				E4R_FileInfo.ctxid); 

if (status != 0) 
{
__DBGpr_int("status is bad.  status =  ", status);

	if(status == 1)
       	{
         	UI_status("There was an AIM connection problem.");
         	fprintf(ptr,"There wan an AIM socket connection problem.\n");
       	 	status = OM_E_ERROR;
       	}

	if(status == 30)
       	{
         	UI_status("The AIM work location could not be found.");
         	fprintf(ptr,"The AIM work location could not be found.  Verify that the work location exist.  If it does, contact your administrator.\n");
       	 	status = OM_E_ERROR;
       	}

       if(status == 31)
       {
         	UI_status("Error in retrieving the server host name in AIM.");
         	fprintf(ptr,"Error in retrieving the server host name in AIM.  Contact Administrator.\n");
         	status = OM_E_ERROR;
       }

       if(status == 32)
       {
         	UI_status("An Error has occured in AIM.");
         	fprintf(ptr,"An Error has occured in AIM.  Contact the Administrator.\n");
         	status = OM_E_ERROR;
       }

       if(status == 33)
       {
         	UI_status("The extracted files are not in the work locations.");
         	fprintf(ptr,"The extracted files are not in the work locations.\n");
         	status = OM_E_ERROR;
       }
       if(status == 34)
       {
         	UI_status("The AIM vault could not be found.");
         	fprintf(ptr,"The AIM vault could not be found.  Verify that the vault exist.  If it does, contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
       if(status == 35)
       {
         	UI_status("The AIM vault location could not be found.");
         	fprintf(ptr,"The AIM vault location could not be found.  Verify that the vault location exist.  If it does, contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
       if(status == 36)
       {
         	UI_status("An ERROR Occurred In AIM .");
         	fprintf(ptr,"The unregisted AIM object could not be located in the work location.  Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }

       if(status == 37)
       {
         	UI_status("The AIM work location is not set in the config file.");
         	fprintf(ptr,"The AIM work location is not set in the config file.  Locate the config parameter in the AIM config.cfg file and set it to the work location name.  If it id set then conatact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
       else
       {
         	UI_status("Error in sending post command to AIM.\n");
         	fprintf(ptr,"Error in sending post command to AIM. Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
}
else 
{
	status = OM_S_SUCCESS;
       	UI_status("Posting to AIM  was Successful.....................\n");
       	fprintf(ptr,"Posting to AIM  was Successful.....................\n");
}              

quit:

  return status ;

}
/********************************************************
* Remove the .dri file from the work location directory.  
* The transfer process does not remove the file because
* there is an sysmbolic link between the .dri and DesignReview.
* Instead it makes a local copy of the file in to the vault
* location and leaves a local copy in the exported dir.
**********************************************************/

remove_dri_file( retCode )
int     *retCode ;
{
int		i, status, ch, check;
char          	temp[256];

*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;

/*
status = VDP_remove_cmd(E4R_FileInfo.exportDir, E4R_FileInfo.filename);
*/

status = OM_S_SUCCESS;

quit:

  return status ;

}





/*****************************************************************
* This is the program                                       *
*****************************************************************/
main()
{
int	status ;
int	retCode ;
int	savDebugFlag ;
char    file[15];
char 	log[30];
IGRchar	prdPath[256];
IGRchar	CtxId[256];

status 	= OM_S_SUCCESS;
retCode = OM_S_SUCCESS;
ptr	= NULL;

        /* open the log file to print out posting information */
	sprintf(log, "%s","AIMpost.log");
        ptr = fopen(log, "w+");
        if(ptr == NULL)
          UI_status("Can not open log file for writing...");

        UI_status("Processing..........................");
	
  	status = EXR_getProdInfo( "Extr4rvw", NULL, prdPath );
  	if (status != OM_S_SUCCESS)
  	{
		fprintf(ptr," Error finding Extract for Review product ..\n"); 
		UI_status(" Error finding Extract for Review product.... "); 
		goto quit;
  	}

	/*
	 * Make sure that we are connected to the server through postman
	 * before processing the extraction. 
	 */
	status = verify_connect_postman( &retCode );
	__CheckRC( retCode, status, "verify_connect_postman", quit );

	/*
	 * Determine which aim server we are connected to.
	 * It must be SIR for now.
	 */
	status = determine_AIM( &retCode );
	__CheckRC( retCode, status, "determin_AIM", quit );


	/*
	 * Verify that the Default Aim Data is set on the file.
	 * If it is set, then get the context id from the collector.
	 */
	status = get_ctx_id( &retCode );
	__CheckRC( retCode, status, "get_ctx_id", quit );
	
	/*
	 * Verify that the Default Aim Data is set on the file.
	 * If it is set, then get the context id from the collector.
	 */
	status = get_file_info( &retCode );
	__CheckRC( retCode, status, "get_file_info", quit );

	/*
	 * Verify that the Default Aim Data is set on the file.
	 * If it is set, then get the context id from the collector.
	 */
	status = get_server_name( &retCode );
	__CheckRC( retCode, status, "get_server_name", quit );

	/*
	 * Extract the file.
	 */
	status = extract_files( &retCode );
	__CheckRC( retCode, status, "extract_files", quit );
 
	/*
	 * copy extracted files to the exported work location.
	 */
	status = ftp_files_to_aim_wl( &retCode );
	__CheckRC( retCode, status, "ftp_files_to_aim_wl", quit );
 
	/*
	 * Send command to AIM to register, reference, and 
	 * transfer the extracted object to a vault within AIM.
	 */
	status = post_files( &retCode );
	__CheckRC( retCode, status, "post_files", quit );

   	/*
	 * remove the .dri file that from the exported dir.  It was
 	 * not removed because of a symbolic link between it and DRV.
	 * However the transfer process make a local copy of the file
	 * into the vault location in DM2.
	status = remove_dri_file( &retCode );
	__CheckRC( retCode, status, "remove_dri_file", quit );
	 */ 


quit:

	if(status != OM_S_SUCCESS)
        {
          fprintf(ptr, "Process Terminated.....\n");
          UI_status( "Process Terminated.....");
        }
        else
        {
	  fprintf( "Process Complete.......\n" );
	  UI_status( "Process Complete......." );
        }

        fclose(ptr);
        ptr = NULL;

}
