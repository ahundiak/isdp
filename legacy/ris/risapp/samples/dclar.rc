/*
** Copyright 1993, Intergraph Corporation, All Rights Reserved
*/

/*
**  ========================================================================
**
**  File        : dclar.rc
**
**  Purpose     : This program generates "declare table" and "declare view"
**     			  statements for existing schema tables and views.
**
**     		      Output (SQL statements) are written to standard output.
**  		      Errors are written to standard error.
**
**  ========================================================================
*/
 
/*
**	INCLUDES
*/
#include <stdio.h>
#include <string.h>
#include <sys/types.h> 
#include <stdlib.h> 
#if defined(__hpux__)
#include <ctype.h>
#endif
#include "rislimit.h"  
#include "ris.prt"
/*
**	DEFINES
*/
#define TYPE_TABLE	0
#define TYPE_VIEW	1
#define TYPE_BOTH	2
#define VERIFY_PARTIAL	0
#define VERIFY_FULL	1
#define VERIFY_NONE	2

/*
**	VARIABLES
*/
exec sql begin declare section;
	char table_type[2];
	long  i_table_type;
	char table_name[32];
	long  i_table_name;
	char column_name[32];
	long  i_column_name;
	int	position;
	long  i_position;
	int ris_type;
	long  i_ris_type;
	int length;
	long  i_length;
	int prec;
	long  i_prec;
	int scale;
	long  i_scale;
	char nullable[4];
	long  i_nullable;
	char *err_ptr;

	char type1;
	char type2;
exec sql end declare section;

char verify_option = 'n';
char object_option = 'b';	
int  stmt_started  = 0;

int cur_type = TYPE_BOTH;
int cur_verify =VERIFY_NONE;
char sname[255];

/*
**	FUNCTIONS
*/
static int get_prompts(char *value1,char *value2);

/*****************************************************************************/
/*
** If anything goes wrong, print out the error.
*/
extern void dump_error()
{
    exec sql report error into :err_ptr;
    printf(err_ptr);
    RISterminate(); 
}


/*****************************************************************************/

/*
** Terminate a declare table/view statement:	");"
*/
extern void end_statement()
{

	/*
	** There may have been no tables/views for this schema, so there
	** may not be a statement in progress.
	** We also call this before the first begin-stmt, so we may
	** not be in a statement for that reason.
	*/
	if (!stmt_started)
        {
          return;
        }
	
	switch(verify_option)
	{
		case 'p':
			printf(") with partial verify;\n");
			break;
		case 'f':
			printf(") with verify;\n");
			break;
		case 'n':	
			printf(");\n");
			break;
	}
	stmt_started = 0;

}

/*****************************************************************************/

/*
** Begin a declare table/view statement: 
**
**		"declare table/view  name ( "
*/
extern void begin_statement(
	char *schema, 
	char *name, 
	char  type)
{
	printf("\n");
	printf("declare %s %s.%s (\n    ", type == 'T' ? "table" : "view",
		schema, name);
	stmt_started = 1;

}

/*****************************************************************************/

/*
** Add a column definition to a statement.
** Every column is put on a new line, preceded by 4 spaces.
*/
extern void add_column(
	char *column_name, 
	int  ris_type, 
	int  length, 
	int  prec, 
	int  scale, 
	char null,
	int  first_column)
{

	if (!first_column)
		printf(",\n    ");

	printf("%s ", column_name);

	switch (ris_type)
	{
		case RIS_CHARACTER:
			printf("char(%d)", length);
			break;

		case RIS_DECIMAL:
			printf("decimal(%d,%d)",prec,scale);
			break;

		case RIS_INTEGER:
			printf("integer");
			break;
		
		case RIS_SMALLINT:
			printf("smallint");
			break;
		
		case RIS_REAL:
			printf("real");
			break;
		
		case RIS_DOUBLE:
			printf("double");
			break;
		
		case RIS_TIMESTAMP:
			printf("timestamp");
			break;

		case RIS_BLOB:
			printf("blob");
			break;

		case RIS_TEXT:
			printf("text");
			break;

		default:
			printf("unsupported");
	}

	if (null == 'N')
	{
		printf(" NOT NULL");
	}

}

/*****************************************************************************/

/*
**	This routine fetches all table/view information for a schema
**  and calls the routines to generate declare statements.
**
**  There is only one execution of the query, ordered so as to get
**  the column information in the correct order.  A change in
**  column number is used to indicate the beginning of the next table/view.
*/
extern int dump_schema(
	char *schema_name)
{
	int first_column = 1;	/* flag to determine if starting a new column */
	int last_position = 9;	/* anything > 1 to start out */


	/*
	** Select from ris5tables/ris5columns.
	**
	** Do not fetch the definitions for the RIS dictionary tables
	** because it is illegal (and unnecessary) to declare a 
	** dictionary table or view.
	*/

	exec sql declare c1 cursor for 
		select t.table_type, t.table_name, 
			   c.column_name, c.position,
			   c.ris_type, c.char_max_length, 
			   c.prec, c.scale, c.nullable
        from ris5tables t, ris5columns c
		where t.table_name = c.table_name
			and t.table_name not like 'ris%'
			and t.table_type in (:type1,:type2)
		order by t.table_type, t.table_name, 
				 c.position;

	if (SQLCODE)
	{
		dump_error();
		return(-1);
	}

	switch (object_option)
	{
		case 't':
			type1 = 'T';
			type2 = 'T';
			break;
		case 'v':
			type1 = 'V';
			type2 = 'V';
			break;
		case 'b':
			type1 = 'T';
			type2 = 'V';
			break;
	}

	exec sql open c1;

	if (SQLCODE)
	{
		dump_error();
		return(-1);
	}


	while (1)
	{
		exec sql fetch c1 into 
			:table_type:i_table_type, 
			:table_name:i_table_name,
			:column_name:i_column_name,
			:position:i_position,
			:ris_type:i_ris_type,
			:length:i_length,
			:prec:i_prec,
			:scale:i_scale,
			:nullable:i_nullable;

		if (SQLCODE == END_OF_DATA)
			break;

		if (SQLCODE)
		{
			dump_error();
			return(-1);
		}


		if (position <= last_position)
		{
			end_statement();
			begin_statement(schema_name, table_name, table_type[0]);
			first_column = 1;
		}

		add_column(column_name, ris_type, length, prec, scale, nullable[0],
			first_column);

		last_position = position;
		first_column = 0;
	}

	end_statement();
	first_column = 1;
	
	exec sql close c1;

	if (SQLCODE)
	{
		dump_error();
		return(-1);
	}


	return(0);
}

/*****************************************************************************/


/*
** Main.  Loop through the schemas, processing each one.
*/

exec sql begin declare section;
	char connection[80];
exec sql end declare section;

extern int main(
	int argc,
	char *argv[])
{
	int		i;
	char	*c;
	char	schema[64];
	int total;
	char schpass[255];
	char value1[255],value2[255];
	int err;

    printf("****************************************************************\n");
	printf("  This program generates \"declare table\" and \"declare view\" \n");
    printf("     statements for existing schema tables and views. \n");
    printf("****************************************************************\n");
	strcpy(sname,"");
again:
	total = 3;
	if (get_prompts(value1,value2) ==1)
	{
		exit(0);
	}

	/*
	** Schema processing loop
	*/
	for (i=1; total--; ++i)
	{
		switch (i)
		{
			case 1:
				strcpy(schpass,value1);
				break;
			case 2:
				strcpy(schpass,value2);
				break;
			case 3:
				strcpy(schpass,sname);
	 			break;
		}
		if (schpass[0] == '-')
		{
			switch(schpass[1])
			{
				case 't':
				case 'v':
				case 'b':
					object_option = schpass[1];
					break;

				case 'p':
				case 'f':
				case 'n':	
					verify_option = schpass[1];
					break;

				default:
					printf("Unknown option %s ",schpass[1]);
			}
			continue;
		}
		/*
		** Scan the schema from a possible "schema.password"
		*/

		sscanf(schpass, "%s", schema);
		c = strchr(schema,'.');
		if (c)
		{
			*c = '\0';
		}

		/*
		** connect
		*/
		sprintf(connection,"default schema %s", schpass);
		exec sql execute immediate :connection;
		if (SQLCODE)
		{
		        dump_error();
			goto again;

		}

		/*
		** process this schema
		*/
		err = dump_schema(schema);
		if (err != -1)
		{
			/*
			** disconnect
			*/
			sprintf(connection,"close schema %s", schema);
			exec sql execute immediate :connection;
			if (SQLCODE)
			{
				dump_error();
			}
		}
	}
	RISterminate(); 
	goto again;
}


/******************************************************************************/
static int get_prompts(
	char *type_flag,
	char *verify_flag)
{
	int i;
	char wrk[255];
          /* these arrays were dimensioned to only 3 char */
	char types[4],verifies[4];

	strcpy(types,"tvb");
	strcpy(verifies,"pfn");

 
	while (1)
	{
		printf("\n\n");

		printf(" 1) Types <t>able <v>iew <b>oth ...");
		printf("[%c]\n",types[cur_type]);

		printf(" 2) Verify <p>artial <f>ull <n>one ");
       	        printf("[%c]\n",verifies[cur_verify]);


		printf(" 3) Schema Name.Password ...........");
		printf("[%s]\n\n",sname);


		printf(" 4) Execute Program\n");
		printf(" 5) Exit program\n");
		printf("\n   Enter your choice: ");

		gets(wrk);
		i = atoi(wrk);
		printf("\n\n");

		switch (i)
		{
			case 1:
				printf("Types <t>able <v>iew <b>oth: [%c]",types[cur_type]);
				gets(wrk);
				if (strcmp(wrk,"")!=0)	
				{
					if (isupper(wrk[0])) wrk[0] = _tolower(wrk[0]);
					if (wrk[0] == 't')
						cur_type = TYPE_TABLE;
					else if (wrk[0] == 'v')
						cur_type = TYPE_VIEW;
					else if (wrk[0] == 'b')
						cur_type = TYPE_BOTH;
					else
					{
						printf("\n\n");
						printf("Valid responses are 't', 'v', or 'b'\n");
					}
					break;
				}
				else
					break;

			case 2:
				printf("Verify <p>artial <f>ull <n>one: [%c]",verifies[cur_verify]);
				gets(wrk);
				if (strcmp(wrk,"")!=0)	
				{
					if (isupper(wrk[0])) wrk[0] = _tolower(wrk[0]);
					if (wrk[0] == 'p')
						cur_verify = VERIFY_PARTIAL;
					else if (wrk[0] == 'f')
						cur_verify = VERIFY_FULL;
					else if (wrk[0] == 'n')
						cur_verify = VERIFY_NONE;
					else
					{
						printf("\n\n");
						printf("Valid responses are 'p', 'f', or 'n'\n");
					}
					break;
				}
				else
					break;
			case 3:
				printf("Schema Name.Password: [%s]",sname);
				gets(wrk);
				if (strcmp(wrk,"")!=0)	
				{
					strcpy(sname,wrk);
				 	break;
				}
				else 
				{
					printf("\n\n");
			        	printf("No schema name.password entered.\n");
					break;
				}

			case 4:
				if (strcmp(sname,"")==0)
				{
			        	printf("No schema name.password entered.\n");
					break;
				}
				else
				{
					switch (cur_type)
 					{
						case TYPE_TABLE:
							strcpy(type_flag,"-t");
							break;
						case TYPE_VIEW:
							strcpy(type_flag,"-v");
							break;
						case TYPE_BOTH:
							strcpy(type_flag,"-b");
							break;
					}
					switch (cur_verify)
					{
						case VERIFY_PARTIAL:
							strcpy(verify_flag,"-p");
							break;
						case VERIFY_FULL:
							strcpy(verify_flag,"-f");
							break;
						case VERIFY_NONE:
							strcpy(verify_flag,"-n");
							break;
					}
				}
				return(0);
   			case 5:
                                return(1);
		}/* switch i */
	}/* while (1) */
}
/******************************************************************************/
