/*
**	NAME:							clsmain.rc
**  AUTHORS:						Dan Karier
**  CREATION DATE:					Feb 1991 
**	ABSTRACT:
**	
**	REVISION HISTORY:
*/

/*
**	INCLUDES
*/
#if defined(WIN32S)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#endif
#if !defined(WIN32S)
#include <stdio.h>
#endif
#include <ctype.h>
#include "rislimit.h"
#include "risver.h"
#include "risutl.h"
#include "risstjmp.h"
#include "userver.h"
#include "utl_err.h"
#include "utl_inf.h"
#if defined(WIN32S)
#include "prog32s.h"
#endif 


/*
**	DEFINES
*/
#ifdef NO_CLS_DBG
#define CLS_DBG(s)
#else
#define CLS_DBG(s)	if (RIScls_debug) {RIScom_output_debug s;}
#endif
#define STRING(s) ((s)?(s):"NULL")

#define BATCH		0
#define INTERACTIVE	1


/*
**	TYPES
*/

/*
**	FUNCTION PROTOTYPES
*/
#define clsmain_rc
#include "clsmain.prt"
#include "comdebug.prt"
#include "comjmp.prt"
#include "comumsg.prt"
#include "ucodebug.prt"
#include "ucodesch.prt"
#include "ucoerrbx.prt"
#include "ucoumsg.prt"
#include "usvclnsr.prt"
#if defined(WIN32) || defined(DOS)
#include "ucogtopt.prt"
#elif defined(unix)
#else
ERROR NO CODE
#endif
#include "ris.prt"
#include "sys.prt"
#if defined(WIN32S)
#include "btcerrbx.prt"
#endif

/*
**	VARIABLES
*/
int	RIScls_debug = 0;
debug_info_s debug_info[] =
{
	{ "cls", 3, &RIScls_debug },
	{ "usv", 3, &RISusv_debug }
};
int debug_count = sizeof(debug_info)/sizeof(debug_info_s);

exec sql begin declare section;
	char	sqlstring[512];
exec sql end declare section;


/*
**	FUNCTIONS
*/

/******************************************************************************/

static int RisError()
{
	int return_sts;
	exec sql begin declare section;
		char	*err_ptr;
	exec sql end declare section;

	CLS_DBG(("RisError()\n"));

	if (risca->sqlcode != RIS_SUCCESS)
	{ 
   		exec sql report error into :err_ptr;
   		PUTS(err_ptr);
	}
	return_sts = risca->sqlcode == RIS_SUCCESS ? 0 : 1;

	CLS_DBG(("RisError:returning %d\n", return_sts));
	return return_sts;
}

/******************************************************************************/

static void head()
{
	CLS_DBG(("head()\n"));

	PRINTF(MSG(RISUTL_I_CLNSR_HEAD1));
	PRINTF(MSG(RISUTL_I_CLNSR_HEAD2));
	PRINTF(MSG(RISUTL_I_CLNSR_HEAD3));

	CLS_DBG(("head:returning\n"));
}

/*****************************************************************************/

static void success()
{
	CLS_DBG(("success()\n"));

	PRINTF(MSG(RISUTL_I_CLNSR_TAIL));

	CLS_DBG(("success:returning\n"));
}

/******************************************************************************/

static void DoVersion()
{
	CLS_DBG(("DoVersion()\n"));

	/*PRINTF(MSG(RISUTL_I_COPYRIGHT));*/
	/* 1996.03.12:Alan Barksdale:TR439600483 */
	PRINTF(MSG(RISUTL_I_BEGIN_COPYRIGHT));
	PRINTF(" ");
	PRINTF(COPYRIGHTYEAR);
	PRINTF(", ");
	PRINTF(MSG(RISUTL_I_END_COPYRIGHT));
	PRINTF(MSG(RISUTL_I_CLNSR_UTILITY), RIS_version);

	CLS_DBG(("DoVersion:returning\n"));
}

/******************************************************************************/

static void DoUsage()
{
	CLS_DBG(("DoUsage()\n"));

	PRINTF(MSG(RISUTL_I_5CLNSR_USAGE_1));
	PRINTF(MSG(RISUTL_I_CLNSR_USAGE_2));
	PRINTF(MSG(RISUTL_I_CLNSR_USAGE_3));
	PRINTF(MSG(RISUTL_I_CLNSR_USAGE_4));
	PRINTF(MSG(RISUTL_I_CLNSR_USAGE_5));
	PRINTF(MSG(RISUTL_I_CLNSR_USAGE_6));

	CLS_DBG(("DoUsage:returning\n"));
}

/******************************************************************************/

static void close_schema(
	char *schname)
{
	CLS_DBG(("close_schema()\n"));

	if (schname && *schname)
	{
		sprintf(sqlstring, "close schema %s\n", schname);
		exec sql execute immediate :sqlstring;
		/* ignore errors */
	}

	CLS_DBG(("close_schema:returning\n"));
}

/******************************************************************************/

static int clean_server()
{
	int return_sts = 0;
	char schname[RIS_MAX_ID_SIZE];
	ris_db_info *db = NULL;

	CLS_DBG(("clean_server()\n"));

	RISget_default_schema_name(schname);
	if (RisError())
	{
		return_sts =  1;
	}
	else
	{
		CLS_DBG(("clean_server:schname:<%s>\n", STRING(schname)));

		RISget_schema_info(schname, NULL, &db, NULL);
		if (RisError())
		{
			return_sts = 1;
		}
		else
		{
			CLS_DBG(("clean_server:dtype:<%c>\n", db->dtype));

			RISusv_clean_server(schname, db->dtype);
			if (RisError())
			{
				return_sts = 1;
			}

			close_schema(schname);
		}
	}

	CLS_DBG(("clean_server:returning:%d\n", return_sts));
	return return_sts;
}

/******************************************************************************/

extern int main(
	int		argc,
	char	*argv[])
{
	int c;
	int mode;
	int	status;
	char *schnamepass = NULL;
	char *usrnamepass = NULL;
	char *osunamepass = NULL;
    
#if defined(WIN32S)
	char about[128];
#endif

        RISint_process_debug ("+clnsr") ;

	if (RISload_dll())
	{
#if defined(WIN32S)
		DestroyWindow(winio_current());
		winio_end();
#endif
		return(1);
	}

	status = SETJMP();
	if (status)
	{
		RESETJMP();

#if defined(WIN32S)
		RIS32s_file_error_box(RISUTL_I_CLNSR_ERROR,0,status,NULL,0,1);
#else
		RISuco_file_error_box(stdout, RISUTL_I_CLNSR_ERROR,0,status,NULL,0,1);
#endif
		PRINTF(CHECK_UNINIT_MSG(RISUTL_I_CLNSR_COULD_NOT_INIT,
			"RIS Clean Server Utility could not initialize... Bye\n"));
		RISterminate();
 		return(1);
	}

	RISuco_initialize_debug(debug_info, debug_count);

	RISuco_initialize_ums(INIT_UTL_UMS_FILE|INIT_RIS_UMS_FILE);

	RESETJMP();

#if defined(WIN32S)
	winio_setfont(winio_current(),ANSI_FIXED_FONT);
	sprintf(about,MSG(RISUTL_I_CLNSR_UTILITY), RIS_version);
	winio_about(about);
#endif

	if ((c = getopt(argc, argv, "V?")) != -1)
	{
		switch(c)
		{
			case 'V':
				DoVersion();
				return(0);
			case '?':
				DoUsage();
				head();
				return(0);
			default:
				DoUsage();
				return(1);
		}
	}

#if defined(WIN32)
	/*
	** The if statements were added to fix TR # 439502826.
	** The version and usage option was added. GBF (9/27/95)
	*/
	if (argc == 2)
	{
		if (!strcmp(argv[1],"/V"))
		{
			DoVersion();
			return(0);
		} 
		else if (!strcmp(argv[1],"/?"))
		{
			DoUsage();
			head();
			return(0);
		} 
	}
#endif

	switch(argc)
	{
		case 1:
			mode = INTERACTIVE;
			break;

		case 2:
			mode = BATCH;
			schnamepass = argv[1];
			break;

		case 3:
			mode = BATCH;
			schnamepass = argv[1];
			usrnamepass = argv[2];
			break;

        /* for secure schemas on db's which require distinct os and db
           usrername/passwd is required */
        case 4:   
           mode = BATCH;
           schnamepass = argv[1];
           usrnamepass = argv[2];
           osunamepass = argv[3];
           break; 

		default:
			DoUsage();
			return(1);
	}

	if (mode == INTERACTIVE)
	{
		CLS_DBG(("risclnsr: mode == INTERACTIVE\n"));

		head();
		while(1)
		{
			if (RISuco_default_schema(1))
			{
				break;
			}
			if (RisError())
			{
				continue;
			}

			if (clean_server())
			{
				continue;
			}

			success();
		}
	}
	else 
	{
		char *dot;
		char *schname = "";
		char *schpass = "";
		char *usrname = "";
		char *usrpass = "";
        char *osuname = "";
        char *ospass  = "";

		CLS_DBG(("risclnsr: mode == BATCH\n"));

		schname = schnamepass;
		if ((dot = strchr(schnamepass, '.')) != NULL)
		{
			*dot++ = '\0';
			schpass = dot;
		}

		if (usrnamepass)
		{
			usrname = usrnamepass;
			if ((dot = strchr(usrnamepass, '.')) != NULL)
			{
				*dot++ = '\0';
				usrpass = dot;
			}
		}

        if ( osunamepass )
        {
           osuname = osunamepass;
           if ( (dot = strchr(osunamepass, '.')) != NULL ) 
           {
              *dot++ = '\0';
              ospass = dot;
           }
        }


		if ((*schpass != '\0' || *usrname != '\0') && strlen(osuname) < 1 )
		{
			RISuco_declare_schema_str(schname, schpass, usrname, usrpass,
				"", "", sqlstring, sizeof(sqlstring));

			exec sql execute immediate :sqlstring;
			if (RisError())
			{
				RISterminate();
				return 1;
			}
		}
        /* declare a secure schema on db requiring dbuser/passwd */
        else if ((*schpass != '\0' || *usrname != '\0') && strlen(osuname) >= 1)
        {
           RISuco_declare_schema_str(schname, 
                                     schpass,
                                     usrname,
                                     usrpass, 
                                     osuname,
                                     ospass,
                                     sqlstring, 
                                     sizeof(sqlstring) );

           exec sql execute immediate :sqlstring;
             
           if ( RisError() )
           {
              RISterminate();
              return 1;
           }
        }      

		sprintf(sqlstring, "default schema %s", schnamepass);
		exec sql execute immediate :sqlstring;
		if (RisError())
		{
			RISterminate();
#if defined(WIN32S)
	winio_end();
#endif
			return 1;
		}

		if (clean_server())
		{
			RISterminate();
#if defined(WIN32S)
	winio_end();
#endif
			return 1;
		}

		success();
	}
	
	RISterminate();
#if defined(WIN32S)
	winio_end();
#endif

	return 0;
}

/******************************************************************************/
