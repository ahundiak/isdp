/* Do not alter this SPC information: $Revision: 1.2.13.1 $ */
/*
**	NAME:				lodinxdf.rc								
**	AUTHORS:			Jennifer Xia			
**	CREATION DATE:		June 26, 1990			
**	ABSTRACT:			It contains a function which processes a create index
**						statement.  It also contains three other functions
**						which process those index deinitions stored in a 
**						temporary file.
**	REVISION HISTORY:	August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#if defined(WIN32S) && defined(ULD_EXE)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#include "risutl.h"
#include "prog32s.h"
#endif 

#include "ris_err.h"

#ifdef MM
#include "lod.h"
#endif

exec sql include "lod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define lodinxdf_rc
#include "sys.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "loddmp.prt"
#include "lodmisc.prt"
#include "lodermsg.prt"
#include "lodgtstm.prt"
#include "lodinxdf.prt"
#include "lodlogdp.prt"
#include "lodtime.prt"
#include "ucoerrbx.prt"


extern indx_node_type	*RISlod_proc_create_indx(
	char			*sch_name,
	char			*indx_tab,
	char			*indx_name,
	int 			indx_select,
	indx_node_type 	*indx_header,
	FILE			*indx_tfp)
{

	indx_node_type	*RISlod_insert_to_indx_list();

	exec sql begin declare section;
		char	*err_ptr;
	exec sql end declare section;

	LOD_DBG(("RISlod_proc_create_indx: sch_name <%s>, indx_tab <%s> indx_name <%s>\n",sch_name, indx_tab, indx_name));
	LOD_DBG(("\tindx_select <%c> indx_header 0x%x \n",
						indx_select, indx_header));

	if (RISlod_lod_or_dmp_indx(sch_name, 
							   indx_tab, 
							   indx_select) == DUMP)
	{
		LOD_DBG(("1. RISlod_proc_create_indx: end"));
		return(indx_header);
	}

	/*
	**	Table may not be create yet and this message will be repeated later on
	**	RISlod_print_msg(MSG(RISUTL_E_LOADING_INDEX), indx_tab);
	*/

	exec sql execute immediate :RISlod_sql_stmt;

	if (SQLCODE < 0)
	{
		if (SQLCODE == RIS_E_UNKNOWN_RELATION)
		{
			indx_header = RISlod_insert_to_indx_list(indx_name,
													 indx_tab,
													 indx_header, 
													 indx_tfp,
													 NO);
			LOD_WARNING_CHECK(indx_header->sqlwarnings);
			LOD_DBG(("2. RISlod_proc_create_indx: end"));
			return(indx_header);
		}
		else
		{
			/* to pass back more info later on */
			indx_header = RISlod_insert_to_indx_list(indx_name,
													 indx_tab,
													 indx_header, 
													 indx_tfp,
													 YES);

			RISlod_dump_to_bad_with_err(RISlod_sql_stmt);
			if( RISlod_mode != EMBED )
			{
				exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
				PUTS(err_ptr);
#endif
			}

			indx_header->ris_err_code = risca->sqlcode;
			indx_header->db_err_code = dbca->sqlcode;
			LOD_WARNING_CHECK(indx_header->sqlwarnings);

			LOD_DBG(("3. RISlod_proc_create_indx: end"));
			return(indx_header);
		}
	}
	else
	{		
		RISlod_print_msg(MSG(RISUTL_E_LOADED_INDEX), 
				indx_name, indx_tab);
		RISlod_indx_loaded++;
		indx_header = RISlod_insert_to_indx_list(indx_name,
												 indx_tab,
												 indx_header, 
												 indx_tfp,
												 YES);
		LOD_DBG(("4. RISlod_proc_create_indx: end"));
		return(indx_header);
	}
}


extern indx_node_type *RISlod_insert_to_indx_list(
	char			*indx_name,
	char			*indx_tab,
	indx_node_type	*indx_header,
	FILE			*indx_tfp,
	int				processed)
{

	indx_node_type	*pre_indx_header;
	long			ftell();
	
	LOD_DBG(("RISlod_insert_to_indx_list: indx_name <%s> indx_tab <%s> indx_header 0x%x indx_tfp 0x%x\n", 
						indx_name, indx_tab, indx_header, indx_tfp));

	pre_indx_header = indx_header;
	indx_header = (indx_node_type *) calloc(1, sizeof(indx_node_type));
	CHK_MEM_ALLOC_ERR(indx_header)
	
	strcpy(indx_header->indx_name, indx_name);
	strcpy(indx_header->indx_tab, indx_tab);
	indx_header->processed = processed;

	indx_header->offset = ftell(indx_tfp);
	indx_header->ris_err_code = 0;
	indx_header->db_err_code = 0;
	if (FPUTS(RISlod_sql_stmt, indx_tfp) == EOF) WRITING_FILE_ERR(RISUTL_E_CANT_WRITE_TEMP_FILE) 

	indx_header->link = pre_indx_header;

	LOD_DBG(("indx_header = %d\n", indx_header));	
	LOD_DBG(("indx_name = <%s>\n", indx_header->indx_name));
	LOD_DBG(("indx_tab = <%s>\n", indx_header->indx_tab));
	LOD_DBG(("processed = <%d>\n", indx_header->processed));
	LOD_DBG(("offset = <%ld>\n", indx_header->offset));
	LOD_DBG(("ris_err_code = <%ld>\n", indx_header->ris_err_code));
	LOD_DBG(("db_err_code = <%ld>\n", indx_header->db_err_code));
	LOD_DBG(("RISlod_sql_stmt = <%s>\n", RISlod_sql_stmt));
	LOD_DBG(("indx_header->link = %d\n", indx_header->link));	
	
	LOD_DBG(("1. RISlod_insert_to_indx_list: end"));
	return(indx_header);
}


extern void RISlod_proc_indx_list(
	indx_node_type 	*indx_header,
	FILE			*indx_tfp)
{
	
	indx_node_type	*node_ptr;
	indx_node_type	*post_node_ptr;

	exec sql begin declare section;
		char	*err_ptr;
	exec sql end declare section;

	LOD_DBG(("RISlod_proc_indx_list: indx_header 0x%x indx_tfp 0x%x\n", 
						indx_header, indx_tfp));

	for(node_ptr = indx_header; node_ptr != NULL; node_ptr = post_node_ptr)
	{
		post_node_ptr = node_ptr->link;
		if(node_ptr->processed == NO)
		{
			fseek(indx_tfp, node_ptr->offset, 0);
			RISlod_indx_from_tfile(indx_tfp);
			LOD_DBG(("RISlod_sql_stmt = <%s>\n", RISlod_sql_stmt));

			exec sql execute immediate :RISlod_sql_stmt;

			LOD_WARNING_CHECK(node_ptr->sqlwarnings);

			if (SQLCODE < 0)
			{
				if( RISlod_mode != EMBED)
				{
					exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
					PUTS(err_ptr);
#endif
				}
	
				RISlod_dump_to_bad_with_err(RISlod_sql_stmt);
				/* strcpy sqlcode */
				node_ptr->ris_err_code = risca->sqlcode;
				node_ptr->db_err_code = dbca->sqlcode;

			}
			else
			{		
				RISlod_print_msg(MSG(RISUTL_E_LOADED_INDEX), 
						node_ptr->indx_name, node_ptr->indx_tab);
				RISlod_indx_loaded++;
			}

		} /* processed */
	} /* for */

	LOD_DBG(("1. RISlod_proc_indx_list: end\n"));
}


extern void RISlod_free_indx_header(
	indx_node_type *indx_header)
{
	indx_node_type *node_ptr;
	indx_node_type *post_node_ptr;

	for(node_ptr = indx_header; node_ptr != NULL; node_ptr = post_node_ptr)
	{
		post_node_ptr = node_ptr->link;
		free(node_ptr);
	}
}
