/* Do not alter this SPC information: $Revision: 1.2.13.1 $ */
/*
**	NAME:					loddstab.rc
**	AUTHORS:				Hitesh Patel		
**	CREATION DATE:			30th May, 1991		
**	ABSTRACT:				These functions passes information between risloddes**							descriptor and RISlod_ptr_struct_ptr relating to 
**							table only.
**	
**	REVISION HISTORY:
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#ifdef MM
#include "lod.h"
#endif

exec sql include "lod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define loddstab_rc
#include "sys.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "comumsg.prt"
#include "lodmisc.prt"
#include "loddstab.prt"
#include "lodermsg.prt"
#include "lodstspc.prt"
#include "lodtime.prt"



extern int RISlod_tab_select_mode_ALL(
	risloddes		*risloddes_ptr,
	int				schindx,
	int				num_tab)
{
	int					tabindx;
	rislodsch			*rislodsch_ptr;
	rislodtab			*rislodtab_ptr;
	batch_tnode_type	*btnode_ptr;

	LOD_DBG(("RISlod_tab_select_mode_ALL! risloddes_ptr: 0x%x schindx: <%d> num_tab: <%d>\n",risloddes_ptr,schindx,num_tab));

	rislodsch_ptr = risloddes_ptr->schemas+schindx;
	rislodsch_ptr->tabinfo.table_count = num_tab;

	if( num_tab == 0 )
		return(SUCCESS);

	rislodtab_ptr = (rislodtab *) calloc(num_tab,sizeof(rislodtab));
	CHK_MEM_ALLOC_ERR(rislodtab_ptr);

	for( tabindx = 0, btnode_ptr = RISlod_ptr_struct_ptr->bsnode_ptr->bthlink->btlink;
			(tabindx < num_tab) && (btnode_ptr != NULL);
				tabindx++, btnode_ptr = btnode_ptr->btlink )
	{
		strcpy(rislodtab_ptr[tabindx].tabname,btnode_ptr->tab_name);
		rislodtab_ptr[tabindx].rows_loaded = btnode_ptr->rowsdonewith;
		rislodtab_ptr[tabindx].err_rows = (btnode_ptr->totalrows) - (btnode_ptr->rowsdonewith);
		rislodtab_ptr[tabindx].lod_err_code = btnode_ptr->lnd_err_code;
		rislodtab_ptr[tabindx].ris_err_code = btnode_ptr->ris_err_code;
		rislodtab_ptr[tabindx].db_err_code = btnode_ptr->db_err_code;
		strncpy(rislodtab_ptr[tabindx].sqlwarnings,btnode_ptr->sqlwarnings,8);
	}

	rislodsch_ptr->tabinfo.tables = rislodtab_ptr;

	LOD_DBG(("1. RISlod_tab_select_mode_ALL! END.\n"));
	return(SUCCESS);
}


extern void RISlod_tab_select_mode_SOME(
	risloddes		*risloddes_ptr,
	int				schindx)
{
	int			tabindx;
	rislodsch	*rislodsch_ptr;

	LOD_DBG(("RISlod_tab_select_mode_SOME! risloddes_ptr: 0x%x schindx: <%d>\n",risloddes_ptr,schindx));

	rislodsch_ptr = risloddes_ptr->schemas+schindx;

	for(tabindx = 0; tabindx < rislodsch_ptr->tabinfo.table_count; tabindx++)
	{
		if( !CHECK_ID_SIZE_OK(
			strlen(rislodsch_ptr->tabinfo.tables[tabindx].tabname),
			RIS_MAX_ID_SIZE) )	
		{ 	
			rislodsch_ptr->lod_err_code = RISUTL_E_INVALID_ID_SIZE;
			TERMINATE_RISLOAD
		}
		RISlod_create_btnode(rislodsch_ptr->tabinfo.tables[tabindx].tabname);
	}

	LOD_DBG(("1. RISlod_tab_select_mode_SOME! END.\n"));
}


extern void RISlod_tab_mode_post(
	risloddes		*risloddes_ptr,
	int				schindx)
{
	int					tabindx;
	rislodsch			*rislodsch_ptr;
	batch_tnode_type	*btnode_ptr;

	LOD_DBG(("RISlod_tab_mode_post! risloddes_ptr: 0x%x schindx: <%d> \n",risloddes_ptr,schindx));

	rislodsch_ptr = risloddes_ptr->schemas+schindx;

	for( tabindx = 0, btnode_ptr = RISlod_ptr_struct_ptr->bsnode_ptr->bthlink->btlink;
			(tabindx < rislodsch_ptr->tabinfo.table_count) && (btnode_ptr != NULL);
				tabindx++, btnode_ptr = btnode_ptr->btlink )
	{
		rislodsch_ptr->tabinfo.tables[tabindx].rows_loaded = btnode_ptr->rowsdonewith;
		rislodsch_ptr->tabinfo.tables[tabindx].err_rows = (btnode_ptr->totalrows) - (btnode_ptr->rowsdonewith);
		rislodsch_ptr->tabinfo.tables[tabindx].lod_err_code = btnode_ptr->lnd_err_code;
		rislodsch_ptr->tabinfo.tables[tabindx].ris_err_code = btnode_ptr->ris_err_code;
		rislodsch_ptr->tabinfo.tables[tabindx].db_err_code = btnode_ptr->db_err_code;
		strncpy(rislodsch_ptr->tabinfo.tables[tabindx].sqlwarnings,
			btnode_ptr->sqlwarnings, 8);
	}

	LOD_DBG(("1. RISlod_tab_mode_post! END.\n"));
}

