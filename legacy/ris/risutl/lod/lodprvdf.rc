/* Do not alter this SPC information: $Revision: 1.3.9.1 $ */
/*
**	NAME:				lodprvdf.rc								
**	AUTHORS:			Jennifer Xia			
**	CREATION DATE:		June 26, 1990			
**	ABSTRACT:			It contains a function which processes grant sta tement.
**						statement from the original grant statement being
**						processed.	
**	REVISION HISTORY:	August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#if defined(WIN32S) && defined(ULD_EXE)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#include "risutl.h"
#include "prog32s.h"
#endif 
#include "comisfn.prt"

#include <ctype.h>
#ifdef MM
#include "lod.h"
#endif

exec sql include "lod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define lodprvdf_rc
#include "sys.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "comstcmi.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "loddmp.prt"
#include "lodermsg.prt"
#include "lodmisc.prt"
#include "lodlogdp.prt"
#include "lodprvdf.prt"
#include "lodprvls.prt"
#include "lodtime.prt"
#include "ucoerrbx.prt"



extern void RISlod_proc_grant_stmt(
	char				*sch_name,
	char				*rel_spec,
	int		 			grant_select,
	grant_hnode_type	*ghnode_ptr,
	FILE				*grant_tfp)
{

	int			gtee_posi;
	int			next_gtee_indx;

	exec sql begin declare section;
		char	*grant_stmt;
		char	*err_ptr;
	exec sql end declare section;

	LOD_DBG(("RISlod_proc_grant_stmt: sch_name <%s> rel_spec <%s>\n", sch_name, rel_spec));
	LOD_DBG(("\tgrant_select <%c> ghnode_ptr 0x%x grant_tfp 0x%x\n",
					grant_select, ghnode_ptr, grant_tfp));

	if (RISlod_lod_or_dmp_grant(sch_name, 
								rel_spec,
								grant_select) == DUMP)
	{
		LOD_DBG(("2. RISlod_proc_grant_stmt: end"));
		return;
	}

	exec sql prepare grant_stmt_id from :RISlod_sql_stmt;

	/*
	** Improve this to have warning in grant section
	*/
	LOD_WARNING_CHECK(RISlod_general_warn);
/*
**  We changed this since the error message structure has been changed to UMS.
**  The parser now sets risca->sqlerrd[5] to 1 if its a parser error.
**  - Sunil 01/09/92
**	if ((RISpar_MAX >= SQLCODE) && (SQLCODE >= RISpar))
*/
	if (risca->sqlerrd[5] == 1)
	{
		RISlod_insert_to_grant_struct(rel_spec, grant_stmt, ghnode_ptr, 
			grant_tfp);
		ghnode_ptr->nlink->processed = YES;

		/*
		** parsing err and there do not process it again but still get it
		** into grant_header list 
		*/
		ghnode_ptr->nlink->ris_err_code = risca->sqlcode;
		if( RISlod_mode != EMBED )
		{
			exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
			PUTS(err_ptr);
#endif
		}

		RISlod_dump_to_bad_with_err(RISlod_sql_stmt);
		exec sql clear grant_stmt_id;
		LOD_WARNING_CHECK(ghnode_ptr->nlink->sqlwarnings);
		LOD_DBG(("1. RISlod_proc_grant_stmt: end"));
		return;
	}

	exec sql clear grant_stmt_id;

	LOD_WARNING_CHECK(RISlod_general_warn);
	gtee_posi = RISlod_form_partial_grant(&grant_stmt);
	next_gtee_indx = gtee_posi;
	
	for(;;)
	{
		next_gtee_indx = RISlod_get_grantee(grant_stmt, 
											gtee_posi, 
											RISlod_sql_stmt, 
											next_gtee_indx);
		LOD_DBG(("grant_stmt = <%s>\n", grant_stmt));

		if (next_gtee_indx == FAILURE)
		{
			break;
		}
		else
		{
			RISlod_insert_to_grant_struct(rel_spec, grant_stmt, ghnode_ptr,
				grant_tfp);

			exec sql execute immediate :grant_stmt;

			LOD_WARNING_CHECK(ghnode_ptr->nlink->sqlwarnings);
			if (SQLCODE < 0)
			{
				ghnode_ptr->nlink->processed = NO;
			}
			else
			{
				ghnode_ptr->nlink->processed = YES;
				RISlod_print_msg(MSG(RISUTL_E_LOADED_PRIVILEGE), rel_spec);
			}
		}
	}

	free(grant_stmt);

	LOD_DBG(("3. RISlod_proc_grant_stmt: end"));
	return;
}


extern int RISlod_form_partial_grant(
	char	**grant_stmt_ptr)
{
	char 	*grant_stmt;
	int		grant_stmt_len;
	int		grant_indxi;
	int		grant_indxj;
	int		gtee_posi;
	int		with_clause_posi;

	LOD_DBG(("RISlod_form_partial_grant: *grant_stmt_ptr 0x%x\n", *grant_stmt_ptr));

	grant_stmt_len = strlen(RISlod_sql_stmt);
	LOD_DBG(("grant_stmt_len = %d\n", grant_stmt_len));

	grant_stmt = (char *) calloc (grant_stmt_len + 1 + RIS_MAX_ID_SIZE, sizeof(char));
	CHK_MEM_ALLOC_ERR(grant_stmt)

	*grant_stmt_ptr = grant_stmt;

	grant_indxi = 15;	/* the minimum length of the string in front of */ 
						/* the keyword <to> in a grant statement */

	for(;;)
	{
		if ((RIScom_strncmp_ic(RISlod_sql_stmt + grant_indxi, "to", 2) == 0) &&
			RIScom_isspace(RISlod_sql_stmt[grant_indxi - 1]) && 
			RIScom_isspace(RISlod_sql_stmt[grant_indxi + 2]))
		{
				break;
		}

		grant_indxi++;
	}
	LOD_DBG(("grant_indxi = %d\n", grant_indxi));

	gtee_posi = grant_indxi + 3;

	for(grant_indxj = 0; grant_indxj < gtee_posi; grant_indxj++)
		grant_stmt[grant_indxj] = RISlod_sql_stmt[grant_indxj];
	LOD_DBG(("grant_indxj = %d, grant_stmt = <%s>\n", grant_indxj, grant_stmt));

	for(grant_indxj = gtee_posi; grant_indxj < grant_stmt_len - 3; grant_indxj++)
	{
		if ((RIScom_strncmp_ic(RISlod_sql_stmt + grant_indxj, "with", 4) == 0) && 
			RIScom_isspace(RISlod_sql_stmt[grant_indxj - 1]) &&
			RIScom_isspace(RISlod_sql_stmt[grant_indxj + 4]))
		{
			with_clause_posi = gtee_posi + RIS_MAX_ID_SIZE;
			strcpy(grant_stmt + with_clause_posi, "with grant option");
			break;
		}
	}

	LOD_DBG(("grant_stmt = <%s>\n", grant_stmt));

	LOD_DBG(("RISlod_form_partial_grant: end"));
	return(gtee_posi);
}


extern int RISlod_get_grantee(
	char	*to_str,
	int		to_indx,
	char	*from_str,
	int		from_indx)
{

	int 	gtee_indxi;
	int		gtee_indxj;
	char	grantee[RIS_MAX_ID_SIZE];
	char	*gtee_ptr;
	int		gtee_name_len;

	LOD_DBG(("RISlod_get_grantee: to_str 0x%x to_indx %d from_str 0x%x from_indx %d\n",
						to_str, to_indx, from_str, from_indx));

	gtee_indxi = from_indx;
	for(;;)
	{
		if (RIScom_isspace(from_str[gtee_indxi]) || (from_str[gtee_indxi] == ','))
			gtee_indxi++;
		else if (from_str[gtee_indxi] == '\0')
		{
			LOD_DBG(("1. RISlod_get_grantee: end"));
			return(FAILURE);
		}
		else
		{
			break;
		}
	}

	for (gtee_indxj = 0; 
				(gtee_indxj < (RIS_MAX_ID_SIZE - 1)) && 
				(! RIScom_isspace(*(from_str + gtee_indxi + gtee_indxj))) &&
				(*(from_str + gtee_indxi + gtee_indxj) != ',') &&
				(*(from_str + gtee_indxi + gtee_indxj) != '\0');  
						gtee_indxj++)
	{
		grantee[gtee_indxj] = *(from_str + gtee_indxi + gtee_indxj);
	}
	grantee[gtee_indxj] = '\0';
		 
	gtee_name_len = strlen(grantee);
	strcpy(to_str + to_indx, grantee);
	for	(gtee_ptr = to_str + to_indx + gtee_name_len; 
				gtee_ptr < to_str + to_indx + RIS_MAX_ID_SIZE; 
						gtee_ptr++)
	{
		*gtee_ptr = ' ';
	}
	
	if (RIScom_strcmp_ic(grantee, "with") == 0)
	{
		LOD_DBG(("2. RISlod_get_grantee: end"));
		return(FAILURE);
	}
	else
	{
		LOD_DBG(("return = %d\n", gtee_indxi + gtee_name_len));
		LOD_DBG(("3. RISlod_get_grantee: end"));
		return(gtee_indxi + gtee_name_len);
	}
}
