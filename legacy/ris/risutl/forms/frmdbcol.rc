/* Do not alter this SPC information: $Revision: 1.1.54.1 $ */
/*
**	NAME:									frmdbcol.rc
**	AUTHORS:								Terry McIntyre
**	CREATION DATE:							11/90
**	ABSTRACT:
**	
**		The code to process the schema info form.
**	
**	REVISION HISTORY:
*/
 
/*
**	INCLUDES
*/
#include "risstjmp.h"
#include "ristypes.h"
#include "forms.h"
exec sql include "rislimit.h";

/*
**	FUNCTION PROTOTYPES
*/
#define frmdbcol_rc
#include "comdebug.prt"
#include "comjmp.prt"
#include "fi.prt"
#include "frmdbcol.prt"
#include "frmerror.prt"
#include "ucosqlca.prt"
#include "ris.prt"
#include "sys.prt"

/*
**	DEFINES
*/
#define ERROR_CHECK \
if (SQLCODE != RIS_SUCCESS)	\
{	\
	FRM_DBG(("SQLCODE:%d\n", SQLCODE));	\
	LONGJMP(RISUTL_E_RIS_ERROR);	\
}

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/******************************************************************************/

static void declare_cursor(
	char	*dbms_owner,
	char	*tabname)
{
	exec sql begin declare section;
		char string[400];
	exec sql end declare section;

	FRM_DBG(("declare_cursor(dbms_owner:<%s> tabname:<%s>)\n",
		STRING(dbms_owner), STRING(tabname)));

	sprintf(string,
		"select position, column_name from ris5dbms_columns where "
		"dbms_owner = '%s' and table_name = '%s' order by position", 
		dbms_owner, tabname);

	FRM_DBG(("preparing statement <%s>\n", string));
	exec sql prepare stmt1 from :string;
	ERROR_CHECK;

	FRM_DBG(("declare cursor\n"));
	exec sql declare curs1 cursor for stmt1;
	ERROR_CHECK;
}

/******************************************************************************/

static void clear_cursor(
	int check_error)
{
	exec sql clear cursor curs1;
	if (check_error)
	{
		ERROR_CHECK;
	}
}

/******************************************************************************/

extern int RISfrm_load_dbms_columns_mcf(
	char	*dbms_owner,
	char	*tabname,
	Form	fp,
	int		mcf_label)
{
	int		sts;
	int		row_count;

exec sql begin declare section;
	int		position;
	char	column_name[RIS_MAX_ID_SIZE];
exec sql end declare section;

	FRM_DBG(("RISfrm_load_dbms_columns_mcf(dbms_owner:<%s> tabname:<%s> fp:0x%x mcf_label:%d)\n", STRING(dbms_owner), STRING(tabname), fp, mcf_label));

	if ((sts = SETJMP()) != 0)
	{
		int stack_sts;

		RESETJMP();

		if ((stack_sts = RISuco_push_risca_dbca()) != RIS_SUCCESS)
		{
			RISfrm_form_errhandle(stack_sts, 0);
			return RIS_forms_error.error;
		}

		clear_cursor(0);

		if ((stack_sts = RISuco_pop_risca_dbca()) != RIS_SUCCESS)
		{
			RISfrm_form_errhandle(stack_sts, 0);
			return RIS_forms_error.error;
		}

		RISfrm_form_errhandle(sts, 0);
		return RIS_forms_error.error;
	}

	declare_cursor(dbms_owner, tabname);

	FRM_DBG(("open cursor\n"));
	exec sql open curs1;
	ERROR_CHECK;

	FRM_DBG(("fetching\n"));
	row_count = 0;
	while (1)
	{
		exec sql fetch curs1 into :position, :column_name;

		if (SQLCODE == END_OF_DATA)
		{
			FRM_DBG(("End of data\n"));
			break;
		}
		ERROR_CHECK;

		FRM_DBG(("column_name:<%s>", column_name));
		FIfld_set_text(fp, mcf_label, row_count, 0, column_name, 0);
		FIfld_set_text(fp, mcf_label, row_count, 1, column_name, 0);

		row_count++;
	}
/*
	FIfld_set_num_rows(fp, mcf_label, row_count);
	FIfld_set_max_num_rows(fp, mcf_label, row_count);
*/

	FRM_DBG(("close cursor\n"));
	exec sql close curs1;
	ERROR_CHECK;

	FRM_DBG(("clear cursor\n"));
	clear_cursor(1);

	RESETJMP();

	CLEAR_ERROR;
	return RIS_SUCCESS;
}

/******************************************************************************/
