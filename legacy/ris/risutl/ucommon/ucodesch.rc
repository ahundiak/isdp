/* Do not alter this SPC information: $Revision: 1.1.53.1 $ */
/*
**	NAME:							ucodesch.rc
**	AUTHORS:						Terrence D. McIntyre
**	CREATION DATE:					1/94
**	ABSTRACT:
**	
**	REVISION HISTORY:
*/
 
/*
**	INCLUDES
*/
#include <ctype.h>
#include "ucommon.h"
#include "utl_inf.h"
#include "ris_err.h"
#include "rislimit.h"
#include "risutl.h"

/*
**	DEFINES
*/

/*
**	TYPES
*/

/*
**	FUNCTION PROTOTYPES
*/
#define ucodesch_rc
#include "comdebug.prt"
#include "comumsg.prt"
#include "ucodesch.prt"
#include "ucofgets.prt"
#include "ucopaswd.prt"
#include "ucosqlca.prt"
#include "ris.prt"
#include "sys.prt"

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/******************************************************************************/

/*
**	Returns 1 if valid schema name, otherwise 0;
*/
extern int RISuco_valid_schname(
	char *schname)
{
	if (!schname)
	{
		return 0;
	}

	if (!isalpha(*schname))
	{
		return 0;	
	}
	schname++;

	while(*schname)
	{
		if (!isalnum(*schname) && *schname != '_')
		{
			return 0;
		}
		schname++;
	}

	return 1;
}

/******************************************************************************/

/*
** Returns 1 if schname is invalid, otherwise returns 0
*/
extern int RISuco_set_default_schema(
	char *schname,	/* input */
	char *schpass,	/* output -- assumming at least RIS_MAX_ID_SIZE */
	char *osusr,	/* output -- assumming at least RIS_MAX_ID_SIZE */
	char *ospass,	/* output -- assumming at least RIS_MAX_ID_SIZE */
        char *dbname,	/* output -- assumming at least RIS_MAX_ID_SIZE */
        char *dbpass)  	/* output -- assumming at least RIS_MAX_ID_SIZE */
{
exec sql begin declare section;
	char default_command[80];
	char declare_command[256];
exec sql end declare section;


	UCO_DBG(("RISuco_set_default_schema()\n"));

	if (!RISuco_valid_schname(schname))
	{
		UCO_DBG(("RISuco_set_default_schema:returning 1\n"));
		return 1;
	}

	sprintf(default_command, "default schema %s", schname);
	exec sql execute immediate :default_command;
	
	if (SQLCODE == RIS_E_NEED_DECLARE_SCHEMA)
	{
		PRINTF(MSG(RISUTL_I_IS_SECURE_SCHEMA), schname);
		/*
		**	Get user name
		*/
		while (!dbname[0])
		{
			PRINTF(MSG(RISUTL_I_ENTER_DBUSR));
#if defined(WIN32S)
                        GETS(dbname);
#else
			RISuco_fgets(dbname, RIS_MAX_ID_SIZE, stdin);
#endif

			if (!dbname[0])
			{
				PRINTF(MSG(RISUTL_I_USER_MUST_BE_SPEC));
			}
		}

		/*
		**	Get user password
		*/
		RISuco_get_password(RIScom_umsg(RISUTL_I_ENTER_DBUSR_PASSWORD),
			dbpass, RIS_MAX_ID_SIZE);

		   RISuco_declare_schema_str(schname, schpass, osusr, ospass,
			dbname, dbpass, declare_command, 
                        sizeof(declare_command));

		exec sql execute immediate :declare_command;

		exec sql execute immediate :default_command;
	        if (SQLCODE == RIS_E_NEED_DECLARE_SCHEMA_OSUSER) 

                {                     /*need os usr/pass */
		   while (!osusr[0])
		   {
			PRINTF(MSG(RISUTL_I_ENTER_OS_USERNAME));
#if defined(WIN32S)
                        GETS(osusr);
#else
			RISuco_fgets(osusr, RIS_MAX_ID_SIZE, stdin);
#endif

			if (!osusr[0])
			{
				PRINTF(MSG(RISUTL_I_USER_MUST_BE_SPEC));
			}
		   }

		   /*
		   **	Get user password
		   */
		   RISuco_get_password(RIScom_umsg(
                           RISUTL_I_ENTER_OS_PASSWORD),ospass, 
                           RIS_MAX_ID_SIZE);

		   RISuco_declare_schema_str(schname, schpass, 
                   osusr, ospass, dbname, dbpass, 
                   declare_command, sizeof(declare_command));

		   exec sql execute immediate :declare_command;

		   exec sql execute immediate :default_command;
                }
	}

	if (SQLCODE == RIS_E_SCHPASS_NOT_SAME)
	{
		RISuco_get_password(RIScom_umsg(RISUTL_I_ENTER_SCHEMA_PASSWORD),
			schpass, RIS_MAX_ID_SIZE);

		   RISuco_declare_schema_str(schname, schpass, osusr, ospass,
			dbname, dbpass, declare_command, 
                        sizeof(declare_command));

		exec sql execute immediate :declare_command;

		exec sql execute immediate :default_command;

	        if (SQLCODE == RIS_E_SCHPASS_NOT_SAME) /*one last chance */
                {
		      RISuco_get_password(
                         RIScom_umsg(RISUTL_I_INV_SCHPASS_ENTER_SCHPASS),
			 schpass, RIS_MAX_ID_SIZE);

		      RISuco_declare_schema_str(schname, schpass, osusr, 
                         ospass, dbname, dbpass, declare_command, 
                        sizeof(declare_command));

		exec sql execute immediate :declare_command;

		exec sql execute immediate :default_command;

                }
	}

	if (SQLCODE != RIS_SUCCESS) 
	{
		if ((SQLCODE == RIS_E_BAD_LOGIN)        || 
                    (SQLCODE == RIS_E_SCHPASS_NOT_SAME) ||  
                    (SQLCODE == RIS_E_INV_OPEN_DB))
		{
		      RISuco_push_risca_dbca();
		      sprintf(declare_command, "undeclare schema %s", schname);
		      exec sql execute immediate :declare_command;
		      RISuco_pop_risca_dbca();
                      strcpy(schpass,"");
	              strcpy(osusr,"");
	              strcpy(ospass,"");
	              strcpy(dbname,"");
	              strcpy(dbpass,""); 
	       }
	}

	UCO_DBG(("RISuco_set_default_schema:returning 0\n"));
	return 0;
}

/******************************************************************************/

/* 
**	Returns	1 if user hit CR and cr_to_exit_flag is non-zero,
**	otherwise returns 0.
*/

extern int RISuco_default_schema(
	int cr_to_exit_flag)
{
	int return_sts = 0;
	char schname[RIS_MAX_ID_SIZE];
	char schpass[RIS_MAX_ID_SIZE];
	char usrname[RIS_MAX_ID_SIZE];
	char usrpass[RIS_MAX_ID_SIZE];
	char dbname[RIS_MAX_ID_SIZE];
	char dbpass[RIS_MAX_ID_SIZE];

	UCO_DBG(("RISuco_default_schema()\n"));

	strcpy(schname,"");
	strcpy(schpass,"");
	strcpy(usrname,"");
	strcpy(usrpass,"");
	strcpy(dbname,"");
	strcpy(dbpass,"");

	while (1)
	{
		/* NOTE: This prompt doesn't really have a dot password in it */
		/*       It's named this for historic reasons                 */
		PRINTF(MSG(cr_to_exit_flag ? RISUTL_I_ENTER_SCHEMA_DOT_PASSWORD_CR :
			RISUTL_I_ENTER_SCHEMA_DOT_PASSWORD));
		RISuco_fgets(schname, sizeof(schname), stdin);

		if (!schname[0])
		{
			if (cr_to_exit_flag)
			{
				return_sts = 1;
				break;
			}
			PRINTF(MSG(RISUTL_I_SCHEMA_MUST_BE_SPEC));
		}
		else
		{
			if (!RISuco_set_default_schema(schname, schpass, usrname, usrpass, dbname, dbpass))
			{
				break;
			}
			PRINTF(MSG(RISUTL_I_INV_SCHEMA_NAME));
		}
	}


	UCO_DBG(("RISuco_default_schema:returning %d\n", return_sts));
	return return_sts;
}

/******************************************************************************/

/* {{{ RISuco_declare_schema_str() */

/* {{{ doc */

/**==================================================
 ** FUNCTION: RISuco_declare_schema_str
 ** DESCRIPTION: Creates a DECLARE SCHEMA statement in a string.
 ** RETURN: 0 (zero) for success, 1 (one) if statement is longer than buffer_len
 ** ARGUMENTS:
 **		sch_name	I	Schema name.
 **		sch_passwd	I	Schema password.
 **		user		I	Operating system user.
 **		passwd		I	Operating system user password.
 **		db_user		I	Database username (oracle, AS400, .etc.)
 **		db_passwd	I	Database username password 
 **		buffer		O	String for the DECLARE SCHEMA statment
 **		buffer_len	I	Length of the buffer string.
 ** NOTES: This function assumes that all arguments are non-NULL strings.
 ** AUTHOR(S): pmfitzge, ddferran
 **==================================================*/

/* }}} */
extern int RISuco_declare_schema_str(
	char *sch_name,
	char *sch_passwd,
	char *user,          /*os_user */
	char *passwd,       /*os_password */
	char *db_user,       /*database user */ 
	char *db_passwd,     /*database password */
	char *buffer,
	unsigned int buffer_len)
{
/* {{{ Check string boundary */

	UCO_DBG(("RISuco_declare_schema_str() sch = <%s>, usr = <%s>, dbusr = <%s>, \n",sch_name, user, db_user));

	if (strlen("declare schema . user . osuser .") +
		strlen(sch_name) + strlen(sch_passwd) +
		strlen(user) + strlen(passwd) +
		strlen(db_user) + strlen(db_passwd)
		>= buffer_len)
	{
		/* DECLARE SCHEMA statement is too long to fit in buffer */
		*buffer = '\0';
		return 1;
	}

/* }}} */
/* {{{ "declare schema <sch_name>[.<sch_passwd>]" */

	strcpy(buffer, "declare schema ");
	strcat(buffer, sch_name);

	if (sch_passwd[0] != '\0')
	{
		strcat(buffer, ".");
		strcat(buffer, sch_passwd);
	}

/* }}} */
/* {{{ "[user <user>[.[<passwd>]]]" */

	if ((user[0] != '\0') && (db_user[0] == '\0'))
	{ 

		strcat(buffer, " user ");
		strcat(buffer, user);

		if (passwd[0] != '\0')
		{
			strcat(buffer, ".");
			strcat(buffer, passwd);
		}
	}
        else if ((user[0] == '\0') && (db_user[0] != '\0'))
	{ 
          /* if only one argument was sent in it must be the db_user */

		strcat(buffer, " user ");
		strcat(buffer, db_user);

		if (db_passwd[0] != '\0')
		{
			strcat(buffer, ".");
			strcat(buffer, db_passwd);
		}
	}
/* }}} */
/* {{{ "[osuser <db_user>[.[<db_passwd>]]]" */
        else if ((user[0] != '\0') && (db_user[0] != '\0'))
        {
		strcat(buffer, " user ");
		strcat(buffer, db_user);

		if (db_passwd[0] != '\0')
		{
			strcat(buffer, ".");
			strcat(buffer, db_passwd);
		}

		strcat(buffer, " osuser ");
		strcat(buffer, user);

		if (passwd[0] != '\0')
		{
			strcat(buffer, ".");
			strcat(buffer, passwd);
		}
       }
/* }}} */
	return 0;
}

/* }}} */

/******************************************************************************/
