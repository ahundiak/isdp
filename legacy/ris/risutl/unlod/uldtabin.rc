/* Do not alter this SPC information: $Revision: 1.2.26.1 $ */
/*
**	NAME:							uldtabin.rc
**	AUTHORS:						Jennifer Xia
**	CREATION DATE:					July 9, 1990
**	ABSTRACT:
**		It contains a function which unloads a table. It also
**		contains a function for obtaining characteristics of
**		a table and a function for allocating data buffer for
**		unloading table data.
**	
**	REVISION HISTORY:August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#if defined(WIN32S) && defined(ULD_EXE)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#include "risutl.h"
#include "prog32s.h"
#endif 

#ifdef MM
#include "unlod.h"
#endif

#include "ris_err.h"

exec sql include "unlod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define uldtabin_rc
#include "sys.prt"
#include "comdebug.prt"
#include "comjmp.prt"
#include "comwrap.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "uldermsg.prt"
#include "uldmisc.prt"
#include "uldtabda.prt"
#include "uldtabhr.prt"
#include "uldtabin.prt"
#include "uldtime.prt"
#include "ucoerrbx.prt"

extern int RISuld_get_tab_info(
	tab_node_type	*tab_node_ptr,		/* changed to tab_node_type */
	int include_blobs) /* If 0, assumes you called this function earlier with value 1;
						  that is, assumes that RISuld_out_desc is valid */
{
	char *select_query_ptr;
	int  col_indx;

	exec sql begin declare section;
		sqlda	in_desc;
		char	select_query_stmt[SQL_MAX_STMT_LEN]; 
		char	*err_ptr;
	exec sql end declare section;

	ULD_DBG(("RISuld_get_tab_info: tab_name <%s>\n", tab_node_ptr->tab_name));

	exec sql whenever sqlerror goto :GTI_error;

	/* Create the select statement, with or without blob/text columns */
	if (RISuld_make_table_select(select_query_stmt, tab_node_ptr->tab_name,
								 include_blobs))
	{
		ULD_DBG(("RISuld_get_tab_info: select string not long enough to fit all columns\n"));
		return(FAILURE);
	}

	/* Add the WHERE clause */
	if( tab_node_ptr->where_clause_ptr != (char *) NULL )
	{
		if( strncmp(tab_node_ptr->where_clause_ptr,", ",2) == 0 ) /* additional tables */
		{
			exec sql prepare select_get_columns from :select_query_stmt;

			UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

			RISuld_out_desc.sqld = 0;
			RISuld_out_desc.sqln = 0;
			RISuld_out_desc.sqlvar = 0;

			exec sql describe output select_get_columns using descriptor RISuld_out_desc;

			UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

			if (RISuld_out_desc.sqld == 0)
			{
				RISuld_unload_err_handler(RISUTL_E_NO_COLUMNS_FOUND);
				if( RISuld_mode == EMBED )
				{
					tab_node_ptr->lnd_err_code = RISUTL_E_NO_COLUMNS_FOUND;
				}
				ULD_DBG(("2. RISuld_get_tab_info: end\n"));
				return(FAILURE);
			}

			RISuld_out_desc.sqlvar = (sqlvar *) calloc(RISuld_out_desc.sqld, sizeof(sqlvar));
			CHK_MEM_ALLOC_ERR(RISuld_out_desc.sqlvar)

			RISuld_out_desc.sqln = RISuld_out_desc.sqld;

			exec sql describe output select_get_columns using descriptor RISuld_out_desc;

			UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

			select_query_ptr = select_query_stmt;

			strcpy(select_query_ptr,"select ");
			select_query_ptr += 7;

			for( col_indx = 0; col_indx < RISuld_out_desc.sqld; col_indx++ )
			{
				sprintf(select_query_ptr,"%s.",tab_node_ptr->tab_name);
				select_query_ptr += strlen(tab_node_ptr->tab_name) + 1;

				RISuld_strncpy(select_query_ptr,
					RISuld_out_desc.sqlvar[col_indx].sqlname.sqlnamec,
					RISuld_out_desc.sqlvar[col_indx].sqlname.sqlnamel,
					(RIS_MAX_ID_SIZE-1));
				select_query_ptr +=
					(RISuld_out_desc.sqlvar[col_indx].sqlname.sqlnamel < (RIS_MAX_ID_SIZE-1))?
					RISuld_out_desc.sqlvar[col_indx].sqlname.sqlnamel : (RIS_MAX_ID_SIZE-1);
				strcpy(select_query_ptr,", ");
				select_query_ptr += 2;
			}
			select_query_ptr -= 2; /* remove trailing , and blank */

			strcpy(select_query_ptr," from ");
			select_query_ptr += 6;

			strcpy(select_query_ptr,tab_node_ptr->tab_name);
			select_query_ptr += strlen(tab_node_ptr->tab_name);
			strcpy(select_query_ptr,"\0");
			strcpy(select_query_ptr,tab_node_ptr->where_clause_ptr);

			exec sql clear select_get_columns;

			UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

			free(RISuld_out_desc.sqlvar);
		} /* additional tables */
		else	/* where clause exists without additional tables */
		{
			strcat(select_query_stmt, "  ");
			strcat(select_query_stmt, tab_node_ptr->where_clause_ptr);
		}
	}

	/* Prepare the dynamic SQL statement */
	ULD_DBG(("select_query_stmt = <%s>\n", select_query_stmt));
	exec sql prepare select_stmt from :select_query_stmt;

	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	/* Get the count of input columns */
	in_desc.sqld = 0;
	in_desc.sqln = 0;
	in_desc.sqlvar = 0;

	exec sql describe input select_stmt using descriptor in_desc;

	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	/* Get the count of ouput columns */
	RISuld_out_desc.sqld = 0;
	RISuld_out_desc.sqln = 0;
	RISuld_out_desc.sqlvar = 0;

	exec sql describe output select_stmt using descriptor RISuld_out_desc;

	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	/* No output columns?  We're done then. */
	if (RISuld_out_desc.sqld == 0)
	{
		RISuld_unload_err_handler(RISUTL_E_NO_COLUMNS_FOUND);
		if( RISuld_mode == EMBED )
		{
			tab_node_ptr->lnd_err_code = RISUTL_E_NO_COLUMNS_FOUND;
		}
		ULD_DBG(("2. RISuld_get_tab_info: end\n"));
		return(FAILURE);
	}

	/* Allocate output columns, and call describe again
	   to get the information about each result column */
	RISuld_out_desc.sqlvar = (sqlvar *) calloc(RISuld_out_desc.sqld, sizeof(sqlvar));
	CHK_MEM_ALLOC_ERR(RISuld_out_desc.sqlvar)

	RISuld_out_desc.sqln = RISuld_out_desc.sqld;

	exec sql describe output select_stmt using descriptor RISuld_out_desc;

	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	/* open the SELECT statement */
	exec sql declare tab_data_cursor cursor for select_stmt;
	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	exec sql open tab_data_cursor using descriptor in_desc;
	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);


	ULD_DBG(("3. RISuld_get_tab_info: end\n"));
	return(SUCCESS);

GTI_error:
	exec sql whenever  sqlerror continue;
	if( RISuld_mode == EMBED )
	{
		tab_node_ptr->ris_err_code = risca->sqlcode;
		tab_node_ptr->db_err_code = dbca->sqlcode;
	}
	else
	{
		exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
		PUTS(err_ptr);
#endif
	}


	ULD_DBG(("4. RISuld_get_tab_info: end\n"));
	return(FAILURE);
}


extern void RISuld_unload_tab_info(
	char			*sch_name,
	tab_node_type	*tab_node_ptr,
	int				def_data_select,
	int				dfile_select,
	int				format_select)
{
	int		num_row;
	int		err_row;
	char	*dfile_name;
	FILE	*data_fp;
	int		col_indx;
	int		retn = 0;		/* if 1 then successfully written to file */

	exec sql begin declare section;
		char	*err_ptr;
	exec sql end declare section;

	ULD_DBG(("RISuld_unload_tab_info: sch_name <%s> tab_node_ptr 0x%x\n",
						sch_name, tab_node_ptr));
	ULD_DBG(("\t def_data_select <%c> dfile_select <%c> format_select %d\n",
					 def_data_select, dfile_select, format_select));

	num_row = 0;	
	err_row = 0;	
	data_fp = (FILE *) NULL;

	if (RISuld_get_tab_info(tab_node_ptr,
							1 /* include blob/text */)
		== FAILURE)
	{
		ULD_DBG(("2. RISuld_unload_tab_info: end\n"));
		return;
	}

	if (RISuld_form_create_tab(tab_node_ptr->tab_name) == FAILURE)
	{
		ULD_DBG(("3. RISuld_unload_tab_info: end\n"));
		return;
	}

	if (def_data_select == BOTH)
	{
		/* Re-create the select statement so it does not include
		   RIS_BLOB or RIS_TEXT columns */
		if (RISuld_table_has_blob_or_text())
		{
			if (RISuld_get_tab_info(tab_node_ptr,
									0 /* do not include blob/text */ )
				== FAILURE)
			{
				ULD_DBG(("2. RISuld_unload_tab_info: end\n"));
				return;
			}
		}

		RISuld_form_insert_into(tab_node_ptr->tab_name);
		if (RISuld_form_field_def() == FAILURE)
		{
			ULD_DBG(("4. RISuld_unload_tab_info: end\n"));
			return;
		}

		RISuld_allocate_data_buf();

		for (;;)
		{
			exec sql fetch tab_data_cursor using descriptor RISuld_out_desc;

			UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

			if (SQLCODE < 0)
			{
				if( RISuld_mode == EMBED )
				{
					tab_node_ptr->ris_err_code = risca->sqlcode;
					tab_node_ptr->db_err_code = dbca->sqlcode;
				}
				else
				{
					exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
					PUTS(err_ptr);
#endif
				}
				err_row++;

				/* Temporary! */
				if (SQLCODE == RIS_E_NO_BLOB_STRUC)
				{
					ULD_DBG(("RISuld_unload_tab_info: blob/text warning\n"));
					break;
				}
			}
			else if (SQLCODE == END_OF_DATA)
			{
				break;
			}
			else
			{
				if ((dfile_select == DIFFERENT) && (data_fp == NULL))
				{
					if ((data_fp = RISuld_create_dfile(sch_name, 
													   tab_node_ptr->tab_name, 
													   &dfile_name)) ==  NULL)
					{
						break;
					}
				}

				if (dfile_select == DIFFERENT)
				{
					retn += RISuld_unload_one_row('d', data_fp);
				}
				else
				{
					retn += RISuld_unload_one_row('m',RISuld_out_fp);
				}

				if (retn == 0) 
				{
					err_row++;
				}
				else 
				{
					num_row++;
				}
			}
		}

		for (col_indx = 0; col_indx < RISuld_out_desc.sqld; col_indx++)
		{
			free(RISuld_out_desc.sqlvar[col_indx].sqldata);
                       /* fixing TR 439502019 - heap error when unload using
                          variable format */
			if (RISuld_ptr_struct_ptr->bthnode_ptr->format_select != VARIABLE )
			free(RISuld_out_desc.sqlvar[col_indx].sqlind);
		}
	}
	else
	{
		RISuld_print_msg(MSG(RISUTL_E_UNLOADED_TAB_DEF), 
			tab_node_ptr->tab_name);
	}

	if (FPUTS("***RIS*** End of Table ***RIS***\n", RISuld_out_fp) == EOF)
		WRITING_FILE_ERR(RISUTL_E_CANT_WRITE_OUTPUT_FILE)

	tab_node_ptr->unloaded = TRUE;

	if (def_data_select == BOTH) 
	{
		if ((dfile_select == DIFFERENT) && (num_row > 0))
		{
			RISuld_print_msg(MSG(RISUTL_E_UNLOADED_TAB_ROWS), num_row, 
					tab_node_ptr->tab_name, dfile_name);
			strcpy(tab_node_ptr->datafile,dfile_name);
			tab_node_ptr->rowsdonewith = num_row;
		}
		else
		{
			RISuld_print_msg(MSG(RISUTL_E_UNLOADED_TAB_ROWS), num_row, 
						tab_node_ptr->tab_name, RISuld_mfile);
			tab_node_ptr->rowsdonewith = num_row;
		}

		if (err_row > 0)
		{
			RISuld_print_msg(MSG(RISUTL_E_NOT_UNLOADED_TAB_ROWS), err_row, 
					tab_node_ptr->tab_name );
			tab_node_ptr->err_row = err_row;
		}
		else
		{
			RISuld_print_msg("");
		}

		if ((dfile_select == DIFFERENT) && (data_fp != NULL)) 
		{
			free(dfile_name);
			RIScom_fclose(data_fp);
		}
	}

	free(RISuld_out_desc.sqlvar);

	exec sql close tab_data_cursor;

	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	exec sql clear cursor tab_data_cursor;

	UNLOD_WARNING_CHECK(tab_node_ptr->sqlwarnings);

	ULD_DBG(("5. RISuld_unload_tab_info: end\n"));
}



extern void RISuld_allocate_data_buf()
{
	int	col_indx;

	ULD_DBG(("RISuld_allocate_data_buf"));

	for (col_indx = 0; col_indx < RISuld_out_desc.sqld; col_indx++)
	{
		ULD_DBG(("size of column(%d) = %d\n", col_indx, RISuld_out_desc.sqlvar[col_indx].sqllen));
		
		switch (RISuld_out_desc.sqlvar[col_indx].sqltype)
		{
		  case RIS_CHARACTER:
			RISuld_out_desc.sqlvar[col_indx].sqldata =
				calloc(RISuld_out_desc.sqlvar[col_indx].sqllen + 1, sizeof(char));
			break;
		  case RIS_DATETIME:
			RISuld_out_desc.sqlvar[col_indx].sqldata = calloc(1, sizeof(datetime));
			break;
		  case RIS_BLOB:
			RISuld_out_desc.sqlvar[col_indx].sqldata = calloc(1, sizeof(ris_blob));
			break;
		  case RIS_TEXT:
			RISuld_out_desc.sqlvar[col_indx].sqldata = calloc(1, sizeof(ris_text));
			break;
		  default:
			RISuld_out_desc.sqlvar[col_indx].sqldata =
				calloc(1, RISuld_out_desc.sqlvar[col_indx].sqllen);
			break;
		}
		CHK_MEM_ALLOC_ERR(RISuld_out_desc.sqlvar[col_indx].sqldata)

	 	RISuld_out_desc.sqlvar[col_indx].sqlind = (long *) calloc(1, sizeof(long));
		CHK_MEM_ALLOC_ERR(RISuld_out_desc.sqlvar[col_indx].sqlind)
	}

	ULD_DBG(("1. RISuld_allocate_data_buf: end\n"));
}



extern int RISuld_table_has_blob_or_text()
{
	int	col_indx;

	ULD_DBG(("RISuld_table_has_blob_or_text"));

	for (col_indx = 0; col_indx < RISuld_out_desc.sqld; col_indx++)
	{
		if (RISuld_out_desc.sqlvar[col_indx].sqltype == RIS_BLOB ||
			RISuld_out_desc.sqlvar[col_indx].sqltype == RIS_TEXT)
		{
			ULD_DBG(("RISuld_table_has_blob_or_text: found blob/text column\n"));
			return 1;
		}
	}

	ULD_DBG(("RISuld_table_has_blob_or_text: no blob/text columns\n"));
	return 0;
}


/* Returns 0 for success, 1 if select statement > SQL_MAX_STMT_LEN */
extern int RISuld_make_table_select(
	char *select,
	char *table,
	int	include_blobs) /* if 0, assumes RISuld_out_desc is valid */
{
	int len, col_indx, first_col;
	char *col;

	ULD_DBG(("RISuld_make_table_select: table <%s> include_blobs <%d>\n", table, include_blobs));
	
	if (include_blobs)
	{
		strcpy(select, "select all * from ");
		strcat(select, table);
	}
	else /* Do not include blob/text data */
	{
		strcpy(select, "select all ");

		len = strlen(select);
		for(first_col = 1, col_indx = 0; col_indx < RISuld_out_desc.sqld; col_indx++ )
		{
			/* Skip blob and text columns */
			if (RISuld_out_desc.sqlvar[col_indx].sqltype == RIS_BLOB ||
				RISuld_out_desc.sqlvar[col_indx].sqltype == RIS_TEXT)
				continue;

			/* Get the column name */
			col = RISuld_out_desc.sqlvar[col_indx].sqlname.sqlnamec;

			/* Check string boundaries */
			if ((len += strlen(col) + 2) > SQL_MAX_STMT_LEN)
				return 1;

			/* Add comma onto end of last column, unless this is the first column */
			if (! first_col)
				strcat(select, ", ");
			first_col = 0; /* make sure next column triggers a comma */

			strcat(select, col);
		}

		if ((len += strlen(" from ") + strlen(table)) > SQL_MAX_STMT_LEN)
			return 1;

		strcat(select, " from ");
		strcat(select, table);
	}
	ULD_DBG(("RISuld_make_table_select: select <%s>\n", select));
	return 0;
}
