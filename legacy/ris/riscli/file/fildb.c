/*
**	NAME:							fildb.c
**	AUTHORS:						David Michal
**	CREATION DATE:					3/90
**	ABSTRACT:
**	This file contains the routines that manage databases in the dictionary
**	file.
**		
**	
**	REVISION HISTORY:
*/
 
/*
**	INCLUDES
*/
#include "file.h"

/*
**	DEFINES
*/

/*
**	VARIABLES
*/

/*
**	FUNCTION PROTOTYPES
*/
#define fildb_c
#include "ccocmpar.prt"
#include "comalloc.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "comstrcp.prt"
#include "fildb.prt"
#include "fillist.prt"
#include "filshare.prt"
#include "filtrans.prt"
#include "sys.prt"

/*
**	FUNCTIONS
*/

/******************************************************************************/

static char *db_mask_name(
	int mask)
{
	int		i;
	int		first_flag = 1;
	static	char	*ptr;
	static	char	buffer[80];
	static	struct
	{
		int		flag;
		char	*name;
	} db_flag_name[] =
	{
		{ DBID_FLAG,		"DBID_FLAG"		},
		{ DTYPE_FLAG,		"DTYPE_FLAG"	},
		{ DBNAME_FLAG,		"DBNAME_FLAG"	},
		{ OSTYPE_FLAG,		"OSTYPE_FLAG"	},
		{ PARMS_FLAG,		"PARMS_FLAG"	},
		{ PROTADDR_FLAG,	"PROTADDR_FLAG"	},
	};
	static	int		flag_count = 6;

	if (mask == ALL_FLAG) return "ALL_FLAG";

	ptr = buffer;
	*ptr = 0;
	for (i = 0; i < flag_count; i++)
	{
		if (mask & db_flag_name[i].flag)
		{
			if (first_flag)
				first_flag = 0;
			else
				*ptr++ = '|';
			ptr += RIScom_strcpy(ptr, db_flag_name[i].name);
		}
	}
	return buffer;
}

/******************************************************************************/

extern void RISfil_copy_db(
	risdb	*to,
	risdb	*from,
	int mask)
{
	int		i;

	if (mask & DBID_FLAG)
		to->dbid = from->dbid;
	if (mask & DTYPE_FLAG)
		to->dtype = from->dtype;
	if (mask & DBNAME_FLAG)
		strcpy(to->dbname, from->dbname);
	if (mask & OSTYPE_FLAG)
		to->ostype = from->ostype;
	if (mask & PARMS_FLAG)
		memcpy((char *)&to->parms ,(char *)&from->parms,sizeof(from->parms));
	if (mask & PROTADDR_FLAG)
	{
		for (i = 0; i < RIS_MAX_PROTOCOLS; i++)
		{
			to->pathways[i].protocol = from->pathways[i].protocol;
			strcpy(to->pathways[i].netaddr, from->pathways[i].netaddr);
		}
	}
}

/******************************************************************************/

/*
** Get information about a database from the dictionary file and put it into an
** risdb struct.  The dbid field needs to be filled in with the id
** of the database in question.
*/

extern void RISfil_get_db(
	risdb	*db_info,
	int		mask)
{
	fildb_list	*dbp;
	fildb_tmp_list *temp;

	FIL_DBG(("RISfil_get_db(db_info:0x%x mask:%s)\ndbid:%d\n",
		db_info, db_mask_name(mask), db_info->dbid));
	/*
	**	begin transaction
	*/
	RISfil_begin_schema_transact(READ_ONLY_TRANSACTION);

	FIL_DBG(("looking in temp. db list first.\n"));
	for (temp=RISfil_db_tmp_list[RIS_stmt->stmt_id];temp;temp = temp->next)
	{
		if (temp->tmp_dbp && (db_info->dbid == temp->tmp_dbp->dbid))
		{
			FIL_DBG(("tmp_dbp exists, dbid:%d\n",temp->tmp_dbp->dbid));
			RISfil_copy_db(db_info, temp->tmp_dbp, mask);
			db_info->next = 0;
			return;
		}
		else if((temp->master_dbp) && 
				(db_info->dbid==temp->master_dbp->dbp->dbid))
		{
			FIL_DBG(("master_dbp exists,dbid:%d\n",
				temp->master_dbp->dbp->dbid));
			RISfil_copy_db(db_info, temp->master_dbp->dbp, mask);
			db_info->next = 0;
			FIL_DBG(("RISfil_get_db returning...\n"));
			return;
		}
	}
	FIL_DBG(("couldnt find it in temp. list. looking in master list\n"));

	for (dbp = RISfil_db_list; dbp; dbp = dbp->next)
	{
		if (db_info->dbid == dbp->dbp->dbid)
		{
			FIL_DBG(("found dbid:%d in master list\n",dbp->dbp->dbid));
			RISfil_copy_db(db_info, dbp->dbp, mask);
			db_info->next = 0;
			FIL_DBG(("RISfil_get_db returning...\n"));
			return;
		}
	}
	LONGJMP(RIS_E_UNKNOWN_DATABASE);
}

/*****************************************************************************/

/*
** Put information from an risdb struct into the dictionary file.
** Duplicate database ids are not allowed.
** A new database id is automatically generated by this function.
*/

extern void RISfil_put_db(
	risdb	*db_info)
{
	unsigned short	max_dbid;
	fildb_list	*dbp;
	fildb_tmp_list	*tmp_dbp;

	FIL_DBG(("RISfil_put_db(db_info:0x%x)\n",db_info));

	/*
	**	begin transaction
	*/
	RISfil_begin_schema_transact(READ_WRITE_TRANSACTION);

	if (RISfil_debug) 
	{
		RISfil_print_lists();
	}
	/*
	**	Get the new dbid;
	*/
	for (max_dbid = 0, dbp = RISfil_db_list; dbp; dbp = dbp->next)
	{
/*
**		if (dbp->update_lock_flag == UPDATE_LOCK_ON)
**		{
**			LONGJMP(RIS_E_SCHEMA_DB_LOCKED);
**		}
*/
		if (RIScco_compare_dbs(db_info, dbp->dbp, NOT_ALL_PARMS)==SAME_DATABASE)
		{
			FIL_DBG(("database already exists; dbid:%d\n", dbp->dbp->dbid));
			db_info->dbid = dbp->dbp->dbid;
			LONGJMP(RIS_E_DUP_DATABASE);
		}
		if (dbp->dbp->dbid > max_dbid) max_dbid = dbp->dbp->dbid;
	}
	db_info->dbid = max_dbid + (short)1;

	/*
	**	Add new db
	*/
	tmp_dbp = ALLOCT(fildb_tmp_list);
	tmp_dbp->tmp_dbp = ALLOCT(risdb);
	RISfil_copy_db(tmp_dbp->tmp_dbp, db_info, ALL_FLAG);
	tmp_dbp->next = RISfil_db_tmp_list[RIS_stmt->stmt_id];
	RISfil_db_tmp_list[RIS_stmt->stmt_id] = tmp_dbp;

	/*
	**	Update timestamp
	*/
	RISfil_timestamp = time(0);
	if (RISfil_debug) 
	{
		RISfil_print_lists();
		RISfil_print_temp_list(RIS_stmt->stmt_id);
	}
}

/******************************************************************************/

extern void RISfil_delete_db(
	risdb		*db_info)
{
	int			dropped_dbid;
	fildb_list	**dbpp;
	fildb_tmp_list	*tmp_dbp;

	FIL_DBG(("RISfil_delete_db(db_info:0x%x)\ndbid:%d\n",db_info,db_info->dbid));

	/*
	**	begin transaction
	*/
	RISfil_begin_schema_transact(READ_WRITE_TRANSACTION);

	for (dbpp = &RISfil_db_list; (*dbpp); dbpp = &((*dbpp)->next))
	{
		if (db_info->dbid == (*dbpp)->dbp->dbid)
		{
			if (!(tmp_dbp=RISfil_set_db_tmp_list((*dbpp))))
			{
				LONGJMP(RIS_E_INTERNAL_ERROR);
			}
			/*
			**	Drop the db from the db file.
			*/
			dropped_dbid = (*dbpp)->dbp->dbid;
			tmp_dbp->tmp_dbp = 0;

			/*
			**	Update timestamp;
			*/
			RISfil_timestamp = time(0);

if (RISfil_debug) RISfil_print_temp_list(RIS_stmt->stmt_id);

			return;
		}
	}
	LONGJMP(RIS_E_UNKNOWN_DATABASE);
}

/******************************************************************************/

/*
** Update a database in the dictionary file.  The id of the database to be 
** updated should be in the dbid field of the risdb struct.
** The mask indicates what values are to be updated.
*/

extern void RISfil_update_db(
	risdb	*db_info,
	int mask)
{
	int		i;
	fildb_tmp_list	*dbp1, *tmp_dbp;
	fildb_list *dbp;

	FIL_DBG(("RISfil_update_db(db_info:0x%x mask:%s)\ndbid:%d\n",
		db_info, db_mask_name(mask), db_info->dbid));
	if (RISfil_debug)
	{
		for (i = 0; i < RIS_MAX_PROTOCOLS; i++)
		{
			RIScom_output_debug("%d: protocol:<%c> netaddr:<%s>\n", i,
				db_info->pathways[i].protocol, db_info->pathways[i].netaddr);
		}
	}

	/*
	**	begin transaction
	*/
	RISfil_begin_schema_transact(READ_WRITE_TRANSACTION);

	for (dbp1 = RISfil_db_tmp_list[RIS_stmt->stmt_id]; dbp1; dbp1 = dbp1->next)
	{
		if (dbp1->tmp_dbp && (db_info->dbid == dbp1->tmp_dbp->dbid))
		{
			FIL_DBG(("found temp. db \n"));
			RISfil_copy_db(dbp1->tmp_dbp, db_info, mask);
			RISfil_timestamp = time(0);
			return;
		}
	}

	for (dbp = RISfil_db_list; dbp; dbp = dbp->next)
	{
		if (db_info->dbid == dbp->dbp->dbid)
		{
			FIL_DBG(("found db in master list\n"));
			if (!(tmp_dbp=RISfil_set_db_tmp_list(dbp)))
			{
				LONGJMP(RIS_E_INTERNAL_ERROR);
			}
			RISfil_copy_db(tmp_dbp->tmp_dbp, db_info, mask);
			RISfil_timestamp = time(0);
			return;
		}
	}
	LONGJMP(RIS_E_UNKNOWN_DATABASE);
}

/******************************************************************************/

/*
** Get information about all databases from the dictionary file and put it into
** risdb structs.
*/

extern void RISfil_get_all_dbs(
	risdb	**db_list,
	int mask)
{
	fildb_list	*dbp;
	risdb	*db_info;

	FIL_DBG(("RISfil_get_all_dbs(db_list:0x%x mask:%s)\n",
		db_list, db_mask_name(mask)));

	*db_list = 0;

	/*
	**	begin transaction
	*/
	RISfil_begin_schema_transact(READ_ONLY_TRANSACTION);

	for (dbp = RISfil_db_list; dbp; dbp = dbp->next)
	{
		db_info = ALLOCT(risdb);
		RISfil_copy_db(db_info, dbp->dbp, mask);
		db_info->next = 0;

		*db_list = db_info;
		db_list = &(db_info->next);
	}
}

/******************************************************************************/

extern void RISfil_get_timestamp(
	long	*timestamp)
{
	FIL_DBG(("RISfil_get_timestamp(timestamp:0x%x)\n",timestamp));

	/*
	**	begin transaction
	*/
	RISfil_begin_schema_transact(READ_ONLY_TRANSACTION);

	*timestamp = RISfil_timestamp;
	FIL_DBG(("*timestamp:%d\n",*timestamp));
}

/******************************************************************************/
