extern char  *malloc(), *calloc() ;
int   RISqry_no_output (  ris_query,  err_code )
char   *ris_query;
int   *err_code ;
{
	exec sql begin declare section;
		int	i;
		char	*sql_stmt2;
		char	buffer[100];
		sqlda	in_desc;
		sqlda	out_desc;
		char	*err_ptr;
	exec sql end declare section;

	/*
	**	create the sql statement (for illustration only...
	**	a real dynamic would have been passed in).
	*/

	sql_stmt2 = ris_query;
	
	/* define exception handlers */
	
	exec sql whenever sqlerror goto :error;
	exec sql whenever not found goto :not_found;
	

	/* prepare a dynamic SQL statement */
	
	exec sql prepare stmt2 from :sql_stmt2;

	in_desc.sqld = 0;
	in_desc.sqln = 0;
	in_desc.sqlvar = 0;
	
	/* see if there are any input parameters */
	
	exec sql describe input stmt2 using descriptor in_desc;


	if ( in_desc.sqld )
	{
		/* allocate input buffers for any input parameters */

		in_desc.sqlvar = (sqlvar*) calloc ( in_desc.sqld,
                                                    sizeof(sqlvar) );
		in_desc.sqln = in_desc.sqld;
	
		/* get information about the input parameters */
	
		exec sql describe input stmt2 using descriptor in_desc;

		for ( i = 0; i < in_desc.sqld; ++i )
		{
			/* get a value for the input parameter */
			printf ( "Enter a value for input parameter #%d\n", i );
	
			gets ( buffer );

			/* set up the program address, 
                                             and (optional) indicator */

			in_desc.sqlvar[i].sqldata = calloc ( 1,
                                                     in_desc.sqlvar[i].sqllen );
	
			/* if no string was entered, assume null value wanted */

			if ( buffer[0] == '\0' )
			{
				*in_desc.sqlvar[i].sqldata = '\0';
				in_desc.sqlvar[i].sqlnull = 1;
				in_desc.sqlvar[i].sqlind = (long*) calloc( 1, 
                                                            sizeof(int) );
				*in_desc.sqlvar[i].sqlind = -1;
			}
			else
			{
				in_desc.sqlvar[i].sqlnull = 0;
				switch ( in_desc.sqlvar[i].sqltype )
				{
					case CHARACTER:
						strncpy ( in_desc.sqlvar[i].sqldata, 
                                                    buffer, in_desc.sqlvar[i].sqllen );
						break;

					case SMALLINT:
						sscanf ( buffer, "%hd", 
                                                   in_desc.sqlvar[i].sqldata );
						break;

					case INTEGER:
						sscanf ( buffer, "%d", 
                                                   in_desc.sqlvar[i].sqldata );
						break;

					case REAL:
						sscanf ( buffer, "%f",
                                                   in_desc.sqlvar[i].sqldata );
						break;

					case DOUBLE:
						sscanf ( buffer, "%lf", 
                                                    in_desc.sqlvar[i].sqldata );
						break;
					case DECIMAL:
						sscanf ( buffer, "%lf", 
                                                    in_desc.sqlvar[i].sqldata );
						break;

					default:
						/* printf ( "Invalid data type found\n" ); */
						/*strcpy ( err_str, "error: Invalid data type found\n" );*/
                                                *err_code = -1 ;
						/* exit (); */
                                                return ( -1 );
				}
			}
		}
	}

	/*
	**	if the statement is not a SELECT statement (sqld == 0),
	**		execute the statement.
	**	else
	**		declare a cursor for, open, and 
        **              fetch from the statement.
	*/
	
	out_desc.sqld = 0;
	out_desc.sqln = 0;
	out_desc.sqlvar = 0;

	/* get the count of output columns */

	exec sql describe output stmt2 using descriptor out_desc;


	/* non-SELECT statements will have sqld == 0 (no result columns) */

	if (out_desc.sqld == 0)
	{
		exec sql execute stmt2 using descriptor in_desc;
		exec sql clear stmt2;
	
         	/* 	printf ( "\nDone\n" );
		 exit(); */
                return ( 0 );
	}
	


not_found:
	exec sql whenever not found continue;
	/* exit (); */
        return ( 0 );
	

error:
	exec sql whenever sqlerror continue;
	exec sql report error into :err_ptr;
	/* puts ( err_ptr ); 
        strcpy ( err_str, err_ptr ); */
        *err_code = risca -> sqlcode ;
	/* exit (); */
        return ( -3 );
}
