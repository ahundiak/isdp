/*
 * Author: Jamal Shakra
 * Date: 2-13-92
 * This command replaces part pointers.
 */


#if ! defined(__sgi)
#include        "unistd.h"
#endif
#include 	"ciminimum.h"
#include 	"cimacros.h"
#include 	"PDUstr.h"
#include        "PDUpart.h"
#include        "ex.h"
#include        "igrdp.h"
#include 	"partmacros.h"
#include 	"part.h"
#include	"cieveryone.h"
#include	"cimacros.h"
#include	"acdef.h"
#include	"acmacros.h"
#include	"ACdb_info.h"
#include	"macro.h"
#include	"grdpbdef.h"
#include	"grdpb.h"
#include	"grdpbmacros.h"
#include	"growner.h"
#include	"igrdp.h"
#include	"madef.h"
#include	"exdef.h"
#include	"exmacros.h"
#include	"dp.h"
#include	"dpdef.h"
#include	"grcoordsys.h"
#include	"csdef.h"
#include	"msdef.h"
#include	"PDUint.h"
#include	"PDUintdef.h"
#include	"grsymdef.h"
#include	"grsym.h"
#include	"grownerdef.h"
#include 	"dpmacros.h"
#include 	"comiscmac.h"
#include 	"coplcmac.h"
#include 	"cotxmacros.h"
#include 	"partdef.h"
#include        "DItypedef.h"
#include        "DIdef.h"
#include        "DIglob.h"
#include        "DIprims.h"
#include        "expmacros.h"
#include        "csmacros.h"
#include        "MEMstruct.h"
#include        "PDUfile_def.h"
#include        "PDUinform.h"
#include        "PDUassy.h"
#include        "PDUforms.h"



/* External functions declaration section */
extern		GRdpb_get();
extern		COpart_construct_func();
extern          COpart_attr_func();
extern          DIfast_trans();
extern          DIgive_pathname();
extern          DImain();
extern          DIreport_error();
extern          DImkpath();
extern          DPdisbyoid();
extern          PDUgenerate_instance_number();
extern          PDUincrement_child_no();
extern          PDUgenerate_child_no();
extern          strcmp();
extern          malloc();
extern          PDUfill_in_string();
extern          PDUdisplay_GRpart();
extern          GRcsget_mgr();
extern          PDUrefresh_init();
extern          PDUpart_init();
extern          PDUunquote();
extern          GRdpb_put();
extern          PDUfree_string_array();
extern          PDUadd_assy_struct_from_buffer();
extern          PDUget_coord_sys_id();
extern          PDUupdate_structure();
extern          PDUget_GRpart_all_attrs();
extern          PDUget_GRparts_ids();
extern          PDUdoes_part_exist();
extern          PDUunquote();
extern          PDUevaluate_exp();
extern          PDUmatrix_to_point();
extern          MAinvmx();
extern          PDUadd_points();
extern          PDMquery_dynamic_attrs();
extern          PDUgenerate_tag_no();
extern          MEMbuild_array();
extern          PDUsetup_buffer();
extern          PDUincrement_tag_no();
extern          PDMget_assembly_structure();
extern          PDUget_buffer_col();
extern          PDUget_date();
extern          PDMget_catno_partno();
extern          PDUget_default_usage_id();
extern          MEMclose();
extern          DIpwd();
extern          DIcd();
extern          DIfind();
extern          free();
extern          memset();
extern          strncmp();
extern          _pdm_debug();
extern          _pdm_status();
extern          pdmoPlacePart();
extern          PDUdisplay_files_and_origins();
extern          PDUcheck_display_dynamic_attr();
extern          PDUcreate_dynamic_arrays();
extern          PDUdynamic_attr_form();
extern          PDUmessage();
extern          pdmoDeletePartOccurrence();
extern          PDUdisplay_design_form();
extern          PDMrcheck_part_status();
extern          PDUnullstr();


/* External variables declaration section */
extern          struct PDUrefresh        *refresh;
extern          struct PDUpart           *part;
extern          IGRchar                  PDU_place_part_by;
extern          IGRshort                 PDU_store_point;
extern          IGRdouble                PDU_point[3]; 
extern          IGRint                   PDU_message_type;
extern          IGRint                   PDU_prompt_type;
extern          IGRint			 PDM_debug_on;
extern          IGRshort                 PDU_loop_cmd;
extern          struct  GRid             *PDU_src_part_id;
extern          struct  GRid             *PDU_dst_part_id;
extern          struct  GRid             *PDU_part_id;
extern          IGRchar                  *PDU_from_catalog;
extern          IGRchar                  *PDU_from_partid;
extern          IGRchar                  *PDU_from_revision;
extern          IGRchar                  *PDU_from_usageid;
extern          IGRchar                  *PDU_to_usageid;
extern          IGRchar                  *PDU_assy_catalog;
extern          IGRchar                  *PDU_assy_partid;
extern          IGRchar                  *PDU_assy_revision;
extern          IGRshort                 PDU_replace_all_occur;
extern          IGRint                   PDU_command;
extern          MEMptr                   PDU_dyn_attr_bufr;
extern          MEMptr                   PDU_dyn_data_bufr;
extern          MEMptr                   PDU_dyn_value_bufr;
extern          MEMptr                   PDU_struct_bufr;
extern          IGRchar                  *PDU_usage_id;
extern          IGRshort                 PDU_list_parts;
extern          IGRchar                  *PDU_incl_BOM;
extern          IGRchar                  *PDU_incl_ASM;
extern          IGRchar                  *PDU_explode_BOM;
extern          IGRchar                  *PDU_quantity;
extern          IGRshort                 PDU_attach;
extern          IGRshort                 PDU_edit_display;
extern          IGRshort                 PDU_display_dyn_attr;
extern          Form                     PDU_form_id;
extern          struct PDUforms          forms;
extern          IGRchar                  *PDU_alt_tagno;
extern          IGRchar                  *PDU_tagno;
extern		IGRint			 PDU_instance_no;

/* TR# 139422348. 31/Jan/95 - raj. Macro to free and assign NULL. */
#define PDUfree_pointer(ptr)	\
{				\
  free ((char *) ptr);		\
  ptr = NULL;			\
}

/* Global variable declaration */

main()
{

 struct           GRmd_env  mod_env;		
 GRobjid          csmgr_id;
 struct           GRid      new_part_id;
 struct           GRid      act_coorid;
 struct           GRid      new_coorid;
 struct           GRobj_env objects[1];
 IGRdouble        point1[3];
 IGRdouble        point2[3];
 IGRdouble        point3[3];
 IGRlong          msg, sts;
 IGRlong          stat;
 IGRlong	  NumberOfBytes, BytesReceived;
 IGRchar          part_label[MAX_VALUE];
 IGRchar          attr_value[MAX_VALUE];
 IGRchar          usr_dir[DI_PATH_MAX];
 IGRchar          assy_dir[DI_PATH_MAX];
 IGRchar          part_dir[DI_PATH_MAX];
 IGRchar          pwd[DI_PATH_MAX];
 IGRchar          tmp_childno[DI_PATH_MAX];
 IGRchar          tmp_usageid[DI_PATH_MAX];
 IGRchar          usage_id[DI_PATH_MAX];
 IGRint           instance_no;
 IGRint           serial_no;
 IGRchar          str_serial_no[10];
 IGRint           i;
 IGRint           k;
 IGRint           display_flag;
 IGRshort         PointerLevel;
 IGRshort         ActiveLevel;
 IGRshort         cstype;
 IGRchar          unsigned weight;
 IGRchar          unsigned style;
 struct           IGRaltdisplay altdp_info;
 IGRchar          *dst_child_no;
 IGRchar          *new_child_no;
 IGRchar          *old_child_no;
 IGRint           type;
 IGRint           four;
 IGRint           count;
 IGRint           copy_depth;
 IGRint           occurence_count;
 IGRint           dst_part_exists;
 IGRchar          catalog[MAX_VALUE];
 IGRchar          number[MAX_VALUE];
 IGRchar          revision[MAX_VALUE];
 IGRchar          name[MAX_VALUE];
 IGRchar          qty[MAX_VALUE];
 IGRchar          src_tag[MAX_VALUE];
 IGRchar          src_alt_tag[MAX_VALUE];
 IGRchar          last_src_tag[MAX_VALUE];
 IGRchar          last_src_alt_tag[MAX_VALUE];
 IGRchar          part_type[MAX_VALUE];
 IGRchar          src_child_no[MAX_VALUE];
 IGRchar          src_serial_no[MAX_VALUE];
 IGRchar          *attach;
 IGRchar          *edit_display;
 IGRchar          *catalog_no;
 IGRchar          *item_no;
 IGRchar          *filename;
 IGRchar          *tmp_qty;
 IGRchar          s[DI_PATH_MAX];
 IGRchar          **attrs;
 IGRchar          **data;
 IGRchar          *p_explode;
 IGRchar          *tagno;
 IGRchar          *alt_tagno;
 IGRchar          tmp_tag[MAX_VALUE];
 IGRchar          tmp_alttag[MAX_VALUE];
 IGRchar          text_value[MAX_VALUE];
 IGRmatrix        trans_matrix;
 IGRint           basic_attr_count;
 IGRshort         increment_tag_no;
 IGRchar          **row_data;
 IGRint           cat_no_col;
 IGRint           item_no_col;
 IGRchar          part_date[26];
 struct PDUpoint  origin;
 struct PDUpoint  x_point;
 struct PDUpoint  y_point;
 struct GRid      *part_ids;
 FILE             *pdu_debug_file;
 IGRshort         SRC_GRAPHIC;
 IGRshort         DST_GRAPHIC;
 IGRshort         SRC_POSITIONED;
 double           quantity;
 int              dyn_attr_count;
 char             **dyn_attr_names;
 char             **dyn_attr_values;
 

 _pdm_debug("In the replace part ppl program", 0);

 PDUmessage(PDM_I_REPLACE_PART,'s');

 /* Initialize local variables */
 dst_child_no = NULL;
 new_child_no = NULL;
 old_child_no = NULL;
 catalog_no = NULL;
 item_no = NULL;
 filename = NULL;
 attrs = NULL;
 data = NULL;
 count = 0;
 four = 4;
 p_explode = NULL;
 PDU_dyn_attr_bufr = NULL;
 PDU_dyn_data_bufr = NULL;
 PDU_dyn_value_bufr = NULL;
 PDU_struct_bufr = NULL;
 basic_attr_count = 15;
 tagno = NULL;
 alt_tagno = NULL;
 increment_tag_no = FALSE;
 row_data = NULL;
 part_ids = NULL;
 SRC_GRAPHIC = FALSE;
 DST_GRAPHIC = FALSE;
 SRC_POSITIONED = FALSE;
 attach = NULL;
 edit_display = NULL;
 tmp_qty = NULL;
 dyn_attr_names = NULL;
 dyn_attr_values = NULL;
 dyn_attr_count = NULL;


 /* Get current module environment information */
 NumberOfBytes = sizeof(mod_env);
 stat = gr$get_module_env( 
                            msg = &msg,
			    sizbuf = &NumberOfBytes,
			    buffer = &(objects[0].mod_env),
			    nret = &BytesReceived 
                           );

 /* Default str_serial_no to "-1" */
 strcpy(str_serial_no, "-1");
 
 /* Set PDU_command to replace part command */
 PDU_command = PDC_M_REPLACE_PART;

 begincmd("locate part pointer");
 endcmd();

 if (PDU_part_id == NULL)
    {
     _pdm_debug("no PDU part located", 0);

     exit;
    }

 PDUmessage(PDM_I_REPLACE_PART,'s');

 /* Malloc space for PDU_src_part_id */
 PDU_src_part_id = (struct GRid *) malloc (sizeof(struct GRid));

 PDU_src_part_id->objid = PDU_part_id->objid;
 PDU_src_part_id->osnum = PDU_part_id->osnum;

 /* Display part file(s) and origin(s) */
 if (!PDUnullstr(part->view))
   PDUfill_in_string(&part->view, NULL);

 stat = PDUdisplay_files_and_origins(
                                    refresh->rev_catalog,
                                    refresh->rev_partid,
                                    refresh->rev_revision,
                                    &refresh->rev_filename,
                                    &part->view
                                   );
 if (!stat)
   {
   _pdm_debug("PDUdisplay_files_and_origins failed", 0);
   exit;
   }

 stat = PDMrcheck_part_status(refresh->rev_catalog, refresh->rev_partid, 
                              refresh->rev_revision);
 if (stat != PDM_I_NEVER_CHECKED_IN)
   {
   if (part->view == NULL)
     {
     PDUmessage(PDM_E_NO_VIEWS_DEFINED, 's');
     exit;
     }
  else if (strcmp(part->view, "") == 0)
    {
     PDUmessage(PDM_E_NO_VIEWS_DEFINED, 's');
     exit;
     }
   }
 
 /* Case I: destination part does not exist in obj space and single
  *           replacement mode is either on or off.
  */
  _pdm_debug("entering Case I", 0);

     /* Check to see if destination part exists in obj space */
     dst_part_exists = PDUdoes_part_exist(
                                          refresh->rev_catalog,
                                          refresh->rev_partid,
                                          refresh->rev_revision
                                         );

     /* Get path to active file */
     di$give_pathname(
                      osnum = objects[0].mod_env.md_id.osnum,
                      pathname = part_dir
                     );

     /* Extract source part catalog */
      co$part_get_attr (
                        msg = &msg,
                        mod_env = &(objects[0].mod_env),
                        part = PDU_src_part_id,
                        attr = "CATALOG",
                        value = catalog,
                        type = &type
                       );

     /* Extract source part number */
      co$part_get_attr (
                        msg = &msg,
                        mod_env = &(objects[0].mod_env),
                        part = PDU_src_part_id,
                        attr = "NUMBER",
                        value = number,
                        type = &type
                       );

     /* Extract source part revision */
      co$part_get_attr (
                        msg = &msg,
                        mod_env = &(objects[0].mod_env),
                        part = PDU_src_part_id,
                        attr = "REVISION",
                        value = revision,
                        type = &type
                       );

      co$part_get_attr (
                        msg = &msg,
                        mod_env = &(objects[0].mod_env),
                        part = PDU_src_part_id,
                        attr = "quantity",
                        value = qty,
                        type = &type
                        );
     PDUfill_in_string(&tmp_qty, qty);
     _pdm_debug("tmp_qty = <%s>", tmp_qty);
     PDUfill_in_string(&PDU_quantity, qty);
     /* Extract source part tag */
      co$part_get_attr (
                        msg = &msg,
                        mod_env = &(objects[0].mod_env),
                        part = PDU_src_part_id,
                        attr = "tag",
                        value = last_src_tag,
                        type = &type
                       );
      PDUunquote(last_src_tag);

      /* Extract source part alt tag */
      co$part_get_attr (
                        msg = &msg,
                        mod_env = &(objects[0].mod_env),
                        part = PDU_src_part_id,
                        attr = "alt_tag",
                        value = last_src_alt_tag,
                        type = &type
                       );
     PDUunquote(last_src_alt_tag);

     /* Extract source part part type */
     co$part_get_attr (
                       msg = &msg,
                       mod_env = &(objects[0].mod_env),
                       part = PDU_src_part_id,
                       attr = "part_type",
                       value = part_type,
                       type = &type
                      );

     /* Extract source part serial no */
     co$part_get_attr (
                       msg = &msg,
                       mod_env = &(objects[0].mod_env),
                       part = PDU_src_part_id,
                       attr = "serial",
                       value = src_serial_no,
                       type = &type
                      );

      SRC_GRAPHIC = ( (strcmp(part_type, "G") == 0) ||
                      (strcmp(part_type, "g") == 0) ||
                      (strcmp(part_type, "D") == 0) ||
                      (strcmp(part_type, "d") == 0) || 
                      (strcmp(part_type, "P") == 0) ||
                      (strcmp(part_type, "p") == 0) );

      DST_GRAPHIC = ( (strcmp(refresh->rev_parttype, "G") == 0) ||
                      (strcmp(refresh->rev_parttype, "g") == 0) ||
                      (strcmp(refresh->rev_parttype, "D") == 0) ||
                      (strcmp(refresh->rev_parttype, "d") == 0) );

      SRC_POSITIONED = ( (strcmp(src_serial_no, "-1.000000") != 0) &&
                         SRC_GRAPHIC );

      if ( (!SRC_POSITIONED) || (!SRC_GRAPHIC) || (!DST_GRAPHIC) )
         {
          if ((PDU_replace_all_occur == TRUE) && (!SRC_POSITIONED))
             {
              status("Only replace one is allowed for positionless parts");
              exit;
             }
          if (PDU_replace_all_occur == TRUE)
             {
              status("Only single replacement is allowed for nongraphic parts");
              exit;
             }

          /* Get child no */
          stat = PDUgenerate_child_no(
                                      &old_child_no,
                                      objects[0].mod_env.md_id.osnum
                                     );
          _pdm_status("PDUgenerate_child_no", stat);

          /* Initialize PDU_usage_id */
          if (PDU_usage_id == NULL)
            _pdm_debug("PDU_usageid is NULL", 0);
          else if (strcmp(PDU_usage_id, "") == 0)
            _pdm_debug("PDU_usageid is NULL", 0);
          else
             {
              free(PDU_usage_id);
              PDU_usage_id = NULL;
             }

          /* Put place part command on the queue */
          begincmd_key("PDPPr");
          endcmd();

          /* Check if placement was successful */
          stat = PDUgenerate_child_no(
                                      &new_child_no,
                                      objects[0].mod_env.md_id.osnum
                                     );

          if (strcmp(old_child_no, new_child_no) != 0)
             {
              /* Delete source part */
              PDU_list_parts = FALSE;
              PDU_loop_cmd = FALSE;

              begincmd("delete part pointer");
                       ci$put(obj = PDU_src_part_id->objid, pos = FRONT);
              endcmd();
             }

          exit;
         }

     if (dst_part_exists)
        {
         /* Load tag and alt tag from other occurences */
         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           catalog = refresh->rev_catalog,
                           number = refresh->rev_partid,
                           revision = refresh->rev_revision,
                           attr = "tag",
                           value = src_tag,
                           type = &type
                          );

         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           catalog = refresh->rev_catalog,
                           number = refresh->rev_partid,
                           revision = refresh->rev_revision,
                           attr = "alt_tag",
                           value = src_alt_tag,
                           type = &type
                          );
        }

     PDUunquote(src_tag);
     PDUunquote(src_alt_tag);

     /* Construct path to part directory */
     sprintf(
             s,
             "%s:parts:%s:%s!%s:",
             part_dir,
             catalog,
             number,
             revision 
            );

     _pdm_debug("part full path = <%s>", s);

     /* Get obj id's of all source occurences */
     stat = PDUget_GRparts_ids(
                                 s,
                                 &part_ids,
                                 &occurence_count
                                );

     _pdm_status("PDUget_GRparts_ids", stat);

     if (occurence_count <= 0)
        {
         _pdm_debug("SEVERE error: no occurences found", 0);
         PDUmessage(PDM_E_FROM_PART_OCCUR,'s');
         delay();

         exit;
        }

     /* Check to see if need to get 1st occurence part id */
     if (PDU_src_part_id == NULL)
        {
         /* Malloc space for PDU_src_part_id */
         PDU_src_part_id = (struct GRid *) malloc (sizeof(struct GRid));

         PDU_src_part_id->objid = part_ids[0].objid;
         PDU_src_part_id->osnum = part_ids[0].osnum;  
        }

     /* Extract child no of source part */
     co$part_get_attr (
                       msg = &msg,
                       mod_env = &(objects[0].mod_env),
                       part = PDU_src_part_id,
                       attr = "child_no",
                       value = attr_value,
                       type = &type
                      );
     PDUunquote(attr_value);

     /* Extract serial no of source part */
     co$part_get_attr (
                       msg = &msg,
                       mod_env = &(objects[0].mod_env),
                       part = PDU_src_part_id,
                       attr = "serial",
                       value = attr_value,
                       type = &type
                      );

     /* Convert serial to integer */
     sscanf(attr_value, "%d", &serial_no);

     if (SRC_POSITIONED)
        {
         /* Extract source part coord sys transition matrix */
         stat = ci$send(
                          msg = message GRgencs.GRgetmatrix
                                               (
                                                &sts,
                                                trans_matrix
                                               ),
                          targetid = serial_no,
                          targetos = objects[0].mod_env.md_id.osnum
                         );

         /* Extract origin of source part coord system */
         stat = PDUmatrix_to_point (
                                      trans_matrix,
                                      &origin
                                     );

         /* Need to find x-axis and y-axis points on source coord sys */
         MAinvmx (
                  &sts,
                  &four,
                  trans_matrix,
                  trans_matrix
                 );

         stat = PDUadd_points (
                                 trans_matrix,
                                 origin,
                                 &x_point,
                                 0,
                                 1,
                                 2
                                );

          stat = PDUadd_points (
                                  trans_matrix,
                                  origin,
                                  &y_point,
                                  4,
                                  5,
                                  6
                                 );
      }

      /* Delete source part */
      PDU_loop_cmd = FALSE;

      begincmd("delete part pointer");
               ci$put(obj = PDU_src_part_id->objid, pos = FRONT);
      endcmd();

     stat = PDUgenerate_instance_number(
                                          refresh->rev_catalog,
                                          refresh->rev_partid,
                                          refresh->rev_revision,
                                          &instance_no,
                                          &(objects[0].mod_env)
                                         );

     _pdm_debug("instance no = %d", instance_no);

/* MJG - 10/3/95 - Save instance number for later use. */
     PDU_instance_no = instance_no;

     _pdm_debug("occurence count = %d", occurence_count);

     if (instance_no == 1)
        /* This is the first instance, need to generate a unique tag number */
        {
         if ( (occurence_count <= 1 ) || (PDU_replace_all_occur == TRUE) )
            {
             /* Carry over tag and alt tag from source part */
             strcpy(src_tag, last_src_tag);
             strcpy(src_alt_tag, last_src_alt_tag);
            }

         else
             {
              stat = PDUgenerate_tag_no(
                                         &tagno,
                                         objects[0].mod_env.md_id.osnum
                                        );

              _pdm_debug("tagno = <%s>", tagno);

              strcpy(src_tag, tagno);
              strcpy(src_alt_tag, "");

              /* Set increment tag no flag to TRUE */
              increment_tag_no = TRUE;
             }
        }

     if (PDU_to_usageid == NULL) 
        {
         /* Default usage id */
         stat = PDUget_default_usage_id(
                                        refresh->rev_catalog,
                                        refresh->rev_partid,
                                        refresh->rev_revision,
                                        part_label
                                       );

         if (stat != PDM_S_SUCCESS)
            {
             _pdm_debug("PDUget_default_usage_id failed", 0);
             exit;
            }
        }

     else if (strcmp(PDU_to_usageid, "") == 0)
        {
         /* Default usage id */
         stat = PDUget_default_usage_id(
                                        refresh->rev_catalog,
                                        refresh->rev_partid,
                                        refresh->rev_revision,
                                        part_label
                                       );

         if (stat != PDM_S_SUCCESS)
            {
             _pdm_debug("PDUget_default_usage_id failed", 0);
             exit;
            }
        }

     else
         {
          strcpy(part_label, PDU_to_usageid); 
         }

     /* Check to see if part label exceeds 25 characters */
     if (strlen(part_label) > 25)
        {
         /* Use catalog no/part no pairs in the default usage id */
         stat = PDMget_catno_partno(
                                      refresh->rev_catalog,
                                      refresh->rev_partid,
                                      refresh->rev_revision,
                                      &catalog_no,
                                      &item_no
                                     );
         _pdm_status("PDMget_catno_partno", stat);

         if (stat != PDM_S_SUCCESS)
            {
             _pdm_debug("SEVERE error: PDMget_catno_partno failed", 0);
             exit;
            }

         /* Default usage id */
         sprintf(
                 part_label,
                 "%s %s #%d",
                 catalog_no,
                 item_no,
                 instance_no
                );
        }

     strcpy(usage_id, part_label);

     if (SRC_POSITIONED && DST_GRAPHIC)
        {
         /* Construct the new coord sys (new part pointer) */
         point1[0] = origin.x;
         point1[1] = origin.y;
         point1[2] = origin.z;

         point2[0] = x_point.x;
         point2[1] = x_point.y;
         point2[2] = x_point.z;

         point3[0] = y_point.x;
         point3[1] = y_point.y;
         point3[2] = y_point.z;

        }

 PDUfill_in_string(&PDU_alt_tagno, src_alt_tag);
 PDUfill_in_string(&PDU_tagno, src_tag);
 PDUfill_in_string(&PDU_usage_id, part_label);
 if (PDU_dyn_attr_bufr)
   {
   MEMclose(&PDU_dyn_attr_bufr);
   PDU_dyn_attr_bufr = NULL;
   }
 if (PDU_dyn_data_bufr)
   {
   MEMclose(&PDU_dyn_data_bufr);
   PDU_dyn_data_bufr = NULL;
   }
 if (PDU_dyn_value_bufr)
   {
   MEMclose(&PDU_dyn_value_bufr);
   PDU_dyn_value_bufr = NULL;
   }

 /* Extract dynamic attributes from PDM if any, and display them on form */
 stat = PDMquery_dynamic_attrs(
                               refresh->rev_catalog,
                               refresh->rev_partid,
                               refresh->rev_revision,
                               &PDU_dyn_attr_bufr,
                               &PDU_dyn_data_bufr,
                               &PDU_dyn_value_bufr,
                               &p_explode
                              );
 _pdm_status("PDMquery_dynamic_attrs", stat);

 /* Display dynamic attributes form, if necessary */
 if (PDU_display_dyn_attr)
    {
     stat = display_dynamic_form();
     _pdm_status("display_dynamic_form", stat);

     if (stat == 0)
        return(0);
    }
  else
    {
    display_flag = PDUcheck_display_dynamic_attr(PDU_dyn_attr_bufr, 
                                                 PDU_dyn_data_bufr);
    _pdm_debug("display flag = <%d>", (char *)display_flag);
    if (display_flag)
      {
      stat = display_dynamic_form();
      _pdm_status("display_dynamic_form", stat);
      if (stat == 0)
        return(0);
      }
    }

 strcpy(part_label, PDU_usage_id);
 stat = PDUcreate_dynamic_arrays(
                                 PDU_dyn_attr_bufr,
                                 PDU_dyn_data_bufr,
                                 &dyn_attr_count,
                                 &dyn_attr_names, 
                                 &dyn_attr_values
                                );
 _pdm_status("PDUcreate_dynamic_arrays", stat);

 PDU_form_id = forms.design_form_id;
        /* call pdmoPlacePart */
        sscanf(qty, "%lf", &quantity);
        if (PDU_attach)
          PDUfill_in_string(&attach, "Y");
        else
          PDUfill_in_string(&attach, "N");
        if (PDU_edit_display)
          PDUfill_in_string(&edit_display, "Y");
        else
          PDUfill_in_string(&edit_display, "N");
        stat = pdmoPlacePart(
                         &msg,
                         NULL,
                         &new_part_id,
                         refresh->rev_catalog,
                         refresh->rev_partid,
                         refresh->rev_revision,
                         refresh->rev_filename,
                         part_label,
                         part->view,
                         quantity,
                         PDU_explode_BOM,
                         attach,
                         src_alt_tag,
                         PDU_incl_ASM,
                         PDU_incl_BOM,
                         dyn_attr_count,
                         dyn_attr_names,
                         dyn_attr_values,
                         0,
                         NULL,
                         NULL,
                         point1,
                         point2,
                         point3,
                         NULL,
                         edit_display
                        );

          if (stat == PDM_S_SUCCESS)
             {
              _pdm_debug("obj id of new part = %d", new_part_id.objid);

              /* Free variables */
               if (PDU_src_part_id)
                 {
                  free(PDU_src_part_id);
                  PDU_src_part_id = NULL;
                 }

              if (PDU_usage_id)
                {
                free(PDU_usage_id);
                PDU_usage_id = NULL;
                }

              if (PDU_tagno)
                PDUfree_pointer(PDU_tagno);

              if (PDU_alt_tagno)
                PDUfree_pointer(PDU_alt_tagno);

              if (PDU_quantity)
                {
                free(PDU_quantity);
		PDU_quantity = NULL;
                }

              if (part_ids)
                 PDUfree_pointer(part_ids);

              if (tagno)
                 PDUfree_pointer(tagno);

              if (new_child_no)
                 PDUfree_pointer(new_child_no);

              if (catalog_no)
                 PDUfree_pointer(catalog_no);

              if (item_no)
                 PDUfree_pointer(item_no);

               if (PDU_replace_all_occur == FALSE)
                  _pdm_debug("PDU_replace_all_occur is FALSE", 0);

               _pdm_debug("occurence_count = %d", occurence_count);

               /* Check if multiple occurence replacement mode is on */
               if ( (PDU_replace_all_occur == TRUE) && (occurence_count > 1) )
                  {
                   /* This case simply reduces to Case II */
                   PDU_dst_part_id = (struct GRid *) malloc
                                                         (sizeof(struct GRid));

                   PDU_dst_part_id->objid = new_part_id.objid;
                   PDU_dst_part_id->osnum = new_part_id.osnum;

                   new_child_no = NULL;
                   catalog_no = NULL;
                   item_no = NULL;

                   goto CaseII_again;
                  }
             }

          else
            {
            PDUmessage(stat, 's');
            stat = pdmoDeletePartOccurrence(&msg, NULL, &new_part_id);
            _pdm_status("pdmoDeletePartOccurrence", stat);
            if (PDU_usage_id)
              {
              free(PDU_usage_id);
              PDU_usage_id = NULL;
              }

            if (PDU_tagno)
              PDUfree_pointer(PDU_tagno);

            if (PDU_alt_tagno)
              PDUfree_pointer(PDU_alt_tagno);

            if (PDU_quantity)
              PDUfree_pointer(PDU_quantity);

            PDUdisplay_design_form();
            exit;
            }

 exit;

 /* Case II: both source and destination parts are specified by point or 
  *          both are present in field and multiple replacemant mode is on.
  */
  CaseII_again:

     _pdm_debug("entering Case II", 0);

     /* Construct path to part directory */
     sprintf(
             s,
             "%s:parts:%s:%s!%s:",
             part_dir,
             catalog,
             number,
             revision 
            );

     _pdm_debug("part full path in Case II = <%s>", s);

     /* Get obj id's of all source occurences */
     stat = PDUget_GRparts_ids(
                                 s,
                                 &part_ids,
                                 &occurence_count
                                );

     _pdm_status("PDUget_GRparts_ids", stat);

     if (occurence_count > 0)
        {
         _pdm_debug("%d occurences were found", occurence_count);

         /* Extract destination part catalog */
         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           part = PDU_dst_part_id,
                           attr = "CATALOG",
                           value = catalog,
                           type = &type
                          );

         /* Extract destination part number */
         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           part = PDU_dst_part_id,
                           attr = "NUMBER",
                           value = number,
                           type = &type
                          );

         /* Extract destination part revision */
         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           part = PDU_dst_part_id,
                           attr = "REVISION",
                           value = revision,
                           type = &type
                          );

         /* Extract destination part name */
         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           part = PDU_dst_part_id,
                           attr = "NAME",
                           value = name,
                           type = &type
                          );

         /* Extract destination part child no */
         co$part_get_attr (
                           msg = &msg,
                           mod_env = &(objects[0].mod_env),
                           part = PDU_dst_part_id,
                           attr = "child_no",
                           value = attr_value,
                           type = &type
                          );

         /* Unquote child no value */
         PDUunquote(attr_value);

         PDUfill_in_string(&dst_child_no, attr_value);

         /* Loop thru replacing source part occurences */
         for (k = 0; k < occurence_count; k = k + 1)
             {
              /* Extract child no of source part */
              co$part_get_attr (
                                msg = &msg,
                                mod_env = &(objects[0].mod_env),
                                part = &part_ids[k],
                                attr = "child_no",
                                value = attr_value,
                                type = &type
                               );
               PDUunquote(attr_value);

              /* Extract serial no of source part occurence */
              co$part_get_attr (
                                msg = &msg,
                                mod_env = &(objects[0].mod_env),
                                part = &part_ids[k],
                                attr = "serial",
                                value = attr_value,
                                type = &type
                               );

              /* Convert serial to integer */
              sscanf(attr_value, "%d", &serial_no);

              /* Extract source part coord sys transition matrix */
              stat = ci$send(
                               msg = message GRgencs.GRgetmatrix
                                                    (
                                                     &sts,
                                                     trans_matrix
                                                    ),
                               targetid = serial_no,
                               targetos = objects[0].mod_env.md_id.osnum
                              );

              /* Extract origin of source part coord system */
              stat = PDUmatrix_to_point (
                                           trans_matrix,
                                           &origin
                                          );

              /* Need to find x-axis and y-axis points on source coord sys */
              MAinvmx (
                       &sts,
                       &four,
                       trans_matrix,
                       trans_matrix
                      );

              stat = PDUadd_points (
                                      trans_matrix,
                                      origin,
                                      &x_point,
                                      0,
                                      1,
                                      2
                                     );

               stat = PDUadd_points (
                                       trans_matrix,
                                       origin,
                                       &y_point,
                                       4,
                                       5,
                                       6
                                      );

               /* Delete source occurence part */
               PDU_loop_cmd = FALSE;

               begincmd("delete part pointer");
                        ci$put(obj = part_ids[k].objid, pos = FRONT);
               endcmd();

              /* Default usage id */
              stat = PDUget_default_usage_id(
                                             catalog,
                                             number,
                                             revision,
                                             part_label
                                            );

              if (stat != PDM_S_SUCCESS)
                 {
                  _pdm_debug("PDUget_default_usage_id failed", 0);
                  exit;
                 }

              strcpy(usage_id, part_label);

              /* Construct the new coord sys (new part pointer) */
              point1[0] = origin.x;
              point1[1] = origin.y;
              point1[2] = origin.z;

              point2[0] = x_point.x;
              point2[1] = x_point.y;
              point2[2] = x_point.z;

              point3[0] = y_point.x;
              point3[1] = y_point.y;
              point3[2] = y_point.z;

              /* call pdmoPlacePart */
        sscanf(qty, "%lf", &quantity);
        if (PDU_attach)
          PDUfill_in_string(&attach, "Y");
        else
          PDUfill_in_string(&attach, "N");
        if (PDU_edit_display)
          PDUfill_in_string(&edit_display, "Y");
        else
          PDUfill_in_string(&edit_display, "N");
        stat = pdmoPlacePart(
                         &msg,
                         NULL,
                         &new_part_id,
                         refresh->rev_catalog,
                         refresh->rev_partid,
                         refresh->rev_revision,
                         refresh->rev_filename,
                         part_label,
                         part->view,
                         quantity,
                         PDU_explode_BOM,
                         attach,
                         src_alt_tag,
                         PDU_incl_ASM,
                         PDU_incl_BOM,
                         0,
                         NULL,
                         NULL,
                         0,
                         NULL,
                         NULL,
                         point1,
                         point2,
                         point3,
                         NULL,
                         edit_display
                        );

          if (stat != PDM_S_SUCCESS)
              {
               _pdm_debug("SEVERE error: co$part_construct failed", 0);
               PDUmessage(PDM_E_CONSTRUCT_PART,'s');
               delay();

               exit;
              }

             } /* end for loop */
           
         /* Free PDU_src_part_id and PDU_dst_part_id */
         if (PDU_src_part_id)
            {
             free(PDU_src_part_id);
             PDU_src_part_id = NULL;
            }

         if (PDU_dst_part_id)
            {
             free(PDU_dst_part_id);
             PDU_dst_part_id = NULL;
            }
 
         /* Free variables */
         if (part_ids)
            PDUfree_pointer(part_ids);

         if (dst_child_no)
            PDUfree_pointer(dst_child_no);

          if (new_child_no)
             PDUfree_pointer(new_child_no);

          if (catalog_no)
              PDUfree_pointer(catalog_no);

          if (item_no)
             PDUfree_pointer(item_no);

          if (filename)
             PDUfree_pointer(filename);

          exit;
        }

      else
          {
           _pdm_debug("SEVERE error: no source part occurences found", 0);
           PDUmessage(PDM_E_FROM_PART_OCCUR,'s');
           delay();
 
           exit;
          }
}

int display_dynamic_form()

  {
  int response;
  int stat;

  _pdm_debug("Entering PDUdynamic_attr_form", 0);
  stat = PDUdynamic_attr_form();

  /* Pause until the form is accepted or cancelled */
  _pdm_debug("Waiting on input", 0);
  do {
     ci$get(prompt = "", response = &response);
     }while (response != MOVE_ON && response!= RESET);

  if (response == MOVE_ON)
    {
     return(1);
    }

  if (response == RESET)
    {
     /* Restore stat */
     PDUfill_in_string(&PDU_alt_tagno, "");
     return(0);
    }

  }

int  delay()

 {
  int  i;

  for (i = 0; i < 20000; i = i + 1);
 }

/* 09/Sep/94 - raj. TR# 139418616. Display Design Operations form
   at the end of command. Display of the same form at the end of
   rep_ppart.u is no longer done.	*/

extern	FIf_display();

delete()
{
  _pdm_debug("delete() of replace_part", 0);
  FIf_display(forms.design_form_id);
}


