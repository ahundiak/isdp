#include "machine.h"
#include "SQL.h"

 extern struct SQLglobal_st SQLglobal ;

 extern long SQLquery_count;
 extern int  SQLcursor[41];
 extern long SQLcursor_count[41];

 exec sql begin declare section;
         sqlda	out_desc_21;
         sqlda	out_desc_22;
         sqlda	out_desc_23;
         sqlda	out_desc_24;
         sqlda	out_desc_25;
         sqlda	out_desc_26;
         sqlda	out_desc_27;
         sqlda	out_desc_28;
         sqlda	out_desc_29;
         sqlda	out_desc_30;
 exec sql end declare section;

 char   *malloc (), *calloc ();

/*  This query routine was developed to be used with large query buffers
 *  where only portions of the data are to be returned. Cursor 2 is used
 *  for display items (full listing).
 */

 long  SQLquery_cursor21 (sql_str21, list, size, rows)
    exec sql begin declare section;
      char     *sql_str21;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor21" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str21, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[21] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[21] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt21" ));
        exec sql prepare stmt21 from : sql_str21;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt21;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_21.sqld = 0;
       out_desc_21.sqln = 0;
       out_desc_21.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt21 using descriptor out_desc_21;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt21;
           return (status);
        }
    } /* if( !SQLcursor[21] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt21;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt21;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[21] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_21" ));
        out_desc_21.sqlvar = (sqlvar *)calloc(out_desc_21.sqld, sizeof (sqlvar));
        if (! out_desc_21.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt21;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_21.sqln = out_desc_21.sqld;

        exec sql describe output stmt21 using descriptor out_desc_21;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt21;
        free (out_desc_21.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_21.sqld; ++i)
        {
          out_desc_21.sqlvar [i].sqldata =
                 calloc (1, out_desc_21.sqlvar [i].sqllen);
          if (! out_desc_21.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_21.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_21.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt21;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_21.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_21.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_21.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_21.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_21.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt21;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_21.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_21.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_21.sqld; ++x)
                free (out_desc_21.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_21.sqld; ++x)
                free (out_desc_21.sqlvar [x].sqlind);

             exec sql clear stmt21;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_21.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[21] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_21.sqld ));
       for (i = 0; i < out_desc_21.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_21.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_21.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_21.sqld; ++x)
                   free (out_desc_21.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_21.sqld; ++x)
                   free (out_desc_21.sqlvar [x].sqlind);

                exec sql clear stmt21;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_21.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_21.sqlvar [i].sqlname.sqlnamec,
		       out_desc_21.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_21.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_21.sqld; ++x)
                   free (out_desc_21.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_21.sqld; ++x)
                   free (out_desc_21.sqlvar [x].sqlind);

                 exec sql clear stmt21;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_21.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_21.sqld; ++x)
                   free (out_desc_21.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_21.sqld; ++x)
                   free (out_desc_21.sqlvar [x].sqlind);

                 exec sql clear stmt21;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_21.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[21] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs21 cursor for stmt21;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqlind);

          exec sql clear stmt21;
          free (out_desc_21.sqlvar);
          return (status);
        }

       exec sql open curs21;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqlind);

          exec sql clear stmt21;
          free (out_desc_21.sqlvar);
          return (status);
        }
    SQLcursor[21] = 1;

    } /* end if( !SQLcursor[21] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[21] != 0 )
    {
        for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqlind);

        exec sql close curs21;
        exec sql clear stmt21;

        free (out_desc_21.sqlvar); 
    }
    SQLcursor[21] = 0;
    SQLcursor_count[21] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs21 using descriptor out_desc_21;
       _SQLdebug(( fname, "%s\n", "Fetch curs21 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[21] && ( SQLcursor_count[21] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqlind);

          exec sql close curs21;
          exec sql clear stmt21;

          free (out_desc_21.sqlvar); 
          SQLcursor[21] = 0;
          SQLcursor_count[21] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqlind);

          exec sql close curs21;
          exec sql clear stmt21;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_21.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[21] = 0;
          SQLcursor_count[21] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[21];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_21.sqld; ++i)
           {
             if (*out_desc_21.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_21.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_21.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_21.sqld; ++x)
                       free (out_desc_21.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_21.sqld; ++x)
                       free (out_desc_21.sqlvar [x].sqlind);

                     exec sql close curs21;
                     exec sql clear stmt21;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_21.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[21] = 0;
	             SQLcursor_count[21] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_21.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_21.sqlvar[i].sqllen, 
                  out_desc_21.sqlvar[i].sqllen, out_desc_21.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_21.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_21.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_21.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_21.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_21.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_21.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_21.sqld; ++x)
                    free (out_desc_21.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_21.sqld; ++x)
                    free (out_desc_21.sqlvar [x].sqlind);

                  exec sql close curs21;
                  exec sql clear stmt21;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_21.sqlvar);
 	          SQLcursor[21] = 0;
  	          SQLcursor_count[21] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_21.sqld; ++x)
                    free (out_desc_21.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_21.sqld; ++x)
                    free (out_desc_21.sqlvar [x].sqlind);

                  exec sql close curs21;
                  exec sql clear stmt21;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_21.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[21] = 0;
	          SQLcursor_count[21] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_21.sqld; ++x)
               free (out_desc_21.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_21.sqld; ++x)
               free (out_desc_21.sqlvar [x].sqlind);

              exec sql close curs21;
              exec sql clear stmt21;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_21.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[21] = 0;
              SQLcursor_count[21] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs21 using descriptor out_desc_21;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[21] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_21.sqld; ++x)
               free (out_desc_21.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_21.sqld; ++x)
               free (out_desc_21.sqlvar [x].sqlind);

             exec sql close curs21;
             exec sql clear stmt21;
             free (str);

             free (out_desc_21.sqlvar);
             SQLcursor[21] = 0;
             SQLcursor_count[21] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[21];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs21;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_21.sqld; ++x)
            free (out_desc_21.sqlvar [x].sqlind);

          exec sql clear stmt21;
          free (str);

          free (out_desc_21.sqlvar);
          SQLcursor[21] = 0;
          SQLcursor_count[21] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_21.sqld; ++i)
        {
          free (out_desc_21.sqlvar [i].sqldata);
          free (out_desc_21.sqlvar [i].sqlind);
        }

       free (out_desc_21.sqlvar);

       exec sql clear stmt21;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[21] = 0;
	  SQLcursor_count[21] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[21] = 0;
       SQLcursor_count[21] = 0;
       return (SQL_I_NO_MORE_DATA);
    }


 long  SQLquery_cursor22 (sql_str22, list, size, rows)
    exec sql begin declare section;
      char     *sql_str22;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor22" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str22, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[22] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[22] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt22" ));
        exec sql prepare stmt22 from : sql_str22;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt22;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_22.sqld = 0;
       out_desc_22.sqln = 0;
       out_desc_22.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt22 using descriptor out_desc_22;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt22;
           return (status);
        }
    } /* if( !SQLcursor[22] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt22;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt22;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[22] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_22" ));
        out_desc_22.sqlvar = (sqlvar *)calloc(out_desc_22.sqld, sizeof (sqlvar));
        if (! out_desc_22.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt22;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_22.sqln = out_desc_22.sqld;

        exec sql describe output stmt22 using descriptor out_desc_22;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt22;
        free (out_desc_22.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_22.sqld; ++i)
        {
          out_desc_22.sqlvar [i].sqldata =
                 calloc (1, out_desc_22.sqlvar [i].sqllen);
          if (! out_desc_22.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_22.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_22.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt22;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_22.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_22.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_22.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_22.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_22.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt22;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_22.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_22.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_22.sqld; ++x)
                free (out_desc_22.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_22.sqld; ++x)
                free (out_desc_22.sqlvar [x].sqlind);

             exec sql clear stmt22;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_22.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[22] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_22.sqld ));
       for (i = 0; i < out_desc_22.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_22.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_22.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_22.sqld; ++x)
                   free (out_desc_22.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_22.sqld; ++x)
                   free (out_desc_22.sqlvar [x].sqlind);

                exec sql clear stmt22;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_22.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_22.sqlvar [i].sqlname.sqlnamec,
		       out_desc_22.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_22.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_22.sqld; ++x)
                   free (out_desc_22.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_22.sqld; ++x)
                   free (out_desc_22.sqlvar [x].sqlind);

                 exec sql clear stmt22;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_22.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_22.sqld; ++x)
                   free (out_desc_22.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_22.sqld; ++x)
                   free (out_desc_22.sqlvar [x].sqlind);

                 exec sql clear stmt22;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_22.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[22] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs22 cursor for stmt22;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqlind);

          exec sql clear stmt22;
          free (out_desc_22.sqlvar);
          return (status);
        }

       exec sql open curs22;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqlind);

          exec sql clear stmt22;
          free (out_desc_22.sqlvar);
          return (status);
        }
    SQLcursor[22] = 1;

    } /* end if( !SQLcursor[22] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[22] != 0 )
    {
        for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqlind);

        exec sql close curs22;
        exec sql clear stmt22;

        free (out_desc_22.sqlvar); 
    }
    SQLcursor[22] = 0;
    SQLcursor_count[22] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs22 using descriptor out_desc_22;
       _SQLdebug(( fname, "%s\n", "Fetch curs22 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[22] && ( SQLcursor_count[22] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqlind);

          exec sql close curs22;
          exec sql clear stmt22;

          free (out_desc_22.sqlvar); 
          SQLcursor[22] = 0;
          SQLcursor_count[22] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqlind);

          exec sql close curs22;
          exec sql clear stmt22;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_22.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[22] = 0;
          SQLcursor_count[22] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[22];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_22.sqld; ++i)
           {
             if (*out_desc_22.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_22.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_22.sqlvar[i].sqllen + 22);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_22.sqld; ++x)
                       free (out_desc_22.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_22.sqld; ++x)
                       free (out_desc_22.sqlvar [x].sqlind);

                     exec sql close curs22;
                     exec sql clear stmt22;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_22.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[22] = 0;
	             SQLcursor_count[22] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_22.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_22.sqlvar[i].sqllen, 
                  out_desc_22.sqlvar[i].sqllen, out_desc_22.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_22.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_22.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_22.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_22.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_22.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_22.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_22.sqld; ++x)
                    free (out_desc_22.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_22.sqld; ++x)
                    free (out_desc_22.sqlvar [x].sqlind);

                  exec sql close curs22;
                  exec sql clear stmt22;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_22.sqlvar);
 	          SQLcursor[22] = 0;
  	          SQLcursor_count[22] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_22.sqld; ++x)
                    free (out_desc_22.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_22.sqld; ++x)
                    free (out_desc_22.sqlvar [x].sqlind);

                  exec sql close curs22;
                  exec sql clear stmt22;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_22.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[22] = 0;
	          SQLcursor_count[22] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_22.sqld; ++x)
               free (out_desc_22.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_22.sqld; ++x)
               free (out_desc_22.sqlvar [x].sqlind);

              exec sql close curs22;
              exec sql clear stmt22;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_22.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[22] = 0;
              SQLcursor_count[22] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs22 using descriptor out_desc_22;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[23] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_22.sqld; ++x)
               free (out_desc_22.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_22.sqld; ++x)
               free (out_desc_22.sqlvar [x].sqlind);

             exec sql close curs22;
             exec sql clear stmt22;
             free (str);

             free (out_desc_22.sqlvar);
             SQLcursor[22] = 0;
             SQLcursor_count[22] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[22];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs22;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_22.sqld; ++x)
            free (out_desc_22.sqlvar [x].sqlind);

          exec sql clear stmt22;
          free (str);

          free (out_desc_22.sqlvar);
          SQLcursor[22] = 0;
          SQLcursor_count[22] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_22.sqld; ++i)
        {
          free (out_desc_22.sqlvar [i].sqldata);
          free (out_desc_22.sqlvar [i].sqlind);
        }

       free (out_desc_22.sqlvar);

       exec sql clear stmt22;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[22] = 0;
	  SQLcursor_count[22] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[22] = 0;
       SQLcursor_count[22] = 0;
       return (SQL_I_NO_MORE_DATA);
    }


 long  SQLquery_cursor23 (sql_str23, list, size, rows)
    exec sql begin declare section;
      char     *sql_str23;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor23" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str23, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[23] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[23] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt23" ));
        exec sql prepare stmt23 from : sql_str23;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt23;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_23.sqld = 0;
       out_desc_23.sqln = 0;
       out_desc_23.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt23 using descriptor out_desc_23;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt23;
           return (status);
        }
    } /* if( !SQLcursor[23] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt23;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt23;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[23] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_23" ));
        out_desc_23.sqlvar = (sqlvar *)calloc(out_desc_23.sqld, sizeof (sqlvar));
        if (! out_desc_23.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt23;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_23.sqln = out_desc_23.sqld;

        exec sql describe output stmt23 using descriptor out_desc_23;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt23;
        free (out_desc_23.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_23.sqld; ++i)
        {
          out_desc_23.sqlvar [i].sqldata =
                 calloc (1, out_desc_23.sqlvar [i].sqllen);
          if (! out_desc_23.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_23.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_23.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt23;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_23.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_23.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_23.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_23.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_23.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt23;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_23.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_23.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_23.sqld; ++x)
                free (out_desc_23.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_23.sqld; ++x)
                free (out_desc_23.sqlvar [x].sqlind);

             exec sql clear stmt23;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_23.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[23] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_23.sqld ));
       for (i = 0; i < out_desc_23.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_23.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_23.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_23.sqld; ++x)
                   free (out_desc_23.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_23.sqld; ++x)
                   free (out_desc_23.sqlvar [x].sqlind);

                exec sql clear stmt23;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_23.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_23.sqlvar [i].sqlname.sqlnamec,
		       out_desc_23.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_23.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_23.sqld; ++x)
                   free (out_desc_23.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_23.sqld; ++x)
                   free (out_desc_23.sqlvar [x].sqlind);

                 exec sql clear stmt23;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_23.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_23.sqld; ++x)
                   free (out_desc_23.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_23.sqld; ++x)
                   free (out_desc_23.sqlvar [x].sqlind);

                 exec sql clear stmt23;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_23.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[23] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs23 cursor for stmt23;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqlind);

          exec sql clear stmt23;
          free (out_desc_23.sqlvar);
          return (status);
        }

       exec sql open curs23;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqlind);

          exec sql clear stmt23;
          free (out_desc_23.sqlvar);
          return (status);
        }
    SQLcursor[23] = 1;

    } /* end if( !SQLcursor[23] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[23] != 0 )
    {
        for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqlind);

        exec sql close curs23;
        exec sql clear stmt23;

        free (out_desc_23.sqlvar); 
    }
    SQLcursor[23] = 0;
    SQLcursor_count[23] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));
    return( SQL_S_SUCCESS );
}

       exec sql fetch curs23 using descriptor out_desc_23;
       _SQLdebug(( fname, "%s\n", "Fetch curs23 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[23] && ( SQLcursor_count[23] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqlind);

          exec sql close curs23;
          exec sql clear stmt23;

          free (out_desc_23.sqlvar); 
          SQLcursor[23] = 0;
          SQLcursor_count[23] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqlind);

          exec sql close curs23;
          exec sql clear stmt23;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_23.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[23] = 0;
          SQLcursor_count[23] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[23];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_23.sqld; ++i)
           {
             if (*out_desc_23.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_23.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_23.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_23.sqld; ++x)
                       free (out_desc_23.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_23.sqld; ++x)
                       free (out_desc_23.sqlvar [x].sqlind);

                     exec sql close curs23;
                     exec sql clear stmt23;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_23.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[23] = 0;
	             SQLcursor_count[23] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_23.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_23.sqlvar[i].sqllen, 
                  out_desc_23.sqlvar[i].sqllen, out_desc_23.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_23.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_23.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_23.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_23.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_23.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_23.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_23.sqld; ++x)
                    free (out_desc_23.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_23.sqld; ++x)
                    free (out_desc_23.sqlvar [x].sqlind);

                  exec sql close curs23;
                  exec sql clear stmt23;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_23.sqlvar);
 	          SQLcursor[23] = 0;
  	          SQLcursor_count[23] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_23.sqld; ++x)
                    free (out_desc_23.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_23.sqld; ++x)
                    free (out_desc_23.sqlvar [x].sqlind);

                  exec sql close curs23;
                  exec sql clear stmt23;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_23.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[23] = 0;
	          SQLcursor_count[23] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_23.sqld; ++x)
               free (out_desc_23.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_23.sqld; ++x)
               free (out_desc_23.sqlvar [x].sqlind);

              exec sql close curs23;
              exec sql clear stmt23;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_23.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[23] = 0;
              SQLcursor_count[23] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs23 using descriptor out_desc_23;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[23] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_23.sqld; ++x)
               free (out_desc_23.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_23.sqld; ++x)
               free (out_desc_23.sqlvar [x].sqlind);

             exec sql close curs23;
             exec sql clear stmt23;
             free (str);

             free (out_desc_23.sqlvar);
             SQLcursor[23] = 0;
             SQLcursor_count[23] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[23];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs23;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_23.sqld; ++x)
            free (out_desc_23.sqlvar [x].sqlind);

          exec sql clear stmt23;
          free (str);

          free (out_desc_23.sqlvar);
          SQLcursor[23] = 0;
          SQLcursor_count[23] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_23.sqld; ++i)
        {
          free (out_desc_23.sqlvar [i].sqldata);
          free (out_desc_23.sqlvar [i].sqlind);
        }

       free (out_desc_23.sqlvar);

       exec sql clear stmt23;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[23] = 0;
	  SQLcursor_count[23] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[23] = 0;
       SQLcursor_count[23] = 0;
       return (SQL_I_NO_MORE_DATA);
    }


 long  SQLquery_cursor24 (sql_str24, list, size, rows)
    exec sql begin declare section;
      char     *sql_str24;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor24" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str24, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[24] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[24] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt24" ));
        exec sql prepare stmt24 from : sql_str24;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt24;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_24.sqld = 0;
       out_desc_24.sqln = 0;
       out_desc_24.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt24 using descriptor out_desc_24;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt24;
           return (status);
        }
    } /* if( !SQLcursor[24] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt24;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt24;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[24] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_24" ));
        out_desc_24.sqlvar = (sqlvar *)calloc(out_desc_24.sqld, sizeof (sqlvar));
        if (! out_desc_24.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt24;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_24.sqln = out_desc_24.sqld;

        exec sql describe output stmt24 using descriptor out_desc_24;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt24;
        free (out_desc_24.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_24.sqld; ++i)
        {
          out_desc_24.sqlvar [i].sqldata =
                 calloc (1, out_desc_24.sqlvar [i].sqllen);
          if (! out_desc_24.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_24.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_24.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt24;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_24.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_24.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_24.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_24.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_24.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt24;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_24.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_24.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_24.sqld; ++x)
                free (out_desc_24.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_24.sqld; ++x)
                free (out_desc_24.sqlvar [x].sqlind);

             exec sql clear stmt24;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_24.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[24] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_24.sqld ));
       for (i = 0; i < out_desc_24.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_24.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_24.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_24.sqld; ++x)
                   free (out_desc_24.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_24.sqld; ++x)
                   free (out_desc_24.sqlvar [x].sqlind);

                exec sql clear stmt24;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_24.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_24.sqlvar [i].sqlname.sqlnamec,
		       out_desc_24.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_24.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_24.sqld; ++x)
                   free (out_desc_24.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_24.sqld; ++x)
                   free (out_desc_24.sqlvar [x].sqlind);

                 exec sql clear stmt24;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_24.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_24.sqld; ++x)
                   free (out_desc_24.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_24.sqld; ++x)
                   free (out_desc_24.sqlvar [x].sqlind);

                 exec sql clear stmt24;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_24.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[24] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs24 cursor for stmt24;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqlind);

          exec sql clear stmt24;
          free (out_desc_24.sqlvar);
          return (status);
        }

       exec sql open curs24;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqlind);

          exec sql clear stmt24;
          free (out_desc_24.sqlvar);
          return (status);
        }
    SQLcursor[24] = 1;

    } /* end if( !SQLcursor[24] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[24] != 0 )
    {
        for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqlind);

        exec sql close curs24;
        exec sql clear stmt24;

        free (out_desc_24.sqlvar); 
    }
    SQLcursor[24] = 0;
    SQLcursor_count[24] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs24 using descriptor out_desc_24;
       _SQLdebug(( fname, "%s\n", "Fetch curs24 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[24] && ( SQLcursor_count[24] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqlind);

          exec sql close curs24;
          exec sql clear stmt24;

          free (out_desc_24.sqlvar); 
          SQLcursor[24] = 0;
          SQLcursor_count[24] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqlind);

          exec sql close curs24;
          exec sql clear stmt24;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_24.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[24] = 0;
          SQLcursor_count[24] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[24];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_24.sqld; ++i)
           {
             if (*out_desc_24.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_24.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_24.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_24.sqld; ++x)
                       free (out_desc_24.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_24.sqld; ++x)
                       free (out_desc_24.sqlvar [x].sqlind);

                     exec sql close curs24;
                     exec sql clear stmt24;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_24.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[24] = 0;
	             SQLcursor_count[24] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_24.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_24.sqlvar[i].sqllen, 
                  out_desc_24.sqlvar[i].sqllen, out_desc_24.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_24.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_24.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_24.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_24.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_24.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_24.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_24.sqld; ++x)
                    free (out_desc_24.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_24.sqld; ++x)
                    free (out_desc_24.sqlvar [x].sqlind);

                  exec sql close curs24;
                  exec sql clear stmt24;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_24.sqlvar);
 	          SQLcursor[24] = 0;
  	          SQLcursor_count[24] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_24.sqld; ++x)
                    free (out_desc_24.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_24.sqld; ++x)
                    free (out_desc_24.sqlvar [x].sqlind);

                  exec sql close curs24;
                  exec sql clear stmt24;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_24.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[24] = 0;
	          SQLcursor_count[24] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_24.sqld; ++x)
               free (out_desc_24.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_24.sqld; ++x)
               free (out_desc_24.sqlvar [x].sqlind);

              exec sql close curs24;
              exec sql clear stmt24;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_24.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[24] = 0;
              SQLcursor_count[24] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs24 using descriptor out_desc_24;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[24] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_24.sqld; ++x)
               free (out_desc_24.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_24.sqld; ++x)
               free (out_desc_24.sqlvar [x].sqlind);

             exec sql close curs24;
             exec sql clear stmt24;
             free (str);

             free (out_desc_24.sqlvar);
             SQLcursor[24] = 0;
             SQLcursor_count[24] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[24];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs24;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_24.sqld; ++x)
            free (out_desc_24.sqlvar [x].sqlind);

          exec sql clear stmt24;
          free (str);

          free (out_desc_24.sqlvar);
          SQLcursor[24] = 0;
          SQLcursor_count[24] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_24.sqld; ++i)
        {
          free (out_desc_24.sqlvar [i].sqldata);
          free (out_desc_24.sqlvar [i].sqlind);
        }

       free (out_desc_24.sqlvar);

       exec sql clear stmt24;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[24] = 0;
	  SQLcursor_count[24] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[24] = 0;
       SQLcursor_count[24] = 0;
       return (SQL_I_NO_MORE_DATA);
    }

 long  SQLquery_cursor25 (sql_str25, list, size, rows)
    exec sql begin declare section;
      char     *sql_str25;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor25" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str25, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[25] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[25] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt25" ));
        exec sql prepare stmt25 from : sql_str25;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt25;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_25.sqld = 0;
       out_desc_25.sqln = 0;
       out_desc_25.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt25 using descriptor out_desc_25;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt25;
           return (status);
        }
    } /* if( !SQLcursor[25] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt25;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt25;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[25] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_25" ));
        out_desc_25.sqlvar = (sqlvar *)calloc(out_desc_25.sqld, sizeof (sqlvar));
        if (! out_desc_25.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt25;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_25.sqln = out_desc_25.sqld;

        exec sql describe output stmt25 using descriptor out_desc_25;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt25;
        free (out_desc_25.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_25.sqld; ++i)
        {
          out_desc_25.sqlvar [i].sqldata =
                 calloc (1, out_desc_25.sqlvar [i].sqllen);
          if (! out_desc_25.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_25.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_25.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt25;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_25.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_25.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_25.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_25.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_25.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt25;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_25.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_25.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_25.sqld; ++x)
                free (out_desc_25.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_25.sqld; ++x)
                free (out_desc_25.sqlvar [x].sqlind);

             exec sql clear stmt25;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_25.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[25] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_25.sqld ));
       for (i = 0; i < out_desc_25.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_25.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_25.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_25.sqld; ++x)
                   free (out_desc_25.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_25.sqld; ++x)
                   free (out_desc_25.sqlvar [x].sqlind);

                exec sql clear stmt25;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_25.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_25.sqlvar [i].sqlname.sqlnamec,
		       out_desc_25.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_25.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_25.sqld; ++x)
                   free (out_desc_25.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_25.sqld; ++x)
                   free (out_desc_25.sqlvar [x].sqlind);

                 exec sql clear stmt25;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_25.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_25.sqld; ++x)
                   free (out_desc_25.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_25.sqld; ++x)
                   free (out_desc_25.sqlvar [x].sqlind);

                 exec sql clear stmt25;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_25.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[25] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs25 cursor for stmt25;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqlind);

          exec sql clear stmt25;
          free (out_desc_25.sqlvar);
          return (status);
        }

       exec sql open curs25;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqlind);

          exec sql clear stmt25;
          free (out_desc_25.sqlvar);
          return (status);
        }
    SQLcursor[25] = 1;

    } /* end if( !SQLcursor[25] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[25] != 0 )
    {
        for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqlind);

        exec sql close curs25;
        exec sql clear stmt25;

        free (out_desc_25.sqlvar); 
    }
    SQLcursor[25] = 0;
    SQLcursor_count[25] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs25 using descriptor out_desc_25;
       _SQLdebug(( fname, "%s\n", "Fetch curs25 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[25] && ( SQLcursor_count[25] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqlind);

          exec sql close curs25;
          exec sql clear stmt25;

          free (out_desc_25.sqlvar); 
          SQLcursor[25] = 0;
          SQLcursor_count[25] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqlind);

          exec sql close curs25;
          exec sql clear stmt25;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_25.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[25] = 0;
          SQLcursor_count[25] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[25];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_25.sqld; ++i)
           {
             if (*out_desc_25.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_25.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_25.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_25.sqld; ++x)
                       free (out_desc_25.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_25.sqld; ++x)
                       free (out_desc_25.sqlvar [x].sqlind);

                     exec sql close curs25;
                     exec sql clear stmt25;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_25.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[25] = 0;
	             SQLcursor_count[25] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_25.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_25.sqlvar[i].sqllen, 
                  out_desc_25.sqlvar[i].sqllen, out_desc_25.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_25.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_25.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_25.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_25.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_25.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_25.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_25.sqld; ++x)
                    free (out_desc_25.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_25.sqld; ++x)
                    free (out_desc_25.sqlvar [x].sqlind);

                  exec sql close curs25;
                  exec sql clear stmt25;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_25.sqlvar);
 	          SQLcursor[25] = 0;
  	          SQLcursor_count[25] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_25.sqld; ++x)
                    free (out_desc_25.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_25.sqld; ++x)
                    free (out_desc_25.sqlvar [x].sqlind);

                  exec sql close curs25;
                  exec sql clear stmt25;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_25.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[25] = 0;
	          SQLcursor_count[25] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_25.sqld; ++x)
               free (out_desc_25.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_25.sqld; ++x)
               free (out_desc_25.sqlvar [x].sqlind);

              exec sql close curs25;
              exec sql clear stmt25;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_25.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[25] = 0;
              SQLcursor_count[25] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs25 using descriptor out_desc_25;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[25] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_25.sqld; ++x)
               free (out_desc_25.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_25.sqld; ++x)
               free (out_desc_25.sqlvar [x].sqlind);

             exec sql close curs25;
             exec sql clear stmt25;
             free (str);

             free (out_desc_25.sqlvar);
             SQLcursor[25] = 0;
             SQLcursor_count[25] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[25];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs25;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_25.sqld; ++x)
            free (out_desc_25.sqlvar [x].sqlind);

          exec sql clear stmt25;
          free (str);

          free (out_desc_25.sqlvar);
          SQLcursor[25] = 0;
          SQLcursor_count[25] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_25.sqld; ++i)
        {
          free (out_desc_25.sqlvar [i].sqldata);
          free (out_desc_25.sqlvar [i].sqlind);
        }

       free (out_desc_25.sqlvar);

       exec sql clear stmt25;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[25] = 0;
	  SQLcursor_count[25] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[25] = 0;
       SQLcursor_count[25] = 0;
       return (SQL_I_NO_MORE_DATA);
    }

 long  SQLquery_cursor26 (sql_str26, list, size, rows)
    exec sql begin declare section;
      char     *sql_str26;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor26" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str26, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[26] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[26] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt26" ));
        exec sql prepare stmt26 from : sql_str26;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt26;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_26.sqld = 0;
       out_desc_26.sqln = 0;
       out_desc_26.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt26 using descriptor out_desc_26;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt26;
           return (status);
        }
    } /* if( !SQLcursor[26] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt26;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt26;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[26] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_26" ));
        out_desc_26.sqlvar = (sqlvar *)calloc(out_desc_26.sqld, sizeof (sqlvar));
        if (! out_desc_26.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt26;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_26.sqln = out_desc_26.sqld;

        exec sql describe output stmt26 using descriptor out_desc_26;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt26;
        free (out_desc_26.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_26.sqld; ++i)
        {
          out_desc_26.sqlvar [i].sqldata =
                 calloc (1, out_desc_26.sqlvar [i].sqllen);
          if (! out_desc_26.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_26.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_26.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt26;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_26.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_26.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_26.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_26.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_26.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt26;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_26.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_26.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_26.sqld; ++x)
                free (out_desc_26.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_26.sqld; ++x)
                free (out_desc_26.sqlvar [x].sqlind);

             exec sql clear stmt26;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_26.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[26] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_26.sqld ));
       for (i = 0; i < out_desc_26.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_26.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_26.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_26.sqld; ++x)
                   free (out_desc_26.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_26.sqld; ++x)
                   free (out_desc_26.sqlvar [x].sqlind);

                exec sql clear stmt26;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_26.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_26.sqlvar [i].sqlname.sqlnamec,
		       out_desc_26.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_26.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_26.sqld; ++x)
                   free (out_desc_26.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_26.sqld; ++x)
                   free (out_desc_26.sqlvar [x].sqlind);

                 exec sql clear stmt26;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_26.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_26.sqld; ++x)
                   free (out_desc_26.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_26.sqld; ++x)
                   free (out_desc_26.sqlvar [x].sqlind);

                 exec sql clear stmt26;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_26.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[26] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs26 cursor for stmt26;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqlind);

          exec sql clear stmt26;
          free (out_desc_26.sqlvar);
          return (status);
        }

       exec sql open curs26;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqlind);

          exec sql clear stmt26;
          free (out_desc_26.sqlvar);
          return (status);
        }
    SQLcursor[26] = 1;

    } /* end if( !SQLcursor[26] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[26] != 0 )
    {
        for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqlind);

        exec sql close curs26;
        exec sql clear stmt26;

        free (out_desc_26.sqlvar); 
    }
    SQLcursor[26] = 0;
    SQLcursor_count[26] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs26 using descriptor out_desc_26;
       _SQLdebug(( fname, "%s\n", "Fetch curs26 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[26] && ( SQLcursor_count[26] > 0 ) )
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqlind);

          exec sql close curs26;
          exec sql clear stmt26;

          free (out_desc_26.sqlvar); 
          SQLcursor[26] = 0;
          SQLcursor_count[26] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqlind);

          exec sql close curs26;
          exec sql clear stmt26;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_26.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[26] = 0;
          SQLcursor_count[26] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[26];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_26.sqld; ++i)
           {
             if (*out_desc_26.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_26.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_26.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_26.sqld; ++x)
                       free (out_desc_26.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_26.sqld; ++x)
                       free (out_desc_26.sqlvar [x].sqlind);

                     exec sql close curs26;
                     exec sql clear stmt26;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_26.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[26] = 0;
	             SQLcursor_count[26] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_26.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_26.sqlvar[i].sqllen, 
                  out_desc_26.sqlvar[i].sqllen, out_desc_26.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_26.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_26.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_26.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_26.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_26.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_26.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_26.sqld; ++x)
                    free (out_desc_26.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_26.sqld; ++x)
                    free (out_desc_26.sqlvar [x].sqlind);

                  exec sql close curs26;
                  exec sql clear stmt26;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_26.sqlvar);
 	          SQLcursor[26] = 0;
  	          SQLcursor_count[26] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_26.sqld; ++x)
                    free (out_desc_26.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_26.sqld; ++x)
                    free (out_desc_26.sqlvar [x].sqlind);

                  exec sql close curs26;
                  exec sql clear stmt26;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_26.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[26] = 0;
	          SQLcursor_count[26] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_26.sqld; ++x)
               free (out_desc_26.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_26.sqld; ++x)
               free (out_desc_26.sqlvar [x].sqlind);

              exec sql close curs26;
              exec sql clear stmt26;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_26.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[26] = 0;
              SQLcursor_count[26] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs26 using descriptor out_desc_26;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[26] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_26.sqld; ++x)
               free (out_desc_26.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_26.sqld; ++x)
               free (out_desc_26.sqlvar [x].sqlind);

             exec sql close curs26;
             exec sql clear stmt26;
             free (str);

             free (out_desc_26.sqlvar);
             SQLcursor[26] = 0;
             SQLcursor_count[26] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[26];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs26;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_26.sqld; ++x)
            free (out_desc_26.sqlvar [x].sqlind);

          exec sql clear stmt26;
          free (str);

          free (out_desc_26.sqlvar);
          SQLcursor[26] = 0;
          SQLcursor_count[26] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_26.sqld; ++i)
        {
          free (out_desc_26.sqlvar [i].sqldata);
          free (out_desc_26.sqlvar [i].sqlind);
        }

       free (out_desc_26.sqlvar);

       exec sql clear stmt26;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[26] = 0;
	  SQLcursor_count[26] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[26] = 0;
       SQLcursor_count[26] = 0;
       return (SQL_I_NO_MORE_DATA);
    }


 long  SQLquery_cursor27 (sql_str27, list, size, rows)
    exec sql begin declare section;
      char     *sql_str27;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor27" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str27, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[27] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[27] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt27" ));
        exec sql prepare stmt27 from : sql_str27;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.27x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt27;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_27.sqld = 0;
       out_desc_27.sqln = 0;
       out_desc_27.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt27 using descriptor out_desc_27;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.27x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt27;
           return (status);
        }
    } /* if( !SQLcursor[27] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt27;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.27x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt27;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.27x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[27] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_27" ));
        out_desc_27.sqlvar = (sqlvar *)calloc(out_desc_27.sqld, sizeof (sqlvar));
        if (! out_desc_27.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt27;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.27x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_27.sqln = out_desc_27.sqld;

        exec sql describe output stmt27 using descriptor out_desc_27;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.27x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt27;
        free (out_desc_27.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_27.sqld; ++i)
        {
          out_desc_27.sqlvar [i].sqldata =
                 calloc (1, out_desc_27.sqlvar [i].sqllen);
          if (! out_desc_27.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_27.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_27.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt27;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_27.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.27x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_27.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_27.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_27.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_27.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt27;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_27.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.27x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_27.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_27.sqld; ++x)
                free (out_desc_27.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_27.sqld; ++x)
                free (out_desc_27.sqlvar [x].sqlind);

             exec sql clear stmt27;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_27.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.27x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[27] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_27.sqld ));
       for (i = 0; i < out_desc_27.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_27.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_27.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.27x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_27.sqld; ++x)
                   free (out_desc_27.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_27.sqld; ++x)
                   free (out_desc_27.sqlvar [x].sqlind);

                exec sql clear stmt27;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_27.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.27x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_27.sqlvar [i].sqlname.sqlnamec,
		       out_desc_27.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_27.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_27.sqld; ++x)
                   free (out_desc_27.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_27.sqld; ++x)
                   free (out_desc_27.sqlvar [x].sqlind);

                 exec sql clear stmt27;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_27.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.27x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_27.sqld; ++x)
                   free (out_desc_27.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_27.sqld; ++x)
                   free (out_desc_27.sqlvar [x].sqlind);

                 exec sql clear stmt27;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_27.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.27x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[27] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs27 cursor for stmt27;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.27x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqlind);

          exec sql clear stmt27;
          free (out_desc_27.sqlvar);
          return (status);
        }

       exec sql open curs27;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.27x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqlind);

          exec sql clear stmt27;
          free (out_desc_27.sqlvar);
          return (status);
        }
    SQLcursor[27] = 1;

    } /* end if( !SQLcursor[27] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[27] != 0 )
    {
        for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqlind);

        exec sql close curs27;
        exec sql clear stmt27;

        free (out_desc_27.sqlvar); 
    }
    SQLcursor[27] = 0;
    SQLcursor_count[27] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs27 using descriptor out_desc_27;
       _SQLdebug(( fname, "%s\n", "Fetch curs27 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.27x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[27] && ( SQLcursor_count[27] > 0 ) )
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.27x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqlind);

          exec sql close curs27;
          exec sql clear stmt27;

          free (out_desc_27.sqlvar); 
          SQLcursor[27] = 0;
          SQLcursor_count[27] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqlind);

          exec sql close curs27;
          exec sql clear stmt27;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_27.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.27x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[27] = 0;
          SQLcursor_count[27] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[27];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_27.sqld; ++i)
           {
             if (*out_desc_27.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_27.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_27.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_27.sqld; ++x)
                       free (out_desc_27.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_27.sqld; ++x)
                       free (out_desc_27.sqlvar [x].sqlind);

                     exec sql close curs27;
                     exec sql clear stmt27;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_27.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.27x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[27] = 0;
	             SQLcursor_count[27] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_27.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_27.sqlvar[i].sqllen, 
                  out_desc_27.sqlvar[i].sqllen, out_desc_27.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_27.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_27.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_27.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_27.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_27.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_27.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_27.sqld; ++x)
                    free (out_desc_27.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_27.sqld; ++x)
                    free (out_desc_27.sqlvar [x].sqlind);

                  exec sql close curs27;
                  exec sql clear stmt27;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_27.sqlvar);
 	          SQLcursor[27] = 0;
  	          SQLcursor_count[27] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_27.sqld; ++x)
                    free (out_desc_27.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_27.sqld; ++x)
                    free (out_desc_27.sqlvar [x].sqlind);

                  exec sql close curs27;
                  exec sql clear stmt27;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_27.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.27x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[27] = 0;
	          SQLcursor_count[27] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_27.sqld; ++x)
               free (out_desc_27.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_27.sqld; ++x)
               free (out_desc_27.sqlvar [x].sqlind);

              exec sql close curs27;
              exec sql clear stmt27;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_27.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.27x>\n",
    	          status));
              SQLcursor[27] = 0;
              SQLcursor_count[27] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs27 using descriptor out_desc_27;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.27x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[27] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_27.sqld; ++x)
               free (out_desc_27.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_27.sqld; ++x)
               free (out_desc_27.sqlvar [x].sqlind);

             exec sql close curs27;
             exec sql clear stmt27;
             free (str);

             free (out_desc_27.sqlvar);
             SQLcursor[27] = 0;
             SQLcursor_count[27] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[27];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs27;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.27x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_27.sqld; ++x)
            free (out_desc_27.sqlvar [x].sqlind);

          exec sql clear stmt27;
          free (str);

          free (out_desc_27.sqlvar);
          SQLcursor[27] = 0;
          SQLcursor_count[27] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_27.sqld; ++i)
        {
          free (out_desc_27.sqlvar [i].sqldata);
          free (out_desc_27.sqlvar [i].sqlind);
        }

       free (out_desc_27.sqlvar);

       exec sql clear stmt27;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.27x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.27x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[27] = 0;
	  SQLcursor_count[27] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[27] = 0;
       SQLcursor_count[27] = 0;
       return (SQL_I_NO_MORE_DATA);
    }

 long  SQLquery_cursor28 (sql_str28, list, size, rows)
    exec sql begin declare section;
      char     *sql_str28;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor28" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str28, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[28] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[28] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt28" ));
        exec sql prepare stmt28 from : sql_str28;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt28;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_28.sqld = 0;
       out_desc_28.sqln = 0;
       out_desc_28.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt28 using descriptor out_desc_28;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt28;
           return (status);
        }
    } /* if( !SQLcursor[28] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt28;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt28;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[28] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_28" ));
        out_desc_28.sqlvar = (sqlvar *)calloc(out_desc_28.sqld, sizeof (sqlvar));
        if (! out_desc_28.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt28;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_28.sqln = out_desc_28.sqld;

        exec sql describe output stmt28 using descriptor out_desc_28;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt28;
        free (out_desc_28.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_28.sqld; ++i)
        {
          out_desc_28.sqlvar [i].sqldata =
                 calloc (1, out_desc_28.sqlvar [i].sqllen);
          if (! out_desc_28.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_28.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_28.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt28;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_28.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_28.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_28.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_28.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_28.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt28;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_28.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_28.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_28.sqld; ++x)
                free (out_desc_28.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_28.sqld; ++x)
                free (out_desc_28.sqlvar [x].sqlind);

             exec sql clear stmt28;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_28.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[28] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_28.sqld ));
       for (i = 0; i < out_desc_28.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_28.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_28.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_28.sqld; ++x)
                   free (out_desc_28.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_28.sqld; ++x)
                   free (out_desc_28.sqlvar [x].sqlind);

                exec sql clear stmt28;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_28.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_28.sqlvar [i].sqlname.sqlnamec,
		       out_desc_28.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_28.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_28.sqld; ++x)
                   free (out_desc_28.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_28.sqld; ++x)
                   free (out_desc_28.sqlvar [x].sqlind);

                 exec sql clear stmt28;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_28.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_28.sqld; ++x)
                   free (out_desc_28.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_28.sqld; ++x)
                   free (out_desc_28.sqlvar [x].sqlind);

                 exec sql clear stmt28;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_28.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[28] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs28 cursor for stmt28;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqlind);

          exec sql clear stmt28;
          free (out_desc_28.sqlvar);
          return (status);
        }

       exec sql open curs28;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqlind);

          exec sql clear stmt28;
          free (out_desc_28.sqlvar);
          return (status);
        }
    SQLcursor[28] = 1;

    } /* end if( !SQLcursor[28] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[28] != 0 )
    {
        for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqlind);

        exec sql close curs28;
        exec sql clear stmt28;

        free (out_desc_28.sqlvar); 
    }
    SQLcursor[28] = 0;
    SQLcursor_count[28] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));
    return( SQL_S_SUCCESS );
}

       exec sql fetch curs28 using descriptor out_desc_28;
       _SQLdebug(( fname, "%s\n", "Fetch curs28 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[28] && ( SQLcursor_count[28] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqlind);

          exec sql close curs28;
          exec sql clear stmt28;

          free (out_desc_28.sqlvar); 
          SQLcursor[28] = 0;
          SQLcursor_count[28] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqlind);

          exec sql close curs28;
          exec sql clear stmt28;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_28.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[28] = 0;
          SQLcursor_count[28] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[28];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_28.sqld; ++i)
           {
             if (*out_desc_28.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_28.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_28.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_28.sqld; ++x)
                       free (out_desc_28.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_28.sqld; ++x)
                       free (out_desc_28.sqlvar [x].sqlind);

                     exec sql close curs28;
                     exec sql clear stmt28;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_28.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[28] = 0;
	             SQLcursor_count[28] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_28.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_28.sqlvar[i].sqllen, 
                  out_desc_28.sqlvar[i].sqllen, out_desc_28.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_28.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_28.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_28.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_28.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_28.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_28.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_28.sqld; ++x)
                    free (out_desc_28.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_28.sqld; ++x)
                    free (out_desc_28.sqlvar [x].sqlind);

                  exec sql close curs28;
                  exec sql clear stmt28;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_28.sqlvar);
 	          SQLcursor[28] = 0;
  	          SQLcursor_count[28] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_28.sqld; ++x)
                    free (out_desc_28.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_28.sqld; ++x)
                    free (out_desc_28.sqlvar [x].sqlind);

                  exec sql close curs28;
                  exec sql clear stmt28;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_28.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[28] = 0;
	          SQLcursor_count[28] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_28.sqld; ++x)
               free (out_desc_28.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_28.sqld; ++x)
               free (out_desc_28.sqlvar [x].sqlind);

              exec sql close curs28;
              exec sql clear stmt28;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_28.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[28] = 0;
              SQLcursor_count[28] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs28 using descriptor out_desc_28;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[28] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_28.sqld; ++x)
               free (out_desc_28.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_28.sqld; ++x)
               free (out_desc_28.sqlvar [x].sqlind);

             exec sql close curs28;
             exec sql clear stmt28;
             free (str);

             free (out_desc_28.sqlvar);
             SQLcursor[28] = 0;
             SQLcursor_count[28] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[28];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs28;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_28.sqld; ++x)
            free (out_desc_28.sqlvar [x].sqlind);

          exec sql clear stmt28;
          free (str);

          free (out_desc_28.sqlvar);
          SQLcursor[28] = 0;
          SQLcursor_count[28] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_28.sqld; ++i)
        {
          free (out_desc_28.sqlvar [i].sqldata);
          free (out_desc_28.sqlvar [i].sqlind);
        }

       free (out_desc_28.sqlvar);

       exec sql clear stmt28;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[28] = 0;
	  SQLcursor_count[28] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[28] = 0;
       SQLcursor_count[28] = 0;
       return (SQL_I_NO_MORE_DATA);
    }

 long  SQLquery_cursor29 (sql_str29, list, size, rows)
    exec sql begin declare section;
      char     *sql_str29;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor29" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str29, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[29] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[29] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt29" ));
        exec sql prepare stmt29 from : sql_str29;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt29;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_29.sqld = 0;
       out_desc_29.sqln = 0;
       out_desc_29.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt29 using descriptor out_desc_29;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt29;
           return (status);
        }
    } /* if( !SQLcursor[29] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt29;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt29;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[29] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_29" ));
        out_desc_29.sqlvar = (sqlvar *)calloc(out_desc_29.sqld, sizeof (sqlvar));
        if (! out_desc_29.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt29;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_29.sqln = out_desc_29.sqld;

        exec sql describe output stmt29 using descriptor out_desc_29;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt29;
        free (out_desc_29.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_29.sqld; ++i)
        {
          out_desc_29.sqlvar [i].sqldata =
                 calloc (1, out_desc_29.sqlvar [i].sqllen);
          if (! out_desc_29.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_29.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_29.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt29;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_29.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_29.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_29.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_29.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_29.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt29;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_29.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_29.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_29.sqld; ++x)
                free (out_desc_29.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_29.sqld; ++x)
                free (out_desc_29.sqlvar [x].sqlind);

             exec sql clear stmt29;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_29.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[29] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_29.sqld ));
       for (i = 0; i < out_desc_29.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_29.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_29.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_29.sqld; ++x)
                   free (out_desc_29.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_29.sqld; ++x)
                   free (out_desc_29.sqlvar [x].sqlind);

                exec sql clear stmt29;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_29.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_29.sqlvar [i].sqlname.sqlnamec,
		       out_desc_29.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_29.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_29.sqld; ++x)
                   free (out_desc_29.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_29.sqld; ++x)
                   free (out_desc_29.sqlvar [x].sqlind);

                 exec sql clear stmt29;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_29.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_29.sqld; ++x)
                   free (out_desc_29.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_29.sqld; ++x)
                   free (out_desc_29.sqlvar [x].sqlind);

                 exec sql clear stmt29;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_29.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[29] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs29 cursor for stmt29;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqlind);

          exec sql clear stmt29;
          free (out_desc_29.sqlvar);
          return (status);
        }

       exec sql open curs29;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqlind);

          exec sql clear stmt29;
          free (out_desc_29.sqlvar);
          return (status);
        }
    SQLcursor[29] = 1;

    } /* end if( !SQLcursor[29] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[29] != 0 )
    {
        for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqlind);

        exec sql close curs29;
        exec sql clear stmt29;

        free (out_desc_29.sqlvar); 
    }
    SQLcursor[29] = 0;
    SQLcursor_count[29] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs29 using descriptor out_desc_29;
       _SQLdebug(( fname, "%s\n", "Fetch curs29 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[29] && ( SQLcursor_count[29] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqlind);

          exec sql close curs29;
          exec sql clear stmt29;

          free (out_desc_29.sqlvar); 
          SQLcursor[29] = 0;
          SQLcursor_count[29] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqlind);

          exec sql close curs29;
          exec sql clear stmt29;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_29.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[29] = 0;
          SQLcursor_count[29] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[29];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_29.sqld; ++i)
           {
             if (*out_desc_29.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_29.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_29.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_29.sqld; ++x)
                       free (out_desc_29.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_29.sqld; ++x)
                       free (out_desc_29.sqlvar [x].sqlind);

                     exec sql close curs29;
                     exec sql clear stmt29;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_29.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[29] = 0;
	             SQLcursor_count[29] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_29.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_29.sqlvar[i].sqllen, 
                  out_desc_29.sqlvar[i].sqllen, out_desc_29.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_29.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_29.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_29.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_29.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_29.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_29.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_29.sqld; ++x)
                    free (out_desc_29.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_29.sqld; ++x)
                    free (out_desc_29.sqlvar [x].sqlind);

                  exec sql close curs29;
                  exec sql clear stmt29;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_29.sqlvar);
 	          SQLcursor[29] = 0;
  	          SQLcursor_count[29] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_29.sqld; ++x)
                    free (out_desc_29.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_29.sqld; ++x)
                    free (out_desc_29.sqlvar [x].sqlind);

                  exec sql close curs29;
                  exec sql clear stmt29;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_29.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[29] = 0;
	          SQLcursor_count[29] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_29.sqld; ++x)
               free (out_desc_29.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_29.sqld; ++x)
               free (out_desc_29.sqlvar [x].sqlind);

              exec sql close curs29;
              exec sql clear stmt29;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_29.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[29] = 0;
              SQLcursor_count[29] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs29 using descriptor out_desc_29;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[29] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_29.sqld; ++x)
               free (out_desc_29.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_29.sqld; ++x)
               free (out_desc_29.sqlvar [x].sqlind);

             exec sql close curs29;
             exec sql clear stmt29;
             free (str);

             free (out_desc_29.sqlvar);
             SQLcursor[29] = 0;
             SQLcursor_count[29] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[29];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs29;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_29.sqld; ++x)
            free (out_desc_29.sqlvar [x].sqlind);

          exec sql clear stmt29;
          free (str);

          free (out_desc_29.sqlvar);
          SQLcursor[29] = 0;
          SQLcursor_count[29] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_29.sqld; ++i)
        {
          free (out_desc_29.sqlvar [i].sqldata);
          free (out_desc_29.sqlvar [i].sqlind);
        }

       free (out_desc_29.sqlvar);

       exec sql clear stmt29;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[29] = 0;
	  SQLcursor_count[29] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[29] = 0;
       SQLcursor_count[29] = 0;
       return (SQL_I_NO_MORE_DATA);
    }

 long  SQLquery_cursor30 (sql_str30, list, size, rows)
    exec sql begin declare section;
      char     *sql_str30;
    exec sql end declare section;
    MEMptr   *list;
    long     size;
    long     rows;	/* i  - number of rows of data to fetch 
		   	    0 - stop fetching and clean up
			    n - fetch this many rows
			 */
    {
       static char *fname = "SQLquery_cursor30" ;
       exec sql begin declare section;
         long   status;
         long   i;
	 long   x;
	 long   NEW_LIST;
	 long   fetch_count;
         char   data_type [30];
	 char   data[30];
         char   *str;
	 char   *data1;
         char   **format;
	 datetime *ptr ;
	 char column_name [50] ;
       exec sql end declare section;
       char message [100];
       
    SQLquery_count += 1;

    _SQLdebug ((fname, "Qry  Str  = <%s> : Size = <%d>\n : Rows = <%d>\n", 
	sql_str30, size, rows));
   
    /* prepare a dynamic SQL statement but only if this is the first
     * time through. 
     */
if( rows > 0 )
{	
    if( SQLcursor[30] )
	_SQLdebug(( fname, "%s\n", "Cursor already prepared" ));

    if( !SQLcursor[30] )
    {
	_SQLdebug(( fname, "%s\n", "Preparing stmt30" ));
        exec sql prepare stmt30 from : sql_str30;
        if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
           {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname, "Prepare Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	      status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
 	             status));
	      ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt30;
           return (status);
       }

    /*
     **	if the statement is a SELECT statement (sqld != 0),
     **	declare a cursor for, open, and fetch from the statement.
     */

       out_desc_30.sqld = 0;
       out_desc_30.sqln = 0;
       out_desc_30.sqlvar = 0;

    /* get the count of output columns */

       exec sql describe output stmt30 using descriptor out_desc_30;
       if (SQLCODE)
       {
           if (SQLCODE != END_OF_DATA)
           { 
               status = SQLerror (SQL_E_DESCRIBE, 
                      risca -> sqlerrd [1], SQLCODE); 
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
	              status));
           }
           else                       
           {
	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
	       ERRload_struct (SQL, status, NULL) ;
           }

           exec sql clear stmt30;
           return (status);
        }
    } /* if( !SQLcursor[30] ) */

    if (! (*list))
    {
        _SQLdebug(( fname, "%s\n", "Opening buffer" ));
        status = MEMopen (list, size);
        if (status != MEM_S_SUCCESS)
        {
            exec sql clear stmt30;
            _SQLdebug ((fname, "MEM Open Failed : status = <0x%.8x>\n",
	              status));
            return (SQL_E_MEM);
        }

        NEW_LIST = 1;
     }
     else
     {
         status = MEMbuild_array (*list);
         if (status != MEM_S_SUCCESS)
         {
              exec sql clear stmt30;
              _SQLdebug ((fname, "MEM Build Array : status = <0x%.8x>\n",
              status));
              return (SQL_E_MEM);
         }
       
         NEW_LIST = 0;

         format = (char **) (*list) -> format_ptr;
      }

    if( !SQLcursor[30] )
    {
        _SQLdebug(( fname, "%s\n", "Calloc space for out_desc_30" ));
        out_desc_30.sqlvar = (sqlvar *)calloc(out_desc_30.sqld, sizeof (sqlvar));
        if (! out_desc_30.sqlvar)
        {
  	    status = SQL_E_MALLOC ;
            exec sql clear stmt30;
            if (NEW_LIST) MEMclose (list);
            _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n", status));
            ERRload_struct (SQL, status, "%s", "Calloc failed");
            return (status);
        }

        out_desc_30.sqln = out_desc_30.sqld;

        exec sql describe output stmt30 using descriptor out_desc_30;
        if (SQLCODE)
        {
            if (SQLCODE != END_OF_DATA)
            {
               if (NEW_LIST) MEMclose (list);
               status = SQLerror (SQL_E_DESCRIBE,
                      risca -> sqlerrd [1], SQLCODE);
               _SQLdebug ((fname, "Describe Failed : status = <0x%.8x>\n",
            	  status));
            }
            else
            {
  	       status = SQL_I_NO_ROWS_FOUND ;
               _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
	             status));
  	       ERRload_struct (SQL, status, NULL) ;
            }

        exec sql clear stmt30;
        free (out_desc_30.sqlvar);
        return (status);
        }
           
       for (i = 0; i < out_desc_30.sqld; ++i)
        {
          out_desc_30.sqlvar [i].sqldata =
                 calloc (1, out_desc_30.sqlvar [i].sqllen);
          if (! out_desc_30.sqlvar [i].sqldata)
           {
             for (x = 0; x < i; ++x) free (out_desc_30.sqlvar [x].sqldata);
             for (x = 0; x < i; ++x) free (out_desc_30.sqlvar [x].sqlind);
	     status = SQL_E_MALLOC ;
             exec sql clear stmt30;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_30.sqlvar);
             _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, "%s", "Calloc failed");
             return (status);
           }

          out_desc_30.sqlvar [i].sqlind = (long *) calloc (1, sizeof (long));
          if (! out_desc_30.sqlvar [i].sqlind)
           {
              for (x = 0; x <= i; ++x) free (out_desc_30.sqlvar [x].sqldata);
              for (x = 0; x < i; ++x)  free (out_desc_30.sqlvar [x].sqlind);
	      status = SQL_E_MALLOC ;
              exec sql clear stmt30;
              if (NEW_LIST) MEMclose (list);
              free (out_desc_30.sqlvar);
              _SQLdebug ((fname, "Calloc Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, "%s", "Calloc failed");
              return (status); 
            }
        }

       if (! NEW_LIST)
        {
          if ((*list) -> columns != out_desc_30.sqld)
           {
	     status = SQL_E_NO_FORMAT_MISMATCH ;

             for (x = 0; x < out_desc_30.sqld; ++x)
                free (out_desc_30.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_30.sqld; ++x)
                free (out_desc_30.sqlvar [x].sqlind);

             exec sql clear stmt30;
             if (NEW_LIST) MEMclose (list);
             free (out_desc_30.sqlvar);
             _SQLdebug ((fname, "No Columns Mismatch : status = <0x%.8x>\n",
             status));
             ERRload_struct (SQL, status, NULL);
             return (status);
           }
        }
    } /* end if( !SQLcursor[30] ) */

/*  We have to open and reformat the MEMbuffer for each call */

	_SQLdebug(( fname, "Number of columns <%d>\n", out_desc_30.sqld ));
       for (i = 0; i < out_desc_30.sqld; ++i)
        {
           memset (data_type, 0, 29);
           switch (out_desc_30.sqlvar [i].sqltype)
            {
              case CHARACTER :
                sprintf (data_type, "char(%d)",
                         out_desc_30.sqlvar[i].sqllen);
                break;

              case INTEGER   :
                strcpy (data_type, "integer");
                break;

              case SMALLINT  :
                strcpy (data_type, "smallint");
                break;

              case DOUBLE    :
                strcpy (data_type, "double");
                break;

              case REAL      :
                strcpy (data_type, "real");
                break;

              case DECIMAL   :
                strcpy (data_type, "decimal");
                break;

              case DATETIME   :
                strcpy (data_type, "timestamp");
                break;

              default :
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
				status ));	
	        status = SQL_E_DATA_TYPE ;
                for (x = 0; x < out_desc_30.sqld; ++x)
                   free (out_desc_30.sqlvar [x].sqldata);

                for (x = 0; x < out_desc_30.sqld; ++x)
                   free (out_desc_30.sqlvar [x].sqlind);

                exec sql clear stmt30;
                if (NEW_LIST) MEMclose (list);
                free (out_desc_30.sqlvar);
                _SQLdebug ((fname, "No Such Data Type : status = <0x%.8x>\n",
                status));
                ERRload_struct (SQL, status, "%s", "Invalid data type");
                return (status);
            }

           if (NEW_LIST)
            {
	        strncpy (column_name, out_desc_30.sqlvar [i].sqlname.sqlnamec,
		       out_desc_30.sqlvar [i].sqlname.sqlnamel) ;
		       column_name[out_desc_30.sqlvar[i].sqlname.sqlnamel] = 0 ;
              status = MEMwrite_format (*list, column_name, data_type);
              if (status != MEM_S_SUCCESS)
               {
                 for (x = 0; x < out_desc_30.sqld; ++x)
                   free (out_desc_30.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_30.sqld; ++x)
                   free (out_desc_30.sqlvar [x].sqlind);

                 exec sql clear stmt30;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_30.sqlvar);
                 _SQLdebug ((fname, "Wr For Failed : status = <0x%.8x>\n",
                 status));
                 return (SQL_E_MEM);
               }
            }
           else
            {
              if (strcmp (format [i], data_type))
               {
		 status = SQL_E_FORMAT_MISMATCH ;

                 for (x = 0; x < out_desc_30.sqld; ++x)
                   free (out_desc_30.sqlvar [x].sqldata);

                 for (x = 0; x < out_desc_30.sqld; ++x)
                   free (out_desc_30.sqlvar [x].sqlind);

                 exec sql clear stmt30;
                 if (NEW_LIST) MEMclose (list);
                 free (out_desc_30.sqlvar);
                 _SQLdebug ((fname, "Fmt Match Failed : status = <0x%.8x>\n",
                 status));
                 ERRload_struct (SQL, status, NULL);
                 return (status);
               }
            }
        }

    if( !SQLcursor[30] )
    {
       _SQLdebug(( fname, "%s\n", "Declare cursor" ));
       exec sql declare curs30 cursor for stmt30;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_DECLARE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Declare Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqlind);

          exec sql clear stmt30;
          free (out_desc_30.sqlvar);
          return (status);
        }

       exec sql open curs30;
        _SQLdebug(( fname, "%s\n", "Open cursor" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CURSOR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Open Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqlind);

          exec sql clear stmt30;
          free (out_desc_30.sqlvar);
          return (status);
        }
    SQLcursor[30] = 1;

    } /* end if( !SQLcursor[30] ) */
}
/*  If rows == 0, this is the signal to close the cursor and clean up.
 *  The RIS preprocessor would not allow these closing statements until
 *  now; otherwise, this would have been executed first.
 */
else if( rows == 0 )
{
    if( SQLcursor[30] != 0 )
    {
        for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqldata);

        for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqlind);

        exec sql close curs30;
        exec sql clear stmt30;

        free (out_desc_30.sqlvar); 
    }
    SQLcursor[30] = 0;
    SQLcursor_count[30] = 0;
	
    _SQLdebug(( fname, "%s\n", "Closing out partial query" ));

    return( SQL_S_SUCCESS );
}

       exec sql fetch curs30 using descriptor out_desc_30;
       _SQLdebug(( fname, "%s\n", "Fetch curs30 (First time)" ));
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_FETCH,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Fetch Cursors Failed : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
                if( SQLcursor[30] && ( SQLcursor_count[30] > 0 ))
                    status = SQL_I_NO_MORE_DATA;
             _SQLdebug ((fname,  "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqlind);

          exec sql close curs30;
          exec sql clear stmt30;

          free (out_desc_30.sqlvar); 
          SQLcursor[30] = 0;
          SQLcursor_count[30] = 0;
          return (status);
        }

       str = (char *) malloc ((*list) -> row_size + 100);
       if (! str)
        {
	  status = SQL_E_MALLOC ;
          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqlind);

          exec sql close curs30;
          exec sql clear stmt30;
          if (NEW_LIST) MEMclose (list);
          free (out_desc_30.sqlvar);
          _SQLdebug ((fname, "Malloc Failed : status = <0x%.8x>\n", status));
          ERRload_struct (SQL, status, "%s", "Malloc failed");
          SQLcursor[30] = 0;
          SQLcursor_count[30] = 0;
          return (status);
        }

       fetch_count = 1;
       ++SQLcursor_count[30];

       while (SQLCODE != END_OF_DATA )            
       {
	  _SQLdebug(( fname, "Fetch_count <%d>\n", fetch_count ));
          str [0] = 0;

          for (i = 0; i < out_desc_30.sqld; ++i)
           {
             if (*out_desc_30.sqlvar [i].sqlind < 0)
              {
                strcat (str, "\1");
                continue;
              }

             memset (data, 0, 29);

             switch (out_desc_30.sqlvar [i].sqltype)
              {
                case CHARACTER :
                  data1 = (char *) malloc (out_desc_30.sqlvar[i].sqllen + 2);
                  if (! data1)
                   {
		     status = SQL_E_MALLOC ;
                     for (x = 0; x < out_desc_30.sqld; ++x)
                       free (out_desc_30.sqlvar [x].sqldata);
  
                     for (x = 0; x < out_desc_30.sqld; ++x)
                       free (out_desc_30.sqlvar [x].sqlind);

                     exec sql close curs30;
                     exec sql clear stmt30;
                     free (str);
                     if (NEW_LIST) MEMclose (list);
                     free (out_desc_30.sqlvar);
                     _SQLdebug ((fname, "Malloc : status = <0x%.8x>\n",
                     status));
                     ERRload_struct (SQL, status, "%s", "Malloc failed");
	             SQLcursor[30] = 0;
	             SQLcursor_count[30] = 0;
                     return (status);
                   }
                  memset (data1, 0,  out_desc_30.sqlvar[i].sqllen + 1);

                  sprintf (data1, "%-*.*s", out_desc_30.sqlvar[i].sqllen, 
                  out_desc_30.sqlvar[i].sqllen, out_desc_30.sqlvar [i].sqldata);
                  strcat (str, data1);
                  strcat (str, "\1");
                  free (data1);
                  break;

                case INTEGER :
                  sprintf (data, "%d", *(int *)
                           out_desc_30.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case SMALLINT :
                  sprintf (data, "%hd", 
                           *(short *) out_desc_30.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DOUBLE :
                  sprintf (data, "%lf", 
                           *(double *) out_desc_30.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case REAL :
                  sprintf (data, "%lG", 
                           *(float *) out_desc_30.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

                case DECIMAL :
                  sprintf (data, "%d", *(int *)
                           out_desc_30.sqlvar [i].sqldata);
                  strcat (str, data);
                  strcat (str, "\1");
                  break;

	        case DATETIME :
	        ptr  = (datetime *) out_desc_30.sqlvar [i].sqldata ;
	
	        status = RISdatetime_to_ascii (ptr, data, 
                                          SQLglobal.ris_print_format) ;	
	        if (status != RIS_SUCCESS)
               {
                  for (x = 0; x < out_desc_30.sqld; ++x)
                    free (out_desc_30.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_30.sqld; ++x)
                    free (out_desc_30.sqlvar [x].sqlind);

                  exec sql close curs30;
                  exec sql clear stmt30;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_30.sqlvar);
 	          SQLcursor[30] = 0;
  	          SQLcursor_count[30] = 0;
	          sprintf (message, "RISdatetime_to_ascii : error %ld",
			   status);
	          ERRload_struct (SQL, SQL_E_MESSAGE, "%s", message) ;
	          return (SQL_E_MESSAGE) ;
               }
                  strcat (str, data);
                  strcat (str, "\1");
		break;

                default :
	          status = SQL_E_DATA_TYPE ;
                  for (x = 0; x < out_desc_30.sqld; ++x)
                    free (out_desc_30.sqlvar [x].sqldata);
  
                  for (x = 0; x < out_desc_30.sqld; ++x)
                    free (out_desc_30.sqlvar [x].sqlind);

                  exec sql close curs30;
                  exec sql clear stmt30;
                  free (str);
                  if (NEW_LIST) MEMclose (list);
                  free (out_desc_30.sqlvar);
                  _SQLdebug ((fname, "Bad Data Type : status = <0x%.8x>\n",
                  status));
                  ERRload_struct (SQL, status, "%s", "Invalid data type");
 	          SQLcursor[30] = 0;
	          SQLcursor_count[30] = 0;
                  return (status);
              }
           }

          status = MEMwrite (*list, str);
          if (status != MEM_S_SUCCESS)
           {
             for (x = 0; x < out_desc_30.sqld; ++x)
               free (out_desc_30.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_30.sqld; ++x)
               free (out_desc_30.sqlvar [x].sqlind);

              exec sql close curs30;
              exec sql clear stmt30;
              free (str);
              if (NEW_LIST) MEMclose (list);
              free (out_desc_30.sqlvar);
              _SQLdebug ((fname, "MEM Write Failed: status = <0x%.8x>\n",
    	          status));
              SQLcursor[30] = 0;
              SQLcursor_count[30] = 0;
              return (SQL_E_MEM);
           }

	if( fetch_count < rows )
	{ 
          exec sql fetch curs30 using descriptor out_desc_30;
          _SQLdebug(( fname, "%s\n", "Fetch in loop" ));
          if (SQLCODE && (SQLCODE != END_OF_DATA))
           {
             if (SQLCODE != END_OF_DATA)
              {
                if (NEW_LIST) MEMclose (list);
                status = SQLerror (SQL_E_FETCH,
                         risca -> sqlerrd [1], SQLCODE);
                _SQLdebug ((fname, "Fetch Cursors : status = <0x%.8x>\n",
                status));
              }
             else
              {
                status = SQL_I_NO_ROWS_FOUND;
                if( SQLcursor[30] )
                    status = SQL_I_NO_MORE_DATA;
                _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
                status));
		ERRload_struct (SQL, status, NULL) ;
              }

             for (x = 0; x < out_desc_30.sqld; ++x)
               free (out_desc_30.sqlvar [x].sqldata);

             for (x = 0; x < out_desc_30.sqld; ++x)
               free (out_desc_30.sqlvar [x].sqlind);

             exec sql close curs30;
             exec sql clear stmt30;
             free (str);

             free (out_desc_30.sqlvar);
             SQLcursor[30] = 0;
             SQLcursor_count[30] = 0;
             return (status);
           }
 	 ++fetch_count;
	 ++SQLcursor_count[30];
	 } /*  end if( fetch_count < rows ) */
	 else
	 {
	     _SQLdebug(( fname, "Fetch_count <%d> :  Requested Rows <%d>\n",
			 fetch_count, rows ));	
	     _SQLdebug(( fname, "%s\n", "Reached Requested Row # before End of Data " ));
	     free( str );
	     return (SQL_S_SUCCESS);
	 }
        }
       _SQLdebug(( fname, "%s\n", "Closing Cursor" ));

       exec sql close curs30;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLOSE,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Close Cursors : status = <0x%.8x>\n",
             status));
           }
          else
           {
	     status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }

	  
          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqldata);

          for (x = 0; x < out_desc_30.sqld; ++x)
            free (out_desc_30.sqlvar [x].sqlind);

          exec sql clear stmt30;
          free (str);

          free (out_desc_30.sqlvar);
          SQLcursor[30] = 0;
          SQLcursor_count[30] = 0;
          return (status); 
        }

       free (str);

       for (i = 0; i < out_desc_30.sqld; ++i)
        {
          free (out_desc_30.sqlvar [i].sqldata);
          free (out_desc_30.sqlvar [i].sqlind);
        }

       free (out_desc_30.sqlvar);

       exec sql clear stmt30;
       if (SQLCODE)
        {
          if (SQLCODE != END_OF_DATA)
           {
             if (NEW_LIST) MEMclose (list);
             status = SQLerror (SQL_E_CLEAR,
                      risca -> sqlerrd [1], SQLCODE);
             _SQLdebug ((fname, "Clear Statement : status = <0x%.8x>\n",
             status));
           }
          else
           {
             status = SQL_I_NO_ROWS_FOUND ;
             _SQLdebug ((fname, "No Rows Found : status = <0x%.8x>\n",
             status));
	     ERRload_struct (SQL, status, NULL) ;
           }
          SQLcursor[30] = 0;
	  SQLcursor_count[30] = 0;
          return (status);
        }


       _SQLdebug ((fname, "SUCCESSFUL : number of rows = <%ld>\n", 	
	(*list)->rows)) ;		
       SQLcursor[30] = 0;
       SQLcursor_count[30] = 0;
       return (SQL_I_NO_MORE_DATA);
    }

