#include "machine.h"
#include <stdio.h>
#include "MEMstruct.h"
#include "SQLerrordef.h"
#include "MSGstruct.h"
#include "DEBUG.h"
#include "ERR.h"




/***************************************************************************
*				SQLget_max_record_num			   *
*									   *
*	Get the maximum value of indicated attribute in the given table	   *
***************************************************************************/

long SQLget_max_record_num(table_name ,attr_name, max_num)
	char *table_name,*attr_name;
	long *max_num ;
{
	char *fname="SQLget_max_record_num";
	exec sql begin declare section;
	long status,i;
	char sql_str[1024];
	long num_of_rows;
	sqlda	out_desc;
	exec sql end declare section;

	long SQLget_n_name();
	_SQLdebug((fname,"Entry\t>>\ntable_name\
 %s attribute name <%s> maximum number address %x\n",table_name,attr_name,max_num));
	sprintf(sql_str,"SELECT max(%s) from %s",attr_name,table_name);
	exec sql prepare stmt1 from :sql_str;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt1;
           return (status);
        }

        out_desc.sqld = 0;
        out_desc.sqln = 0;
        out_desc.sqlvar = 0;
	exec sql describe output stmt1 using descriptor out_desc;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_DESCRIBE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt1;
           return (status);
        }
	exec sql declare curs1 cursor for stmt1;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_DECLARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt1;
           return (status);
        }

	exec sql open curs1;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_CURSOR,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt1;
           return (status);
        }

	out_desc.sqlvar = (sqlvar *)calloc(out_desc.sqld,sizeof(sqlvar));
	out_desc.sqln = out_desc.sqld ;
	exec sql describe output stmt1 using descriptor out_desc;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_DESCRIBE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n", status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt1;
	   free(out_desc.sqlvar);
           return (status);
        }

	for(i=0;i < out_desc.sqld;i++)
	{
		out_desc.sqlvar[i].sqldata=(char *)calloc(1,out_desc.sqlvar[i].sqllen);
		out_desc.sqlvar[i].sqlind =(long *) calloc ( 1, sizeof(long));
	}

	exec sql fetch curs1 using descriptor out_desc;	
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_FETCH,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
	

           exec sql clear stmt1;
		free(out_desc.sqlvar);
		for(i=0;i < out_desc.sqld;i++)
		{
			free(out_desc.sqlvar[i].sqldata);
			free(out_desc.sqlvar[i].sqlind);
		}
           return (status);
        }

	i=0;
	exec sql close curs1;
	exec sql clear stmt1;
	*max_num = * ( int *) out_desc.sqlvar[0].sqldata ;
	_SQLdebug((fname,"Successful : Number of rows <%d> \n", *max_num ));
		free(out_desc.sqlvar);
		for(i=0;i < out_desc.sqld;i++)
		{
			free(out_desc.sqlvar[i].sqldata);
			free(out_desc.sqlvar[i].sqlind);
		}
	return(SQL_S_SUCCESS);	
}





/***************************************************************************
*				SQLget_min_record_num			   *
*									   *
*	Get the minimum value of indicated attribute in the given table	   *
***************************************************************************/

long SQLget_min_record_num(table_name ,attr_name, min_num)
	char *table_name,*attr_name;
	long *min_num ;
{
	char *fname="SQLget_min_record_num";
	exec sql begin declare section;
	long status,i;
	char sql_str[1024];
	long num_of_rows;
	sqlda	out_desc;
	exec sql end declare section;

	_SQLdebug((fname,"Entry\t>>\ntable_name\
 %s attribute name <%s> minimum number address %x\n",table_name,attr_name,min_num));
	sprintf(sql_str,"SELECT min(%s) from %s",attr_name,table_name);
	exec sql prepare stmt2 from :sql_str;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_PREPARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt2;
           return (status);
        }

        out_desc.sqld = 0;
        out_desc.sqln = 0;
        out_desc.sqlvar = 0;
	exec sql describe output stmt2 using descriptor out_desc;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_DESCRIBE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt2;
           return (status);
        }
	exec sql declare curs2 cursor for stmt2;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_DECLARE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt2;
           return (status);
        }

	exec sql open curs2;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_CURSOR,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt2;
           return (status);
        }

	out_desc.sqlvar = (sqlvar *)calloc(out_desc.sqld,sizeof(sqlvar));
	out_desc.sqln = out_desc.sqld ;
	exec sql describe output stmt2 using descriptor out_desc;
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_DESCRIBE,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n", status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }

           exec sql clear stmt2;
	   free(out_desc.sqlvar);
           return (status);
        }

	for(i=0;i < out_desc.sqld;i++)
	{
		out_desc.sqlvar[i].sqldata=(char *)calloc(1,out_desc.sqlvar[i].sqllen);
		out_desc.sqlvar[i].sqlind =(long *) calloc ( 1, sizeof(long));
	}

	exec sql fetch curs2 using descriptor out_desc;	
       if (SQLCODE)
        {
           if (SQLCODE != END_OF_DATA)
            {
              status = SQLerror (SQL_E_FETCH,
                       risca -> sqlerrd [1], SQLCODE);
              _SQLdebug ((fname,"SQL QRY : Prepare Failed : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
           else
           {
              status = SQLerror (SQL_I_NO_ROWS_FOUND,
                       risca -> sqlerrd [1], SQLCODE); 
              status = SQL_I_NO_ROWS_FOUND ;
              _SQLdebug ((fname,"SQL QRY : No Rows Found : status = <0x%.8x>\n",
              status));
              ERRload_struct (SQL, status, NULL) ;
            }
	

           exec sql clear stmt2;
		free(out_desc.sqlvar);
		for(i=0;i < out_desc.sqld;i++)
		{
			free(out_desc.sqlvar[i].sqldata);
			free(out_desc.sqlvar[i].sqlind);
		}
           return (status);
        }

	i=0;
	exec sql close curs2;
	exec sql clear stmt2;
	*min_num = * ( int *) out_desc.sqlvar[0].sqldata ;
	_SQLdebug((fname,"Successful : Number of rows <%d> \n", *min_num ));
		free(out_desc.sqlvar);
		for(i=0;i < out_desc.sqld;i++)
		{
			free(out_desc.sqlvar[i].sqldata);
			free(out_desc.sqlvar[i].sqlind);
		}
	return(SQL_S_SUCCESS);	
}


