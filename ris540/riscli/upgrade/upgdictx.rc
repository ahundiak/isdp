/*
**  NAME:                           upgdictx.rc
**  AUTHORS:                        Bhaskar R. Sayyaparaju
**  CREATION DATE:                  3/94
**  ABSTRACT:
**      The functions that handle schemas for the RIS upgrade utility.
**
**  REVISION HISTORY:
*/

/*
**  DEFINES
*/

/*
**  INCLUDES
*/
#ifdef UPGRADE_GLOBAL_DEFINE
#undef UPGRADE_GLOBAL_DEFINE
#endif

#ifdef MKMK_KLUDGE
#include "upgrade.h"
#endif

exec sql include "upgrade.h";
#ifdef WIN32
#include <windows.h>
#endif
#include <sys/stat.h>
#include "ris_err.h"
#include "risupger.h"

/*
**  FUNCTION PROTOTYPES
*/
#define  upgschema_rc
#include "sys.prt"
#if defined(clipper) || defined(__clipper__) || defined(sco) || defined(WIN32) || defined(vms)
#include "sysalloc.prt"
#endif
#include "comjmp.prt"
#include "comwrap.prt"
#include "wrap.prt"
#include "comdebug.prt"
#include "comumsg.prt"
#include "cnvschfl.prt"
#include "upgcolmn.prt"
#include "upgprvdf.prt"
#include "upgtable.prt"
#include "upgview.prt"
#include "upgdictx.prt"

/*
**  VARIABLES
*/

/*
**  FUNCTIONS
*/

extern int RISupg_extract_dict_info(
			char *sch_name,
			char *tab_filename,
			char *view_filename,
			char *col_filename,
			char *priv_filename)
{
	char schname[RIS_MAX_ID_SIZE];
	access_struct	*access_ptr=0;
	int unload_table_info=0; 
	int unload_view_info=0; 
	int unload_col_info=0; 
	int unload_grant_info=0; 
	char	save_dir[RIS_MAX_PATH_SIZE]="";
	char	tab_sav_file[RIS_MAX_PATH_SIZE]="";
	char	vew_sav_file[RIS_MAX_PATH_SIZE]="";
	char	col_sav_file[RIS_MAX_PATH_SIZE]="";
	char	prv_sav_file[RIS_MAX_PATH_SIZE]="";
	char	save_file[RIS_MAX_PATH_SIZE]="";
	int status = 0;
#if !defined(WIN32)
	struct stat buf;
#else
	struct _stat buf;
#endif

	UPG_DBG(("RISupg_extract_dict_info: schema name <0x%x>\n",sch_name));
	strcpy(schname,sch_name);
	UPG_DBG(("Table dump file name : <%s>\n",tab_filename));
	UPG_DBG(("View dump file name : <%s>\n",view_filename));
	UPG_DBG(("Column dump file name : <%s>\n",col_filename));
	UPG_DBG(("Grant dump file name : <%s>\n",priv_filename));
	status = SETJMP();
	if (status)
	{
		RESETJMP();
		printf(MSG(RIS_E_UPG_EXTRACT_DATA),
					schname);	
		RIScom_fclose(RISupg_table_fp);
		RIScom_fclose(RISupg_view_fp);
		RIScom_fclose(RISupg_col_fp);
		RIScom_fclose(RISupg_priv_fp);
		LONGJMP(status);
	}
#ifdef DEBUG
	printf("Unloading the Table information into %s file\n",tab_filename);
#endif
	unload_table_info = risupg_cur_sch->tabunload;
	unload_view_info = risupg_cur_sch->viewunload;
	unload_col_info = risupg_cur_sch->colunload;
	unload_grant_info = risupg_cur_sch->grantunload;

	printf(MSG(RIS_I_UPG_EXTRACT_SCHEMA_MSG1));
	printf(MSG(RIS_I_UPG_EXTRACT_SCHEMA_MSG2));
	printf(MSG(RIS_I_UPG_EXTRACT_SCHEMA_MSG3));
	while (1)
	{
		printf(MSG(RIS_I_UPG_EXTRACT_SCHEMA_MSG4));
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
		gets(save_dir); 
		if (save_dir[0] == '\0')
			break;
#if defined(WIN32)
		status = _stat(save_dir,&buf);
#else
		status = stat(save_dir,&buf);
#endif
		if (status)
			printf(MSG(RIS_E_UPG_CANT_ACCESS_DIR));
		else
			break;
	}
	strcpy(save_file,schname);
	if (save_dir[0] != '\0')
	{
#ifdef WIN32
		strcat(save_dir,"\\");
		if (strlen(save_file) > 8)
			save_file[8] = '\0';
#else
		strcat(save_dir,"/");
		if (strlen(save_file) > 10)
			save_file[10] = '\0';
#endif
		strcat(save_dir,save_file);
	}
	else
	{
#ifdef WIN32
        if (strlen(save_file) > 8)
            save_file[8] = '\0';
#else
        if (strlen(save_file) > 10)
            save_file[10] = '\0';
#endif
        strcpy(save_dir,save_file);
	}

	if (unload_table_info == -1)
	{
		RISupg_table_fp = RIScom_fopen(tab_filename,"w+");
		if (!RISupg_table_fp)
		{
			printf(MSG(RIS_E_UPG_CANT_READ_SCHEMADUMPFILE));
			LONGJMP(RISupg_CANT_READ_SCHEMADUMPFILE);
		}
		strcpy(tab_sav_file,save_dir);
		strcat(tab_sav_file,".");
		strcat(tab_sav_file,"tab");

	}
	if (unload_view_info == -1)
	{
		RISupg_view_fp = RIScom_fopen(view_filename,"w+");
		if (!RISupg_view_fp)
		{
			printf(MSG(RIS_E_UPG_CANT_READ_SCHEMADUMPFILE));
			LONGJMP(RISupg_CANT_READ_SCHEMADUMPFILE);
		}
		strcpy(vew_sav_file,save_dir);
		strcat(vew_sav_file,".");
		strcat(vew_sav_file,"vew");
	}
	if (unload_col_info == -1)
	{
		RISupg_col_fp = RIScom_fopen(col_filename,"w+");
		if (!RISupg_col_fp)
		{
			printf(MSG(RIS_E_UPG_CANT_READ_SCHEMADUMPFILE));
			LONGJMP(RISupg_CANT_READ_SCHEMADUMPFILE);
		}
		strcpy(col_sav_file,save_dir);
		strcat(col_sav_file,".");
		strcat(col_sav_file,"col");
	}
	if (unload_grant_info == -1)
	{
		RISupg_priv_fp = RIScom_fopen(priv_filename,"w+");
		if (!RISupg_priv_fp)
		{
			printf(MSG(RIS_E_UPG_CANT_READ_SCHEMADUMPFILE));
			LONGJMP(RISupg_CANT_READ_SCHEMADUMPFILE);
		}
		strcpy(prv_sav_file,save_dir);
		strcat(prv_sav_file,".");
		strcat(prv_sav_file,"prv");
	}
#ifdef DEBUG
	printf("UNLOAD INFO:TABUNLOAD:%d\n VIEWUNLOAD:%d\nCOLUNLOAD:%d\n",
			unload_table_info,unload_view_info,unload_col_info);
	printf("GRANTUNLOAD:%d\n",unload_grant_info);
#endif
	UPG_DBG(("UNLOAD INFO:TABUNLOAD:%d\n VIEWUNLOAD:%d\nCOLUNLOAD:%d\n",
			unload_table_info,unload_view_info,unload_col_info));
	UPG_DBG(("GRANTUNLOAD:%d\n",unload_grant_info));
	if (unload_table_info == -1)
	{
		RISupg_extract_n_include_tables(sch_name);
		RIScom_fclose(RISupg_table_fp);
		RISupg_put_file(tab_filename,tab_sav_file);
	}
	else
	{
		printf(MSG(RIS_I_UPG_TABINFO_ALREADY_EXTRACTED));
		fflush(stdout);
	}
	if (unload_view_info == -1)
	{
		printf(MSG(RIS_I_UPG_EXTRACT_VIEWINFO));
		fflush(stdout);
		RISupg_build_n_process_views();
		RIScom_fclose(RISupg_view_fp);
		RISupg_put_file(view_filename,vew_sav_file);
	}
	else
	{
		printf(MSG(RIS_I_UPG_VIEWINFO_ALREADY_EXTRACTED));
		fflush(stdout);
	}
	if (unload_col_info == -1)
	{
		printf(MSG(RIS_I_UPG_EXTRACT_COLINFO));
		fflush(stdout);
		RISupg_get_col_data(sch_name);
		RIScom_fclose(RISupg_col_fp);
		RISupg_put_file(col_filename,col_sav_file);
	}
	else
	{
		printf(MSG(RIS_I_UPG_COLINFO_ALREADY_EXTRACTED));
		fflush(stdout);
	}
	if (unload_grant_info == -1)
	{
		printf(MSG(RIS_I_UPG_EXTRACT_GRANTINFO));
		fflush(stdout);
		RISupg_extract_n_build_privs(sch_name,&access_ptr);
		RIScom_fclose(RISupg_priv_fp);
		RISupg_put_file(priv_filename,prv_sav_file);
	}
	else
	{
		printf(MSG(RIS_I_UPG_GRANTINFO_ALREADY_EXTRACTED));
		fflush(stdout);
	}
	
	RESETJMP();
	UPG_DBG(("RISupg_extract_dict_info: end\n"));
	return(0);
}
