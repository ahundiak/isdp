/*
**  NAME:                           cnvschfl.rc
**  AUTHORS:                        Sunil Murthy
**  CREATION DATE:                  01/19/93
**  ABSTRACT:
**      Utility for fixing the schema file.
**
**  REVISION HISTORY:
**		Modified by Raju to accomodate V4 -> V5 schema file
**		Conversion. 03/94
*/

/*
**  INCLUDES
*/
#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#if defined(WIN32)
#include <windows.h>
#else
#if !defined(sun)
#include <termio.h>
#endif
#include "rislimit.h"
#include "risver.h"
#include "riscom.h"
#include "risprods.h"
#include "file.h"
#endif
#include "ris.h"
#include "risstjmp.h"
#include "schfile.h"
#include "risupger.h"
#include "risupg.h"

#ifdef MKMKKLUDGE
#include "upgrade.h"
#endif

exec sql include "upgrade.h";
/*
**  FUNCTION PROTOTYPES
*/
#define cnvschfl_rc
#include "sys.prt"
#include "sysalloc.prt"
#include "wrap.prt"
#include "ris.prt"
#include "cnvschfl.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "compd.prt"
#include "comwrap.prt"
#include "comumsg.prt"
#include "upgmisc.prt"
#include "upgterm.prt"
#if !defined (WIN32)
#include "comprtcl.prt"
#include "netgnerc.prt"
#endif

/*
** DEFINES
*/
#if defined (__Sol2__)
# define NSIG	44
#elif defined(Soli)
# define NSIG	34
#endif
#if defined (sun)
#define _NSIG NSIG
#endif
#if defined (WIN32)
# define	SIGSET(a,b)	signal(a,b)	
#else
# define	SIGSET(a,b)	sigset(a,b)
#endif
#ifndef _NSIG
# define _NSIG NSIG
#endif
#define OSCOUNT 2
#define ID_BUFFER_SIZE  256
/*
**	Version 5 specific schema information.
*/
#define V5SCHEMA_INFO "SERVER_VERSION=0.0\nSECURE=0\nDICTOWNER"

/*
** VARIABLES
*/
static char yesno[3] = "YN";
static char sybmsoft[3]="YM";
static char id[ID_BUFFER_SIZE];
static char id_name[ID_BUFFER_SIZE];
static char filename[L_tmpnam];
static char tmp_name[L_tmpnam];
static char tmp_id_name[L_tmpnam];
#if defined(WIN32)
static char lock_file_name[RIS_MAX_PATH_SIZE];
static char id_file_name[RIS_MAX_PATH_SIZE];
static char sch_file_name[RIS_MAX_PATH_SIZE];
#endif

/* 
**	The following variables are used to store the info about schemas
**	. i.e what kind of database the schema belongs to so as to figure
**	which case to use to write the DICTOWNER field during the conversion
**	of schema file.
*/
static schdbmap    *schdblist;
static dbinfo      *dbinfp;

/*
**  FUNCTIONS
*/

/******************************************************************************/

static void head()
{
	printf("================================================================================\n");
	printf(MSG(RIS_I_UPG_HEAD1));
	printf(MSG(RIS_I_UPG_HEAD2));
	printf(MSG(RIS_I_UPG_HEAD3));
	printf(MSG(RIS_I_UPG_HEAD4));
	printf(MSG(RIS_I_UPG_HEAD5));
	printf(MSG(RIS_I_UPG_HEAD6));
	printf(MSG(RIS_I_UPG_HEAD7));
	printf(MSG(RIS_I_UPG_HEAD8));
	printf("\n");
	printf(MSG(RIS_I_UPG_HEAD9));
	printf(MSG(RIS_I_UPG_HEAD10));
	printf("================================================================================\n");
}

/******************************************************************************/

static int read_id_file(
	char	*buffer,
	int	size)
{
	char	*ptr;
	char	temp_name[L_tmpnam];
	FILE	*filep;

	/*
	**	NOTE:	If the id file doesn't exist, this routine will put a 
	**		null string in buffer and return RIS_SUCCESS
	*/

	UPG_DBG(("read_id_file:begin\n"));
	*buffer = 0;
  	tmpnam(temp_name);

#if defined (WIN32)
	if (!RISupg_put_file(id_file_name,temp_name))
#else
	if (!NET_get_file(&RIS_file_net,&RIS_file_connect,RIS_id_file,
		temp_name))
#endif
	{
		if ((filep = fopen(temp_name, "r")) == NULL)
		{
			UNLINK(temp_name);
			return -1;
		}

		fgets(buffer, size, filep);
		if ((ptr = strchr(buffer, '\n')) == NULL)
			ptr = buffer + (size - 1);
		*ptr = 0;
		UPG_DBG(("read_id_file: buffer: %s\n",buffer));
		fclose(filep);

		UNLINK(temp_name);
		UPG_DBG(("read_id_file:end returning 1\n"));
		return 1;
	}
	else
	{
		UNLINK(temp_name);
		UPG_DBG(("read_id_file:end returning -1\n"));
		return -1;
	}
}

/******************************************************************************/

extern void no_change_exit()
{
	UPG_DBG(("no_change_exit:begin\n"));
	read_id_file(id, ID_BUFFER_SIZE);
	if (!strcmp(id, id_name))
	{
#ifdef WIN32
		_unlink(id_file_name);
#else
		NET_remove_file(&RIS_file_net,&RIS_file_connect,RIS_id_file);
#endif
	}
#ifdef WIN32
	RISupg_put_lock_file(lock_file_name);
#else
	NET_put_lock_file(&RIS_file_net,&RIS_file_connect,RIS_lock_file);
#endif
	UNLINK(filename);
	UNLINK(tmp_name);
	UNLINK(tmp_id_name);
	printf(MSG(RIS_E_UPG_NO_MODIFICATION));
	UPG_DBG(("no_change_exit: end\n"));
	return;
}

/******************************************************************************/
#if defined (WIN32)
extern BOOL     WINAPI handle_int(
        DWORD   dwCtrlType)
{
      UPG_DBG(("handle_int: begin\n"));
        if (dwCtrlType == CTRL_C_EVENT)
        {
                SET_INTERRUPT();
              printf(MSG(RIS_E_UPG_GOT_INTERRUPT));
              UPG_DBG(("handle_int: returning TRUE\n"));
                return TRUE;
        }
      UPG_DBG(("handle_int: returning FALSE\n"));
        return FALSE;
}
#endif
/*****************************************************************************/

extern void sig_handler(int sig)
{
   	printf(MSG(RIS_E_UPG_INTERRUPT), sig);
	no_change_exit();
	UPG_DBG(("sig_handler: reset_terminal\n"));
    RISupg_reset_terminal();
	UPG_DBG(("LONGJMP : due to signal %d",sig));
	RISupg_got_signal = 1;
	LONGJMP(sig);
}

/******************************************************************************/

extern void init_signal()
{
	int sig;

	UPG_DBG(("init_signal: begin\n"));
	for (sig=1;sig < _NSIG;sig++)
	{
		switch(sig)
		{

/* handle these signals */

#ifdef SIGHUP
			case SIGHUP:
#endif
#ifdef SIGINT
#if !defined WIN32
			case SIGINT:
#endif
#endif
#ifdef SIGQUIT
			case SIGQUIT:
#endif
#ifdef SIGILL
			case SIGILL:
#endif
#ifdef SIGABRT
			case SIGABRT:
#endif
#ifdef SIGEMT
			case SIGEMT:
#endif
#ifdef SIGFPE
			case SIGFPE:
#endif
#ifdef SIGBUS
			case SIGBUS:
#endif
#ifdef SIGSEGV
			case SIGSEGV:
#endif
#ifdef SIGSYS
			case SIGSYS:
#endif
#ifdef SIGPIPE
			case SIGPIPE:
#endif
#ifdef SIGTERM
			case SIGTERM:
#endif
#if !defined (sun)
#ifdef SIGPWR
			case SIGPWR:
#endif
#endif
				if (SIGSET(sig, &sig_handler) == SIG_ERR)
				{
                    printf(MSG(RIS_E_UPG_ERR_SIGSET), sig);
					no_change_exit();
				}
			break;

			default:
			break;
		}
	}
	UPG_DBG(("init_signal: end\n"));
}

/******************************************************************************/
#if !defined (WIN32)

static void init_net_parms_addr(
	schema_file_parms *sf,
	char	**ptr)
{
	
	/*
	** initialize protocol address
	*/
	UPG_DBG(("init_net_parms_addr: begin\n"));
	RIScom_init_protocols(
		RIS_local_xns_addr, sizeof(RIS_local_xns_addr),
		RIS_local_tcp_addr, sizeof(RIS_local_tcp_addr),
		RIS_local_lu62_addr, sizeof(RIS_local_lu62_addr),
		RIS_local_dnp_addr, sizeof(RIS_local_dnp_addr));

	/*
	** initialize network parameters
	*/
	switch(sf->protocol)
	{
		case 'M':
			RIS_file_net.protocol = SHMEM;

			break;

		case 'T':
			RIS_file_net.protocol = TCP;
			strcpy(RIS_file_connect.tcp.address, sf->address);
			strcpy(RIS_file_connect.tcp.username, sf->username);
#ifdef OLD
			strcpy(RIS_file_connect.tcp.password, sf->password);
#else
			RIScom_depd(sf->password, RIS_file_connect.tcp.password);
#endif
			*ptr = RIS_local_tcp_addr;

			break;

		case 'X':
			RIS_file_net.protocol = XNS;
			strcpy(RIS_file_connect.xns.address, sf->address);
			strcpy(RIS_file_connect.xns.username, sf->username);
#ifdef OLD
			strcpy(RIS_file_connect.xns.password, sf->password);
#else
			RIScom_depd(sf->password, RIS_file_connect.xns.password);
#endif
			*ptr = RIS_local_xns_addr;

			break;

		case 'D':
			RIS_file_net.protocol = DNP;
			strcpy(RIS_file_connect.dnp.node_name, sf->address);
			strcpy(RIS_file_connect.dnp.userid, sf->username);
#ifdef OLD
			strcpy(RIS_file_connect.dnp.password, sf->password);
#else
			RIScom_depd(sf->password, RIS_file_connect.dnp.password);
#endif
			*ptr = RIS_local_dnp_addr;

			break;

		default:

			break;
	}
	UPG_DBG(("init_net_parms_addr: end\n"));
}
#endif

/******************************************************************************/

extern char get_answer(
	char *prompt,
	int answer_count,
	char answers[],
	char def)
{
	char tmp_prompt[512]; /* MAX_MSG_SIZE */
	char *ptr=0;
	int i=0;
	char buf[80]="";

	buf[0] = '\0';

	strcpy(tmp_prompt,prompt);
	UPG_DBG(("get_answer: prompt <%s>, answer_count <%d>, answers <%s> def <%c>\n",prompt,answer_count,answers,def));
	while(1)
	{
		printf("%s",tmp_prompt);
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
		fflush(stdout);
		if (!gets(buf))
		{
			continue;
		}
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
		ptr = buf;
		while (*ptr && isspace(*ptr))
		{
			++ptr;
		}
		if (islower(*ptr))
		{
			*ptr = _toupper(*ptr);
		}
		if (*ptr == '\0') 
		{
			*ptr = def;
		}
		for (i=0; i < answer_count; ++i)
		{
			if (*ptr == answers[i])
			{
				UPG_DBG(("get_answer: prompt <%s>, answer <%c>\n",tmp_prompt,*ptr));
				return *ptr;
			}
		}
        printf(MSG(RIS_E_UPG_INVALID_ANSWER), *ptr);
	}
}

/******************************************************************************/
/*
**	Build schema and database information from the schema file to findout
**	the database type for the schema
*/

static void build_schema_db_info(
    FILE *in)
{
    char    line[80];
    schdbmap    *tmpschlst=0;
    dbinfo      *tmpdbinfp=0;

    schdblist = 0;
    dbinfp = 0;

	UPG_DBG(("build_schema_db_info: begin\n"));
    while (fgets(line,80,in) != NULL)
    {
        line[strlen(line)-1] = '\0';
	UPG_DBG(("build_schema_db_info: %s\n",line));
        if (strncmp(line, SCHNAME, SCHNAME_SIZE) == 0)
        {
            if (!schdblist)
            {
                schdblist = (schdbmap *) malloc(sizeof(schdbmap));
                if (!schdblist)
                {
               	 	fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
                	LONGJMP(RISupg_CANNOT_ALLOCATE_MEMORY);
                }
                tmpschlst = schdblist;
            }
            else
            {
                tmpschlst->next = (schdbmap *) malloc(sizeof(schdbmap));
                if (!tmpschlst->next)
                {
               	 	fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
                	LONGJMP(RISupg_CANNOT_ALLOCATE_MEMORY);
                }
                tmpschlst = tmpschlst->next;
            }
            strcpy(tmpschlst->schname,line+SCHNAME_SIZE);
            tmpschlst->next = 0;
            tmpschlst->dbid = 0;
            tmpschlst->dbtype = 0;
            while(1)
            {
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
                if(fgets(line,80,in) == NULL)
                {
					printf(MSG(RIS_E_UPG_SCHEMAFILE_CORRUPTED1));
        			no_change_exit();
        			LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
                }
                else
                {
                    line[strlen(line)-1] = '\0';
                    if (!strncmp(line,DBID,DBID_SIZE))
			{
            		tmpschlst->dbid = (unsigned short)atoi(line + DBID_SIZE);
			UPG_DBG(("build_schema_db_info: schname: %s, dbid :%d\n"
					,tmpschlst->schname,tmpschlst->dbid));
                        break;
			}
                }
            }
        }
        else if (strncmp(line, DBID, DBID_SIZE) == 0)
        {
            if (!dbinfp)
            {
                dbinfp = (dbinfo *) malloc(sizeof(dbinfo));
                if (!dbinfp)
                {
               	 	fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
                	LONGJMP(RISupg_CANNOT_ALLOCATE_MEMORY);
                }
                tmpdbinfp = dbinfp;
            }
            else
            {
                tmpdbinfp->next = (dbinfo *) malloc(sizeof(dbinfo));
                if (!tmpdbinfp->next)
                {
               	 	fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
                	LONGJMP(RISupg_CANNOT_ALLOCATE_MEMORY);
                }
                tmpdbinfp = tmpdbinfp->next;
            }
            tmpdbinfp->dbid =(unsigned short)atoi(line + DBID_SIZE) ;
            tmpdbinfp->next = 0;
            if(fgets(line,80,in) == NULL)
            {
				printf(MSG(RIS_E_UPG_SCHEMAFILE_CORRUPTED1));
        		no_change_exit();
        		LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
            }
            else
            {
                line[strlen(line)-1] = '\0';
                if (!strncmp(line,DTYPE,DTYPE_SIZE))
                    tmpdbinfp->dbtype = *(line + DTYPE_SIZE);
            }
        }
    }
	UPG_DBG(("build_schema_db_info: end\n"));
}
/******************************************************************************/
/*
**	map the database type to the schema from the information built by
**	build_schema_db_info
*/

static void map_schema_to_dbtype()
{
    schdbmap    *tmpschlst=0;
    dbinfo      *tmpdbinfp=0;

    tmpschlst = schdblist;
    tmpdbinfp = dbinfp;

	UPG_DBG(("map_schema_to_dbtype: begin\n"));
    if (tmpschlst)
    {
        while (tmpschlst->next)
        {
            tmpdbinfp = dbinfp;
            while(tmpdbinfp)
            {
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
                if (tmpdbinfp->dbid == tmpschlst->dbid)
                {
                    tmpschlst->dbtype = tmpdbinfp->dbtype;
                    break;
                }
                tmpdbinfp = tmpdbinfp->next;
            }
            if (!tmpdbinfp)
            {
				UPG_DBG(("map_schema_to_dbtype: errori: \n"));
        		printf(MSG(RIS_E_UPG_SCHEMAFILE_CORRUPTED1));
        		no_change_exit();
        		LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
            }
            tmpschlst = tmpschlst->next;
        }
    }
	UPG_DBG(("map_schema_to_dbtype: end\n"));
}

/******************************************************************************/
static int find_dbtype(
	char	*schname)
{
    schdbmap    *tmpschlst=0;

	UPG_DBG(("find_dbtype: begin : schname: %s\n",schname));
	tmpschlst = schdblist;
	while (tmpschlst)
	{
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
		UPG_DBG(("find_dbtype: schlist: %s\n",
				tmpschlst->schname));
		if (!strncmp(tmpschlst->schname,schname,
				strlen(tmpschlst->schname)))
		{
			if (tmpschlst->dbtype == 'O' ||
				tmpschlst->dbtype == 'D' ||
				tmpschlst->dbtype == '4' ||
				tmpschlst->dbtype == 'R')
			{
				UPG_DBG(("find_dbtype: returning 1\n"));
				return (1);
			}
			else
			{
				UPG_DBG(("find_dbtype: returning 0\n"));
				return (0);
			}
		}
		tmpschlst = tmpschlst->next;
	}
	if (!tmpschlst)
	{
		UPG_DBG(("find_dbtype: error\n"));
        printf(MSG(RIS_E_UPG_SCHEMAFILE_CORRUPTED1));
        no_change_exit();
        LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
	}
	return(0);
}
	
/******************************************************************************/
static void Free_sch_db_info()
{
    schdbmap    *tmpschlst=0,*tmpschlst_priv=0;
    dbinfo      *tmpdbinfp=0,*tmpdbinfp_priv=0;

    tmpschlst = schdblist;
    tmpdbinfp = dbinfp;

	UPG_DBG(("Free_sch_db_info: begin\n"));
	while(tmpschlst)
	{
		tmpschlst_priv = tmpschlst;
		tmpschlst = tmpschlst->next;
		free(tmpschlst_priv);
	}
	while(tmpdbinfp)
	{
		tmpdbinfp_priv = tmpdbinfp;
		tmpdbinfp = tmpdbinfp->next;
		free(tmpdbinfp_priv);
	}
	schdblist = 0;
	dbinfp = 0;
	UPG_DBG(("Free_sch_db_info: end\n"));
}
	
/******************************************************************************/
static int read_write_file(
	FILE *in,
	FILE *out)
{
	char buffer[LINE_BUFFER_SIZE],dbname_buffer[LINE_BUFFER_SIZE];
	char schname[RIS_MAX_ID_SIZE];
	char dbname[RIS_MAX_ID_SIZE];
	char envbuf[80];
	char usrname[RIS_MAX_ID_SIZE];
	char passwd[100];
	char dtype[4];
	char ostype[4];
	char dir[100];
	char new_syb_dir[RIS_MAX_PATH_SIZE];
	int linenum=0;
	int schname_linenum=0;
	int secure_linenum=0;
	int dicown_linenum=0;
	int server_linenum=0;
	int usr_linenum=0;
	int passwd_linenum=0;
	int dtype_linenum=0,ostype_linenum=0;
	int change_sqlserv=0;
	int	ucase=0;

	int cflag=0;
	int empty=1;
	char confirm;

	UPG_DBG(("read_write_file: begin\n"));
	for(;;)
	{
#if defined (WIN32)
		if (INTERRUPTED())
		{
			no_change_exit();
			CLEAR_INTERRUPT();
			LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
		}
#endif
		memset (buffer,0, LINE_BUFFER_SIZE);
		if (fgets(buffer, LINE_BUFFER_SIZE, in) == NULL)
		{
			break;
		}
		linenum++;
		UPG_DBG(("%d: %s",linenum,buffer));

		if (buffer[LINE_BUFFER_SIZE - 2] && 
			buffer[LINE_BUFFER_SIZE - 2] != '\n')
		{
            printf(MSG(RIS_E_UPG_LINE_TOO_LONG),linenum);
			no_change_exit();
			LONGJMP(RISupg_LINE_TOO_BIG);
		}

		/*
		**	Added logic to be able to determine the dtype for SYBASE,
		**	since it could be SYBASE System 10 or Microsoft SQL SERVER.
		**	In case of Microsoft SQL SERVER the dtype is changed to 'M'.
		**	This is true only on NT.
		**	RAJU 11/08/94
		*/

		if (!strncmp(buffer,DTYPE,DTYPE_SIZE))
		{
			strcpy(dtype,"");
			dtype_linenum = linenum;
			strcpy(dtype,buffer+DTYPE_SIZE);
			if (strncmp(dtype,"Y",1))
			{
				if (fputs(buffer, out) == EOF)
				{
					printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
			}		
		}
		else if (!strncmp(buffer,DBNAME,DBNAME_SIZE))
		{
			strcpy(dbname_buffer,"");
			strcpy(dbname,buffer+DBNAME_SIZE);
			dbname[strlen(dbname) - 1] = '\0';
			if (strncmp(dtype,"Y",1))
			{
				if (fputs(buffer, out) == EOF)
				{
					printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
			}
			else			
			   strcpy(dbname_buffer,buffer);
		}
		else if (!strncmp(buffer,OSTYPE,OSTYPE_SIZE))
		{
			strcpy(ostype,"");
			ostype_linenum = linenum;
			strncpy(ostype,buffer+OSTYPE_SIZE,1);
			if (!strncmp(dtype,"Y",1))
			{
				if (!strncmp(ostype,"N",1))
				{
					printf(MSG(RIS_I_UPG_UPDATE_TO_MSQLSERV),dbname);
					printf(MSG(RIS_I_UPG_UPDATE_TO_MSQLSERV1));
					printf(MSG(RIS_I_UPG_PROMPT_SYB_OR_MSOFT1));
					printf(MSG(RIS_I_UPG_PROMPT_SYB_OR_MSOFT2));
					confirm = get_answer(
						MSG(RIS_I_UPG_PROMPT_SYB_OR_MSOFT3), 2, sybmsoft, 'Y');
					change_sqlserv = 0;
					if (confirm == 'M')
					{
						strcpy(dtype,"M\n");
						change_sqlserv = 1;
						cflag = 1;
					}
				}
				sprintf(envbuf,"DTYPE=%s",dtype);
				if (fputs(envbuf, out) == EOF) 
				{ 
                	printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break; 
				} 
				if (fputs(dbname_buffer, out) == EOF) 
				{ 
                	printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break; 
				} 
				if (fputs(buffer, out) == EOF) 
				{ 
                	printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break; 
				} 
			}
			else
			{
				if (fputs(buffer, out) == EOF)
				{
					printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
			} /* else */
		}
#if defined (WIN32) || defined (vms)
		else if (!strncmp(buffer,DIR,DIR_SIZE))
#else
		else if (!strncmp(buffer,SCHFILE_DIR,DIR_SIZE))
#endif
		{
			/*
			** Ask for new DBMS location, if only SYBASE
			**
			** SunOS TR fix #439502079 -Surjit-
			*/
			if (!strncmp(dtype,"Y",1))
			{
				strcpy(dir,buffer+DIR_SIZE);
				dir[strlen(dir)-1] = '\0';
				if (change_sqlserv)
				{
					printf(MSG(RIS_I_UPG_NAME_OF_SYB_DIR),dir);
				}
				else
				{
					printf(MSG(RIS_I_UPG_NAME_OF_SYB10_DIR),dir);
				}
				gets(new_syb_dir);
				if (new_syb_dir[0] != '\0')
				{
					sprintf(envbuf,"DIR=%s\n",new_syb_dir);
					if (fputs(envbuf, out) == EOF) 
					{ 
						printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
						break; 
					} 
					continue;
				}
			}
			if (fputs(buffer, out) == EOF) 
			{ 
               	printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break; 
			} 
		}
		else if (!strncmp(buffer, SCHNAME, SCHNAME_SIZE))
		{
			empty = 0;
			schname_linenum = linenum;
			strcpy(schname,buffer+SCHNAME_SIZE);
			ucase = find_dbtype(schname);
			if (fputs(buffer, out) == EOF) 
			{ 
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break; 
			} 
			fflush(out);
		}
		else if (!strncmp(buffer, USR, USR_SIZE))
		{
			usr_linenum = linenum;
			strcpy(usrname,(buffer + USR_SIZE));
			if(ucase)
			{
				char *tmpusr;
				
				tmpusr = usrname;
				while(*tmpusr != '\n' &&
					*tmpusr != '\0') 
				{
					*tmpusr = (char)toupper(*tmpusr);
					tmpusr++;
				}
				UPG_DBG(("read_write_file: Usrname: %s",
							usrname));
			}
			ucase = 0;
			UPG_DBG(("read_write_file: usrname: %s",
					usrname));
			if (usr_linenum == schname_linenum + 1)
			{
                printf(MSG(RIS_I_UPG_ADDING_V5INFO),schname);
				sprintf(envbuf,"%s=%s",V5SCHEMA_INFO,usrname);
				if (fputs(envbuf, out) == EOF)
				{
                    printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
				cflag = 1;
			}
			else if (usr_linenum == secure_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_MISSING_DICTOWNER));
                printf(MSG(RIS_I_UPG_ADDING_DICTOWNER));
				memset(envbuf,0,80);
				sprintf(envbuf,"DICTOWNER=%s",usrname);
				if (fputs(envbuf,out) == EOF)
				{
                    printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
				cflag = 1;
			}
			else if (usr_linenum == server_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_MISSING_DICTOWNER_SECURE));
                printf(MSG(RIS_I_UPG_ADDING_ENTRIES));
				memset(envbuf,0,80);
				sprintf(envbuf,"SECURE=0\nDICTOWNER=%s",usrname);
				if (fputs(envbuf,out) == EOF)
				{
                    printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
				cflag = 1;
			}
			strcpy(envbuf,"SCHOWNER=");
			strcat(envbuf,usrname);
			if (fputs(envbuf, out) == EOF)
			{
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, USRPASS, USRPASS_SIZE))
		{
			passwd_linenum = linenum;
			strcpy(passwd,(buffer + USRPASS_SIZE));
			if (passwd_linenum != usr_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_SCHFILE_CORRUPTED),
                            linenum);
                printf(MSG(RIS_E_UPG_EXIT));
				no_change_exit();
				LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
			}
			strcpy(envbuf,"SCHOWNPASS=");
			strcat(envbuf,passwd);
			if (fputs(envbuf, out) == EOF)
			{
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer,SERVER_VERSION,SERVER_VERSION_SIZE))
		{
			server_linenum = linenum;
			if (server_linenum != schname_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_SCHFILE_CORRUPTED),
                            linenum);
                printf(MSG(RIS_E_UPG_EXIT));
				no_change_exit();
				LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
			}
			if (fputs(buffer, out) == EOF)
			{
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer,SECURE,SECURE_SIZE))
		{
			secure_linenum = linenum;
			if (secure_linenum == schname_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_MISSING_SERVER_VERSION));
                printf(MSG(RIS_I_UPG_ADDING_ENTRY));
				sprintf(envbuf,"SERVER_VERSION=0.0\n");
				if (fputs(envbuf, out) == EOF)
				{
                    printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
				fflush(out);
				cflag = 1;
			}
			if (fputs(buffer, out) == EOF)
			{
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer,DICTOWNER,DICTOWNER_SIZE))
		{
			dicown_linenum = linenum;
			if (dicown_linenum == schname_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_MISSING_SERV_SECURE));
                printf(MSG(RIS_I_UPG_ADDING_ENTRIES));
				memset(envbuf,0,80);
				sprintf(envbuf,"SERVER_VERSION=0.0\nSECURE=0\n");
				if (fputs(envbuf, out) == EOF)
				{
                    printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
				fflush(out);
				cflag = 1;
			}
			else if (dicown_linenum == server_linenum + 1)
			{
                printf(MSG(RIS_E_UPG_MISSING_SECURE));
                printf(MSG(RIS_I_UPG_ADDING_ENTRY));
				memset(envbuf,0,80);
				sprintf(envbuf,"SECURE=0\n");
				if (fputs(envbuf, out) == EOF)
				{
                    printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
					break;
				}
				fflush(out);
				cflag = 1;
			}
			if (fputs(buffer, out) == EOF)
			{
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break;
			}
			fflush(out);
		}
		else
		{
			if (fputs(buffer, out) == EOF)
			{
                printf(MSG(RIS_E_UPGRR_WRITE_TO_FILE), linenum);
				break;
			}
			fflush(out);
		}
	}
	if (empty)
	{
        printf(MSG(RIS_E_UPG_SCHFILE_EMPTY));
	}
	UPG_DBG(("read_write_file: end\n"));
	return cflag;
}

/******************************************************************************/
/*
**	This function checks to see if the schema file had already been upgraded
**  and if the user wants it to be upgraded even if it had been upgraded
**  before.
**	RAJU	04/26/94
*/

static int RISupg_schfile_converted(
	risupg_inf_struct **pass_inf_list,
	int *already_in_inf_file)
{
	risupg_inf_struct *tmp_inf_list=0;
	char	confirm;

	if (risupg_inf_list)
	{
		UPG_DBG(("risupg_inf_list: 0x%x\n",risupg_inf_list));
		tmp_inf_list = risupg_inf_list;
		while(tmp_inf_list)
		{
#if defined (WIN32)
                	if (INTERRUPTED())
                	{
                        	no_change_exit();
                        	CLEAR_INTERRUPT();
                        	LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                	}
#endif
			if(!strncmp(tmp_inf_list->sch_fil_name,file_parms->filename,
				strlen(file_parms->filename)) || 
			!strncmp(tmp_inf_list->new_sch_fil_name,file_parms->filename,
						strlen(file_parms->filename)))
			{
				if ((tmp_inf_list->sch_fil_prot == file_parms->protocol) &&
				    ((tmp_inf_list->sch_fil_prot == 'M') ||
					 (!strncmp(tmp_inf_list->sch_fil_address,
							file_parms->address,strlen(file_parms->address)))))	
				{
			/*
			** This schema file had been upgraded before
			*/
					*already_in_inf_file = 1;
					risupg_cur_file = tmp_inf_list;
					*pass_inf_list = tmp_inf_list;
					UPG_DBG(("risupg_cur_file: 0x%x\n",risupg_cur_file));
      					printf(MSG(RIS_I_UPG_SCHEMA_FILE), file_parms->filename);
					if (file_parms->protocol != 'M')
					{
          					printf(MSG(RIS_I_UPG_REMOTE_NODE), file_parms->address);
					}
					else
					{
          					printf(MSG(RIS_I_UPG_LOCAL_NODE));
					}
                  			printf(MSG(RIS_E_UPG_SCHFILE_UPGRADED));
					confirm = get_answer(
						MSG(RIS_I_UPG_PROMPT_UPGRADE_SCHFILE2), 2, yesno, 'N');
					if (confirm == 'Y')
						return(1);
					if (!strcmp(tmp_inf_list->sch_fil_name,
							file_parms->filename))
					{
						printf(MSG(RIS_I_UPG_LOCATE_CONV_SCHFILE));
						printf(MSG(RIS_I_UPG_UPD_PARMS_FIL_MSG));
						strcpy(file_parms->filename, 
							tmp_inf_list->new_sch_fil_name);
#ifndef OLD
						RIScom_depd(file_parms->password, file_parms->password);
#endif
						RISlocate_schema_file(file_parms);
						if (SQLCODE != RIS_SUCCESS)
						{
							printf(MSG(RIS_E_UPG_CANT_LOCATE_SCHFILE));
							RISupg_report_error(SQLCODE);
							RISterminate();
							LONGJMP(RISupg_CANT_LOCATE_SCHEMA_FILE);
						}
					}
					RESETJMP();
					UPG_DBG(("RISupg_convert_schfile: returning 0\n"));
					return(0);
				}
			}
			tmp_inf_list = tmp_inf_list->next;
		}
		if (!tmp_inf_list)
		{
			/*
			** This schema file had not been upgraded before.
			*/
			tmp_inf_list = risupg_inf_list;
			while (tmp_inf_list->next != NULL)
				tmp_inf_list = tmp_inf_list->next;
			tmp_inf_list->next = (struct RISupg_inf_struct *)
					malloc(sizeof(struct RISupg_inf_struct));
			if (!tmp_inf_list->next)
			{
                		fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
				LONGJMP(RISupg_CANNOT_ALLOCATE_MEMORY);
			}
			tmp_inf_list = tmp_inf_list->next;
			memset((char *)tmp_inf_list,0,sizeof(struct RISupg_inf_struct));
		}
	}
	else
	{
		/*
		** This is the fiorst schema file that is being upgraded.
		*/
		risupg_inf_list = (struct RISupg_inf_struct *)malloc(sizeof(struct RISupg_inf_struct));
		if (!risupg_inf_list)
		{
            		fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
			LONGJMP(RISupg_CANNOT_ALLOCATE_MEMORY);
		}
		tmp_inf_list = risupg_inf_list;
		memset((char *)tmp_inf_list,0,sizeof(struct RISupg_inf_struct));
	}
	*pass_inf_list = tmp_inf_list;
#if defined (WIN32)
        if (INTERRUPTED())
        {
                no_change_exit();
                CLEAR_INTERRUPT();
                LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
        }
#endif
	return(1);	
}

/******************************************************************************/

/*tag0*/
#if !defined (WIN32)
extern int RISupg_convert_schfile()
{
	FILE *in_file;
	FILE *out_file;
	FILE *filep;
	char confirm;
	char *schema_filename;
	char new_schema_filename[RIS_MAX_PATH_SIZE];
	char *net_addr_ptr;
	char buf[RIS_MAX_PATH_SIZE];
	int	status;
	int	cflag;
	int already_in_inf_file = 0;
	risupg_inf_struct *tmp_inf_list=0;
	int conv_before=1; 

	UPG_DBG(("RISupg_convert_schema_file: begin\n"));
	status = SETJMP();
	if (status)
	{
		RESETJMP();
		if (status != RISupg_DONOT_UPGRADE_NOW)
		{
			printf(MSG(RIS_E_UPG_CONVERT_SCHFILE));
			NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
		}
		Free_sch_db_info();
		LONGJMP(status);
	}

	init_signal();
	
	printf("\n\n");
	head();
	
	file_parms = (schema_file_parms *)malloc(sizeof(schema_file_parms));
	RISget_schema_file_location(file_parms);
	if (SQLCODE != RIS_SUCCESS)
	{
        	printf(MSG(RIS_E_UPG_LOCATE_SCHFILE));
		RISterminate();
		LONGJMP(RISupg_CANT_GET_SCHEMA_FILE);
	}
	UPG_DBG(("file_parms->filename: %s\n",file_parms->filename));
	UPG_DBG(("file_parms->protocol: %c\n",file_parms->protocol));
	UPG_DBG(("file_parms->address: %s\n",file_parms->address));
	UPG_DBG(("file_parms->username: %s\n",file_parms->username));

	conv_before = RISupg_schfile_converted(&tmp_inf_list,&already_in_inf_file);
	if (!conv_before)
		return(0);
    	printf(MSG(RIS_I_UPG_SCHEMA_FILE), file_parms->filename);
	if (file_parms->protocol != 'M')
	{
        	printf(MSG(RIS_I_UPG_REMOTE_NODE), file_parms->address);
	}
	else
	{
        	printf(MSG(RIS_I_UPG_LOCAL_NODE));
	}
    	printf(MSG(RIS_I_UPG_SCHFILE_MSG1));
	printf(MSG(RIS_I_UPG_SCHFILE_MSG2));
	confirm = get_answer(MSG(RIS_I_UPG_PROMPT_UPGRADE_SCHFILE),2, yesno, 'Y');
	
	printf("================================================================================\n");

	if (confirm == 'N')
	{
		no_change_exit();
		LONGJMP(RISupg_DONOT_UPGRADE_NOW);
	}

	printf(MSG(RIS_I_UPG_RUNNING_GET_SCHFILE));
	RISint_process_debug("+upgrade");
	RISget_schema_file(&schema_filename, 0, 0, 0);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_CANT_GET_SCHEMA_FILE));
		LONGJMP(RISupg_CANT_GET_SCHEMA_FILE);
	}
	printf(MSG(RIS_I_UPG_MACHINE));
	if (file_parms->protocol != 'M')
	{
		printf("   <%s>\n", file_parms->address);
	}
	else
	{
		printf(MSG(RIS_I_UPG_MACHINE_LOCAL));
	}
	printf(MSG(RIS_I_UPG_SCHFILE_NAME), schema_filename);

	strcpy(RIS_file, schema_filename);
	strcpy(RIS_lock_file, schema_filename);
	strcat(RIS_lock_file, ".LCK");
	strcpy(RIS_id_file, schema_filename);
	strcat(RIS_id_file, ".ID");
	strcpy(new_schema_filename,schema_filename);
	strcat(new_schema_filename,"v5");
	net_addr_ptr = "";
	init_net_parms_addr(file_parms, &net_addr_ptr);
	/*
	**	lock schema file
	*/
	if (NET_get_lock_file(&RIS_file_net,&RIS_file_connect, RIS_lock_file))
	{
		printf(MSG(RIS_E_UPG_TRY_LATER1));
		printf(MSG(RIS_E_UPG_TRY_LATER2));
		LONGJMP(RISupg_MISSING_LOCK_FILE);
	}

	tmpnam(tmp_name);
	tmpnam(tmp_id_name);
	tmpnam(filename);
	UPG_DBG(("RISupg_convert_schema_file: %s %s %s\n",tmp_name,
			tmp_id_name,filename));
	
	/*
	** write schema id file
	*/
	if ((filep = fopen(tmp_id_name, "w")) == NULL)
	{
		printf("\n");
		fprintf(stderr,MSG(RIS_E_UPG_CANT_OPEN_TMPID),
			"risupgrd", tmp_id_name);
		no_change_exit();
		LONGJMP(RISupg_CANT_OPEN_TMPID);
	}
	RIScom_chmod(tmp_id_name,0666);
	
	sprintf(id_name, "%s:%d", net_addr_ptr, getpid());

	if (fputs(id_name, filep) < 0)
	{
		fclose(filep);
		printf(MSG(RIS_E_UPG_CANT_WRITE_TO_TMPID));
		no_change_exit();
		LONGJMP(RISupg_CANT_WRITE_TO_TMPID);
	}

	fclose(filep);

	if (NET_put_file(&RIS_file_net, &RIS_file_connect, 
		tmp_id_name, RIS_id_file))
	{
		printf(MSG(RIS_E_UPG_CANT_WRITE_SCHEMAID_FILE));
		no_change_exit();
		LONGJMP(RISupg_CANT_WRITE_SCHEMAID_FILE);
	}

	/*
	**	make a copy of the schema file
	*/
	if (NET_get_file(&RIS_file_net, &RIS_file_connect,
		RIS_file, filename))
	{
		printf(MSG(RIS_E_UPG_CANT_GET_SCHEMA_FILE1));
		no_change_exit();
		LONGJMP(RISupg_CANT_GET_SCHEMA_FILE);
	}

	if ((in_file = fopen(filename,"r")) == NULL)
	{
		printf("\n");
		fprintf(stderr,MSG(RIS_E_UPG_CANT_OPEN_SCHEMAFILE),
			"risupgrd", filename);
		printf(MSG(RIS_I_UPG_CHECKLOC_SCHFILE));
		no_change_exit();
		LONGJMP(RISupg_CANT_OPEN_SCHEMAFILE);
	}
	RIScom_chmod(filename,0666);
	if ((out_file = fopen(tmp_name, "w")) == NULL)
	{
		printf("\n");
		fprintf(stderr,MSG(RIS_E_UPG_CANT_OPEN_TMPFILE),
			"risupgrd", tmp_name);
	}
	RIScom_chmod(tmp_name,0666);

	printf("\n================================================================================\n");
	
	build_schema_db_info(in_file);
	map_schema_to_dbtype();
	rewind(in_file);
	cflag = read_write_file(in_file, out_file);
	Free_sch_db_info();
	if (!cflag)
	{
		printf(MSG(RIS_I_UPG_SCHFILE_UPGRADED));
		NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
		unlink(tmp_name);
		unlink(tmp_id_name);
		unlink(filename);
		strcpy(tmp_inf_list->sch_fil_name,schema_filename);
		strcpy(tmp_inf_list->new_sch_fil_name,schema_filename);
		tmp_inf_list->sch_fil_prot = file_parms->protocol;
		strcpy(tmp_inf_list->sch_fil_address,file_parms->address);
		if (!already_in_inf_file)
		{
			tmp_inf_list->sch_list = 0;
			tmp_inf_list->next = 0;
		}
		risupg_cur_file = tmp_inf_list;
		RESETJMP();
		UPG_DBG(("schema file name : <%s>\n",
			tmp_inf_list->sch_fil_name));
		UPG_DBG(("New schema file name : <%s>\n",
			tmp_inf_list->new_sch_fil_name));
		UPG_DBG(("schema file protocol : <%c>\n",
			tmp_inf_list->sch_fil_prot));
		UPG_DBG(("schema file address : <%s>\n",
			tmp_inf_list->sch_fil_address));
		UPG_DBG(("RISupg_convert_schfile: returning 0 cflag <%d>\n",cflag));
		return(0);
	}
	else
	{
		char	*nopath;
		char	def_new_sch_file_name[RIS_MAX_PATH_SIZE];

		nopath = strrchr(new_schema_filename,'/');
		if ((nopath) && strlen(nopath) > 10)
		{
			nopath[10] = '\0';
			if (!strncmp(schema_filename,new_schema_filename,
							sizeof(new_schema_filename)))
				nopath[9] = '5';
		}
		printf(MSG(RIS_I_UPG_SCHFILE_COPIED_TO), new_schema_filename);
		strcpy(def_new_sch_file_name,new_schema_filename);
		printf(MSG(RIS_I_UPG_CHANGE_SCHFILE_NAME));
		while (1)
		{

			printf(MSG(RIS_I_UPG_NAME_OF_SCHFILE),
				def_new_sch_file_name);
			if (gets(buf)) 
			{
				if (buf[0] == '\0') /*nothing entered */
				{
					strcpy(new_schema_filename,def_new_sch_file_name);
				}
				else if ((nopath = strrchr(buf,'/')) == NULL) /*filename with no path*/
				{
					printf(MSG(RIS_I_UPG_EXTRACT_SCHEMA_MSG3));
					/* subtract two for the slash and at least one char in filename */
					if (getcwd(new_schema_filename,RIS_MAX_PATH_SIZE - 2) == NULL)
					{
						printf(MSG(RIS_E_UPG_CANT_ACCESS_DIR));
						continue;
					}
					strcat(new_schema_filename,"/");
					strncat(new_schema_filename,buf,RIS_MAX_PATH_SIZE - strlen(new_schema_filename));
				}
				else /*full filename with path */
				{
					strcpy(new_schema_filename,buf);
				}

				nopath = strrchr(new_schema_filename,'/');

				if ((nopath) && strlen(nopath) > 10)
				{
					printf(MSG(RIS_E_UPG_SCHEMAFILE_NAME_SIZE));
					printf(MSG(RIS_I_UPG_TRY_AGAIN_MSG));
					continue;
				}		
				else
					break;
			}
		}
		
		printf(MSG(RIS_I_UPG_CHANGED_SCHFILE),
   				new_schema_filename);
	}
	read_id_file(id, ID_BUFFER_SIZE);
	if (strcmp(id, id_name))
	{
		printf(MSG(RIS_I_UPG_TRY_LATER_MSG1));
		printf(MSG(RIS_I_UPG_TRY_LATER_MSG2));
		printf(MSG(RIS_I_UPG_TRY_LATER_MSG3));
		no_change_exit();
		LONGJMP(RISupg_TRY_LATER);
	}
	strcpy(file_parms->filename, new_schema_filename);
#ifndef OLD
	RIScom_depd(file_parms->password, file_parms->password);
#endif
	RISlocate_schema_file(file_parms);
	if (SQLCODE != RIS_SUCCESS)
	{
		NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
		printf(MSG(RIS_E_UPG_CANT_LOCATE_SCHFILE));
		RISupg_report_error(SQLCODE);
		RISterminate();
		LONGJMP(SQLCODE);
	}
	NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
	strcpy(RIS_file,new_schema_filename);
	strcpy(RIS_lock_file,new_schema_filename);
	strcat(RIS_lock_file,".LCK");

	if (NET_put_file(&RIS_file_net, &RIS_file_connect, tmp_name,
	   	RIS_file))
	{
		printf(MSG(RIS_E_UPG_CANT_WRITE_SCHEMAFILE));
		no_change_exit();
		LONGJMP(RISupg_CANT_WRITE_SCHEMAFILE);
	}
	NET_remove_file(&RIS_file_net,&RIS_file_connect, RIS_id_file);
	NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
	unlink(filename);
	printf(MSG(RIS_I_UPG_CHECKSUM_SCHFILE));
	RISrestore_schema_file_checksum();
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_SCHEMAFILE_CORRUPTED1));
		no_change_exit();
		LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
	}
	unlink(tmp_name);
	unlink(tmp_id_name);
	unlink(filename);
	printf("\n");
	strcpy(tmp_inf_list->sch_fil_name,schema_filename);
	strcpy(tmp_inf_list->new_sch_fil_name,new_schema_filename);
	tmp_inf_list->sch_fil_prot = file_parms->protocol;
	strcpy(tmp_inf_list->sch_fil_address,file_parms->address);
	if (!already_in_inf_file)
	{
		tmp_inf_list->sch_list = 0;
		tmp_inf_list->next = 0;
	}
	risupg_cur_file = tmp_inf_list;
	UPG_DBG(("schema file name : <%s>\n",tmp_inf_list->sch_fil_name));
	UPG_DBG(("New schema file name : <%s>\n",tmp_inf_list->new_sch_fil_name));
	UPG_DBG(("schema file protocol : <%c>\n",tmp_inf_list->sch_fil_prot));
	UPG_DBG(("schema file address : <%s>\n",tmp_inf_list->sch_fil_address));
	printf(MSG(RIS_I_UPG_CONV_SCHFILE_COMPLETE));
	RESETJMP();
	return(0);
}
#endif

/******************************************************************************/
extern int RISupg_put_file(
	char	*from_file,
	char	*to_file)
{
	FILE 	*from;
	FILE	*to;
	char	buf[80];

	from = fopen(from_file,"r");
	if (!from)
	{
		printf(MSG(RIS_E_UPG_OPEN_FILE));
		UPG_DBG(("ERROR reading %s\n",from_file));
		return 1;
	}
	to = fopen(to_file,"w");
	if (!to)
	{
		printf(MSG(RIS_E_UPG_OPEN_WRITE));
		UPG_DBG(("ERROR writing to %s\n",to_file));
		return 1;
	}
	while (RIScom_fgets(buf,80,from) != NULL)
		fprintf(to,"%s",buf);	
	fclose(from);
	fclose(to);
	return 0;
}
/******************************************************************************/
#if defined (WIN32)
static int RISupg_put_lock_file(
	char	*lock_file)
{
	FILE *tfp;

	if ((tfp = fopen(lock_file,"w+")) == NULL)
	{
		UPG_DBG(("RISupg_put_lock_file : error opening %s file\n",lock_file));
		return 1;
	}
	fclose(tfp);
	return 0;
}
#endif
/******************************************************************************/
/*tag1*/
#if defined (WIN32)
extern int RISupg_convert_schfile()
{
	FILE *in_file;
	FILE *out_file;
	FILE *filep;
	char confirm;
	char *schema_filename;
	char new_schema_filename[RIS_MAX_PATH_SIZE];
	char *net_addr_ptr;
	char buf[RIS_MAX_PATH_SIZE];
	int	status;
	int	cflag;
	int already_in_inf_file = 0;
	risupg_inf_struct *tmp_inf_list=0;
	int conv_before=1; 
	client_parms	cli_parms;

	UPG_DBG(("RISupg_convert_schema_file: begin\n"));
	status = SETJMP();
	if (status)
	{
		RESETJMP();
		if (status != RISupg_DONOT_UPGRADE_NOW)
		{
			printf(MSG(RIS_E_UPG_CONVERT_SCHFILE));
			RISupg_put_lock_file(lock_file_name);
		}
		Free_sch_db_info();
		LONGJMP(status);
	}

	
	init_signal();
	printf("\n\n");
	head();
	
	/*
	** Check if the client is local. If not local error out.
	** Check if the schema file is local. If not local error out.
	** Added code to check if the client is local on NT. 
	** This fixes TR# 24940360.
	*/
	RISget_client_location(&cli_parms);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_GET_CLIENT_LOC));
		RISterminate();
		LONGJMP(RISupg_CANT_GET_CLIENT_LOC);
	}
        if (cli_parms.protocol != 'M')
    	{
        	printf(MSG(RIS_I_UPG_CLIENT_MUST_BE_LOCAL));
        	return(1);
    	}
	file_parms = (schema_file_parms *)malloc(sizeof(schema_file_parms));
	RISget_schema_file_location(file_parms);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_LOCATE_SCHFILE));
		RISterminate();
		LONGJMP(RISupg_CANT_GET_SCHEMA_FILE);
	}
	UPG_DBG(("file_parms->filename: %s\n",file_parms->filename));
	UPG_DBG(("file_parms->protocol: %c\n",file_parms->protocol));
	UPG_DBG(("file_parms->address: %s\n",file_parms->address));
	UPG_DBG(("file_parms->username: %s\n",file_parms->username));
/*
**	The following if statement is added to check to see if the schema file
**	is local, if it is error out. This should have been in place before.
**	Looks like an oversight. This fixes TR# 249403660
**	RAJU	06/30/94
*/
        if (file_parms->protocol != 'M')
    	{
        	printf(MSG(RIS_I_UPG_SCHFILE_MUST_BE_LOCAL));
        	return(1);
    	}
        if (INTERRUPTED())
        {
                no_change_exit();
                CLEAR_INTERRUPT();
                LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
        }
	conv_before = RISupg_schfile_converted(&tmp_inf_list,&already_in_inf_file);
	if (!conv_before)
		return(0);
	printf(MSG(RIS_I_UPG_SCHEMA_FILE), file_parms->filename);
	if (file_parms->protocol != 'M')
	{
		printf(MSG(RIS_I_UPG_REMOTE_NODE), file_parms->address);
	}
	else
	{
		printf(MSG(RIS_I_UPG_LOCAL_NODE));
	}
	printf(MSG(RIS_I_UPG_SCHFILE_MSG1));
	printf(MSG(RIS_I_UPG_SCHFILE_MSG2));
	confirm = get_answer(MSG(RIS_I_UPG_PROMPT_UPGRADE_SCHFILE),2, yesno, 'Y');
	
	printf(
	"================================================================================\n");

	if (confirm == 'N')
	{
		no_change_exit();
		LONGJMP(RISupg_DONOT_UPGRADE_NOW);
	}

	printf(MSG(RIS_I_UPG_RUNNING_GET_SCHFILE));
	RISint_process_debug("+upgrade");
	RISget_schema_file(&schema_filename, 0, 0, 0);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_CANT_GET_SCHEMA_FILE));
		LONGJMP(RISupg_CANT_GET_SCHEMA_FILE);
	}
	printf(MSG(RIS_I_UPG_MACHINE));
	if (file_parms->protocol != 'M')
	{
		printf("   <%s>\n", file_parms->address);
	}
	else
	{
		printf(MSG(RIS_I_UPG_MACHINE_LOCAL));
	}
	printf(MSG(RIS_I_UPG_SCHFILE_NAME), schema_filename);

	strcpy(sch_file_name, schema_filename);
	strcpy(lock_file_name, schema_filename);
	strcat(lock_file_name, ".LCK");
	strcpy(id_file_name, schema_filename);
	strcat(id_file_name, ".ID");
	strcpy(new_schema_filename,schema_filename);
	strcat(new_schema_filename,"v5");
	net_addr_ptr = "";
	/*
	**	lock schema file
	*/
	if (_unlink(lock_file_name))
	{
		printf(MSG(RIS_E_UPG_TRY_LATER1));
        printf(MSG(RIS_E_UPG_TRY_LATER2));
		LONGJMP(RISupg_MISSING_LOCK_FILE);
	}

	tmpnam(tmp_name);
	tmpnam(tmp_id_name);
	tmpnam(filename);
	UPG_DBG(("RISupg_convert_schema_file: %s %s %s\n",tmp_name,
			tmp_id_name,filename));
	
	/*
	** write schema id file
	*/
	if ((filep = fopen(tmp_id_name, "w")) == NULL)
	{
		printf("\n");
		fprintf(stderr,MSG(RIS_E_UPG_CANT_OPEN_TMPID),
			"risupgrd", tmp_id_name);
		no_change_exit();
		LONGJMP(RISupg_CANT_OPEN_TMPID);
	}
	
	sprintf(id_name, "%s:%d", net_addr_ptr, _getpid());

	if (fputs(id_name, filep) < 0)
	{
		fclose(filep);
		printf(MSG(RIS_E_UPG_CANT_WRITE_TO_TMPID));
		no_change_exit();
		LONGJMP(RISupg_CANT_WRITE_TO_TMPID);
	}

	fclose(filep);

	if (RISupg_put_file(tmp_id_name, id_file_name))
	{
		printf(MSG(RIS_E_UPG_CANT_WRITE_SCHEMAID_FILE));
		no_change_exit();
		LONGJMP(RISupg_CANT_WRITE_SCHEMAID_FILE);
	}

	/*
	**	make a copy of the schema file
	*/
	if (RISupg_put_file(sch_file_name, filename))
	{
		printf(MSG(RIS_E_UPG_CANT_GET_SCHEMA_FILE1));
		no_change_exit();
		LONGJMP(RISupg_CANT_GET_SCHEMA_FILE);
	}

	if ((in_file = fopen(filename,"r")) == NULL)
	{
		printf("\n");
		fprintf(stderr,MSG(RIS_E_UPG_CANT_OPEN_SCHEMAFILE),
            "risupgrd", filename);
		printf(MSG(RIS_I_UPG_CHECKLOC_SCHFILE));
		no_change_exit();
		LONGJMP(RISupg_CANT_OPEN_SCHEMAFILE);
	}
	if ((out_file = fopen(tmp_name, "w")) == NULL)
	{
		printf("\n");
		fprintf(stderr,MSG(RIS_E_UPG_CANT_OPEN_TMPFILE),
            "risupgrd", tmp_name);
	}

	printf("\n================================================================================\n");
	
	build_schema_db_info(in_file);
	map_schema_to_dbtype();
	rewind(in_file);
	cflag = read_write_file(in_file, out_file);
	fclose(in_file);
	fclose(out_file);
	Free_sch_db_info();
	if (!cflag)
	{
			printf(MSG(RIS_I_UPG_SCHFILE_UPGRADED));
			RISupg_put_lock_file(lock_file_name);
			_unlink(tmp_name);
			_unlink(tmp_id_name);
			_unlink(filename);
			strcpy(tmp_inf_list->sch_fil_name,schema_filename);
			strcpy(tmp_inf_list->new_sch_fil_name,schema_filename);
			tmp_inf_list->sch_fil_prot = file_parms->protocol;
			strcpy(tmp_inf_list->sch_fil_address,file_parms->address);
			if (!already_in_inf_file)
			{
				tmp_inf_list->sch_list = 0;
				tmp_inf_list->next = 0;
			}
			risupg_cur_file = tmp_inf_list;
			RESETJMP();
			UPG_DBG(("schema file name : <%s>\n",tmp_inf_list->sch_fil_name));
			UPG_DBG(("New schema file name : <%s>\n",
						tmp_inf_list->new_sch_fil_name));
			UPG_DBG(("schema file protocol : <%c>\n",
						tmp_inf_list->sch_fil_prot));
			UPG_DBG(("schema file address : <%s>\n",
						tmp_inf_list->sch_fil_address));
			UPG_DBG(("RISupg_convert_schfile: returning 0 cflag <%d>\n",cflag));
			return(0);
	}
	else
	{
		char *nopath;
		char	def_new_sch_file_name[RIS_MAX_PATH_SIZE];

		nopath = strrchr(new_schema_filename,'\\');
		if ((nopath) && strlen(nopath) > 8)
		{
			nopath[8] = '\0';
			if (!strncmp(schema_filename,new_schema_filename,
							sizeof(new_schema_filename)))
				nopath[7] = '5';
		}
		printf(MSG(RIS_I_UPG_SCHFILE_COPIED_TO), new_schema_filename);
		strcpy(def_new_sch_file_name,new_schema_filename);
		printf(MSG(RIS_I_UPG_CHANGE_SCHFILE_NAME));
		while (1)
		{

			printf(MSG(RIS_I_UPG_NAME_OF_SCHFILE),
				def_new_sch_file_name);
                	if (INTERRUPTED())
                	{
                        	no_change_exit();
                        	CLEAR_INTERRUPT();
                        	LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                	}
			if (gets(buf)) 
			{
				if (buf[0] == '\0') /*nothing entered */
				{
					strcpy(new_schema_filename,def_new_sch_file_name);
				}
				else if ((nopath = strrchr(buf,'\\')) == NULL) /*filename with no path*/
				{
					printf(MSG(RIS_I_UPG_EXTRACT_SCHEMA_MSG3));
					/* subtract two for the slash and at least one char in filename */
					if (_getcwd(new_schema_filename,RIS_MAX_PATH_SIZE - 2) == NULL)
					{
						printf(MSG(RIS_E_UPG_CANT_ACCESS_DIR));
						continue;
					}
					strcat(new_schema_filename,"\\");
					strncat(new_schema_filename,buf,RIS_MAX_PATH_SIZE - strlen(new_schema_filename));
				}
				else /*full filename with path */
				{
					strcpy(new_schema_filename,buf);
				}

				nopath = strrchr(new_schema_filename,'\\');

				if ((nopath) && strlen(nopath) > 8)
				{
					printf(MSG(RIS_E_UPG_SCHEMAFILE_NAME_SIZE_NT));
					printf(MSG(RIS_I_UPG_TRY_AGAIN_MSG));
					continue;
				}		
				else
					break;
			}
		}
		
		printf(MSG(RIS_I_UPG_CHANGED_SCHFILE),
   				new_schema_filename);
	}
	read_id_file(id, ID_BUFFER_SIZE);
	if (strcmp(id, id_name))
	{
		printf(MSG(RIS_I_UPG_TRY_LATER_MSG1));
        printf(MSG(RIS_I_UPG_TRY_LATER_MSG2));
        printf(MSG(RIS_I_UPG_TRY_LATER_MSG3));
		no_change_exit();
		LONGJMP(RISupg_TRY_LATER);
	}
	strcpy(file_parms->filename, new_schema_filename);
#ifndef OLD
	RIScom_depd(file_parms->password, file_parms->password);
#endif
	RISlocate_schema_file(file_parms);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_CANT_LOCATE_SCHFILE));
		RISupg_put_lock_file(lock_file_name);
		RISupg_report_error(SQLCODE);
		RISterminate();
		LONGJMP(SQLCODE);
	}
	RISupg_put_lock_file(lock_file_name);
	strcpy(sch_file_name,new_schema_filename);
	strcpy(lock_file_name,new_schema_filename);
	strcat(lock_file_name,".LCK");

	if (RISupg_put_file(tmp_name,sch_file_name))
	{
		printf(MSG(RIS_E_UPG_CANT_WRITE_SCHEMAFILE));
		no_change_exit();
		LONGJMP(RISupg_CANT_WRITE_SCHEMAFILE);
	}
	_unlink(id_file_name);
	RISupg_put_lock_file(lock_file_name);
	_unlink(filename);
	printf(MSG(RIS_I_UPG_CHECKSUM_SCHFILE));
	RISrestore_schema_file_checksum();
	if (SQLCODE != RIS_SUCCESS)
	{
		printf(MSG(RIS_E_UPG_SCHEMAFILE_CORRUPTED1));
		no_change_exit();
		LONGJMP(RISupg_SCHEMAFILE_CORRUPTED);
	}
	_unlink(tmp_name);
	_unlink(tmp_id_name);
	_unlink(filename);
	printf("\n");
	strcpy(tmp_inf_list->sch_fil_name,schema_filename);
	strcpy(tmp_inf_list->new_sch_fil_name,new_schema_filename);
	tmp_inf_list->sch_fil_prot = file_parms->protocol;
	strcpy(tmp_inf_list->sch_fil_address,file_parms->address);
	if (!already_in_inf_file)
	{
		tmp_inf_list->sch_list = 0;
		tmp_inf_list->next = 0;
	}
	risupg_cur_file = tmp_inf_list;
	UPG_DBG(("schema file name : <%s>\n",tmp_inf_list->sch_fil_name));
	UPG_DBG(("New schema file name : <%s>\n",tmp_inf_list->new_sch_fil_name));
	UPG_DBG(("schema file protocol : <%c>\n",tmp_inf_list->sch_fil_prot));
	UPG_DBG(("schema file address : <%s>\n",tmp_inf_list->sch_fil_address));
	printf(MSG(RIS_I_UPG_CONV_SCHFILE_COMPLETE));
	RESETJMP();
	return(0);
}
#endif
