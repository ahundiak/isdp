/*
** Copyright 1993, Intergraph Corporation, All Rights Reserved
*/

/*
**	===============================================================
**
**	File		: asynctrn.rc
**	Purpose		: Asynchronous Execution of multiple transactions 
**
**	===============================================================
*/

#include <stdio.h>
#include <string.h>
#include "ris.prt"

/*
**	Host variable declarations -- this is global
*/
exec sql begin declare section;
 	int		async1, async2;
exec sql end declare section;

extern int my_error_handler();
extern void display_tools();
extern void display_entries();

extern void main()
{
	/*
	** 	Set the autocommit off so that transactions are not committing until
	**	and explicit commit statement is executed
	*/
	exec sql set transaction autocommit off;

    /*
	**	Default to schema sch1 (static SQL with no parameters)
	*/
	printf("Default to schema sch1\n");
    exec sql default schema sch1;
	if( my_error_handler(SQLCODE) != RIS_SUCCESS )
	{
		return;
	}

    /*
	**	Asynchonously, insert a row into the table tools (static SQL with no 
	**	parameters)
	*/
	printf("Insert one more row into table tools\n");
    exec sql async :async1 insert into tools values('blue steel', 300, 202.95);
	if( my_error_handler(SQLCODE) != RIS_SUCCESS )
	{
		return;
	}

	/*
	**	Default to schema sch2 (static SQL with no parameters)
	*/
	printf("Default to schema sch2\n");
    exec sql default schema sch2;
	if( my_error_handler(SQLCODE) != RIS_SUCCESS )
	{
		return;
	}

    /*
	**	Asynchonously, insert a row into the table entries (static SQL
	**	with no parameters)
	*/
	printf("Insert one more row into table entries\n");
    exec sql async :async2 
		insert into entries values('blue steel', current_timestamp);
	if( my_error_handler(SQLCODE) != RIS_SUCCESS )
	{
		return;
	}

	/*
	**	Execute some user code here
	*/
	printf(" ** Execute some user code here ** \n");

	/*
	**	Wait till the previous started asynchronous statements are complete
	*/
	printf("Wait completion on async1 and async2\n");
	exec sql wait :async1, :async2 completion;
	if( my_error_handler(SQLCODE) != RIS_SUCCESS )
	{
		return;
	}

	/*
	** If successfully completed, commit the transactions
	*/
	printf("Commit transaction for schema sch1\n");
	exec sql commit for sch1;
	printf("Commit transaction for schema sch2\n");
	exec sql commit for sch2;

	/*
	** Set transaction to autocommit on (static SQL without parameters)
	*/
	exec sql set transaction autocommit on;

	/*
	**  select tools table
	*/
	display_tools();

	/*
	**  select entries table
	*/
	display_entries();
}

extern int my_error_handler(
	int status)
{
	/*
	**	Host variable declarations
	*/
    exec sql begin declare section;
		char	*error_ptr;
    exec sql end declare section;

	switch( status )
	{
		case RIS_SUCCESS:
		case END_OF_DATA:
		case STATEMENT_NOT_COMPLETE:
		return(status);
		case STATEMENT_FAILED:
			/*
			** For asynchronous errors
			*/
			exec sql report error for async :async1 into :error_ptr;
			puts(error_ptr);
			exec sql report error for async :async2 into :error_ptr;
			puts(error_ptr);

			/*
			** rollback the transactions
			*/
			printf("Rollback transaction for schema sch1\n");
			exec sql rollback for sch1;
			printf("Rollback transaction for schema sch2\n");
			exec sql rollback for sch2;
		return(status);
		default:
			/*
			** For any other types of errors
			*/
			exec sql report error into :error_ptr;
			puts(error_ptr);
		return(status);
	}
}

extern void display_tools()
{
	/*
	**	Host variable declarations
	*/
    exec sql begin declare section;
        char	name[21];
        int		amount;
        long	amount_ind;
		char	value[10];
        char	*error_ptr;
    exec sql end declare section;

	/*
	**	Define exception handlers
	**	i.e., if SQL error detected goto label error
	**		  if no more rows detected goto lable not_found
	*/
    exec sql whenever sqlerror goto :error;
    exec sql whenever not found goto :not_found;

	/*
	**  Default to schema sch1
	*/
	exec sql default schema sch1;

    /*
	**	Select multiple rows from the table using cursors
	*/

	/*
	** Declare a cursor for select statement (static SQL with parameters)
	*/
	printf("Declare cursor for select from table tools\n");
    exec sql declare c1 cursor for select * from tools;

	/*
	**	Open cursor c1 using parameter
	*/
	printf("Open cursor for select from table tools\n");
    exec sql open c1;

    for (;;)
    {
        exec sql fetch c1 into :name, :amount:amount_ind, :value;
    	printf("name: %s amount: %d value: %s\n", 
				name, amount_ind ? -1 : amount, value);
    }

not_found:
	/*
	** This part of code is executed when no more data is found
	*/
    exec sql whenever not found continue;
    printf("No more data\n");

	/*
	** Close the cursor c1
	*/
    printf("Close cursor c1\n");
	exec sql close c1;

    return;

error:
	/*
	** This part of code is executed when error is detected
	*/

	/*
	** Ignore SQL error from onwards and continue processing
	*/
    exec sql whenever sqlerror continue;

	/*
	** Retreive the message string resulting form the last SQL error
	*/
    exec sql report error into :error_ptr;
    puts(error_ptr);

    return;
}

extern void display_entries()
{
	/*
	**	Host variable declarations
	*/
	char	buffer[50];
	char	*format = "Day, Month d yyyy hh:nn:ss AM";
    exec sql begin declare section;
        char	name[21];
		struct datetime	status_time;
        char	*error_ptr;
    exec sql end declare section;

	/*
	**	Define exception handlers
	**	i.e., if SQL error detected goto label error
	**		  if no more rows detected goto lable not_found
	*/
    exec sql whenever sqlerror goto :error;
    exec sql whenever not found goto :not_found;

	/*
	**  Default to schema sch2
	*/
	exec sql default schema sch2;

    /*
	**	Select multiple rows from the table using cursors
	*/

	/*
	** Declare a cursor for select statement (static SQL with parameters)
	*/
	printf("Declare cursor for select from table entries\n");
    exec sql declare c2 cursor for select * from entries;

	/*
	**	Open cursor c2 using parameter
	*/
	printf("Open cursor for select from table entries\n");
    exec sql open c2;

    for (;;)
    {
        exec sql fetch c2 into :name, :status_time;
		RISdatetime_to_ascii(&status_time,buffer,format);
    	printf("name: %s status_time: %s \n", name, buffer);
    }

not_found:
	/*
	** This part of code is executed when no more data is found
	*/
    exec sql whenever not found continue;
    printf("No more data\n");

	/*
	** Close the cursor c2
	*/
	exec sql close c2;

    return;

error:
	/*
	** This part of code is executed when error is detected
	*/

	/*
	** Ignore SQL error from onwards and continue processing
	*/
    exec sql whenever sqlerror continue;

	/*
	** Retreive the message string resulting form the last SQL error
	*/
    exec sql report error into :error_ptr;
    puts(error_ptr);

    return;
}
