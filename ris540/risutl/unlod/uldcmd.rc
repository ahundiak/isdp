/* Do not alter this SPC information: $Revision: 1.2.9.1 $ */
/*
**	NAME:							uldcmd.rc
**	AUTHORS:						Jennifer Xia
**	CREATION DATE:					July 25, 1990
**	ABSTRACT:
**		It contains three functions which parses a command line
**		in three levels.
**	
**	REVISION HISTORY:August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#include <ctype.h>
#ifdef MM
#include "unlod.h"
#endif
#include "comisfn.prt"

exec sql include "unlod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define uldcmd_rc
#include "sys.prt"
#include "comdebug.prt"
#include "comjmp.prt"
#include "comumsg.prt"
#include "uldermsg.prt"
#include "uldgtspc.prt"
#include "uldmisc.prt"
#include "uldcmd.prt"
#include "uldstspc.prt"
#include "uldtime.prt"
#include "uldwhere.prt"


/* 
**	Level 3 parser ==> individual table, index, view and grant names 
**	or all for each of them 
*/

static int RISuld_parse_ind_rel(
	int					name_type,
	int					argc,
	char				*argv[],
	FILE				*spec_fp,
	char				*token_buf,
	short int			tblname_fetched_lvl2)
{

	int 	usr_pre_spec = FALSE;
	int 	spec_type3;
	int		spec_type4 = 0;			/* for where_clause */
	char	original_gtor[RIS_MAX_ID_SIZE];
	char	rel_name[RIS_MAX_ID_SIZE];
	char	table_name[RIS_MAX_ID_SIZE];
    char	*where_clause_ptr;		/* pointer to where_clause */

	ULD_DBG(("RISuld_parse_ind_rel: name_type <%d> \n",
						name_type));
	ULD_DBG(("\targc %d argv 0x%x spec_fp 0x%x token_buf 0x%x\n", 
						argc, argv, spec_fp, token_buf));

	for(;;)
	{
		if( tblname_fetched_lvl2 )	/* table name was already fetched
									   at level 2 parser */
		{  
			spec_type3 = RELATION_NAME;
			tblname_fetched_lvl2 = FALSE;
		}
		else
		{
			if( usr_pre_spec )
			{
				spec_type3 = spec_type4;
				usr_pre_spec = FALSE;
			}
			else
				spec_type3 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
		}
	
		switch(spec_type3)
		{
			case RELATION_NAME:
				switch (name_type)
				{
					case TABLE:
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISUNLOAD
						}
						
						strcpy(table_name,token_buf);
						spec_type4 = RISuld_fetch_analyze_spec(argc,argv,spec_fp,token_buf);
						if( (spec_type4 == JOIN) || (spec_type4 == WHERE) )
						{
							where_clause_ptr = (char *) RISuld_get_where_clause(argc,argv,spec_fp,token_buf,spec_type4);
 							RISuld_create_btnode(table_name,where_clause_ptr);
						} 
						else
						{
							usr_pre_spec = TRUE;
							RISuld_create_btnode(table_name,(char *) NULL);
						}
						break;
					case INDEX:
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISUNLOAD
						}
						RISuld_create_binode(token_buf,(char *)NULL);
						break;
					case VIEW:
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISUNLOAD
						}
	
						RISuld_create_bvnode(token_buf);
						break;
					case GRANT:
						if (RISuld_separate_gtor_rel(token_buf, original_gtor, rel_name) == FAILURE)
						{
							TERMINATE_RISUNLOAD
						}
					
						if (original_gtor[0] == '\0')
							strcpy(original_gtor, RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sch_name);
	
						RISuld_create_bgnode(original_gtor, rel_name);
						break;
				}
				break;
			case EVERY_THING:
				switch (name_type)
				{
					case TABLE:
						RISuld_ptr_struct_ptr->bthnode_ptr->tab_select = ALL;
						break;
					case INDEX:
						RISuld_ptr_struct_ptr->bihnode_ptr->indx_select = ALL;
						break;
					case VIEW:
						RISuld_ptr_struct_ptr->bvhnode_ptr->view_select = ALL;
						break;
					case GRANT:
						RISuld_ptr_struct_ptr->bghnode_ptr->grant_select = ALL;
						break;
				}
				spec_type3 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
			
				ULD_DBG(("1. RISuld_parse_ind_rel: end\n"));
				return(spec_type3);
			default:
				ULD_DBG(("2. RISuld_parse_ind_rel: end\n"));
				return(spec_type3);
		}
	}
}


/*
**	Level 2 parser ==> keywords such as table, index, view and grant 
*/

static int RISuld_parse_rel_option(
	int					argc,
	char				*argv[],
	FILE				*spec_fp,
	char				*token_buf,
	int 				spec_type3)
{
	int 		spec_type2;
	short int	tab_fnd;
	short int	indx_fnd;
	short int	view_fnd;
	short int	grant_fnd;
	short int	use_pre_spec;

	ULD_DBG(("RISuld_parse_rel_option: argc %d argv 0x%x\n", argc, argv));
	ULD_DBG(("\tspec_fp 0x%x token_buf <%s> spec_type3 %d\n",
						spec_fp, token_buf, spec_type3));

	tab_fnd = FALSE;
	indx_fnd = FALSE;
	view_fnd = FALSE;
	grant_fnd = FALSE;
	use_pre_spec = TRUE;

	for(;;)
	{
		if (use_pre_spec)
		{
			spec_type2 = spec_type3;
			use_pre_spec = FALSE;
		}
		else
			spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
			
		switch(spec_type2)		/* switch 2 */
		{
			case TABLE:
				if (tab_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_TABLE_SPEC_TWICE);
					TERMINATE_RISUNLOAD
				}

				/* with default values */
				RISuld_create_bthnode(SOME, ONLY, SAME, FIXED);
				tab_fnd = TRUE;
				
				spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
				if (spec_type2 == WITH)
				{
					RISuld_ptr_struct_ptr->bthnode_ptr->def_data_select = BOTH;

					spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
					if (spec_type2 == DATA)
					{
						RISuld_ptr_struct_ptr->bthnode_ptr->dfile_select = SAME;
					}
					else if (spec_type2 == DFILE)
					{
						RISuld_ptr_struct_ptr->bthnode_ptr->dfile_select = DIFFERENT;

						spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
						if (spec_type2 != DATA)
						{
							RISuld_unload_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
							TERMINATE_RISUNLOAD
						}
 					}
					else if (spec_type2 == VAR)
					{
						RISuld_ptr_struct_ptr->bthnode_ptr->format_select = VARIABLE;

						spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
						if (spec_type2 == DFILE)
						{
							RISuld_ptr_struct_ptr->bthnode_ptr->dfile_select = DIFFERENT;
							spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
							if (spec_type2 != DATA)
							{
								RISuld_unload_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
								TERMINATE_RISUNLOAD
							}
						}
						else if (spec_type2 != DATA)
						{
							RISuld_unload_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
							TERMINATE_RISUNLOAD
						}
 					}
					else 
					{
						RISuld_unload_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
						TERMINATE_RISUNLOAD
					}

					spec_type3 = RISuld_parse_ind_rel(TABLE, 
													  argc, 
													  argv, 
													  spec_fp, 
													  token_buf,
													  FALSE);
				}
				else if (spec_type2 == EVERY_THING)
				{
					RISuld_ptr_struct_ptr->bthnode_ptr->tab_select = ALL;
					spec_type3 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
				}
				else if (spec_type2 == RELATION_NAME)
				{
					if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
					{
						RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
						TERMINATE_RISUNLOAD
					}
				
					spec_type3 = RISuld_parse_ind_rel(TABLE, 
													  argc, 
													  argv, 
													  spec_fp, 
													  token_buf,
													  TRUE);
				}	
				else
				{
					RISuld_unload_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
					TERMINATE_RISUNLOAD
				}
				break;
			case INDEX:
				if (indx_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_INDEX_SPEC_TWICE);
					TERMINATE_RISUNLOAD
				}

				RISuld_create_bihnode(SOME);
				indx_fnd = TRUE;

				spec_type3 = RISuld_parse_ind_rel(INDEX,
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf,
												  FALSE);
				break;
			case VIEW:
				if (view_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_VIEW_SPEC_TWICE);
					TERMINATE_RISUNLOAD
				}

				RISuld_create_bvhnode(SOME);
				view_fnd = TRUE;

				spec_type3 = RISuld_parse_ind_rel(VIEW, 
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf,
												  FALSE);
				break;
			case GRANT:
				if (grant_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_GRANT_SPEC_TWICE);
					TERMINATE_RISUNLOAD
				}

				RISuld_create_bghnode(SOME);
				grant_fnd = TRUE;

				spec_type3 = RISuld_parse_ind_rel(GRANT, 
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf,
												  FALSE);
				break;
			case EVERY_THING:
				if (tab_fnd || indx_fnd || view_fnd || grant_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_INVALID_ARGUMENT);
					TERMINATE_RISUNLOAD
				}

				RISuld_create_bthnode(ALL, BOTH, SAME, FIXED);

				RISuld_create_bihnode(ALL);

				RISuld_create_bvhnode(ALL);

				RISuld_create_bghnode(ALL);

				spec_type2 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

				ULD_DBG(("1. RISuld_parse_rel_option: end\n"));
				return(spec_type2);
			default:
				ULD_DBG(("2. RISuld_parse_rel_option: end\n"));
				return(spec_type2);
		}

		switch (spec_type3)		/* switch 3 */
		{
			case TABLE:
			case INDEX:
			case VIEW:
			case GRANT:
				use_pre_spec = TRUE;
				break;
			case SCHEMA:
			case NO_MORE_SPEC:
			case END_OF_SPEC_FILE:
			case FILE_MODE:
			case DEBUG_FLAG:
			case PRESERVE_BLANKS:
			case MAIN_FILE:
				ULD_DBG(("3. RISuld_parse_rel_option: end\n"));
				return(spec_type3);
			case SPEC_FILE:
				RISuld_unload_err_handler(RISUTL_E_UNEXPECTED_F_OPTION);
				TERMINATE_RISUNLOAD
			default:
				RISuld_unload_err_handler(RISUTL_E_INVALID_ARGUMENT);
				TERMINATE_RISUNLOAD
		} /* switch 3 */
	} /* switch 2 */
} /* for */


/*
**	Level 1 parser ==> -f, -g, -m, -o, -s -u options
*/

extern void RISuld_parse_cmd_line(
	int				argc,
	char			*argv[])
{
	int			spec_type1;
	int			spec_type2 = 0;
	int			use_pre_spec;
	short int		debugflag_fnd;
	short int		preserve_blanks_fnd;
	short int		filemode_fnd;
	short int		mfile_fnd;
	short int		sfile_fnd;
	short int		sch_spec_fnd;
	short int		delimiter_fnd;
	char			token_buf[SQL_MAX_STMT_LEN]; 
	char			sch_name[RIS_MAX_ID_SIZE];
	char			sch_pwd[RIS_MAX_ID_SIZE];
	char			os_name[RIS_MAX_ID_SIZE]; /* for secure schema */
	char			os_pwd[RIS_MAX_ID_SIZE];  /* for secure schema */
	char			db_name[RIS_MAX_ID_SIZE]; /* for secure schema */
	char			db_pwd[RIS_MAX_ID_SIZE];  /* for secure schema */
	FILE			*spec_fp;	

	ULD_DBG(("RISuld_parse_cmd_line: argc %d argv 0x%x \n", argc, argv));

	use_pre_spec = FALSE;		/* if TRUE then Do not fetch the next token */
	sch_spec_fnd = FALSE;		/* -s option found if TRUE */
	debugflag_fnd = FALSE;		/* -g option found if TRUE */
	preserve_blanks_fnd = FALSE;/* -p option found if TRUE */
	filemode_fnd = FALSE;		/* -m option found if TRUE */
	mfile_fnd = FALSE;			/* -o option found if TRUE */
	sfile_fnd = FALSE;			/* -f option found if TRUE */
	delimiter_fnd = FALSE;		/* -d option found if TRUE */
	spec_fp = (FILE *) NULL;

	for(;;)
	{ 
		if (use_pre_spec)
		{
			spec_type1 = spec_type2;
			use_pre_spec = FALSE;
		}
		else
			spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

		switch(spec_type1)
		{
			case SCHEMA:
				if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
				{
					RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
                   	                TERMINATE_RISUNLOAD
				}

				RISuld_separate_sch_name_pwd(token_buf, sch_name, sch_pwd);

				/* Get the next spec */
				spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
/***
				strcpy(sch_name, token_buf);
***/
				if (sch_pwd[0] == '\0')
				{
					if (spec_type1 == PASSWORD)
					{
						if (strlen(token_buf + 1) >= RIS_MAX_ID_SIZE)
						{
							RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISUNLOAD
						}
			
						strcpy(sch_pwd, (token_buf + 1));

						spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
					}
/***
					else
						sch_pwd[0] = '\0';
***/
				}

				/* 
				** Is this a secure schema? 
				*/
				if (spec_type1 == OSUSER)
				{
					spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

					/* Copy the user name */
					if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
					{
						RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
						TERMINATE_RISUNLOAD
					}

					RISuld_separate_sch_name_pwd(token_buf, os_name, os_pwd);

					/* Get the next spec */
					spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

					if (os_pwd[0] == '\0')
					{
						if (spec_type1 == PASSWORD)
						{
							if (strlen(token_buf + 1) >= RIS_MAX_ID_SIZE)
							{
								RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
								TERMINATE_RISUNLOAD
							}
			
							strcpy(os_pwd, (token_buf + 1));

							spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
						}
					}
				}
				else
                                {
					os_name[0] = '\0';
					os_pwd[0] = '\0';
                                 }


				if (spec_type1 == USER)
				{
					spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

					/* Copy the user name */
					if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
					{
						RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
						TERMINATE_RISUNLOAD
					}

					RISuld_separate_sch_name_pwd(token_buf, db_name, db_pwd);

					/* Get the next spec */
					spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

					if (db_pwd[0] == '\0')
					{
						if (spec_type1 == PASSWORD)
						{
							if (strlen(token_buf + 1) >= RIS_MAX_ID_SIZE)
							{
								RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
								TERMINATE_RISUNLOAD
							}
			
							strcpy(db_pwd, (token_buf + 1));

							spec_type1 = RISuld_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
						}
					}
				}
				else
                                {
					db_name[0] = '\0';
					db_pwd[0] = '\0';
                                }

				RISuld_create_bsnode(sch_name, sch_pwd,
				 os_name, os_pwd, db_name, db_pwd); /* secure schema */

				/*
				** create other structures with none values
				*/
				RISuld_create_bthnode(NONE, ONLY, SAME, FIXED);

				RISuld_create_bihnode(NONE);

				RISuld_create_bvhnode(NONE);

				RISuld_create_bghnode(NONE);

				sch_spec_fnd = TRUE;	

				spec_type2 = RISuld_parse_rel_option(argc, 
													 argv, 
													 spec_fp, 
													 token_buf,
													 spec_type1);

				switch(spec_type2)
				{
					case SCHEMA:
					case NO_MORE_SPEC:
					case END_OF_SPEC_FILE:
					case FILE_MODE:
					case MAIN_FILE:
						use_pre_spec = TRUE;
						break;
					case SPEC_FILE:
						RISuld_unload_err_handler(RISUTL_E_UNEXPECTED_F_OPTION);
						TERMINATE_RISUNLOAD
					default:
						RISuld_unload_err_handler(RISUTL_E_INVALID_ARGUMENT);
						TERMINATE_RISUNLOAD
				}
				break;
			case DEBUG_FLAG:
				if (debugflag_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_G_OPTION_TWICE);
					TERMINATE_RISUNLOAD
				}
				debugflag_fnd = TRUE;
				RISuld_debug = 1;
				break;

			case PRESERVE_BLANKS:
				if (preserve_blanks_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_P_OPTION_TWICE);
					TERMINATE_RISUNLOAD
				}
				preserve_blanks_fnd = TRUE;
				break;

			case FILE_MODE:
				if (filemode_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_M_OPTION_TWICE);
					TERMINATE_RISUNLOAD
				}

				if (strlen(token_buf) != 1)
				{
					RISuld_unload_err_handler(RISUTL_E_ILLEGAL_FILE_TYPE);
					TERMINATE_RISUNLOAD
				}

				if (RIScom_isupper(token_buf[0]))
				{
					RISuld_filemode = RIScom_tolower(token_buf[0]);
				}
				else
				{
					RISuld_filemode = token_buf[0];
				}
				filemode_fnd = TRUE;
				break;
			case MAIN_FILE:
				if (mfile_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_O_OPTION_TWICE);
					TERMINATE_RISUNLOAD
				}

				if (strlen(token_buf) >= RIS_MAX_PATH_SIZE)
				{
					RISuld_unload_err_handler(RISUTL_E_INVALID_PATH_SIZE);
					TERMINATE_RISUNLOAD
				}
					
				strcpy(RISuld_mfile,token_buf);

				/*
				RISuld_out_fp = RISuld_batch_open_file('m', RISuld_mfile);
				*/
				mfile_fnd = TRUE;
				break;
			case SPEC_FILE:
				if (sfile_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_F_OPTION_TWICE);
					TERMINATE_RISUNLOAD
				}

				if (sch_spec_fnd)
				{
					RISuld_unload_err_handler(RISUTL_E_UNEXPECTED_F_OPTION);
					TERMINATE_RISUNLOAD
				}

				if (strlen(token_buf) >= RIS_MAX_PATH_SIZE)
				{
					RISuld_unload_err_handler(RISUTL_E_INVALID_PATH_SIZE);
					TERMINATE_RISUNLOAD
				}
					
				strcpy(RISuld_sfile,token_buf);
				spec_fp = RISuld_batch_open_file('s', RISuld_sfile);
				sfile_fnd = TRUE;
				break;
			case NO_MORE_SPEC:
				/* Blankstrip */
				RISuld_blankstrip_mode(!preserve_blanks_fnd);

				/* File mode */
				if (!filemode_fnd)
				{
					RISuld_filemode = 'e';
				}

				/* Dump file */
				if (!mfile_fnd)
				{
					strcpy(RISuld_mfile,"ris.dmp");
				}
				RISuld_out_fp = RISuld_batch_open_file('m', RISuld_mfile);

				ULD_DBG(("1. RISuld_parse_cmd_line: end\n"));
				return;
			case END_OF_SPEC_FILE:
				spec_fp = (FILE *) NULL;
				break;
			default:
			{
				RISuld_unload_err_handler(RISUTL_E_INVALID_ARGUMENT);
				TERMINATE_RISUNLOAD
			}
		}
	}
}	
