/* Do not alter this SPC information: $Revision: 1.1.53.1 $ */
/*
**	NAME:							UTLquery.c
**	AUTHORS:						Dave Buehmann
**	CREATION DATE:					5/87
**	ABSTRACT:
**		Prepare and execute a query.
**	
*/
 
/*
**	INCLUDES
*/
#include "util.h"

/*
**	FUNCTION PROTOTYPES
*/
#define utlquery_rc
#include "comdebug.prt"
#include "comjmp.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "utlmisc.prt"
#include "utlquery.prt"
#include "utlerror.prt"
#include "utloutpt.prt"
#include "utlprint.prt"
#include "sys.prt"


/*
**	DEFINES
*/

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*****************************************************************************/

extern void RISutl_query(
	char *query)
{
	int			i;
	int			status;

	exec sql begin declare section;
		virtual char	*query as query;
		sqlda	desc1;
	exec sql end declare section;

	UTL_DBG(("RISutl_query(query: <>)\n")); 

       /****NOTE, you can NOT ^^^^^^^^^^^^ add the query to the DBG statement 
         because it reveils passwords into the dbg file...if you add it, 
         delete it before checkin! *** 7/94*/

	exec sql prepare stmt1 from :query;
	UTL_WARNING_CHECK();
	UTL_ERROR_CHECK();

	desc1.sqld = 0;
	desc1.sqln = 0;
	desc1.sqlvar = 0;

	if ((status = SETJMP()) != 0)
	{
		RESETJMP();

		RISutl_clear_sqlda(&desc1);

		exec sql clear stmt1;
		/* IGNORE CLEANUP ERROR */
		/* IGNORE CLEANUP WARNING */

		LONGJMP(status);
	}

	exec sql describe output stmt1 using descriptor desc1;
	UTL_WARNING_CHECK();
	UTL_ERROR_CHECK();

	if (desc1.sqld == 0)
	{
		/*
		**	Not a select
		*/
		exec sql execute stmt1;
		UTL_WARNING_CHECK();
		UTL_ERROR_CHECK();
		if (SQLCODE == END_OF_DATA)
		{
			RISutl_printf(MSG(RISUTL_I_NO_ROWS_UPDATED));
		}
	}
	else
	{
		/*
		**	A select
		*/

		desc1.sqlvar = (sqlvar *)calloc(desc1.sqld, sizeof(sqlvar));
		if (desc1.sqlvar == NULL)
		{
			LONGJMP(RISUTL_E_MALLOC);
		}

		desc1.sqln = desc1.sqld;
		exec sql describe output stmt1 using descriptor desc1;
		UTL_WARNING_CHECK();
		UTL_ERROR_CHECK();

    	for (i = 0; i < desc1.sqld; ++i)
    	{
			UTL_DBG(("RISutl_query: column %d: sqltype:%d sqllen:%d\n",
				i, desc1.sqlvar[i].sqltype, desc1.sqlvar[i].sqllen));
			if (desc1.sqlvar[i].sqltype == RIS_CHARACTER ||
				desc1.sqlvar[i].sqltype == RIS_DECIMAL)
			{
        		desc1.sqlvar[i].sqldata = calloc(1, desc1.sqlvar[i].sqllen + 1);
			}
			else if (desc1.sqlvar[i].sqltype == RIS_BLOB ||
				desc1.sqlvar[i].sqltype == RIS_TEXT)
			{
				LONGJMP(RISUTL_E_BLOB_QUERY);
			}
			else
			{
        		desc1.sqlvar[i].sqldata = calloc(1, desc1.sqlvar[i].sqllen);
			}
			if (desc1.sqlvar[i].sqldata == NULL)
			{
				LONGJMP(RISUTL_E_MALLOC);
			}
        	desc1.sqlvar[i].sqlind = (long*)calloc(1, sizeof(long));
			if (desc1.sqlvar[i].sqlind == NULL)
			{
				LONGJMP(RISUTL_E_MALLOC);
			}
        	desc1.sqlvar[i].sqlnull = 1;
    	}

		exec sql declare curs1 cursor for stmt1;
		UTL_WARNING_CHECK();
		UTL_ERROR_CHECK();

		exec sql open curs1;
		UTL_WARNING_CHECK();
		UTL_ERROR_CHECK();

		CLEAR_INTERRUPT();
		while(!INTERRUPTED())
		{
			exec sql fetch curs1 using descriptor desc1;
			UTL_WARNING_CHECK();
			UTL_ERROR_CHECK();
			if (SQLCODE == END_OF_DATA)
			{
				RISutl_printf(MSG(RISUTL_I_END_OF_DATA_FOUND));
				break;
			}

			RISutl_output_data(&desc1);
		}

		RISutl_clear_sqlda(&desc1);
	}

	RESETJMP();

#ifdef ROW_COUNT_SUPPORTED
	RISutl_printf(MSG(RISUTL_I_ROWS_PROCESSED), risca->sqlerrd[2]);
#endif

	exec sql clear stmt1;
	UTL_WARNING_CHECK();
	UTL_ERROR_CHECK();

	UTL_DBG(("RISutl_query:returing\n"));
}

/*****************************************************************************/
