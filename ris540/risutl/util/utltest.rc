/* Do not alter this SPC information: $Revision: 1.1.53.1 $ */
/*
**	NAME:							utltest.rc
**	AUTHORS:						Terry McIntyre
**	CREATION DATE:					4/92
**	ABSTRACT:
**	
**	REVISION HISTORY:
*/
 
/*
**	INCLUDES
*/
#include "util.h"
#include "rislimit.h"

/*
**	DEFINES
*/

/*
**	TYPES
*/

/*
**	FUNCTION PROTOTYPES
*/
#define utltest_rc
#include "comdebug.prt"
#include "comstcmi.prt"
#include "comjmp.prt"
#include "ris.prt"
#include "utltest.prt"
#include "utlerror.prt"
#include "utlmisc.prt"
#include "sys.prt"
#include "utlprint.prt"

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/******************************************************************************/

extern void RISutl_test_wait(
	int wait_flag)
{
	int		async_ids[RIS_MAX_TRANSACTIONS];
	char	*tok;
	char	*arg1;
	char	buffer[256];
	sqlvar	in_sqlvar[RIS_MAX_TRANSACTIONS];


	exec sql begin declare section;
		sqlda	in_sqlda;
	exec sql end declare section;

	UTL_DBG(("RISutl_test_wait(wait_flag:%d)\n", wait_flag));

	CLEAR_INTERRUPT();

	if (RISutl_async_id >= 0 &&
		RISutl_async_id < RIS_MAX_TRANSACTIONS)
	{
		RISutl_printf("\nEnter a list of async ids, 'all' or 'any' [%d]: ",
			RISutl_async_id);
	}
	else
	{
		RISutl_printf("\nEnter a list of async ids, 'all' or 'any': ");
	}
	RISutl_fgets(buffer, sizeof(buffer), RISutl_file_tos->file);
	if (INTERRUPTED())
	{
		UTL_DBG(("RISutl_test_wait:interrupted:complete\n"));
		return;
	}
	if (!buffer[0])
	{
		if (RISutl_async_id >= 0 &&
			RISutl_async_id < RIS_MAX_TRANSACTIONS)
		{
			async_ids[0] = RISutl_async_id;
			in_sqlvar[0].sqltype = RIS_INTEGER;
			in_sqlvar[0].sqldata = (char *)&async_ids[0];
			in_sqlda.sqln = 1;
			in_sqlda.sqld = 1;
			in_sqlda.sqlvar = in_sqlvar;
		}
		else
		{
			RISutl_printf("Invalid async id.\n");
			UTL_DBG(("RISutl_test_wait:complete\n"));
			return;
		}
	}
	else
	{
		in_sqlda.sqln = 0;
		in_sqlda.sqld = 0;
		in_sqlda.sqlvar = in_sqlvar;

		arg1 = buffer;
		while((tok = strtok(arg1, ",; \t\n")) != NULL)
		{
			if (in_sqlda.sqln >= RIS_MAX_TRANSACTIONS)
			{
				RISutl_printf("Too many async ids specified.\n");
				RISutl_printf("The macro RIS_MAX_TRANSACTIONS is the limit.\n");
				UTL_DBG(("RISutl_test_wait:complete\n"));
				return;
			}

			if (!RIScom_strcmp_ic("all", tok))
			{
				if (in_sqlda.sqln != 0 || strtok(NULL, ", \t\n") != NULL)
				{
					RISutl_printf("Keyword 'all' must be used alone.\n");
					UTL_DBG(("RISutl_test_wait:complete\n"));
					return;
				}
				in_sqlvar[0].sqltype = RIS_CHARACTER;
				in_sqlvar[0].sqldata = tok;
				in_sqlda.sqln = 1;
				in_sqlda.sqld = 1;
				break;
			}

			if (!RIScom_strcmp_ic("any", tok))
			{
				if (in_sqlda.sqln != 0 || strtok(NULL, ", \t\n") != NULL)
				{
					RISutl_printf("Keyword 'any' must be used alone.\n");
					UTL_DBG(("RISutl_test_wait:complete\n"));
					return;
				}
				in_sqlvar[0].sqltype = RIS_CHARACTER;
				in_sqlvar[0].sqldata = tok;
				in_sqlda.sqln = 1;
				in_sqlda.sqld = 1;
				break;
			}

			async_ids[in_sqlda.sqln] = atoi(tok);
			in_sqlvar[in_sqlda.sqln].sqltype = RIS_INTEGER;
			in_sqlvar[in_sqlda.sqln].sqldata=(char *)&async_ids[in_sqlda.sqln];
			in_sqlda.sqln++;
			in_sqlda.sqld++;
			arg1 = NULL;
		}
	}

	if (wait_flag)
	{
		exec sql wait using descriptor in_sqlda completion;
		UTL_WARNING_CHECK();
		UTL_ERROR_CHECK();
	}
	else
	{
		exec sql test using descriptor in_sqlda completion;
		UTL_WARNING_CHECK();
		UTL_ERROR_CHECK();
	}

	UTL_DBG(("RISutl_test_wait: SQLCODE:%d\n", SQLCODE));

	switch(SQLCODE)
	{
		case RIS_SUCCESS:
			RISutl_printf("\nStatement complete.\n");
			break;

		case STATEMENT_NOT_COMPLETE:
			RISutl_printf("\nStatement not complete.\n");
			break;

		case END_OF_DATA:
			RISutl_printf("\nEnd of data.\n");
			break;

		case STATEMENT_FAILED:
			RISutl_printf("\nStatement failed.\n");
			break;

		default:
			break;
	}


	UTL_DBG(("RISutl_test_wait:complete\n"));
}

/******************************************************************************/
