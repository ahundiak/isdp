/* Do not alter this SPC information: $Revision: 1.2.13.1 $ */
/*
**	NAME:				loddbs.rc								
**	AUTHORS:			Hitesh Patel
**	CREATION DATE:		November 26, 1991			
**	ABSTRACT:			It has functions concerning stmt "set database enable".
**		
**	
**	REVISION HISTORY:	August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/

#if defined(WIN32S) && defined(ULD_EXE)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#include "risutl.h"
#include "prog32s.h"
#endif 

#ifdef MM
#include "lod.h"
#endif
exec sql include "lod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define lodmisc_rc
#include "sys.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "lodmisc.prt"
#include "lodermsg.prt"
#include "lodtime.prt"
#include "ucoerrbx.prt"



extern dbs_type *RISlod_insert_in_dbs_list(
	dbs_type	*dbs_type_ptr,
	char		*dbsname)
{
	dbs_type *prev = NULL;
	dbs_type *curr = NULL;

	LOD_DBG(("RISlod_insert_in_dbs_list: dbsname <%s>\n",dbsname));

	prev = dbs_type_ptr;

	curr = (dbs_type *) calloc(1, sizeof(dbs_type));
	CHK_MEM_ALLOC_ERR(curr)
	strcpy(curr->dbsname, dbsname);
	curr->next = (dbs_type *) NULL;

	if( dbs_type_ptr == NULL)
	{
		dbs_type_ptr = curr;
	}
	else
	{
		dbs_type_ptr = curr;
		dbs_type_ptr->next = prev;
	}
	
	if (RISlod_debug)
	{
		for( prev = dbs_type_ptr; prev != NULL; prev = prev->next )
		{
			RIScom_output_debug("prev = %s\n",prev->dbsname);
		}
		RIScom_output_debug("1. RISlod_insert_in_dbs_list: End\n");
	}
	return dbs_type_ptr;
}

extern int RISlod_copy_dbs_ptr_to_risloddbs(
	dbs_type 	*dbs_type_ptr,
	risloddbs 	**risloddbs_ptr)
{
	dbs_type 	*curr_dbs_type;
	risloddbs 	*curr_risloddbs;
	int			num = 0;
	int 		dbs_num = 0;

	LOD_DBG(("RISlod_copy_dbs_ptr_to_risloddbs: Begin\n"));

	for( curr_dbs_type = dbs_type_ptr; 
			curr_dbs_type; 
				curr_dbs_type = curr_dbs_type->next )
	{
		dbs_num++;
	}

	if( dbs_num >= 1 )
	{
		curr_risloddbs = (risloddbs *) calloc(dbs_num,sizeof(risloddbs));
	
		for( curr_dbs_type = dbs_type_ptr, num = 0;
				curr_dbs_type && num < dbs_num;
					curr_dbs_type = curr_dbs_type->next, num++ )
		{
			strcpy(curr_risloddbs[num].dbsname,curr_dbs_type->dbsname);
		}
		*risloddbs_ptr = curr_risloddbs;

		LOD_DBG(("1. RISlod_copy_dbs_ptr_to_risloddbs: returning dbs_num = %d\n",dbs_num));
		return dbs_num;
	}
	else
	{
		return 0;
	}
}

extern void RISlod_exec_enforce_dbs(
	int			dbs_num,
	risloddbs	*risloddbs_ptr)
{
	int		num = 0;
	int		len = 0;

    exec sql begin declare section;
		char    dbs_stmt[STRING_MAX_LEN];
		char    *err_ptr;
	exec sql end declare section;

    LOD_DBG(("RISlod_exec_enforce: Begin\n"));
	exec sql whenever sqlerror goto :ED_error;

	strcpy(dbs_stmt,"set database enable only ");
	for( num = 0; num < dbs_num; num++ )
	{
		strcat(dbs_stmt,risloddbs_ptr[num].dbsname);
		strcat(dbs_stmt,",");
	}
	/*
	**	rm trailing comma
	*/
	len = strlen(dbs_stmt);
	dbs_stmt[len-1] = '\0';

	exec sql execute immediate :dbs_stmt;
	LOD_WARNING_CHECK(RISlod_general_warn);
	if( risca->sqlstmt )
	{
		risca->sqlstmt[0] = '\0';
	}

	LOD_DBG(("1. RISlod_exec_enforce_dbs: end\n"));
	return;
		
ED_error:
    exec sql whenever sqlerror continue;
    exec sql report error into :err_ptr;

    /* Error is written here */
    if( RISlod_mode == EMBED )
    {
		*RISlod_general_err = risca->sqlcode;
    }
    else
    {
#if !defined(ULD_DLL)
        PUTS(err_ptr);
#endif
    }

    LOD_DBG(("2. RISlod_exec_enforce_dbs: end\n"));
    TERMINATE_RISLOAD
	return;
}

extern void RISlod_free_dbs_lists(
	dbs_type 	*dbs_type_ptr,
	risloddbs 	*risloddbs_ptr)
{
	dbs_type *prev = NULL;
	dbs_type *curr = NULL;

	LOD_DBG(("RISuld_free_dbs_lists: begin\n"));

	for( curr = dbs_type_ptr; curr != NULL; curr = prev )
	{
		prev = curr->next;
		free(curr);
	}	
	free(risloddbs_ptr);
	LOD_DBG(("1. RISuld_free_dbs_lists: end\n"));
}
								  
