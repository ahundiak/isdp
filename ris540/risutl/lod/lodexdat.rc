/* Do not alter this SPC information: $Revision: 1.2.9.1 $ */
/*
**	NAME:				lodexdat.rc									
**	AUTHORS:			Jennifer Xia			
**	CREATION DATE:		June 26, 1990			
**	ABSTRACT:			It contains function which extract a column valu e from
**						its field.	
**	
**	REVISION HISTORY:	August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#include <ctype.h>
#ifdef MM
#include "lod.h"
#endif

exec sql include "lod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define lodexdat_rc
#include "sys.prt"
#include "comdebug.prt"
#include "lodexdat.prt"
#include "lodermsg.prt"
#include "lodlogdp.prt"
#include "lodmisc.prt"
#include "comisfn.prt"

/******************************************************************************/

extern int RISlod_extr_VARCHAR_val(
	field_type	*field_defs,
	int			col_indx,
	int			max_end_posi,
	int			*curr_pos_ptr)
{
	char		ch;
	int			i;
	int			pos;
	
	LOD_DBG(("RISlod_extr_VARCHAR_val: field_defs 0x%x col_indx %d max_end_posi %d *curr_pos_ptr %d\n",
					field_defs, col_indx, max_end_posi, *curr_pos_ptr));

	pos = *curr_pos_ptr;

	if (RIScom_isspace(RISlod_sql_stmt[pos]))
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
		pos += 2;
		*curr_pos_ptr = pos;

		LOD_DBG(("1. RISlod_extr_VARCHAR_val: end\n"));
		return(SUCCESS);
	}
	else if (RISlod_sql_stmt[pos] != RISlod_delimiter)
	{
		strcat(RISlod_sql_stmt,"\0"); /* What the hell is this??? */
		RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
		RISlod_load_err_handler(RISUTL_E_LEFT_DELIMITER_MISSING,RISlod_sql_stmt+1);
		if( RISlod_mode == EMBED )
			RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_LEFT_DELIMITER_MISSING;
		
		LOD_DBG(("RISlod_extr_VARCHAR_val: RISUTL_E_LEFT_DELIMITER_MISSING\n"));
		return(FAILURE);
	}
	
	for (pos++, i = 0; pos <= max_end_posi; pos++, i++)
	{
		LOD_DBG(("i = %d",i));
		LOD_DBG(("\tpos = %d",pos));

		ch = RISlod_sql_stmt[pos];

		LOD_DBG(("\tch = %c\n",ch));

		if ( ch == RISlod_delimiter )
		{
			if( RISlod_sql_stmt[pos+1] == RISlod_delimiter )
			{
				/*
				** escaping delimiter
				*/
				pos++;
			}
			else
			{
				if (i <  RISlod_in_desc.sqlvar[col_indx].sqllen)
					RISlod_in_desc.sqlvar[col_indx].sqldata[i] = '\0';

				*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;
				pos += 2;
				*curr_pos_ptr = pos;
	
				LOD_DBG(("3. RISlod_extr_VARCHAR_val: end\n"));
				return(SUCCESS);
			}
		}

		/* Error - string is too long */
		if (i >= RISlod_in_desc.sqlvar[col_indx].sqllen)
		{
			strcat(RISlod_sql_stmt,"\0");
			RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
			RISlod_load_err_handler(RISUTL_E_INPUT_TOO_LONG,RISlod_sql_stmt+1);
			if( RISlod_mode == EMBED )
				RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_INPUT_TOO_LONG;

			LOD_DBG(("RISlod_extr_VARCHAR_val: RISUTL_E_INPUT_TOO_LONG\n"));
			return(FAILURE);
		}

		RISlod_in_desc.sqlvar[col_indx].sqldata[i] = ch;
	} /* for */

	LOD_DBG(("4. RISlod_extr_VARCHAR_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_VARDECIMAL_val(
	field_type	*field_defs,
	int			col_indx,
	int			max_end_posi,
	int 		*curr_pos_ptr)
{
	char		ch;
	int			i = 0;
	int			pos = 0;
	int			head = 0;
	int			tail = 0;
	
	LOD_DBG(("RISlod_extr_VARDECIMAL_val: field_defs 0x%x col_indx %d max_end_posi %d *curr_pos_ptr %d\n",
					field_defs, col_indx, max_end_posi, *curr_pos_ptr));

	pos = *curr_pos_ptr;

	if (RIScom_isspace(RISlod_sql_stmt[pos]))
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
		*curr_pos_ptr = pos + 2;

		LOD_DBG(("1. RISlod_extr_VARDECIMAL_val: end\n"));
		return(SUCCESS);
	}

	for (i = 0, head = pos; pos <= max_end_posi; pos++, i++)
	{
		LOD_DBG(("i = %d",i));
		LOD_DBG(("\tpos = %d",pos));

		ch = RISlod_sql_stmt[pos];

		LOD_DBG(("\tch = %c\n",ch));

		if (RIScom_isspace(ch))
		{
			tail = i - 1;
			if ((tail - head + 1) > (RISlod_in_desc.sqlvar[col_indx].sqllen - 1))
			{
				strcat(RISlod_sql_stmt,"\0");
				RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
				RISlod_load_err_handler(RISUTL_E_INVALID_DECIMAL_VALUE,RISlod_sql_stmt+1);
				if( RISlod_mode == EMBED )
						RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_INVALID_DECIMAL_VALUE;
					
				LOD_DBG(("1. RISlod_extr_VARDECIMAL_val: end\n"));
				return(FAILURE);
			}

			for (; i < RISlod_in_desc.sqlvar[col_indx].sqllen - 1; i++)
				RISlod_in_desc.sqlvar[col_indx].sqldata[i] = ' ';
	
			RISlod_in_desc.sqlvar[col_indx].sqldata[RISlod_in_desc.sqlvar[col_indx].sqllen - 1] = '\0';

			*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;
			*curr_pos_ptr = pos + 1;

			LOD_DBG(("2. RISlod_extr_VARDECIMAL_val: end\n"));
			return(SUCCESS);
		}

		RISlod_in_desc.sqlvar[col_indx].sqldata[i] = ch;
	}

	LOD_DBG(("3. RISlod_extr_VARDECIMAL_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_VARNUMERAL_val(
	field_type	*field_defs,
	int			col_indx,
	int			max_end_posi,
	int 		*curr_pos_ptr)
{
	int			pos = 0;
	long		for_test;
	
	LOD_DBG(("RISlod_extr_VARNUMERAL_val: field_defs 0x%x col_indx %d max_end_posi %d *curr_pos_ptr %d\n",
					field_defs, col_indx, max_end_posi, *curr_pos_ptr));

	pos = *curr_pos_ptr;

	if (RIScom_isspace(RISlod_sql_stmt[pos]))
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
		*curr_pos_ptr = pos + 2;

		LOD_DBG(("1. RISlod_extr_VARNUMERAL_val: end\n"));
		return(SUCCESS);
	}

	switch(RISlod_in_desc.sqlvar[col_indx].sqltype)
	{
		case RIS_SMALLINT:
			sscanf(RISlod_sql_stmt + pos, "%ld", &for_test);
			if ((for_test > MAX_SMALLINT) || (for_test < MIN_SMALLINT))
			{
				strcat(RISlod_sql_stmt,"\0");
				RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
				RISlod_load_err_handler(RISUTL_E_VALUE_OUT_OF_RANGE,RISlod_sql_stmt+1);
				if( RISlod_mode == EMBED )
					RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_VALUE_OUT_OF_RANGE;

				LOD_DBG(("1. RISlod_extr_VARNUMERAL_val: end\n"));
				return(FAILURE);
			}
			sscanf(RISlod_sql_stmt + pos, "%hd", RISlod_in_desc.sqlvar[col_indx].sqldata);
			LOD_DBG(("SMALLINT = %hd\n", *(short *)RISlod_in_desc.sqlvar[col_indx].sqldata));
		break;
		case RIS_INTEGER:
			sscanf(RISlod_sql_stmt + pos, "%d", RISlod_in_desc.sqlvar[col_indx].sqldata);
			LOD_DBG(("INTEGER = %d\n", *(int *)RISlod_in_desc.sqlvar[col_indx].sqldata));

		break;
		case RIS_REAL:
			sscanf(RISlod_sql_stmt + pos, "%f", RISlod_in_desc.sqlvar[col_indx].sqldata);

			LOD_DBG(("REAL = %f\n", *(float *)RISlod_in_desc.sqlvar[col_indx].sqldata));
			break;
		case RIS_DOUBLE:
			sscanf(RISlod_sql_stmt + pos, "%lf", RISlod_in_desc.sqlvar[col_indx].sqldata);
			LOD_DBG(("DOUBLE = %lf\n", *(double *)RISlod_in_desc.sqlvar[col_indx].sqldata));

		break;
	}

	*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;

	for( pos = *curr_pos_ptr; pos <= max_end_posi; pos++ )
	{
		LOD_DBG(("RISlod_sql_stmt[%d]={%c}\n",pos,RISlod_sql_stmt[pos]));
		if(RIScom_isspace(RISlod_sql_stmt[pos]))
			break;
	}
	LOD_DBG(("pos = %d\n", pos));
	*curr_pos_ptr = pos + 1;

	LOD_DBG(("3. RISlod_extr_VARNUMERAL_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_VARDATETIME_val(
	field_type	*field_defs,
	int			col_indx,
	int			max_end_posi,
	int 		*curr_pos_ptr)
{
	int			pos;
	int			year;
	int			month;
	int			day;
	int			hour;
	int			minute;
	int			second;
	datetime	*dt;

	LOD_DBG(("RISlod_extr_VARDATETIME_val: field_defs 0x%x col_indx %d max_end_posi %d *curr_pos_ptr %d\n",
			field_defs, col_indx, max_end_posi, *curr_pos_ptr));

	pos = *curr_pos_ptr;

	if (RIScom_isspace(RISlod_sql_stmt[pos]))
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
		*curr_pos_ptr = pos + 2;

		LOD_DBG(("1. RISlod_extr_VARDATETIME_val: end\n"));
		return(SUCCESS);
	}

	year = -1;
	month = -1;
	day = -1;
	hour = -1;
	minute = -1;
	second = -1;

	pos += 
		sscanf(RISlod_sql_stmt + pos, "%d-%d-%d:%d:%d:%d", &year, &month, &day, &hour, &minute, &second);	
		
	dt = (datetime *)RISlod_in_desc.sqlvar[col_indx].sqldata;
	dt->year = year;
	dt->month = month;
	dt->day = day;
	dt->hour = hour;
	dt->minute = minute;
	dt->second = second;

	*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;

	for( pos = *curr_pos_ptr; pos <= max_end_posi; pos++ )
	{
		LOD_DBG(("RISlod_sql_stmt[%d]={%c}\n",pos,RISlod_sql_stmt[pos]));
		if(RIScom_isspace(RISlod_sql_stmt[pos]))
			break;
	}
	LOD_DBG(("pos = %d\n", pos));
	*curr_pos_ptr = pos + 1;

	LOD_DBG(("2. RISlod_extr_VARDATETIME_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_varchar_val(
	field_type	*field_defs,
	int			col_indx)
{
	int		not_null;
	char	*ldelim;
	char	*rdelim;
	char	ch;
	char	*ptr;
	int		i;
	
	LOD_DBG(("RISlod_extr_varchar_val: field_defs 0x%x col_indx %d \n",
						field_defs, col_indx));

	not_null = FALSE;
	ldelim = (char	*) NULL;
	rdelim = (char	*) NULL;

	for (i = field_defs[col_indx].start; i <= field_defs[col_indx].end; i++)
	{
		ch = RISlod_sql_stmt[i];

		if (!RIScom_isspace(ch))
		{
			if (ch == RISlod_delimiter)
			{	
				not_null = TRUE;
				ldelim = RISlod_sql_stmt + i;

				break;
			}
			else
			{
				strcat(RISlod_sql_stmt,"\0");
				RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
				RISlod_load_err_handler(RISUTL_E_LEFT_DELIMITER_MISSING,RISlod_sql_stmt+1);
				if( RISlod_mode == EMBED )
					RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_LEFT_DELIMITER_MISSING;
				
				LOD_DBG(("1. RISlod_extr_varchar_val: end\n"));
				return(FAILURE);
			}
		}
	}

	if (not_null)
	{
		rdelim = RISlod_reverse_skip_space(RISlod_sql_stmt + field_defs[col_indx].end);

		if ((rdelim == ldelim) || (*rdelim != RISlod_delimiter))
		{
			strcat(RISlod_sql_stmt,"\0");
			RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
			RISlod_load_err_handler(RISUTL_E_RIGHT_DELIMITER_MISSING,RISlod_sql_stmt+1);
			if( RISlod_mode == EMBED )
					RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_RIGHT_DELIMITER_MISSING;
				
			LOD_DBG(("2. RISlod_extr_varchar_val: end\n"));
			return(FAILURE);
		}

		for (ptr = ldelim + 1, i = 0; 
					(ptr < rdelim) && (i <  RISlod_in_desc.sqlvar[col_indx].sqllen);
							ptr++, i++)
		{
			RISlod_in_desc.sqlvar[col_indx].sqldata[i] = *ptr;
		}

		if (i <  RISlod_in_desc.sqlvar[col_indx].sqllen)
			RISlod_in_desc.sqlvar[col_indx].sqldata[i] = '\0';

		*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;

	}
	else
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
	}

	LOD_DBG(("3. RISlod_extr_varchar_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_fixchar_val(
	field_type	*field_defs,
	int			col_indx)
{
	int	not_null; /* Indicator of an empty (all spaces) string */
	int	field_indx;
	int	val_indx;

	LOD_DBG(("RISlod_extr_fixchar_val: field_defs 0x%x col_indx %d\n", field_defs, col_indx));

	not_null = FALSE; /* empty string */

	/* Copy the string into the SQL data buffer */
	val_indx = 0;
	for (field_indx = field_defs[col_indx].start; 
				(field_indx <= field_defs[col_indx].end) && 
				(val_indx <  RISlod_in_desc.sqlvar[col_indx].sqllen); 
						field_indx++)
	{
		/* Get the character */
		RISlod_in_desc.sqlvar[col_indx].sqldata[val_indx++] = RISlod_sql_stmt[field_indx];

		/* Did we get a non-space character? */
		not_null = not_null || (! RIScom_isspace(RISlod_sql_stmt[field_indx]));
	}

	/* Ran out of buffer space, but keep reading until we exaust the data for the column */
	for (field_indx = field_defs[col_indx].start + val_indx; 
				(! not_null) && (field_indx <= field_defs[col_indx].end); 
						field_indx++)
	{
		not_null = not_null || (! RIScom_isspace(RISlod_sql_stmt[field_indx]));
	}


	if (not_null)
	{
		/* Pad string with spaces */
		for (; val_indx < RISlod_in_desc.sqlvar[col_indx].sqllen; val_indx++)
		{
			RISlod_in_desc.sqlvar[col_indx].sqldata[val_indx] = ' ';
		}

		*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;
	}
	else /* string is just spaces */
	{
		/* Set the indicator to a null value for this field */
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
	}

	LOD_DBG(("1. RISlod_extr_fixchar_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_decimal_val(
	field_type	*field_defs,
	int			col_indx)
{
	int			not_null;
	char		*head = (char *) NULL;
	char		*tail;
	char		ch;
	int			i;
	char		*ptr;

	LOD_DBG(("RISlod_extr_decimal_val: field_defs 0x%x col_indx %d\n", field_defs, col_indx));

	not_null = FALSE; 
	for (i = field_defs[col_indx].start; i <= field_defs[col_indx].end; i++)
	{
		ch = RISlod_sql_stmt[i];

		if (! RIScom_isspace(ch))
		{
			not_null = TRUE; 
			head = RISlod_sql_stmt + i;
			
			break;	
		}
	}

	if (not_null)
	{
		tail = RISlod_reverse_skip_space(RISlod_sql_stmt + field_defs[col_indx].end); 

/*
** i = 1(start) head is not initialized 
*/

		if ((tail - head + 1) > (RISlod_in_desc.sqlvar[col_indx].sqllen - 1))
		{
			strcat(RISlod_sql_stmt,"\0");
			RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
			RISlod_load_err_handler(RISUTL_E_INVALID_DECIMAL_VALUE,RISlod_sql_stmt+1);
			if( RISlod_mode == EMBED )
					RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_INVALID_DECIMAL_VALUE;
				
			LOD_DBG(("1. RISlod_extr_decimal_val: end\n"));
			return(FAILURE);
		}

		for (ptr = head, i = 0; (ptr <= tail); ptr++, i++)
		{
			RISlod_in_desc.sqlvar[col_indx].sqldata[i] = *ptr;
		}
		
		for (; i < RISlod_in_desc.sqlvar[col_indx].sqllen - 1; i++)
			RISlod_in_desc.sqlvar[col_indx].sqldata[i] = ' ';

		RISlod_in_desc.sqlvar[col_indx].sqldata[RISlod_in_desc.sqlvar[col_indx].sqllen - 1] = '\0';

		*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;
	}
	else
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
	}

	LOD_DBG(("2. RISlod_extr_decimal_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_numeral_val(
	field_type	*field_defs,
	int			col_indx)
{
	int		not_null;
	int		field_indx;
	long	for_test;

	LOD_DBG(("RISlod_extr_numeral_val: field_defs 0x%x col_indx %d\n", field_defs, col_indx));

	not_null = FALSE;
					
	for (field_indx = field_defs[col_indx].start; (field_indx <= field_defs[col_indx].end); field_indx++)
	{
		if (! RIScom_isspace(RISlod_sql_stmt[field_indx]))
		{
			not_null = TRUE;
			break;
		}
	}

	if (not_null)
	{
		switch(RISlod_in_desc.sqlvar[col_indx].sqltype)
		{
			case RIS_SMALLINT:
				sscanf(RISlod_sql_stmt + field_defs[col_indx].start, "%ld", &for_test);
				if ((for_test > MAX_SMALLINT) || (for_test < MIN_SMALLINT))
				{
					strcat(RISlod_sql_stmt,"\0");
					RISlod_dump_partial_tab(TRUE,TRUE,TRUE);
					RISlod_load_err_handler(RISUTL_E_VALUE_OUT_OF_RANGE,RISlod_sql_stmt+1);
					if( RISlod_mode == EMBED )
						RISlod_ptr_struct_ptr->btnode_ptr->lnd_err_code = RISUTL_E_VALUE_OUT_OF_RANGE;

					LOD_DBG(("1. RISlod_extr_numeral_val: end\n"));
					return(FAILURE);
				}

				sscanf(RISlod_sql_stmt + field_defs[col_indx].start, "%hd", RISlod_in_desc.sqlvar[col_indx].sqldata);

				break;
			case RIS_INTEGER:

				sscanf(RISlod_sql_stmt + field_defs[col_indx].start, "%d", RISlod_in_desc.sqlvar[col_indx].sqldata);

				break;
			case RIS_REAL:
				sscanf(RISlod_sql_stmt + field_defs[col_indx].start, "%f", RISlod_in_desc.sqlvar[col_indx].sqldata);

				break;
			case RIS_DOUBLE:
				sscanf(RISlod_sql_stmt + field_defs[col_indx].start, "%lf", RISlod_in_desc.sqlvar[col_indx].sqldata);

				break;
		}

		*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;
	}
	else 
	{
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;
	}

	LOD_DBG(("3. RISlod_extr_numeral_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

extern int RISlod_extr_datetime_val(
	field_type	*field_defs,
	int			col_indx)
{
	int			not_null;
	int			field_indx;
	int			year;
	int			month;
	int			day;
	int			hour;
	int			minute;
	int			second;
	datetime	*dt;

	LOD_DBG(("RISlod_extr_datetime_val: field_defs 0x%x col_indx %d\n", field_defs, col_indx));

	not_null = FALSE;

	for (field_indx = field_defs[col_indx].start; 
				field_indx <= field_defs[col_indx].end; 
						field_indx++)
	{
		if (! RIScom_isspace(RISlod_sql_stmt[field_indx]))
		{
			not_null = TRUE;
			break;
		}
	}

	if (not_null)
	{
		year = -1;
		month = -1;
		day = -1;
		hour = -1;
		minute = -1;
		second = -1;

		sscanf(RISlod_sql_stmt + field_defs[col_indx].start, "%d-%d-%d:%d:%d:%d", &year, &month, &day, &hour, &minute, &second);	
		
		dt = (datetime *)RISlod_in_desc.sqlvar[col_indx].sqldata;
		dt->year = year;
		dt->month = month;
		dt->day = day;
		dt->hour = hour;
		dt->minute = minute;
		dt->second = second;

		*RISlod_in_desc.sqlvar[col_indx].sqlind = 0;
	}
	else
		*RISlod_in_desc.sqlvar[col_indx].sqlind = -1;

	LOD_DBG(("1. RISlod_extr_datetime_val: end\n"));
	return(SUCCESS);
}

/******************************************************************************/

#ifdef NOT_USED
static void PRINT_SQLDATA(
	int pos)
{
	int i = pos;
	int x = 0;
	char stmt[1000];

	while( !RIScom_isspace(RISlod_sql_stmt[i]) )
	{
		stmt[x++] = RISlod_sql_stmt[i++];
	}
	stmt[x] = '\0';
	LOD_DBG(("stmt = %s\n", stmt));
}
#endif

/******************************************************************************/
