/* Do not alter this SPC information: $Revision: 1.1.53.1 $ */
/*
**	NAME:				lodcmd.rc								
**	AUTHORS:			Jennifer Xia			
**	CREATION DATE:		July 25, 1990			
**	ABSTRACT:			It contains three functions which parses a command line.
**		
**	REVISION HISTORY:	August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#include <ctype.h>
#ifdef MM
#include "lod.h"
#endif

exec sql include "lod.h";

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define lodcmd_rc
#include "sys.prt"
#include "comjmp.prt"
#include "comdebug.prt"
#include "comumsg.prt"
#include "comstrcp.prt"
#include "loddbs.prt"
#include "lodermsg.prt"
#include "lodgtspc.prt"
#include "lodcmd.prt"
#include "lodmisc.prt"
#include "lodstspc.prt"
#include "lodtime.prt"

static int RISlod_parse_exec_enforce_db(
	int					argc,
	char				*argv[],
	FILE				*spec_fp,
	char				*token_buf)
{
	int 		dbs_num = 0;
	int 		spec_type2 = 0;
	dbs_type	*dbs_type_ptr = (dbs_type *) NULL;
	risloddbs	*risloddbs_ptr = (risloddbs *) NULL;

	/* Insert the first one */
	dbs_type_ptr = RISlod_insert_in_dbs_list(dbs_type_ptr,token_buf);
	for(;;)
	{
		spec_type2 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
		switch(spec_type2)
		{
			case RELATION_NAME:
				if (strlen(token_buf) >= RIS_MAX_KEYWORD_SIZE)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_KEYWORD_SIZE);
					TERMINATE_RISLOAD
				}
				dbs_type_ptr = RISlod_insert_in_dbs_list(dbs_type_ptr,token_buf);
			break;
			case SCHEMA:
			case NO_MORE_SPEC:
			case END_OF_SPEC_FILE:
			case BAD_FILE:
			case COMMIT_INTERVAL:
			case DEBUG_FLAG:
			case DELIMITOR:
			case FILE_MODE:
			case LOG_FILE:
			case MAIN_FILE:
			case SPEC_FILE:
			case NON_ANSI_MODE:
			case PRESERVE_BLANKS:
				dbs_num = RISlod_copy_dbs_ptr_to_risloddbs(dbs_type_ptr,&risloddbs_ptr);
				if( dbs_num == 0 )
				{
					RISlod_parse_err_handler(RISUTL_E_DBSNAME_EXPECTED);
					TERMINATE_RISLOAD
				}
				RISlod_exec_enforce_dbs(dbs_num,risloddbs_ptr);
				RISlod_free_dbs_lists(dbs_type_ptr,risloddbs_ptr);
			return(spec_type2);
			case ENABLE_DB:
				RISlod_parse_err_handler(RISUTL_E_E_OPTION_TWICE);
				TERMINATE_RISLOAD
			break;
		}
	}
}


static int RISlod_parse_ind_rel(
	int					name_type,
	int					argc,
	char				*argv[],
	FILE				*spec_fp,
	char				*token_buf)
{

	int 	spec_type3;

	LOD_DBG(("RISlod_parse_ind_rel: name_type %d \n", name_type));
	LOD_DBG(("\targc %d argv 0x%x spec_fp 0x%x token_buf 0x%x\n", 
		argc, argv, spec_fp,token_buf));

	for(;;)
	{
		spec_type3 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
	
		switch(spec_type3)
		{
			case RELATION_NAME:
				switch (name_type)
				{
					case TABLE:
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISLOAD
						}
						
						RISlod_create_btnode(token_buf);
						break;
					case INDEX:
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISLOAD
						}
						
						RISlod_create_binode(token_buf);
						break;
					case VIEW:
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISLOAD
						}
	
						RISlod_create_bvnode(token_buf);
						break;
					case GRANT:
						if (strlen(token_buf) >= (2 * RIS_MAX_ID_SIZE))
						{
							RISlod_parse_err_handler(RISUTL_E_INVALID_RELSPEC_SIZE);
							TERMINATE_RISLOAD
						}
						
						RISlod_create_bgnode(token_buf);
						break;
				}
				break;
			case EVERY_THING:
				switch (name_type)
				{
					case TABLE:
						RISlod_ptr_struct_ptr->bthnode_ptr->tab_select = ALL;
						break;
					case INDEX:
						RISlod_ptr_struct_ptr->bihnode_ptr->indx_select = ALL;
						break;
					case VIEW:
						RISlod_ptr_struct_ptr->bvhnode_ptr->view_select = ALL;
						break;
					case GRANT:
						RISlod_ptr_struct_ptr->bghnode_ptr->grant_select = ALL;
						break;
				}
				spec_type3 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
			
				LOD_DBG(("1. RISlod_parse_ind_rel: end"));
				return(spec_type3);
			default:
				LOD_DBG(("2. RISlod_parse_ind_rel: end"));
				return(spec_type3);
		}
	}
}


static int RISlod_parse_rel_option(
	int					argc,
	char				*argv[],
	FILE				*spec_fp,
	char				*token_buf,
	int 				spec_type3)
{
	short int	use_pre_spec;
	int 		spec_type2;
	short int	tab_fnd;
	short int	indx_fnd;
	short int	view_fnd;
	short int	grant_fnd;
	int			keyword2;
	int			keyword3;
	int			keyword4;

	LOD_DBG(("RISlod_parse_rel_option: argc %d argv 0x%x\n", argc, argv));
	LOD_DBG(("\tspec_fp 0x%x token_buf <%s>, spec_type3 %d\n", 
						spec_fp,token_buf, spec_type3));


	tab_fnd = FALSE;
	indx_fnd = FALSE;
	view_fnd = FALSE;
	grant_fnd = FALSE;
	use_pre_spec = TRUE;

	for(;;)
	{
		if (use_pre_spec)
		{
			spec_type2 = spec_type3;
			use_pre_spec = FALSE;
		}
		else
			spec_type2 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
			
		switch(spec_type2)
		{
			case TABLE:
				if (tab_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_TABLE_SPEC_TWICE);
					TERMINATE_RISLOAD
				}

				tab_fnd = TRUE;
				RISlod_ptr_struct_ptr->bthnode_ptr->tab_select = SOME;
				RISlod_ptr_struct_ptr->bthnode_ptr->def_data_select = ONLY;
				RISlod_ptr_struct_ptr->bthnode_ptr->clear_tab_select = NO;

				spec_type2 = RISlod_fetch_analyze_spec(argc, 
													   argv, 
													   spec_fp, 
													   token_buf);
				if (spec_type2 == WITH)
				{
					keyword3 = RISlod_fetch_analyze_spec(argc, 
														 argv, 
														 spec_fp, 
														 token_buf);

					if (keyword3 == DATA)
					{
						RISlod_ptr_struct_ptr->bthnode_ptr->def_data_select = BOTH;
						RISlod_ptr_struct_ptr->bthnode_ptr->exist_tab_select = RIS_IGNORE;
					}
					else
					{
						RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
						TERMINATE_RISLOAD
					}

					spec_type3 = RISlod_parse_ind_rel(TABLE, 
													  argc, 
													  argv, 
													  spec_fp, 
													  token_buf);
				}
				else if (spec_type2 == EVERY_THING)
				{
					RISlod_ptr_struct_ptr->bthnode_ptr->tab_select = ALL;
					spec_type3 = RISlod_fetch_analyze_spec(argc, 
														   argv, 
														   spec_fp, 
														   token_buf);
				}
				else if (spec_type2 == RELATION_NAME)
				{
					if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
					{
						RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
						TERMINATE_RISLOAD
					}
				
					RISlod_create_btnode(token_buf);
					spec_type3 = RISlod_parse_ind_rel(TABLE, 
													  argc, 
													  argv, 
													  spec_fp, 
													  token_buf);
				}	
				else
				{
					RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
					TERMINATE_RISLOAD
				}
				break;
			case INDEX:
				if (indx_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_INDEX_SPEC_TWICE);
					TERMINATE_RISLOAD
				}

				RISlod_ptr_struct_ptr->bihnode_ptr->indx_select = SOME;
				indx_fnd = TRUE;

				spec_type3 = RISlod_parse_ind_rel(INDEX,
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf);
				break;
			case VIEW:
				if (view_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_VIEW_SPEC_TWICE);
					TERMINATE_RISLOAD
				}

				RISlod_ptr_struct_ptr->bvhnode_ptr->view_select = SOME;
				view_fnd = TRUE;

				spec_type3 = RISlod_parse_ind_rel(VIEW, 
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf);
				break;
			case GRANT:
				if (grant_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_GRANT_SPEC_TWICE);
					TERMINATE_RISLOAD
				}

				RISlod_ptr_struct_ptr->bghnode_ptr->grant_select = SOME;
				grant_fnd = TRUE;

				spec_type3 = RISlod_parse_ind_rel(GRANT, 
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf);
				break;
			case NEW:
				if (tab_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_TABLE_SPEC_TWICE);
					TERMINATE_RISLOAD
				}

				keyword2 = RISlod_fetch_analyze_spec(argc, 
													 argv, 
													 spec_fp, 
													 token_buf);
				if (keyword2 == TABLE)
				{
					keyword3 = RISlod_fetch_analyze_spec(argc, 
														 argv, 
														 spec_fp, 
														 token_buf);

					if (keyword3 == WITH) 
					{
						keyword4 = RISlod_fetch_analyze_spec(argc, 
															 argv, 
															 spec_fp, 
															 token_buf);

						if (keyword4 == DATA) 
						{
							RISlod_ptr_struct_ptr->bthnode_ptr->tab_select = SOME;
							RISlod_ptr_struct_ptr->bthnode_ptr->def_data_select = BOTH;
							RISlod_ptr_struct_ptr->bthnode_ptr->exist_tab_select = DO_NOT_IGNORE;
							RISlod_ptr_struct_ptr->bthnode_ptr->clear_tab_select = NO;
							tab_fnd = TRUE;
						}
						else
						{
							RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
							TERMINATE_RISLOAD
						}
					}
					else
					{
						RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
						TERMINATE_RISLOAD
					}
				}
				else
				{
					RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
					TERMINATE_RISLOAD
				}

				spec_type3 = RISlod_parse_ind_rel(TABLE, 
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf);
				break;
			case CLEAR:
				if (tab_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_TABLE_SPEC_TWICE);
					TERMINATE_RISLOAD
				}

				keyword2 = RISlod_fetch_analyze_spec(argc, 
													 argv, 
													 spec_fp, 
													 token_buf);
				if (keyword2 == TABLE)
				{
					keyword3 = RISlod_fetch_analyze_spec(argc, 
														 argv, 
														 spec_fp, 
														 token_buf);

					if (keyword3 == WITH) 
					{
						keyword4 = RISlod_fetch_analyze_spec(argc, 
															 argv, 
															 spec_fp, 
															 token_buf);

						if (keyword4 == DATA) 
						{
							RISlod_ptr_struct_ptr->bthnode_ptr->tab_select = SOME;
							RISlod_ptr_struct_ptr->bthnode_ptr->def_data_select = BOTH;
							RISlod_ptr_struct_ptr->bthnode_ptr->exist_tab_select = RIS_IGNORE;
							RISlod_ptr_struct_ptr->bthnode_ptr->clear_tab_select = YES;
							tab_fnd = TRUE;
						}
						else
						{
							RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
							TERMINATE_RISLOAD
						}
					}
					else
					{
						RISlod_parse_err_handler(RISUTL_E_WITH_DATA_MISSING);
						TERMINATE_RISLOAD
					}
				}
				else
				{
					RISlod_parse_err_handler(RISUTL_E_SYNTAX_ERROR_TABLE);
					TERMINATE_RISLOAD
				}

				spec_type3 = RISlod_parse_ind_rel(TABLE, 
												  argc, 
												  argv, 
												  spec_fp, 
												  token_buf);
				break;
			case EVERY_THING:
				if (tab_fnd || indx_fnd || view_fnd || grant_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_ARGUMENT);
					TERMINATE_RISLOAD
				}

				RISlod_ptr_struct_ptr->bthnode_ptr->tab_select = ALL;
				RISlod_ptr_struct_ptr->bthnode_ptr->def_data_select = BOTH;
				RISlod_ptr_struct_ptr->bthnode_ptr->exist_tab_select = RIS_IGNORE;
				RISlod_ptr_struct_ptr->bthnode_ptr->clear_tab_select = NO;

				RISlod_ptr_struct_ptr->bihnode_ptr->indx_select = ALL;

				RISlod_ptr_struct_ptr->bvhnode_ptr->view_select = ALL;

				RISlod_ptr_struct_ptr->bghnode_ptr->grant_select = ALL;

				spec_type2 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

				LOD_DBG(("1. RISlod_parse_rel_option: end"));
				return(spec_type2);
			default:
				LOD_DBG(("2. RISlod_parse_rel_option: end"));
				return(spec_type2);
		}

		switch (spec_type3)
		{
			case TABLE:
			case INDEX:
			case VIEW:
			case GRANT:
				use_pre_spec = TRUE;
				break;
			case SCHEMA:
			case NO_MORE_SPEC:
			case END_OF_SPEC_FILE:
			case COMMIT_INTERVAL:
			case BAD_FILE:
			case DEBUG_FLAG:
			case DELIMITOR:
			case ENABLE_DB:
			case FILE_MODE:
			case LOG_FILE:
			case MAIN_FILE:
			case NON_ANSI_MODE:
			case PRESERVE_BLANKS:
				return(spec_type3);
			case SPEC_FILE:
				RISlod_parse_err_handler(RISUTL_E_UNEXPECTED_F_OPTION);
				TERMINATE_RISLOAD
			default:
				RISlod_parse_err_handler(RISUTL_E_INVALID_ARGUMENT);
				TERMINATE_RISLOAD
		}
	}
}

		
extern void RISlod_parse_cmd_line(
	int				argc,
	char			*argv[])
{
	int			spec_type1 = 0;
	int			spec_type2 = 0;
	int			use_pre_spec;
	short int		bfile_fnd;
	short int		commit_fnd;
	short int		debugflag_fnd;
	short int		delim_fnd;
	short int		enable_db_fnd;
	short int		filemode_fnd;
	short int		lfile_fnd;
	short int		mfile_fnd;
	short int		non_ansi_fnd;
	short int		preserve_blanks_fnd;
	short int		sfile_fnd;
	short int		sch_spec_fnd;
	char			token_buf[RIS_MAX_PATH_SIZE + 3];
	FILE			*spec_fp;	
	char *dot;
	short int		num_relations=0;


	LOD_DBG(("RISlod_parse_cmd_line: argc %d argv 0x%x\n", argc, argv));


	use_pre_spec = FALSE;
	sch_spec_fnd = FALSE;
	commit_fnd = FALSE;
	bfile_fnd = FALSE;
	debugflag_fnd = FALSE;
	delim_fnd = FALSE;
	enable_db_fnd = FALSE;
	filemode_fnd = FALSE;
	lfile_fnd = FALSE;
	mfile_fnd = FALSE;
	non_ansi_fnd = FALSE;
	preserve_blanks_fnd = FALSE;
	sfile_fnd = FALSE;
	spec_fp = (FILE *) NULL;

	for(;;)
	{ 
		if (use_pre_spec)
		{
			spec_type1 = spec_type2;
			use_pre_spec = FALSE;
		}
		else
			spec_type1 = RISlod_fetch_analyze_spec(argc,
												   argv,
												   spec_fp,
												   token_buf);

		switch(spec_type1)
		{
		  case SCHEMA:

			dot = strchr(token_buf, '.');
			if (dot)
			{
				*dot = '\0';
				dot++;
			}

			/* Check the schema name and make a bsnode */
			if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
			{
				RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
				TERMINATE_RISLOAD
			}
			RISlod_create_bsnode(token_buf);
			sch_spec_fnd = TRUE;	

			/* If necessary, remove the password part from the schema name */
			RISlod_ptr_struct_ptr->bsnode_ptr->num_sch_pwd = 0;

			if (dot)
			{
				RIScom_strncpy(RISlod_ptr_struct_ptr->bsnode_ptr->sch_pwd_matrix[0],
							   dot, RIS_MAX_ID_SIZE);
				RISlod_ptr_struct_ptr->bsnode_ptr->num_sch_pwd++;
			}


			/*
			** Get passwords. Max 3 passwords (schema, osuser and dbuser).
			** USER name is also allowed (for "default schema" to a secure schema)
			*/
			for(;;)
			{
				spec_type1 =
                    RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);

				if (spec_type1 == PASSWORD)
				{
					if( RISlod_ptr_struct_ptr->bsnode_ptr->num_sch_pwd ==
					   MAX_NUM_PWD )
					{
						/* Only MAX_NUM_PWD allowed */
						break;
					}
					RISlod_ptr_struct_ptr->bsnode_ptr->num_sch_pwd++;

			strcpy(RISlod_ptr_struct_ptr->bsnode_ptr-> sch_pwd_matrix[RISlod_ptr_struct_ptr->bsnode_ptr->num_sch_pwd-1], token_buf+1);
				}
				else if (spec_type1 == RELATION_NAME)
				{
				     num_relations++;
					if (strlen((token_buf + 1)) >= RIS_MAX_ID_SIZE)
					{
					   RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
					   TERMINATE_RISLOAD
					}
					
					if (num_relations == 1) /*user name first */
				        {
						strcpy(RISlod_ptr_struct_ptr->bsnode_ptr->user_name,
						   token_buf);
					}
					else /*secure schema database name second */
					{
						strcpy(RISlod_ptr_struct_ptr->bsnode_ptr->db_name,
						   token_buf);
					}
				        RISlod_ptr_struct_ptr->bsnode_ptr->num_relations = num_relations;
				}
				else
				{
				   break;
				}
			}
			if (RISlod_debug)
			{
				int i;
				RIScom_output_debug("\tnum_sch_pwd=%d\n",
									RISlod_ptr_struct_ptr->bsnode_ptr->num_sch_pwd);
				for(i=0; i<MAX_NUM_PWD; i++)
				{
					RIScom_output_debug("\tPASS[%d]='%s'\n", i,
										RISlod_ptr_struct_ptr->bsnode_ptr->sch_pwd_matrix[i]);
				}
			}

			if( spec_type1 == RENAME )
			{
				spec_type1 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
				if( spec_type1 != RELATION_NAME )
				{
					RISlod_parse_err_handler(RISUTL_E_NEW_SCH_EXPECTED);
					TERMINATE_RISLOAD
				}
				
				if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
					TERMINATE_RISLOAD
				}
				
				strcpy(RISlod_ptr_struct_ptr->bsnode_ptr->new_sch_name,token_buf);
				
				/* Get the password for the new schema name */
				spec_type1 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
				if( spec_type1 == PASSWORD )
				{
					if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
					{
						RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
						TERMINATE_RISLOAD
					}
					strcpy(RISlod_ptr_struct_ptr->bsnode_ptr->new_sch_pwd,token_buf+1);
					spec_type1 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
				} /* PASSWORD */

				/* Get the USER clause (required for secure schema) */
				if (spec_type1 == RENAME_USER)
				{
					/* Get the user name */
					spec_type1 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
					if( spec_type1 != RELATION_NAME )
					{
						RISlod_parse_err_handler(RISUTL_E_NEW_SCH_EXPECTED);
						TERMINATE_RISLOAD
					}

					if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
					{
						RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
						TERMINATE_RISLOAD
					}

					strcpy(RISlod_ptr_struct_ptr->bsnode_ptr->new_user_name,token_buf);

					/* Get the user password */
					spec_type1 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
					if( spec_type1 == PASSWORD )
					{
						if (strlen(token_buf) >= RIS_MAX_ID_SIZE)
						{
							RISlod_parse_err_handler(RISUTL_E_INVALID_ID_SIZE);
							TERMINATE_RISLOAD
						}
						strcpy(RISlod_ptr_struct_ptr->bsnode_ptr->new_user_pwd,token_buf+1);
						spec_type1 = RISlod_fetch_analyze_spec(argc, argv, spec_fp, token_buf);
					} /* PASSWORD */
				} /* USER */
			} /* RENAME */
			
			spec_type2 = RISlod_parse_rel_option(argc, 
												 argv, 
												 spec_fp, 
												 token_buf,
												 spec_type1);
			
			switch(spec_type2)
			{
			  case SCHEMA:
			  case NO_MORE_SPEC:
			  case END_OF_SPEC_FILE:
			  case BAD_FILE:
			  case COMMIT_INTERVAL:
			  case DEBUG_FLAG:
			  case DELIMITOR:
			  case ENABLE_DB:
			  case FILE_MODE:
			  case LOG_FILE:
			  case MAIN_FILE:
			  case NON_ANSI_MODE:
			  case PRESERVE_BLANKS:
				use_pre_spec = TRUE;
				break;
			  case SPEC_FILE:
				RISlod_parse_err_handler(RISUTL_E_UNEXPECTED_F_OPTION);
				TERMINATE_RISLOAD
				  default:
				RISlod_parse_err_handler(RISUTL_E_INVALID_ARGUMENT);
				TERMINATE_RISLOAD
				}
			break;
		  case DEBUG_FLAG:
			if (debugflag_fnd)
			{
				RISlod_parse_err_handler(RISUTL_E_G_OPTION_TWICE);
				TERMINATE_RISLOAD
				}

			 	debugflag_fnd = TRUE;
				RISlod_debug = 1;
				break;
			case ENABLE_DB:
				if (enable_db_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_E_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

			 	enable_db_fnd = TRUE;

				spec_type2 = RISlod_parse_exec_enforce_db(argc, 
													 	 argv, 
													 	 spec_fp, 
													 	 token_buf);

				switch(spec_type2)
				{
					case SCHEMA:
					case NO_MORE_SPEC:
					case END_OF_SPEC_FILE:
					case BAD_FILE:
					case COMMIT_INTERVAL:
					case DEBUG_FLAG:
					case DELIMITOR:
					case FILE_MODE:
					case LOG_FILE:
					case MAIN_FILE:
					case SPEC_FILE:
					case PRESERVE_BLANKS:
						use_pre_spec = TRUE;
					break;
					case ENABLE_DB:
						RISlod_parse_err_handler(RISUTL_E_E_OPTION_TWICE);
						TERMINATE_RISLOAD
					break;
					default:
						RISlod_parse_err_handler(RISUTL_E_INVALID_ARGUMENT);
						TERMINATE_RISLOAD
				}

				use_pre_spec = TRUE;
				break;
			case FILE_MODE:
				if (filemode_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_M_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				if (strlen(token_buf) != 1)
				{
					RISlod_parse_err_handler(RISUTL_E_ILLEGAL_FILE_MODE);
					TERMINATE_RISLOAD
				}
					
				if (isupper(token_buf[0]))
				{
					RISlod_filemode = _tolower(token_buf[0]);
				}
				else
				{
					RISlod_filemode = token_buf[0];
				}

			 	filemode_fnd = TRUE;
				break;
			case MAIN_FILE:
				if (mfile_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_I_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				if (strlen(token_buf) >= RIS_MAX_PATH_SIZE)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_PATH_SIZE);
					TERMINATE_RISLOAD
				}
					
				strcpy(RISlod_mfile,token_buf);

				/*
				RISlod_in_fp = RISlod_batch_open_file('m', token_buf);
				*/
				mfile_fnd = TRUE;
				break;
			case NON_ANSI_MODE:
				if (non_ansi_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_N_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				non_ansi_fnd = TRUE;
				break;
			case PRESERVE_BLANKS:
				if (preserve_blanks_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_P_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				preserve_blanks_fnd = TRUE;
				break;
			case LOG_FILE:
				if (lfile_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_L_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				if (strlen(token_buf) >= RIS_MAX_PATH_SIZE)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_PATH_SIZE);
					TERMINATE_RISLOAD
				}
					
				strcpy(RISlod_lfile,token_buf);
				/*
				RISlod_log_fp = RISlod_batch_open_file('l', token_buf);
				*/
			 	lfile_fnd = TRUE;
				break;
			case BAD_FILE:
				if (bfile_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_B_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				if (strlen(token_buf) >= RIS_MAX_PATH_SIZE)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_PATH_SIZE);
					TERMINATE_RISLOAD
				}
					
				strcpy(RISlod_bfile,token_buf);
				/*
				RISlod_bad_fp = RISlod_batch_open_file('b', token_buf);
				*/
			 	bfile_fnd = TRUE;
				break;
			case DELIMITOR:
				if (delim_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_D_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				if (strlen(token_buf) != 1)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_DELIMITER);
					TERMINATE_RISLOAD
				}
					
				RISlod_delimiter = token_buf[0];

			 	delim_fnd = TRUE;
				break;
			case COMMIT_INTERVAL:
				if (commit_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_C_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				RISlod_commit_interval = atoi(token_buf);
				if( RISlod_commit_interval <= 0 )
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_COMMIT);
					TERMINATE_RISLOAD
				}
			 	commit_fnd = TRUE;
				break;
			case SPEC_FILE:
				if (sfile_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_F_OPTION_TWICE);
					TERMINATE_RISLOAD
				}

				if (sch_spec_fnd)
				{
					RISlod_parse_err_handler(RISUTL_E_UNEXPECTED_F_OPTION);
					TERMINATE_RISLOAD
				}

				if (strlen(token_buf) >= RIS_MAX_PATH_SIZE)
				{
					RISlod_parse_err_handler(RISUTL_E_INVALID_PATH_SIZE);
					TERMINATE_RISLOAD
				}
					
				spec_fp = RISlod_batch_open_file('s', token_buf);
				LOD_DBG(("spec_fp 0x%x\n",spec_fp));
				sfile_fnd = TRUE;
				break;
			case NO_MORE_SPEC:
				/* enabled databases */
				if (!enable_db_fnd)
				{
					/* do what check what is default */;
				}
			
				/* file mode */
				if (!filemode_fnd)
				{
					RISlod_filemode = 'e';
				}

				/* ansi mode */
				RISlod_ansi_mode(!non_ansi_fnd);

				/* preserve_blanks */
				RISlod_blankstrip_mode(!preserve_blanks_fnd);

				/* dump file */
				if (! mfile_fnd)
				{
					strcpy(RISlod_mfile,"ris.dmp");
				}
				RISlod_in_fp = RISlod_batch_open_file('m', RISlod_mfile);

				/* log file */
				if (! lfile_fnd)
				{
					strcpy(RISlod_lfile,"ris.log");
				}
				RISlod_log_fp = RISlod_batch_open_file('l', RISlod_lfile);

				/* bad file */
				if (! bfile_fnd)
				{
					strcpy(RISlod_bfile,"ris.bad");
				}
				RISlod_bad_fp = RISlod_batch_open_file('b', RISlod_bfile);

				/* delimiter */
				if (! delim_fnd)
				{
					RISlod_delimiter = '\'';
				}

				/* commit */
				if (! commit_fnd)
				{
					RISlod_commit_interval = DEFAULT_COMMIT_INTERVAL;
				}
				LOD_DBG(("1. RISlod_parse_cmd_line: end"));
				return;
			case END_OF_SPEC_FILE:
				spec_fp = (FILE *) NULL;
				break;
			default:
			{
				RISlod_parse_err_handler(RISUTL_E_INVALID_ARGUMENT);
				TERMINATE_RISLOAD
			}
		}
	} /* for (;;) */
}	
