/************************************************************************/
/*									*/
/*  Program: extrpartsrf.u	    Macro: ems$place_partial_surface	*/
/*									*/
/*  Defined in: EMSascmacros.h						*/
/*									*/
/*  Comments  : Can extract only rectangular shapes out of any surface. */
/*		The first two points indicate the diagonal extremes and */
/*		the 3rd point resolves the conflict that is likely to   */
/*		arise in the case of a closed surface.			*/
/*									*/
/************************************************************************/
#include <stdio.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "ci_easy.h"
#include "go.h"
#include "grdpbmacros.h"
#include "dpmacros.h"
#include "lcdef.h"
#include "EMSascmacros.h"
#include "EMSasnuc.h"
#include "EMSasopts.h"

extern	int	GRdpb_get();
extern	int	DPmacupdate();

main ()
{
  /* Declare variables here : */
     struct EMSobject_info    surface;
     struct EMSpoint_info     start_point;
     struct EMSpoint_info     mid_point;
     struct EMSpoint_info     end_point;
     struct GRvg_construct    const_list;
     GRobjid                  partsf_obj;

     struct IGRdisplay        disp_buffer;
     IGRboolean               trimming_required;
     IGRshort                 disp_level;
     IGRboolean               assoc_placement;
     IGRushort                options;
     IGRpoint                 start_pt;
     IGRpoint                 mid_pt;
     IGRpoint                 end_pt;
     IGRint                   sts, num_bytes;
     IGRlong                  msg_loc, nbytes_ret;

  /* End of variable declarations */

    message (" Extract Partial Surface ") ;

    /*Get the object */

    ci$locate ( obj=&surface.grid.objid,
		osnum = &surface.grid.osnum,
	        md_env=&surface.env,
	        prompt="Identify surface",
	        acc_prompt="Accept/Reject ",
	        relocate_prompt="Surface not Found",
		classes = "EMSsubbs",
		owner_action = LC_RIGID_COMP | LC_FLEX_COMP
	      );

    ci$get(prompt = "Enter the start point on the surface",
           point  = start_pt);

    start_point.pt[0] = start_pt[0];
    start_point.pt[1] = start_pt[1];
    start_point.pt[2] = start_pt[2];
    start_point.type  = EMSdatainfo_numeric;

    ci$get(prompt = "Enter the end point on the surface",
           point  = end_pt);
  
    end_point.pt[0] = end_pt[0];
    end_point.pt[1] = end_pt[1];
    end_point.pt[2] = end_pt[2];
    end_point.type  = EMSdatainfo_numeric;

    ci$get(prompt = "Enter the mid point on the surface",
           point  = mid_pt);
  
    mid_point.pt[0] = mid_pt[0];
    mid_point.pt[1] = mid_pt[1];
    mid_point.pt[2] = mid_pt[2];
    mid_point.type  = EMSdatainfo_numeric;

    ci$get ( value = trimming_required,
	     prompt = "Is trimming required ? Yes = 1; No = 0"
	   );

    num_bytes = sizeof(struct IGRdisplay);
    gr$get_active_display ( msg = &msg_loc, sizbuf = &num_bytes,
			    nret= &nbytes_ret, buffer = &disp_buffer );
    gr$get_active_level   ( buffer = &disp_level );
    
    const_list.msg        = &msg_loc;
    const_list.env_info   = &surface.env;
    const_list.display    = &disp_buffer;
    const_list.properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    const_list.newflag    = FALSE;
    const_list.level      = disp_level;
    const_list.class_attr = NULL;
    const_list.name       = NULL;
    const_list.geometry   = NULL;

    gr$get_associative_flag ( buffer = &assoc_placement );
    
    if ( ! assoc_placement )
         options = EMSasconst_notassociative;
    else
         options = NULL;

    sts = ems$place_partial_surface( msg               = &msg_loc,
                                     surface           = &surface,
                                     start_point       = &start_point,
                                     end_point         = &end_point,
                                     mid_point         = &mid_point,
                                     trimming_required = trimming_required,
				     options           = options,
                                     construction_list = &const_list,
                                     partsf_obj        = &partsf_obj);
    if (!(sts & msg_loc & 1)) goto wrapup;

    dp$update ( msg   = &msg_loc );
    exit;
wrapup:
	status(" Severe failure ");
	exit;
}
