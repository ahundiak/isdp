/*	FILE:		opl.c

	DESCRIPTON:
   			Given a command line consisting of common object files
			and or archive libraries, "opl" generates a file
			containing information describing class and relation
			definitions.  The output by default is OMclassinit.C.

        CHANGE HISTORY:
		cgp001	11-nov-1985
			version 2.0. Reserve OM_K_NUM_META_RELATIONS at top of 
			relation table, thus allowing OM to create relations 
			in addition to user defined ones. Put version number
			data in global variables. 

		cgp002	20-nov-1985
			add opl invocatin flags

		cgp003	25-jan-1986
			v2.1 - ignore OM metaclass names. insure no
			repeats in list. use OMminimum.h, not OMtypedef.h

		gja001	18-jun-1986
			re-wrote using common object and archive file routines
			ld*(3X).

		gja002	25-jul-1986
			expand list of meta classes to encoporate all known
			meta classes.

		jhm	27-aug-1986
			removed code to process relations

		jhm	2-sep-1986
			added new metaclasses - OMbtree, OMindex, 
			OMNamObjDir, OMlnkbtree
			changed default output file name

		geo     20-mar-1987
		      	added new metaclasses - QYchantype,  QYclassdef, 
			QYcode,  QYdefault,  QYdictionary,  QYfielddef, 
			QYmsgdef,  QYrestrict,  QYtype,  QYvardef.
			
                rme     06-apr-1987
                        added newmetaclasses - OMTag, OMTagCon for
                        tagged object and tagged connections.

		geo	18-jun-1987
			add shared memory extra work & add -m option
			to create .._class_id & .._method_index args.
			for metaclasses. remove dictionary metaclasses
			since oden separated from libOM as of OM4.3.

		geo	06-jul-1987
			remove opl version numbers
			2nd output file for OM_GA_class_defns (not shared)
			add initialization function

                ems     31-may-1988
                        remove OMSymCon, OMNamObjDir, and OMdirectory from
                        the metaclass list.

                ems     28-jul-1988
                        add application version mods. (-a option).

		rme	26-oct-1988
			add split option

		rme	5-may-1989
			do not make a defining entry for classid and
			method index if a defining entry already exists.

		rme	16-may-1989
			remove DIbobpt class

		saw	26-jun-1990
			Add -d option for dynamic loading of a product.
			This generates an OMprodinit.C file (or 3
			such files if split mode specified) containing
			structures normally generated by the -a switch
			and the default opl mode, except structures are
			null-terminated in this case.  Structure names
			are prefixed by the product name rather than OM.

		saw	May 1991  Port to SunOS

		ems	1/15/92   Add support for the verbose option in the
			Sun section of the code.

		saw	Sept 1992 Port to Silicon Graphics

		saw	Apr 1993 Port to SunOS 5 (Solaris 2; SVR4)
                        Switches on #ifdef statements:
                        CLIX = Ingr version of Unix System V, Rel 3
                        IRIX = SGI version of Unix System V, Rel 3
                        SUNOS4 = Sun BSD Unix, Version 4.1.x
                        SUNOS5 = Sun Unix System V, Rel 4
                        SVR3 = Unix System V, Rel 3 (CLIX && IRIX)
                        SVR4 = Unix System V, Rel 4 (SUNOS5)
                        BSD = Sun Berkeley Unix, Version 4.1.x (SUNOS4)
                        SYSV = SVR3 && SVR4 (CLIX && IRIX && SUNOS5)
                        Note:
                        IRIX and SUNOS5 symbols from file symbol tables
                        are not preceded by an underbar as symbols from
                        CLIX and SUNOS4 files are.

		saw	May 1993 Similar changes for porting to IRIX 5.x,
			which is also SVR4.  Add switches IRIX4 and IRIX5.
*/

#include "exsysdep.h"
#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifdef SVR3
#include <filehdr.h>
#include <syms.h>
#ifdef __STDC__
#ifdef CLIX
#include <linenum.h>
#endif  /* CLIX */
#include <scnhdr.h>
#endif  /* __STDC__ */
#include <ldfcn.h>
#endif

#if defined(BSD)
#include <fcntl.h>
#include <a.out.h>
#include <stab.h>
#include <sys/mman.h>
#include <ranlib.h>
#include <ad.h>
#endif

#if defined(SVR4)
#include <fcntl.h>
#include <libelf.h>
#endif

#if defined(IRIX5)
#include <sym.h>
#include <symconst.h>
#endif

#include "hash.h"	/* has hashing functions & definitions (LIBXC) */
#include "version.h"
#include "OMlimits.h"

#define NULL 	0
#define TRUE	1
#define FALSE	0
#define HSHTBLSIZE  500
#define HSHTBLBKLEN   3
#define MAXAPPVERLEN  33   /* account for leading underbar */

#ifdef clipper
#define MAGIC_VALID(M)  ( (M) == CLIPPERMAGIC )
#endif

#ifdef CLIX
#define _isDefiningEntry(S)	((S).n_scnum)

#elif defined(IRIX4)
#define _isDefiningEntry(S) \
	(((S).sc != scUndefined) && ((S).sc != scSUndefined) && \
	 ((S).sc != scNil))

#elif defined(IRIX5)
#define _isDefiningEntry(S) \
	(((S)->sc != scUndefined) && ((S)->sc != scSUndefined) && \
	 ((S)->sc != scNil))

#elif defined(SUNOS5)
#define _isDefiningEntry(S) \
 	((S)->st_size)
#endif

#if defined(SUNOS4)
struct filelist
{
   char              *file;
   ADFILE            *adptr;
   struct filelist   *nextitem;
};
#endif

char	*OPL_version = "2.4.0";


extern	int	optind;		/* values set up by getopt(3c) */
extern	char	*optarg;
extern  int	hashc();	/* hashing index function for strings */

extern	char	*strchr();
extern	char	*strcpy();

struct hash_entry
{
   int  flags;		/* non-zero if found a defining entry for this symbol. */
   char  name[1];
};


	/*  If names are added to meta class list then it is imperative that
	 *  the parameter "LAST_NDX" be updated to reflect the actual last
	 *  index.  Also add to _<metaclass>_OM_class_init list.
	 */

#define LAST_NDX 	28

char *metaclass_list[]=	   { "Root",
			     "OMCluster", 
			     "OMISO",
			     "OMObjSpace",
			     "OMMOSDOS",
			     "OMTransOS",
			     "OMFiledOS",
			     "OMindex",
			     "OMbtree",
			     "OMlnkbtree",
			     "OMMOSD",
			     "OMrtree",
			     "OMGroup",
			     "OMOSCO", 
                             "OMTag",
                             "OMTagCon",
			     "OMSupGroup",
			     "GRoup",
			     "GRoups",
			     "DIbtree",
			     "DIbstob",
			     "DIbst",
			     "DIrectory",
			     "DIstorage",
			     "IGRdir",
			     "DImaster",
			     "DIbstgr",
			     "DIlink",
                             "DIroot"};

static char	*findPastClassName(methodIndexName)
char	*methodIndexName;
{
	char	*underbar = 0;
	char	*src;

	src = methodIndexName;
	underbar = strchr(src, '_');
	while (underbar)
	{
		if (!strncmp(underbar, "_OPP_", 5))
			return underbar;
		src = ++underbar;
		underbar = strchr(src, '_');
	}
	return methodIndexName;
}

/*
	Not_a_meta_class determines if the given name matches any of the
        listed meta class names.  These are to be ignored.
*/

int Not_a_meta_class_init (name)		
char	*name;
{
  static char	*nm_list[]={ "_Root_OM_class_init",
			     "_OMCluster_OM_class_init", 
			     "_OMISO_OM_class_init",
			     "_OMObjSpace_OM_class_init",
			     "_OMMOSDOS_OM_class_init",
			     "_OMTransOS_OM_class_init",
			     "_OMFiledOS_OM_class_init",
			     "_OMindex_OM_class_init",
			     "_OMbtree_OM_class_init",
			     "_OMlnkbtree_OM_class_init",
			     "_OMMOSD_OM_class_init",
			     "_OMrtree_OM_class_init",
			     "_OMGroup_OM_class_init",
			     "_OMOSCO_OM_class_init", 
                             "_OMTag_OM_class_init",
                             "_OMTagCon_OM_class_init",
			     "_OMSupGroup_OM_class_init",
			     "_GRoup_OM_class_init",
			     "_GRoups_OM_class_init",
			     "_DIbtree_OM_class_init",
			     "_DIbstob_OM_class_init",
			     "_DIbst_OM_class_init",
			     "_DIrectory_OM_class_init",
			     "_DIstorage_OM_class_init",
			     "_IGRdir_OM_class_init",
			     "_DImaster_OM_class_init",
			     "_DIbstgr_OM_class_init",
			     "_DIlink_OM_class_init",
			     "_DIroot_OM_class_init"};

  register int		lst_ndx;

  for( lst_ndx=LAST_NDX; lst_ndx >=0; lst_ndx-- )
#if defined(IRIX) || defined(SUNOS5)
	    if ( !strcmp(name, &nm_list[lst_ndx][1] ) ) return (0);
#else
	    if ( !strcmp(name, nm_list[lst_ndx] ) ) return (0);
#endif
     
  return (1);
}

/*
	Not_a_meta_class determines if the given name matches any of the
        listed meta class names.  These are to be ignored.
*/

int Not_a_meta_class (name)
char	*name;
{
  register int		lst_ndx;

  for( lst_ndx=LAST_NDX; lst_ndx >=0; lst_ndx-- )
	    if ( !strcmp(name, metaclass_list[lst_ndx] ) ) return (0);
     
  return (1);
}

/*
	Metaclasses builds output file for metaclasses' shared
	variables.  This is the -m option.
*/

int  Metaclasses (metas_out)
  FILE			*metas_out;
{

  register int		lst_ndx;

  for( lst_ndx=0; lst_ndx<=LAST_NDX; lst_ndx++ )
      fprintf(metas_out,"OMuword %s%s%s = 65535;\n", "OPP_",
			metaclass_list[lst_ndx], "_class_id");
  fprintf(metas_out,"\n");

  return (1);
}


static char applver[]    ="_appl_version_id";
static char OMclassinit[]="_OM_class_init";
static char methodindex[]="_method_index";
static char classid[]    ="_class_id";	/* must have prefix OPP_ */

static char	  classname[13];
int		  classnamelen,
                  metasonly, apponly, dload;
char	          *pastclassname;
struct hash_entry *new_entry, *old_entry;
char              *symbol, *app_table[MAXNUMAPPVER];
int               length, OMclassinit_len, methodindex_len, classid_len,
                  applver_len, numappver=0;
HASHTABLE         *classinittbl=NULL;
HASHTABLE         *classidtbl=NULL;
HASHTABLE         *methodindextbl=NULL;


#ifdef SUNOS4
struct filelist * openobject(filename)
char  *filename;
{
   ADFILE            *ap;
   struct filelist   *listptr;

   if ((ap = adopen(filename, NULL)) == NULL)
   {
      printf("cannot open %s\n", filename);
      return(NULL);
   } 
   if (!(listptr = (struct filelist *) calloc(1, sizeof(struct filelist))))
   {
      printf("cannot allocate memory for file list\n");
      exit();
   }
   listptr->file = filename;
   listptr->adptr = ap;
   listptr->nextitem = NULL;
   return(listptr);
}
#endif

main(argc, argv)
int   argc;
char  *argv[];
{
   FILE              *opl_out=NULL;
   char		     *split_name1, *split_name2 = NULL;
   char              *split_name3 = NULL;
   int		     reportonly, verbose, split, arg_num,
                     ii, i, outspec = 0;

#ifdef SVR3
   LDFILE            *ldptr, *ldopen();
#ifdef CLIX
   SYMENT	     syment;
   int               symndx;
#endif
#ifdef IRIX4
   SYMR		     syment;
   long              symndx;
#endif
   char              *ldgetname();
#elif defined(SUNOS4)
   ADFILE            *adptr;
   struct filelist   *listptr, *nextptr, *listhead = NULL;
#endif

   char		     product[32], filename[132], output_file[132], option;

   strcpy(output_file, "OMclassinit.C");  /* default output file name */
   strcpy(product, "OM_GA");
   metasonly = reportonly = verbose = apponly = split = dload = FALSE;

   while (EOF != (option = getopt(argc, argv, "ad:nvVmo:s")))
   {
      switch (option)
      {
         case '?':
            printf ("Usage: opl [-vVnms] [-d product] [-o outfile] infile_list\n");
            printf ("-v makes opl verbose\n");
            printf ("-V reports opl version before doing work\n");
            printf ("-n just reports located classes, no output file created\n");
            printf ("-m allocates metaclass shared varibles only\n");
            printf ("-s split output file into three files\n");
            printf ("-o outfile specifies output file (def OMclassinit.c)\n");
            printf ("-a processes application init files\n");
            printf ("-d <productname> processes product init file for dloading\n");
            exit();
            break;
         case 'a':
            apponly = TRUE;
            if (!outspec)
               strcpy(output_file, "OMapplinit.C");
            break;
         case 'd':
            /* Generate data structures required by som_dload_class
             * to dynamically load and initialize a product
             */
            dload = TRUE;
            apponly = metasonly = FALSE;
            strcpy(product, optarg);
            if (!outspec)
               strcpy(output_file, "OMprodinit.C");
            break;
         case 'V':
            printf("opl version %s\n", OPL_version);
            break;
         case 'v':
            verbose = TRUE;
            break;
         case 'n':
            verbose = reportonly = TRUE;
            break;
         case 'm':
            metasonly = TRUE;
            strcpy(output_file, "OMmetas.c");
            break;
         case 'o':
            outspec = 1;
            strcpy(output_file, optarg);
            break;
         case 's':
            split = TRUE;
            break;
         default:
            break;
      }
   }
  

   applver_len     = strlen(applver);
   OMclassinit_len = strlen(OMclassinit);
   methodindex_len = strlen(methodindex);
   classid_len     = strlen(classid);

   if (!apponly)
   {
      /* create 3 hash tables: classinit, methodindex & classid */

      if (!(classinittbl = hashinit(struct hash_entry, HSHTBLSIZE, 
         hashc, strcmp, name[0], VLREC | NOMEM)))
      {
         printf("\nError from creating hash table for classinit\n");
         exit();
      }
      if (!(classidtbl = hashinit(struct hash_entry, HSHTBLSIZE, 
         hashc, strcmp, name[0], VLREC | NOMEM)))
      {
         printf("\nError from creating hash table for classid\n");
         exit();
      }
      if (!(methodindextbl = hashinit(struct hash_entry, HSHTBLSIZE, 
         hashc, strcmp, name[0], VLREC | NOMEM)))
      {
         printf("\nError from creating hash table for methodindex\n");
         exit();
      }
   }


   /*
	For each of the files listed, be they object or archive files,
	search all symbol tables for some specific symbols and store
	them in the appropriate hash table.
        Below are code sections for processing SYSV files and SUNOS4
        files.  Within the SYSV section, CLIX and IRIX files are treated
        very similarly, but there is a separate code segment for SUNOS5
        (Elf) files.
    */

#ifdef SYSV
#ifdef SVR3
   /* Before examining this next section it would be wise to become
    * familiar with the special object and archive file routines found
    * in section 3X of the Programmer Reference Manual, especially how
    * ldopen works with archive files.
    */

   for (arg_num = optind; arg_num < argc; arg_num++)
   {
      strcpy(filename, argv[arg_num]);
      ldptr = NULL;
      do
      {
         if (ldptr = ldopen(filename, ldptr))
         {
#ifdef CLIX
            if (MAGIC_VALID(HEADER(ldptr).f_magic))
#endif
            {
               if (ldtbseek(ldptr) == FAILURE)
               {
                  printf("\nSymbol table has been stripped from object");
                  printf(" or object in %s\n", filename);
                  exit();
               }

               if (verbose)
                  printf("processing: %s\n", filename);

#if defined(CLIX)
               for (symndx=0; symndx < HEADER(ldptr).f_nsyms;)
#elif defined(IRIX4)
               for (symndx=0; symndx < SYMHEADER(ldptr).isymMax +
                  SYMHEADER(ldptr).iextMax; symndx++)
#else
#error Unknown SVR3 OS
#endif
               {
                  if (ldtbread(ldptr, symndx, &syment) == FAILURE)
                  {
                     printf("\nError obtaining entry from symbol table:");
                     printf(" %s:", filename);
                     printf(" INDEX = %d\n", symndx);
                     exit();
                  }

                  if (!(symbol = ldgetname(ldptr, &syment)))
                  {
                     printf("\nError getting name from symbol table entry:");
                     printf(" %s:", filename);
                     printf(" INDEX = %d\n",symndx);
                     exit();
                  }

#elif defined(SVR4)
/* elif defined(SUNOS5) */

   for (arg_num = optind; arg_num < argc; arg_num++)
   {
      Elf      *elf, *arf;
      int      fd;
      Elf_Cmd  cmd;

      strcpy(filename, argv[arg_num]);
      if (!(fd = open(filename, O_RDONLY)))
      {
         fprintf(stderr, "Could not open %s\n", filename);
         perror("");
         exit();
      }
      if (verbose)
          fprintf(stderr, "Processing %s\n", filename);
      if (elf_version(EV_CURRENT) == EV_NONE)
      {
         fprintf(stderr, "File version is out of date\n");
         exit();
      }
      cmd = ELF_C_READ;
      if (!(arf = elf_begin(fd, cmd, (Elf *) NULL))) /* In case of archive */
      {
         perror("elf_begin failed");
         exit();
      }
      while (elf = elf_begin(fd, cmd, arf))
      {
         Elf_Scn     *scn, *strscn;
         Elf32_Shdr  *shdr;
         Elf_Data    *data;
         char        *strtab, found;

         strtab = NULL;
         data = NULL;
         scn = strscn = NULL;
         found = 0;
         while (scn = elf_nextscn(elf, scn))
         {
            /* Search all sections for the symbol table */

            if ((shdr = elf32_getshdr(scn)) &&
               (shdr->sh_type == SHT_SYMTAB))
            {
               found = 1;
               break;
            }
         }
         if (found)
         {
            Elf32_Sym   *symtab;
            char        *strtab;

            /* Process symbol table */

            if (strscn = elf_getscn(elf, shdr->sh_link))
            {
               data = elf_getdata(strscn, NULL);
               strtab = (char *) data->d_buf;
               data = elf_getdata(scn, NULL);
               symtab = (Elf32_Sym *) data->d_buf;
               while ((size_t) symtab < (size_t) data->d_buf + data->d_size)
               {
                  if (symtab->st_name)
                  {
                     symbol = &strtab[symtab->st_name];
#else
#error Undefined SYSV O.S.
#endif

                  /* A symbol has been found in the symbol table.
                   * Determine whether it needs to be added to one of
                   * our hash tables, to be written to a file later.
                   */

                  length = strlen(symbol);
                  if ((apponly || dload) &&
                     ((length >= applver_len) &&
                     (!strcmp(&symbol[(length-applver_len)], applver))))
                  {
                     /* Search for application version stamps among
                      * the symbols in the symbol table
                      */

                     for (i=0; i<numappver; ++i)
                        if (!strncmp(symbol, app_table[i], MAXAPPVERLEN))
                           break;

                     if (i == numappver)
                     {
                        if (numappver == MAXNUMAPPVER) 
                        {
                           fprintf(stderr, "Exceeded maximum number of APPVER symbols\n");
                           exit(0);
                        }
                        if (!(app_table[numappver] = malloc(MAXAPPVERLEN)))
                        {
                           fprintf(stderr, "Out of dynamic memory\n");
                           exit(0);
                        }
                        strcpy(app_table[numappver], symbol);
                        ++numappver;
                     }
                  }
                  if (!apponly && (length >= OMclassinit_len))
                  {
                     if (!metasonly &&
                        !strcmp(&symbol[(length - OMclassinit_len)],
                           OMclassinit) &&
                        (Not_a_meta_class_init(symbol)) &&
                        !(hashlookup(classinittbl, symbol)))
                     {
                        if (!(new_entry = (struct hash_entry *)
                           malloc(length+ sizeof(struct hash_entry))))
                        {
                           fprintf(stderr, "Out of memory\n");
                           exit(0);
                        }
                        new_entry->flags = 0;
                        strcpy(new_entry->name, symbol);
                        if (!hashadd(classinittbl, new_entry, 0))
                        {
                           fprintf(stderr, "\nError from adding to classinit hash table\n");
                           fprintf(stderr, " %s:\n", filename);
                           exit();
                        }
                     }
                     else
                     {
                        if (!strcmp(&symbol[(length - methodindex_len)],
                           methodindex) &&
                           (! (old_entry = (struct hash_entry *)
                              hashlookup(methodindextbl, symbol)) ||
                           (old_entry->flags |=
#if defined(SVR3)
                              _isDefiningEntry(syment), 0)))
#elif defined(SUNOS5)
                              _isDefiningEntry(symtab), 0)))
#elif defined(IRIX5)
                              _isDefiningEntry((pSYMR) symtab), 0)))
#else
#error Unknown SYSV OS
#endif
                        {
#if defined(CLIX)
                           pastclassname = findPastClassName(symbol+1);
                           if ((classnamelen =
                              pastclassname - (symbol+1)) < 1)
#elif defined(IRIX) || defined(SUNOS5)
                           pastclassname = findPastClassName(symbol);
                           if ((classnamelen =
                              pastclassname - (symbol)) < 1)
#else
#error Unknown SYSV OS
#endif
                           {
                              fprintf(stderr, "\nError finding classname within methodindex variable in file: %s\n", filename);
                              fprintf(stderr, " %s:\n", filename);
                              exit();
                           }
#if defined(CLIX)
                           strncpy(classname, symbol+1, classnamelen);
#elif defined(IRIX) || defined(SUNOS5)
                           strncpy(classname, symbol, classnamelen);
#else
#error Unknown SYSV OS
#endif

                           classname[classnamelen] = '\0';
                           if ((metasonly) ||
                              Not_a_meta_class(classname))
                           {
                              if (!(new_entry = (struct hash_entry *)
                                 malloc(length + sizeof(struct hash_entry))))
                              {
                                 fprintf(stderr, "Out of memory\n");
                                 exit(0);
                              }
#if defined(SVR3)
                              new_entry->flags = _isDefiningEntry(syment);
#elif defined(SUNOS5)
                              new_entry->flags = _isDefiningEntry(symtab);
#elif defined(IRIX5)
                              new_entry->flags = 
                                 _isDefiningEntry((pSYMR) symtab);
#else
#error Unknown SYSV OS
#endif

                              strcpy(new_entry->name, symbol);
                              if ( ! hashadd(methodindextbl, new_entry, 0))
                              {
                                 fprintf(stderr, "Error from adding to methodindex hash table\n");
                                 fprintf(stderr, " %s:\n", filename);
                                 exit();
                              }
                           }
                        }
                        else
                        {
                           if (! metasonly &&
                              ! strcmp(&symbol[(length-classid_len)],
                              classid) &&
#if defined(CLIX)
                              ! strncmp(&symbol[0],"_OPP_",5) &&
#elif defined(IRIX) || defined(SUNOS5)
                              ! strncmp(&symbol[0],"OPP_",4) &&
#else
#error Unknown SYSV OS
#endif
                              (!(old_entry = (struct hash_entry *)
                                 hashlookup(classidtbl, symbol)) ||
                              (old_entry->flags |=
#if defined(SVR3)
                              _isDefiningEntry(syment), 0)))
#elif defined(SUNOS5)
                              _isDefiningEntry(symtab), 0)))
#elif defined(IRIX5)
                              _isDefiningEntry((pSYMR) symtab), 0)))
#else
#error Unknown SYSV OS
#endif
                            {
                              if ((classnamelen=(symbol+
#if defined(CLIX)
                                 (length-classid_len))-(symbol+5))<1)
                                 /* first 5 chars are _OPP_ */
#elif defined(IRIX) || defined(SUNOS5)
                                 (length-classid_len))-(symbol+4))<1)
                                 /* first 4 chars are OPP_ */
#else
#error Unknown SYSV OS
#endif
                              {
                                 fprintf(stderr, "\nError finding classname within classid variable in file: %s\n",filename);
                                 fprintf(stderr, " %s:\n", filename);
                                 exit();
                              }
#if defined(CLIX)
                              strncpy(classname, symbol+5, classnamelen);
#elif defined(IRIX) || defined(SUNOS5)
                              strncpy(classname, symbol+4, classnamelen);
#else
#error Unknown SYSV OS
#endif
                              classname[classnamelen] = '\0';
                              if (Not_a_meta_class(classname))
                              {
                                 new_entry = (struct hash_entry *)
                                    malloc(length +
                                    sizeof(struct hash_entry));
#if defined(SVR3)
                                 new_entry->flags = _isDefiningEntry(syment);
#elif defined(SUNOS5)
                                 new_entry->flags = _isDefiningEntry(symtab);
#elif defined(IRIX5)
                                 new_entry->flags =
                                    _isDefiningEntry((pSYMR) symtab);
#else
#error Unknown SYSV OS
#endif
                                 strcpy(new_entry->name, symbol);
                                 if ( ! hashadd(classidtbl, new_entry, 0))
                                 {
                                    printf("Error from adding to classid hash table\n");
                                    printf(" %s:\n", filename);
                                    exit();
                                 }
                              }
                           }
                        }
                     }
                  }
#if defined(SVR3)
#ifdef CLIX
                  symndx += syment.n_numaux + 1;  /* ignore AUX. ste's */
#endif
               }
            }
         }
         else
         {
            printf("\nOpen failure on %s, errno = %d\n",filename,errno);
            exit();
         }
      }
      while (ldclose(ldptr) == FAILURE);
   }  /* End of SVR3 symbol table processing */

#elif defined(SVR4)
                  }
                  symtab++;
               }  /* While symbols in symtab */
            }     /* if strtab */
         }        /* if symtab */
    
         cmd = elf_next(elf);
         elf_end(elf);
      }  /* while members in archive */
      elf_end(arf);
      close(fd);
   }  /* End of for loop and SUNOS5 symbol table processing */
   /* End of SYSV symbol table processing */
#endif

#elif defined(SUNOS4)

   /* Process Sun object files */

   for (arg_num = optind; (arg_num < argc) && !(listhead = (struct filelist *)
      openobject(argv[arg_num])); arg_num++) ;
   for (++arg_num, listptr = listhead; arg_num < argc; arg_num++)
   {
      if (listptr->nextitem = (struct filelist *) openobject(argv[arg_num]))
         listptr = listptr->nextitem;
   }

   if (listptr = listhead)
   {
      struct filelist *ptr, *last, *save;
      int             n, status;
      ADFILE          *newptr;
      char            name[513];

      last = NULL;
      for (listptr = listhead; listptr != NULL; listptr = save)
      {
         if (verbose) printf("processing: %s\n", listptr->file);
         save = listptr->nextitem;
         if (listptr->adptr->archive)
         {
            if ((newptr=adaopen(listptr->file, listptr->adptr))==NULL)
            {
               printf("cannot adaopen %s\n", listptr->file);
               exit();
            }
            else
            {
               int found = 0;
               do
               {
                  sprintf(name, "%s[%.14s]", listptr->file,
                     newptr->arhdr.ar_name);
                  if (!strncmp(newptr->arhdr.ar_name,"__.SYMDEF", 9))
                  {
                     found = 1;
                     continue;
                  }
                  if (!found)   /* __.SYMDEF must be first ar_name found */
                  {
                     printf("\nopl: You must run 'ranlib' on archive %s\n\n",
                        listptr->file);
                     exit();
                  }
                  if ((status = scan_syms(newptr, name)) != SUCCESS) 
                  {
                     adaclose(newptr);
                     break;
                  }
               } while(adclose(newptr) == FAILURE);
            }
         }
         else	/* Not an archive file */
         {
            if (!(listptr->adptr->ioptr = fopen( listptr->file, "r" )))
            {
               cfree( listptr->adptr );
               return NULL;
            }
            status = scan_syms(listptr->adptr, listptr->file);
            fclose(listptr->adptr->ioptr);
         }
         if (status != SUCCESS)
         {
            adaclose(listptr->adptr);
            if (last == NULL)
               listhead = save;
            else
               last->nextitem = save;
            free(listptr);
         }
         else
            last = listptr;
      }

      for (listptr = listhead; listptr != NULL; listptr = nextptr)
      {
         nextptr = listptr->nextitem;
/*         adaclose(listptr->adptr);*/
         free(listptr);
      }
   }

#else
#error Unknown UNIX type
#endif



   /*
	Generate the output file.  It is simply the genesis of various OM
	related data structures composed of the acquired symbols
	corresponding to class initialization.
	Reviewing the printf's should yield an overview good enough for
	the mere mortal.
   */

   if (!reportonly)
   {
      if (!split)
      {
         if (!(opl_out = fopen(output_file, "w")))
         {
            printf("\nOpen failure on %s\n",output_file);
            perror("");
            exit();
         }
      }  
      else
      {
         int  len = strlen(output_file);
         char *p_ext = (char *) strrchr(output_file, '.');

         if (p_ext)
            *p_ext = '\0';
         strcpy(split_name1 = malloc(len+2), output_file);
         strcat(split_name1, "1");
         if (p_ext)
         {
            *p_ext = '.';
            strcat(split_name1, p_ext);
            *p_ext = '\0';
         }
         strcpy(split_name2 = malloc(len+2), output_file);
         strcat(split_name2, "2");
         if (p_ext)
         {
            *p_ext = '.';
            strcat(split_name2, p_ext);
            *p_ext = '\0';
         }
         strcpy(split_name3 = malloc(len+2), output_file);
         strcat(split_name3, "3");
         if (p_ext)
         {
            *p_ext = '.';
            strcat(split_name3, p_ext);
            *p_ext = '\0';
         }
         if(!(opl_out = fopen(split_name1,"w")))
         {
            printf("\nOpen failure on %s\n",split_name1);
            perror("");
            exit();
         }
      }/* else split */   
    
      fprintf(opl_out, "#define NULL 0\n");
      fprintf(opl_out, "#include \"OMminimum.h\"\n\n\n");
      fprintf(opl_out, "/* opl version %s */\n\n\n", OPL_version);

      if (apponly || dload)
      {
         fprintf(opl_out,"#include \"version.h\"\n\n\n");
         for (i=0; i < numappver; ++i)
         {
            fprintf(opl_out,"extern INGR_S_PRODUCT_DEF %s;\n",
#if defined(CLIX) || defined(SUNOS4)
               app_table[i]+1);
#elif defined(IRIX) || defined(SUNOS5)
               app_table[i]);
#else
#error Unknown OS
#endif
         }

         fprintf(opl_out,"\nINGR_p_PRODUCT_DEF %s_appl_version[", product);
         if (apponly)
            fprintf(opl_out, "MAXNUMAPPVER]=\n");
         else     /* dload */
            fprintf(opl_out, "]=\n");
         fprintf(opl_out," {\n");

         for (i=0; i<numappver; ++i)
         {
            fprintf(opl_out,"  &%s,\n",
#if defined(CLIX) || defined(SUNOS4)
               app_table[i]+1);
            if (verbose)
               printf("  located application init: %s\n",app_table[i]+1);
#elif defined(IRIX) || defined(SUNOS5)
               app_table[i]);
            if (verbose)
               printf("  located application init: %s\n",app_table[i]);
#else
#error Unknown OS
#endif
         } 
         if (dload || !numappver)
            fprintf(opl_out, "  0\n");    /* Null-terminated list for dload */
         fprintf(opl_out," };\n\n");
         if (apponly)
         {
            /* If -a specified, we're all done */

            fprintf(opl_out,"int OM_Gi_number_of_appl_ids=%d;\n\n\n",numappver);
            fclose(opl_out);
            exit(0);
         }
      }

      if (metasonly)
         Metaclasses(opl_out);
      else
      {
         while (old_entry=(struct hash_entry *)hashnext(classinittbl))
         {
            fprintf(opl_out,"int %s();\n",
#if defined(CLIX) || defined(SUNOS4)
               &old_entry->name[1]);
#elif defined(IRIX) || defined(SUNOS5)
               old_entry->name);
#else
#error Unknown OS
#endif
         }

         fprintf(opl_out,"\nOM_p_FUNCPTR %s_class_definitions[]=\n", product);
         fprintf(opl_out," {\n");
      }
   }

   ii=0;
   if (NULL==(old_entry=(struct hash_entry *)hashnext(classinittbl)) &&
      !metasonly)
   {
      if (!reportonly && !dload)
         fprintf(opl_out,"  0\n");
      if (verbose)
         printf ("No classes located in input files\n");
   }
   if ((!metasonly) && old_entry)
   {
#if defined(CLIX) || defined(SUNOS4)
      if (!reportonly) fprintf(opl_out,"  %s,\n",&old_entry->name[1]);
      if (verbose) printf("  located class: %s\n", &old_entry->name[1]);
#elif defined(IRIX) || defined(SUNOS5)
      if (!reportonly) fprintf(opl_out,"  %s,\n",old_entry->name);
      if (verbose) printf("  located class: %s\n", old_entry->name);
#else
#error Unknown OS
#endif

      ii++;
      while (NULL != (old_entry=(struct hash_entry *)hashnext(classinittbl)))
      {
#if defined(CLIX) || defined(SUNOS4)
         if (!reportonly) fprintf(opl_out,"  %s,\n",&old_entry->name[1]);
         if (verbose) printf("  located class: %s\n", &old_entry->name[1]);
#elif defined(IRIX) || defined(SUNOS5)
         if (!reportonly) fprintf(opl_out,"  %s,\n",old_entry->name);
         if (verbose) printf("  located class: %s\n", old_entry->name);
#else
#error Unknown OS
#endif
         ii++;
      } 
   } 
   if (!reportonly && !metasonly)
   {
      if (dload)
         fprintf(opl_out,"   0\n };\n\n");
      if (!dload)
      {
         fprintf(opl_out," };\n\n");
         fprintf(opl_out,"int OM_Gi_number_of_defns=%d;\n\n\n",ii);
      }
   }

   if (split && !metasonly)
   {
      fclose(opl_out);
      if (!(opl_out = fopen(split_name2,"w")))
      {
         printf("\nOpen failure on %s, errno = %d\n",split_name2, errno);
         exit();
      }
      fprintf(opl_out,"#include \042OMminimum.h\042\n\n\n");
   }

   while (NULL != (old_entry=(struct hash_entry *)hashnext(classidtbl)))
   {
      if (old_entry->flags)
         continue;
      if (!reportonly)
#if defined(CLIX) || defined(SUNOS4)
         fprintf(opl_out,"OMuword %s = 65535;\n", &old_entry->name[1]);
      if (verbose)
         printf("  located class_id: %s\n", &old_entry->name[1]);
#elif defined(IRIX) || defined(SUNOS5)
         fprintf(opl_out,"OMuword %s = 65535;\n", old_entry->name);
      if (verbose)
         printf("  located class_id: %s\n", old_entry->name);
#else
#error Unknown OS
#endif
   }

   if (!reportonly)
      fprintf(opl_out,"\n\n");
   if (split && !metasonly)
   {
      fclose(opl_out);
      if (!(opl_out=fopen(split_name3,"w")))
      {
         printf("\nOpen failure on %s, errno = %d\n",split_name3, errno);
         exit();
      }
      fprintf(opl_out,"#include \042OMminimum.h\042\n\n\n");
   }

   while (old_entry = (struct hash_entry *) hashnext(methodindextbl))
   {
      if (old_entry->flags)
         continue;

      if (!reportonly)
#if defined(CLIX) || defined(SUNOS4)
         fprintf(opl_out, "OMuword %s = 65535;\n", &old_entry->name[1]);
      if (verbose)
         printf("  located method index: %s\n", &old_entry->name[1]);
#elif defined(IRIX) || defined(SUNOS5)
         fprintf(opl_out, "OMuword %s = 65535;\n", old_entry->name);
      if (verbose) printf("  located method index: %s\n", old_entry->name);
#else
#error Unknown OS
#endif

   } 
   if (!reportonly)
      fclose(opl_out);
   exit(0);
} /*main*/




#ifdef SUNOS4

ADFILE	*adopen( filename, adptr )
char	*filename;
ADFILE	*adptr;
{
	if (adptr) {
		/*	Check to see if we're on the last archive object */

		if (adptr->archive && (adptr->offset <  adptr->fileSize)) {
			/* Read new archive header */

			if (!fread(&(adptr->arhdr),
				sizeof(struct ar_hdr), 1, adptr->ioptr ))
			{
				return NULL;
			}

			adptr->offset += sizeof(struct ar_hdr);

			/*	Read file header of current object	*/

			if (!fread( (char *)&(adptr->header), 
				sizeof(struct exec), 1, adptr->ioptr ))
				return NULL;
		}

		return adptr;
	}
	else {
		ADFILE *ap = NULL;
		char	magic[SARMAG];
		struct	stat statBuf;

		/*	Allocate space for new adptr		*/

		ap = (ADFILE *)calloc( sizeof(ADFILE), 1 );
		if (!ap)
			return NULL;

		/*	Open file				*/
	
		if (!(ap->ioptr = fopen( filename, "r" ))) {
			cfree( ap );
			return NULL;
		}

		/*	Get its size and save it away	*/

		if (fstat( fileno(ap->ioptr), &statBuf ) == -1) {
			fclose( ap->ioptr );
			cfree( ap );
			return NULL;
		}

		ap->fileSize = statBuf.st_size;

		/*	See if its an archive		*/

		if (!fread( magic, SARMAG, 1, ap->ioptr )) {
			fclose( ap->ioptr );
			cfree( ap );
			return NULL;
		}

		if (strncmp( magic, ARMAG, SARMAG )) {
			/* If not an archive, seek back to beginning 	*/
			if (fseek( ap->ioptr, 0, 0 )) {
				fclose(ap->ioptr);
				cfree( ap );
				return NULL;
			}
		
			/* Read the file header			*/
			if (!fread( (char *)&(ap->header),
                            sizeof(struct exec), 1, ap->ioptr )) {
				fclose(ap->ioptr);
				cfree( ap );
				return NULL;
			}
	
			ap->offset = 0;
			ap->archive = 0;
                        fclose(ap->ioptr);
		}
		else {
			ap->archive = 1;
			ap->offset = SARMAG;
			
			/*	Read first archive header and file header */

			if ( ap->offset < ap->fileSize) {
				if (!(fread(&(ap->arhdr),
					sizeof(struct ar_hdr), 1, ap->ioptr )))
				{
					fclose( ap->ioptr );
					cfree( ap );
					return NULL;
				}

				if (!fread( (char *)&(ap->header), 
					sizeof(struct exec), 1, ap->ioptr ))	
				{				
					fclose(ap->ioptr);
					cfree( ap );
					return NULL;
				}
				ap->offset += sizeof(struct ar_hdr);
			}
		}		
		
		return ap;
	}
}
ADFILE  *adaopen( filename, old )
char	*filename;
ADFILE	*old;
{
	ADFILE	*ap = NULL;

	/*	Allocate space for new adptr		*/

	ap = (ADFILE *)calloc( sizeof(ADFILE), 1 );
	if (!ap)
		return NULL;

	/*	Open file				*/

	if (!(ap->ioptr = fopen( filename, "r" ))) {
		cfree( ap );
		ap = NULL;
		return NULL;
	}

	if (!old)
		return ap;

	/*	Copy info from old to new		*/
	
	ap->fileSize = FILESZ(old);
	memcpy( (char *)&(ap->header), (char *)&(old->header), sizeof(HEADER(old)) );
	ap->archive = old->archive;
	ap->offset = old->offset;

	memcpy( (char *)&(ap->arhdr), (char *)&(old->arhdr), sizeof(ARHDR(old)) );

	return ap;
}	

int	adaclose( adptr )
ADFILE 	*adptr;
{
	/*	Close the file and unmap the file	*/

        if (adptr->ioptr)
           fclose(adptr->ioptr);

	if (adptr->mapmem)
          munmap((caddr_t) adptr->mapmem, adptr->mapLen);

	free(adptr);
	adptr = NULL;

	return SUCCESS;
}


int	adclose( adptr )
ADFILE 	*adptr;
{
	long	atol();
	long size;

	/*	Check for non-archive or end of file		*/

        if (!adptr)
           return SUCCESS;
	size = atol(adptr->arhdr.ar_size);
	if (!adptr->archive || (adptr->offset >=
           FILESZ(adptr)))
		return(adaclose(adptr));

	/*	Header must begin on even boundary		*/
		
	if ((adptr->offset + size) % 2)
		size++;

	/*	Seek to next archive header if present		*/
	if (adptr->offset + size < FILESZ(adptr)) {
		if (fseek(adptr->ioptr, adptr->offset + size, 0 )) {
			printf("Could not seek to next object.\n" );
			return( FAILURE );
		}
		adptr->offset += size;
	}
	else 
		return(adaclose(adptr));

	/*	Read the archive header			*/

	if (!fread(&adptr->arhdr, sizeof(struct ar_hdr), 1,
           adptr->ioptr)) {
		printf("Could not read archive header.\n" );
		return( FAILURE );
	}
	
	adptr->offset += sizeof(struct ar_hdr);

	/*	Read the object's file header		*/

	if (!fread( (char *)&(adptr->header), sizeof(struct exec), 1,
           adptr->ioptr)) {
		printf("Could not read file header.\n" );
		return( FAILURE );
	}
	if (adptr->mapmem)
        {
           munmap(adptr->mapmem, adptr->mapLen);
             adptr->mapmem = NULL;

           if (admaptables(adptr) != SUCCESS) 
	      return( FAILURE );
	}
	
        return( FAILURE );
}


int admaptables(adptr)
ADFILE   *adptr;
{
   long	aoff = (adptr->archive) ? adptr->offset : 0;
   long strOffset = aoff + N_STROFF(adptr->header);
   long symOffset = aoff + N_SYMOFF(adptr->header);
   long	symIndex;

   /*	Offset must be on a page boundary	*/
   off_t off = symOffset - (symOffset % getpagesize());

   if (adptr->mapmem)		/* sanity check */
      return( SUCCESS );

   /* symIndex is the offset into the mapped area of the symbol table */
   symIndex = symOffset - off;

   if (!adptr->ioptr)
   {
	 printf("In admaptables: file is not open\n");
	 return NULL;
   }

   /* Read the size of the string table */
   if (fseek(adptr->ioptr, (long) strOffset, 0))
   {
      printf("Could not seek to string table.\n");
      return(0);
   }

   if (!fread( (char *) &(adptr->strSize), sizeof(int), 1, adptr->ioptr))
   {
      printf("Could not read string table size.\n" );
      return(0);
   }	

   /*	Map the symbol and string tables	*/

   adptr->mapLen = symIndex + adptr->header.a_syms + adptr->strSize;

   adptr->mapmem = (char *)mmap( 0, adptr->mapLen, PROT_READ, MAP_PRIVATE, 
      fileno(adptr->ioptr), off );
   if (!adptr->mapmem)
   {
      printf("Could not mmap file.\n" );
      return(0);
   }

   /*	Set the pointer to the symbol table		*/
   adptr->tables = adptr->mapmem + symIndex;

   /*	Set the pointer to the string table		*/	
   adptr->strings = adptr->tables + strOffset - symOffset;

   return(1);
}

scan_syms(adptr, filename)
ADFILE   *adptr;
char     *filename;
{
   long           index, last = adptr->header.a_syms / sizeof(struct nlist);
   struct nlist   sym;
   char           *symPtr, symname[513];

   if (!adptr->mapmem)
   {
      if (admaptables(adptr) != SUCCESS)
         return( FAILURE );
   }
   if (!last)
      return(SUCCESS);
   last--;
   madvise(adptr->mapmem, adptr->mapLen, MADV_SEQUENTIAL);

   symbol = &symname[0];
   for (index = 0; index <= last; ++index)
   {
      int    i;
      char   *ptr;
      symPtr = adptr->tables + (index * sizeof(struct nlist));
      memcpy((char *) &sym, symPtr, sizeof(struct nlist));
      if ((sym.n_type & 1) || (sym.n_type & 4))
      {
         if (!(length = strlen(adptr->strings + sym.n_un.n_strx)))
            continue;
         if (length > 512)
         {
            strncpy(symname, adptr->strings + sym.n_un.n_strx, 512);
            symname[512] = '\0';
            length = 512;
         }
         else
            strncpy(symname, adptr->strings + sym.n_un.n_strx, length+1);
         if (ptr = strchr(symbol, ':'))
            *ptr = '\0';

         if ( apponly || dload ) 
         {
           if (length >= applver_len)
           {
              if (strcmp(&symbol[(length-applver_len)],applver)==0)
              {
                 for (i=0; i<numappver; ++i)
                   if (!strncmp(symbol,app_table[i],MAXAPPVERLEN)) break;
                 if ( i == numappver )
                 {
                    if (numappver == MAXNUMAPPVER) 
                    {
                       printf("Exceeded maximum number of APPVER symbols\n");
                       exit(0);
                    }
                    app_table[numappver] = malloc (MAXAPPVERLEN);
                    strcpy(app_table[numappver], symbol);
                    ++numappver;
                 }
              }
           }
        }

        if (!apponly)
        {
           if (length >= OMclassinit_len)
           {
              if ((!metasonly) &&
                 (strcmp(&symbol[(length-OMclassinit_len)],
                 OMclassinit)==0) &&
                 (Not_a_meta_class_init(symbol)) &&
                 !(hashlookup(classinittbl, symbol)))
              {
                 new_entry = (struct hash_entry *) malloc(length +
                    sizeof(struct hash_entry));
                 new_entry->flags = 0;
                 strcpy(new_entry->name, symbol);
                 if ( ! hashadd(classinittbl, new_entry, 0))
                 {
                    printf("\nError from adding to classinit hash table\n");
                    printf(" %s:\n", filename);
                    exit();
                 }
              }
              else
              {
                 if (!strcmp(&symbol[(length-methodindex_len)], methodindex)
                       &&
                     (! (old_entry = (struct hash_entry *)
                       hashlookup(methodindextbl, symbol))))
                 {
                    pastclassname = findPastClassName(symbol+1);
                    if ((classnamelen= pastclassname -(symbol+1))<1)
                    {
                       printf("\nError finding classname within methodindex variable in file: %s\n", filename);
                       printf(" %s:\n", filename);
                       exit();
                    }
                    strncpy(classname, symbol+1, classnamelen);
                    classname[classnamelen] = '\0';
                    if ((metasonly) || Not_a_meta_class(classname))
                    {
                       new_entry = (struct hash_entry *)
                       malloc(length + sizeof(struct hash_entry));
                       new_entry->flags = 0;
                       strcpy(new_entry->name, symbol);
                       if ( ! hashadd(methodindextbl, new_entry, 0))
                       {
                           printf("Error from adding to methodindex hash table\n");
                           printf(" %s:\n", filename);
                           exit();
                       }
                    }
                 }
                 else
                 {
                    if (! metasonly &&
                       ! strcmp(&symbol[(length-classid_len)],classid) &&
                       ! strncmp(&symbol[0],"_OPP_",5) &&
                       (! (old_entry = (struct hash_entry *)
                       hashlookup(classidtbl, symbol))))
                    {
                       if ((classnamelen=(symbol+(length-classid_len))-(symbol+5))<1)
                       {
                          printf("\nError finding classname within classid variable in file: %s\n",filename);
                          printf(" %s:\n", filename);
                          exit();
                       }
                       strncpy(classname, symbol+5, classnamelen);
                       classname[classnamelen] = '\0';
                       if (Not_a_meta_class(classname))
                       {
                          new_entry = (struct hash_entry *)malloc(length+ sizeof(struct hash_entry));
                          new_entry->flags = 0;
                          strcpy(new_entry->name, symbol);
                          if ( ! hashadd(classidtbl, new_entry, 0))
                          {
                             printf("Error from adding to classid hash table\n");
                             printf(" %s:\n", filename);
                             exit();
                          }
                       }
                    }
                 }
              }
            }
          }
       }
    }
    return(SUCCESS);
}
#endif
