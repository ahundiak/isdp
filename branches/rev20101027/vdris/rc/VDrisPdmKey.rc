/* $Id: VDrisPdmKey.rc,v 1.1 2002/03/13 16:19:33 ahundiak Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:        vdris/rc/VDrsxKey.rc
 *
 * Description: Unique Key Routines
 *
 * Dependencies:
 *
 * Revision History:
 * $Log: VDrisPdmKey.rc,v $
 * Revision 1.1  2002/03/13 16:19:33  ahundiak
 * ah
 *
 * Revision 1.2  2001/02/11 17:59:58  ahundiak
 * Renamed VDris2 to VDrisc
 *
 * Revision 1.1  2001/02/01 21:58:19  ahundiak
 * ah
 *
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 03/12/02  ah      Need special handling for pdm file key
 *
 ***************************************************************************/
#include "VDtypedefc.h"
#include "VDrisc.h"
#include "time.h"

#define VDPDM_KEY_TABLE_TABLE_NAME             "vdpdm_key_table"
#define VDPDM_KEY_TABLE_COLN_KEY_NAME          "key_name"
#define VDPDM_KEY_TABLE_COLN_VALUE             "value"
#define VDPDM_KEY_TABLE_COLN_UPD_DATE          "upd_date"
#define VDPDM_FILE_KEY_COLN_FILE_KEY           "file_key"

/* -------------------------------------------
 * Read a key using a select into system
 * A value of 0 is returned is key is not defined
 */
int VDrisPdmGetCurFileKey(int *key)
{
  int retFlag = 0;

  exec sql begin declare section;
    int   keyx;
  exec sql end   declare section;

  /* Arg check */
  if (key == NULL) goto wrapup;
  *key = 0;

  /* Generic Error Handler */
  exec sql whenever sqlerror goto :error;

  /* Make sure have a value */
  exec sql whenever not found goto :not_found;

  exec sql select value into :keyx from vdpdm_key_table where key_name = 'file_key';
  *key = keyx;
  retFlag = 1;

error:
  exec sql whenever sqlerror continue;

not_found:
wrapup:
  return retFlag;
}

/* -------------------------------------------
 * Gets a unique key from a table
 *
 * Used the routine from App B of the ris programing ref manual
 * The idea is to avoid locking by adding a where clause to the update
 * statement.  This allows safe multiple updating of the keys.
 *
 * Inits a key to 1 for the first time a key is requested.
 */
int VDrisPdmGetNextFileKey(int *key)
{
  int retFlag = 0;

  exec sql begin declare section;
    char  sqlx[128];
    char *err_ptr;
  exec sql end   declare section;

  int keyx,key_try;

  time_t current_time;
  struct tm *tm;
  IGRchar cur_date[40];

  /* Arg check */
  if (key == NULL) goto wrapup;
  *key = 0;

  /* Generic Error Handler */
  exec sql whenever sqlerror goto :error;

  /* Get the current key */
  /* ---------------------------------------------
   * Sometimes a connection will just fail
   * The end result is 0
   * Retry when this happens before giving up
   */
  keyx = 0;
  key_try = 0;
  while((keyx < 1) && (key_try < 10)) {
    VDrisPdmGetCurFileKey(&keyx);
    if (keyx < 1) {
      sleep(1);
      key_try++;
    }
  }

  /* --------------------------------------------
   * Values have to be seeded
   * So fail completely if no value is found
   */
  if (keyx < 1) return 0;

  /* Got the key, need to update the table */
  exec sql whenever not found goto :file_key_not_found;
  key_try = 0;

key_loop:
  keyx++;

   // Timestamp
   time(&current_time);
   tm = localtime(&current_time);
   sprintf(cur_date,
           "%4d-%02d-%02d %02d:%02d:%02d",
	   tm->tm_year+1900,tm->tm_mon+1,tm->tm_mday,
	   tm->tm_hour,tm->tm_min,tm->tm_sec);

  /* Update the table taking into account the possibility that someone else
   * may have tried updating at the same time */
  sprintf(sqlx,
          "Update %s set %s=%d,%s='%s' where %s='%s' and %s=%d;",
	  VDPDM_KEY_TABLE_TABLE_NAME,

          VDPDM_KEY_TABLE_COLN_VALUE,
          keyx,

          VDPDM_KEY_TABLE_COLN_UPD_DATE,
          cur_date,

	  VDPDM_KEY_TABLE_COLN_KEY_NAME,
          VDPDM_FILE_KEY_COLN_FILE_KEY,

          VDPDM_KEY_TABLE_COLN_VALUE,
          keyx-1);

  exec sql prepare stmt_update_pdm_file_key from :sqlx;
  exec sql execute stmt_update_pdm_file_key;
  exec sql clear   stmt_update_pdm_file_key;

  /* Done */
  *key = keyx;
  retFlag = 1;
  return retFlag;

  /* Someone is trying to update at the same time */
file_key_not_found:
  exec sql whenever not found continue;
  exec sql clear stmt_update_pdm_file_key;

  if (key_try < 10) {
    key_try++;
    goto key_loop;
  }
  printf("*** Giving up getting pdm file key after %d tries \n",key_try);
  
wrapup:
  return retFlag;

error:
  exec sql whenever sqlerror continue;
  exec sql report error into :err_ptr;
  puts(err_ptr);
  return retFlag;
}
