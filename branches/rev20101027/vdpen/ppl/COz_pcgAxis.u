/* $Id: COz_pcgAxis.u,v 1.3 2002/04/12 17:30:53 ylong Exp $  */
/***************************************************************************
 * I/ROUTE
 *
 * File:        vds/vdpen/COz_pcgAxis.u
 *
 * Description: Validate pcg long axis.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COz_pcgAxis.u,v $
 *      Revision 1.3  2002/04/12 17:30:53  ylong
 *      *** empty log message ***
 *
 *      Revision 1.2  2002/04/11 21:45:17  ylong
 *      *** empty log message ***
 *
 *      Revision 1.1  2001/10/10 19:24:56  ylong
 *      *** empty log message ***
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      10/10/01        ylong           File Creation for CR5360
 ***************************************************************************/

#include "VDppl.h"
#include "VDmem_ppl.h"
#include "VDobj.h"
#include "vdVALmacros.h"
#include "VDchn.h"

extern	VDgetMacrosByMacName();
extern	GRclassid	OPP_nci_macro_class_id;

/*--------------------------------------------------------
 * Get Long axi"s
 * oldAxis is retrieved from pen foot penAttrID, and
 * newAxis is retrieved from pcg foot pcgAttrID
 */
IGRlong	GetLongAxis( csID, penAttrID, pcgAttrID, oldAxis, newAxis )
	struct GRid		csID;
	struct GRid		penAttrID;
	struct GRid		pcgAttrID;
	IGRchar			*oldAxis;
	IGRchar			*newAxis;
{
	int		retFlag;
	IGRlong		sts, msg;
	IGRdouble	val[10];
	IGRdouble	cm[16], cosin, angle;
	IGRdouble	loc_vec[3], max, dot_prod;
	IGRdouble	width, depth;
	IGRint		m, iWidth, iLongAxis;
	IGRint		orient, loc_orient;
	IGRint		nbAttrs;
	struct ACrg_coll	*attrs, axisAttr;

	retFlag = 0;
	nbAttrs	= 0;
	attrs	= NULL;

	if (	csID.objid	== NULL_OBJID ||
		penAttrID.objid	== NULL_OBJID ||
		pcgAttrID.objid	== NULL_OBJID ||
		oldAxis		== NULL ||
		newAxis		== NULL	) 
        {
		goto wrapup;
	}

	/* get old long axis from pcg foot */
	strcpy( axisAttr.name, "long_axis");
	sts = ci$send(	msg      = message  ACrg_collect.ACget_named_attribute
							( &msg, &axisAttr ),
			targetid = pcgAttrID.objid,
			targetos = pcgAttrID.osnum );
	if( !(sts&msg&1) ) 
	{
		goto wrapup;
	}

	strcpy( oldAxis, axisAttr.desc.value.att_txt );

	/* compute new long axis */

	sts = ci$send(	msg	= message  ACrg_collect.AClist_attribute(
							&msg,
							0,
							NULL,
							&nbAttrs),
			targetid = penAttrID.objid,
			targetos = penAttrID.osnum );
	if( !(sts&msg&1) || nbAttrs < 1 )
	{
		goto wrapup;
	}

	attrs = _MALLOC( nbAttrs, struct ACrg_coll );
	if( attrs == NULL ) 
        {
		goto wrapup;
        }

	sts = ci$send(	msg	= message  ACrg_collect.AClist_attribute(
							&msg,
							nbAttrs,
							attrs,
							&nbAttrs),
			targetid = penAttrID.objid,
			targetos = penAttrID.osnum );
	if( !(sts&msg&1) || attrs == NULL ) 
	{
		goto wrapup;
	}
	
	width = 0;
	depth = 0;
	iWidth = -1;
	iLongAxis = -1;
	for( m = 0; m < nbAttrs; m = m+1 ) {
		if( !strcmp( attrs[m].name, "width" ) ) {
			iWidth = m;
		}

		if( !strncmp( attrs[m].name, "long_axis", 9 ) ) {
			iLongAxis = m;
		}
	}

	for(m = 0; m < 3; m = m+1) {
		loc_vec[m] = 0.;
	}

	if( iWidth < 0 ) {
		strcpy(attrs[iLongAxis].desc.value.att_txt, "N/A");
		retFlag = 1;
		goto wrapup;
	}
	else if ( iWidth < (nbAttrs-1) ) {
		width = attrs[iWidth].desc.value.att_exp;
		depth = attrs[iWidth+1].desc.value.att_exp;
		if( width < depth ) {
			loc_orient = 1;
		}
		else {
			loc_orient = 0;
		}

		loc_vec[loc_orient] = 1.0;
	}
	else {
		goto wrapup;
	}

	sts = ci$send(  msg      = message GRgencs.GRgetmatrix (&msg, cm),
                        targetid = csID.objid,
                        targetos = csID.osnum );
	if( !(sts&msg&1) ) {
		printf("GRgencs.GRgetmatrix failed");
		goto wrapup;
	}

	max = 0.;
	for( m = 0; m < 3; m = m+1 ) {
		dot_prod =	cm[m*4+0]*loc_vec[0] + 
				cm[m*4+1]*loc_vec[1] + 
				cm[m*4+2]*loc_vec[2];
		if( fabs(dot_prod) > max ) {
			max = fabs(dot_prod);
			orient = m;
		}
	}
	
	switch( orient ) {

	case 0:		/* X */
		cosin = fabs( cm[loc_orient+0] );
		if( cosin > 1.0 ) cosin = 1.0;
		angle = acos( cosin )*180/PI ;
		strcpy(newAxis, " 1 ");
		break;
	case 1:		/* Y */
		cosin = fabs( cm[loc_orient+4] );
		if( cosin > 1.0 ) cosin = 1.0;
		angle = acos( cosin )*180/PI ;
		strcpy(newAxis, " 2 ");
		break;
	case 2:		/* Z */
		cosin = fabs( cm[loc_orient+8] );
		if( cosin > 1.0 ) cosin = 1.0;
		angle = acos( cosin )*180/PI ;
		strcpy(newAxis, " 3 ");
		break;
	default:	/* NA */
		angle = 45.0;		/* doesn't matter what value */
		strcpy(newAxis, "N/A");
		break;
	};

	if( angle > 1.0 && (180.0 - angle) > 1.0 ) strcpy(newAxis, "N/A");

	retFlag = 1;
wrapup:
	_FREE( attrs );
	return retFlag;
}


main()
{
IGRlong                 sts, msg;
IGRint                  i, j, loc_cnt, nb_class, mac_cnt, child_cnt, state;
IGRchar			macName[128], penName[128], pcgName[128],
			tmpStr[128], oldAxis[80], newAxis[80];
IGRboolean		penFlag, csFlag, pcgFlag;
GRclassid               classid[1];
GRspacenum		osnum;
GRrange			range;
struct GRmd_env		loc_env, mod_env;
struct GRobj_env	footOE;
struct GRid		*loc_list, parentID, *penIDs, *csIDs;
struct GRid             penAttrID, pcgAttrID;
struct ACrg_coll	*attrs, axisAttr;

   nb_class  = 1;
   loc_cnt   = 0;
   loc_list  = NULL;
   penIDs    = NULL;
   csIDs     = NULL;
   mac_cnt   = 0;
   penFlag	= FALSE;
   csFlag	= FALSE;
   pcgFlag	= FALSE;

   ci$get_module_info( md_env = &loc_env );
   osnum = loc_env.md_id.osnum;

   classid[0] = OPP_nci_macro_class_id;

   vd$VAL_openLog();

   loc_cnt = 0;

   VDgetMacrosByMacName( osnum, "pcgMacro", &loc_cnt, &loc_list );

   if( !loc_cnt )  
   {
      vd$VAL_addInfo( Text = "No Penetrations Found." );
      goto wrapup;
   }

   penIDs = _MALLOC( loc_cnt, struct GRid );
   if( penIDs == NULL ) 
   {
	goto wrapup;
   }
   csIDs = _MALLOC( loc_cnt, struct GRid );
   if( csIDs == NULL ) 
   {
	goto wrapup;
   }
   
#ifdef DEBUG
   for( i = 0; i < loc_cnt; i = i+1 ) 
   {
	vdobj$Print(objID=&loc_list[i]);
   }
#endif


   /*
    * check if pcgs have pen parents and report if no pen parent
    */
   for( i = 0; i < loc_cnt; i = i+1 ) 
   {
      pcgName[0] = '\0';
      parentID.objid  = NULL_OBJID;
      penIDs[i].objid = NULL_OBJID;
      csIDs[i].objid  = NULL_OBJID;

      /* get ACpretend of pen macro */
      sts = ci$send(	msg	 = message  ACcpx.ACfind_exp_temp_obj(
							&msg,
							0,
							&parentID),
			targetid = loc_list[i].objid,
			targetos = loc_list[i].osnum );
      if( !(sts&msg&1) || parentID.objid == NULL_OBJID )
      {
	 continue;
      }

      /* get pen macro */
      sts = ci$send( msg = message NDmacro.ACreturn_foot(
                                &msg,
                                "",
                                &penIDs[i],
                                &mod_env.md_env.matrix_type,
                                mod_env.md_env.matrix ),
                targetid = parentID.objid,
                targetos = parentID.osnum );
      if( !(sts&msg&1) || penIDs[i].objid == NULL_OBJID )
      {
	 penIDs[i].objid = NULL_OBJID;
	 continue;
      }

      /* get ACpretend of cs */
      parentID.objid = NULL_OBJID;
      sts = ci$send(	msg	 = message  ACcpx.ACfind_exp_temp_obj(
							&msg,
							0,
							&parentID),
			targetid = penIDs[i].objid,
			targetos = penIDs[i].osnum );
      if( !(sts&msg&1) || parentID.objid == NULL_OBJID )
      {
	 continue;
      }

      /* get cs */
      sts = ci$send( msg = message NDmacro.ACreturn_foot(
                                &msg,
                                "",
                                &csIDs[i],
                                &mod_env.md_env.matrix_type,
                                mod_env.md_env.matrix ),
                targetid = parentID.objid,
                targetos = parentID.osnum );
      if( !(sts&msg&1) || csIDs[i].objid == NULL_OBJID )
      {
	 csIDs[i].objid = NULL_OBJID;
	 continue;
      }

   }

   /*
    * report pcg if missing parent pen macro
    */
   for( i = 0; i < loc_cnt; i = i+1 ) 
   {
      if( penIDs[i].objid == NULL_OBJID )
      {
	 if( penFlag == FALSE )
         {
	    vd$VAL_addInfo( Text = "PCG macros missing PEN macro as parent:");
	    vd$VAL_addInfo( Text = "" );
	    penFlag = TRUE;
	 }
	 vdobj$Get( objID = &loc_list[i], objName = pcgName );
	 vd$VAL_addObject (	GRid     = loc_list[i],
				PostText = pcgName );
      }
   }

   if( penFlag )
   {
      vd$VAL_addInfo( Text = "" );
   }

   /*
    * report pcg if its parent pen macro missing coordinate syytem
    */
   for( i = 0; i < loc_cnt; i = i+1 ) 
   {
      if( penIDs[i].objid != NULL_OBJID && csIDs[i].objid == NULL_OBJID )
      {
	 if( csFlag == FALSE )
         {
	    vd$VAL_addInfo( 
		Text = "PCG macros whose PEN macro missing coordinate system:");
	    vd$VAL_addInfo( Text = "" );
	    csFlag = TRUE;
	 }
	 vdobj$Get( objID = &loc_list[i], objName = pcgName );
	 vd$VAL_addObject (	GRid     = loc_list[i],
				PostText = pcgName );
      }
   }
   if( csFlag )
   {
      vd$VAL_addInfo( Text = "" );
   }

   /*
    * report pcg if its long axis is not corret
    */
   for( i = 0; i < loc_cnt; i = i+1 ) 
   {
      if( csIDs[i].objid == NULL_OBJID ) continue;

      footOE.obj_id.objid = NULL_OBJID;
      pcgAttrID.objid = NULL_OBJID;
      penAttrID.objid = NULL_OBJID;
      vdobj$GetFoot(	objID		= &loc_list[i],
			footName	= "Attributes",
			footOE		= &footOE );

      if( footOE.obj_id.objid != NULL_OBJID )
      {
	 pcgAttrID = footOE.obj_id;
      }
      else
      {
	 vdobj$Get( objID = &loc_list[i], objName = pcgName );
	 sprintf( tmpStr, "%s: missing attribute foot", pcgName );
	 vd$VAL_addObject (	GRid     = loc_list[i],
				PostText = tmpStr );
	 continue;
      }
         
      footOE.obj_id.objid = NULL_OBJID;
      vdobj$GetFoot(	objID		= &penIDs[i],
			footName	= "Attributes",
			footOE		= &footOE );

      if( footOE.obj_id.objid != NULL_OBJID )
      {
	 penAttrID = footOE.obj_id;
      }
      else
      {
	 vdobj$Get( objID = &loc_list[i], objName = pcgName );
	 sprintf( tmpStr, "%s: missing pen's attribute foot", pcgName );
	 vd$VAL_addObject (	GRid     = loc_list[i],
				PostText = tmpStr );
	 continue;
      }
         
      oldAxis[0] = '\0';
      newAxis[0] = '\0';
      sts = GetLongAxis( csIDs[i], penAttrID, pcgAttrID, oldAxis, newAxis );
	
      if( !(sts&1) ) continue;

      if( strcmp( oldAxis, newAxis ) )
      {
	 if( pcgFlag == FALSE )
         {
	    vd$VAL_addInfo( Text = "PCG macro's long axis validated:");
	    vd$VAL_addInfo( Text = "" );
	    pcgFlag = TRUE;
	 }
	 vdobj$Get( objID = &loc_list[i], objName = pcgName );
	 sprintf( tmpStr, "%s: long axis = %s", pcgName, newAxis );
	 vd$VAL_addObject (	GRid     = loc_list[i],
				PostText = tmpStr );
      
	 strcpy(axisAttr.name, "long_axis" );
	 strcpy(axisAttr.desc.value.att_txt, newAxis );
	 axisAttr.desc.type = AC_ATTRIB_TEXT;
	 sts = ci$send(	msg	 = message ACrg_collect.ACmod_list_attribute
                                           ( &msg, 1, &axisAttr ),
			targetid = pcgAttrID.objid,
			targetos = pcgAttrID.osnum  );
      }
   }
   if( pcgFlag == TRUE )
   {
      vd$VAL_addInfo( Text = "" );
   }
   else
   {
      vd$VAL_addInfo( Text = "Every PCG long axis is fine.");
   }

wrapup:
   vd$VAL_closeLog();
   _FREE( loc_list  );
   _FREE( penIDs  );
   _FREE( csIDs  );
   return 1;
}
