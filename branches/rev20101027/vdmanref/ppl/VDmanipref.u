/* $Id: VDmanipref.u,v 1.1.1.1 2001/01/04 21:08:56 cvs Exp $  */
/***************************************************************************
 * I/VDS
 *
 * File:	vdmanref/VDmanipref.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDmanipref.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:08:56  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/12/30  16:08:26  pinnacle
# Created: vdmanref/ppl/VDmanipref.u by mdong for vds
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	12/17/97      Adz & Ming	Creation
 *
 ***************************************************************************/

#include <stdio.h>
#include <string.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "DItypedef.h"
#include "DIprims.h"
#include "grmacros.h"
#include "exmacros.h"
#include "dpmacros.h"
#include "VDmsg.h"
#include "VDmanref.h"
#include "v_dbgmacros.h"

extern	int	VDman_convert_lev_string ();
extern	int	VDman_get_on_off_lev();
extern	int	VDman_convert_lev_array();
extern	int	VDman_center_message();

extern          EX_get_oid_nodname ();
extern          GRget_properties ();
extern          GRdisplay_object ();
extern          DPdisbyoid ();
extern          GRchange_properties ();
extern          DPmacupdate ();
extern          DPinq_level ();
extern          DPlev_num_to_name ();
extern  int     EX_filename1 __((char *result, int len));

extern	int	UI_status();
extern	char	*malloc();
extern	char	*realloc();
extern	void	free();

/*
 * Globals in design file ....
 */
char		EXRmsg_str[256];

EXRglobals		EXRform_info;
EXRreference_files	*EXRref_files; /* use only once malloc & free */
struct GRmd_env 	EXRmod_info; 

struct CIform_st form_st;
extern ci_notification ();

return_error ()
{
  /*
   * before exiting the program we clean-up the message and prompt field
   */
  message ("");
  prompt ("");

  if (EXRform_info.ref_form_exists == TRUE) 
   {
      FIf_delete (EXRform_info.ref_form); 
      EXRform_info.ref_form_exists = FALSE;
      EXRform_info.ref_form_displayed = FALSE;
   }

  exit;
}

wakeup ()
{
  /*
   * check during wakeup if form is already active.
   */

  if ((EXRform_info.ref_form_exists == TRUE) &&
      (EXRform_info.ref_form_displayed != TRUE)) 
    {
      FIf_display (EXRform_info.ref_form); 
      EXRform_info.ref_form_displayed = TRUE;
    }
}

delete ()
{
  /*
   * in the termination state of the command object we erase/delete the form
   */
 if (EXRform_info.ref_form_exists == TRUE) 
  {
      FIf_delete (EXRform_info.ref_form); 
      EXRform_info.ref_form_exists = FALSE;
      EXRform_info.ref_form_displayed = FALSE;
  }

  prompt(" ");
  message (" ");
/**
  status(" ");
**/
}

IGRint VDman_get_arrange_name( refname )
IGRchar	*refname;
{
	int	i, j ;

	SetProc( VDman_get_arrange_name ); Begin

	__DBGpr_str(" ref_name ", refname );

	j = strlen (refname);
	for ( i=j; i>0; i = i - 1 ){

	  if( refname[i] == ',' ){
	    refname[i] = '\0';
	    break;
	  }
	}

	End
	return ( OM_S_SUCCESS );
}

IGRint	VDman_get_ref_info( mod_env, refcount, reftab )
struct GRmd_env		*mod_env;
IGRlong			*refcount;
struct EXR_reffile	**reftab;
{
long		sts, status;
OM_S_OBJID	Super_id;
IGRshort	count_nested;
GRobjid		*objlist;
GRspacenum	*oslist;
int             on_off; 
IGRint		i,j;
IGRint          msg;
IGRlong		count;
IGRulong	prop_mask, props;
unsigned short  properties;
IGRchar         buffer[512];
struct GRobj_info	refinfo;
struct EXR_reffile	*curref, *ref;
struct GRid     ref_object;

  SetProc( VDman_get_ref_info ); Begin

  objlist = (GRobjid *)(NULL);
  oslist  = (GRspacenum *)(NULL);
  *refcount = 0;
  count = 0;

  /*| Get id of ref manager */
  status = ex$get_objid_from_NOD(
                        NODname         = "IGENOD",
                        objname         = "Ref Mgr",
                        pobjid          = &Super_id,
                        modid           = mod_env->md_id.objid,
                        mod_osnum       = mod_env->md_id.osnum);
  if(!(status&1)) goto wrapup ;

  /*"Ref Mgr id = %d\n", Super_id */
  /*| Get count of reference file */
  prop_mask = 0;
  count_nested = 0;
  status = ci$send(msg	   = message Super_rfmgr.GRget_channel_count
                                   (&sts, &prop_mask, &count_nested, &count),
	  targetid = Super_id,
	  targetos = mod_env->md_id.osnum );

  if(!(status&1)) goto wrapup ;
  /*"Ref count = %d\n", count*/

  __DBGpr_int("channel count =", count);

  /*| Get reference file objects */
  i = (int)count;
  objlist = om$calloc( num = i, structure = GRobjid );
  oslist  = om$calloc( num = i, structure = GRspacenum );

  prop_mask = 0; count_nested = 0;
  status =
  ci$send(msg      = message Super_rfmgr.GRget_channel_objects
                                     (&sts, &prop_mask, &count_nested, &count,
                                      objlist, oslist, &count),
	  targetid = Super_id,
	  targetos = mod_env->md_id.osnum );
  if(!(status&1)) goto wrapup ;

  i = (int) count;
  *reftab = om$calloc( num = i, structure = struct EXR_reffile );

  __DBGpr_int(" Channel objects retrieved ", count);

  /*
   * For all reference files, get the object space and filename
   */
  curref = *reftab;
  *refcount = count;
  j = 0;
  for( i=0; i<count ; i = i + 1 ) {
    status =
    ci$send(msg      = message GRreffile.GRgetobjinfo( &sts, &refinfo ),
	    targetid = objlist[i],
	    targetos = oslist[i] );
    if(!(status&1)) continue;

    status =
    ci$send(msg      = message GRreffile.GRgetenvironment
                                          ( &sts, mod_env, &(curref->md_env) ),
	    targetid = objlist[i],
	    targetos = oslist[i] );
    if(!(status&sts&1)) continue;

    curref->osnum = curref->md_env.md_id.osnum;

    VDman_get_arrange_name( refinfo.type );
    strcpy( curref->ref_name, refinfo.type );
    curref->ctx_id.objid = objlist[i];
    curref->ctx_id.osnum = oslist[i];

    __DBGpr_str(" refinfo.type ", refinfo.type );
    __DBGpr_obj(" Cur Refernce ", curref->md_env.md_id );

    on_off = 0 ;

    status =
    ci$send(msg = message GRreffile.GRgetrfprops
                                          ( &sts, &props ),
	    targetid = objlist[i],
	    targetos = oslist[i] );


    ref_object.objid = objlist[i];
    ref_object.osnum = oslist[i];
    gr$get_properties( object_id = &ref_object,
                       properties_mask = &properties);

    curref->properties = props;

    if ( properties & GRIS_DISPLAYABLE )   
         on_off = 1;

    __DBGpr_int("on_off ", on_off);

    curref->display = on_off;

    j = j + 1;
    curref = curref + 1;

  }  /*** for ***/

  if (j <= 0)
   {
      *refcount = 0;
      goto wrapup;
   }

  if( j < count )
   {
      i = j;
      *refcount = j;
      i = i * sizeof(struct EXR_reffile);
      *reftab = (struct EXR_reffile *)om$realloc( ptr  = (char *)*reftab,
                                                  size = i );
   }
   __DBGpr_int("refcount ", *refcount);

  /*| Free locals allocated ptrs */
  if( objlist ) om$dealloc( ptr = objlist );
  if( oslist )  om$dealloc( ptr = oslist );

  End
  return( OM_S_SUCCESS );

wrapup:
  /*| Free locals allocated ptrs */
  
  if( objlist ) om$dealloc( ptr = objlist );
  if( oslist )  om$dealloc( ptr = oslist );
  if( *reftab ) om$dealloc( ptr = *reftab );
  *refcount = 0;

  End
  return( OM_S_SUCCESS );
}

int VDman_process_attached_file (mod_env, osnum, ref_ctx_id, on_off)
  struct GRmd_env *mod_env;
  GRspacenum  osnum;
  struct GRid *ref_ctx_id;
  int  on_off;
{
  IGRlong msg, status, sts;
  IGRulong prop_mask;
  IGRshort flag;

  SetProc( VDman_process_attached_file ); Begin

  prop_mask = GRIS_DISPLAYABLE | GRIS_LOCATABLE;

  if (on_off == 1)
   {
       /** turn the display on in all windows **/

       gr$display_object (object_id = ref_ctx_id,
			  md_env = mod_env,
			  mode = GRbd);

       dp$display (msg = &msg,
                   objid = EXRmod_info.md_id,
	           mode = GRbd,
                   oids = ref_ctx_id);

       gr$put_properties (object_id = ref_ctx_id,
                          action = 1,
                          properties_mask = prop_mask);

       /*** Call GRchgrfprops to change the properties mask **/ 

       flag = 1;
       status =
       ci$send(msg = message GRreffile.GRchgrfprops
                                             ( &sts, 
                                               &flag,
                                               &prop_mask ),
	       targetid = ref_ctx_id->objid,
	       targetos = ref_ctx_id->osnum );
   }
  else
   {
       /** turn the display off in all windows **/

       gr$display_object (object_id = ref_ctx_id,
 		          md_env = mod_env,
	                  mode = GRbe);

       dp$display (msg = &msg,
                   objid = EXRmod_info.md_id,
		   mode = GRbe,
                   oids = ref_ctx_id);

       gr$put_properties (object_id = ref_ctx_id,
                          action = 0,
                          properties_mask = prop_mask);

       /*** Call GRchgrfprops to change the properties mask **/ 

       flag = 0;
       status =
       ci$send(msg = message GRreffile.GRchgrfprops
                                             ( &sts, 
                                               &flag,
                                               &prop_mask ),
	       targetid = ref_ctx_id->objid,
	       targetos = ref_ctx_id->osnum );
   }

  End 
  return (0);
}

int VDman_process_request (form)
  Form form;
{
   int d_state;
   int m_state;
   int status, sel_flag, r_pos;
   int i, j, k, n, num_rows, num_levels;
   int upd;
   int selected;
   int  color, dlevel[1024], d_level[1];
   char ref_file[256];
   char level [256];
   IGRlong msg, sts;
   IGRint levels[32];
   IGRshort flags;

   SetProc( VDman_process_request ); Begin

   num_rows = 0;
   status = FIfld_get_num_rows (form, EXR_REF_FILES_SCF, &num_rows); 
   if (status != FI_SUCCESS)
      return (status);

   /**  Get the display state from the EXR_DISPLAY_TOGGLE **/

   d_state = 0;
   FIg_get_state (form, EXR_DISPLAY_TOGGLE, &d_state);
   if (d_state == 1)
   {
	__DBGpr_com(" Display OFF ");
       /** The user can only turn on/off reference files **/
       /**  Get the Selected file(s) from the EXR_REF_FILES_SCF **/

       selected = 0;

       for (i = 0; i < num_rows; i = i + 1)
        {
           status = FIfld_get_select (form, EXR_REF_FILES_SCF, i,0, &sel_flag);
            if (status != FI_SUCCESS)
               return (status);
      
            if (sel_flag == TRUE)
             {
                 selected = 1;

                status = FIfld_get_text (form, EXR_REF_FILES_SCF, i, 0, 255,
                                         ref_file, &sel_flag, &r_pos);
                if (status != FI_SUCCESS)
                   return (status);

                __DBGpr_str ("selected_file", ref_file);

                /**  find the reference file in the EXRref_files array  **/

                for (j = 0; j < EXRform_info.ref_count; j = j + 1)
                 {
                    if ( (strcmp (ref_file, EXRref_files[j].ref_file) == 0) &&
                         (EXRref_files[j].level == EXRform_info.cur_ref_idx) )
                     {
                        EXRref_files[j].on_off = 0;  
                        if (EXRref_files[j].display == 1)
                         {
                            sprintf (EXRmsg_str, 
                                     "Turning display off for file <%s>",
                                     EXRref_files[j].ref_file);
                            VDman_center_message (EXRform_info.ref_form,
                                                  FI_MSG_FIELD, EXRmsg_str);

                            /** turn off the reference file display **/
                            EXRref_files[j].display = 0;  
                            VDman_process_attached_file (
					   	  &EXRref_files[j].md_env,
                                                  EXRref_files[j].osnum,
                                                  &(EXRref_files[j].ctx_id), 0);
                            FIfld_set_line_color (form, EXR_REF_FILES_SCF,
                                                  i, 0, FI_RED);
                            selected = 1;
                         }
                        else
                         {
                            sprintf (EXRmsg_str, 
                                     "Display of file <%s> is already off",
                                     EXRref_files[j].ref_file);
                            VDman_center_message (EXRform_info.ref_form,
                                                  FI_MSG_FIELD, EXRmsg_str);
                         }
                        break;
                     }
                 } /** for j **/          
             } /** If sel_flag **/
        }

       if (!selected)
        {
          strcpy (EXRmsg_str, "No files selected. Push Cancel to exit");
          VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                EXRmsg_str);
        } 
       dp$update (msg = &msg);

       for (i = 0; i < num_rows; i = i + 1)
        {
           FIfld_set_select (form, EXR_REF_FILES_SCF, i,0, FALSE);
        }

       return (0); 
    }

   /** get the EXR_ON_OFF_LAY_TOGGLE state from the gadget **/

   d_state = 0;
   FIg_get_state (form, EXR_ON_OFF_LAY_TOGGLE, &d_state);

   /** get the mode state from the EXR_SEL_MODE_TOGGLE.   **/

   m_state = 0;
   FIg_get_state (form, EXR_SEL_MODE_TOGGLE, &m_state);

   selected = -1;
   upd = -1;

   /*** Get the selected file(s) from the Attached Files list ***/ 

   __DBGpr_com ("Display ON\n");
   for (i = 0; i < num_rows; i = i + 1)
    {
       status = FIfld_get_select (form, EXR_REF_FILES_SCF, i, 0,
                                  &sel_flag);
        if (status != FI_SUCCESS)
           return (status);
  
        if (sel_flag == TRUE)
         {
            status = FIfld_get_text (form, EXR_REF_FILES_SCF, i, 0, 255,
                                     ref_file, &sel_flag, &r_pos);
            if (status != FI_SUCCESS)
               return (status);

            /**  find the reference file in the EXRref_files array  **/

            for (j = 0; j < EXRform_info.ref_count; j = j + 1)
             {
                if ( (strcmp (ref_file, EXRref_files[j].ref_file) == 0) &&
                     (EXRref_files[j].level == EXRform_info.cur_ref_idx) )
                 {
                    selected = j;
                    EXRref_files[j].on_off = 0;  

                    /*** If it is off, turn it on.  ***/ 

                    if (EXRref_files[j].display == 0)
                     {
                        sprintf (EXRmsg_str, 
                                 "Turning display on for file <%s>",
                                 EXRref_files[j].ref_file);
                        VDman_center_message (EXRform_info.ref_form,
                                              FI_MSG_FIELD, EXRmsg_str);
                        EXRref_files[j].display = 1;  
                        VDman_process_attached_file(&EXRref_files[j].md_env,
                                                    EXRref_files[j].osnum, 
                                                    &EXRref_files[j].ctx_id, 1);
                        FIfld_set_line_color (form, EXR_REF_FILES_SCF,
                                              i, 0, FI_GREEN);
                        upd = j;
                        break;
                     }
                 }  /** if  **/
             }  /** for j **/
            if (m_state == 0)   /** single select **/
               break;
            else 
             {
                /** see if we need to turn levels on/off for this file **/

                status = FIfld_get_text (form, EXR_KEYIN_LAYER_FIELD, 0, 0,
                                         255, level, &sel_flag, &r_pos);
                if (status != FI_SUCCESS)
                   continue;

 		__DBGpr_str ("level", level);

                if (strcmp (level, "") == 0)
                   continue;
                else if ( (strcmp (level, "*") == 0) ||
                   (strcmp (level,"all") == 0) || (strcmp (level,"ALL") == 0) ||
                   (strcmp (level,"All") == 0) || (strcmp (level,"aLL") == 0) ) 
                    strcpy (level, "0-1023");
                 

                 /*** convert the level string in level array ***/

                 VDman_convert_lev_string (&msg, level, levels);  
                 if ((msg != OM_S_SUCCESS) && (msg != MSSUCC))
                  {
                     printf ("VDman_convert_lev_string: msg = <%ld>\n", msg);
                      continue;
                  }

                 if (d_state == 1)   /** display off ***/
                    flags = 0;
                 else
                    flags = 1;

                 upd = 0;
                 status =
                    ci$send(msg = message GRreffile.GRchglevels
                                       ( &sts, &flags, levels ),
                            targetid = EXRref_files[selected].ctx_id.objid,
                            targetos = EXRref_files[selected].ctx_id.osnum );
                 if(!(status&sts&1))
                  {
                      printf ("GRchglevels failed : status = <%d>,  sts = <%d>\n",
                              status, sts );
                      continue;
                  }
             }
         }
    }  /** for i **/
   if ( (selected != -1) && (upd != -1) )
       dp$update (msg = &msg);


   for (i = 0; i < num_rows; i = i + 1)
    {
       FIfld_set_select (form, EXR_REF_FILES_SCF, i,0, FALSE);
    }

   __DBGpr_com ("Check for layers");
   __DBGpr_int ("m_state ", m_state);
   __DBGpr_int ("d_state", d_state);

   if (selected == -1)
      return (0);       /** Should not happen, but just in case. **/


   if (m_state == 0)
    {
       /**  retrieve the selected layers from the EXR_LAYERS_MCF and turn
            them off/on based on the Layer Display toggle.                ***/

       num_levels = 0;
       status = FIfld_get_num_rows (form, EXR_LAYERS_MCF, &num_levels); 
       if (status != FI_SUCCESS)
          return (0);  /** This is ok. **/

       for (i = 0; i < num_levels; i = i + 1)
        {
           status = FIfld_get_select (form, EXR_LAYERS_MCF, i, 0, &sel_flag);
            if (status != FI_SUCCESS)
               return (status);
      
            if (sel_flag == TRUE)
             {

                status = FIfld_get_text (form, EXR_LAYERS_MCF, i, 1, 40,
                                         level, &sel_flag, &r_pos);
                if (status != FI_SUCCESS)
                   return (status);

                status = FIfld_get_line_color (form, EXR_LAYERS_MCF, i, 1,
                                               &color);
                if (status != FI_SUCCESS)
                   return (status);

   		__DBGpr_int ("line_color", color);

                n = 1; 
                if ( (d_state == 0) && ( (color == FI_RED) || 
                                         (strcmp (level, "1-1023") == 0) ) )
                 {
                    sprintf (EXRmsg_str,  "Turning layer <%s> on", level);
                    VDman_center_message (EXRform_info.ref_form,
                                          FI_MSG_FIELD, EXRmsg_str);
                    FIfld_set_line_color (form, EXR_LAYERS_MCF, i, 0, FI_GREEN);
                    FIfld_set_line_color (form, EXR_LAYERS_MCF, i, 1, FI_GREEN);

                    /*** convert the level string in level array ***/

                    VDman_convert_lev_string (&msg, level, levels);  
                    if ((msg != OM_S_SUCCESS) && (msg != MSSUCC))
                     {
                        printf ("msg = <%ld>\n", msg);
                        if (strcmp (level, "1-1023") == 0)
                           break;
                        else
                           continue;
                     }
                    flags = 1;

                    status =
                      ci$send(msg = message GRreffile.GRchglevels
                                           ( &sts, &flags, levels ),
                             targetid = EXRref_files[selected].ctx_id.objid,
                             targetos = EXRref_files[selected].ctx_id.osnum );
                    if(!(status&sts&1))
                     {
                         printf ("GRchglevels failed : status = <%d>,  sts = <%d>\n",
                                 status, sts );
                     }

                    if (sts != MSSUCC)
                     {
                        strcpy (EXRmsg_str,"Warning : Cannot change level <%s>",
                                level);
                        VDman_center_message (EXRform_info.ref_form,
					      FI_MSG_FIELD,
                                              EXRmsg_str);
                     }

                    if (strcmp (level, "1-1023") == 0)
                       break; 
                 }
                else if ( (d_state == 1) && ( (color == FI_GREEN) || 
                                             (strcmp (level, "1-1023") == 0) ) )
                 {
                    sprintf (EXRmsg_str, "Turning layer <%s> off", level);
                    VDman_center_message (EXRform_info.ref_form,
                                          FI_MSG_FIELD, EXRmsg_str);
                    FIfld_set_line_color (form, EXR_LAYERS_MCF, i, 0, FI_RED);
                    FIfld_set_line_color (form, EXR_LAYERS_MCF, i, 1, FI_RED);

                    /*** convert the level string in level array ***/

                    VDman_convert_lev_string (&msg, level, levels);  
                    if ((msg != OM_S_SUCCESS) && (msg != MSSUCC))
                     {
                        printf ("msg = <%ld>\n", msg);
                        if (strcmp (level, "1-1023") == 0)
                           break;
                        else
                           continue;
                     }
                    flags = 0;

                    status =
                       ci$send(msg = message GRreffile.GRchglevels
                                          ( &sts, &flags, levels ),
                               targetid = EXRref_files[selected].ctx_id.objid,
                               targetos = EXRref_files[selected].ctx_id.osnum );
                    if(!(status&sts&1))
                     {
                         printf ("GRchglevels failed : status = <%d>,  sts = <%d>\n",
                                 status, sts );
                     }

                    if (sts != MSSUCC)
                     {
                        strcpy (EXRmsg_str,"Warning : Cannot change level <%s>",
                                level);
                        VDman_center_message (EXRform_info.ref_form,
					      FI_MSG_FIELD,
                                              EXRmsg_str);
                     }

                    if (strcmp (level, "1-1023") == 0)
                       break; 
                 }
             }
        }  /** for i **/

       for (i = 0; i < num_levels; i = i + 1)
        {
           FIfld_set_select (form, EXR_LAYERS_MCF, i,0, FALSE);
           FIfld_set_select (form, EXR_LAYERS_MCF, i,1, FALSE);
        }
       dp$update (msg = &msg);
    }

   __DBGpr_com ("Exiting");

   End
   return (0);
}

void VDman_set_all_layers (form)
   Form form;
{
   int k, d_state, num_levels;
   int status, sel_flag;

   SetProc( VDman_set_all_layers ); Begin

   sel_flag = FALSE;
   status = FIfld_get_select (form, EXR_LAYERS_MCF, 0, 0, &sel_flag);
   if (status != FI_SUCCESS)
       return;

   if (sel_flag) 
    {
       num_levels = 0;
       status = FIfld_get_num_rows (form, EXR_LAYERS_MCF, &num_levels); 
       if (status != FI_SUCCESS)
          return;  

        /**  Get the display state from EXR_ON_OFF_LAY_TOGGLE  **/

        d_state = 0;
        FIg_get_state (form, EXR_ON_OFF_LAY_TOGGLE, &d_state);
        if (d_state == 0)
         {
            sprintf (EXRmsg_str, "Selecting all levels for display on");
            VDman_center_message (EXRform_info.ref_form,
				  FI_MSG_FIELD, EXRmsg_str);
            for (k = 1; k < num_levels; k = k + 1)
             {
                 FIfld_set_select (form, EXR_LAYERS_MCF, k, 0, TRUE);
                 FIfld_set_select (form, EXR_LAYERS_MCF, k, 1, TRUE);
             }
         }
        else 
         {
            sprintf (EXRmsg_str, "Selecting all levels for display off");
            VDman_center_message (EXRform_info.ref_form,
				  FI_MSG_FIELD, EXRmsg_str);
            for (k = 1; k < num_levels; k = k + 1)
             {
                 FIfld_set_select (form, EXR_LAYERS_MCF, k, 0, TRUE);
                 FIfld_set_select (form, EXR_LAYERS_MCF, k, 1, TRUE);
             }
         }
     }

    End
    return;
}

int  VDman_check_level_string (form)
    Form  form;
{
	char		level[256];
	int		sts, sel_flag, r_pos;
	long		msg;
	IGRint		levels[32]; 

        SetProc( VDman_check_level_string ); Begin

	sts = FIfld_get_text (form, EXR_KEYIN_LAYER_FIELD, 0, 0, 255,
                             level, &sel_flag, &r_pos);
	if (sts != FI_SUCCESS) return (sts);

    if ( (strcmp (level, "all") == 0) || (strcmp (level, "ALL") == 0) ||
         (strcmp (level, "All") == 0) || (strcmp (level, "aLL") == 0) ) 
       return (0);

    if (strcmp (level, "*") == 0) 
       return (0);

    if (strcmp (level, "") == 0)
       return (-2);

    /*** convert the level string in level array ***/

    __DBGpr_str ("level ", level);

    VDman_convert_lev_string (&msg, level, levels);  
    if ((msg != OM_S_SUCCESS) && (msg != MSSUCC))
     {
        sprintf (EXRmsg_str, "Invalid input in levels : <%s>", level);
        VDman_center_message (EXRform_info.ref_form, FI_MSG_FIELD, EXRmsg_str);
        strcpy (level, "");
        FIfld_set_text (form, EXR_KEYIN_LAYER_FIELD, 0, 0, level, FALSE); 
        return (-3);
     }

    End
    return (0);
}

form_notification ()
{
  ci$put (response = MOVE_ON);
}

long VDman_add_ref_files (level, parent, path, reftab)
    int  level;
    int  parent;
    char *path;
    struct EXR_reffile reftab;
{
   int i, j;
   int display;
   IGRchar ref_name[512];
   char *str_ptr;

   SetProc( VDman_add_ref_files ); Begin

   __DBGpr_int ("VDman_add_ref_files: level    ", level);
   __DBGpr_int ("VDman_add_ref_files: parent   ", parent);
   __DBGpr_str ("VDman_add_ref_files: path     ", path);
   __DBGpr_str ("VDman_add_ref_files: ref_file ", reftab.ref_name);

   if (EXRform_info.ref_count == 0)
    {
       EXRref_files = (EXRreference_files *) malloc (sizeof
                                                       (EXRreference_files));
       if (EXRref_files == NULL)
        {
           sprintf (EXRmsg_str,
                    "FATAL: Memory allocation error size = <%d> bytes\n",
                    sizeof (EXRreference_files));
           write (EXRmsg_str);
           return (VD_F_MemAllErr);
        }
       EXRform_info.ref_count = 1; 
       i = 1;
    }
   else
    {
       i = EXRform_info.ref_count + 1;
       EXRref_files = (EXRreference_files *) realloc (EXRref_files,
                                           i * sizeof (EXRreference_files));
       if (EXRref_files == NULL)
        {
           sprintf (EXRmsg_str,
                    "FATAL: Memory allocation error size = <%d> bytes\n",
                    sizeof (EXRreference_files));
           write (EXRmsg_str);
           return (VD_F_MemAllErr);
        }
       EXRform_info.ref_count = EXRform_info.ref_count + 1; 
    }
          
   /**  Only show the user the reference file_name not the path. **/

   strncpy (EXRref_files[i - 1].ref_file, reftab.ref_name, 39);
   EXRref_files[i - 1].ref_file[39] = '\0';
   sprintf (EXRref_files[i - 1].file, "%s%s", path, reftab.ref_name);

   __DBGpr_str ("EXRadd_ref_file: ref_file ", EXRref_files[i - 1].ref_file); 
   __DBGpr_str ("EXRadd_ref_file: file     ", EXRref_files[i - 1].file); 

   EXRref_files[i - 1].level = level;
   EXRref_files[i - 1].on_off = 0;
   EXRref_files[i - 1].parent = parent;
   EXRref_files[i - 1].display = reftab.display;
   EXRref_files[i - 1].ctx_id = reftab.ctx_id;
   EXRref_files[i - 1].md_env = reftab.md_env;
   EXRref_files[i - 1].osnum = reftab.osnum;

   End 
   return (VD_S_SUCCESS);
}

long VDman_get_ref_files (act_or_nested, ref_file, form)
   int  act_or_nested;  /** active = 1;  nested = 0 **/
   char *ref_file;
   Form form;
{
  int i, j, num_rows, sel, r_pos;
  int level; 
  int state;
  int fstatus;
  int num_lines;
  int parent;
  long pstatus;
  IGRchar ref_name[512];
  IGRchar path[80];
  IGRchar **lines;
  struct GRmd_env         mod_env;
  IGRlong                 refcount;
  struct EXR_reffile      *reftab;

  SetProc( VDman_get_ref_files ); Begin

  state = 0;
  FIg_get_state (form, EXR_SEL_MODE_TOGGLE, &state); 
  if (state == 0)
   {
      /** Clear out the EXR_LAYERS_MCF **/
      FIg_enable (form, EXR_LAYERS_MCF);
      FIfld_set_num_rows (form, EXR_LAYERS_MCF, 0);
      FIg_disable (form, EXR_LAYERS_MCF);
   }
  
  if (act_or_nested)
   {
      if (EXRform_info.cur_ref_idx == 0) 
       {
         strcpy (path, "");

         di$give_pathname (osnum = EXRmod_info.md_id.osnum,
                           pathname = path);

         __DBGpr_str ("path ", path);

         strcat (path, ":ref:"); 

         __DBGpr_str ("path ", path);

         refcount = 0;
         reftab = NULL;
         VDman_get_ref_info (&EXRmod_info, &refcount, &reftab);
         if(refcount <= 0)
          {
             pstatus = VD_E_FAILURE;
             strcpy (EXRmsg_str, "VDman_get_ref_files: No reference files\n");
             UI_status (EXRmsg_str);
             write (EXRmsg_str, "Error code = ", pstatus, "\n");
             return (VD_E_FAILURE);
          }

         for (i = 0; i < refcount; i = i + 1)
          {
             pstatus = VDman_add_ref_files (1, -1, path, reftab[i]);
             if (pstatus != VD_S_SUCCESS)
              {
                 if (EXRref_files != NULL)
                    free (EXRref_files); 
                 EXRref_files = NULL;
                 EXRform_info.ref_count = 0;
                 EXRform_info.cur_ref_level = 0;
                 EXRform_info.cur_ref_idx = 0;
                 if( reftab ) om$dealloc( ptr = reftab );
                 return (pstatus);
              }
          } /* for */
         EXRform_info.cur_ref_level = 1;
         if( reftab ) om$dealloc( ptr = reftab );
         reftab = NULL;
       }
    
      FIfld_set_num_rows (form, EXR_REF_FILES_SCF, 0);
      j = 0;
      for (i = 0; i < EXRform_info.ref_count; i = i + 1)
       {
          if (EXRref_files[i].level == 1)
           {
              fstatus = FIfld_set_text (form, EXR_REF_FILES_SCF, j, 0,
                                        EXRref_files[i].ref_file, FALSE);
              if (EXRref_files[i].display == 0)
               {
                  FIfld_set_line_color (form, EXR_REF_FILES_SCF, j, 0,
                                        FI_RED);
               }
              else
               {
                  FIfld_set_line_color (form, EXR_REF_FILES_SCF, j, 0,
                                        FI_GREEN);
               }
             
              j = j + 1;
           }
       }
      EXRform_info.cur_ref_idx = 1;
   } 
  else
   {
      if (strcmp (ref_file, "") == 0)
         return (VD_S_SUCCESS);

      state = 0;

      __DBGpr_str ("input reference file ", ref_file);

      strcpy (ref_name, ref_file);

      /**  Get the nested files for this reference file. **/
      /**  Child keeps track of its parent.              **/

      parent = -1;  /* reference file parent is active design file */
      level = 1;
      for (i = 0; i < EXRform_info.ref_count; i = i + 1) 
       {
          if ( (strcmp (EXRref_files[i].file, ref_file) == 0) &&
               (EXRref_files[i].level == EXRform_info.cur_ref_idx) )
           {
              if (EXRref_files[i].display == 0)
               {
                 return (1); 
                 strcpy (EXRmsg_str, 
                  "Cannot get nested files : Display is off");
                 VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                       EXRmsg_str);
                 return (1); 
               }
              parent = i;
              level = EXRref_files[i].level;
              strcpy (ref_name, EXRref_files[i].file);
              break;
           }
       }

      __DBGpr_int ("parent : index ", parent );
      __DBGpr_int ("parent : level ", level);
      __DBGpr_str ("ref_name       ", ref_name);

      if (parent == -1)
         return (VD_S_SUCCESS);  /** user unselected a row **/ 

      /** Children may already have been previously located.  if so no need
          to look in directory subsystem.                                 **/

      j = 0;
      for (i = 0; i < EXRform_info.ref_count; i = i + 1) 
      {
           if ((EXRref_files[i].parent == parent) &&
               (parent > -1))
            {
               j = 1;
               break; 
            } 
      }

      num_lines = 0;
      if (j == 0)
       {
          /** Get nested files by calling VDman_get_ref_info **/

          num_lines = 0;
          reftab = NULL;
          VDman_get_ref_info (&EXRref_files[parent].md_env, &num_lines, &reftab);
          if(num_lines <= 0)
           {
              pstatus = VD_S_SUCCESS;  /* assume no nested files */
              strcpy (EXRmsg_str, "No nested files found for selected file");
              VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                    EXRmsg_str);
              return (pstatus);
           }

          level = level + 1;
          for (i = 0; i < num_lines; i = i + 1)
           {
              /** The reference files do not have paths.  use the parent
                  as the path.                                            **/

              sprintf (ref_name, "%s%s", ref_file, ":ref:"); 
              pstatus = VDman_add_ref_files (level, parent, ref_name, reftab[i]);
              if (pstatus != VD_S_SUCCESS)
               {
                  if (EXRref_files != NULL)
                     free (EXRref_files); 
                  EXRref_files = NULL;
                  EXRform_info.ref_count = 0;
                  EXRform_info.cur_ref_level = 0;
                  EXRform_info.cur_ref_idx = 0;
                  if( reftab ) om$dealloc( ptr = reftab );
                  reftab = NULL;
                  return (pstatus);
               }
           } /* for */

          if( reftab ) om$dealloc( ptr = reftab );
          reftab = NULL;
       } /** if **/
      else
       {
          level = level + 1;  /** point to childs level **/
       }
      EXRform_info.cur_ref_idx = EXRform_info.cur_ref_idx + 1;

      __DBGpr_int ("Child: level", level);
    
      FIfld_set_num_rows (form, EXR_REF_FILES_SCF, 0);
      fstatus = FIfld_set_text (form, EXR_REF_FILES_SCF, 0, 0,
                                "..", FALSE);
      j = 1;
      for (i = 0; i < EXRform_info.ref_count; i = i + 1)
       {
          if ((EXRref_files[i].level == level) &&
              (EXRref_files[i].parent == parent))
           {

              fstatus = FIfld_set_text (form, EXR_REF_FILES_SCF, j, 0,
                                         EXRref_files[i].ref_file, FALSE);
              if (EXRref_files[i].display == 0)
               {
                  FIfld_set_line_color (form, EXR_REF_FILES_SCF, j, 0,
                                        FI_RED);
               }
              else
               {
                  FIfld_set_line_color (form, EXR_REF_FILES_SCF, j, 0,
                                        FI_GREEN);
               }
              j = j + 1;
           }
       }
   }

  End
  return (VD_S_SUCCESS);
}

int VDman_do_ref_files_exist (ref_file)
   char *ref_file;
{
  int num_lines;
  IGRchar **lines;
  IGRchar ref_name[512];
  int pstatus;

  SetProc( VDman_do_ref_files_exist ); Begin

  num_lines = 0;

  /** Get nested files from IGRdir **/

  sprintf (ref_name, "%s%s", ref_file, ":ref:*");

  __DBGpr_str(" query to IGDIR ", ref_name);

  di$find (start_dir = ref_name,
           regexp = "*",
           lines = &lines,
           ptr = &num_lines,
           max_level = -1,
           deep = NULL,
           options = OPT_LEVEL);

  if(num_lines <= 0)
   {
      pstatus = 1;  /* assume no nested files */
      strcpy (EXRmsg_str, "No nested files found for selected file");
      VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                            EXRmsg_str);
      return (pstatus);
   }
  di$free (lines = lines,
           count = num_lines);

  End
  return (0);
}

int VDman_get_levels_for_ref_file (form, g_label, osnum, objid)
Form            form;
int             g_label;
GRspacenum      osnum;
GRobjid         objid;
{
  IGRlong msg, sts;
  IGRint status;
  int i, j;
  IGRint levels[32];
  char level[5];
  char level_name[80];
  char level_str[512];
  IGRshort on_levels[1024], off_levels[1024], num_layers;
  GRobj window_id;
  int num_of_off_levels, num_of_on_levels;
  IGRlong sz_name_buf;

  SetProc( VDman_get_levels_for_ref_file ); Begin

  num_of_off_levels = 0;
  num_of_on_levels = 0;
  sz_name_buf = sizeof (level_name);

  /***  Get the levels that are on in the reference file attachment ***/
  status =
  ci$send(msg = message GRreffile.GRgetlevels ( &sts, levels ),
           targetid = objid,
           targetos = osnum );
  if(!(status&sts&1))
   {
       printf ("GRgetlevels : Cannot get ref file layers: status = <%d>, sts = <%d>\n", status, sts );
       return (-1);
   }

  /***  Get the level string from the level array ***/

/***  Get rid of this call it is here for re-checking ****/
  strcpy (level_str, "");
  msg = VDman_convert_lev_array( &status, levels, level_str ); 
/****                                               ***********/

  msg = VDman_get_on_off_lev( &status, levels, on_levels, &num_of_on_levels,
                           off_levels, &num_of_off_levels ); 
  if (status != MSSUCC)
   {
       /**  clear out the field **/

       FIg_enable (form, g_label);
       FIfld_set_num_rows (form, g_label, 0);
       FIg_display (form, g_label);
       return (-1);
   }

  __DBGpr_int ("num_of_on_levels", num_of_on_levels);
  __DBGpr_int ("num_of_off_levels", num_of_off_levels);

  j = 0;

  /**  clear out the field **/

  FIg_enable (form, g_label);
  FIfld_set_num_rows (form, g_label, 0);
  FIg_display (form, g_label);

  if ( (num_of_off_levels == 0) && (num_of_on_levels == 0) ) 
  {
      printf (" cannot get levels\n");
      return (1);
  } 

  sprintf (level, "all");
  FIfld_set_text (form, g_label, j, 0, level, FALSE);
  sprintf (level, "1-1023");
     FIfld_set_text (form, g_label, j, 1, level, FALSE);

  j = j + 1;

  for (i = 0; i < num_of_on_levels; i = i + 1)
   {
     strcpy (level_name, "");
     if (on_levels[i] == 0)
        continue;

     dp$levels_number_to_name (msg    = &msg,   
                               number = on_levels[i],
                               ret_num_lev = &num_layers,
                               size_name_buffer = &sz_name_buf,
                               name             = level_name,
                               osnum            = osnum,
                               mod_objid        = objid); 

     if (strcmp (level_name, "all") == 0)
        strcpy (level_name, "");

     FIfld_set_text (form, g_label, j, 0, level_name, FALSE);
     sprintf (level, "%-4.4d", on_levels[i]);
     FIfld_set_text (form, g_label, j, 1, level, FALSE);
     FIfld_set_line_color (form, g_label, j, 0, FI_GREEN);
     FIfld_set_line_color (form, g_label, j, 1, FI_GREEN);
     j = j + 1;
   }

  for (i = 0; i < num_of_off_levels; i = i + 1)
   {
     strcpy (level_name, "");
     if (off_levels[i] == 0)
        continue;
     dp$levels_number_to_name (msg    = &msg,   
                               number = off_levels[i],
                               ret_num_lev = &num_layers,
                               size_name_buffer = &sz_name_buf,
                               name             = level_name,
                               osnum            = osnum,
                               mod_objid        = objid); 

     if (strcmp (level_name, "all") == 0)
        strcpy (level_name, "");
     FIfld_set_text (form, g_label, j, 0, level_name, FALSE);
     sprintf (level, "%-4.4d", off_levels[i]);
     FIfld_set_text (form, g_label, j, 1, level, FALSE);
     FIfld_set_line_color (form, g_label, j, 0, FI_RED);
     FIfld_set_line_color (form, g_label, j, 1, FI_RED);
     j = j + 1;
   }

 /***  Set the list to the first visible row ***/ 

  FIfld_pos_cursor  (form, g_label, 0, 0, 0, 0, 0, 0);
  FIfld_set_select (form, g_label, 0, 0, FALSE);
  FIfld_set_select (form, g_label, 0, 1, FALSE);

  End
  return (0);
}

/** Calling routine needs to make sure the ref_file display is on before
    calling this routine.   VDman_get_layers
***/

int VDman_get_layers (ref_file, form)
   char *ref_file;
   Form form;
{
  int state;
  int i, j, num_rows, sel_flag, r_pos;
  char sel_file[40];

  SetProc( VDman_get_layers ); Begin

  __DBGpr_str(" ref_file ", ref_file );

  /**  If the gadget state is single select mode get the layer
       information for this file and put it in layer list          **/

  state = 0;
  FIg_get_state (form, EXR_SEL_MODE_TOGGLE, &state);  
  if (state == 1)
     return (1);   /** Multi select mode **/

  /**  If the Display toggle is set to Display OFF, do not get
       the layers.                                                 **/

  state = 0;
  FIg_get_state (form, EXR_DISPLAY_TOGGLE, &state);  
  if (state == 1)
     return (1);   /** Reference file Display is OFF **/

  /**  find the reference file in the list and use this index to get the
       layers.
  **/

  j = -1;

  /** Get the selected file from the EXR_REF_FILES_SCF **/

  num_rows = 0; 
  FIfld_get_num_rows (form, EXR_REF_FILES_SCF, &num_rows);
  if (num_rows <= 0)
     return (1);

  strcpy (sel_file, "");
  for (i = 0; i < num_rows; i = i + 1)
   {
       sel_flag = FALSE;
       FIfld_get_select (form, EXR_REF_FILES_SCF, i, 0, &sel_flag);
       if (sel_flag)
        {
            FIfld_get_text (form, EXR_REF_FILES_SCF, i, 0, 39, sel_file,
                            &sel_flag, &r_pos);
            break;
        } 
   } 

  if (strcmp (sel_file, "") == 0)  /** nothing was selected **/
     return (1);
  __DBGpr_str ("sel_file", sel_file);

  for (i = 0; i < EXRform_info.ref_count; i = i + 1)
   {
      if ( (strcmp (EXRref_files[i].file, ref_file) == 0) &&
           (strcmp (EXRref_files[i].ref_file, sel_file) == 0) )
       {
           j = i;
           break;
       }
   }

  if (j == -1)  /*** shouldn't happen but just in case ***/
     return (1);   /** Reference file Display is OFF **/

  __DBGpr_int ("file index", j);
  __DBGpr_str ("EXRref_files.file", EXRref_files[j].file);

  if (EXRref_files[j].display == 0)
     return (1);   /** reference file display is off **/

  /** Get the layers for this reference file **/

  FIg_enable (form, EXR_LAYERS_MCF);
  FIg_display (form, EXR_LAYERS_MCF);

  strcpy (EXRmsg_str,
          "Retrieving layers, please wait ..."); 
  VDman_center_message (EXRform_info.ref_form,  FI_MSG_FIELD, EXRmsg_str); 

  VDman_get_levels_for_ref_file (form, EXR_LAYERS_MCF,
                   EXRref_files[j].ctx_id.osnum,  EXRref_files[j].ctx_id.objid);
  strcpy (EXRmsg_str, ""); 
  FIfld_set_text (EXRform_info.ref_form, FI_MSG_FIELD, 0, 0, EXRmsg_str,
                  FALSE); 

  End
  return (0);
}

void VDman_set_display_on (form)
  Form form;
{
  int state;

  SetProc( VDman_set_display_on ); Begin

  /** get the selection mode toggle state. **/

  state = 0;
  FIg_get_state (form, EXR_SEL_MODE_TOGGLE, &state);

  if (state == 0)
   {  
       /** Single select mode **/
      
       FIg_erase (form, EXR_KEYIN_LAYER_FIELD);
       FIg_disable (form, EXR_KEYIN_LAYER_FIELD);
       FIg_erase (form, EXR_KEYIN_TEXT);

       FIg_display (form, EXR_NESTED_REFS_BUTTON);
       FIg_enable (form, EXR_LAYERS_MCF);
       FIg_display (form, EXR_LAYERS_MCF);
       FIg_display (form, EXR_USED_TEXT);
       FIg_display (form, EXR_USED_RECT);
       FIg_display (form, EXR_LAYER_TEXT);
       FIg_display (form, EXR_LAYER_RECT);
       FIg_display (form, EXR_VALUE_TEXT);
       FIg_display (form, EXR_VALUE_RECT);

       /** Don't need to set the selection mode.  **/
       FIfld_set_mode (form, EXR_REF_FILES_SCF, 0, FI_SINGLE_SELECT);
   }
  else
   { 
       /** Multi select mode **/
      
       FIg_erase (form, EXR_NESTED_REFS_BUTTON);
       FIg_disable (form, EXR_NESTED_REFS_BUTTON);
       FIg_erase (form, EXR_LAYERS_MCF);
       FIg_disable (form, EXR_LAYERS_MCF);
       FIg_erase (form, EXR_USED_TEXT);
       FIg_erase (form, EXR_USED_RECT);
       FIg_erase (form, EXR_LAYER_TEXT);
       FIg_erase (form, EXR_LAYER_RECT);
       FIg_erase (form, EXR_VALUE_TEXT);
       FIg_erase (form, EXR_VALUE_RECT);

       FIg_enable (form, EXR_KEYIN_LAYER_FIELD);
       FIg_display (form, EXR_KEYIN_LAYER_FIELD);
       FIg_display (form, EXR_KEYIN_TEXT);
       FIg_enable (form, EXR_KEYIN_TEXT);

       /** Don't need to set the selection mode.  **/
       FIfld_set_mode (form, EXR_REF_FILES_SCF, 0, FI_MULTI_SELECT);
   }

   FIg_enable (form, EXR_ON_OFF_LAY_TOGGLE);
   FIg_display (form, EXR_ON_OFF_LAY_TOGGLE);

   End
   return;
} 

void VDman_set_display_off (form)
  Form form;
{
  int state;

  SetProc( VDman_set_display_off ); Begin

  /** get the selection mode toggle state. **/

  state = 0;
  FIg_get_state (form, EXR_SEL_MODE_TOGGLE, &state);

  if (state == 0)
   {  
       /** Single select mode **/
      
       /** Clear out the EXR_LAYERS_MCF **/

       FIg_enable (form, EXR_LAYERS_MCF);
       FIfld_set_num_rows (form, EXR_LAYERS_MCF, 0);
       FIg_disable (form, EXR_LAYERS_MCF);

       /** Don't need to set the selection mode.  **/
       FIfld_set_mode (form, EXR_REF_FILES_SCF, 0, FI_SINGLE_SELECT);
   }
  else
   { 
       /** Multi select mode **/
      
       FIg_disable (form, EXR_KEYIN_LAYER_FIELD);
       FIg_disable (form, EXR_KEYIN_TEXT);


       /** Don't need to set the selection mode.  **/
       FIfld_set_mode (form, EXR_REF_FILES_SCF, 0, FI_MULTI_SELECT);
   }

   FIg_disable (form, EXR_ON_OFF_LAY_TOGGLE);

   End
   return;
} 

int VDman_get_selected_file (ref_file, form)
   char *ref_file;   /** O : should be large enough to hold 256 chars **/
   Form form;
{
  int i, j, k, parent, num_rows, vis_rows, sel_flag, r_pos;
  int state, selected;
  char tmp_file[256];
  int status;

  SetProc( VDman_get_selected_file ); Begin

  __DBGpr_str ("ref_file    ", ref_file);
  __DBGpr_int ("cur_ref_idx ", EXRform_info.cur_ref_idx);

  selected = 0;
  status = FIfld_get_num_rows (form, EXR_REF_FILES_SCF, &num_rows); 
  if (status != FI_SUCCESS){
     End
     return (status);
  }

  for (j = 0; j < EXRform_info.ref_count; j = j + 1)
   {
      /** for this level turn off all on_off's for children at this level **/

      if (EXRref_files[j].level == EXRform_info.cur_ref_idx)
         EXRref_files[j].on_off = 0;
   }

  for (i = 0; i < num_rows; i = i + 1)
   {
      status = FIfld_get_select (form, EXR_REF_FILES_SCF, i, 0, &sel_flag); 
      if (status != FI_SUCCESS){
         End
         return (status);
      }

      if (sel_flag == TRUE)
       {
          selected = 1;
          status = FIfld_get_text (form, EXR_REF_FILES_SCF, i, 0, 255,
                                   tmp_file, &sel_flag, &r_pos);
          if (status != FI_SUCCESS){
             End
             return (status);
          }

	  __DBGpr_str(" selected_file ", tmp_file);

          if (strcmp (tmp_file, "..") != 0)
           {
              strcat (ref_file, ":ref:");
              strcat (ref_file, tmp_file);

              /**  find the reference file in the EXRref_files array  **/

              for (j = 0; j < EXRform_info.ref_count; j = j + 1)
               {
                  if ( (strcmp (tmp_file, EXRref_files[j].ref_file) == 0) &&
                       (EXRref_files[j].level == EXRform_info.cur_ref_idx) )
                   {
                      strcpy (ref_file, EXRref_files[j].file);
		      __DBGpr_str(" ref_file ", ref_file );
                      EXRref_files[j].on_off = 1;
                      if (EXRref_files[j].display == 0)
                       {
                          VDman_set_display_off (form);
                          /** disable the EXR_NESTED_REFS_BUTTON  **/

                          FIg_disable (form, EXR_NESTED_REFS_BUTTON);

                           /** clear out the EXR_LAYER_MCF ***/
                    
                           FIg_enable (form, EXR_LAYERS_MCF);
                           FIfld_set_num_rows (form, EXR_LAYERS_MCF, 0); 
                           FIg_disable (form, EXR_LAYERS_MCF);

			  End
                          return (-1);
                       }
                      else
                          VDman_set_display_on (form);
                      break;
                   }
               }          
           }
          else
           {

              /** clear out the EXR_LAYER_MCF ***/

              FIfld_set_num_rows (form, EXR_LAYERS_MCF, 0); 
              FIg_disable (form, EXR_LAYERS_MCF);

              /** need to go back up one level **/

              EXRform_info.cur_ref_idx = EXRform_info.cur_ref_idx - 1;

              /** get the parent **/

              k = EXRform_info.cur_ref_idx;
              parent = 0;

	      __DBGpr_int(" cur_ref_idx ", k );

              for (j = 0; j < EXRform_info.ref_count; j = j + 1)
              {
                  if ( (EXRref_files[j].level == k) &&
                       (EXRref_files[j].on_off == 1) )
                   {
                      strcpy (ref_file, EXRref_files[j].file);
                      if (EXRref_files[j].display == 0)
                          VDman_set_display_off (form);
                      else
                          VDman_set_display_on (form);
                      parent = j;
                      break;
                   }
              }          

		__DBGpr_str(" ref_file ", ref_file );
		__DBGpr_int(" parent   ", parent );
     
              /** Get maximum number of visible rows for EXR_REF_FILES_SCF. **/

              vis_rows = 7;
              FIfld_get_num_vis_rows (form, EXR_REF_FILES_SCF, &vis_rows); 

              /** clear out the EXR_REF_FILES_SCF field.  **/

              FIfld_set_num_rows (form, EXR_REF_FILES_SCF, 0); 

              k = 0; 
              for (j = 0; j < EXRform_info.ref_count; j = j + 1)
              {
                   sel_flag = FALSE;
                   if (EXRref_files[j].level == EXRform_info.cur_ref_idx)
                    {
                       if (parent == j)
                        {
                           r_pos = k;
                           sel_flag = TRUE;
                        }
                       status = FIfld_set_text (form, EXR_REF_FILES_SCF, k, 0,
                                         EXRref_files[j].ref_file, sel_flag);
                       if (EXRref_files[j].display == 0)
                        { 
                           FIfld_set_line_color (form, EXR_REF_FILES_SCF, k, 0,
                                                 FI_RED);
                        }
                       else
                        {
                           FIfld_set_line_color (form, EXR_REF_FILES_SCF, k, 0,
                                                 FI_GREEN);
                        }
                       k = k + 1;
                    } 
               }

              if (r_pos > vis_rows)
               {
                  FIfld_pos_cursor (form, EXR_REF_FILES_SCF, r_pos,
                                    r_pos + (vis_rows / 2), 0, 0, 0, 0);
               }

           }  /** if sel_flag == TRUE **/

	  End
          return (0); 
       }
   }

  if (selected == 0)
   {
      /** disable the EXR_NESTED_REFS_BUTTON  **/

      FIg_disable (form, EXR_NESTED_REFS_BUTTON);

      state = 0;
      FIg_get_state (form, EXR_SEL_MODE_TOGGLE, &state);
      if (state == 1)
       {
          strcpy (ref_file, "");
	  End
          return (-1);
       }

       /** clear out the EXR_LAYER_MCF ***/

       FIfld_set_num_rows (form, EXR_LAYERS_MCF, 0); 
       FIg_disable (form, EXR_LAYERS_MCF);
   }

  strcpy (ref_file, "");
  End
  return (-1);
}

void VDman_set_groups (select_mode, form)
  int  select_mode;
  Form form;
{
  int state;

  SetProc( VDman_set_groups ); Begin
  state = 0;
  FIg_get_state (form, EXR_DISPLAY_TOGGLE, &state); 

  if (select_mode == 0)
   {  
       /** Single select mode **/
      
       FIg_erase (form, EXR_KEYIN_LAYER_FIELD);
       FIg_disable (form, EXR_KEYIN_LAYER_FIELD);
       FIg_erase (form, EXR_KEYIN_TEXT);
       FIg_display (form, EXR_NESTED_REFS_BUTTON);
       if (state == 0)
          FIg_enable (form, EXR_LAYERS_MCF);
       FIg_display (form, EXR_LAYERS_MCF);
       FIg_display (form, EXR_USED_TEXT);
       FIg_display (form, EXR_USED_RECT);
       FIg_display (form, EXR_LAYER_TEXT);
       FIg_display (form, EXR_LAYER_RECT);
       FIg_display (form, EXR_VALUE_TEXT);
       FIg_display (form, EXR_VALUE_RECT);

       /**  Set the selection mode for EXR_REF_FILES_SCF to SINGLE_SELECT **/ 

       FIfld_set_mode (form, EXR_REF_FILES_SCF, 0, FI_SINGLE_SELECT);
   }
  else
   { 
       /** Multi select mode **/
      
       FIg_erase (form, EXR_NESTED_REFS_BUTTON);
       FIg_disable (form, EXR_NESTED_REFS_BUTTON);
       FIg_erase (form, EXR_LAYERS_MCF);
       FIg_disable (form, EXR_LAYERS_MCF);
       FIg_erase (form, EXR_USED_TEXT);
       FIg_erase (form, EXR_USED_RECT);
       FIg_erase (form, EXR_LAYER_TEXT);
       FIg_erase (form, EXR_LAYER_RECT);
       FIg_erase (form, EXR_VALUE_TEXT);
       FIg_erase (form, EXR_VALUE_RECT);

       if (state == 0)
          FIg_enable (form, EXR_KEYIN_LAYER_FIELD);
       FIg_display (form, EXR_KEYIN_LAYER_FIELD);
       FIg_display (form, EXR_KEYIN_TEXT);
       if (state == 0)
          FIg_enable (form, EXR_KEYIN_TEXT);

       /**  Set the selection mode for EXR_REF_FILES_SCF to MULTI_SELECT **/ 

       FIfld_set_mode (form, EXR_REF_FILES_SCF, 0, FI_MULTI_SELECT);
   }

  End
  return;
} 

long VDman_ref_form_init ()
{
   int		sts;

  /*
   * the initialization of the form, which includes setting/linking the form
   * to the command object; Get the form input and display the found
   * information in the form.
   */
 
  SetProc( VDman_ref_form_init ); Begin

  sts = FIf_new (EXRREF_FORM, EXR_REF_FORM, ci_notification,
		     &EXRform_info.ref_form);
  if ( (sts != FI_SUCCESS) || (EXRform_info.ref_form == NULL) )
  {
      UI_status(" Form Creation Failed ");
      return (VD_F_InitForm);
  }

  EXRform_info.ref_form_exists = TRUE;

  /*
   * MY_ID and OM_Gw_current_OS are symbolic constants that are defined in
   *   the "ciminimum.h" include file.
   */

  sts = FIf_set_cmd_oid_os (EXRform_info.ref_form, MY_ID, OM_Gw_current_OS);
  if (sts != FI_SUCCESS){

	UI_status( "FATAL: Cannot link to the I/Forms system");

	/*
	 * The form has been loaded into memory at this point.  we need to
         * delete it from memory at this point.  return_error will not
         * delete the form. 
	 */ 
	EXRform_info.ref_form_exists = FALSE;
	FIf_delete (EXRform_info.ref_form);
	EXRform_info.ref_form_displayed = FALSE;
	return (VD_F_FormLink);
  }

  /** Enable the needed gadgets and disable unneeded. **/

  VDman_set_groups (EXR_SINGLE_SELECT_MODE, EXRform_info.ref_form);

  FIg_set_state_off (EXRform_info.ref_form, EXR_SEL_MODE_TOGGLE);
  FIg_set_state_off (EXRform_info.ref_form, EXR_DISPLAY_TOGGLE);
  FIg_set_state_off (EXRform_info.ref_form, EXR_ON_OFF_LAY_TOGGLE);
  FIg_disable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);
  FIg_disable (EXRform_info.ref_form, EXR_LAYERS_MCF);

  /*
   * Put the reference files into the EXR_REF_FILES_SCF list **
   */

  sts = VDman_get_ref_files (1, "", EXRform_info.ref_form);
  if (sts != VD_S_SUCCESS){

	UI_status(" Error: Retrievel Reference Files Failed ");

	EXRform_info.ref_form_exists = FALSE;
	EXRform_info.ref_form_displayed = FALSE;
	FIf_delete (EXRform_info.ref_form);
	EXRform_info.ref_form = NULL ;
	return( sts );
  }

  EXRform_info.cur_ref_level = 1;

  /*
   * display the form
   */

  sts = FIf_display (EXRform_info.ref_form);
  if (sts != FI_SUCCESS){

	UI_status(" ERROR: Cannot display th form");
	EXRform_info.ref_form_exists = FALSE;
	EXRform_info.ref_form_displayed = FALSE;
	FIf_delete (EXRform_info.ref_form);
	EXRform_info.ref_form = NULL ;
	return( VD_F_DisplayForm );

  }

  EXRform_info.ref_form_displayed = TRUE;
  EXRform_info.ref_form_exists = TRUE;

  /**  Overide update to display before forms are displayed **/
 
  strcpy (EXRmsg_str, "");
  status (EXRmsg_str);
  FIfld_set_text (EXRform_info.ref_form, FI_MSG_FIELD, 0, 0,
                  EXRmsg_str, FALSE);
  strcpy (EXRmsg_str, "Awaiting user input ...");
  VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD, EXRmsg_str);

  End
  return (VD_S_SUCCESS);
}

long VDman_reset (select_mode, form)
  int  select_mode;
  Form form; 
{
  int i, j;
  char text1[8];

  SetProc(VDman_reset); Begin

  strcpy (text1, "");
  FIg_enable (form, EXR_KEYIN_LAYER_FIELD);
  FIfld_set_text (form, EXR_KEYIN_LAYER_FIELD, 0, 0, text1, FALSE);

  VDman_set_groups (select_mode, form);

  if (select_mode == EXR_SINGLE_SELECT_MODE)
   { 
      /** Set the gadget state to single select mode **/  

      FIg_set_state (form, EXR_SEL_MODE_TOGGLE, 0);

      /** unselect the files in the attached files list **/

      j = 0;
      FIfld_get_num_rows (form, EXR_REF_FILES_SCF, &j);
      for (i = 0; i < j; i = i + 1)
       {
          FIfld_set_select (form, EXR_REF_FILES_SCF, i, 0, FALSE);
       } 

      for (j = 0; j < EXRform_info.ref_count; j = j + 1)
       {
          /* for this level turn off all on_off's for children at this level */
    
          if (EXRref_files[j].level == EXRform_info.cur_ref_idx)
             EXRref_files[j].on_off = 0;
       }

      /** Clear out the EXR_LAYERS_MCF gadget **/

      FIg_enable (form, EXR_LAYERS_MCF);
      FIfld_set_num_rows (form, EXR_LAYERS_MCF, 0);
      FIg_disable (form, EXR_LAYERS_MCF);
      FIg_display (form, EXR_LAYERS_MCF);
   }

  /** Set the gadget state to single display on **/  

  FIg_set_state (form, EXR_DISPLAY_TOGGLE, 0);

  /** Set the gadget state to layer on **/  

  FIg_set_state (form, EXR_ON_OFF_LAY_TOGGLE, 0);

  End
  return (VD_S_SUCCESS);
}

int VDman_reference_form ()
{
  char 		help_cmd[256];
  char 		ref_file [512];
  int		sts, state; 
  int  		sel_flag, r_pos;
  int  		vis_rows;
  int  		i, j;
  int  		num_rows;
  int  		response;

  SetProc( VDman_reference_form ); Begin

  /*
   * this function is the main interface control for all activities with
   * the command. It manages the initialization and the form_notification
   * of the form.
   * It also controls the output functionalities of the command object.
   */

  state = 0; 

  strcpy (EXRmsg_str, "");
  strcpy (ref_file, "");

  sts = VDman_ref_form_init ();
  if ( sts != VD_S_SUCCESS){ return_error (); };
  
  /*
   * Process the form gadgets *
   */

  while (1)   /* loop until user cancels the form. */
  {

      /*** suspend the command file and wait for the form.   ***/

      ci$get (prompt = "Fill in the form", response = &response);

      strcpy (EXRmsg_str, "");

      FIfld_set_text (EXRform_info.ref_form, FI_MSG_FIELD, 0, 0,
                      EXRmsg_str, FALSE);
      FIfld_set_text (EXRform_info.ref_form, FI_PROMPT_FIELD, 0, 0,
                      EXRmsg_str, FALSE);

      switch (form_st.gadget_label){

	case FI_ACCEPT:
	case FI_EXECUTE: 

	  __DBGpr_com ("EXRreference_form: ACCEPT or EXECUTE ");

          /**  get the gadget state for the Select Mode toggle  **/

         __DBGpr_com ("IN case FI_ACCEPT, EXECUTE");
         __DBGpr_com ("Coding not finished for this gadget");

          strcpy (EXRmsg_str, "Processing requests,  please wait ...");
          VDman_center_message (EXRform_info.ref_form, FI_MSG_FIELD,
                                EXRmsg_str);

          sts = VDman_process_request (EXRform_info.ref_form);
          if (sts) break ;

	  if( form_st.gadget_label == FI_ACCEPT ){

	    __DBGpr_com ("EXRreference_form: ACCEPT ");
	    __DBGpr_com (" Before call to delete ");

            if (EXRref_files != NULL) 
                free (EXRref_files); 

            EXRref_files = NULL;

            EXRform_info.cur_ref_idx = 0; 
            EXRform_info.ref_count = 0; 
            EXRform_info.cur_ref_level = 0; 

            EXRform_info.ref_form_displayed = FALSE;
            EXRform_info.ref_form_exists = FALSE;
            FIf_delete (EXRform_info.ref_form);

      	    __DBGpr_com ("After call to delete\n");

	    return;
	  }

          /**  Reset the form gadgets **/
         
          strcpy (EXRmsg_str, "Successful Completion ...");
          VDman_center_message (EXRform_info.ref_form, FI_MSG_FIELD,
                                EXRmsg_str);
	  __DBGpr_com("Before calls to reset gadgets\n");

          VDman_reset (EXR_SINGLE_SELECT_MODE, EXRform_info.ref_form);
          strcpy (EXRmsg_str, "Awaiting user input ...");
          VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                EXRmsg_str);
	  __DBGpr_com("After calls to reset gadgets\n");
	  break;

	case FI_CANCEL:	/* Member of group FI_CTRL_GROUP */

          __DBGpr_com ("EXRreference_form: Cancel");

          if (EXRref_files != NULL)
              	free (EXRref_files); 
          EXRref_files = NULL;
          EXRform_info.cur_ref_idx = 0; 
          EXRform_info.ref_count = 0; 
          EXRform_info.cur_ref_level = 0; 

          EXRform_info.ref_form_displayed = FALSE;
          EXRform_info.ref_form_exists = FALSE;
          FIf_delete (EXRform_info.ref_form);

	  __DBGpr_com(" After Delete ... ");

	  return;

        case EXR_SEL_MODE_TOGGLE:

          __DBGpr_com ("EXRreference_form: EXR_SEL_MODE_TOGGLE ");

          state = 0;
          FIg_get_state (EXRform_info.ref_form, EXR_SEL_MODE_TOGGLE,
                                 &state);
          if (state)
           {
              __DBGpr_str(" Select Mode:  ref_file ", ref_file);

              VDman_set_groups (EXR_MULTI_SELECT_MODE, EXRform_info.ref_form);
              
              strcpy (EXRmsg_str,
                      "\"Attached Files\" list now in Multiple Select Mode");
              VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                    EXRmsg_str);
           }
          else
           {
              VDman_set_groups (EXR_SINGLE_SELECT_MODE, EXRform_info.ref_form);
              strcpy (EXRmsg_str,
                      "\"Attached Files\" list now in Single Select Mode");
              VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                    EXRmsg_str);

              /** If more than one file has been selected, unselect the files 
                  in the SCF except for the last selected file              **/
              
              j = 0;
              i = 0;
              num_rows = 0;
              FIfld_get_num_rows (EXRform_info.ref_form, EXR_REF_FILES_SCF,
                                  &num_rows);
              if (strcmp (ref_file, "") == 0)
               {
                  for (j = 0; j < num_rows;  j = j + 1)
                   {
                      FIfld_set_select (EXRform_info.ref_form,
                                        EXR_REF_FILES_SCF, j, 0, FALSE);
                   }
                  FIg_disable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);
                  break;
               } 

              i = 0;
              vis_rows = 0;
              FIfld_get_num_vis_rows (EXRform_info.ref_form, EXR_REF_FILES_SCF,
                                      &vis_rows);
              sel_flag = FALSE;
              i = -1;
              for (j = 0; j < num_rows;  j = j + 1)
               {
                  sel_flag = FALSE;
                  FIfld_get_text (EXRform_info.ref_form, EXR_REF_FILES_SCF,
                                  j, 0, 255, help_cmd, &sel_flag, &r_pos);
                  if (sel_flag == TRUE)
                   {
                      i = j;
                   }
               }

              /** Pass 2 **/

              for (j = 0; j < num_rows;  j = j + 1)
               {
                  if (i != j)
                   {
                      FIfld_set_select (EXRform_info.ref_form,
                                        EXR_REF_FILES_SCF, j, 0, FALSE);
                   } 
               }

              if (i > vis_rows)
               {
                  FIfld_pos_cursor (EXRform_info.ref_form, EXR_REF_FILES_SCF, i,
                                    i + (vis_rows / 2), 0, 0, 0, 0);
               }

             /** get the selected reference file **/

             sts = VDman_get_selected_file (ref_file, EXRform_info.ref_form);
             if((sts != 0) && (sts != -1) ){

                 strcpy (EXRmsg_str,
                        "Internal Error:  Cannot get selected file");
                 VDman_center_message (EXRform_info.ref_form, FI_MSG_FIELD,
                                       EXRmsg_str);
             }

             /**  If sts == -1 then just reset **/

             if (sts == -1)
                FIg_disable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);
             else
              {
                 sts =  VDman_do_ref_files_exist (ref_file);
                 if (sts != 0)
                  {
                     FIg_disable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);
                     break;
                  }
                 FIg_enable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);
              }
           }

	  break;

        case EXR_REF_FILES_SCF:

          __DBGpr_com ("EXRreference_form: EXR_REF_FILES_SCF ");

          state = 1;
          sts = FIg_get_state (EXRform_info.ref_form, EXR_SEL_MODE_TOGGLE,
                                    &state);

          /** get the selected reference file **/

          sts = VDman_get_selected_file (ref_file, EXRform_info.ref_form);
          if ( (sts != 0) && (sts != -1) ){

               strcpy (EXRmsg_str,
                      "Internal Error:  Cannot get selected file");
               VDman_center_message (EXRform_info.ref_form, FI_MSG_FIELD,
                                     EXRmsg_str);
          }

          if (state == EXR_SINGLE_SELECT_MODE)
          {
               /**  If sts == -1 file was unselected or display is off**/

            if ( sts == -1)
                  FIg_disable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);
            else{
                  sts =  VDman_do_ref_files_exist (ref_file);
                  if (sts != 0)
                     FIg_disable (EXRform_info.ref_form,
                                    EXR_NESTED_REFS_BUTTON);
                  else
                     FIg_enable (EXRform_info.ref_form, EXR_NESTED_REFS_BUTTON);

                  VDman_get_layers (ref_file, EXRform_info.ref_form);
            }
          }

          break;

        case EXR_NESTED_REFS_BUTTON:

          __DBGpr_com ("EXRreference_form: EXR_NESTED_REFS_BUTTON ");

          sts = VDman_get_ref_files (0, ref_file, EXRform_info.ref_form);
          break;

        case EXR_DISPLAY_TOGGLE:

          __DBGpr_com ("EXRreference_form: EXR_DISPLAY_TOGGLE ");

          /**  Get the toggle state  **/

          state = 0; 
          FIg_get_state (EXRform_info.ref_form, EXR_DISPLAY_TOGGLE, &state);
          if (state == 1)
          {
              VDman_set_display_off (EXRform_info.ref_form);
          }
          else  
          {
              VDman_set_display_on (EXRform_info.ref_form);
              state = 1; 
              FIg_get_state (EXRform_info.ref_form,EXR_SEL_MODE_TOGGLE,&state);
              if (state == 0) 
                   VDman_get_layers (ref_file, EXRform_info.ref_form);
           }
          strcpy (EXRmsg_str, 
                  "Only files in the current attachment level are eligible");
          VDman_center_message (EXRform_info.ref_form, FI_PROMPT_FIELD,
                                EXRmsg_str);

        break;

        case EXR_LAYERS_MCF:

          __DBGpr_com ("EXRreference_form: EXR_LAYERS_MCF ");

            VDman_set_all_layers (EXRform_info.ref_form);
        break;

        case EXR_KEYIN_LAYER_FIELD:

          __DBGpr_com ("EXRreference_form: EXR_KEYIN_LAYER_FIELD ");

            VDman_check_level_string (EXRform_info.ref_form); 
        break;

       }  /** switch **/
      form_st.gadget_label = 0;
    }   /****  while  ****/

	End 
}

main ()
{
  /*
   * this function is the main interface control for all activities with
   * the command. It manages the initialization and the form_notification
   * of the form.
   * It also controls the output functionalities of the command object.
   */

  strcpy (EXRmsg_str, "");

  /** setup the signal handler **/
  EXRref_files				= NULL;
  EXRform_info.ref_count		= 0; 
  EXRform_info.cur_ref_idx		= 0; 
  EXRform_info.cur_ref_level		= 0; 
  EXRform_info.main_form_exists		= FALSE;  
  EXRform_info.help_form_exist		= FALSE;  
  EXRform_info.ref_form_exists		= FALSE;  
  EXRform_info.main_form_displayed	= FALSE;  
  EXRform_info.ref_form_displayed	= FALSE;  
  EXRform_info.help_form_displayed	= FALSE;  

  ci$get_module_info( md_env = &EXRmod_info );

  /*
  ** Get the reference form 
  */
  
  VDman_reference_form ();
}
