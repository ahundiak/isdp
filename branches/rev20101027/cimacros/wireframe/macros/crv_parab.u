/* $Id: crv_parab.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / crv_parab.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: crv_parab.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"

 
struct GRid	CI_MACRO_ID;


GRobj 			ci_mac_def1, CURVE;

IGRdouble 	 	pt1[15],rho,focus;
IGRdouble		p1[3],p2[3],p3[3],p4[3],p5[3],p6[3];
IGRdouble		stpt[3],enpt[3],fpt[3],axis[3],cvst[3],cvst1[3];
IGRdouble		unit_vecx[3],unit_vecy[3],vecy;
IGRdouble		vec1,vec2,vec3,anga,angb;
IGRdouble		xdist1,xdist2,xdist3,xdist4,xdist5;
IGRdouble		ydist1,ydist2,ydist3,ydist4,ydist5;

IGRint			i, j, opt;
IGRlong		        stat, msg;
struct GRvg_construct	cst;
struct GRmd_env		MOD_ENV;
struct IGRdisplay	dis;

struct GRid		COMP;

struct ret_struct	temp_rts, expr;

IGRchar 		*temp_names[5], *feet_names[1], txt[5];
IGRint			temp_types[5];


extern int init_cnst_list();
extern			ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

  temp_names[0]="fpt";
  temp_names[1]="axis";
  temp_names[2]="stpt";
  temp_names[3]="enpt";
  temp_names[4]="focus";

  for(i=0;i<4;i=i+1) temp_types[i] = point_generic;
  temp_types[4] = parameter_generic | double_type;
 
  feet_names[0]="ressur";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat,
	 	name              = "crv_parab",
              	temp_num          = 5, 		
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{

  construct_comp();

  if( COMP.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &COMP, &MOD_ENV ),
	   	targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum );
  return(1);

}

/* ========================================================================= */

place ()
{

  construct_comp();

  if( COMP.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &COMP, &MOD_ENV ),
	   	targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum );
  return(1);

}


/* ========================================================================= */

construct_comp()
{

     COMP.objid = NULL_OBJID;
     COMP.osnum = MOD_ENV.md_id.osnum;


     msg = ci$send( msg = message  ACcpx.ACfind_temp_struct
		(&stat,"fpt",(char *) &temp_rts,&MOD_ENV ),
 	        targetid = CI_MACRO_ID.objid ,
	      	targetos = CI_MACRO_ID.osnum );
     if( !(stat&msg&1) ) return;
     for(j=0; j<3; j=j+1)fpt[j] = temp_rts.var.point_st.pt[j];


     msg = ci$send( msg = message  ACcpx.ACfind_temp_struct
		(&stat,"axis", (char *)&temp_rts,&MOD_ENV ),
 	      	targetid = CI_MACRO_ID.objid ,
	      	targetos = CI_MACRO_ID.osnum );
     if( !(stat&msg&1) ) return;
     for(j=0; j<3; j=j+1)axis[j] = temp_rts.var.point_st.pt[j];


     msg = ci$send( msg = message  ACcpx.ACfind_temp_struct
		(&stat,"stpt", (char *)&temp_rts,&MOD_ENV ),
 	      	targetid = CI_MACRO_ID.objid ,
	      	targetos = CI_MACRO_ID.osnum );
     if( !(stat&msg&1) ) return;
     for(j=0; j<3; j=j+1)stpt[j] = temp_rts.var.point_st.pt[j];


     msg = ci$send( msg = message  ACcpx.ACfind_temp_struct
		(&stat,"enpt",(char *) &temp_rts,&MOD_ENV ),
 	        targetid = CI_MACRO_ID.objid ,
	        targetos = CI_MACRO_ID.osnum );
     if( !(stat&msg&1) ) return;
     for(j=0; j<3; j=j+1)enpt[j] = temp_rts.var.point_st.pt[j];


     msg = ci$send( msg = message  ACcpx.ACfind_temp_struct
		(&stat,"focus",(char *) &expr,&MOD_ENV ),
 	        targetid = CI_MACRO_ID.objid ,
	        targetos = CI_MACRO_ID.osnum );
     if( !(stat&msg&1) ) return;
     focus = expr.var.root_pm_st.value;



// CALCULATE THE START AND END VALUES FOR THE PARABOLA

 v_sub(axis,fpt,p1);
 v_scale(p1,1/v_len(p1),unit_vecx);
 v_scale(unit_vecx,focus,cvst1); /*zero vector*/
 v_sub(fpt,cvst1,cvst);         /*starting point for complete parab*/
// write("origin=",cvst,'\n');

 v_sub(stpt,cvst,p1);		 /*normalized vector of first point*/
 v_scale(p1,1/v_len(p1),p2);
 v_cross(unit_vecx,p2,p3);
 v_cross(p3,unit_vecx,unit_vecy); /*unit vector for y axis*/
 v_scale(unit_vecy,1/v_len(unit_vecy),p6);
 v_equal(p6,unit_vecy);

vecy=v_len(unit_vecy);
//write("y vec=",vecy,'\n');

 anga=v_dot(unit_vecx,p2);    /* the angle between axis and stpt through cvst*/

 xdist1=v_len(p1)*(anga); 
 if(xdist1 < 0)xdist1=0;
 ydist1=sqrt(xdist1*focus*4);

 // calculate the endpoint on the curve

 v_sub(enpt,cvst,p1);		 /*normalized vector of second point*/
 v_scale(p1,1/v_len(p1),p2);
 anga=v_dot(unit_vecx,p2);    /* the angle between axis and enpt through cvst*/

 xdist2=v_len(p1)*(anga); 
 if(xdist2 < 0)xdist2=0;
 ydist2=sqrt(xdist2*focus*4);

 if(xdist1 < xdist2)
  {
   xdist3=(xdist2-xdist1)*.333+xdist1;
   ydist3=sqrt(xdist3*focus*4);

   xdist4=(xdist2-xdist1)*.5+xdist1;
   ydist4=sqrt(xdist4*focus*4);

   xdist5=(xdist2-xdist1)*.6667+xdist1;
   ydist5=sqrt(xdist5*focus*4);
  }
 else
  {
   xdist3=(xdist1-xdist2)*.333+xdist2;
   ydist3=sqrt(xdist3*focus*4);

   xdist4=(xdist1-xdist2)*.5+xdist2;
   ydist4=sqrt(xdist4*focus*4);

   xdist5=(xdist1-xdist2)*.6667+xdist2;
   ydist5=sqrt(xdist5*focus*4);
  }

 v_comb(xdist1,unit_vecx,ydist1,unit_vecy,p5);
 v_add(p5,cvst,&pt1[0]);

 v_comb(xdist3,unit_vecx,ydist3,unit_vecy,p5);
 v_add(p5,cvst,&pt1[3]);


 v_comb(xdist4,unit_vecx,ydist4,unit_vecy,p5);
 v_add(p5,cvst,&pt1[6]);


 v_comb(xdist5,unit_vecx,ydist5,unit_vecy,p5);
 v_add(p5,cvst,&pt1[9]);



 v_comb(xdist2,unit_vecx,ydist2,unit_vecy,p5);
 v_add(p5,cvst,&pt1[12]);


  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= NULL;
  cst.class_attr	= 0;
  cst.name		= 0;

   rho = .5;

   opt=50;

   CURVE = NULL_OBJID;

#ifdef DEBUG
 write( "enter GRbcsubbc.EMgenConicBy5inputs \n");
#endif

   msg = ci$send(msg= message GRbcsubbc.EMgenConicBy5inputs(
             &cst,opt,pt1,rho,&CURVE),
             targetid = COMP.objid,
	     targetos = COMP.osnum );
#ifdef DEBUG
 write( "exit GRbcsubbc.EMgenConicBy5inputs \n");
#endif

   if( !(msg&1 ) ) COMP.objid = NULL_OBJID;
   else            COMP.objid = CURVE;

}

