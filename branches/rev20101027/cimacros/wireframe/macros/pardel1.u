/* $Id: pardel1.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / pardel.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: pardel1.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.4  1997/04/23  13:34:04  pinnacle
# Replaced: cimacros/wireframe/macros/pardel1.u by ahundiak for vds.241
#
# Revision 1.3  1996/08/28  19:08:40  pinnacle
# TR179601878 ah
#
# Revision 1.1  1996/08/07  16:40:36  pinnacle
# TR179601878 Assoc Partial Delete
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *      04/17/97        AH              TR179700883 - Problem with u value
 *                                      for open curves
 *      08/06/96        AH              TR179601878 - Added support for
 *                                      physically closed curves.
 *                                      Replaces pardel.u macro
 *                                      Changes limited to LLbs_part_del
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   

#include <stdio.h>

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "EMSmsgdef.h"
#include "AS_status.h"
#include "v_geommacros.h"

#define	MAX_SEG		10
#define EPS 1.e-6

IGRlong			EMS_ret;
IGRshort		mat_type;
IGRdouble		matrix[16];
IGRboolean      	want_status;
IGRchar 		*temp_names[3], *feet_names[2], str[40], tmp[40];

IGRint			stat, msg, i, j, num_surfaces;
GRobj 			ci_mac_def1, list[1], COMP, SURF;

IGRdouble               org[3], out_in[20], pnt[6], scaling_factor;

IGRint			chan_index;

OM_S_CHANSELECT		notify_chan, to_object;

IGRdouble		density;

struct GRid		CUV, GCV, CI_MACRO_ID, GRid_list[2], MPROP;
struct	GRid		par_list[3];

struct GRmd_env		MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;

struct IGRpolyline      geom;


extern		BScveval(), BSmdstptcv(), ASextract_cv();



extern int 		init_cnst_list(),
			sprintf(),
			printf(),
			ASsuper_construct();

extern IGRboolean ASbroadcast_in_progress;

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  temp_names[0]  = "curve";  
  temp_names[1]  = "pt1";  
  temp_names[2]  = "pt2";  
  feet_names[0]  = "cv1";
  feet_names[1]  = "cv2";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef =  ci_mac_def1,
		status 	 = &stat, 	name = "pardel1",
              	temp_num = 3, 		temp_names = temp_names,
	      	extern_feet_num = 2, 	extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{
IGRint		nb_comp;


  construct_comp( &nb_comp, GRid_list );

  if( nb_comp == 0 )	return	0;

  if( (GRid_list[0].objid == NULL_OBJID) &&
      (GRid_list[1].objid == NULL_OBJID)    ) return(0); 

   ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, nb_comp, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );


  return(1);
}

/* ========================================================================= */

place ()
{
IGRlong		msg, sts;
struct	GRid	my_as_sup;
IGRint		nb_comp;

  construct_comp( &nb_comp, GRid_list );


  if( nb_comp == 0 )	return	0;

  if( (GRid_list[0].objid == NULL_OBJID) &&
      (GRid_list[1].objid == NULL_OBJID)    ) return(0); 

	/*| get support */
	sts = ci$send(	msg	 = message ACcpx.ACfind_exp_temp_obj
					( &msg, 0, &my_as_sup ),
			targetid = CI_MACRO_ID.objid,
			targetos = CI_MACRO_ID.osnum );
	as$status( sts = sts );

	/*| consume support */
	consume_and_display( my_as_sup, 1, 0, &MOD_ENV );

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, nb_comp, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}

/* ========================================================================= */
NDdelete(md_env)

struct GRmd_env *md_env;

{

struct GRid	my_as_sup;
	

	   if( md_env->md_id.objid == -1 ) goto wrapup ;

           ci$send( msg = message  ACcpx.ACfind_exp_temp_obj
					(&stat,0,&my_as_sup),
                    targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );
	   if(!stat) goto wrapup;

	   consume_and_display( my_as_sup, 0, 1, md_env );

wrapup:
        ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
	         targetid = CI_MACRO_ID.objid,
	         targetos = CI_MACRO_ID.osnum,
                 mode     = WRT_message );
 return(1);
}


/* ========================================================================= */

construct_comp( num_seg, seg_list )

IGRint		*num_seg;
struct	GRid	*seg_list;

{

struct	GRid	sup_go;
IGRlong		sts;
struct	GRmd_env	sup_env;
struct	GRid		bsp_to_del;

      seg_list[0].objid = NULL_OBJID;
      seg_list[0].osnum = MOD_ENV.md_id.osnum;
      seg_list[1].objid = NULL_OBJID;
      seg_list[1].osnum = MOD_ENV.md_id.osnum;

      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj
					(&stat,0,&par_list[0]),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj
					(&stat,1,&par_list[1]),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj
					(&stat,2,&par_list[2]),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );


 	sts = ci$send(msg = message NDnode.ASreturn_go(&sup_go,
						   &sup_env.md_env.matrix_type,
						    sup_env.md_env.matrix),
		  targetid = par_list[0].objid,
		  targetos = par_list[0].osnum);
	as$status( sts = sts, action = RET_STATUS );
	/*" sup_go : id/os = (%d/%d)\n", sup_go.objid, sup_go.osnum */

	/*| copy du graphic */
	sts = ci$send(msg          = message GRgraphics.GRcopy(&msg,
                	                  &sup_env,&MOD_ENV,
                        	          &(bsp_to_del.objid)),
		   targetid = sup_go.objid,
		   targetos = sup_go.osnum);
	as$status( sts = sts );
	bsp_to_del.osnum	= MOD_ENV.md_id.osnum;

	LLbs_part_del( bsp_to_del, par_list, &MOD_ENV, seg_list, num_seg );
/*^
	printf(" nb_seg : %d\n", *num_seg );
	printf(" GRid : %d, %d \n", seg_list[0].objid, seg_list[1].objid );
*/
}

IGRboolean IsCompCurve(curve_id)
struct GRid curve_id;
{
  IGRchar classname[32];
  IGRboolean isCompCurve;

  om$get_classname(
    objid = curve_id.objid,
    osnum = curve_id.osnum,
    classname = classname);

  if (om$is_ancestry_valid(
      subclassname = classname,
    superclassname = "GRcompcurve") == OM_S_SUCCESS)
  {
    isCompCurve = TRUE;
  }
  else
  {
    isCompCurve = FALSE;
  }

  return isCompCurve;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                          FCT LLbs_part_del                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* ---------------------------- 
 * TR179601878
 * Completely rewritten, roughly matches the non-associative
 * partial delete routine
 *
 * Following the conventions established in GR3ptpartdel, 
 * pt1 is the first cut point, 
 * pt2 is the direction point
 * pt3 is the second cut point
*/


LLbs_part_del( bsp_to_split, parents, md_env, segment, nseg )
struct	GRid	bsp_to_split;
struct	GRid	*parents;
struct	GRmd_env	*md_env;
struct	GRid		*segment;
IGRint			*nseg;
{
  IGRlong   status,msg; 
  struct    GRprops   props;     /* Properties of the support                 */
  IGRchar *bc;
  IGRlong size_geom;
  IGRlong rc,rc1;

  IGRpoint split_point;
  double dist;

  struct ret_struct pr1,pr3;

  IGRint         i;
  IGRpoint       pt1,pt2,pt3;     /* Projected points */
  IGRpoint       px1,px2,px3;     /* Copies of projected points */
  IGRdouble      pu1,pu2,pu3;     /* Original paramertization values */
  struct GRparms pa1,pa2,pa3;     /* Full parms information */
  struct GRid    result_id[2];    /* 2 possible result curves */
  struct GRid    comp_id;         /* Composite curve */       
  IGRlong        num;
  IGRdouble      u_eps;           /* Used to inccrement u-value a bit */
  IGRboolean     isCompCurve;
  IGRboolean     isClosed;

  /* nseg = 0 is one failure flag */
  *nseg = 0;
  bc = 0;

  /* Get information about curve to split */
  status = ci$send(msg  = message GRvg.GRgeomprops(&msg,
                                  &(md_env->md_env.matrix_type),
                                  md_env->md_env.matrix,
                                  &props),
	      targetos = bsp_to_split.osnum,
              targetid = bsp_to_split.objid);
  as$status(action = RET_STATUS);

  status = ci$send(msg = message GRvg.GRgetsize(&msg,
                                  &md_env->md_env.matrix_type,
                                   md_env->md_env.matrix,
                                   &size_geom),
              targetos = bsp_to_split.osnum,
              targetid = bsp_to_split.objid);
  as$status(action = RET_STATUS);

  bc =  om$malloc(size = size_geom);
  if (bc == NULL) goto wrapup;

  status = ci$send(msg = message GRvg.GRgetgeom(&msg,
                                  &(md_env->md_env.matrix_type),
                                  md_env->md_env.matrix,
                                  bc),
              targetos = bsp_to_split.osnum,
              targetid = bsp_to_split.objid);
  as$status(action = RET_STATUS);

  /* Find parameter values for two cutting points */
  status=ci$send(msg = message NDnode.NDgive_structure(&msg,&pr1, md_env),
                        targetos = parents[1].osnum,
                        targetid = parents[1].objid);
  as$status(action = GOTO_VALUE, value = wrapup );
  v_equal(pr1.var.point_st.pt,px1);
  BSmdstptcv(bc,px1,&pu1,split_point,&dist,&rc1);

  status=ci$send(msg = message NDnode.NDgive_structure(&msg,&pr3, md_env),
                        targetos = parents[2].osnum,
                        targetid = parents[2].objid);
  as$status(action = GOTO_VALUE, value = wrapup );
  v_equal(pr3.var.point_st.pt,px3);
  BSmdstptcv(bc,px3,&pu3,split_point,&dist,&rc1);

  /* Set Closed Flag */
  if ((props.phy_closed) || (props.closed)) {
    isClosed = TRUE;
  }
  else {
    isClosed = FALSE;
  }
  /* Composite curves should always return composite results */
  isCompCurve = IsCompCurve(bsp_to_split);

/* TR179700884 ah 17APR97
 * Before, I was adding a small value to one of the end point
 * parameters to calc the direction pt parameter (pu2).
 * Not sure why.
 * For open curves, just use median u value.
 * For close curves, use either median or add .5
 * based on order points were selected.
 */
 
  /* Direction point is in between curves */
  pu2 = (pu1 + pu3) / 2.0;

  /* For closed curve, adjust based on order selected */
  if ((isClosed) && (pu3 < pu1)) {
    pu2 = pu2 + .5;
    if (pu2 > 1.0) pu2 = pu2 - 1.0;
  }
/*
  printf("pu1: %5.2f, pu2: %5.2f, pu3: %5.2f\n",pu1,pu2,pu3);
*/
  /* Gets calculated direction point */
  BScveval(bc,pu2,0,px2,&rc);

  /* Obtain full GRparms information for each point */
  status = ci$send(msg = message GRgraphics.GRptproject(&msg,
                                  	&md_env->md_env.matrix_type,
                                         md_env->md_env.matrix,
                                         px1,pt1,&pa1),
                   	targetid = bsp_to_split.objid,
                   	targetos = bsp_to_split.osnum);
  as$status(action = GOTO_VALUE, value = wrapup );

  status = ci$send(msg = message GRgraphics.GRptproject(&msg,
                                  	&md_env->md_env.matrix_type,
                                         md_env->md_env.matrix,
                                         px3,pt3,&pa3),
                   	targetid = bsp_to_split.objid,
                   	targetos = bsp_to_split.osnum);
  as$status(action = GOTO_VALUE, value = wrapup );

  status = ci$send(msg = message GRgraphics.GRptproject(&msg,
                                  	&md_env->md_env.matrix_type,
                                         md_env->md_env.matrix,
                                         px2,
                                         pt2,&pa2),
                   	targetid = bsp_to_split.objid,
                   	targetos = bsp_to_split.osnum);
  as$status(action = GOTO_VALUE, value = wrapup );

/*
  printf("1 %.6f,%.6f, %.2f,%.2f,%.2f\n",pu1,pa1.u,pt1[0],pt1[1],pt1[2]);
  printf("2 %.6f,%.6f, %.2f,%.2f,%.2f\n",pu2,pa2.u,pt2[0],pt2[1],pt2[2]);
  printf("3 %.6f,%.6f, %.2f,%.2f,%.2f\n",pu3,pa3.u,pt3[0],pt3[1],pt3[2]);
*/

  /* Setup call to partial delete */
  num = 0;

  status=ci$send(msg = message GRcurve.GR3ptpartdel(&msg,md_env,
			pt1,pt2,pt3,&pa1,&pa2,&pa3,
                        &result_id[0].objid,&result_id[1].objid,&num),
                        targetos = bsp_to_split.osnum,
                        targetid = bsp_to_split.objid);

  if (!(status & 1)) {
    printf("GRcurve.GR3ptpartdel failed\n");
    goto wrapup;
  }

  switch(msg) {
    case MSSUCC:  
    break;

    case MSINARG: 
      printf("Delete object identical to original, failing\n"); 
      goto wrapup;
    break;

    case MSFAIL:  
      printf("Partial Delete Failed\n"); 
      goto wrapup;
    break;

    default:
      printf("Partial Delete returned unknown result, failing\n"); 
      goto wrapup;
    break;
  }

  if (num == 0) {
    printf("Partial delete returned no curves, failing\n");
    goto wrapup;
  }
  if (num  > 2) {
    printf("Partial delete returned more than 2 curves, failing\n");
    goto wrapup;
  }

  result_id[0].osnum = md_env->md_id.osnum;
  result_id[1].osnum = md_env->md_id.osnum;

  /* If not a closed composite curve then copy results and done */
  if (isCompCurve == FALSE) { 
    *nseg = num;
    segment[0].objid = result_id[0].objid;
    segment[0].osnum = result_id[0].osnum;
 
    if (num == 2) {
      segment[1].objid = result_id[1].objid;
      segment[1].osnum = result_id[1].osnum;
    }
    goto wrapup;
  }

  /* If closed and two curves returned, create 1 composite curve */
  if ((isClosed) && (num == 2))
  {
    status = vd_$makeCompCurve(
      msg     = &msg,
      cvList  = result_id,
      cvCount = num,
      cvEnv   = md_env,
      compEnv = md_env,
      compCv  = &comp_id);

    if (!(status & msg & 1)) {
      printf("vd_$makeCompCurve failed\n");
      goto wrapup;
    }
    *nseg = 1;
    segment[0].objid = comp_id.objid;
    segment[0].osnum = comp_id.osnum;
    goto wrapup;
  }

  /* If Necessary, convert any remaining curves to composites */
  *nseg = num;

  for(i = 0; i < num; i = i + 1) {

    if (IsCompCurve(result_id[i])) {
      segment[i].objid = result_id[i].objid;
      segment[i].osnum = result_id[i].osnum;
    }
    else {
      status = vd_$makeCompCurve(
        msg     = &msg,
        cvList  = &result_id[i],
        cvCount = 1,
        cvEnv   = md_env,
        compEnv = md_env,
        compCv  = &comp_id);

      if (!(status & msg & 1)) {
        printf("vd_$makeCompCurve failed\n");
        goto wrapup;
      }
      segment[i].objid = comp_id.objid;
      segment[i].osnum = comp_id.osnum;
    }
  }
  goto wrapup;

  /* Free memory and return */
  wrapup :
  if(bc!= NULL) om$dealloc(ptr = bc);
  return(OM_S_SUCCESS);
}/* end method ASbs_part_del */

/* ***************** FCT consume_and_display () ***********************	*/

consume_and_display( as_sup, c_mod, d_mod, md_env )

struct	GRid		as_sup;
IGRshort		c_mod;
IGRshort		d_mod;
struct	GRmd_env	*md_env;

{
IGRlong			sts, msg;
struct	GRid		go_sup;
struct	GRmd_env	sup_env;
enum	GRdpmode	pen;


	sts = ci$send(	msg	 = message NDnode.ASreturn_go(
					&go_sup,
					&sup_env.md_env.matrix_type,
					sup_env.md_env.matrix ),
			targetid = as_sup.objid,
			targetos = as_sup.osnum );
	as$status( sts = sts );

	if( c_mod ){

		if( d_mod )	pen = GRbd;
		else		pen	= GRbehe;

		sts = ci$send(	msg	 = message GRgraphics.GRdisplay(
						&msg,
						&sup_env.md_env.matrix_type,
						sup_env.md_env.matrix,
						&pen,
						&md_env->md_id ),
				targetid = go_sup.objid,
				targetos = go_sup.osnum );
		as$status( sts = sts );

		sts = ci$send( msg	 = message NDmacro.ACconsume( 
						&msg,
						"",
						0,
						0,
						md_env ),
				targetid = as_sup.objid,
				targetos = as_sup.osnum );
		as$status( sts = sts );

	} else {

		sts = ci$send(	msg	 = message NDnodein.ACunconsume
						( &msg, "" ),
				targetid = as_sup.objid,
				targetos = as_sup.osnum );
		as$status( sts = sts );

		if( d_mod )	pen = GRbd;
		else		pen	= GRbehe;
	
		sts = ci$send(	msg	 = message GRgraphics.GRdisplay(
						&msg,
						&sup_env.md_env.matrix_type,
						sup_env.md_env.matrix,
						&pen,
						&md_env->md_id ),
				targetid = go_sup.objid,
				targetos = go_sup.osnum );
		as$status( sts = sts );
	  }

return	1;
}

