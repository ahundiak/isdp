/* $Id: boolean.u,v 1.1.1.1 2001/01/04 21:07:19 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/general/macros / boolean.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: boolean.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:19  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)

	 92/08/06	****  This file is OBSOLETE (to be removed)  ***
	 92/07/30	Get rid of NDcopy_to_root(), and use emsbool.h include
 */
   

// #define CLOCK 1
#ifdef CLOCK
extern clock();
#endif

/**************************************************************************/
/*
/*   jll  design date: june 88
/*
/*   Associative boolean operations on solid
/*
/*   may be used by the command object COsol_op
/*   
/*   Jan '90 modifications  R Patience
/*			    E Beeker
/*	. adapted to fit new macros
/*	. indexing on surfaces
/*	. ACgive_path, ACgive_foot, NDdelete overriden
/*	. macro now named "nboolean" not to interfere with previous one
/*	. some small bugs fixed
/*
/**************************************************************************/


#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "AS_status.h"
#include "madef.h"
#include "msdef.h"
#include "EMSmsgdef.h"
#include "emssfintdef.h"
#include "emsbool.h"

#define MAX_TEMP		33
#define MAX_CHA_TEMP		4

#define SUC_SOL			2654217


IGRint      		status;
IGRchar	 		txt[MAX_CHA_TEMP], buff[MAX_TEMP*MAX_CHA_TEMP];
IGRchar 		*temp_names[MAX_TEMP], *feet_names[1];
IGRint			temp_types[MAX_TEMP];
IGRchar         	old_ASbroad;

IGRshort        	action, mask, mat_type;

IGRlong			msg;

IGRint 			j,i, k, stat, display_count;
IGRint			GRdpmode;
unsigned short  	option;

GRobj           	SOLOBJ[MAX_TEMP], ci_mac_def1;
GRobj			RES1, RES2, *PRES2;

IGRdouble 		matrix[16];

struct IGRdisplay 	dis;
struct GRvg_construct 	cst;
struct GRmd_env 	MOD_ENV, from_env;
struct GRid 		S[MAX_TEMP], SOL, TMP, GRid_list[1], CI_MACRO_ID;
struct GRid      	display_info,wrk_GRid, CUV;

char			status_str[54];


struct xy
 {
  int               num_solid; /* number of solid to do operation 	  */
  enum EMSbooltype  booltype;  /* type de l'operation (union, inter, ...) */
 } var;


short list_count[MAX_TEMP];	/* indices in this table */
short oss[30];
struct GRid solid_GRid;
char classname[64];

 
extern char     ASbroadcast_in_progress;
extern int	GRfindmod(),
		init_cnst_list(),
		sprintf(),
		printf(),
		MAidmx(),
		sscanf();
extern ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

#ifdef DEBUGPLUS
printf("We are in the main() function of file boolean.u \n") ;
#endif 

 for (i=0; i<MAX_TEMP; i=i+1)
  {
	sprintf(&buff[i*MAX_CHA_TEMP],"S%d",i+1);
	temp_names[i] = &buff[i*MAX_CHA_TEMP];
	temp_types[i] = other_generic;
  }

  feet_names[0] = "SOL";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat   , 	
		name              = "boolean",
		int_name 	  = "var",
		int_size          = sizeof(struct xy),
              	temp_num          = MAX_TEMP,	
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{

#ifdef CLOCK
write( "nboolean compute begin clock() = ", clock()/1000, '\n' );
#endif

  construct_comp();

#ifdef CLOCK
write( "nboolean compute after construct clock() = ", clock()/1000, '\n' );
#endif

  if( SOL.objid == NULL_OBJID ) return(0);

  feet_names[0] = "SOL";

  ci$send( msg = message  ci_macro.chang_extern_feet
	 ( &stat, 1, feet_names, &SOL, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

#ifdef CLOCK
write( "nboolean compute end clock() = ", clock()/1000, '\n' );
#endif
}

/* ========================================================================= */

place ()
{

  construct_comp();

  if( SOL.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1, &SOL, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}

/* ========================================================================= */
NDdelete()
{
	IGRint		stat1;
	struct GRid	GCV;
	IGRshort	matrix_type;
	IGRdouble	matrix[16];
	IGRshort        action, mask;

        GRfindmod(&display_info);
        GRdpmode = 0;
        action = 1;    // set using mask
        mask   = 0x40; // display bit

        for( k=0; k<var.num_solid; k=k+1)
        {

           ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat1,k,&TMP),
                    targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );

	   if(!stat1) goto wrapup;

       	   ci$send( msg      = message ASnode.ASreturn_go( 
							&GCV, 
							&matrix_type, 
							matrix ),
	      	    targetid = TMP.objid,
	      	    targetos = TMP.osnum );

	   if(!stat1) goto wrapup;

           ci$send( msg = message GRvg.GRchgprops( &msg, &action, &mask),
	            targetid = GCV.objid,
		    targetos = GCV.osnum );  

	   ci$send(msg      = message GRgraphics.GRdisplay(
							&msg,
							&matrix_type,
                                			matrix,
	                        			&GRdpmode,
							&display_info),
	           targetid = GCV.objid,
		   targetos = GCV.osnum);


        }
wrapup:
        ci$send( msg      = message ACcpx.NDdelete(&MOD_ENV),
	         targetid = CI_MACRO_ID.objid,
	         targetos = CI_MACRO_ID.osnum,
                 mode     = WRT_message );
 return(1);
}
/*==========================================================================*/

construct_comp()
{
#ifdef DEBUGPLUS
printf("We are in the construct_comp() function of file boolean.u \n") ;
#endif 

#ifdef CLOCK
write( "nboolean construct_comp begin clock() = ", my_clock(), '\n' );
#endif

  SOL.objid = NULL_OBJID;
  SOL.osnum = MOD_ENV.md_id.osnum;


#ifdef DEBUG
	write("var.num_solid = ",var.num_solid,"\n");
#endif

  action = 0;    // set using mask
  mask   = 0x40; // display bit
  GRfindmod(&display_info);

 for( k=0; k<var.num_solid; k=k+1) {

     ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat, k, &wrk_GRid ),
              targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );

     ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						".",
						&S[k], 
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix ),
	      targetid = wrk_GRid.objid,
	      targetos = wrk_GRid.osnum );

     if( !stat ){
		write(" bad element \n" );
		return;
     }

	/* Copy */

	from_env.md_id.osnum = S[k].osnum;
        stat = ci$send( msg	   = message GRgraphics.GRcopy( &msg,
							        &from_env,
                                             	                &MOD_ENV,
							        &SOLOBJ[k]),
                        targetid = S[k].objid,
	                targetos = S[k].osnum  );
        if( !( stat & 1 ) ){
  	  	printf( "boolean -  GRgraphics.GRcopy error\n" ) ;
		return;
        }


#ifdef DEBUG
	om$get_classname ( objid= S[k].objid,
			  osnum = S[k].osnum,
                          classname = txt  );
 	write("SOLOBJ[",k,"]:",SOLOBJ[k], " class:", txt, '\n');
#endif

/* ---  Set undisplayable the copies --- */


       ci$send( msg = message GRvg.GRchgprops( &msg, &action, &mask),
	        targetid = S[k].objid,
		targetos = S[k].osnum );

       ci$send(msg      = message GRgraphics.GRdisplay(
						&msg,
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix,
                        			&GRdpmode,
						&display_info),
	           targetid = S[k].objid,
		   targetos = S[k].osnum);

  }/* end loop to retrieve solid */

/**********************    boolean operation    *****************************/


//init. the construction list
  
  mat_type = MAIDMX;
  MAidmx(&msg,matrix);

  init_cnst_list();
  get_symb();

  dis.color 		= cnst_list.color;
  dis.weight 		= cnst_list.weight;
  dis.style 		= cnst_list.style;
  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= FALSE;
  cst.level		= cnst_list.level;
  cst.geometry  	= NULL;
  cst.class_attr	= NULL;
  cst.name		= NULL;


#ifdef CLOCK
write( "nboolean construct_comp before  EMSslboolean.xxx clock() = ", my_clock(), '\n' );
#endif

  stat = ci$send( msg = message EMSslboolean.GRconstruct(&cst), 
           targetid = SOL.objid, targetos = SOL.osnum );
  as$status( sts = stat );

  RES1 = NULL_OBJID;
  RES2 = NULL_OBJID;
  PRES2 = &RES2;
  option =  EMSsfbool_opt_display | EMSsfbool_opt_retryDisjoint |
            EMSsfbool_opt_HandleStop;

#ifdef DEBUG
	write("before  EMSslboolean.EMboolean \n");
#endif

  stat = ci$send( msg = message EMSslboolean.EMboolean( 
						 &msg, 
						 &mat_type,
						 matrix,
           					 SOLOBJ[0],
						 var.num_solid-1,
						 &SOLOBJ[1],
           					 &cst,
						 var.booltype,
						 option,
						 status_str,
						 NULL,
						 NULL,
						 NULL,
						 NULL ),
           targetid = SOL.objid,
	   targetos = SOL.osnum  );
  as$status( sts = stat );
#ifdef CLOCK
write( "nboolean construct_comp after  EMSslboolean.xxx clock() = ", my_clock(), '\n' );
#endif

#ifdef DEBUG
	write("after  EMSslboolean.EMboolean msg:", msg,"\n");
#endif

    if(  msg != EMS_S_Success  ){


     	write(" boolean failed\n");
        goto endend;
    }
    else  {

/* add the compress tree */
/*  build_real_pot();*/

   	stat = ci$send(msg = message EMSdpr.EMmake_primitive1(
				&msg,
				&MOD_ENV,
                                GRid_list ),
	        targetid = SOL.objid,
		targetos = SOL.osnum);
   	as$status( sts = stat );

    if(  msg != EMS_S_Success  ) {

	stat = ci$send(msg = message Root.GRdelete(0),
	        targetid = SOL.objid,
		targetos = SOL.osnum);
	as$status( sts = stat );

	goto endend;
    }

    SOL.objid = GRid_list[0].objid;    
    SOL.osnum = GRid_list[0].osnum;    
    return;
  } 

endend:

    GRfindmod(&display_info);
    GRdpmode = 0;
    action = 1;    // set using mask
    mask   = 0x40; // display bit

    for( k=0; k<var.num_solid; k=k+1){

	ci$send( msg = message GRvg.GRchgprops( &msg, &action, &mask),
		 targetid = S[k].objid,
		 targetos = S[k].osnum );

   	ci$send(msg      = message GRgraphics.GRdisplay(
							&msg,
							&mat_type,
                                			matrix,
	                        			&GRdpmode,
							&display_info),
	           	targetid = S[k].objid,
		   	targetos = S[k].osnum);

     }


     SOL.objid = NULL_OBJID;
 

}

/*==========================================================================*/

#ifdef CLOCK
int clk;
my_clock()
{
	int tmp1, tmp2;
	tmp1 = clock();
	tmp2 = (clk - tmp1)/10000;
	clk = tmp1;
	write(clk/10000,"   ");
	return -tmp2;
}
#endif
