/* $Id: COtxt_on_crv.u,v 1.1.1.1 2001/01/04 21:07:19 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/general/cmd / COtxt_on_crv.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COtxt_on_crv.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:19  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/06/27  21:13:28  pinnacle
# Created: cimacros/general/cmd/COtxt_on_crv.u by mdong for vds
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	05/12/97	Ming Dong
 *
 * -------------------------------------------------------------------*/

   
#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "nddef.h"
#include "asmacros.h"
#include "msmacros.h"
#include "ASmessages.h"
#include "expmacros.h"
#include "VDSudp_mac.h"


#define EXP_DOUBLE      0
#define EXP_TEXT        4


double		accept_pt[4];         /* Accept point of the locate           */
struct GRmd_env md_env, MOD_ENV;      /* Environment located                  */
long		sts;                  /* returned message from a function     */
long		msg;                  /* returned message from a function     */
struct GRid	select_obj;           /* Identifier of the selected object    */
struct GRid	src_id;               /* Identifier of the src object         */
struct GRid	window;
short		osnum;                /* Current object space                 */
char		loc_prompt[80];       /* locate prompt                        */
char		exp_prompt[80];       /* locate prompt                        */
char		acc_prompt[80];       /* accept prompt                        */
double		snap_point[3];
IGRdouble	exp_default;
int		suc;
char		loc_mes[80];
GRobj           MAC1;
struct GRid	list[6];              /* List of object to place              */
int		initial_count; 	      /* Number of object to place            */
struct IGRline	boreline;
double		view_rot[16];
double		dummy_pt[3];
double		dummy_pt1[3];
double		dummy_dbl;
char		sup_state;
int		k, i;
int		count_flag;

struct ret_struct rst;

struct GRparms dummy_par;

struct
{
 int num_tmp;
} var;


/* External functions */

extern 		ASmake_source_from_env();
extern 		ASany_give_struct();
extern 		CO_xlate_from_user_mode();
extern          UI_status();
extern int	EXP_translate_exp();
extern int	EXP_create_double();
extern int	EXP_create();
extern char	*strchr();


// #define DEBUG 1
#ifdef DEBUG
#    define TRACE(txt)	write("ci_mac_bib: ", txt, '\n');
#else
#    define TRACE(txt)	;
#endif



main()
{

  while(1)
   {
	
        initial_count = 0;

	message(loc_mes);

	sup_state = ND_DEL_NO_CH | ND_DONT_MVRT;


  /* Get the current osnum */

	ci$get_module_info(md_os = &osnum);

	strcpy(loc_prompt,"Identify coordinate system");


/* get coordinate system for attachement */

	while(1)
	 {
	  ci$locate( prompt       = loc_prompt,
                     obj          = &select_obj.objid,
                     osnum        = &select_obj.osnum,
	             owner_action = LC_RIGID_COMP,
	             md_env       = &md_env);
	    
	  as$any_give_structure(go_grid = select_obj,
                                mod_env = &md_env,
                                inst    = &rst);

          if(rst.type & ref_generic)
      	   {
            as$make_source(go_grid = select_obj,
                           mod_env = &md_env,
                           as_os   = osnum,
                           as_grid = &src_id);
            list[0] = src_id;
	    initial_count = initial_count + 1;
            break;
           }
	  else
	   {
	    status("Wrong object or input (It is not a coordinate system)");
	    continue;
           }

	 }


/* Get text to display */

	text_expressions();


/* Get the height of text */

	height_expressions();


/* Get the width of text */

	width_expressions();


/* Locate the wireframe and compute the base point of text for placing */

	while(1)
	 {
	  ex$message(buff =  loc_prompt, msgnumb = AS_P_IdCurvPt);
	  ex$message(buff =  acc_prompt, msgnumb = AS_P_TXTCRV3);
	  if(!ci$locate (prompt       = loc_prompt,
            		 md_env       = &md_env,
			 acc_prompt   = acc_prompt,
            		 obj          = &select_obj.objid,
            		 accept_point = snap_point,
            		 osnum        = &select_obj.osnum,
            		 window_id    = &window.objid,
            		 window_osnum = &window.osnum))
	   {
	    status("Wrong input (It is not a wireframe)");
	    continue;
	   }


/* control the type of the located object */

	  as$any_give_structure(go_grid = select_obj,
                                mod_env = &md_env,
                                inst    = &rst);

	  if(!(rst.type & point_generic) &&
	     !(rst.type & line_generic ) &&
	     !(rst.type & curve_generic) &&
	     !(rst.type & conic_generic)) 
	   {
	    status("Wrong object (It is not a wireframe)");
	    continue;
	   }


/* lineproject the accept point on the curve */

	  sts = ci$send (msg      = message IGEgragad.DPinrot(&msg,view_rot),
                         targetid = window.objid,
                         targetos = window.osnum);

          boreline.point1 = snap_point;
          boreline.point2 = dummy_pt1;
          dummy_pt1[0] = snap_point[0] + 100*view_rot[8];
          dummy_pt1[1] = snap_point[1] + 100*view_rot[9];
          dummy_pt1[2] = snap_point[2] + 100*view_rot[10];

          sts = ci$send(msg   = message GRgraphics.GRlnproject(
                                &msg,
                                &md_env.md_env.matrix_type,
                                md_env.md_env.matrix,
                                &boreline,
                                dummy_pt,
                                &accept_pt[1],
                                &dummy_dbl,
                                &dummy_par),

                     targetid = select_obj.objid,
                     targetos = select_obj.osnum);


/* Make a src object with the selected object */

	  as$make_source(go_grid      = select_obj,
                         mod_env      = &md_env,
                         as_os        = osnum,
                         as_grid      = &src_id);
	  list[1] = src_id;
	  initial_count = initial_count + 1;


/* create index point on curve */

	  if(!(rst.type & point_generic))
           {

/* Text on curve */
            list[3].objid = NULL_OBJID;
            list[3].osnum = osnum;
            accept_pt[0] = 2.e+10;

            sts = ci$send( msg      = message ASindexpt.place(1,
							      &src_id.objid,
							      accept_pt), 
	                   targetid = list[3].objid);

	    initial_count = initial_count + 1;

/* Turn it to support only element */
	    sts = ci$send( msg      = message NDnode.NDchg_state(sup_state,
								 sup_state),
			   targetid = list[1].objid);

           }
	  else
	   {

/* Text on point */
	    list[3].objid = list[1].objid;
	    list[3].osnum = list[1].osnum;
	    initial_count = initial_count + 1;
	   }
	  
          break;
         
         }


/* Check if wireframe and index point have the same GRid */

	count_flag = 4;
	if(rst.type == point_generic)
	 {
	  count_flag = 3;
	  list[3].objid = list[4].objid;
	  list[3].osnum = list[4].osnum;
	  list[4].objid = list[5].objid;
	  list[4].osnum = list[5].osnum;
	  initial_count = initial_count - 1;
	 }


/* Check if width and height have the same GRid */

	if(list[count_flag].objid == list[count_flag+1].objid &&
	   list[count_flag].osnum == list[count_flag+1].osnum)
	 initial_count = initial_count - 1;

	ci$get_module_info(md_env = &MOD_ENV);

        MAC1 = NULL_OBJID;

	var.num_tmp = initial_count;
        ci$send(msg = message nci_macro.init (  &suc, 
						0, 
						"txt_on_crv", 
						initial_count, 
						list, 
						&var,
						&MOD_ENV),
                targetid = MAC1,
                targetos = MOD_ENV.md_id.osnum );

        if( suc == 0 ){
                write("placement of nci_macro \"txt_on_crv\" failed\n");
                status("placement of nci_macro \"txt_on_crv\" failed");
                ci$send(msg      = message Root.delete(0),
                        targetid = MAC1,
                        targetos = MOD_ENV.md_id.osnum );
        }

   }

}

/*==========================================================================*/

init()
 {

        strcpy(loc_mes,"<Assoc> Place Text on Wireframe from Parameters");

 }

wakeup()
 {

        message(loc_mes);

 }


text_expressions()
 {

	strcpy(loc_prompt,"Enter expression for text");
	strcpy(exp_prompt,"Enter value");
	exp_default = 0.0;
	loc_exp( &suc, loc_mes, loc_prompt, exp_prompt, exp_default,
                 &list[2] );
	initial_count = initial_count + 1;

	if( suc != 1 ) exit;

 }


height_expressions()
 {

	strcpy(loc_prompt,"Enter text height");
	strcpy(exp_prompt,"Enter value");
	exp_default = 10.0;

	loc_exp( &suc, loc_mes, loc_prompt, exp_prompt, exp_default,
                 &list[4] );
	initial_count = initial_count + 1;

	if( suc != 1 ) exit;

 }


width_expressions()
 {

	strcpy(loc_prompt,"Enter text width");
	strcpy(exp_prompt,"Enter value");
	exp_default = 10.0;

	loc_exp( &suc, loc_mes, loc_prompt, exp_prompt, exp_default,
                 &list[5] );

	initial_count = initial_count + 1;

	if( suc != 1 ) exit;

 }

									
/*======================================================================*/
/*      manage the user interface to locate an expression		*/
/*======================================================================*/

int loc_exp( loc_suc, loc_message, loc_prompt, exp_prompt, exp_default, 
             EXP_GRid )

char		loc_prompt[80];	/* prompt to ask the name of the expression */
char		exp_prompt[80]; /* prompt ask a value			    */
char		loc_message[80];/* prompt to set the message field          */
struct GRid	*EXP_GRid;	/* return objid & osnum of the expression   */
int		*loc_suc;       /* return status			    */
double   	exp_default;    /* default value of the expression          */
                                /* must be setup                            */
{ 

char		expc_prompt[256];
char		*exp_true_name;
char		exp_name[80];
char		*exp_value, exp_true_value[80];
char		*equal;
int		stat, mask, response;
short		sender_class;
char		*start_str, *end_str;
double		exp_double;
struct GRmd_env	MOD_ENV;
struct GRevent	event;


TRACE( "loc_exp: BEGIN" )

        message(loc_message);
	strcpy(expc_prompt,exp_prompt);
        strcat(expc_prompt," (default = ");
        strcat(expc_prompt,ftoa(exp_default));
        strcat(expc_prompt,")");

	ci$get_module_info(md_env = &MOD_ENV);


step0:
	EXP_GRid->objid = NULL_OBJID;

	mask =  GRm_RJT_MOVEON | GRm_STRING | GRm_OBJID | GRm_BACK_UP;

        do
        {
           *loc_suc = ci$getevent( prompt = loc_prompt, response = &response,
	     			   data   = exp_value,  mask     = mask,
				   event = &event,
                                   stackable = 1 );
           status("");
           if( (response == EX_RJT_MOVEON) || (response == EX_BACK_UP ) )
           { 
		*loc_suc = 0; 
		return(0);
	   }

        }
  	while( *loc_suc != 1 );


/* we got an object via the navigate graph */

	if( response == EX_OBJID )
        {
	  om$get_classid( osnum     = event.located_object[0].located_obj.osnum,
			  objid     = event.located_object[0].located_obj.objid,
			  p_classid = &sender_class );

	  stat = om$is_ancestry_valid( subclassid     = sender_class,
				       superclassname = "expression" );
	  if( stat  != 1 ) goto step0;
	  EXP_GRid->objid = event.located_object[0].located_obj.objid;
	  EXP_GRid->osnum = event.located_object[0].located_obj.osnum;
	  return(1);
        }


/* a caracter string has been returned */

        if( response == STRING )
        {
           strcpy(exp_name, exp_value);
           if(exp_name[0] == 0 ) goto step1;

/* try to find an "=" in the tring */

 	   equal = strchr(exp_value,'=');
           if( equal != NULL )
           {
          	*equal = '\0';
	  	stat = exp$translate(exp_name = exp_value,
			             p_exp_id = &EXP_GRid->objid,
			             p_osnum  = &EXP_GRid->osnum );

                if( EXP_GRid->objid == NULL_OBJID )
                {
		 start_str = strchr(equal+1, '"');
		 if(start_str != NULL)
		  {

		   equal = start_str + 1;
		   end_str = strchr(equal, '"');
		   if(end_str != NULL)
		    {
		     *end_str = '\0';
		     stat = exp$create(exp_name   = exp_value,
                                       exp_syntax = equal,
                                       osnum      = MOD_ENV.md_id.osnum,
                                       p_exp_id   = &EXP_GRid->objid,
                                       p_osnum    = &EXP_GRid->osnum,
                                       type_rq    = EXP_TEXT );

                     if( stat != 1 )
                      {
                       UI_status(" syntax error ");
                       goto step0;
                      }
		    }
		   else
		    {
		     UI_status(" Wrong expression syntax ");
		     goto step0;
		    }

		  }
		 else
		  {
		   if(check_str(equal+1) == FALSE)
		    {
		      UI_status(" Wrong expression value ");
		      goto step0;
		    }
		   exp_double = atof(equal+1);
		   stat = exp$create(exp_name   = exp_value,
				     exp_value  = exp_double,
				     osnum      = MOD_ENV.md_id.osnum,
			      	     p_exp_id   = &EXP_GRid->objid,
			             p_osnum    = &EXP_GRid->osnum);

		   if( stat != 1 )
                    {
	             UI_status(" syntax error ");
		     goto step0;
		    }
		  }

		}
                else if( stat == 1 ){
			status(" left hand side already defined ");
			goto step0;
		}
            }/* end of process if we got "expxx = value" */

	    else
            {
		#ifdef DEBUG
			write("check objname =", exp_name,"\n");
		#endif

          	vds$translate (objname = exp_name, 
                	       p_objid = &(EXP_GRid->objid),
                               p_osnum = &(EXP_GRid->osnum) );
		

          	if ( (EXP_GRid->objid) == NULL_OBJID )
          	{

/*---  		try to create an unname expression 			---*/

		 EXP_GRid->objid = NULL_OBJID;			
		 exp_true_name = NULL;
		 start_str = strchr(exp_value, '"');
		 if(start_str != NULL)
		  {
		   start_str = start_str + 1;
		   exp_value = start_str;
		   end_str = strchr(exp_value, '"');
		   if(end_str != NULL)
		    {
		     *end_str = '\0';
		     stat = exp$create(exp_name   = exp_true_name,
                                       exp_syntax = exp_value,
                                       osnum      = MOD_ENV.md_id.osnum,
                                       p_exp_id   = &EXP_GRid->objid,
                                       p_osnum    = &EXP_GRid->osnum,
                                       type_rq    = EXP_TEXT );

                     if( stat == 1 ) goto step3;
		     if( stat != 1 ) goto step1;
		    }
		   else
                    {
                     UI_status(" Wrong expression syntax ");
                     goto step0;
		    }
		  }
		 else
		  {
		   if(check_str(exp_value) == FALSE)
                    {
                      UI_status(" Wrong expression value ");
                      goto step0;
                    }
		   exp_double = atof(exp_value);
		   stat = exp$create(exp_name   = exp_true_name,
				     exp_value  = exp_double,
				     osnum      = MOD_ENV.md_id.osnum,
			      	     p_exp_id   = &EXP_GRid->objid,
			             p_osnum    = &EXP_GRid->osnum);

		   if( stat == 1 ) goto step3;
		   if( stat != 1 ) goto step1;
		  }

/*--- 		fin de la modify					---*/

step1:	   	        UI_status("expression does not exist");
step2:           	
	   		EXP_GRid->osnum = MOD_ENV.md_id.osnum ;           
	   		mask =  GRm_RJT_MOVEON | GRm_BACK_UP | GRm_STRING;

           		do
           		{
             		   *loc_suc = ci$getevent( prompt    = expc_prompt, 
                                                   response  = &response,
	      			                   data      = exp_value, 
                                                   mask      = mask,
                                                   stackable = 1 );

             		   if( (response == EX_RJT_MOVEON) ||  
   	                       (response == EX_BACK_UP)  ) goto step0;

           		}
           		while( *loc_suc != 1 );

	   		if( exp_value[0] == '\0' )
                             strcpy( exp_value, ftoa(exp_default));

			start_str = strchr(exp_value, '"');
			if(start_str != NULL)
			 {
			  start_str = start_str + 1;
			  exp_value = start_str;
			  end_str = strchr(exp_value, '"');
			  if(end_str != NULL)
			   {
			    *end_str = '\0';
			    stat = exp$create(exp_name   = exp_true_name,
                                              exp_syntax = exp_value,
                                              osnum      = MOD_ENV.md_id.osnum,
                                              p_exp_id   = &EXP_GRid->objid,
                                              p_osnum    = &EXP_GRid->osnum,
                                              type_rq    = EXP_TEXT );
                            if( stat != 1 )
                             {
                              UI_status(" syntaxe error ");
                              goto step2;
                             }

			   }
			  else
                           {
                            UI_status(" Wrong expression syntax ");
                            goto step0;
                           }
			 }
			else
			 {
			if(exp_name[0] == '\0' ) exp_true_name = NULL;
			else		     exp_true_name = exp_name;
			#ifdef DEBUG
			  write("exp_true_name = ",exp_true_name,"\n");
			  write("exp_value     = ",exp_value,"\n");
			#endif 
			if(check_str(exp_value) == FALSE)
                         {
                           UI_status(" Wrong expression value ");
                           goto step0;
                         }
			exp_double = atof(exp_value);
			stat = exp$create(exp_name   = exp_true_name,
					  exp_value  = exp_double,
					  osnum      = MOD_ENV.md_id.osnum,
			      		  p_exp_id   = &EXP_GRid->objid,
			                  p_osnum    = &EXP_GRid->osnum);
			if( stat != 1 )
                        {
	                  UI_status(" syntaxe error "); 
			  goto step2;
			}
		     }

	  	} /*  string was null */ 


            } /* expression did'nt exist */   
	    return(1);

step3:
	    ci$send(msg      = message NDnode.NDchg_state( 
                                                   (char)16,(char)16 ),
                    targetid = EXP_GRid->objid,
                    targetos = EXP_GRid->osnum	 ); 

	    return(1);

	} /* end of process string */
}

int check_str(origin_str)
char	*origin_str;
{
	char tmp_str[80];
	int i, flag_period;

	i = 0;

	while(*origin_str != '\0')
	{
	  if(*origin_str == ' ')
	  {
	    origin_str = origin_str + 1;
	    continue;
	  }

	  tmp_str[i] = *origin_str;
	  origin_str = origin_str + 1;
	  i = i + 1;
	}

	tmp_str[i] = '\0';

	i = 0;
	flag_period = 1;
	while(tmp_str[i] != '\0')
	{
	  if(tmp_str[i] < '0' || tmp_str[i] > '9')
	  {
	    if(tmp_str[i] == '.' && flag_period == 1)
	    {
	      flag_period = flag_period + 1;
	      i = i + 1;
	      continue;
	    }
	    
	    return 0;
	  }

	  i = i + 1;
	}

	return 1;
}
