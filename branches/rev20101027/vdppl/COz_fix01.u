/* $Id: COz_fix01.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $ */ 

/***************************************************************************
 * I/VDS
 *
 * File:        vdppl/COz_fix01.u
 *
 * Description: Reconnects ACpretends based on text file from COz_scan01.u
 *
 * Dependencies:
 *
 * Revision History:
 * $Log: COz_fix01.u,v $
 * Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 * Initial import to CVS
 *
# Revision 1.1  1998/11/05  16:53:12  pinnacle
# tags
#
 *
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 11/05/98  ah      Created
 ***************************************************************************/

#include "VDppl.h"
#include "VDobj.h"

TGRid preID;  // ACpretendin ID
TGRid conID;  // Context ID
TGRid parID;  // Parent  ID

IGRint errCnt;
IGRint fixCnt;
FILE  *file;

// Listener channel information
#define chnName"ASsource.listeners"
OM_S_CHANSELECT chnSelect;

extern VDclassid OPP_ACpretendin_class_id;
extern VDclassid OPP_ASsourcein_class_id;
extern VDclassid OPP_GRcontext_class_id;

/* -----------------------------------------------
 * Gets the listener objects 
 */
IGRstar getListeners()
{
  IGRstat retFlag;
  IGRstat sts;

  OM_S_OBJECT_LINKAGE   chnLinks[16];
  IGRuint               chnLinkCnt;
  IGRuint               chnLinkSize;
  IGRuint               i;

  TGRid lisID;

  // Init
  retFlag = 0;
  parID.objid = NULL_OBJID;
  conID.objid = NULL_OBJID;

  /* Grab the objects */
  chnLinkSize = sizeof(chnLinks);
  chnLinkCnt  = 0;
  sts  = om$get_channel_objects(
    osnum = preID.osnum,
    objid = preID.objid,
    p_chanselect = &chnSelect,
    list  =  chnLinks,
    size  =  chnLinkSize,
    count = &chnLinkCnt
  );
  if (!(sts & 1)) goto wrapup;
  
  /* Xfer Over */
  for(i = 0; i < chnLinkCnt; i = i + 1) {

    lisID.osnum = chnLinks[i].osnum;
    lisID.objid = chnLinks[i].S_objid;

    sts = vdobj$IsAncestryValid(
      objID = &lisID, 
      superClassID = OPP_GRcontext_class_id);

    if (sts & 1) conID = lisID;
    else         parID = lisID;
  }

  retFlag = 1;

wrapup:
  return retFlag;

}

/* --------------------------------------------
 * Find the object in the file
 */
IGRstat findInFile()
{
  IGRchar buf1[256];
  IGRchar buf2[256];
  
  // Ignore for no input file
  if (file == NULL) return 0;

  fseek(file,0,SEEK_SET);

  // Match on description
  vdobj$Print(objID = &preID, str = buf2);
  sprintf(buf1,"1 %s",buf2);
  
  while(fgets(buf2,sizeof(buf2),file)) {
  
    if (!strcmp(buf1,buf2)) return 1;
    
  }
  
  return 0;
}

/* --------------------------------------------
 * Process each object
 */
IGRstar process()
{
  IGRstat retFlag;
  IGRstat sts;

  IGRint  srcFlag;
  
  IGRchar downScan[128];
  
  IGRchar buf1[256];
  IGRchar buf2[256];
  IGRchar buf3[256];
  IGRchar *p;
  
  // Init
  retFlag = 0;
  srcFlag = 0;
  
  // Filter all but ACpretendin and ASsourcein
  sts = vdobj$IsAncestryValid(objID = &preID, 
			      superClassID = OPP_ACpretendin_class_id);
  if (!(sts & 1)) {
    sts = vdobj$IsAncestryValid(objID = &preID, 
				superClassID = OPP_ASsourcein_class_id);
    if (!(sts & 1)) goto wrapup;
    srcFlag = 1;
  }
  
  // see if they have two objects on the listener channel
  getListeners();

  if (conID.objid == NULL_OBJID) {
    vdobj$Print(objID = &preID);
    printf("Major problem, no GRcontext on listener channel\n");
    errCnt = errCnt + 1;
    goto wrapup;
  }
  if (parID.objid != NULL_OBJID) goto wrapup;
  
  vdobj$Print(objID = &preID);

  if (srcFlag) {
    printf("ASsourcein cannot currently be repaired\n");
    errCnt = errCnt + 1;
    goto wrapup;
  }
  
  // Check the data file for it
  if (file == NULL) {
    fixCnt = fixCnt + 1;
    goto wrapup;
  }
  
  sts = findInFile();
  if (!(sts & 1)) {
    printf("Not found in data file\n");
    errCnt = errCnt + 1;
    goto wrapup;
    
  }

  // Context should match
  vdobj$Print(objID = &conID, str = buf2);
  sprintf(buf1,"2 %s",buf2);

  *buf3 = 0;
  fgets(buf3,sizeof(buf3),file);
  if (strcmp(buf1,buf3)) {
    printf("Serious problem, GRcontext does not match\n");
    errCnt = errCnt + 1;
    goto wrapup;
  }

  // Next line is the parent
  fgets(buf3,sizeof(buf3),file);

  p = strchr(buf3,' ');
  if (p) p = strchr(p+1,' ');
  if (p) parID.osnum = atoi(p+1);
  p = strchr(buf3,',');
  if (p) parID.objid = atoi(p+1);
  
  // Make sure object is the same
  vdobj$Print(objID = &parID, str = buf2);
  sprintf(buf1,"3 %s",buf2);

  if (strcmp(buf1,buf3)) {
    printf("Serious problem, cannot locate parent\n");
    printf("%s",buf1);
    printf("%s",buf3);
    errCnt = errCnt + 1;
    goto wrapup;
  }

  // Now get the existing downscan
  *downScan = 0;
  ci$send (msg = message ACpretend.ACgive_downscan(downScan),
      targetid = preID.objid,
      targetos = preID.osnum );
    
  // Connect it back
  sts = ci$send (msg = message ACpretendin.ACiconnect(666,parID,conID,downScan),
      targetid = preID.objid,
      targetos = preID.osnum );
	 
  
  if (!(sts & 1)) {
    printf("Reconnecting parent\n");
    errCnt = errCnt + 1;
    goto wrapup;
  }
  fixCnt = fixCnt + 1;
  
  // Done
  retFlag = 1;

wrapup:
  return retFlag;
}

extern EX_findmod();

/* ---------------------------------------------
 * Cycles through os and process objects
 */
main()
{
  IGRstat sts;
  IGRuint i,max;

  IGRchar *p;
  IGRchar  name[64];
  IGRchar  buf[128];

  // Init
  printf("=============== Fixing ============\n");
  UI_status("Fix...");
  errCnt = 0;
  fixCnt = 0;
  *name  = 0;

  /* Make a channel selector */
  sts = om$make_chanselect(
    channame     =  chnName, 
    p_chanselect = &chnSelect
  );
  if (!(sts & 1)) {
    UI_status("Problem making listener channel selector");
    return 0;
  }

  // Cycle through current os
  ex$get_cur_mod(osnum = &preID.osnum);

  // Open the file
  p = strrchr(OM_GA_OSDs[preID.osnum]->name,'/');
  if (p == NULL) {
    UI_status("Problem getting os name");
    return 0;
  }
  strcpy(name,p+1);
  strcat(name,"F");
  file = fopen(name,"rt");
  if (file == NULL) {
    sprintf(buf,"Could not open input file %s",name);
    UI_status(buf);
  }

  // Cycle through
  max = OM_GA_OSDs[preID.osnum]->CurSpaceMapSize;
  for(i = 0; i < max; i = i + 1) {
    preID.objid = i;
    process();
  }

  if (file) fclose(file);

wrapup:
  sprintf(buf,"Fixing Complete, %d errors, %d fixes",errCnt,fixCnt);
  UI_status(buf);
  return 1;
}





