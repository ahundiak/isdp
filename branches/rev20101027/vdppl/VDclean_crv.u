/* $Id: VDclean_crv.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	VDclean_crv.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDclean_crv.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  2000/03/22  17:04:34  pinnacle
# Created: vdppl/VDclean_crv.u by impd252 for vds
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	08/12/99	HF		Creation date
 *
 * -------------------------------------------------------------------*/

/*
 * PPL VDclean_crv.u
 *
 * This PPL provides a very fast function to find ALL objects of a particular CLASSID
 * in the specified object space (no locate required !!!).
 *
 * Usage: "ci=VDclean_crv"
 *
 * Following is an example of how to find & list ALL OPP_nci_macro_class_id's in OS 2
 */

#include <stdio.h>
#include <cieveryone.h>
#include <cimacros.h>
#include "OMindex.h"
#include <grmacros.h>
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"

extern                  VDpms_find_objects();
extern                  GRdelete_object();
extern			DIuntranslate();

extern GRclassid        OPP_GAbspline_class_id;
extern GRclassid        OPP_GAbcsubbc_class_id;
extern GRclassid        OPP_GA3dlineseg_class_id;
extern GRclassid        OPP_GA3dlinestr_class_id;

extern GRclassid        OPP_expression_class_id;
extern                  OM_Gf_verbose_warning;

main()
{
  int                   i0, k0, m0, m1, m2, m3, cnt, cnt1, cnt2, cnt3, sts, chcnt[5], f_defer_flag;

  struct GRid           obj_id;
  struct GRmd_env       ModuleInfo;

  OM_S_OBJID           *list;
  GRclassid             class_id;
  OM_S_CHANSELECT       my_chansel[5];
  OM_S_OBJECT_LINKAGE   objet;

  my_chansel[0].type       = OM_e_name;
  my_chansel[1].type       = OM_e_name;
  my_chansel[2].type       = OM_e_name;
  my_chansel[3].type       = OM_e_name;
  my_chansel[4].type       = OM_e_name;
  my_chansel[0].u_sel.name = "children";
  my_chansel[1].u_sel.name = "father";
  my_chansel[2].u_sel.name = "notification";
  my_chansel[3].u_sel.name = "to_owners";
  my_chansel[4].u_sel.name = "to_components";

  message ( "Delete all obsolete GAbcsubbc/GA3dlineseg/GA3dlinestr" );

  class_id = OPP_GAbcsubbc_class_id;
  sts = VDpms_find_objects ( 2, class_id, &cnt1, NULL );

  class_id = OPP_GA3dlineseg_class_id;
  sts = VDpms_find_objects ( 2, class_id, &cnt2, NULL );

  class_id = OPP_GA3dlinestr_class_id;
  sts = VDpms_find_objects ( 2, class_id, &cnt3, NULL );

  cnt = cnt1 + cnt2 + cnt3;
  printf ( "\nVDpms_find_objects() : sts = %d, Number of objects = %d (GAbcsubbc %d, GA3dlineseg %d, GA3dlinestr %d)\n",
           sts, cnt, cnt1, cnt2, cnt3 );

  list = ( OM_S_OBJID * ) om$malloc ( size = cnt * sizeof ( OM_S_OBJID ) );

  ci$get_module_info ( md_env = &ModuleInfo );

  if ( list )
  {
    class_id = OPP_GAbcsubbc_class_id;
    sts = VDpms_find_objects ( 2, class_id, &cnt1, &list[0] );

    class_id = OPP_GA3dlineseg_class_id;
    sts = VDpms_find_objects ( 2, class_id, &cnt2, &list[cnt1] );

    class_id = OPP_GA3dlinestr_class_id;
    sts = VDpms_find_objects ( 2, class_id, &cnt3, &list[cnt1+cnt2] );

    m0           = 0;
    m1           = 0;
    m2           = 0;
    m3           = 0;
    obj_id.osnum = 2;
    objet.osnum  = 2;

    for ( i0=0; i0 < cnt; i0=i0+1)
    {
      objet.S_objid = list[i0];
      obj_id.objid  = list[i0];

      for ( k0=0; k0 < 4; k0=k0+1)
      {
        sts = om$get_channel_count ( osnum            = objet.osnum,
                                     objid            = objet.S_objid,
                                     p_chanselect     = &my_chansel[k0],
                                     count            = &chcnt[k0] );
      }
      if ( chcnt[0] == 0 && chcnt[1] == 0 && chcnt[2] == 0 && chcnt[3] == 0 && chcnt[4] == 0 )
      {
        m0  = m0+1;
        if ( i0 < cnt1 )                   m1 = m1 + 1;
        if ( i0 >= cnt1 && i0 < cnt1+cnt2) m2 = m2 + 1;
        if ( i0 >= cnt1+cnt2 && i0 < cnt ) m3 = m3 + 1;

        sts = ci$send ( msg      = message EMSassoc.NDdelete ( &ModuleInfo ),
                        targetid = list[i0]);
        if ( ! (sts & 1) && OM_Gf_verbose_warning) printf ("EMSassoc.NDdelete ID[%d] = [%8d], sts = %d\n", i0, list[i0], sts );

        sts = ci$send ( msg      = message Root.delete ( f_defer_flag ),	// DO NOT USE (mode = OM_e_wrt_message,)
                        targetid = list[i0]);
        if ( ! (sts & 1) && OM_Gf_verbose_warning)
        {
          printf ("Root.delete       ID[%d] = [%8d], sts = %d\n", i0, list[i0], sts );
          om$report_error ( sts = sts );
        }
      }
      else
      {
        printf ( "ID[%d] = [%8d], %d, %d, %d, %d\n", i0, list[i0], chcnt[0], chcnt[1], chcnt[2], chcnt[3] );
      }
    }
    printf ( "\nNumber of objects = %d, # deleted(obsolete) = %d, (GAbcsubbc = %d, GA3dlineseg = %d, GA3dlinestr = %d)\n", cnt, m0, m1, m2, m3 );

    if (list)
    {
      om$dealloc ( ptr = list );
      list = NULL;
    }
  }
}
