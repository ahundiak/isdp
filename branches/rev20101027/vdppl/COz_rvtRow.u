/* $Id: COz_rvtRow.u,v 1.6 2001/08/07 22:20:50 ylong Exp $  */
/***************************************************************************
 * I/VDS
 *
 * File:  vds/vdppl/COz_rvtRow.u 
 *
 * Description: 
 *	
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_rvtRow.u,v $
 *	Revision 1.6  2001/08/07 22:20:50  ylong
 *	*** empty log message ***
 *	
 *	Revision 1.5  2001/05/10 20:11:30  ylong
 *	*** empty log message ***
 *	
 *	Revision 1.4  2001/04/30 13:34:12  ylong
 *	*** empty log message ***
 *	
 *	Revision 1.3  2001/04/26 13:07:53  ylong
 *	*** empty log message ***
 *	
 *	Revision 1.2  2001/04/25 23:43:06  ylong
 *	*** empty log message ***
 *	
 *	
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	04/19/01	ylong		CR5077
 ***************************************************************************/
#include "VDppl.h"
#include "VDobj.h"
#include "VDmem_ppl.h"
#include "VDdrwlo.h"
#include "vdtblmacros.h"
#include "text_fontppl.h"
#include "v_dbgmacros.h"
#define  cmdPrompt "Revert BOM Field Entry"

extern	IGRint	DMget_exact_str(char*, short, char*, short*);
extern	IGRlong	VDdrw_getAttFromColl( &msg, collId, name, &datValue );
extern	VD_drwlo_gfix();
extern	VD_drwlo_gdata();
extern	VD_stripString();

extern	OPP_VDdrwTblRow_class_id;
extern	OPP_VDdrwTbl_class_id;

/*-----------------------------------------------------------------------*/

IGRstat	VDrvtRow_getSelectedCol( rowId, nbDatRecs, point, col )
  TGRid		rowId;
  IGRint	nbDatRecs;
  IGRdouble	*point;
  IGRint	*col;
{
	IGRstat		retFlag;
	IGRlong		sts, msg;
	IGRint		i, j, rowNo, nbFixRecs, colNo, nbLine;
	IGRchar		tblLoName[80], adsTblName[80];
	IGRshort	tblOrient, xFound, yFound;
	TGRid		csId, tblId, hdrId;
	IGRdouble	rowHeight, cornerPnt[3], cornerPnt1[3];
	IGRdouble	mat[16], x1, x2, y1, y2;
	struct VDdrwlo_apifix	*fixRecs;

  retFlag	= 0;
  nbFixRecs	= 0;
  fixRecs	= NULL;
  *col		= -1;

  if( rowId.objid == NULL_OBJID || nbDatRecs < 1 ) goto wrapup;

  sts = ci$send(msg      = message VDdrwTblRow.VDgetTableHeader (
							&msg,
							&hdrId,
							&tblId ),
		targetid = rowId.objid,
		targetos = rowId.osnum);
  if( !(sts&msg&1) )
  {
    __DBGpr_com("VDdrwTblRow.VDgetTableHeader failed\n");
    goto wrapup;
  }

  sts = ci$send(msg      = message VDdrwTblRow.VDgetRowNumber (
							&msg,
							&rowNo ),
		targetid = rowId.objid,
		targetos = rowId.osnum);
  if( !(sts&msg&1) ) 
  {
    __DBGpr_com("VDdrwTblRow.VDgetRowNumbe failed\n");
    goto wrapup;
  }

  sts = ci$send(msg      = message VDdrwTblHdr.VDgetRowConstructInfo(
							&msg,
							rowNo,
							tblLoName,
							&tblOrient,
							&csId,
							cornerPnt,
							adsTblName ),
		targetid = hdrId.objid,
		targetos = hdrId.osnum);
  if( !(sts&msg&1) ) 
  {
    __DBGpr_com("VDdrwTblHdr.VDgetRowConstructInfo failed\n");
    goto wrapup;
  }

  sts = ci$send( msg      = message GRgencs.GRgetmatrix ( &msg, mat),
                 targetid = csId.objid,
                 targetos = csId.osnum);

  if( !(sts&msg&1) ) {
    __DBGpr_com("GRgencs.GRgetmatrix failed\n");
    goto wrapup ;
  }

  sts = VD_drwlo_gfix (	&msg,
			tblLoName,
			VD_DRWLO_EN_DATA,
			cornerPnt[0], cornerPnt[1],
			0, NULL,
			&rowHeight,
			&nbFixRecs,
			NULL );

  if( !(sts&msg&1) )
  {
    __DBGpr_com("VD_drwlo_gfix failed\n");
    goto wrapup;
  }
  /*
  if( tblOrient == VD_DRWLO_EN_DESCEND ) 
  {
    cornerPnt[1] = cornerPnt[1] - rowHeight;
  }
  */
  cornerPnt[0] = cornerPnt[0] + mat[3];
  cornerPnt[1] = cornerPnt[1] + mat[7];

  fixRecs = _MALLOC( nbFixRecs, struct VDdrwlo_apifix );

  if( fixRecs == NULL )
  {
    __DBGpr_com("_MALLOC  failed for fixRecs\n");
    goto wrapup;
  }

  sts = VD_drwlo_gfix (	&msg,
			tblLoName,
			VD_DRWLO_EN_DATA,
			cornerPnt[0], cornerPnt[1],
			0, NULL,
			&rowHeight,
			&nbFixRecs,
			fixRecs );
  if( !(sts&msg&1) )
  {
    __DBGpr_com("VD_drwlo_gfix failed for fixRecs\n");
    goto wrapup;
  }
  

  nbLine = nbFixRecs/nbDatRecs;
  for( i = 0; i < nbDatRecs; i = i + 1 )
  {
    for( j = 0; j < nbLine; j = j+1 )
    {
      /* horizontal line */
      xFound =	(fabs (fixRecs[nbLine*i+j].VD.ln.y1 - 
			fixRecs[nbLine*i+j].VD.ln.y2) < 0.01 )  &&
		((point[0] > fixRecs[nbLine*i+j].VD.ln.x1 &&
		  point[0] < fixRecs[nbLine*i+j].VD.ln.x2 )  ||
		 (point[0] < fixRecs[nbLine*i+j].VD.ln.x1 &&
		  point[0] > fixRecs[nbLine*i+j].VD.ln.x2 ) ) ;
      if( xFound ) 
      {
        colNo = i + 1;
	goto get_yFound;
      }
    }
  }
  UI_status("Selected Entry is NOT in the Row");
  goto wrapup;

get_yFound:

  sts = ci$send(msg      = message VDdrwTblHdr.VDgetRowConstructInfo(
							&msg,
							(rowNo+1),
							tblLoName,
							&tblOrient,
							&csId,
							cornerPnt1,
							adsTblName ),
		targetid = hdrId.objid,
		targetos = hdrId.osnum);
  if( !(sts&msg&1) ) 
  {
    __DBGpr_com("VDdrwTblHdr.VDgetRowConstructInfo failed\n");
    goto wrapup;
  }

  cornerPnt1[1] = cornerPnt1[1] + mat[7];
  yFound = ( point[1] > cornerPnt[1] && point[1] < cornerPnt1[1] )  ||
	   ( point[1] < cornerPnt[1] && point[1] > cornerPnt1[1] ) ;

  if( yFound ) *col = colNo;
  else
  {
    UI_status("Selected Entry is NOT in the Row");
    goto wrapup;
  }

  retFlag = 1;
wrapup:
  _FREE(fixRecs);
  return retFlag;
}

/*---------------------------------------------------------------------------*/
IGRstat	VDrvtRow_getData( rowId, nbDatRecs, datRecs )
  TGRid			rowId;
  IGRint		*nbDatRecs;
  struct VDdrwlo_data	**datRecs;
  
{
  IGRstat	retFlag;
  IGRlong	sts, msg;
  IGRchar	tblLoName[VD_DRWLO_CHR_IDFLD];
  IGRdouble	height;
		
  TGRid		tblId, hdrId;
  IGRint	cnt;

  retFlag	= 0;

  if( rowId.objid == NULL_OBJID || datRecs == NULL ) goto wrapup;

  *nbDatRecs	= 0;
  *datRecs	= NULL;

  /* get table and header */
  
  sts = ci$send(msg      = message VDdrwTblRow.VDgetTableHeader (
							&msg,
							&hdrId,
							&tblId ),
		targetid = rowId.objid,
		targetos = rowId.osnum);
  if( !(sts&msg&1) )
  {
    __DBGpr_com("VDdrwTblRow.VDgetTableHeader failed\n");
    goto wrapup;
  }


  /* get table layout */

  sts = ci$send(msg      = message VDdrwTbl.VDgetTableLayoutName (
							&msg,
							tblLoName ),
		targetid = tblId.objid,
		targetos = tblId.osnum);
  if( !(sts&msg&1) ) 
  {
    __DBGpr_com("VDdrwTbl.VDgetTableLayoutName failed\n");
    goto wrapup;
  }

  /* get replaceable components */
  sts = VD_drwlo_gdata (	&msg,
				tblLoName,
				VD_DRWLO_EN_DATA,
				0.0,
				0.0,
				0,
				NULL,
				&height,
				nbDatRecs,
				NULL );

  if( !(sts&msg&1) )
  {
    __DBGpr_com("VD_drwlo_gdata failed\n");
    goto wrapup;
  }

  if( nbDatRecs > 0 )
  {
      *datRecs = _MALLOC( *nbDatRecs, struct VDdrwlo_data );
      if( datRecs == NULL ) goto wrapup;
  }
  else *nbDatRecs = 0;

  if( *nbDatRecs > 0 )
  {
    sts = VD_drwlo_gdata (	&msg,
				tblLoName,
				VD_DRWLO_EN_DATA,
				0.0,
				0.0,
				0,
				NULL,
				&height,
				nbDatRecs,
				(*datRecs) );
    if( !(sts&msg&1) ) {
        __DBGpr_com("VD_drwlo_gdata failed\n");
        goto wrapup;
    }
  }

  retFlag = 1;
wrapup:
  return retFlag;
}

/*---------------------------------------------------------------------------*/
IGRstat	VDrvtRow_revertEntry( rowId, entryId, point )
  TGRid		rowId;
  TGRid		entryId;
  IGRdouble	*point;
{
  IGRstat	retFlag;
  IGRlong	sts, msg;
  IGRint	i, j;
  IGRchar	*datValue,
		name[40], 
		txt[40], 
		prompt[80], inputStr[80],
		tblLoName[VD_DRWLO_CHR_IDFLD];
  IGRdouble	height;
		
  TGRid		collId;
  IGRint	nbDatRecs, type, col;

  struct VDdrwlo_data	*datRecs;

  retFlag	= 0;
  datValue	= NULL;
  datRecs	= NULL;
  inputStr[0]	= '\0';


  sts = VDrvtRow_getData( rowId, &nbDatRecs, &datRecs );

  /* Instead of comparing selected text with attribute to find correct entry,
   * just check which cell the click point is in 
  gr$get_text_attr (	ret_msg		= &msg,
			text_id		= &entryId,
			text_length	= &textLen,
			text_string	= &text);

  DMget_exact_str ( text, textLen, entryVal, &textLen);
  */
  
  /* get collector */

  collId.objid = NULL_OBJID;
  sts = ci$send(msg	 = message VDdrwTblRow.ACfind_temp_obj( &msg,
                                                               "coll",
                                                               &collId ),
		targetid = rowId.objid,
		targetos = rowId.osnum );
  if( !(sts&msg&1) ) 
  {
    __DBGpr_com("VDdrwTblRow.ACfind_temp_obj failed\n");
    goto wrapup;
  }

  col = -1;
  sts = VDrvtRow_getSelectedCol( rowId, nbDatRecs, point, &col );
  if( !sts || col == -1 )
  {
    __DBGpr_com("VDtbl_getSelectedCol failed\n");
    goto wrapup;
  }

  if(datRecs[col-1].rectyp == VD_DRWLO_EN_USERDEFINED)
  {
    UI_status("Unable to Revert/Field is User Defined");
    goto wrapup;
  }
  else if(datRecs[col-1].rectyp == VD_DRWLO_EN_ITEMNO)
  {
    UI_status("Unable to Revert/Field is Item No.");
    goto wrapup;
  }

  name[0] = '\0';
  sprintf( name, "%d %d", datRecs[col-1].colno, datRecs[col-1].lineno );

  sts = VDdrw_getAttFromColl( &msg, collId, name, &datValue );
  if( (sts&msg&1) ) 
  {
    /* ask user to confirm , may use it later
    sprintf( prompt, "Revert collomn %d, y/n [n]?", col);
    ci$get (	prompt	= prompt, 
		string	= inputStr);

    VD_stripString( inputStr );
    if( inputStr[0] != 'y' && inputStr[0] != 'y' )
    {
      goto wrapup;
    }
    */

    sts = ci$send (	msg     = message ACrg_collect.ACrem_attribute
							( &msg, name ),
			targetid = collId.objid,
			targetos = collId.osnum);
    for( j = 0; j < 50; j = j + 1 )
    {
      sprintf( txt, "%s", "(%d)", name, j);
      sts = ci$send (	msg     = message ACrg_collect.ACrem_attribute
                                                      ( &msg, txt ),
			targetid = collId.objid,
			targetos = collId.osnum);
      if( !(sts&msg&1) ) break;
    }
  }

  type = ND_COMP;
  sts = ci$send (	msg      = message VDSroot.VDcompute( &msg, &type),
			targetid = rowId.objid,
			targetos = rowId.osnum);

  UI_status("The Entry has been reverted");

  retFlag = 1;
wrapup:
  _FREE(datRecs);
  _FREE(datValue);
  return retFlag;
}


/*---------------------------------------------------------------------------*/
IGRstat	VDrvtRow_revertAllEntries( rowId )
  TGRid		rowId;
{
  IGRstat	retFlag;
  IGRlong	sts, msg;
  IGRint	i, j;
  IGRchar	name[40], txt[40] ,
		tblLoName[VD_DRWLO_CHR_IDFLD],
		*datValue;
  TGRid		collId;
  IGRint	nbDatRecs, type;

  struct VDdrwlo_data	*datRecs;

  retFlag	= 0;
  datRecs	= NULL;
  datValue	= NULL;

  /* get collector */

  collId.objid = NULL_OBJID;
  sts = ci$send(msg	 = message VDdrwTblRow.ACfind_temp_obj( &msg,
                                                               "coll",
                                                               &collId ),
		targetid = rowId.objid,
		targetos = rowId.osnum );
  if( !(sts&msg&1) ) 
  {
    __DBGpr_com("VDdrwTblRow.ACfind_temp_obj failed\n");
    goto wrapup;
  }

  /* get replaceable components */

  VDrvtRow_getData( rowId, &nbDatRecs, &datRecs );

  /* get attribute name from collector if any */

  for( i = 0 ; i < nbDatRecs ; i = i +1 )
  {
     if(datRecs[i].rectyp == VD_DRWLO_EN_USERDEFINED) continue;
     name[0] = '\0';
     sprintf( name, "%d %d", datRecs[i].colno, datRecs[i].lineno );
     sts = VDdrw_getAttFromColl( &msg, collId, name, &datValue );
     if( (sts&msg&1) ) 
     {
  	   sts = ci$send(msg     = message ACrg_collect.ACrem_attribute 
							( &msg, name ),
			targetid = collId.objid,
			targetos = collId.osnum);
	   for( j = 1; j < 50; j = j + 1 )
	   {
	     sprintf( txt, "%s", "(%d)", name, j);
	     sts = ci$send (	msg     = message ACrg_collect.ACrem_attribute
                                                        ( &msg, txt ),
				targetid = collId.objid,
				targetos = collId.osnum);
	     if( !(sts&msg&1) ) break;
	   }
     }

     _FREE(datValue);
  }
  
  type = ND_COMP;
  sts = ci$send (	msg      = message VDSroot.VDcompute( &msg, &type),
			targetid = rowId.objid,
			targetos = rowId.osnum);

  UI_status("All entries in the row have been reverted");

  retFlag = 1;
wrapup:
  _FREE(datRecs);
  _FREE(datValue);

  return retFlag;
}

/*---------------------------------------------------------------------------*/
IGRstat	VDrvtRow_rvtAllTblEntries( tblId )
  TGRid		tblId;
{
  IGRstat	retFlag;
  IGRlong	sts, msg;
  IGRint	i, j, nbHdrs,  nbRows, startRowNo;
  TGRid		*hdrIds, rowId;

  retFlag	= 0;
  nbHdrs	= 0;
  hdrIds	= NULL;

  sts = ci$send( msg		= message VDdrwTbl.VDgetTableParts (	
								&msg,
								&nbHdrs,
								hdrIds),
		targetid	= tblId.objid,
		targetos	= tblId.osnum );

  if( !(sts&msg&1) ) {
	UI_status("Failed to get table headers");
	goto wrapup;
  }

  if( nbHdrs < 0 ) goto wrapup;

  hdrIds = _MALLOC( nbHdrs, TGRid );
  if( hdrIds == NULL ) goto wrapup;

  sts = ci$send( msg		= message VDdrwTbl.VDgetTableParts (	
								&msg,
								&nbHdrs,
								hdrIds),
		targetid	= tblId.objid,
		targetos	= tblId.osnum );

  if( !(sts&msg&1) ) {
	UI_status("Failed to get table headers");
	goto wrapup;
  }

  for( i = 0; i < nbHdrs; i = i+1 )
  {
    nbRows = 0;
    sts = ci$send( msg		= message VDdrwTblHdr.VDgetRowInfo(
							&msg,
							&nbRows,
							&startRowNo),
		targetid	= hdrIds[i].objid,
		targetos	= hdrIds[i].osnum );
    if( !(sts&msg&1) ) goto wrapup;

    for( j = startRowNo ; j < startRowNo+nbRows ; j = j+1 )
    {
      rowId.objid = NULL_OBJID;
      sts = ci$send (	msg		= message VDdrwTblHdr.VDrowNoToGRid(
							&msg,
							j,
							&rowId ),
			targetid	= hdrIds[i].objid,
			targetos	= hdrIds[i].osnum );
      VDrvtRow_revertAllEntries( rowId );
    }
  }

 
  retFlag = 1;
wrapup:
  _FREE( hdrIds );
  return retFlag;
}


/* --------------------------------------
 * The main routine
 */
int main()
{
  IGRint		sts, msg, i, j;
  IGRint		response1, response2;
  IGRstat		retFlag;
  IGRchar		prompt1[80], prompt2[80], inputStr[80];
  IGRdouble		point[3];

  TGRid			rowId, entryId, locObj;
  OM_S_CLASSLIST	classList;
  VDclassid		classid, classids[2];

  
  retFlag = 0 ;
  classids[0] = OPP_VDdrwTblRow_class_id;
  classids[1] = OPP_VDdrwTbl_class_id;
  classList.p_classes	= classids;
  classList.w_count	= 2;
  classList.w_flags	= OM_CLST_subclass;
  strcpy( prompt1, "Select Table or Row");
  strcpy( prompt2, "Select an Entry from Row/Move on for all");

  response1 = 0;

  while(1) 
  {
    UI_message(cmdPrompt);
    sts = ci$locate (
		prompt			= prompt1,
		/*classes		= "VDdrwTblRow",*/
		properties		= LC_LC_ONLY | LC_DP_ONLY | LC_RW,
		owner_action		= LC_RIGID_COMP | LC_RIGID_OWNER |
					  LC_FLEX_COMP  | LC_FLEX_OWNER  | 
					  LC_REF_OBJECTS,
		eligible_classes	= &classList,
		response		= &response1,
		obj			= &locObj.objid,
		osnum			= &locObj.osnum );

    switch(response1) 
    {

    case EX_OBJID: 
	break;

    case EX_DATA:		/* single object selected */
	
	sts = om$get_classid (  objid     = locObj.objid,
                                osnum     = locObj.osnum,
				p_classid = &classid );

	if( classid == classids[1] )
	{
	  ci$get (	prompt	= "Revert All Table Entries, y/n [n]?", 
			string	= inputStr);

	  VD_stripString( inputStr );
	  if( inputStr[0] == 'y' || inputStr[0] == 'y' )
	  {
	    VDrvtRow_rvtAllTblEntries( locObj );
	    UI_status("All Entries have been reverted");
	  }
	  break;
	}

	while(1) 
	{
	  response2 = 0;
	  sts = ci$locate(prompt       = prompt2,
			  classes      = "GR3dtext",
			  properties   =  LC_LC_ONLY | LC_DP_ONLY | LC_RW,
			  owner_action =  LC_RIGID_COMP | LC_RIGID_OWNER |
			  		LC_FLEX_COMP  | LC_FLEX_OWNER |
			  		LC_REF_OBJECTS,
			  response     = &response2,
			  obj          = &entryId.objid,
			  osnum        = &entryId.osnum,
			  data_point   = point );

	  switch(response2) 
	  {

	  case EX_OBJID:
		break;

	  case EX_DATA:		/* single object selected */
		UI_status("");
		VDrvtRow_revertEntry( locObj, entryId, point );
		goto get_row;
     
    	  case EX_RJT_MOVEON:		/* move on */
		VDrvtRow_revertAllEntries( locObj );
		goto get_row;
	  };
	}

    case EX_RJT_MOVEON:		/* move on */
	break;
    } // Switch

get_row:
    continue;

  }   // while

wrapup:
  UI_message("");
  UI_status("");
  UI_prompt("");
  return 1;
}

/* -----------------------------------------------------------
 * Usual routines
 */

int init()
{
  return 1;
}

int delete()
{
  return 1;
}

int wakeup()
{
  return 1;
}

int sleep()
{
  return 1;
}
