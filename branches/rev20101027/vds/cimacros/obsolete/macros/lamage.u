/* $Id: lamage.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/obsolete/macros / lamage.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: lamage.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
	 92/07/22 Get rid of internal data (not used)
	 92/08/13	This macro is OBSOLETE (to be removed)
 */
   
/*******************************************************************/
/*
/*	Etienne BEEKER
/*	Sept 1st 89
/*
/*	place lamage in a solid
/*	with one point and depth
/*
/*******************************************************************/

// #define DEBUG 1

#include "cieveryone.h"
#include "cimacros.h"
#include "cisend.h"
#include "cimath.h"
#include "ci_mac_def.h"

#include "AS_status.h"
extern int	GRfindmod(), printf();

struct GRid		TMP;
int			status;


/* templates */
char 			*temp_names[8], *feet_names[1];

int			sts, j, temp_types[8];

GRobj 			ci_mac_def1;

struct GRid		GRid_list[1], CI_MACRO_ID;

struct GRmd_env		MOD_ENV, *pmod_env;
struct ret_struct	ret_st, expr, st_ref;

double 		matrix[16];
short		mat_type;


extern int 	EMintersect_two_element();
extern int 	sprintf(), init_cnst_list();
extern ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  temp_names[0]  = "radius";	// radius of the lamage
  temp_names[1]  = "r1";	// 
  temp_names[2]  = "h";		// 
  temp_names[3]  = "h1";	// 
  temp_names[4]  = "P";
  temp_names[5]  = "ref";
  temp_names[6]  = "solid";
  temp_names[7]  = "trav";

  temp_types[0] = parameter_generic | double_type;
  temp_types[1] = parameter_generic | double_type;
  temp_types[2] = parameter_generic | double_type;
  temp_types[3] = parameter_generic | double_type;
  temp_types[4] = point_generic;
  temp_types[5] = ref_generic;
  temp_types[6] = other_generic;
  temp_types[7] = parameter_generic | double_type;

  feet_names[0] = "SOL";
  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef =  ci_mac_def1,
		status 	 = &sts, 	
		name = "lamage",
              	temp_num = 8, 		
		temp_names = temp_names,
		temp_types = temp_types,
	      	extern_feet_num = 1, 	
		extern_feet_names = feet_names );
}

/* ========================================================================= */

init()
{
  feet_names[0] = "SOL";		// MADE_FACE; for RP
}

compute ()
{
#include "dp.h"
#include "dpmacros.h"
   int			Msg, action, mask;
   extern		DPdisbyoid();

  feet_names[0] = "SOL";
  GRid_list[0].objid = const_lamage();
   GRid_list[0].osnum = MOD_ENV.md_id.osnum;

  sts = ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &sts, 1, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  as$status(sts=sts);

/*
  Msg = ci$get_channel_objects(
		osnum		= CI_MACRO_ID.osnum,
		objid		= CI_MACRO_ID.objid,
		channname	= "GRcmpowner.to_components",
		obj_list	= &GRid_list[0].objid,
		osn_list	= &GRid_list[0].osnum,
		count		= &action );
  if( action != 1 || !(Msg & 1)){
#if DEBUG
write("pbs in trou.compute.ci$get_channel_objects, count=",action," Msg=", Msg,"\n");
#endif
	return(0);
  }
*/
// redisplays
  action = 1;    // set using mask
  mask   = 0x40; // display bit

  sts = ci$send( msg = message GRvg.GRchgprops( &Msg, &action, &mask),
       	   targetid = GRid_list[0].objid,
	   targetos = GRid_list[0].osnum );  
  as$status(sts=sts);

  dp$display( msg = &Msg,
  	    mode = GRbd,
	    oids = &GRid_list[0]);
  return(1);
}

/* ========================================================================= */

place ()
{
  GRid_list[0].objid = const_lamage();
  if( GRid_list[0].objid == NULL_OBJID ) return(0);
  GRid_list[0].osnum = MOD_ENV.md_id.osnum;

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &sts, 1,GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}

/* ============================================================ */

const_lamage()
{
    struct GRid			solid;
    double 	 		h1, h, r1, r2, r;
    GRobj			res_id, *pres_id;
    struct GRid			*psolid;
    int				trav, type;
    double			p[3], v[3];
    double			P1[3], P2[3];

   /* get parents info */
   ci$send( msg = message ACcpx.ACfind_temp_struct(&sts, "radius",
						    (char *) &expr, &MOD_ENV ),
  	 targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   r =  expr.var.root_pm_st.value;

#if DEBUG
write("got r:", r, '\n');
#endif

   ci$send( msg = message  ACcpx.ACfind_temp_struct(&sts,"P",
						   (char *) &ret_st
						   ,&MOD_ENV ),
	    targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   for(j=0; j<3; j=j+1)
      p[j] = ret_st.var.point_st.pt[j];

#if DEBUG
write("got P:", p,'\n');
#endif

   ci$send( msg = message ACcpx.ACfind_temp_struct(&sts, "h1",
						 (char *) &expr, &MOD_ENV),
	    targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   h1 = expr.var.root_pm_st.value;

   ci$send( msg = message ACcpx.ACfind_temp_struct(&sts, "h",
						 (char *) &expr, &MOD_ENV),
	    targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   h = expr.var.root_pm_st.value;

   ci$send( msg = message ACcpx.ACfind_temp_struct(&sts, "r1",
						 (char *) &expr, &MOD_ENV),
	    targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   r1 = expr.var.root_pm_st.value;

   ci$send( msg = message ACcpx.ACfind_temp_struct(&sts, "trav",
						 (char *) &expr, &MOD_ENV),
	    targetid = CI_MACRO_ID.objid, targetos = CI_MACRO_ID.osnum );
   trav = expr.var.root_pm_st.value;

#if DEBUG
write("got h1:", h1,"  h:", h, '\n');
write("got r1:", r1, '\n');
#endif

   if( !get_temp(CI_MACRO_ID, "solid", &solid) ){
	write("pbs in get_temp solid\n");
	return NULL_OBJID;
   }

  ci$send
    (msg      = message ACcpx.ACfind_temp_struct(&sts, "ref",
                                                 (char *)&st_ref, &MOD_ENV ),  
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  v[0] = st_ref.var.ref_st.t[2];
  v[1] = st_ref.var.ref_st.t[6];
  v[2] = st_ref.var.ref_st.t[10];

#if DEBUG
write("lamage, v:",v,'\n' );
#endif


   pmod_env = &MOD_ENV;
   psolid = &solid;

   if( !get_2p_int( p, v, psolid, h, P1, P2, pmod_env ) )
	return NULL_OBJID;

   pres_id = &res_id ;
   type = 0;
   r2 = 0.;
   h = 0.;

   push r, h1, h, r1, r2, P1, P2, psolid, pres_id, pmod_env, type, trav ;
   ci$exec( file_name = "bib_hole",
		load = LOAD,
		delete = 0,
	    entry = "place_hole_poly" );

   if( res_id == NULL_OBJID ){
	/* must unconsume */
	status = ci$send( msg = message  ACcpx.ACfind_temp_obj(&sts,"solid",&TMP),
                    targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );
        as$status(  );

        status = ci$send( msg = message  NDmacro.ACunconsume(&sts,""),
              targetid = TMP.objid,
	      targetos = TMP.osnum );
        as$status(  );
   }

   return res_id;
}

get_2p_int( p, v, solid, d, p1, p2, pmod_env )
double *p, *v;
struct GRid *solid;
double d, *p1, *p2;
struct GRmd_env *pmod_env;
/*
 * giving p, ref and solid, does the projection of p on the solid
 * along vector v
 * p2 is obtained with dist d
 */
{
   IGRboolean		flag;
   double		pts[6];
   int			msg, i;
   int			num_inter;
   struct GRid		linestr;
   struct GRvg_construct	cst;
   struct IGRdisplay	dis;
   struct IGRpolyline	polyline;
   struct GRid		*GRint;
   struct GRlc_info	obj1,obj2;
   double		dist, distx;
 

   /* construction list */
   init_cnst_list();
   get_symb();

   dis.color		= cnst_list.color;
   dis.weight		= cnst_list.weight;
   dis.style		= cnst_list.style;

   cst.msg		= &msg;
   cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
   cst.display		= &dis;
   cst.env_info		= pmod_env;
   cst.newflag		= FALSE;
   cst.level		= cnst_list.level;
   cst.geometry   	= (char *)&polyline;
   cst.class_attr	= NULL;
   cst.name		= NULL;

  /* create line obj1 */
  for( i=0; i<3; i=i+1 ){
     pts[i] = p[i];
     pts[i+3] = p[i] + v[i];
  }
  extend_2p(pts, &pts[3] );
  polyline.points = pts;
  polyline.num_points = 2;

  linestr.objid = NULL_OBJID;
  ci$send(msg      = message GR3dlinestr.GRaltconstruct(&cst),
	   targetid = linestr.objid,
	   targetos = pmod_env->md_id.osnum );

  linestr.osnum = pmod_env->md_id.osnum;


  
  obj1.located_obj = linestr;
  obj1.module_info = *pmod_env;

  obj2.located_obj = *solid;
  obj2.module_info = *pmod_env;
  flag = TRUE;

  EMintersect_two_element(&obj1,&obj2,flag,&cst,&num_inter,&GRint,&msg);

  /* the linestring is no longer used */
  ci$send(msg      = message GRgraphics.GRdelete(&sts,pmod_env), 
             targetid = linestr.objid,
	   targetos = linestr.osnum );

  if( num_inter == 0 )
	return 0;

  /* the nearest one */
  for(i=0;i<num_inter;i=i+1)
  {
   /* get the coord of the point */
    j /* action */ = 1;
    sts = ci$send( msg = message GRlinear.GRgetpolyline(
			    &msg, &pmod_env->md_env.matrix_type,
			    pmod_env->md_env.matrix, &j, &polyline),
		targetid = GRint[i].objid,
		targetos = GRint[i].osnum );

    distx =     (pts[0] - p[0]) * (pts[0] - p[0]) +
		(pts[1] - p[1]) * (pts[1] - p[1]) +
		(pts[2] - p[2]) * (pts[2] - p[2]);

    if( i == 0 || distx < dist ){
	dist = distx;
	for(j=0; j<3; j=j+1 )
		p1[j] = pts[j];
    }
  }
  dist = v_len(v);
  for(j=0; j<3; j=j+1)
   {
	v[j] = v[j] / dist;
	p2[j] = p1[j] - d * v[j];
   }
#if DEBUG
write("p1:",p1[0], p1[1], p1[2], '\n' );
write("p2:",p2[0], p2[1], p2[2], '\n' );
#endif

  /* the points are no longer used */
  ci$send(msg      = message GRgraphics.GRdelete(&sts,pmod_env), 
		targetid = GRint[0].objid,
		targetos = GRint[0].osnum );
  ci$send(msg      = message GRgraphics.GRdelete(&sts,pmod_env), 
		targetid = GRint[1].objid,
		targetos = GRint[1].osnum );

  return 1;
}

extend_2p( pt1, pt2)
double	*pt1, *pt2;
{
   #define BIG	100
   double v[3], p1[3], p2[3];
   int j;

   for(j=0; j<3; j=j+1){
	p1[j] = pt1[j];
	p2[j] = pt2[j];
	v[j] = p2[j] - p1[j];
	pt2[j] = p1[j] + BIG*v[j];
	pt1[j] = p2[j] - BIG*v[j];
   }
}

NDdelete(md_env)
struct GRmd_env *md_env;
{
	struct GRid 		TMP;
	struct GRid      	display_info;
	int			GRdpmode, status;
	int			action, mask;

        GRfindmod(&display_info);
        GRdpmode = 0;
	MOD_ENV=  *md_env;

#if DEBUG
write(">>>>>>>>> NDdelete \n");
#endif
        
	status = ci$send( msg = message  ACcpx.ACfind_temp_obj(&sts,"solid",&TMP),
                    targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );
        as$status(  );
	if(!sts) goto wrapup;

        status = ci$send( msg = message  NDmacro.ACunconsume(&sts,""),
              targetid = TMP.objid,
	      targetos = TMP.osnum );
        as$status(  );

	ci$send(msg = message GRgraphics.GRdisplay(
			&sts,
			&MOD_ENV.md_env.matrix_type,
                        MOD_ENV.md_env.matrix,
	                &GRdpmode,
			&display_info),
	        targetid = TMP.objid,
		targetos = TMP.osnum);

wrapup:
        ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
	         targetid = CI_MACRO_ID.objid,
	         targetos = CI_MACRO_ID.osnum,
                 mode     = WRT_message );

	return(1);
}

get_temp(cimacid, temp_name, temp)
struct GRid cimacid;
char * temp_name;
struct GRid *temp;
{
     status = ci$send( msg = message  ACcpx.ACfind_temp_obj
						(&sts,temp_name,&TMP),
                    targetid = cimacid.objid,
	            targetos = cimacid.osnum );
     as$status(  );

     status = ci$send( msg = message  
	      NDmacro.ACconsume(&sts,"", 1,temp, &MOD_ENV),
              targetid = TMP.objid,
	      targetos = TMP.osnum );
     as$status(  );

   return 1;
}


