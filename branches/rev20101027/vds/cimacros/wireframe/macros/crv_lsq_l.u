/* $Id: crv_lsq_l.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / crv_lsq_l.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: crv_lsq_l.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1996/02/15  11:24:38  pinnacle
# Replaced: cimacros/wireframe/macros/crv_lsq_l.u for:  by ksundar for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bserr.h"
#include "macro.h"
#include "msdef.h"


IGRboolean		periodic;
IGRchar 		*temp_names[5], *feet_names[1], txt[5], str[80];
IGRint			temp_types[5]; 
IGRlong			order, mx_ind;
IGRshort	 	matrix_type;

IGRlong      		number_of_points, num_seg, stat, msg;
IGRint		        k;

GRobj 	 		ci_mac_def1;

IGRdouble 	 	matrix[16], *beg_tan, *end_tan;
IGRdouble               *points, ave_err, max_err, pt1[6];

struct var
{
  int    beg;
  int    end;
}*me;


struct ret_struct  	expr;
struct ret_struct       tan_con;

struct GRid		CI_MACRO_ID, COMP, GCV, CUV;
struct GRmd_env		MOD_ENV;
struct IGRbsp_curve     *bsp_curve, curve;
struct GRvg_construct   cst;
struct IGRdisplay	dis;


extern int 		BSlsqfitcv(),
	   		*malloc(),
			free(),
			BSmkvec(),
			init_cnst_list();
extern IGRdouble	BSdotp();
extern 			ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation         */
/* ========================================================================= */

main ()
{

  temp_names[0]  = "ordr";
  temp_names[1]  = "nseg";
  temp_names[2]  = "crv0";  
  temp_names[3]  = "crv1";  
  temp_names[4]  = "crv2";

  temp_types[0]  = parameter_generic | double_type;
  temp_types[1]  = parameter_generic | double_type;
  temp_types[2]  = curve_generic;  
  temp_types[3]  = point_generic | line_generic;  
  temp_types[4]  = point_generic | line_generic;

  feet_names[0] = "rescur";
  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		prop		  = ACvariable_template | ACwith_instances,
		status 	          = &stat, 	   
		name              = "crv_lsq_l",
		int_name          = "var",	   
		int_size          = sizeof(struct var),
              	temp_num          = 5,              
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = 1, 	   
		extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{

  construct_comp();

  if( COMP.objid == NULL_OBJID ) return(0);

  strcpy(str,"average error = ");
  strcat(str,ftoa(ave_err));
  strcat(str,"  maximun error = ");
  strcat(str,ftoa(max_err));
  status(str);


  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &COMP, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum);
  return(1);

}

/* ========================================================================= */

place ()
{
  construct_comp();

  if( COMP.objid == NULL_OBJID ) return(0);

  strcpy(str,"average error = ");
  strcat(str,ftoa(ave_err));
  strcat(str,"  maximun error = ");
  strcat(str,ftoa(max_err));
  status(str);


  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &COMP, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum);
  return(1);
}


/* ========================================================================= */

construct_comp()
{

  COMP.objid = NULL_OBJID;
  COMP.osnum = MOD_ENV.md_id.osnum;
  beg_tan = NULL;
  end_tan = NULL;

/*--------------------------------------------------------------------------*/
/*----------------    get the order	        ----------------------------*/
/*--------------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct(
					&stat, 0, (IGRchar *)&expr,&MOD_ENV ),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) ){
		write(" bad expression for the order\n");
		return;
  }
  order = expr.var.root_pm_st.value;
/*--------------------------------------------------------------------------*/
/*----------------    get the number of segment           ------------------*/
/*--------------------------------------------------------------------------*/



  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct(
					&stat, 1, (IGRchar *)&expr,&MOD_ENV ),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  if( !(stat&msg&1) ){
		write(" bad expression for number of segment\n ");
		return;
  }

  num_seg = expr.var.root_pm_st.value;

/*--------------------------------------------------------------------------*/
/*----------------    get the linestring	     -----------------------*/
/*--------------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,2,&CUV),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );

  if( !(stat&msg&1) ) return;

   msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						"",
						&GCV, 
						&matrix_type, 
					        matrix ),
	   targetid = CUV.objid,
	   targetos = CUV.osnum );

  if(!(stat&msg&1)){
		write(" bad curve\n" );
		return;
  }



  ci$send(  msg = message GRvg.GRgenabsg( &msg,
			                  &matrix_type, 
				          matrix, 
					  &bsp_curve ),
           targetid = GCV.objid,
 	   targetos = GCV.osnum );

  if( (bsp_curve->num_poles) <= order )
  {
     write("order > number of points\n");
     return;
  }

/*--------------------------------------------------------------------------*/
/*----------------    get start tangent if exists          -----------------*/
/*--------------------------------------------------------------------------*/
  k = 3;

  if(me->beg == 1 ){

    	msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( 
							&stat, 
							k,
							(IGRchar *)&tan_con,
						        &MOD_ENV ),
	     	targetid = CI_MACRO_ID.objid,
	     	targetos = CI_MACRO_ID.osnum );

  	if( !(stat&msg&1) ){
		write("error in start tangent\n");
		goto wrapup;
	}

        beg_tan = (IGRdouble *) malloc(3 * sizeof(IGRdouble));
	set_tgt( &msg, (IGRint) 1, &(bsp_curve->poles[0]),
		 &(bsp_curve->poles[3]),&tan_con,beg_tan );
	if( msg != BSSUCC ) goto wrapup;

	k = 4;

  	#ifdef DEBUG
        	write("beg_tan =",beg_tan[0],beg_tan[1],beg_tan[2],"\n");
  	#endif

  }

/*--------------------------------------------------------------------------*/
/*----------------    get end tangent if exists            -----------------*/
/*--------------------------------------------------------------------------*/


  if(me->end == 1 )
  {
    	msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( 
							&stat, 
							k,
							(IGRchar *)&tan_con,
						        &MOD_ENV ),
	     	targetid = CI_MACRO_ID.objid,
	     	targetos = CI_MACRO_ID.osnum );

  	if( !(stat&msg&1) ){
		write(" error in end tangent\n");
		goto wrapup;
	}

        end_tan = (IGRdouble *) malloc(3 * sizeof(IGRdouble));
	k = 3 * (bsp_curve->num_poles-1);

	set_tgt( &msg, (IGRint)2, &(bsp_curve->poles[k]), 
				  &(bsp_curve->poles[k-3]), 
		 		  &tan_con, end_tan );
	if( msg != BSSUCC ) goto wrapup;

  	#ifdef DEBUG
        	write("end_tan =",end_tan[0],end_tan[1],end_tan[2],"\n");
  	#endif

  }


  number_of_points = bsp_curve->num_poles;
  points = bsp_curve->poles;
  periodic = FALSE;

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= (char *)&curve;
  cst.class_attr	= 0;
  cst.name		= 0;

  stat = ci$send(msg      = message GRbcsubbc.EMleast_squares_fit_curvee(
					order,
 					periodic,
					number_of_points,
					points,
					NULL,
					beg_tan,
					end_tan,
					num_seg,
					NULL,
					&ave_err,
					&max_err,
					&mx_ind,
					pt1,
					&cst ),
                targetid = COMP.objid,
	        targetos = COMP.osnum );

  	if( !(stat&1) ){
		COMP.objid = NULL_OBJID;
		#ifdef DEBUG
		   write(" error in GRbcsubbc.EMleast_squares_fit_curvee \n");
		#endif
	}
	else{
	     if( dis.weight < 2 ) dis.weight = 2;
	     if ( mx_ind != -1 )
	     	display_max_error( &msg, pt1, (IGRdouble) 1.0, &cst );
	     /*if max_err=0 then EMleast_squares_fit_curvee sets mx_ind -1*/
	}

wrapup:

  if(beg_tan) { free(beg_tan); beg_tan = NULL; }
  if(end_tan) { free(end_tan); end_tan = NULL; }

}

/*=========================================================================*/

set_tgt( rc, flag, frompt, topt, ret, tan )

IGRlong			*rc;
IGRint		        flag;     /* flag = 1 -> start tangent */
IGRdouble		*frompt;
IGRdouble		*topt;
struct ret_struct 	*ret;
IGRdouble		*tan;

{
		
IGRdouble vdif[3], v1[3];
IGRint	  ind;

	    #ifdef DEBUG
		write("frompt=",frompt[0],frompt[1],frompt[2],"\n");
		write("topt=",topt[0],topt[1],topt[2],"\n");
	    #endif

	    if( flag == 1 ) BSmkvec(rc,vdif,frompt,topt);
            else            BSmkvec(rc,vdif,topt,frompt);
	    if( *rc != BSSUCC ) return;
		
	    if( ret->type == line_generic ){
		if( BSdotp(rc,vdif,ret->var.line_st.v0) < 0.0 ){
			tan[0] = -1.0 * ret->var.line_st.v0[0];
			tan[1] = -1.0 * ret->var.line_st.v0[1];
			tan[2] = -1.0 * ret->var.line_st.v0[2];
		}
		else{
			tan[0] = ret->var.line_st.v0[0];
			tan[1] = ret->var.line_st.v0[1];
			tan[2] = ret->var.line_st.v0[2];
		}
		*rc = BSSUCC; 
		return;		
	    }
	    else if( ret->type == point_generic ){

	    	BSmkvec(rc,tan,frompt,ret->var.point_st.pt);
		if( BSdotp(rc,vdif,tan) < 0.0 ){
			tan[0] = -1.0 * tan[0];
			tan[1] = -1.0 * tan[1];
			tan[2] = -1.0 * tan[2];
		}

		*rc = BSSUCC;
		return;
	    }
	    else *rc = BSFAIL;

}


/*=========================================================================*/

display_max_error( rc, fromtopt, ratio, cst )

IGRlong			*rc;
IGRdouble		*fromtopt;
IGRdouble		ratio;
struct GRvg_construct	*cst;

{

struct IGRpolyline	line;
IGRint			GRdpmode;
struct GRid		display_info, lineGRid;
IGRlong			OMsts, msgmsg;
IGRint			i;
IGRdouble		unMratio;
extern IGRint		GRfindmod();


     	GRfindmod(&display_info);
	GRdpmode = GRbd;
	lineGRid.objid = NULL_OBJID;
	lineGRid.osnum = cst->env_info->md_id.osnum;
	line.num_points = 2;
	unMratio = 1.0 - ratio;

	for(i=0;i<3;i=i+1) 
	fromtopt[i+3] = unMratio * fromtopt[i] + ratio * fromtopt[i+3];

        line.points = (IGRdouble *) fromtopt;
	cst->geometry = (char *)&line;


  	OMsts = ci$send( msg       = message GR3dlineseg.GRaltconstruct(cst),
        	         targetid  = lineGRid.objid,
 	                 targetos  = lineGRid.osnum ) ;
 	if( !(OMsts&1) ){ *rc = MSFAIL; return; }
 
       	OMsts = ci$send( msg      = message GRgraphics.GRdisplay(
                 		     &msgmsg,
				     &cst->env_info->md_env.matrix_type,
              			     cst->env_info->md_env.matrix,
				     &GRdpmode, 
				     &display_info),
                         targetid = lineGRid.objid,
		         targetos = lineGRid.osnum );
  
 	if( !(OMsts&msgmsg&1) ){ *rc = MSFAIL; return; }

  	OMsts = ci$send( msg      = message  GRgraphics.GRdelete( 
							&msgmsg,
                                                        &cst->env_info ),
                 targetid = lineGRid.objid,
		 targetos = lineGRid.osnum );
 	if( !(OMsts&msgmsg&1) ){ *rc = MSFAIL; return; }

	*rc = MSSUCC;
}

