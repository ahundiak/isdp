/* $Id: COcrv_offset.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/cmd / COcrv_offset.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COcrv_offset.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.5  1996/09/09  15:04:36  pinnacle
# Replaced: cimacros/wireframe/cmd/COcrv_offset.u for:  by yzhu for vds.241
#
# Revision 1.4  1996/09/06  18:11:32  pinnacle
# Replaced: cimacros/wireframe/cmd/COcrv_offset.u for:  by yzhu for vds.241
#
# Revision 1.3  1996/09/06  17:23:46  pinnacle
# Replaced: cimacros/wireframe/cmd/COcrv_offset.u for:  by yzhu for vds.241
#
# Revision 1.2  1996/07/30  19:30:56  pinnacle
# Replaced: cimacros/wireframe/cmd/COcrv_offset.u for:  by yzhu for vds.241
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
	 92/07/22 Get rid of internal data (not used)
 */
   
#include "ciminimum.h"
#include "cimacros.h"
#include "igr.h"
#include "cieveryone.h"
#include "EMSmsgdef.h"
#include "msdef.h"
#include "ciexec.h"
/* #define  DEBUG  1 */

GRobj 			ci_mac_bib_FileId;


struct OM_sd_classlist	classlist;
OMuword			classid[2];

IGRchar			loc_mes[80],loc_prompt[80], prompt_mes[80], 
			exp_prompt[80], exp_class[40];
IGRlong			EMSrtmsg;
int 			suc, num_temp, suc1,i;
GRobj 			MAC1;
struct GRid 		TEMP[3], GRO;
struct GRmd_env 	MOD_ENV;
struct IGRplane 	plane;
struct IGRbsp_curve  	*bsp;
struct GRprops		props;
IGRdouble		exp_default, t_plan[6], nvec[3];
IGRboolean		planar;
char            	class_name[80];

OMuword			pt_cl, loc_exp, ln_cl, loc_cl, cs_cl;

extern ASmake_source_from_env();
extern BStst_plan();

extern char 	*malloc();
extern int 	free();
extern GRclassid        OPP_GRpoint_class_id ;

main()
{
  plane.point = &t_plan[0];
  plane.normal = &t_plan[3];

   while(1)
   {
       strcpy(loc_prompt,"Identify offset point / enter offset length");
       strcpy(exp_prompt,"enter offset length value");
       exp_default = 1.0;
       strcpy(exp_class,"GRpoint");       
       push (char *)&suc1,loc_mes,loc_prompt,exp_prompt,exp_default,
	    exp_class,(char *)&TEMP[0];
       ci$run( file_id   = &ci_mac_bib_FileId,
 	       entry     = "loc_obj_exp" );
       if( suc1 == 0 ) exit;

       om$get_classid(	osnum		= TEMP[0].osnum	,
			objid		= TEMP[0].objid	,
			p_classid	= &loc_exp	) ;

       /* add for TR179602145 */
      om$get_classname(objid     = TEMP[0].objid,
                       osnum     = TEMP[0].osnum,
                       classname =  class_name);

       if( om$is_ancestry_valid( 
				  superclassid	= pt_cl,
				  subclassid	= loc_exp ) == OM_S_SUCCESS )
	    suc1 = 1;
       while(1)
       {

step1:  if(!ci$locate( prompt       = "Identify curve ",
                       properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                       owner_action = LC_RIGID_COMP  |
                                      LC_RIGID_OWNER | LC_FLEX_COMP |
                                      LC_FLEX_OWNER  | LC_REF_OBJECTS,
		       classes      = "GRcurve",
	               obj          = &(TEMP[1].objid),
                       osnum        = &(TEMP[1].osnum),
		       md_env       = &MOD_ENV          )) break;



        ci$send(  msg = message GRvg.GRgenabsg( 
					     &EMSrtmsg,
			       		     &MOD_ENV.md_env.matrix_type,
			       		     MOD_ENV.md_env.matrix,
					     &bsp ),
              targetid = TEMP[1].objid,
 	      targetos = TEMP[1].osnum );

     	ASmake_source_from_env( &TEMP[1],&MOD_ENV,&TEMP[1] );	

	BStst_plan((IGRint)bsp->num_poles, bsp->poles,bsp->weights,
		   &planar, nvec, &EMSrtmsg);

	#ifdef DEBUG
	write("EMSrtmsg = ",EMSrtmsg ,"planar =",planar,"\n");
	#endif


	if(  !(planar&1)  ){

/*	   status("curve is NOT planar You must Identify a vector or cs"); */
	   status("Located curve is not planar");
	   num_temp = 3;

           /* modify for TR179602145 */
           if ( strcmp(class_name, "expression")) {
             /* for point */
             if(!ci$locate( prompt       = "Identify vector or cs",
                               properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                               owner_action = LC_RIGID_COMP  |
                                              LC_RIGID_OWNER | LC_FLEX_COMP |
                                              LC_FLEX_OWNER  | LC_REF_OBJECTS,
                               eligible_classes = &classlist,
                               obj          = &(TEMP[2].objid),
                               osnum        = &(TEMP[2].osnum),
                               response     = &M_response,
                               md_env       = &MOD_ENV  ) ) goto step1;
           }
           else { /* for expression */
        	if(!ci$locate( prompt       = "Identify cs",
                               properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                               owner_action = LC_RIGID_COMP  |
                                              LC_RIGID_OWNER | LC_FLEX_COMP |
                                              LC_FLEX_OWNER  | LC_REF_OBJECTS,
                               classes      = "GRlbsys",
                               obj          = &(TEMP[2].objid),
                               osnum        = &(TEMP[2].osnum),
		       	       md_env       = &MOD_ENV  )) goto step1;
           }
     
           ASmake_source_from_env( &TEMP[2],&MOD_ENV,&TEMP[2] );	

	}
        else
	{
	   status("Located curve is planar");
        
           /* modify for TR179602145 */
           if ( strcmp(class_name, "expression")) {
  	     strcpy(prompt_mes,"Identify vector or cs / Move-on for active cs");
             ci$locate( prompt = prompt_mes,
                               properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                               owner_action = LC_RIGID_COMP  |
                                              LC_RIGID_OWNER | LC_FLEX_COMP |
                                              LC_FLEX_OWNER  | LC_REF_OBJECTS,
                               eligible_classes = &classlist,
                               obj          = &(TEMP[2].objid),
                               osnum        = &(TEMP[2].osnum),
                               response     = &M_response,
                               md_env       = &MOD_ENV  );
           }            
           else {
   	     strcpy(prompt_mes,"Identify cs / Move-on for active cs");
             ci$locate( prompt = prompt_mes,
                               properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                	       owner_action = LC_RIGID_COMP  |
                        	              LC_RIGID_OWNER | LC_FLEX_COMP |
                                	      LC_FLEX_OWNER  | LC_REF_OBJECTS,
		               classes      = "GRlbsys",
	                       obj          = &(TEMP[2].objid),
                               osnum        = &(TEMP[2].osnum),
		    	       response     = &M_response,
		       	       md_env       = &MOD_ENV  );
            }
		if( (M_response == EX_RJT_MOVEON)){
			num_temp = 2;
		}
		else if( (M_response == EX_DATA)   ){
			num_temp = 3;
	   		ASmake_source_from_env( &TEMP[2],&MOD_ENV,&TEMP[2]);	
		}
		else if( M_response == EX_BACK_UP ){ 
			goto step1;
		}
		else exit;

	}

step2:
        MAC1 = NULL_OBJID;

   	ci$get_module_info(md_env = &MOD_ENV);
	#ifdef DEBUG
		write("num_temp =",num_temp,"\n");
		for(i=0;i<num_temp;i=i+1)
		write("TEMP[",i,"]=",TEMP[i].objid,TEMP[i].osnum,"\n");
	#endif
        ci$send(msg      = message nci_macro.init(
						 &suc,
						 0,
						 "crv_offset",
						 num_temp,
                                                 TEMP,
						 NULL,
						 &MOD_ENV ),
	        targetid = MAC1,
		targetos = MOD_ENV.md_id.osnum );

   	if( suc == 0 ){
			write("placement of nci_macro \"crv_offset\" failed\n");
			status("placement of nci_macro \"crv_offset\" failed");
      			ci$send(msg      = message Root.delete(0),
	      			targetid = MAC1,
	      			targetos = MOD_ENV.md_id.osnum );
        }


	}
   }
}


/*==========================================================================*/
init(){

   	om$get_classid( classname = "GR3dpoint",
		   	p_classid = &pt_cl);
   	om$get_classid( classname = "GR3dlineseg",
			p_classid = &ln_cl);
   	om$get_classid( classname = "GRlbsys",
			p_classid = &cs_cl);

	classid[0] = ln_cl;
	classid[1] = cs_cl;
  	classlist.w_count = 2;
  	classlist.w_flags = OM_CLST_subclass;
  	classlist.p_classes = classid;

   	strcpy(loc_mes,"<Assoc> Place Offset Curve");

 	ci$load ( file_name = "ci_mac_bib.u",
		  load      = LOAD,
	  	  file_id   = &ci_mac_bib_FileId,
		  stat      = &suc );
	if( suc != CI_S_SUCCESS ) exit;
}

wakeup(){
	message(loc_mes);
}

/*==========================================================================*/



