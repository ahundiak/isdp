/* $Id: COsol_int.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/solid/cmd / COsol_int.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COsol_int.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.3  1996/03/15  04:58:38  pinnacle
# Replaced: cimacros/solid/cmd/COsol_int.u for:  by rgade for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
	 92/08/06	Refresh command object 

	 Description : <Assoc> Intersect Solids
 */
   
#include <stdio.h>
#include "cieveryone.h"
#include "AS_status.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "emsbool.h"

#define MAX_TEMP 2		/* only two solids */

struct GRid 	TEMP[MAX_TEMP],AREA_OBJ[MAX_TEMP];
GRobj 		MAC1 ; 
short           num_solid ;
long		stat, msg ;
char            txt[81], mes_f[81] ; 
struct GRmd_env	MOD_ENV;

struct
 {
  int               num_solid ; /* number of solid to do operation */
  enum EMSbooltype  booltype  ; /* operation type */	
 } var;
 

extern ASmake_source_from_env();
extern UI_status();


main()
{
 strcpy(mes_f,"<Assoc> Intersect Solids") ; 

 while(1) {
 	message(mes_f) ;
      	var.booltype = EMSbool_intersect ;

  	strcpy(txt, "Identify first solid") ;
  	if( !ci$locate ( prompt       = txt,
                   properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
		   classes	= "EMSsolid",
                   owner_action = LC_RIGID_COMP
                                    | LC_RIGID_OWNER | LC_FLEX_COMP
                                    | LC_FLEX_OWNER  | LC_REF_OBJECTS,
		   obj          = &(TEMP[0].objid),
		   osnum        = &(TEMP[0].osnum),
		   md_env       = &MOD_ENV   )) exit;

        AREA_OBJ[0].objid = TEMP[0].objid;
        AREA_OBJ[0].osnum = TEMP[0].osnum;



     	ASmake_source_from_env(&TEMP[0],&MOD_ENV,&TEMP[0]) ;	
  	num_solid = 1 ;
        while(1) {
		strcpy(txt,"Identify second solid") ;
		if (!ci$locate( prompt = txt,
       	            	 properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
       	             	 owner_action = LC_RIGID_COMP
                                    | LC_RIGID_OWNER | LC_FLEX_COMP
                                    | LC_FLEX_OWNER  | LC_REF_OBJECTS,
		    	 classes	 = "EMSsolid",
	            	 obj          = &(TEMP[1].objid),
                    	 osnum        = &(TEMP[1].osnum),
		    	 md_env  = &MOD_ENV )) exit;
 
        	AREA_OBJ[1].objid = TEMP[1].objid;
        	AREA_OBJ[1].osnum = TEMP[1].osnum;
               

		if( TEMP[num_solid].objid == AREA_OBJ[0].objid &&
              		TEMP[num_solid].osnum == AREA_OBJ[0].osnum     )
        	{
             	 	UI_status("Same solid should not be selected");
             		continue;
        	} else
                        break;
	}               

		ASmake_source_from_env( &TEMP[1],&MOD_ENV,&TEMP[1] ) ;	
     		num_solid = num_solid + 1 ;

  	MAC1	      = NULL_OBJID ;
  	var.num_solid = num_solid  ;
  	ci$get_module_info(md_env = &MOD_ENV) ;

  	status("processing");
  	stat = ci$send( msg = message nci_macro.init
		( &msg,0, "nboolean", num_solid,TEMP, &var,&MOD_ENV),  
		targetid = MAC1,
		targetos = MOD_ENV.md_id.osnum) ;
	if (!(stat & msg & 1)) {
		stat = 0 ; as$status(sts = stat) ;
		write("placement of nci_macro \"nboolean\" failed\n");
		status("placement of nci_macro \"nboolean\" failed");
      		stat = ci$send(msg = message Root.delete(0),
			targetid = MAC1,
			targetos = MOD_ENV.md_id.osnum ) ;
		as$status(sts = stat) ;
		}
 	else  { status("") ; return(OM_S_SUCCESS) ; }
	}
} /* main() */


wakeup(){
	message(mes_f) ;
	}
