/* $Id: pla_offext.u,v 1.3 2001/05/31 18:25:47 ad Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / pla_offext.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: pla_offext.u,v $
 *	Revision 1.3  2001/05/31 18:25:47  ad
 *	*** empty log message ***
 *	
 *	Revision 1.2  2001/02/23 16:25:36  jayadev
 *	extent_surface_geom() changed to uv_extent_surface_geom()
 *	
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/02/16  20:02:04  pinnacle
# Replaced: cimacros/surface/macros/pla_offext.u for:  by impd for vds
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.3  1996/01/24  20:08:16  pinnacle
# Replaced: ./cimacros/surface/macros/pla_offext.u for:  by azuurhou for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR	DESCRIPTION
 *	92/05/06 	jll 	Add support for general surface 
 *	92/08/17	alc	Use EMoffset(); Was EMgenerate_offset_surface()
 *	92/11/05	alc	Use EMSgenbs class instead of EMSsubbs
 *	92/11/11	alc	Do manually offset/extent
 *	94/04/11	cvr	changed EMoffset() with new arguments 
 *	01/23/95	adz	Correction TR179524893.	Invalid direction.
 *	02/23/01	Jayadev extent_surface_geom() changed to 
 *				uv_extent_surface_geom() by Jean Luc
 *	05/31/01	adz	The BSxln routine returns Nan at first call(MP5244)
 * -------------------------------------------------------------------*/

#ifdef CLOCK
extern clock();
#endif

/*
 *
 * concatenation of pla_offset and pla_ext
 *
 * this is a new CI_MACRO
 */

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "AS_status.h"
#include "EMSssprops.h"
#include "bserr.h"

// #define DEBUG	1

extern printf(), sprintf();
extern		ASsuper_construct();

unsigned IGRchar	props;

IGRchar 		*temp_names[3], *feet_names[1];

IGRint			temp_types[3];

IGRshort	 	action, mask, option;

IGRlong			stat, msg, size;
IGRint			i, j, k;
 
double 	 		dir,xx;

GRobj 			ci_mac_def1;

struct GRid		GCV, CUV, EXT_SURF, GRid_list[1], CI_MACRO_ID;
struct GRid		S_OFFSET;
struct GRmd_env		MOD_ENV, from_env;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct IGRbsp_surface   *sf1, *sf2;
struct ret_struct	temp1_rts, temp2_rts, expr;

//IGRlong			ext_val;
IGRdouble		offs_val, ext_val;

IGRdouble		v1[3], v2[3], vn[3], lenrng;
IGRdouble		p0[3], p1[3], p2[3], p3[3];
IGRdouble		p01[3], p12[3], p23[3], p30[3];
IGRdouble		p03[3], p10[3], p21[3], p32[3];
IGRdouble		range[6], t_plan[6];
struct IGRplane         plane;
IGRboolean		planar;
IGRdouble		nvec[3];
IGRboolean              is_natural_normal;

extern int 		init_cnst_list(),
			free();
extern IGRboolean 	BSxln();
extern int 		BScrossp(),
			BSnorvec();

extern IGRchar     	*malloc();
extern IGRdouble	BSdistptpt();
extern void		BSallocsf();
extern IGRboolean	BSfreesf();
extern char     	*memcpy();
extern IGRint		uv_extent_surface_geom(); /* from VDSppl_util.I */
extern	IGRdouble	fabs();
extern IGRint extent_surface_geom(); 

main ()
{
  temp_names[0]  = "extension";  
  temp_names[1]  = "offset";  
  temp_names[2]  = "surface";  

  temp_types[0]  = parameter_generic | double_type;
  temp_types[1]  = parameter_generic | double_type; 
  temp_types[2]  = other_generic;

  feet_names[0] = "ressur";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &msg, 	
		name              = "pla_offext",
              	temp_num          = 3, 		
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}
/* ========================================================================= */

place ()
{
  if ( construct_pjs() == OM_E_ABORT )
  {
    status("placement of nci_macro \"pla_offext\" failed");
  }

  if( GRid_list[0].objid == NULL_OBJID ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &msg, 1,GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}
/* ========================================================================= */

compute ()
{
  char str[80];
  
#ifdef CLOCK
write( "pla_offext compute begin clock() = ", clock()/1000, '\n' );
#endif

  if ( construct_pjs() == OM_E_ABORT )
  {
    sprintf ( str, "compute of nci_macro \"pla_offext\" [%d,%d] failed", CI_MACRO_ID.osnum, CI_MACRO_ID.objid );
    
    printf ("%s\n", str);
    status ( str );
  }

#ifdef CLOCK
write( "pla_offext compute after construct clock() = ", clock()/1000, '\n' );
#endif
  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &msg, 1,GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}
/*======================================================================*/

construct_pjs()
{
  int 		num_nooffsetsfs ;
  GRobjid	*nooffsetsfs ;
  char 		*status_str  ;	/* new arguments for EMoffset() in 2.1 */
  double	u_extent, v_extent;

#ifdef DEBUG
	write(" START function construct_pjs \n");
#endif

  GRid_list[0].objid = NULL_OBJID;
  GRid_list[0].osnum = MOD_ENV.md_id.osnum;
  S_OFFSET.objid     = NULL_OBJID;
 
  sf1 = NULL;
  sf2 = NULL;

  stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct(&msg,0,
						   &expr,&MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  if( !(msg&stat&1) ){
	write(" bad expression extension \n");
	return;
  }
//  as$status( sts= stat );
  ext_val = expr.var.root_pm_st.value;

  stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct(&msg,1,
						   &expr,&MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  if( !(msg&stat&1) ){
	write(" bad expression offset \n");	
	return;
  }
//  as$status( sts= stat );
  offs_val = expr.var.root_pm_st.value;

  stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&msg,2,&GCV),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  as$status( sts= stat );

  msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						".",
						&CUV, 
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix ),
	   targetid = GCV.objid,
	   targetos = GCV.osnum );

  if( !(msg&stat&1) ) return;

  #ifdef DEBUG
	write(" surface =",CUV.objid,CUV.osnum,"\n");
  #endif

  stat =	ci$send( msg = message GRvg.GRgetsize( 	
							&msg,
			     		       		&from_env.md_env.matrix_type,
			     		       		from_env.md_env.matrix,
			     		       		&size ),
	  	 	 targetid = CUV.objid,
	  	 	 targetos = CUV.osnum );
  if( !(stat&msg&1) ) goto wrapup;

  #ifdef DEBUG
	write(" size =", size ,"\n");
  #endif


  sf1 = (struct IGRbsp_surface *) malloc(size);
  if (sf1 == NULL) goto wrapup ;

  stat = ci$send( msg = message EMSsubbs.GRgetgeom( 	
					&msg,
			     		&from_env.md_env.matrix_type,
			     		from_env.md_env.matrix,
			     		( char *) sf1 ),
	  	 	 targetid = CUV.objid,
	  	 	 targetos = CUV.osnum );

 if( !(stat&msg&1) ){
			write("erreur\n");
			goto wrapup;
 }

  stat = ci$send( msg      = message  EMSsubbs.EMget_props( &msg,&props),
	   targetid = CUV.objid,
	   targetos = CUV.osnum );
  if( !(msg&stat&1) ) return;
  as$status( sts= stat );

/* doing my own extent (EB) */
#ifdef CLOCK
write( "pla_offext construct beginning of math clock() = ", clock()/1000, '\n' );
#endif

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= (char *)sf1;
  cst.class_attr	= 0;
  cst.name		= 0;



  if( (sf1->u_num_poles > 2) || (sf1->v_num_poles > 2) ){ 

     #ifdef DEBUG
     write(" general case\n");
     #endif


     /*
	1) Offset surface
      */

     if( fabs(offs_val) > 1.0E-6 ){

	#ifdef DEBUG
	write("offs_val =",offs_val,"\n");
	#endif

	if( offs_val < 1.0E-6 ){
		is_natural_normal = TRUE ;
		offs_val = fabs(offs_val);
	}
	else	is_natural_normal = FALSE;
	
	#ifdef DEBUG
	write("is_natural_normal =",is_natural_normal,"\n");
	write("offs_val =",offs_val,"\n");
	#endif

	if( props & EMSIS_NRML_REVERSED ) {
		if( is_natural_normal )
			is_natural_normal = FALSE;
		else	is_natural_normal = TRUE;
	}



	#ifdef DEBUG
	write("macro pla_offext : call to EMoffset\n") ;
	write("is_natural_normal ",is_natural_normal,"\n") ;
	write("offs_val ",offs_val ,"\n") ;
	#endif

	option = 1;
	num_nooffsetsfs = 0 ;
	nooffsetsfs     = NULL ;
	status_str      = NULL ;	/* EMS 2.1 */
	stat = ci$send( 
		   	msg = message EMSsurface.EMoffset(
					&msg,
					option,
                           		&from_env.md_env.matrix_type,
                           		from_env.md_env.matrix,
					&cst,
					is_natural_normal,
					offs_val,
                                        0,
                                        NULL,
                                        NULL,
					0, NULL, NULL,
			/***
					num_nooffsetsfs,
					nooffsetsfs,
					status_str,
			 ***/
					&S_OFFSET.objid,
                                        NULL ),
       			targetid = CUV.objid,
       			targetos = CUV.osnum) ; as$status(sts = stat) ;

//printf ("stat = %d, msg = %#x\n", stat, msg );

   	if( !(stat & 1 & msg) ) goto wrapup;
	S_OFFSET.osnum = MOD_ENV.md_id.osnum;

	sf1 = NULL;
	stat =	ci$send( msg = message GRvg.GRgetsize( 	
						&msg,
			     		       	&MOD_ENV.md_env.matrix_type,
			     		       	MOD_ENV.md_env.matrix,
			     		       	&size ),
	  	 	 	targetid = S_OFFSET.objid,
	  	 	 	targetos = S_OFFSET.osnum );
	if( !(stat&msg&1) ) goto wrapup;


	sf1 = (struct IGRbsp_surface *) malloc(size);
	if( sf1 == NULL ) goto wrapup;

	stat = ci$send( msg = message EMSsubbs.GRgetgeom( 	
					&msg,
			     		&MOD_ENV.md_env.matrix_type,
			     		MOD_ENV.md_env.matrix,
			     		( char *) sf1 ),
	  	 	 targetid = S_OFFSET.objid,
	  	 	 targetos = S_OFFSET.osnum );
	if( !(msg&stat&1) ) goto wrapup ;

	stat = ci$send(	msg = message GRgraphics.GRdelete(
							&msg,
							&MOD_ENV ),
	  	 	 		targetid = S_OFFSET.objid,
	  	 	 		targetos = S_OFFSET.osnum );

     }/* end of offset evaluation */

   else{
     #ifdef DEBUG
     write("pas d'offset\n");
     #endif
     }

   /*
	2) Extent surface (note : a copy is just returned for a small extent)
    */

	#ifdef DEBUG
	write("macro pla_offext : call to uv_extent_surface_geom() \n") ;
	#endif

	sf2 = NULL;
 
	u_extent = ext_val;
	v_extent = ext_val;

	stat = uv_extent_surface_geom( sf1, u_extent, v_extent, &sf2 );
//	stat = extent_surface_geom( sf1,ext_val,&sf2);
	if( stat != 1 ) goto wrapup;

	cst.geometry		= (char *)sf2;
	stat = ci$send(msg = message EMSgenbs.GRconstruct(&cst),
           	               targetid = GRid_list[0].objid,
           		       targetos = GRid_list[0].osnum );
	as$status(sts=stat) ;


  	if( sf1 != NULL ) free(sf1);
  	if( sf2 != NULL ){ BSfreesf(&msg,sf2); sf2 = NULL;}
  	if( !(stat&1) ) GRid_list[0].objid = NULL_OBJID;

	#ifdef DEBUG
	write("Success for general case \n") ;
	#endif

	return OM_S_SUCCESS ;

	} /* if general case */

else{

#ifdef DEBUG
	write("Particular case \n") ;
	write("u_num_poles is ", sf1->u_num_poles, "\n") ;
	write("v_num_poles is ", sf1->v_num_poles, "\n") ;
#endif

  	/* Load the poles */
  	 for(i=0; i<3; i=i+1){
		p0[i] = sf1->poles[i];
		p1[i] = sf1->poles[i+3];
		// ACHTUNG 2 and 3 are inverted
		p2[i] = sf1->poles[i+9];
		p3[i] = sf1->poles[i+6];
   		}
#ifdef DEBUG
	write("Poles", sf1->poles[0], sf1->poles[1], sf1->poles[2] ,"\n") ;
	write("Poles", sf1->poles[3], sf1->poles[4], sf1->poles[5] ,"\n") ;
	write("Poles", sf1->poles[6], sf1->poles[7], sf1->poles[8] ,"\n") ;
	write("Poles", sf1->poles[9], sf1->poles[10], sf1->poles[11],"\n") ;
#endif

  	/* find the normal vector */
   	for(i=0; i<3; i=i+1){
		v1[i] = p0[i] - p1[i];
		v2[i] = p0[i] - p2[i];
   		}
   	BScrossp(&msg,v1,v2,vn);
   	BSnorvec(&msg,vn);
  
  	/* calculating side points */
  	/* nothing optimized */

   	BSnorvec(&msg,v1);
   	BScrossp(&msg,v1,vn,v2);
   	BSnorvec(&msg,v2);

   	for(i=0; i<3; i=i+1){
		p01[i] = p0[i] - v2[i]*ext_val;  
		p10[i] = p1[i] - v2[i]*ext_val;  
   		}

	for(i=0; i<3; i=i+1)
		v1[i] = p1[i] - p2[i];

   	BSnorvec(&msg,v1);
   	BScrossp(&msg,v1,vn,v2);
   	BSnorvec(&msg,v2);

   	for(i=0; i<3; i=i+1){
		p12[i] = p1[i] - v2[i]*ext_val;  
		p21[i] = p2[i] - v2[i]*ext_val;  
   		}

   	for(i=0; i<3; i=i+1)
		v1[i] = p2[i] - p3[i];
   	BSnorvec(&msg,v1);
   	BScrossp(&msg,v1,vn,v2);
   	BSnorvec(&msg,v2);

   	for(i=0; i<3; i=i+1){
		p23[i] = p2[i] - v2[i]*ext_val;  
		p32[i] = p3[i] - v2[i]*ext_val;  
   		}

   	for(i=0; i<3; i=i+1)
		v1[i] = p3[i] - p0[i];
	BSnorvec(&msg,v1);
   	BScrossp(&msg,v1,vn,v2);
   	BSnorvec(&msg,v2);

   	for(i=0; i<3; i=i+1){
		p30[i] = p3[i] - v2[i]*ext_val;  
		p03[i] = p0[i] - v2[i]*ext_val;  
   		}

   /* finding the intersection points, which become the new poles */
#ifdef DEBUG
	write("p01", p01[0], p01[1], p01[2] ,"\n") ;
	write("p10", p10[0], p10[1], p10[2] ,"\n") ;
	write("p03", p03[0], p03[1], p03[2] ,"\n") ;
	write("p30", p30[0], p30[1], p30[2] ,"\n") ;
#endif
    /* TR MP5244 */
    BSxln(&msg, p01, p10, p03, p30, &sf1->poles[0] );

    BSxln(&msg, p01, p10, p03, p30, &sf1->poles[0] );	

#ifdef DEBUG
	write("0-2 Poles", sf1->poles[0], sf1->poles[1], sf1->poles[2] ,"\n") ;
#endif

    BSxln(&msg, p01, p10, p12, p21, &sf1->poles[3] );
#ifdef DEBUG
	write("3-5 Poles", sf1->poles[3], sf1->poles[4], sf1->poles[5] ,"\n") ;
#endif
					// ACHTUNG 2 and 3 are inverted
    BSxln(&msg, p23, p32, p12, p21, &sf1->poles[9] );
#ifdef DEBUG
	write("9-11 Poles", sf1->poles[9], sf1->poles[10], sf1->poles[11],"\n") ;
#endif
    BSxln(&msg, p23, p32, p03, p30, &sf1->poles[6] );
#ifdef DEBUG
	write("6-8 Poles", sf1->poles[6], sf1->poles[7], sf1->poles[8] ,"\n") ;
#endif

    if( props & EMSIS_NRML_REVERSED ){
	dir = 1.0;
	#ifdef DEBUG
	printf(" normal reversed\n");
	#endif
    }
    else{
	dir = -1.0;
	#ifdef DEBUG
	printf(" normal NOT reversed\n");
	#endif
    }


   /* compute the offset poles */
   for(i=0; i<3; i=i+1){
	xx = dir * offs_val * vn[i];
	sf1->poles[i]   = sf1->poles[i]   + xx;
	sf1->poles[i+3] = sf1->poles[i+3] + xx;
	sf1->poles[i+6] = sf1->poles[i+6] + xx;
	sf1->poles[i+9] = sf1->poles[i+9] + xx;
	
   	}

#ifdef DEBUG
	write("New Poles", sf1->poles[0], sf1->poles[1], sf1->poles[2] ,"\n") ;
	write("New Poles", sf1->poles[3], sf1->poles[4], sf1->poles[5] ,"\n") ;
	write("New Poles", sf1->poles[6], sf1->poles[7], sf1->poles[8] ,"\n") ;
	write("New Poles", sf1->poles[9], sf1->poles[10], sf1->poles[11],"\n") ;
#endif

  #ifdef DEBUG
	write("enter EMSplane.GRconstruct\n");
  #endif

  stat = ci$send( msg = message EMSplane.GRconstruct(&cst), 
           targetid = GRid_list[0].objid,
           targetos = GRid_list[0].osnum );
  as$status( sts= stat );

  if( sf1 != NULL ) free(sf1);
  if( !(stat&1) ) GRid_list[0].objid = NULL_OBJID;

#ifdef DEBUG
	write("Success for particular case \n") ;
	write(" END function construct_pjs \n");
#endif

  return OM_S_SUCCESS ;
  } /* particular case */


wrapup : /* error case only */

  if( sf1 != NULL ) free(sf1);
  if( sf2 != NULL ){ BSfreesf(&msg,sf2); sf2 = NULL;}
  if( S_OFFSET.objid != NULL_OBJID )
	   stat = ci$send(	msg = message GRgraphics.GRdelete(
							&msg,
							&MOD_ENV ),
	  	 		targetid = S_OFFSET.objid,
	   	 		targetos = S_OFFSET.osnum );

  GRid_list[0].objid = NULL_OBJID;
#ifdef DEBUG
	write(" WRAPUP function construct_pjs \n");
#endif
  return OM_E_ABORT ;
} /* construct_pjs() */
