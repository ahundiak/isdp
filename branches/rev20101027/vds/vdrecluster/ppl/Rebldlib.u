/* $Id: Rebldlib.u,v 1.1.1.1 2001/01/04 21:09:06 cvs Exp $  */

/******************************************************************************
 * I/VDS
 *
 * File:        vds240/vdrecluster/ppl/Rebldlib.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: Rebldlib.u,v $
 *      Revision 1.1.1.1  2001/01/04 21:09:06  cvs
 *      Initial import to CVS
 *
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.3  1995/12/07  21:59:02  pinnacle
# Replaced: vdrecluster/ppl/Rebldlib.u for:  by jwfrosch for vds.240
#
# Revision 1.2  1995/12/06  23:15:58  pinnacle
# Replaced: vdrecluster/ppl/Rebldlib.u for:  by jwfrosch for vds.240
#
# Revision 1.1  1995/12/06  15:53:10  pinnacle
# Created: vdrecluster/ppl/Rebldlib.u by jwfrosch for vds.240
#
 *
 * History:
 *      MM/DD/YY      AUTHOR    DESCRIPTION
 *
 *	12/05/95	HF	Override of I/EMS Review Macro Library functionality
 *				in order to reduce the memory problems such as
 *				running out of swap space when many large libraries
 *				are attached.
 *
 ******************************************************************************/

/*
 *  For more comprehensive Info, see also VDreclust.hlp
 *  ===================================================
 *
 *  Utility to Recluster and Sort (optional) one or more Macro Libraries.
 *
 *  Usage: ci=Rebldlib [-v] [-c] [-i] [ [-sMACRO_NAME[*] ] or [-nINDEX_NUMBER] ]
 *
 *		-v			Verbose Output Printed
 *		-c			Continue processing if possible
 *		-i			Include Macro's with nested Nozzle's
 *		-sMACRO_NAME[*]		Skip MACRO_NAME[*]
 *		-nINDEX_NUMBER		Index == INDEX_NUMBER processed ONLY
 *
 *  Sorting Options :	0	Libraries will not be sorted
 *			1	Libraries will be sorted alphabetically
 *				(may not be possible if library contains
 *				 conditional macro's, because the
 *				 referenced macro's need to be first)
 *			2	Libraries will be grouped NOT sorted
 *				group	1 regular		unsorted
 *					2 ci_macros ...		unsorted
 *					3 conditional		unsorted
 *			3	Libraries will be grouped AND sorted
 *				group	1 regular		sorted
 *					2 ci_macros ...		sorted
 *					3 conditional		sorted
 */

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#ifndef	_SYS_TYPES_H
#	include <sys/types.h>
#endif
#ifndef _SYS_STAT_H
#	include <sys/stat.h>
#endif

#include "UNIXerrdef.h"

#include "cieveryone.h"
#include "cimacros.h"
#include "msdef.h"
#include "growner.h"
#include "FI.h"

#include "dp.h"
#include "msdef.h"
#include "exdef.h"
#include "godef.h"
#include "gr.h"
#include "igr.h"
#include "igrdp.h"
#include "griodef.h"
#include "go.h"
#include "ex.h"
#include "grio.h"

#include "DIdef.h"
#include "DItypedef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "exmacros.h"

/* The following lines prevent redefinition of superfluous constants */
#undef FI_ALPHA
#undef FI_INT
#undef FI_DOUBLE
#include "CIforms.h"

#define FRM_NAME	"VDreclstr"
#define FRM_LABEL	101
#define FRM_TEXT	 11

#define	 MAX_LIB_CHR	25
#define	 MAX_NUM_LIB	25
#define	 CLIX_FLNM_LNG	14

extern	int	printf(), sprintf(), strcmp(), tolower();
extern		UI_status();
extern	int	RebuildLib();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*			  External functions.					*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

extern	ci_notification();	/* The forms system automatically calls	*/
				/* this function, which in turn calls	*/
				/* your form_notification function	*/

extern	FIf_set_cmd_oid_os(),	/* This function tells the forms system */
				/* to notify this command file when the */
				/* user manipulates the form		*/
  FIf_new(),			/* Creates the form			*/
  FIf_display(),		/* Draws the form			*/
  FIf_erase(),			/* Erases the form			*/
  FIf_delete(),			/* Removes the form			*/
  FIf_reset(),
  FIg_set_text(),
  FIfld_get_num_rows(),
  FIfld_set_select(),
  FIfld_set_text(),
  FIfld_get_select(),
  FIfld_set_num_rows(),
  FIfld_get_text(),
  FIg_disable(),
  FIg_enable();
extern	FIf_collapse();

extern	int	EX_getpath();
extern	int	EX_inq_language();
extern		GRdisplay_object();
extern		stat();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*			  Global variables.					*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

int	first_time;	/* Set to TRUE in init() and used in main()
			   to prevent multiple execution of form_init() */
int	test_wakeup;	/* The wakeup function uses this flag to
			   test if the main function has started yet. */

int	not_done;	/* This value is set to 0 when the user
			   selects the cancel or exit & save buttons */

int	frm_exists,	/* The delete function uses this flag
			   to test if the form exists */
	frm_displayed;	/* The sleep function uses this flag
			   to test if the form is displayed */

Form frm;		/* Use this variable for the forms functions. */

struct CIform_st form_st; /* This structure contains information on
				which form and gadget was manipulated. */

struct mc_lib
{
  char		FrLib [MAX_LIB_CHR];
  char		ToLib [MAX_LIB_CHR];
};

void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  status ("");	/* Clear the status  field */
  message("");	/* Clear the message field */
  exit;
}

void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  char		relName[DI_PATH_MAX], absName[DI_PATH_MAX] ;
  int		sts, error, msg;

  strcpy ( relName, "VDreclust.hlp" );

  /*
   * Create (load) the form.
   */
  error = FIf_new ( FRM_LABEL, FRM_NAME, ci_notification, &frm );
  if ( frm == NULL )
  {
    printf( "Could not create form : <%s> ; Error code = %d\n", FRM_NAME, error);
    return_error();
  }

  frm_exists = TRUE;  /* Flag for delete function */

  /*
   * Tell the Forms System to notify this command
   * file when the user manipulates the form.
   */
  error = FIf_set_cmd_oid_os( frm, MY_ID, OM_Gw_current_OS );
  if ( error )
  {
    printf( "Could not link to the Forms System ; Error code = %d", error);
    frm_exists = FALSE;
    return_error();
  }

  sts = find_help_file ( &msg, relName, absName);

  if (sts != OM_S_SUCCESS || msg != MSSUCC )
  {
    if ( frm_displayed == TRUE )
    {
      FIf_reset ( frm );
      FIf_erase ( frm );
      frm_displayed = FALSE;
    }
  }
  else
  {
    /*
     * Display the "VDreclust.hlp" file in a FORM
     */

    display_help_file(absName);
  }

  /*
   * Display the form.
   */
  
  error = FIf_display( frm );
  if ( error )
  {
    printf( "Could not display the form ; Error code = %d", error);
    return_error();
  }

  frm_displayed = TRUE;  /* Flag for sleep function */
}

init()
{
  first_time = TRUE;
}

wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  /* Display the form unless the command file is just starting */
  if ( test_wakeup == 1 && not_done )
  {
    FIf_display ( frm );  /* Redisplay the form */
    frm_displayed = TRUE; /* Set flag for sleep function */
  }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( frm_displayed == TRUE )
  {
    FIf_erase ( frm );
    frm_displayed = FALSE;
  }
}

my_delete ()
/************************************************************
 * FUNCTION: my_delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
  /* Erase the form if it is displayed */

//    printf ( "Entering my_delete() : frm = %#x, frm_displayed = %d, frm_exists =%d\n",
//	   frm, frm_displayed, frm_exists );

  if ( frm_displayed == TRUE )
  {
    if ( frm ) FIf_erase ( frm );
    frm_displayed = FALSE;
  }

  /* Delete the form if it exists */
  if ( frm_exists )
  {
    if ( frm ) FIf_delete( frm );
    frm = NULL;
  }

  status ("");	/* Clear the status  field */
  message("");	/* Clear the message field */
  prompt ("");	/* Clear the prompt  field */

  ci$put ( response = TERMINATE );

//    exit;
}

/************************************************************
 * FUNCTION	: find_help_file()
 *
 * DESCRIPTION	: This function returns the absolute pathname
 *		  of the '.S' file (if it exists) of a Class.
 ************************************************************/

int find_help_file ( msg, relName, absName )

long	*msg ;
char	*relName, *absName ;
{
  int		i0, found_it, sts;
  char		dir[DI_PATH_MAX] ;
  struct stat	buffer ;

  *msg		= UNIX_E_ENOENT ;
  *absName	= '\0' ;
  found_it	= 0;

  for( i0 = 0 ; ; i0=i0+1 )
  {
    if( ! ex$get_path(	index	= i0,
			path	= dir,
			len	= sizeof( dir ) )
	  || ! *dir )
    {
      break ;
    }
    sprintf ( dir, "%sconfig/%s", dir, relName ) ;

    sts = stat( dir, &buffer );

//	printf ( "i0 = %d, sts = %d, st_mode = %#o, st_mode & S_IFMT = %#o, dir = <%s>\n",
//		i0, sts, buffer.st_mode, buffer.st_mode & S_IFMT, dir );

//	if( sts == 0 && (buffer.st_mode & S_IFMT) == S_IFREG)	// DOES NOT WORK ON SOLARIS !?!
    if( sts == 0 )
    {
      /*
       * Found it !
       */
      strcpy( absName, dir ) ;
      *msg = MSSUCC ;
      found_it = OM_S_SUCCESS;
      break ;
    }
  }
  return ( found_it );
}

/************************************************************
 * FUNCTION	: display_help_file()
 *
 * DESCRIPTION	: This function displays the text of a file
 *		  in a FORM
 ************************************************************/

display_help_file(HelpName)
char	*HelpName;
{
  FILE	*fp0;
  char	strng1[DI_PATH_MAX];
  int	i1;

  fp0 = fopen(HelpName, "r");
  FIf_reset ( frm );

  if ( fp0 != NULL )
  {
    i1 = 0;
    while ( fgets(strng1,sizeof strng1,fp0) )
    {
      FIfld_set_text(frm,FRM_TEXT,i1,0,strng1,FALSE);
      i1=i1+1;
    }
  }
  if ( fp0 ) fclose ( fp0 );
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  test_cancel_accept();
  ci$put( response = MOVE_ON );  /* Give control to the main function */
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

int test_cancel_accept( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  switch ( form_st.gadget_label )
  {
    case FI_CANCEL:

      my_delete();	/* This ends execution & erases form(s) */

      break;

    case FI_ACCEPT :

      if ( frm ) FIf_collapse ( frm );

      break;

    default:
      break;
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

main( argc, argv )
int	  argc;
char	**argv;
{
  int			i0, indx, sort;
  IGRlong		status;
  char			c, y_n, strng[80];

  char			Fr_Lib	[MAX_LIB_CHR];
  char			To_Lib	[MAX_LIB_CHR];

  struct mc_lib		macro_lib [MAX_NUM_LIB];

  int			verbose;
  int			proc_only;
  int			do_cntinue;
  int			skip_nstd_noz;
  int			append_to_lib;
  char			*mac_to_skp, tststr[3];
  FILE			*fp;

  message("Rebuild & Recluster Macro Libraries");

  verbose	=  0;
  proc_only	= -1;
  do_cntinue	=  0;
  skip_nstd_noz =  1;
  append_to_lib	=  0;
  mac_to_skp	= NULL;

  if ( first_time )
  {
    form_init();	/* Set up the form */
    first_time = FALSE;
  }

  if ( argc > 1 )
  {
    for ( i0 = 1; i0 < argc; i0 = i0+1 )
    {
      strncpy ( tststr, argv[i0], 2 );
      tststr[2] = '\0';

      if ( strcmp ( tststr, "-v" ) == 0 )
      {
	UI_status ("Verbose output will be generated");
	printf    ("Verbose output will be generated\n");
	verbose = 1;
      }
      else if ( strcmp ( tststr, "-c" ) == 0 )
      {
	UI_status ("Continue processing even if errors occur (if possible)");
	printf    ("Continue processing even if errors occur (if possible)\n");
	do_cntinue = 1;
      }
      else if ( strcmp ( tststr, "-i" ) == 0 )
      {
	UI_status ("Macro's with nested Nozzle's will be processed");
	printf    ("Macro's with nested Nozzle's will be processed\n");
	skip_nstd_noz = FALSE;
      }
      else if ( strcmp ( tststr, "-s" ) == 0 )
      {
	mac_to_skp = &argv[i0][2];
	if ( strlen ( mac_to_skp ) > 0 )
	{
	  if ( mac_to_skp [ strlen ( mac_to_skp ) - 1 ] == '*' )
	  {
	      printf ("Macro's <%s> will be skipped\n", mac_to_skp );
	  }
	  else
	  {
	    printf ("Macro <%s> will be skipped\n", mac_to_skp );
	  }
	}
	else
	{
	  mac_to_skp = NULL;
	}
      }
      else if ( strcmp ( tststr, "-n" ) == 0 )
      {
	if ( argv[i0][2] != '\0' )
	{
	  proc_only = atoi ( &argv[i0][2] );
	}
	if ( proc_only >= 0 )
	{
	  printf ("Only index [%d] will be processed\n", proc_only );
	}
      }
      else
      {
	printf ( "Invalid argument: <%s>\n", tststr );
	printf ( "usage: ci=%s [-v] [-c] [-i] [ [-sMACRO_NAME[*] ] or [-nINDEX_NUMBER] ]\n", argv[0] );
      }
    }
  }

  sort = 0;		/* Libraries will NOT be sorted */

  ci$get ( prompt = "Sort libraries (0/1/2/3) [0] ?", char = y_n );

  test_cancel_accept();

//  if ( ( c = tolower (y_n) ) == 'n' )

  if ( y_n == '1' )
  {
    sort = 1;
    UI_status	( "Libraries will be sorted alphabetically" );
    printf	( "Libraries will be sorted alphabetically\n" );
  }
  else if ( y_n == '2' )
  {
    sort = 2;
    UI_status	( "Libraries will be grouped NOT sorted alphabetically" );
    printf	( "Libraries will be grouped NOT sorted alphabetically\n" );
  }
  else if ( y_n == '3' )
  {
    sort = 3;
    UI_status	( "Libraries will be grouped AND sorted alphabetically" );
    printf	( "Libraries will be grouped AND sorted alphabetically\n" );
  }
  else
  {
    sort = 0;
    UI_status	( "Libraries will not be sorted" );
    printf	( "Libraries will not be sorted\n" );
  }

  indx = 0;
  while ( indx < MAX_NUM_LIB )
  {
    Fr_Lib [0] = '\0';
    To_Lib [0] = '\0';

    sprintf ( strng, "Library # %d to rebuild ?", indx+1 );

    ci$get ( prompt = strng, string = Fr_Lib);
    test_cancel_accept();

    if ( Fr_Lib [0] == '\0' )
    {
      break;
    }

    if ( strlen ( Fr_Lib ) > CLIX_FLNM_LNG )
    {
      Fr_Lib[CLIX_FLNM_LNG] = '\0';
    }

    strcpy ( To_Lib, Fr_Lib);
    strcat ( To_Lib, "~" );

    if ( strlen ( To_Lib ) > CLIX_FLNM_LNG )
    {
      To_Lib[CLIX_FLNM_LNG-1] = '~';
      To_Lib[CLIX_FLNM_LNG  ] = '\0';
    }

    if ( strcmp( Fr_Lib, To_Lib ) == 0 )
    {
      if ( To_Lib [ strlen ( To_Lib ) - 1 ] == '~' )
      {
	To_Lib [ strlen ( To_Lib ) - 1 ] = '_';
      }
      else
      {
	To_Lib [ strlen ( To_Lib ) - 1 ] = '~';
      }
    }

    append_to_lib =  0;

    fp = fopen ( To_Lib, "r" );
    if ( fp )
    {
      fclose ( fp );

      sprintf ( strng, "Library[%2d] <%s> already exists", indx+1, To_Lib);
      UI_status ( strng );
      printf ( "%s\n", strng );

      ci$get ( prompt = "Overwrite/Append to Library (O/A) [O] ?", char = y_n );
      test_cancel_accept();

      if ( ( c = tolower (y_n) ) == 'a' )
      {
	append_to_lib = TRUE;

	sprintf ( strng, "Library[%2d] <%s> will be appended to", indx+1, To_Lib);
	goto app;
      }
    }

    sprintf ( strng, "Library[%2d] <%s> will be rebuilt as <%s>", indx+1, Fr_Lib, To_Lib);
app:
    UI_status ( strng );
    printf ( "%s\n", strng );

    strcpy ( macro_lib[indx].FrLib, Fr_Lib );
    strcpy ( macro_lib[indx].ToLib, To_Lib );

    indx = indx + 1;
  }

  for ( i0 = 0; i0 < indx; i0 = i0+1 )
  {
    status = RebuildLib (	macro_lib[i0].FrLib,
				macro_lib[i0].ToLib,
				sort,
				verbose,
				proc_only,
				do_cntinue,
				skip_nstd_noz,
				append_to_lib,
				mac_to_skp );
    if ( status <= 0 )
    {
      exit;
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
