/* $Id: VDclean_ndn.u,v 1.1 2001/01/18 20:41:04 hans Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	VDclean_ndn.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDclean_ndn.u,v $
 *	Revision 1.1  2001/01/18 20:41:04  hans
 *	SP16 additions/modifications
 *	
# Revision 1.1  2000/08/30  21:32:44  pinnacle
# Created: vds/vdppl/VDclean_ndn.u by jwfrosch for Service Pack
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	08/29/2000	HF		Creation date
 *
 * -------------------------------------------------------------------*/

/*
 * PPL VDclean_ndn.u
 *
 * This PPL provides a very fast function to find & delete ALL NDnode objects
 * in the specified object space (no locate required !!!).
 *
 * Usage: "ci=VDclean_ndn"
 */

#include <stdio.h>
#include <cieveryone.h>
#include <cimacros.h>
#include "OMindex.h"
#include "OMmacros.h"
#include "VDppl.h"
#include "VDobj.h"

extern VDpms_find_objects();
extern GRdpb_get();

extern int       VDcomment;
extern GRclassid OPP_NDnode_class_id;

main()
{
  int		        cnt, del_count, sts, max_entry, sz;
  IGRuint               max;

  struct GRmd_env       ModuleInfo;
  struct GRobj_env      objOE;

  OM_S_OBJID	        oid;
  OM_p_OSD	        p_OSD;		/* Ptr to object space descriptor */
  OM_p_SPAMAPENT        p_spamap;	/* Ptr to space map entry	 */
  OM_p_OBJECTHDR        p_objhdr;

  p_objhdr = NULL;

  message ( "Delete all zero-sized NDnode objects" );

  sts = VDpms_find_objects ( 2, OPP_NDnode_class_id, &cnt, NULL );

  printf ( "\nVDpms_find_objects() : sts = %d, Number of NDnode objects = %d\n", sts, cnt );

  ci$get_module_info ( md_env = &ModuleInfo );
  gr$get_module_env  ( buffer = &objOE.mod_env);

  objOE.obj_id.osnum = objOE.mod_env.md_id.osnum;

  max       = OM_GA_OSDs[objOE.mod_env.md_id.osnum]->CurSpaceMapSize;
  p_OSD     = OM_GA_OSDs[objOE.mod_env.md_id.osnum];
  max_entry = p_OSD->CurSpaceMapSize;
  p_spamap  = p_OSD->Spacemap;

  for ( oid=0; (int) oid < max_entry;  oid = oid+1 )
  {
    if ( (p_spamap->flags != 0) && (p_spamap->p_acld != NULL) )
    {
      p_objhdr = p_spamap->state.object;

      if ( !(p_spamap->flags & OM_SM_unknown_obj) && p_spamap->p_acld->w_classid == OPP_NDnode_class_id )
      {
        sz = OM_GETOBJSIZE(p_objhdr->i_size);
        //if (VDcomment)
        {
          printf("Size of NDnode object: [%d,%d] = %d",objOE.obj_id.osnum, oid, sz);
        }
        //if ( sz == 0 )
        {
          sts =
            ci$send(msg      = message NDnode.NDdelete(&ModuleInfo),
                    targetos = objOE.obj_id.osnum,
                    targetid = oid);

          //if (VDcomment && sz == 0)
          {
            printf("  Deleting object: sts = %#x", sts);
          }
          del_count = del_count+1;
        }
        //if (VDcomment)
        {
          printf("\n");
        }

      }
    }
    p_spamap = p_spamap+1;
  }
  printf ( "\nNumber of NDnode objects = %d, # of deleted objects = %d\n", cnt, del_count );
}
