/* $Id: COz_rvRefLib.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:	vdppl/COz_rvRefLib.u
 *
 * Description:
 *		Review macro library attachments in active and reference 
 *		files.
 *
 * Dependencies:
 *		super_para.wake_up method.
 *
 * Revision History:
 *	$Log: COz_rvRefLib.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1996/01/09  20:06:00  pinnacle
# Replaced: ./vdppl/COz_rvRefLib.u for:  by azuurhou for vds.240
#
# Revision 1.1  1995/07/11  20:14:02  pinnacle
# Created: vdppl/COz_rvRefLib.u by azuurhou for vds.240
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	07/08/95	adz		creation date
 *	01/09/95	adz		Adapted to created methods in super_para
 *
 ***************************************************************************/

#include <stdio.h>
#include <string.h>
#include "OMerrordef.h"
#include "OMminimum.h"
#include "OMprimitives.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "igrtypedef.h"
#include "igetypedef.h"
#include "exdef.h"
#include "exmacros.h" 
#include "exproto.h"
#include "FI.h"
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "msmacros.h"
#include "acdef.h"
#include "acmacros.h"
#include "macro.h"
#include "vdrefmacros.h"

#define VD_MAX_RefLibInfo       100
#define VD_MAX_RefLibBuff       1024

struct  VD_s_RefLibInfo{
        GRspacenum      osnum ;
        IGRchar         buffer[VD_MAX_RefLibBuff];
} ;

struct  VD_s_RefLibInfo VDflInfo[VD_MAX_RefLibInfo];
IGRint                  VDflCount ;

extern  char    *strrchr(),
                *strchr();
extern	void	free();

extern	int	EX_get_super(),
		EX_get_modid_given_osnum(),
		VDget_ref_os_list();

/*****************************************************************************/

lib_get_info( info )

struct	VD_s_RefLibInfo		**info ;
{
IGRlong		msg ;
IGRint		sts ;
IGRint		i,
		size,
		osCnt ;
GRspacenum	*osList; 
struct	GRmd_env MOD_ENV ;
struct	GRid	superId,
		superMod ;

#ifdef	DEBUG
	printf(" START lib_get_info \n" );
#endif

	/*
	 * Check object space about current situation.
	 */
	*info		= NULL ;
	VDflCount	= 0 ;

	osList		= NULL ;
	osCnt		= 0 ;

	for( i=0 ; i<VD_MAX_RefLibInfo ; i=i+1 ){
		VDflInfo[i].osnum = 0 ;
		VDflInfo[i].buffer[0] = '\0';
	}

#ifdef  DEBUG
	printf(" Get vd$get_ref_os_list \n");
#endif
	ci$get_module_info( md_env = &MOD_ENV );

	sts =
	vd$get_ref_os_list(	msg		= &msg ,
				main_os		= &MOD_ENV.md_id.osnum,
				num_ref_os	= &osCnt,
				ref_os_list	= &osList );
	if( !(sts&1) ){ goto wrapup ; };

	if( osCnt == 0 ){
#ifdef	DEBUG
	  printf(" No Reference Files Found\n");
#endif
	  UI_status(" No Reference Files Found ");
	  return FALSE ;
	}
	  
#ifdef	DEBUG
	printf(" # ObjectSpace: %d\n", osCnt );
#endif

	for( i=0 ; i<osCnt ; i=i+1 ){

#ifdef	DEBUG
	  printf(" Objectspace[%d/%d]: %d\n", i, osCnt, osList[i] );
#endif

	  superMod.objid = NULL_OBJID ;
	  superMod.osnum = osList[i]  ;
	  sts =
	  ex$get_modid(	mod_osnum	= superMod.osnum,
			mod_id		= &superMod.objid );

	  superId.objid = NULL_OBJID ;
	  sts =
	  ex$get_super(		create		= 0,
				mod_id		= superMod.objid,
				mod_osnum	= superMod.osnum,
				super_name	= "super_para",
				super_class	= "super_para",
				super_id	= &(superId.objid),
				super_osnum	= &(superId.osnum) );
	  if( sts&1 ){

#ifdef	DEBUG
	    printf(" superId : %d,%d\n", superId.osnum, superId.objid );
#endif
	    sts =
	    ci$send(msg = message super_para.give_path_size( &size ),
		    targetid = superId.objid,
		    targetos = superId.osnum );
	    if( sts&1 || size < VD_MAX_RefLibBuff ){

	      if( VDflCount < VD_MAX_RefLibInfo ){
		VDflInfo[VDflCount].osnum	= superId.osnum ;
	        sts =
		ci$send(msg = message super_para.give_path(
					VDflInfo[VDflCount].buffer ),
			targetid = superId.objid,
			targetos = superId.osnum );
		if( sts&1 ){
#ifdef	DEBUG
		  printf(" [%d]: %s\n", VDflCount,VDflInfo[VDflCount].buffer);
#endif
		  VDflCount = VDflCount +1 ;
		}
	      }
	      else{
#ifdef	DEBUG
		printf("Max Reference Checking List ");
#endif
	        break ;
	      }
	    }
	  }
	}

#ifdef	DEBUG
	printf(" END lib_get_info \n" );
#endif

wrapup:
	
	*info	= VDflInfo ;
	if( osList ) free( osList );
	return FALSE ;
}

/*****************************************************************************/

lib_review_info()
{
	IGRint			i, cnt, sts;
	IGRchar			pathName[1024];
	IGRchar 		*c,*c1;
	extern OM_p_OSD		*OM_GA_OSDs;
	struct	VD_s_RefLibInfo	*info ;

	info = NULL ;
	lib_get_info( &info );
	if( info == NULL ) return FALSE ;

	printf("\n\n");

	for( i=0 ; i<VDflCount && i<VD_MAX_RefLibInfo; i=i+1 ){

	  if( info[i].osnum != 0 ){

	    /*
	     * Check if the object space is active.
	     */
	    if( OM_GA_OSDs[ info[i].osnum ] ){

		di$give_pathname(	osnum	= info[i].osnum,
					pathname = pathName );

		printf("\n*************************************************\n");
		printf("  Reference filename : %s\n\n", pathName );

		c = info[i].buffer ;

		cnt = 0 ;
	        while( TRUE ){
		  c1 = NULL ;
		  c1 = strchr( c, ',');
		  if( c1 != NULL ) *c1 = '\0';
	
		  cnt = cnt + 1 ;
		  printf("\t%d :\t%s\n", cnt, c );

		  if( c1 == NULL ) break;
		  c = c1+1;
		  *c1 = ',';
	        }
	    }
	  }
	}

	return TRUE ;
}

/*****************************************************************************/

main()
{
int			status;
long			msg;

	/*
	 * Get the number of files attached.
	 */

	UI_message(" Review Reference File Libraries ");

	status = lib_review_info();

	UI_echo( "" );

}

