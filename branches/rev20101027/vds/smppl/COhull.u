/* $Id: COhull.u,v 1.1.1.1 2001/01/04 21:07:36 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/smppl / COhull.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COhull.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:36  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

#include "ciminimum.h"
#include "cimacros.h"
#include "cieveryone.h"
#include "growner.h"
#include "nddef.h"
#include "macro.h"
#include "ACattrib.h"
#include "ACrg_collect.h"
#include "emsmass.h"
#include "asbox.h"
#include "AS_status.h"
#include "msdef.h"
#include "SMdef.h"
#include "SMmacros.h"

#include "SMcomp_def.h"

#define		MAX_TEMP 10

struct GRid 	TEMP[MAX_TEMP];
GRobj 		MAC1;
IGRshort        num_ent;
IGRint 		suc;
IGRchar         txt[40];
struct GRmd_env	MOD_ENV;
IGRchar		mes_f[80];
struct GRid	  mac, mac_col, temp[3*MAX_TEMP+2];
struct ACrg_coll  my_att, crit;
int 		  i, k, msg, sts;
char		  name[80], att_value[20], tpipo[81];
int		  cmp_props, dw, grp, omit;

struct GRid	  CompDynCol;	   
int		  NbRoots, nb_temps;
struct GRid	  CompDynRoots[10];
char		  tmp[23 * MAX_TEMP], pipo[81];
char		  *exclude[MAX_TEMP];
IGRshort	  type;
struct SMObjList  dw_list;


extern free(), ASmake_source_from_env(), printf(), SMCompMacDef(), ASsuper_construct();
extern int SMCompInitCol(), VDSSetAttTxt(), VDSSetAttDbl();
extern int SMCritSel();



main()
{
 strcpy(mes_f,"Compartment Hull Creation");
 message(mes_f);

 ASsuper_construct();
 SMCompMacDef();

 for(i=0; i<MAX_TEMP; i=i+1) exclude[i] = &tmp[21 * i];

 while(1)
  {
   num_ent = 0;
   message(mes_f);

step0:

   while(1)
   {
     strcpy(txt,"Identify a volume");
     strcat(txt,itoa(num_ent + 1));

     if(!ci$locate( prompt       = txt,
		    classes      = "GRgraphics",
                    properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                    owner_action = LC_RIGID_COMP
                                    | LC_RIGID_OWNER | LC_FLEX_COMP
                                    | LC_FLEX_OWNER  | LC_REF_OBJECTS,
	            obj          = &(TEMP[num_ent].objid),
                    osnum        = &(TEMP[num_ent].osnum),
		    md_env       = &MOD_ENV ) ) break;

     ASmake_source_from_env( &TEMP[num_ent],&MOD_ENV,&TEMP[num_ent] );	

     pipo[0] = '\n';
     ci$get(prompt = "exclude y/n [n]",
        string = pipo,
        rc     = sts);
     if(pipo[0] == '\0') 		       strcpy(exclude[num_ent], "n"); 
     else if(pipo[0] == 'y' || pipo[0] == 'Y') strcpy(exclude[num_ent], "y");
     else 				       strcpy(exclude[num_ent], "n");

     num_ent = num_ent + 1;
     if( num_ent > MAX_TEMP )
     {
	status(" number of located objects <= 30 ");
        goto step0;
     }
   }

 if( num_ent == 0 ) exit;

 ci$get_module_info(md_env = &MOD_ENV);
 /* Create static and dynamic collections */

 if(SMCompInitCol(&CompDynCol, num_ent, CompDynRoots, &MOD_ENV) == 0)
   {
    printf("Error SMCompInitCol for comp\n");
    exit;
   }

 /* Update exclude in the corresponding coll */
 for(i=0; i<num_ent; i=i+1)
  {
   if(VDSSetAttTxt(&CompDynRoots[i], "exclude", exclude[i], 1) != 1)
    {
     printf("Erreur updating exclude index: %d, exclude: %s\n", i, exclude[i]); 
    }
  }
 /* create the SMcomp */
 mac.objid = NULL_OBJID;
 mac.osnum = MOD_ENV.md_id.osnum;

 temp[0] = CompDynCol;

 k = 3;
 for(i=0;i<num_ent;i=i+1)
  {
   temp[k] = CompDynRoots[i] ; 
   k = k+1;
   temp[k] = TEMP[i]      ; 
   k = k+1;
  }
 nb_temps = k;

 /* Ask if the compartment is omit or not */
 omit = 0;
 ci$get(prompt = "BCALC computation (y/n) [Y]",
        string = tpipo,
        rc     = sts);
 if(sts != 1) omit = 0;
 else if(tpipo[0] == 'n' || tpipo[0] == 'N') omit = 1;

 if(omit == 1)
  {
   if(VDSSetAttTxt(&CompDynCol, "cal_inc", "no", 1) != 1)
    {
     printf("Erreur updating omit flag: %d\n", (int) omit); 
    }
  }

 /* Ask if the hull type */
 omit = 0;
 ci$get(prompt = "Keyin hull type (STA, STR, BONJ, SUBD, GRN) [STA]",
        string = tpipo,
        rc     = sts);
 if(sts != 1) strcpy(tpipo,"STA");

 if(VDSSetAttTxt(&CompDynCol, "h_type", tpipo, 1) != 1)
    {
     printf("Erreur updating hull sub type: %s\n", tpipo); 
    }

 /* Set the type to hull */
 if(VDSSetAttDbl(&CompDynCol, "type", (IGRdouble) SM_HULL, 1) != 1)
  {
   printf("Erreur updating hull type flag\n"); 
  }

 /* Get the HULL dead weight */
 strcpy(crit.name, "name");
 crit.desc.type = AC_ATTRIB_TEXT;
 strcpy(crit.desc.value.att_txt,"HULL");
 sts = SM$CritSel(msg 	  = &msg, 
 		  options = 0,
 		  type	  = SM_DW,
		  nb_crit = 1,
		  crit    = &crit,
	    	  list	  = &dw_list);
 if(!(sts & 1) || msg != MSSUCC) { printf("booum\n"); exit; }
 if(dw_list.nb_objects <= 0) 
  { 
   printf("No corresponding dead weight found\n");
   exit;
  }
 ASmake_source_from_env(&dw_list.list[0].obj_id, &dw_list.list[0].mod_env, &temp[1]);
 free(dw_list.list);

 /* Get the HULL group name */
 strcpy(crit.name, "name");
 crit.desc.type = AC_ATTRIB_TEXT;
 strcpy(crit.desc.value.att_txt, "HULL");
 sts = SM$CritSel(msg 	  = &msg, 
 		  options = 0,
 		  type	  = SM_GRP,
		  nb_crit = 1,
		  crit    = &crit,
	    	  list	  = &dw_list);
 if(!(sts & 1) || msg != MSSUCC) { printf("booum\n"); exit; }
 if(dw_list.nb_objects <= 0) 
  { 
   printf("No corresponding dead weight found\n");
   exit;
  }
 ASmake_source_from_env(&dw_list.list[0].obj_id, &dw_list.list[0].mod_env, &temp[2]);
 free(dw_list.list);

 /* ASK THE SUB_GROUP .... */

/*#define SM_CMP_DSP_CMP_COG_PT           0x0001   
/*#define SM_CMP_DSP_CMP_COG_NAME         0x0002   
/*#define SM_CMP_DSP_RT_COG_PT            0x0100  
/*#define SM_CMP_DSP_RT_COG_NAME          0x0200  
/*
/*#define SM_CMP_CAL_VOLS                 0x1000  
/*#define SM_CMP_VRF_OVER                 0x2000  
/*
/*#define SM_CMP_X_POS                    0x0010  
/*#define SM_CMP_X_NEG                    0x0020  
/*#define SM_CMP_Y_POS                    0x0040  
/*#define SM_CMP_Y_NEG                    0x0080  
/**/

 pipo[0]   = '\0';
 cmp_props = 0;
 ci$get(prompt = "Display hull cog pt [y]",
        string = pipo,
        rc     = sts);
 if(sts != 1 || pipo[0] == '\0' || pipo[0] != 'n') 
		cmp_props = cmp_props |  SM_CMP_DSP_CMP_COG_PT;

 ci$get(prompt = "Display hull cog name [y]",
        string = pipo,
        rc     = sts);
 if(sts != 1 || pipo[0] == '\0' || pipo[0] != 'n') 
		cmp_props = cmp_props |  SM_CMP_DSP_CMP_COG_NAME;

 ci$get(prompt = "Display volume hull cog pts [n]",
        string = pipo,
        rc     = sts);
 if(sts == 1 && pipo[0] != '\0' && pipo[0] == 'y')
		cmp_props = cmp_props |  SM_CMP_DSP_RT_COG_PT;

 ci$get(prompt = "Display volume hull cog names [n]",
        string = pipo,
        rc     = sts);
 if(sts == 1 && pipo[0] != '\0' && pipo[0] == 'y') 
		cmp_props = cmp_props |  SM_CMP_DSP_RT_COG_NAME;

 ci$get(prompt = "Compute volume hull [n]",
        string = pipo,
        rc     = sts);
 if(sts == 1 && pipo[0] != '\0' && pipo[0] == 'y') 
		cmp_props = cmp_props | SM_CMP_CAL_VOLS;

 ci$get(prompt = "Verify overlapping hull [n]",
        string = pipo,
        rc     = sts);
 if(sts == 1 && pipo[0] != '\0' && pipo[0] == 'y') 
		cmp_props = cmp_props | SM_CMP_VRF_OVER;

 cmp_props = cmp_props | SM_CMP_X_POS;

// printf("properties: %x\n", cmp_props);

 if(VDSSetAttDbl(&CompDynCol, "cmp_props", (double) cmp_props, 1) != 1)
    {
     printf("Erreur updating properties: %d\n", (int) cmp_props); 
    }

 name[0] = '\0';
 ci$get(prompt = "Keyin the hull name",
        string = name,
        rc     = sts);
 if(sts == 1 && name[0] != '\0')
  {
   if(VDSSetAttTxt(&CompDynCol, "name", name, 1) != 1)
    {
     printf("Erreur updating name: %s\n", name); 
    }
  }
 else   name[0] = '\0';

 /* for(i=0;i<nb_temps;i=i+1) printf("temp: %d, %d\n", temp[i].objid, temp[i].osnum); */
 sts = ci$send( msg = message SMcomp.ACmplace(&suc, AChdr_nodisplay,
 				0, "SMcomp", nb_temps, temp, &MOD_ENV),
			targetid = mac.objid,
			targetos = mac.osnum);
 as$status( sts = sts );
// printf("sts: %d, suc: %d\n", sts, suc);

 if( suc == 0 )
  {
		write("placement of the compartment_macro \"SMcomp\" failed\n");
		status("placement of nci_macro \"SMcomp\" failed");
      		ci$send(msg = message Root.delete(0),
	      		targetid = mac.objid,
	      		targetos = mac.osnum );
    break;
   }

// printf("macro created: %d, %d\n", mac.objid, mac.osnum);

 /* Set the symbology to the dead weight path def */
 sts = ci$send(msg = message SMcomp.SMSetDwSymb(&msg),
                        targetid = mac.objid,
                        targetos = mac.osnum);
 as$status(sts = sts);

 if(name[0] != '\0')
  {
   sts = ci$send(msg = message GRvg.GRputname(&msg, name),
                        targetid = mac.objid,
                        targetos = mac.osnum);
   as$status(sts = sts);
  }
 }
}


wakeup(){
	message(mes_f);
}

