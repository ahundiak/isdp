/* $Id: COpenMod.u,v 1.6 2001/10/16 13:51:44 ylong Exp $  */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:        vds/vdpen/ppl/COpenMod.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COpenMod.u,v $
 *      Revision 1.6  2001/10/16 13:51:44  ylong
 *      Replace built-in lists with vds/config/penetrations/DataList
 *
 *      Revision 1.5  2001/10/11 15:36:26  ylong
 *      TR5493
 *
 *      Revision 1.4  2001/05/12 22:10:40  ylong
 *      *** empty log message ***
 *
 *      Revision 1.3  2001/05/09 19:56:29  ylong
 *      *** empty log message ***
 *
 *      Revision 1.2  2001/01/19 22:31:03  jayadev
 *      *** empty log message ***
 *
# Revision 1.11  2000/11/03  22:22:48  pinnacle
# small fix
#
# Revision 1.10  2000/10/31  14:08:44  pinnacle
# CR179901844
#
# Revision 1.9  2000/09/13  15:15:54  pinnacle
# (No comment)
#
# Revision 1.8  2000/07/17  22:07:56  pinnacle
# misc fixes
#
# Revision 1.6  2000/06/23  18:16:24  pinnacle
# ylong
#
# Revision 1.2  2000/06/06  15:44:18  pinnacle
# ylong
#
# Revision 1.12  2000/03/01  23:02:30  pinnacle
# ylong
#
# Revision 1.11  1999/12/29  16:41:46  pinnacle
# added F as a prefix of coord
#
# Revision 1.10  1999/12/06  16:06:00  pinnacle
# ylong
#
# Revision 1.9  1999/12/01  22:52:50  pinnacle
# TR179900968/TR179900969
#
# Revision 1.8  1999/12/01  16:15:26  pinnacle
# type truncate and RUN btn
#
# Revision 1.6  1999/09/14  13:47:20  pinnacle
# ylong
#
# Revision 1.5  1999/05/31  20:21:00  pinnacle
# ylong
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/25/99        ylong           TR179900583
 *      05/31/99        ylong           TR179900636
 *      09/13/99        ylong           TR179900857
 *      11/30/99        ylong           CR179900966
 *	12/01/99	ylong		TR179900968/TR179900969
 *	12/06/99	ylong		truncate "Struct to Cut" to 5
 *      12/29/99        ylong           added F as one of allowed prefixes of 
 *                                      coord name
 *      03/01/00        ylong           hide penMacro & pcgMacro in SHAPE field
 *      06/05/00        ylong           CR179901629
 * -------------------------------------------------------------------*/
/************************************************************
 * FILE:  Pen.u
 * PURPOSE:  This PPL command will modify a penetration macro 
 *		on a coordinate system
 *
 * DESCRIPTION: This command file controls a form that lets
 *    	the user select many options and places a macro on it
 *
 * NOTE:
 *
 ************************************************************/

#include "FI.h"       /* Forms Include File */

#include "VDppl.h"
#include "VDgeom.h"
#include "VDefp.h"
#include "VDmem_ppl.h"
#include "VDobj.h"
#include "VDSudp_mac.h"
#include "vdAPImacros.h"
#include "vdrefmacros.h"

#include "ci_mac_def.h"
#include "VDsa.h"
#include "vdsmacros.h"

/*
#define  DEBUG   1
#define  vdsDEBUG   1
*/
#include "v_dbgmacros.h"

/************************************************************
  Constants for the form.
 ************************************************************/
#define FORM_LABEL 100  /* Arbitrary Number for Form */
#define FORM_NAME  "VDpen.frm"  /* Form File */
#define TITLE_STRING "Modify Penetration"

#define ACCEPT			1
#define RUN			2
#define RE_SET			3
#define CANCEL			4
#define FORM_TITLE		11
#define NAME_FIELD		12
#define REV			13
#define MAC_LIB 		15
#define EXPRESSIONS		14
#define TYPE			19
#define LA			20
#define SHAPE			21
#define COMP_FIELD		27
#define STRUCT_CUT		28
#define DESCRIPTION_FIELD	30
#define COMP_BTN		32
#define NAME_BTN 		33
#define OBJ_FIT_BTN		17

#define MAX_TEMPS		100

#define PLACE_PEN		0
#define MODIFY_PEN		1
#define PLACE_PCG		2
#define MODIFY_PCGP		3


/************************************************************
  External functions.
 ************************************************************/
extern ci_notification();  /* The forms system automatically calls    */
                           /* this function, which in turn calls your */
                           /* form_notification function              */

extern FIf_set_cmd_oid_os();  /* This function tells the forms system */
                              /* to notify this command file when the */
                              /* user manipulates the form */

extern FIf_new();        /* Creates the form              */
extern FIf_display();    /* Draws the form                */
extern FIf_erase();      /* Erases the form               */
extern FIf_delete();     /* Removes the form              */
extern FIg_get_value();  /* Retrieves values from gadgets */
extern int FIg_display ();
extern int FIg_erase ();
extern int FIf_reset ();
extern int FIfld_set_text ();
extern int FIfld_get_text ();
extern int FIg_set_text ();
extern int FIg_set_state_on();
extern int FIg_set_state_off();
extern int FIg_enable();
extern int FIg_disable();
extern int GRdpb_get();
extern int ASmake_source_from_env();
extern int FIfld_set_list_num_rows();
extern int FIfld_set_num_rows();
extern int FIfld_get_num_rows();
extern int FIfld_set_mode();
extern int FIfld_set_list_default_text();
extern int EX_filename1();
extern int toupper();
extern int FIfld_pos_cursor();
extern int FIfld_get_list_text();

extern int FIg_reset();
extern VDpms_findall_ancestryobjects();
extern EX_findmod();
extern GRdisplay_object();
extern VDpenFormFillInCoordNames();
extern VDpenFormFillInObjNames();
extern VDpenFormSetList();

extern int VDGetGridsFromChan_of_Class();
extern GRclassid OPP_ACconst_class_id;
extern GRclassid OPP_ASsource_class_id;
extern VDclassid OPP_nci_macro_class_id;

/************************************************************
  Global variables.
 ************************************************************/
int test_wakeup;  /* The wakeup function uses this flag to
                     test if the main function has started yet. */

int form_exists,    /* The delete function uses this flag
                       to test if the form exists */
    form_displayed, /* The sleep function uses this flag
                       to test if the form is displayed */
    not_done;       /* This value is set to 0 when the user
                       selects the cancel or exit & save buttons */

Form form;  /* Use this variable for the forms functions. */

struct CIform_st form_st; /* This structure contains information on
                             which form and gadget was manipulated. */

struct ACrg_coll  collAttrs[50];
struct GRid	itemColGRid;
struct GRid	dataColGRid;
struct GRid	GRIDS[3];

IGRchar	anoString[80];
IGRchar	tmpString[80]; 
IGRchar	descriptionString[80]; 
IGRchar	commentString[80];
IGRint	num_exps;
IGRdouble exps[MAX_TEMPS];
IGRint	num_temps;
struct GRid Templates[MAX_TEMPS];

IGRchar	formStr[40];
IGRchar	descStr[1024];
IGRchar	revStr[80];
IGRchar	typeStr[80];
IGRchar	shapeStr[80];
IGRchar	laStr[80];
IGRchar	structStr[80];
IGRchar	macStr[128];
IGRchar	compStr[128];
IGRchar	csName[128];
IGRchar	penName[128];
IGRchar	oldName[128];
struct GRid	CoordID;
struct GRid	NEW_MAC;
struct GRid	OldCoord,
		NewCoord,
		TEMPS[3],
		OldPret,
		NewPret;
int	notlocal;


void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  status("");   /* Clear the status field  */
  message("");  /* Clear the message field */
  exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  int error;

 /*************************
   Create (load) the form.
  *************************/
  //printf("about to FIf_new Form name[%s]\n",FORM_NAME);
  error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &form );
  if ( form == NULL ) 
    {
      write( "Could not create the form.\n",
             "Error code = ",  error,  "\n"  );
      return_error();
    }

  form_exists = TRUE;  /* Flag for delete function */

 /**********************************************
   Tell the Forms System to notify this command
   file when the user manipulates the form.
  **********************************************/
  error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
  if ( error )
    {
      write( "Could not link to the Forms System.\n",
             "Error code = ",    error,         "\n"  );
      form_exists = FALSE;
      return_error();
    }

  /* Set the title on the form */
  FIg_set_text( form, FORM_TITLE, formStr);
  FIg_set_text(form, NAME_BTN, "Locate Pen");
 
 /*******************
   Display the form.
  *******************/
  
  error = FIf_display( form );
  if ( error )
    {
      write( "Could not display the form.\n",
             "Error code = ",  error,   "\n"  );
      return_error();
    }
  form_displayed = TRUE;  /* Flag for sleep function */
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  char outString[80];
  
  ci$put( response = MOVE_ON );  /* Give control to the main function */
}


wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  /* Display the form unless the command file is just starting */
  //printf("I'm now waking up, test_wakeup=%d\n",test_wakeup);
  if ( test_wakeup == 1 && not_done )
    {
      FIf_display ( form );  /* Redisplay the form */
      FIg_set_text(form, NAME_BTN, "Locate Pen");
      form_displayed = TRUE; /* Set flag for sleep function */
    }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
  {
    FIf_erase ( form );
    form_displayed = FALSE;
  }
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
    {
      FIf_erase ( form );
      form_displayed = FALSE;
    }

  /* Delete the form if it exists */
  if ( form_exists )
      FIf_delete( form );
}

/**************************************************************************/
IGRlong GetObjByName( objName, className, objID )
IGRchar	*objName ;
IGRchar	*className ;
TGRid	*objID ;
{
IGRlong         ret ;
IGRlong         sts ;
IGRint          i, j, index, nb_obj;
GRspacenum      cur_osnum;
GRclassid       classid ;
GRobjid         *obj_list ;
TGRid           id ;
int		NbRefOs;
GRspacenum	main_os, *RefOsList;
char		name[128], pathName[128] ;


	ret		= 0 ;
	main_os		= 2 ;
	NbRefOs		= 0 ;
	RefOsList	= NULL ;
	obj_list	= NULL  ;
	
	UI_status("Searching for object. Please wait ...");

        /* get obj from current active file */
        objID->objid = NULL_OBJID ;
        vds$translate (objname = objName,
                      p_objid = &(objID->objid),
                      p_osnum = &(objID->osnum) );

        if( objID->objid != NULL_OBJID ) {
                ret = 1;
                goto wrapup ;
        }

        /* if obj not in active file, try ref files */

        sts = om$get_classid (  classname = className ,
                                p_classid = &classid);
        if( !(sts&1) ) {
                printf("om$get_classid failed\n");
                goto wrapup ;
        }

	sts = vd$get_ref_os_list (	msg           =  &msg,
                               		main_os       =  &main_os,
                               		num_ref_os    =  &NbRefOs,
                               		ref_os_list   =  &RefOsList );
	__DBGpr_int("NbRefOs", NbRefOs);
for(i = 0; i < NbRefOs; i = i+1 ) {
	nb_obj = 0 ;
	__DBGpr_int("RefOsList", RefOsList[i]);
        sts = VDpms_findall_ancestryobjects (
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        NULL);
	__DBGpr_int("nb_obj", nb_obj);
        if( !(sts&1) || !nb_obj ) {
		__DBGpr_com("VDpms_findall_ancestryobjects failed 1");
		continue;
	}

	obj_list = NULL ;
        obj_list = _CALLOC( nb_obj, GRobjid ) ;
        if( obj_list == NULL ) {
                printf("_CALLOC failed for obj_list\n") ;
                goto wrapup ;
        }

        sts = VDpms_findall_ancestryobjects(
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        obj_list);
        if( !(sts&1) || !nb_obj ) {
		__DBGpr_com("VDpms_findall_ancestryobjects failed 2");
		continue;
	}

	id.osnum = RefOsList[i];
        for(j = 0; j < nb_obj; j = j + 1 ) {
		id.objid = obj_list[j] ;
		gr$get_name(	GRid_in = id, 
		 		name = name);
		if( !strcmp(objName, name) ) {
			*objID = id ;
			ret = 1;
			goto wrapup ;
		}

        }
        _FREE( obj_list ) ;
	obj_list = NULL ;
}

        ret = 1 ;
wrapup:
        _FREE( obj_list ) ;
	_FREE(RefOsList); 
        //printf(">> Exit VStransEdgeToEJ_Bevel <<\n");
	UI_status(" ");
        return ret ;
}

#ifdef DEBUG
#define TRACE(txt)	write("ci_mac_bib: ", txt, '\n');
#else
#define TRACE(txt)  ;
#endif

#define EXP_DOUBLE 0

/*======================================================================*/
/*      locate an object or a expression				*/
/* copied & modified from vds/cimacros/wireframe/macros/ci_mac_bib.u	*/
/*======================================================================*/

int loc_obj_exp( loc_suc, loc_message, loc_prompt, 
                 class_obj,EXP_GRid )

int		*loc_suc;       /* return status			    */
char		loc_prompt[80];	/* prompt to ask the name of the expression */
char		loc_message[80];/* prompt to set the message field          */
struct GRid	*EXP_GRid;	/* return objid & osnum of the expression   */
char		*class_obj;	/* classes filter for located object	    */


{

char		exp_name[80];
char		*exp_value, msg_string[128] ;
int		stat, mask, response, count;
short		sender_class;

struct GRmd_env	MOD_ENV;
struct GRevent	event;

extern ASmake_source_from_env();


        message(loc_message);

	ci$get_module_info(md_env = &MOD_ENV);

step0:

	EXP_GRid->objid = NULL_OBJID;

	mask = GRm_RJT_MOVEON | GRm_BACK_UP | GRm_STRING | GRm_DATA | GRm_OBJID;

        do
        {
        
           *loc_suc = ci$getevent( prompt = loc_prompt, response = &response,
	     			   data   = exp_value,  mask     = mask,
				   event = &event,
				   stackable = 1 );
           if( (response == EX_RJT_MOVEON) || (response == EX_BACK_UP ) )
           {
		*loc_suc = 0; 
                return(0);
           }
        }while( *loc_suc != 1 );

/* we got an object via the navigate graph */

	if( response == EX_OBJID )
        {
	  om$get_classid( osnum     = event.located_object[0].located_obj.osnum,
			  objid     = event.located_object[0].located_obj.objid,
			  p_classid = &sender_class );

	  stat = om$is_ancestry_valid( subclassid     = sender_class,
				       superclassname = "expression" );
	  if( stat  != 1 ) goto step0;
	  EXP_GRid->objid = event.located_object[0].located_obj.objid;
	  EXP_GRid->osnum = event.located_object[0].located_obj.osnum;
 	  *loc_suc = 2; 
	  return(1);
        }

/* we recieved a data point to locate an abject */

        if ( response == DATA )
        {
		ci$put( point = (double *)exp_value );
		if ( !ci$locate( prompt = loc_prompt,
                                 owner_action = LC_RIGID_COMP
                                              | LC_RIGID_OWNER | LC_FLEX_COMP
                                              | LC_FLEX_OWNER  | LC_REF_OBJECTS,
				 obj    = &(EXP_GRid->objid), 
				 osnum  = &(EXP_GRid->osnum),
				 md_env = &MOD_ENV,
				 classes= class_obj,
				 stackable = 1 ))
        	{
             		EXP_GRid->objid = NULL_OBJID;
             		*loc_suc = 0;
                        return(0);
        	}
		else
		{
			*loc_suc = 1;
                        return(1);
		}
        }

/* we recieved a data point to locate an abject */

	else if ( response == STRING )
        {
		strcpy(exp_name, exp_value);
		if(exp_name[0] == 0 ) goto step0;

		GetObjByName( exp_name, class_obj, EXP_GRid);
		__DBGpr_obj("EXP_GRid", *EXP_GRid);
          	if ( (EXP_GRid->objid) == NULL_OBJID )
          	{
			sprintf(msg_string, "Macro \"%s\" not found", exp_name);
			UI_status(msg_string);
			goto step0 ;
	  	} 

		gr$display_object(object_id = EXP_GRid, mode  = GRhd );
		*loc_suc = 2;
		return(1);
	} /* end of process string */

}

/*-----------------------------------------------------------------------*/
IGRboolean checkForProperName( selObj, objName, check )
struct GRid selObj;
IGRchar	objName[80];
IGRint	check;
{
double pnt[3];
char	junk[80], junk1[80];
char	fullName[128];
int	ret;

	objName[0] = 0;

	#ifdef DEBUG
	printf("objid=%d,%d\n",selObj.objid, selObj.osnum);
	#endif

 	gr$get_name(	GRid_in = selObj, 
			full_name = fullName,
		 	name = objName);
	#ifdef DEBUG
	printf("Selected object name is %s, [%s]\n",objName, fullName);
	#endif

	if(!strcmp(objName,"") && check == TRUE) 
	{
		//status("This object is not named");
		strcpy(commentString, "This object is not named");
		return FALSE;
	}

	if ( check == TRUE ){

	  if( strlen(objName) != 9 ){
		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  if(objName[0] != 'F' && objName[0] != 'P' && objName[0] != 'V' && 
	     objName[0] != 'E' && objName[0] != 'M' ){

		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  if( objName[5] != '-' ){

		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }
	}
	return TRUE;
}

/*
 * Enable every gadget in the form.
 * added by ylong for TR179900857.
 */
void enable_form()
{
        FIg_enable( form, CANCEL);
        FIg_enable( form, RE_SET);
        FIg_enable( form, RUN);
        FIg_enable( form, ACCEPT);
        FIg_enable( form, COMP_BTN);
	FIg_enable( form, NAME_BTN);
        FIg_enable( form, NAME_FIELD);
        FIg_enable( form, COMP_FIELD);
        FIg_enable( form, DESCRIPTION_FIELD);
	FIg_enable( form, EXPRESSIONS);
        FIg_enable( form, REV);
        FIg_enable( form, TYPE);
        FIg_enable( form, SHAPE);
        FIg_enable( form, LA);
        FIg_enable( form, STRUCT_CUT);
        FIg_enable( form, MAC_LIB);
        FIg_enable( form, OBJ_FIT_BTN);
	FIg_set_text(form, NAME_BTN, "Locate Pen");
}

/*
 * Disable every gadget in the form after RE_SET. 
 * added by ylong for TR179900857. 
 */
void disable_form() 
{
	//FIg_disable( form, CANCEL);
	FIg_disable( form, RE_SET);
	FIg_disable( form, RUN);
	FIg_disable( form, ACCEPT);
	FIg_disable( form, COMP_BTN);
	FIg_disable( form, NAME_BTN);
	FIg_disable( form, NAME_FIELD);
	FIg_disable( form, COMP_FIELD);
	FIg_disable( form, DESCRIPTION_FIELD);
	FIg_disable( form, EXPRESSIONS);
	FIg_disable( form, REV);
	FIg_disable( form, TYPE);
	FIg_disable( form, SHAPE);
	FIg_disable( form, LA);
	FIg_disable( form, STRUCT_CUT);
	FIg_disable( form, MAC_LIB);
        //FIg_disable( form, OBJ_FIT_BTN);
}


IGRstat	SetLongAxis(k)
	IGRint	k;
{
	IGRstat		retFlag;
	IGRlong		sts, msg;
	IGRint		m, sel, pos;
	IGRchar		text[128];
	IGRdouble	val[10];
	IGRdouble	cm[16], cosin, angle;
	IGRdouble	loc_vec[3], max, dot_prod;
	IGRint		orient, loc_orient;
	
SetProc(SetLongAxis); Begin

	retFlag = 0;

	if(!strcmp(shapeStr,"rd")) {
		goto wrapup;
	}

	if( k < num_exps ) {
		goto wrapup;
	}

	for(m = 0; m < 3; m = m+1) {
		loc_vec[m] = 0.;
	}

	if(!strcmp(shapeStr,"rh")) {
		loc_vec[0] = 1.0;
		loc_orient = 0;
	}
	else {
		for(m = 0; m < num_exps; m = m+1) {
		  text[0] = '\0';
		  FIfld_get_text(form, EXPRESSIONS, m, 1, 80, text, &sel, &pos);
		  val[m] = atof(text); 
		  __DBGpr_dbl("val", val[m]);
		}
		
		if( val[1] > val[0] ) {
			loc_vec[1] = 1.0;
			loc_orient = 1;
		}
		else {
			loc_vec[0] = 1.0;
			loc_orient = 0;
		}
	}

	__DBGpr_int("num_exps", num_exps);
	__DBGpr_obj("TEMPS[0]", TEMPS[0]);
	sts = ci$send(  msg      = message GRgencs.GRgetmatrix (&msg, cm),
                        targetid = TEMPS[0].objid,
                        targetos = TEMPS[0].osnum );
	if( !(sts&msg&1) ) {
		printf("GRgencs.GRgetmatrix failed");
		goto wrapup;
	}

	max = 0.;
	for( m = 0; m < 3; m = m+1 ) {
		dot_prod =	cm[m*4+0]*loc_vec[0] + 
				cm[m*4+1]*loc_vec[1] + 
				cm[m*4+2]*loc_vec[2];
		if( fabs(dot_prod) > max ) {
			max = fabs(dot_prod);
			orient = m;
		}
	}
	
	__DBGpr_int("orient" , orient);

	switch( orient ) {

	case 0:         /* X */
		cosin = fabs( cm[loc_orient+0] );
		break;
	case 1:         /* Y */
		cosin = fabs( cm[loc_orient+4] );
		break;
	case 2:         /* Z */
		cosin = fabs( cm[loc_orient+8] );
		break;
	default:        /* NA */
		cosin = 0.707;
		break;
	};

        if( cosin > 1.0 ) cosin = 1.0;
        angle = acos( cosin )*180/PI ;
        if( angle > 1.0 ) orient = 3;

	text[0] = '\0';
	FIfld_get_list_text(form, LA, orient, 0, 80, text, &sel);

	FIg_set_text(form, LA, text);

	retFlag = 1;
wrapup:
	End
	return retFlag;
}

main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/


{

  int 	response;     
  int	iSwitch;
  int	i;
  int	m;
  int	msg;
  int	pos;
  int   selFlag;
  int	exitFlag;
  int	numAttrs;
  int	sts;
  int	k;
  int 	error;

  double dSwitch;
  double dDiameter;
  double dWidth;
  double dDepth;
  double dRadius_corner;

  GRobj	pplFileId;

  struct GRid	csObj;
  struct GRid	compObj;
  struct GRid	objID;
  struct GRid	CollID, foundID, winID;

  char	objName[80];
  char	NameToGive[128];
  char	tmpStr[80];
  char	tmp[80];
  char	chkval[80];
  char  expnam[80];
 
  char	loc_msg[128] ;
  char	loc_prompt[128] ;

  struct GRevent  event;

 /***********************************************************
  Do a locate and check to see if the object is named properly
  before displaying the form.
  ***********************************************************/
  /* initialize some parameters before we start */
  dDiameter = 1.0;
  dWidth = 1.0;
  dDepth = 1.0;
  dRadius_corner = 0.4;

  notlocal=TRUE;
  message(TITLE_STRING);
  exitFlag = 1;
  test_wakeup = 1;        /* flag for wakeup function */
  form_exists = FALSE;    /* flag for delete function */
  form_displayed = FALSE; /* flag for sleep  function */
  form_st.gadget_label = -1 ;

again:

  objName[0] = '\0';
  objID.objid = NULL_OBJID ;
  strcpy(loc_msg, TITLE_STRING);
  strcpy(loc_prompt, "Identify Penetration by Name or Locate");
  if( !LocateObj( "nci_macro", loc_prompt, &objID, objName, FALSE ) ) {
	if( form_displayed ) {
	    do {
                ci$get( prompt = "Quit Form", response = &response );
                if( form_st.gadget_label != CANCEL ) continue ;
                not_done = 0;           /* Stop the loop  */
                exitFlag = 0;           /* exit the program */
                FIf_erase ( form );     /* Erase the form */
                goto wrapup;
            } while( form_st.gadget_label != CANCEL ) ;

        }
        else goto wrapup ;
  }

  if( ispenMacro(objID) != TRUE ) {
	sprintf(tmp, "\"%s\" is not a Penetration Macro", oldName);
	UI_status(tmp);
	goto again;
  }
  else {
	UI_status("");
  }

process_located_obj:

  strcpy(revStr, "A1");
  strcpy(typeStr, "N/A");
  strcpy(laStr, "1");
  strcpy(structStr, "DECK");
  strcpy(descStr, "");
  strcpy(formStr, TITLE_STRING);
  strcpy(oldName, "");
  strcpy(csName, "");
  if( objID.objid != NULL_OBJID  ) {
	NEW_MAC = objID ;
	strcpy(oldName, objName);
	strcpy(penName, objName);
  }

  not_done = TRUE;  /* Set this to FALSE when done with form */

  if( form_exists )  {		/* modified for TR179900857 */
	enable_form();
  }
  else {
	form_init();      /* Set up the form */
  }

  strcpy(formStr, "Review Penetration");
  FIg_set_text( form, FORM_TITLE, formStr);
  FIg_set_text( form, NAME_BTN, "Locate Pen");
  FIg_set_text( form, NAME_FIELD, penName);

  if( NEW_MAC.osnum != 2){
	/* 
	   this is not in the current object space 
	   so blank out the run and check buttons.
	*/
	notlocal=TRUE;

	disable_form() ;
	FIg_enable( form, CANCEL );
	FIg_enable( form, NAME_BTN );
	FIg_enable( form, NAME_FIELD );
  	strcpy(formStr, "Review Penetration");
  	FIg_set_text( form, FORM_TITLE, formStr);
  }

  get_current_file_name_and_mod_env();
  get_attached_macro_libraries();

/* get the coordinate system and initialize the variables */
  getCurrentCoord();
  NewCoord = OldCoord;
  NewPret = OldPret;

  fillInForm();
	
  FIfld_get_text(form, SHAPE, 0, 0, 40, shapeStr, &selFlag, &pos);
  if( !strcmp(shapeStr, "rd") ) {
	FIg_disable(form, LA);
  }

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/
  while (not_done )
    {
      objName[0] = '\0';
      objID.objid = NULL_OBJID ;

      /* Suspend the command file and wait for the form */
      ci$get( prompt = "Fill in the form", response = &response );
      status(""); /* clear the status field*/

      /* prevent wrong manipulation */
     if( form_st.gadget_label == RUN && response == 1) continue;

      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){

        case CANCEL:
          /* Quit Button */
          not_done = 0;        /* Stop the loop  */
	  exitFlag = 0;		/* exit the program */
          FIf_erase ( form );  /* Erase the form */
          break;

        case NAME_FIELD:
	  FIg_get_text( form, NAME_FIELD, objName );
 	  GetObjByName(objName,  "nci_macro", &objID);
          if(objID.objid != NULL_OBJID ) {
		gr$display_object(object_id = &objID, mode  = GRhd );
                goto process_located_obj;
	  }
	  else {
                FIf_reset( form );
		VDpenFormSetList( form, TYPE,       "type_list", -1 );
		VDpenFormSetList( form, STRUCT_CUT, "structure_to_cut", -1 );
		VDpenFormSetList( form, LA,         "long_axis", -1 );
		VDpenFormFillInObjNames(form, NAME_FIELD, "penMacro");
		FIg_set_text( form, NAME_FIELD, objName );
		sprintf(tmpStr, "Cannot find PEN Macro %s", objName);
		status( tmpStr );
	  }
          
          break;

        case NAME_BTN:
	  strcpy(loc_prompt, "Identify Penetration by Name or Locate");
	  FIg_get_text(form, NAME_FIELD, penName);
	  disable_form();
          while( objID.objid == NULL_OBJID) {
                if(!LocateObj("nci_macro",loc_prompt,&objID, objName, FALSE)){
		    __DBGpr_str("break here, set backpenName",penName);
                    objID.objid = NULL_OBJID ;
                    break ;
                }
                if( ispenMacro( objID ) != TRUE ) {
                    sprintf(tmp, "\"%s\" is not a Penetration",objName);
                    UI_status(tmp);
                    objID.objid = NULL_OBJID ;
                }
                __DBGpr_obj("objID", objID);
          }
          gr$display_object(object_id = &objID, mode  = GRhd );
          goto process_located_obj;
          
          break;

        case COMP_BTN:
          /* ID COMPARTMENT Button */
 	  LocateObj( "SMcomp", "Identify Compartment", &objID, compStr, FALSE);
	  if( objID.objid != NULL_OBJID ) compObj = objID;
	  /* Get comp_num to replace comp_name for CR179900966 */
	            vdsa$GetStruct (      objID   = &compObj,
                                name    = "attr:comp_num" ,
                                txt     = compStr ) ;
          __DBGpr_str("compStr", compStr ) ;

  	  FIfld_set_text( form, COMP_FIELD, 0, 0, compStr, FALSE);
          break;

        case COMP_FIELD:
          FIfld_get_text(form, COMP_FIELD, 0, 0, 76, compStr, &selFlag, &pos);
          break;

        case REV:
          FIfld_get_text(form, REV, 0, 0, 76, revStr, &selFlag, &pos);
	  for ( i=0;i< strlen(revStr);i=i+1){
		revStr[i] = toupper(revStr[i]);
	  }
#ifdef DEBUG
	  printf("finished changing the text to upper case\n");
#endif
          FIfld_set_text(form, REV, 0, 0, revStr, FALSE);
          if(!strcmp(revStr,""))
          { 
  	  	FIfld_set_text( form, REV, 0, 0, "---", TRUE);	
          	status("Fill in a Revision");
          	break;
          }
	  break;

        case TYPE:
          FIfld_get_text(form, TYPE, 0, 0, 6, typeStr, &selFlag, &pos);
#ifdef DEBUG
	  printf("finished changing the text to upper case\n");
#endif
          if(!strcmp(typeStr,""))
          { 
  	  	FIfld_set_text( form, TYPE, 0, 0, "---", TRUE);	
          	status("Select a Type");
          	break;
          }
	  break;

        case MAC_LIB:
	  /* FILL IN THE SHAPE LIST */
          FIfld_get_text(form, MAC_LIB, 0, 0, 128, macStr, &selFlag, &pos);
          if(!strcmp(macStr,""))
          { 
  	  	FIfld_set_text( form, MAC_LIB, 0, 0, "---", TRUE);	
                FIfld_set_list_num_rows( form, SHAPE, 0, 0);
                FIfld_set_text( form, SHAPE, 0,0, "",FALSE);
          	status("Select a Macro Library");
          	break;
          }
	  set_macro_list(macStr);

	  break;

        case SHAPE:
          FIfld_get_text(form, SHAPE, 0, 0, 40, shapeStr, &selFlag, &pos);
#ifdef DEBUG
	  printf("shape string[%s]\n", shapeStr);
#endif
          if(!strcmp(shapeStr,""))
          { 
  	  	FIfld_set_text( form, SHAPE, 0, 0, "---", TRUE);	
          	status("Select a Shape");
          	break;
	  }
 	  set_argu_list(macStr, shapeStr);

          if(!strcmp(shapeStr,"rd")) {
                strcpy(laStr, "N/A");
                FIfld_set_text( form, LA, 0, 0, laStr, TRUE);
                FIg_disable(form, LA);
          }
          else {
                FIg_enable(form, LA);
		FIfld_set_text(form, LA, 0, 0, "", &selFlag, &pos);
          }

	  break;

        case LA:
          FIfld_get_text(form, LA, 0, 0, 4, laStr, &selFlag, &pos);
          if(!strcmp(laStr,""))
          { 
  	  	FIfld_set_text( form, LA, 0, 0, "-", TRUE);	
          	status("Select a Long Axis Direction");
          	break;
          }
	  break;

	case EXPRESSIONS:
		FIfld_get_num_rows( form, EXPRESSIONS, &k);
		//printf("num expressions=%d\n",k);
		SetLongAxis(k);

	  break;

        case STRUCT_CUT:
          FIfld_get_text(form, STRUCT_CUT, 0, 0, 6, structStr, &selFlag, &pos);
          if(!strcmp(structStr,""))
          { 
  	  	FIfld_set_text( form, STRUCT_CUT, 0, 0, "---", TRUE);	
          	status("Select the type of Structure to cut");
          	break;
          }
	  break;

        case DESCRIPTION_FIELD:
          FIfld_get_text(form, DESCRIPTION_FIELD, 0, 0, 1023, descStr, &selFlag, &pos);
          if(!strcmp(descStr,""))
          { 
  	  	FIfld_set_text( form, DESCRIPTION_FIELD, 0, 0, "---", TRUE);	
          	status("Fill in a Description");
          	break;
          }
	  break;

        case OBJ_FIT_BTN:
          winID.objid = NULL_OBJID ;
          ci$getevent( prompt   = "Identify Window or Moveon for all",
                        response= &response,
                        data    = tmp,
                        event   = &event,
                        mask    = GRm_DATA,
                        window_id = &winID.objid,
                        window_osnum = &winID.osnum,
                        stackable = 1 );

          if( winID.objid == NULL_OBJID ){
            sts = vd$vw_fit_object(
                               factor   = 2.0,
                               object   = &NEW_MAC,
                               md_env   = &MOD_ENV );
          }
          else {
            sts = vd$vw_fit_object(
                               object   = &NEW_MAC,
                               md_env   = &MOD_ENV,
                               ggid     = &winID,
                               factor   = 2.0,
                               num_ggid = 1 );
          }
          gr$display_object(object_id = &NEW_MAC, mode  = GRhd );

          break;


        case RUN:
	  checkAndPlace();
	  computeTheMacro();
 	  status("Modification done.");
	  FIf_reset(form);
	  VDpenFormSetList( form, TYPE,       "type_list", -1 );
	  VDpenFormSetList( form, STRUCT_CUT, "structure_to_cut", -1 );
	  VDpenFormSetList( form, LA,         "long_axis", -1 );
	  disable_form();
	  FIg_enable(form, NAME_BTN);
	  FIg_enable(form, NAME_FIELD);
	  UI_status("Searching for macros. Please wait ...");
	  VDpenFormFillInObjNames(form, NAME_FIELD, "penMacro");
	  UI_status(" ");
	  break;

        case RE_SET:		/* added by ylong for TR179900857 */
	  FIf_reset(form);
	  VDpenFormSetList( form, TYPE,       "type_list", -1 );
	  VDpenFormSetList( form, STRUCT_CUT, "structure_to_cut", -1 );
	  VDpenFormSetList( form, LA,         "long_axis", -1 );
	  disable_form() ;
	  FIg_enable(form, NAME_BTN);
	  FIg_enable(form, NAME_FIELD);
	  VDpenFormFillInObjNames(form, NAME_FIELD, "penMacro");
	  break;

        case ACCEPT:
          
 	  checkAndPlace();
	  computeTheMacro();
          not_done = 0;        /* Stop the loop  */
          FIf_erase ( form );  /* Erase the form */
          break;

        } /* END switch ( g_label ) */
    } /* END while ( not done ) */

wrapup:

    UI_prompt("");
    UI_message("");
    if ( exitFlag == 0 ) {
	exit;
    }

  /* The delete function will delete the form
     when the command file terminates */

}

/**********************************************************/

int LocateObj( inType, inPrompt, selObj, objName, check)
IGRchar	*inType;
IGRchar *inPrompt;
TGRid	selObj[1];
IGRchar	objName[132];
IGRint	check;
{
        IGRlong loc_suc ;
        int     ret ;

        ret = 0 ;

        objName[0] = '\0' ;
        ret = loc_obj_exp( &loc_suc, TITLE_STRING, inPrompt, inType, selObj ) ;
        if( !ret ) goto wrapup ;

	ret = checkForProperName( *selObj, objName, check ) ;
	if(!ret) UI_status(commentString);

wrapup:
        return ret;
}

/***********************************************************/

IGRint	*list;
IGRint	*lines;
IGRchar	txt[1024];
struct GRid *grobjs;
IGRchar	txt1[40];
IGRint	ele_count;
IGRint	l;
IGRchar	filename[132];
IGRint 	var_size[3];
IGRint	bad_var;
struct EX_var_list	ex_var[4];
extern int EX_get_global();
extern int ACconstruct_path();

IGRint not_default_library ( tmpName )
IGRchar *tmpName;
{
        if( ! strcmp( tmpName, "SMPrivMac" )) return FALSE;
        if( ! strcmp( tmpName, "VDSmacro" )) return FALSE;
        if( ! strcmp( tmpName, "PPMmacro" )) return FALSE;
        if( ! strcmp( tmpName, "VDSdrw"   )) return FALSE;
        if( ! strcmp( tmpName, "VSfeatures.mc" )) return FALSE;
        if( ! strcmp( tmpName, "VSmacro" )) return FALSE;
        if( ! strcmp( tmpName, "VRfeatures.mc" )) return FALSE;
        if( ! strcmp( tmpName, "VRmacro" )) return FALSE;
        if( ! strcmp( tmpName, "HVmacro" )) return FALSE;
        if( ! strcmp( tmpName, "PidMetLib" )) return FALSE;
        if( ! strcmp( tmpName, "PidImpLib" )) return FALSE;

#ifdef DEBUG
        printf("libraries : %s\n", tmpName );
#endif
        return TRUE ;
}

get_attached_macro_libraries()
{
IGRint	i, len, k, m;
char	pathStr[1024];
char	tmpName[128];

#ifdef DEBUG
printf("entering get_attached_macro_libraries()\n");
#endif

// SEARCH THE CURRENT FILES CONSTRUCTS_LIB DIRECTORY FOR MACRO LIB ATTACHMENTS

msg = ac$construct_path(
		mode = AC_INQ,
		path = pathStr,
		path_size = 256,
		path_len = &len);

FIfld_set_list_num_rows( form, MAC_LIB, 0, 50);
FIfld_set_text( form, MAC_LIB, 0,0, "",FALSE);

//printf("path[%s], len=%d\n",pathStr, len);

k=0;
m=0;
for( i=0;i<len;i=i+1){

        if( pathStr[i] == ',' ){
          tmpName[k] = 0;
          if( not_default_library ( tmpName ) == TRUE ) {
            FIfld_set_list_default_text( form, MAC_LIB, m,0, tmpName, FALSE);
            m=m+1;
	  }
          k=0;
        }else if( i == len -1){
          tmpName[k] = pathStr[i];
          tmpName[k+1] = 0;
          if( not_default_library ( tmpName ) == TRUE ) {
            FIfld_set_list_default_text( form, MAC_LIB, m,0, tmpName, FALSE);
            m=m+1;
	  }
          k=0;
        }else{
          tmpName[k] = pathStr[i];
          k=k+1;
        }
}
FIfld_set_list_num_rows( form, MAC_LIB, 0, m);

#ifdef DEBUG
printf("exiting get_attached_macro_libraries()\n");
#endif
}

/***********************************************************/

int set_macro_list(macro_lib_name)
IGRchar *macro_lib_name;
{
struct sup 	*xdup;
IGRint		tot_up, prop;
IGRint		k,i;
IGRchar		txt2[128];
IGRint		skip;
IGRint		no_lines;
IGRint		msg;
struct GRid	MACID;

	strcpy(txt2,":");
	strcat(txt2,filename);
	strcat(txt2,":constructs_lib:");
	strcat(txt2,macro_lib_name);
	strcat(txt2,":constructs:");

	di$find( start_dir = txt2, 
                 grids = &grobjs,
		 ptr=&ele_count,
                 max_level = 1,
		 lines=&list,
                 options = OPT_LEVEL);

	FIfld_get_num_rows( form, SHAPE, &k);
	for(i=0;i<k;i=i+1){
		FIfld_set_text( form, SHAPE, i,0, "",FALSE);
	}
	FIfld_set_list_num_rows( form, SHAPE, 0, ele_count);
	FIfld_set_text( form, SHAPE, 0,0, "",FALSE);

	k=0;

	for(i=0;i<ele_count;i=i+1)
	{
		di$split ( pathname = (char *)list[i],
			dirname = NULL,
			name = txt1 );

		/* get the macro$def files out */
		if( strchr(txt1,'$') != NULL ) continue;

		/* added by ylong to prevent them from displaying,  03-01-00 */
		if( !strcmp(txt1, "penMacro") || !strcmp(txt1, "pcgMacro") )
			continue;

		FIfld_set_list_num_rows( form, SHAPE, 0, k+1);
		FIfld_set_list_default_text( form, SHAPE, k,0, txt1,FALSE);
		k=k+1;
	}
	return(k);

#ifdef DEBUG
printf("exiting set_macro_list()\n");
#endif
}

/************************************************************/

int set_argu_list(macro_lib_name, macro_name)
IGRchar *macro_lib_name;
IGRchar *macro_name;
{
struct sup 	*xdup;
IGRint		tot_up, prop;
IGRint		k,i,m;
IGRchar		txt2[128];
IGRint		skip;
IGRint		no_lines;

	SetProc(set_argu_list); Begin

	FIfld_set_list_num_rows( form, EXPRESSIONS, 0, 0);
	FIfld_set_text( form, EXPRESSIONS, 0,0, "",FALSE);
		
	FIfld_get_num_rows( form, EXPRESSIONS, &k);
	for(m=0;m<k;m=m+1){
		FIfld_set_text( form, EXPRESSIONS, m,0, "",FALSE);
		FIfld_set_text( form, EXPRESSIONS, m,1, "",FALSE);
	}

	for(i=0;i<ele_count;i=i+1)
	{
		strcpy(txt1,(char*)list[i]);

 		di$split ( pathname = (char *)list[i],
                	  dirname = NULL,
                  	  name = txt1 );

		/* get the macro$def files out */

           	if( strchr(txt1,'$') != NULL ) continue;

		#ifdef DEBUG
		printf("%s\n",txt1);
		#endif

		if( strcmp( macro_name, txt1) == 0){

			ci$send( msg = message ACmacro_defn.ACgive_upscan(
				&tot_up, &prop, &xdup),
				targetid = grobjs[i].objid,
				targetos = grobjs[i].osnum);

#ifdef DEBUG
			printf("%s has %d templates\n", txt1, tot_up);
#endif

			FIfld_set_list_num_rows( form, EXPRESSIONS, 0, tot_up);
			
			num_exps=0;

			for(l=0;l<tot_up;l=l+1){

				if( xdup[l].type == 65552 ||  xdup[l].type == 131088 ){
					FIfld_set_text( form, EXPRESSIONS, num_exps,0, 
								xdup[l].prompt,FALSE);
					FIfld_set_text( form, EXPRESSIONS, num_exps,1, 
									"",FALSE);
					num_exps=num_exps+1;
				}
			}
			break;
		}
	}
	End	
	return(k);
}

/********************************************************/

get_current_file_name_and_mod_env()
{

#ifdef DEBUG
printf("entering get_current_file_name_and_mod_env()\n");
#endif
// GET THE CURRENT FILE NAME

	var_size[0] = sizeof(filename);
	ex_var[0].var = EX_CUR_FILENAME;
	ex_var[0].var_value = &filename[0];
	ex_var[0].num_bytes = &var_size[0];
	var_size[1] = NULL;

	msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

	#ifdef DEBUG
	printf("filename[%s]\n",filename);
	#endif

 	ci$get_module_info( md_env = &MOD_ENV);

#ifdef DEBUG
printf("exiting get_current_file_name_and_mod_env()\n");
#endif
}

/**************************************************************************/

int	checkExpValues( )
{
int	m, k, selFlag, pos, msg;
char	chkval[80], tmp[80];
struct GRid	EXP_GRid;

	for(m=0;m<num_exps;m=m+1){

		FIfld_get_text( form, EXPRESSIONS, m, 0, 80, tmp, &selFlag, &pos);
		FIfld_get_text( form, EXPRESSIONS, m, 1, 80, chkval, &selFlag, &pos);
		if ( strcmp( chkval, "") == 0 && strcmp( tmp, "") != 0 ){

			sprintf( chkval,"Key in a value for the %s field",tmp);
			status(chkval);
			//printf("%s\n",chkval);
			pos = 0;
 			FIfld_pos_cursor( form, EXPRESSIONS, m, 0, 1, 0, 0, 0 );
			return m+1;
		}
	}
	return 0;
}

/*****************************************************************/

int	modifyMacro()
{

char	cRep;
int	msg, sts;
struct GRid	Locals[3];

	#ifdef DEBUG
	printf("in modifyMacro\n");
	printf("OldCoord[ %d, %d]\n", OldCoord.objid, OldCoord.osnum);
	printf("OldPret[ %d, %d]\n", OldPret.objid, OldPret.osnum);
	printf("NewCoord[ %d, %d]\n", NewCoord.objid, NewCoord.osnum);
	printf("NewPret[ %d, %d]\n", NewPret.objid, NewPret.osnum);
	#endif

    if( OldCoord.objid != NewCoord.objid ||
	OldCoord.osnum != NewCoord.osnum){

	ci$get_module_info( md_env = &MOD_ENV);

	#ifdef DEBUG
	printf("in modifyMacro and have something to change\n");
	printf("mac: %d, %d\n", NEW_MAC.objid, NEW_MAC.osnum);
	printf("make_src sts=%d, OldCoord[ %d, %d]\n",sts, OldCoord.objid, OldCoord.osnum);
	printf("make_src sts=%d, OldPret[ %d, %d]\n",sts, OldPret.objid, OldPret.osnum);
	printf("make_src sts=%d, NewCoord[ %d, %d]\n",sts, NewCoord.objid, NewCoord.osnum);
	printf("make_src sts=%d, NewPret[ %d, %d]\n",sts, NewPret.objid, NewPret.osnum);
	#endif

	NewPret.objid = NULL_OBJID;
	NewPret.osnum = 2;


	sts = ASmake_source_from_env(
		&NewCoord, &MOD_ENV, &NewPret);

	#ifdef DEBUG
	printf("make_src sts=%d, NewCoord[ %d, %d]\n",sts, NewCoord.objid, NewCoord.osnum);
	printf("make_src sts=%d, NewPret[ %d, %d]\n",sts, NewPret.objid, NewPret.osnum);
	#endif

	TEMPS[0] = NewPret;
	Locals[0] = OldPret;
	Locals[1] = TEMPS[1];
	Locals[2] = TEMPS[2];

	msg = 3; // number of parents to change
	sts = ci$send(msg = message  NDnode.NDchange_connect( 
		&msg,
		Locals,
		TEMPS),
		targetid = NEW_MAC.objid,
		targetos = NEW_MAC.osnum );

	#ifdef DEBUG
	printf("NDnode.NDchange_connect msg=%d, sts=%d, macroid[%d,%d]\n",
			msg, sts, NEW_MAC.objid, NEW_MAC.osnum);
	#endif
	
	OldPret = NewPret;
	OldCoord = NewCoord;
   }
   //printf("leavin modifyMacro\n");

   return TRUE;

}

/*********************************************************************/

computeTheMacro(){
int	msg, sts;
struct GRid	JUNK;

   //printf("in computeTheMacro, macid[%d, %d]\n", NEW_MAC.objid, NEW_MAC.osnum );


   sts = ci$send(msg = message GRgraphics.GRxform( 
		&msg,
		&MOD_ENV,
		&MOD_ENV.md_env.matrix_type,
		MOD_ENV.md_env.matrix,
		&NEW_MAC.objid),
		targetid = NEW_MAC.objid,
		targetos = NEW_MAC.osnum );

   FIg_get_text(form, NAME_FIELD, penName);
   __DBGpr_str("old macro name", oldName);
   __DBGpr_str("penName", penName);

   if( strcmp( oldName, penName ) ) {
	putName( &NEW_MAC, FALSE ) ;
	sprintf(oldName, "%s", penName );
   }
   //printf("NDmacro.ACreturn_foot msg=%d, sts=%d\n",msg, sts);

}

/***********************************************************/
int	putName( InGrid , hide)
struct GRid	*InGrid;
int		hide;
{
char	tmpname[128];
int	msg;
int	stat;


	if ( hide == FALSE){

		//sprintf( tmpname,"M%d%d",InGrid->objid, InGrid->osnum);	
		stat = ci$send( msg = message GRvg.GRputname(
			&msg,
			penName),
			targetid = InGrid->objid,
			targetos = InGrid->osnum);
	
		if ( !(stat&msg&1) ) return FALSE;
	}
	return TRUE;
}



/*****************************************************************/

checkAndPlace(){
  int	msg, m, i;
  int	pos;
  int   selFlag;
  int	exitFlag;
  int	numAttrs;
  int	sts;
  char	chkval[80];
  char  expnam[80];


	if( notlocal == FALSE) {
		return ;
	}

	FIfld_get_text(form, DESCRIPTION_FIELD, 0, 0, 1024, descStr, &selFlag, &pos);

	if ( checkExpValues() != 0){
		return;
	}

	if(!strcmp(descStr,"")){ 

		FIfld_pos_cursor(form, DESCRIPTION_FIELD, 0, 0, 0, 0, 0, 0);
          	status("Fill in a description");
          	return;
	} 

#ifdef DEBUG
	printf("ABOUT TO CHANGE ALL OF THE PARAMETERS FOR ID[%d, %d]\n",
				TEMPS[2].objid, TEMPS[2].osnum);
#endif

	i=0;
	strcpy(collAttrs[i].name, "compartment");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, compStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "revision");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, revStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "macro_lib");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, macStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "shape"); 
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, shapeStr);
	
	i=i+1;
	strcpy(collAttrs[i].name, "type");
	collAttrs[i].desc.type = 1; 
	strcpy(collAttrs[i].desc.value.att_txt, typeStr);

	i=i+1;
		strcpy(collAttrs[i].name, "structure_to_cut");
		collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, structStr);

	i=i+1;
	FIfld_get_num_rows( form, EXPRESSIONS, &num_exps);
	strcpy(collAttrs[i].name, "long_axis");
	collAttrs[i].desc.type = 1; 	
	SetLongAxis(num_exps);
	FIfld_get_text(form, LA, 0, 0, 4, laStr, &selFlag, &pos);
	strcpy(collAttrs[i].desc.value.att_txt, laStr);

	i=i+1;
	strcpy(collAttrs[i].name, "description");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, descStr);

	i=i+1;
	sts = ci$send( msg = message ACrg_collect.ACset_list_attribute(
		&msg,
		i,
		collAttrs),
		targetid = TEMPS[2].objid,
		targetos = TEMPS[2].osnum);
	
#ifdef DEBUG
	printf("add list sts=%d, msg=%d\n",sts,msg);
#endif


	strcpy(collAttrs[0].name, "macro_name");
	collAttrs[0].desc.type = 1; 	
	strcpy(collAttrs[0].desc.value.att_txt, shapeStr); 


	for(m=0;m<num_exps;m=m+1){

		FIfld_get_text( form, EXPRESSIONS, m, 0, 80, expnam, &selFlag, &pos);
		FIfld_get_text( form, EXPRESSIONS, m, 1, 80, chkval, &selFlag, &pos);

		if( strcmp( expnam, "" ) == 0 ||
		    strcmp( chkval, "" ) == 0) break;

		strcpy(collAttrs[m+1].name, expnam);
		collAttrs[m+1].desc.type = 2; 	
		collAttrs[m+1].desc.value.att_exp = atof(chkval); 
#ifdef DEBUG
		printf("col[%d] %s=%s\n",m,expnam , chkval);
#endif
	}

	sts = ci$send( msg = message ACrg_collect.ACset_list_attribute(
		&msg,
		m+1,
		collAttrs),
		targetid = TEMPS[1].objid,
		targetos = TEMPS[1].osnum);
	
#ifdef DEBUG
	printf("add list sts=%d, msg=%d\n",sts,msg);
#endif
	sts = modifyMacro();
}

/****************************************************************/

getCurrentCoord( )
{
int	msg, stat;

	msg = ci$send(	msg = message ACcpx.ACfind_exp_temp_obj
					(&stat, 0, &OldPret),
			targetid = NEW_MAC.objid,
			targetos = NEW_MAC.osnum);
	if (!(msg&stat&1)) return;

	msg = ci$send(	msg = message NDmacro.ACreturn_foot(
				&stat,
				"", 
				&OldCoord, 
				&MOD_ENV.md_env.matrix_type,
				MOD_ENV.md_env.matrix),
			targetid = OldPret.objid,
			targetos = OldPret.osnum);

	if (!(msg&stat&1)) return;

	gr$get_name( GRid_in = OldCoord, name = csName );

#ifdef DEBUG
	printf("OldCoord id[%d, %d], msg=%d, stat=%d\n", 
		OldCoord.objid, OldCoord.osnum, msg, stat);
	printf("OldPret id[%d, %d], msg=%d, stat=%d\n", 
		OldPret.objid, OldPret.osnum, msg, stat);

#endif

	 return;
}


/*****************************************************/
/* get the macro's definition name */
extern int	ACfind_macro_defn();

int ispenMacro(objID)
TGRid	objID;
{
struct GRid 	TEMP;
int	stat;
char	macname[132];
char	stripname[132];
char	msgStr[132];
struct GRid	defID;

msg = ci$send( msg = message ci_macro.find_macro(
		&TEMP),
		targetid = objID.objid,
		targetos = objID.osnum);

msg = ci$send( msg = message GRvg.GRgetname(
		&stat,
		macname),
		targetid = TEMP.objid,
		targetos = TEMP.osnum);

#ifdef DEBUG
printf("in ispenMacro macroname[%s]\n",macname);
#endif

di$split ( pathname = macname,
	   dirname = NULL,
	   name = stripname );

msg = ac$find_macro_defn( action = ACfind_load,
			  macro_name = stripname,
			  p_macro_defn_id = &defID);



if( strcmp( stripname, "penMacro") != 0){

	sprintf(msgStr, "%s is NOT a penMacro.\n", stripname);
	status(msgStr);
	return FALSE;

}else {

	#ifdef DEBUG 
	printf("IS penMacro, %s\n", stripname);
	#endif

	strcpy( macStr, stripname);
	return TRUE;
}

}

/**********************************************/

int fillInForm()
{
struct GRid JUNK;
int	msg, stat, i;
char	coordname[128], stripname[128];
int	numReturned;

	FIg_display( form, OBJ_FIT_BTN ) ;
	FIg_set_text(form, NAME_BTN, "Locate Pen");

	for(i=0; i<3; i=i+1){

		msg = ci$send( msg = message ACcpx.ACfind_exp_temp_obj(
			&stat, i, &JUNK),
			targetid = NEW_MAC.objid,
			targetos = NEW_MAC.osnum);

		if (!(msg&stat&1)) return;

		msg = ci$send( msg = message NDmacro.ACreturn_foot(
			&stat,
			"", 
			&TEMPS[i], 
			&MOD_ENV.md_env.matrix_type,
			MOD_ENV.md_env.matrix),
			targetid = JUNK.objid,
			targetos = JUNK.osnum);

		if (!(msg&stat&1)) return;

		#ifdef DEBUG
		printf("Template[%d]=id[%d, %d], msg=%d, stat=%d\n", 
				i, TEMPS[i].objid,  TEMPS[i].osnum, msg, stat);
		#endif

	}

	CoordID = TEMPS[0] ;

	/* get the coord system name */
	
	msg = ci$send( msg = message GRvg.GRgetname(
			&stat,
			coordname),
			targetid = TEMPS[0].objid,
			targetos = TEMPS[0].osnum);

 	di$split ( pathname = coordname,
                   dirname = NULL,
                   name = stripname );

	strcpy( csName, stripname );
	
	vdobj$Get( objID = &NEW_MAC, objName = penName);
  	FIfld_set_text( form, NAME_FIELD, 0,0, penName, FALSE); 


	/* get all the data out of the input collector for macro placement */

	msg = ci$send( msg = message  ACrg_collect.AClist_attribute(
			&stat,
			50,
			collAttrs,
			&numReturned),
        		targetid = TEMPS[1].objid,
        		targetos = TEMPS[1].osnum );

	//printf("number of atts in coll 1=%d\n",numReturned);

	if( !(msg&stat&1)) return FALSE;

	//FIfld_set_num_rows( form, EXPRESSIONS, &numReturned);

	// Set global num_exps
	num_exps = numReturned-1;

	for (i=0; i<numReturned-1; i=i+1){

		/*
		printf("i=%d\n",i);
		printf("[%d] %s\n", i,
			collAttrs[i+1].name);
		printf("1\n");
		*/

	    	FIfld_set_text( form, EXPRESSIONS, i,0, collAttrs[i+1].name,FALSE);

		//printf("attr.type=%d\n", collAttrs[i+1].desc.type);

	    	if( collAttrs[i+1].desc.type == 1){

			#ifdef DEBUG
			printf("[%d] %s=%s\n", i,
				collAttrs[i+1].name,
				collAttrs[i+1].desc.value.att_txt);
			#endif
			FIfld_set_text( form, EXPRESSIONS, i,1, collAttrs[i+1].desc.value.att_txt,FALSE);

	    	}else{

			#ifdef DEBUG
			printf("[%d] %s=%.3f\n", i,
				collAttrs[i+1].name,
				collAttrs[i+1].desc.value.att_exp);
			#endif

			FIfld_set_text( form, EXPRESSIONS, i,1, ftoa(collAttrs[i+1].desc.value.att_exp),FALSE);

	    	}
	}

  	FIfld_set_text( form, SHAPE, 0, 0, collAttrs[0].desc.value.att_txt, FALSE); 

	/* get all the data out of the other data collector */

	msg = ci$send( msg = message  ACrg_collect.AClist_attribute(
			&stat,
			50,
			collAttrs,
			&numReturned),
        		targetid = TEMPS[2].objid,
        		targetos = TEMPS[2].osnum );

	//printf("number of atts in coll 1=%d\n",numReturned);

	if( !(msg&stat&1)) return FALSE;

	i=0;
	strcpy( compStr, collAttrs[i].desc.value.att_txt);
  	FIfld_set_text( form, COMP_FIELD, 0, 0, compStr, FALSE); 

	i=i+1;
	strcpy( revStr, collAttrs[i].desc.value.att_txt);
 	FIfld_set_text( form, REV, 0, 0, revStr, FALSE); 

	i=i+1;
	strcpy( macStr, collAttrs[i].desc.value.att_txt);
	FIfld_set_text( form, MAC_LIB, 0, 0, macStr, FALSE);

	set_macro_list(macStr);

	i=i+1;	
 	strcpy( shapeStr, collAttrs[i].desc.value.att_txt);
 	FIfld_set_text( form, SHAPE, 0, 0, shapeStr, FALSE);

	i=i+1;	
	strcpy( typeStr, collAttrs[i].desc.value.att_txt);
  	FIfld_set_text( form, TYPE, 0, 0, typeStr, FALSE);	

	i=i+1;	
	strcpy( structStr, collAttrs[i].desc.value.att_txt);
  	FIfld_set_text( form, STRUCT_CUT, 0, 0, structStr, FALSE);

	i=i+1;	
	strcpy( laStr, collAttrs[i].desc.value.att_txt);
	FIfld_set_text( form, LA, 0, 0, laStr, FALSE);	

	i=i+1;	
	strcpy( descStr, collAttrs[i].desc.value.att_txt);
  	FIfld_set_text( form, DESCRIPTION_FIELD, 0, 0, descStr, FALSE);	
 	
	//VDpenFormFillInCoordNames( form, NAME_FIELD );
	VDpenFormFillInObjNames(form, NAME_FIELD, "penMacro");
	VDpenFormSetList( form, TYPE,       "type_list", -1 );
	VDpenFormSetList( form, STRUCT_CUT, "structure_to_cut", -1 );
	VDpenFormSetList( form, LA,         "long_axis", -1 );

}

/********************************************************************
 * It is used to test if a penMacro exsits, attached to ASsource cs.
 * Added by ylong for TR179900857, 09-09-99
 */
int A_penMacro_exists(objID) 
TGRid	objID ;
{

	IGRint			i;
        GRclassid               classid;
        struct  GRid            *foundIds;
        struct  GRid            OldCoord;
        struct  GRobj_env       OBJ_ENV;
        OM_S_CHANSELECT         my_chansel;

        IGRint  penFlag;
        IGRint  num_found;
        IGRlong sts, msg;

        penFlag = 0;
        num_found = 0;
        foundIds = NULL ;

        sts = om$make_chanselect(channame     = "GRnotify.notification",
                                 p_chanselect = &my_chansel);

        if( !(sts & 1) ) goto wrapup;

        classid = OPP_ASsource_class_id ;
        sts = VDGetGridsFromChan_of_Class (
                                        &msg,
                                        objID,
                                        &my_chansel,
                                        classid,
                                        &num_found,
                                        &foundIds ) ;
        #ifdef DEBUG
        printf("VDGetGridsFromChan_of_Class: msg = %d, sts = %d\n",msg,sts);
        printf("Number of objs on channel: %d\n", num_found);
        for( i = 0; i < num_found; i = i + 1 ) {
                printf(" foundIds[%d] = [%d, %d]\n",
                         i, foundIds[i].objid, foundIds[i].osnum);
        }
        #endif
        if( !(sts & 1) || !(msg &1) || num_found <= 0) goto wrapup;

        sts = ci$send(  msg = message NDmacro.ACreturn_foot(
                        &msg,
                        "",
                        &OldCoord,
                        &OBJ_ENV.mod_env.md_env.matrix_type,
                        OBJ_ENV.mod_env.md_env.matrix),
                        targetid = foundIds[0].objid,
                        targetos = foundIds[0].osnum);

        if( !(sts & 1) || !(msg &1) ) {
                #ifdef DEBUG
                printf("NDmacro.ACreturn_foot: msg=%d, sts=%d\n", msg,sts);
                #endif
                goto wrapup;
        }

        /*
         * Check if a macro penMacro attached to ASsource cs.
         */
        OBJ_ENV.obj_id.objid = OldCoord.objid;
        OBJ_ENV.obj_id.osnum = OldCoord.osnum;
        penFlag = vdefp$GetAttachedMacro(       macName = "penMacro",
                                                tplOEs  = &OBJ_ENV) ;
wrapup:
        if( penFlag ) {
           status("A pen macro already exists. CS not changed.");
        }

        _FREE( foundIds );
        return penFlag ;
}

