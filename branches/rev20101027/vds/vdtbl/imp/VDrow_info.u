/* $Id: VDrow_info.u,v 1.19 2002/05/14 12:42:00 ahundiak Exp $  */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:        vds/vdtbl/imp/VDrow_info.u
 *
 * Description:
 *	This PPL, VDrow_info.u, is used to handle the revision process within 
 *	the tables. Revision is based on reviewing the information from
 *	an existing table and compare this with the new list of objects from 
 *	the production.
 *
 *	This routine has two major functions:
 *
 *	name :	Request to return a unique name for the row.
 *	check:	Perform a process in which we compare the data with the
 *		new table objects.
 *
 *	The "name" has the following code flow:
 *
 *	- INPUT: Model Object (s) + Table Row.
 *
 *	1. Check the input objects .
 *	2. If we have one model object + table then
 *		check table type.
 *	3. Table type (row -> table)
 *	4. If Table of type 'UCM'.
 *	5       Create string format.
 *	6  Else Create Other format.
 *	
 *	
 *	The "check" has the following code flow:
 *
 *	- INPUT: Model Object (s) + Table Row.
 *
 *	1. Check the input objects .
 *	2. If we have one model object + table + oldName then
 *		check table type.
 *	3. Table type (row -> table)
 *	4. If Table of type 'UCM'.
 *	5       Create string format.
 *	6  Else Create Other format.
 *	7  Compare created string with oldName to reflaect change
 *	
 *	We have the following process in place.
 *	
 *	Object   : Table : Name
 *	==========================
 *	Plate    : UCM   : Name - PCMK
 *	Stiffener: UCM   : Name - PCMK
 *	Stiffener: UCM   : Name - PCMK
 *	Beam     : UCM   : Name - PCMK
 *	AT node  : UCM   : Stage path
 *	OT node  : ...   : stage path.
 *	others   : ...   : objectName (or Macro and attribute ??)
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: VDrow_info.u,v $
 *      Revision 1.19  2002/05/14 12:42:00  ahundiak
 *      *** empty log message ***
 *
 *      Revision 1.18  2001/10/29 20:52:51  ylong
 *      *** empty log message ***
 *
 *      Revision 1.16  2001/07/16 17:55:19  ylong
 *      *** empty log message ***
 *
 *      Revision 1.15  2001/06/29 17:29:00  ylong
 *      *** empty log message ***
 *
 *      Revision 1.14  2001/06/27 21:19:48  ylong
 *      *** empty log message ***
 *
 *      Revision 1.13  2001/06/26 22:26:11  ylong
 *      TR5337
 *
 *      Revision 1.12  2001/06/21 22:42:12  ylong
 *      *** empty log message ***
 *
 *      Revision 1.11  2001/03/06 17:21:38  ylong
 *      *** empty log message ***
 *
 *      Revision 1.10  2001/03/05 18:07:46  ylong
 *      *** empty log message ***
 *
 *      Revision 1.9  2001/03/02 21:49:29  ylong
 *      *** empty log message ***
 *
 *      Revision 1.7  2001/03/01 17:03:10  ylong
 *      *** empty log message ***
 *
 *      Revision 1.2  2001/02/09 14:41:29  ramarao
 *      *** empty log message ***
 *
 *      Revision 1.1  2001/02/07 18:15:56  ramarao
 *      *** empty log message ***
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      02/07/00        Rama Rao        File Creation.
 *      02/15/01        ylong           Check input object.
 *	05/14/02	adz		Add info for VDct1 Tree.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDsa.h"
#include "v_slcdef.h"
#include "v_pplslc.h"
#include "VDtypedef.h"

/* 
#define MY_DEBUG
 */

extern IGRstat VDtrget_nodePath();
extern IGRstat VDtrget_modelObject();
extern IGRstat VDtrIsLeaf();
extern IGRstat VDtrIsTreeAncestry();
extern IGRstat VDtrget_nodeType();
extern IGRstat VDatIsLeaf();

type()
{
IGRint			count;
IGRchar			type[DI_PATH_MAX];
struct GRobj_env	model_obj, row_obj, objOE;

#ifdef MY_DEBUG
   printf("---- VDrow_info - type begin ----\n");
#endif

   type[0]	= '\0';
   objOE.obj_id.objid = NULL_OBJID;

   vd$ppl_get_size( which_info = INPUT_INFO,
                    size       = &count );
   if( count < 2 ) return 1;

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 0,
                           value      = &model_obj  );

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 1,
                           value      = &row_obj  );

   /*
    * object is a AT leaf node
    */
   if (	VDatIsLeaf ( &model_obj.obj_id) )
   {
     VDtrget_modelObject( &model_obj.obj_id, &objOE);
     if( objOE.obj_id.objid != NULL_OBJID ) 
     {
       vdsa$GetStruct(	objID = &objOE.obj_id, 
			name  = "SA_OBJ:category",
			txt   = type );
     }
   } 
   /*
    * object is not a tree node -- model
    */
   else if ( !VDtrIsTreeAncestry ( &model_obj.obj_id ) )
   {
       vdsa$GetStruct(	objID = &model_obj.obj_id, 
			name  = "SA_OBJ:category",
			txt   = type );
   }
   /*
    * a leaf node may not be connected to a model object, like VDct1Base node
    */
   else
   {
     VDtrget_nodeType( &model_obj.obj_id, type );
   } 

   vd$ppl_set_size( which_info = OUTPUT_INFO,
                    size       = 1              );

   vd$ppl_setarg_at_index( which_info = OUTPUT_INFO,
                           index = 0,
                           type  = VD_string,
                           value = type );
   return 1;
}

name()
{
IGRint			count;
IGRchar			temp_str[50], name[DI_PATH_MAX], path[DI_PATH_MAX];
IGRchar			*ptr;
struct GRobj_env	model_obj, row_obj, objOE;

#ifdef MY_DEBUG
   printf("---- VDrow_info - name begin ----\n");
#endif

   name[0]	= '\0';
   temp_str[0]	= '\0';
   path[0]	= '\0';
   ptr		= NULL;
   objOE.obj_id.objid = NULL_OBJID;

   vd$ppl_get_size( which_info = INPUT_INFO,
                    size       = &count );
   if( count < 2 ) return 1;

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 0,
                           value      = &model_obj  );

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 1,
                           value      = &row_obj  );

   /*
    * object is a plate or beam
    */
   if(vdobj$IsAncestryValid (	objID		= &model_obj,
				superClassName	= "VSplate") ||
      vdobj$IsAncestryValid (	objID		= &model_obj,
				superClassName	= "VSbeam") ) 
   {
     vdobj$Get( objID = &model_obj.obj_id, objPath = path );
     ptr = strstr(path, ":ref:");
     if ( ptr != NULL ) ptr = ptr + 5;
     else		ptr = path;
     strcpy( name, ptr);
     vdsa$GetStruct(	objID = &model_obj.obj_id, 
			name  = "SA_AST:StagingTree:0:pcmk",
			txt   = temp_str );
     strcat( name, "-" );
     strcat( name, temp_str );
   }
   /*
    * object is a leaf node of type VDatBase.
    */
   else if (	VDtrIsLeaf ( &model_obj.obj_id) &&
		vdobj$IsAncestryValid (	objID		= &model_obj,
					superClassName	= "VDatBase") ) 
   {
     VDtrget_modelObject( &model_obj.obj_id, &objOE);
     if( objOE.obj_id.objid != NULL_OBJID ) 
     {
       vdobj$Get( objID = &objOE.obj_id, objPath = path );
       ptr = strstr(path, ":ref:");
       if ( ptr != NULL ) ptr = ptr + 5;
       else		ptr = path;
       strcpy( name, ptr);
       vdsa$GetStruct(	objID = &objOE.obj_id, 
			name  = "SA_AST:StagingTree:0:pcmk",
			txt   = temp_str );
       strcat( name, "-" );
       strcat( name, temp_str );
     }
     /*
      * a leaf node may not be connected to a model object, like VDct1Base node
      */
     else
     {
       VDtrget_nodePath( &model_obj.obj_id, name );
     } 
   } 
   /*
    * object is a VDct1Node type.
    */
   else if ( vdobj$IsAncestryValid (	objID		= &model_obj,
					superClassName	= "VDct1Base") ) 
   {
       strcpy( name, "Tree:" );
       vdsa$GetStruct( objID = &model_obj.obj_id,
	       		name = "tree_num",
			txt  = temp_str );
       strcat( name, temp_str );
       strcat( name, ":" );
       vdsa$GetStruct( objID = &model_obj.obj_id,
	       		name = "node_num",
			txt  = temp_str );
       strcat( name, temp_str );
   }
     /*
      * a leaf node may not be connected to a model object, like VDct1Base node
   /*
    * object is a node but not a leaf
    */
   else
   {
     VDtrget_nodePath( &model_obj.obj_id, name );
   }

   vd$ppl_set_size( which_info = OUTPUT_INFO,
                    size       = 1              );

   vd$ppl_setarg_at_index( which_info = OUTPUT_INFO,
                           index = 0,
                           type  = VD_string,
                           value = name );
#ifdef MY_DEBUG
   printf("model_obj: ");vdobj$Print(objOE=&model_obj);
   printf("row_obj:   ");vdobj$Print(objOE=&row_obj);
   printf("objOE if:  ");vdobj$Print(objID=&objOE.obj_id);
   printf("name: [%s]\n", name);
   printf("---- VDrow_info - name return ----\n");
#endif
   return 1;
}

check()
{
IGRint			count, isModified;
IGRchar			temp_str[50], newName[DI_PATH_MAX],oldName[DI_PATH_MAX];
IGRchar			path[DI_PATH_MAX], *oldPtr, *newPtr;
struct GRobj_env	model_obj, row_obj, objOE;

#ifdef MY_DEBUG
   printf("---- VDrow_info - check begin ----\n");
#endif MY_DEBUG

   newName[0]	= '\0';
   temp_str[0]	= '\0';
   path[0]	= '\0';
   oldPtr	= NULL;
   newPtr	= NULL;
   objOE.obj_id.objid = NULL_OBJID;
  

   vd$ppl_get_size( which_info = INPUT_INFO,
                    size       = &count );
   if( count < 3 ) return 1;

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 0,
                           value      = &model_obj  );

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 1,
                           value      = &row_obj  );

   vd$ppl_getarg_at_index( which_info = INPUT_INFO,
                           index      = 2,
                           value      = oldName  );

   if(vdobj$IsAncestryValid (	objID		= &model_obj,
				superClassName	= "VSplate") ||
      vdobj$IsAncestryValid (	objID		= &model_obj,
				superClassName	= "VSbeam") ) 
   {
     vdobj$Get( objID = &model_obj.obj_id, objPath = path );
     newPtr = strstr(path, ":ref:");
     if ( newPtr != NULL )	newPtr = newPtr + 5;
     else			newPtr = path;

     vdsa$GetStruct(	objID = &model_obj.obj_id, 
			name  = "SA_AST:StagingTree:0:pcmk",
			txt   = temp_str );

     sprintf(newName, "%s-%s", newPtr, temp_str);
   }
   /*
    * object is a VDct1Node type.
    */
   else if ( vdobj$IsAncestryValid (	objID		= &model_obj,
					superClassName	= "VDct1Base") ) 
   {
       strcpy( newName, "Tree:" );
       vdsa$GetStruct( objID = &model_obj.obj_id,
	       		name = "tree_num",
			txt  = temp_str );
       strcat( newName, temp_str );
       strcat( newName, ":" );
       vdsa$GetStruct( objID = &model_obj.obj_id,
	       		name = "node_num",
			txt  = temp_str );
       strcat( newName, temp_str );
   }
   else if( VDtrIsLeaf( &model_obj.obj_id) ) 
   {
     VDtrget_modelObject( &model_obj.obj_id, &objOE);
     vdobj$Get( objID = &objOE.obj_id, objPath = path );
     newPtr = strstr(path, ":ref:");

     if ( newPtr != NULL )	newPtr = newPtr + 5;
     else			newPtr = path;

     vdsa$GetStruct(	objID = &objOE.obj_id, 
			name  = "SA_AST:StagingTree:0:pcmk",
			txt   = temp_str );

     sprintf(newName, "%s-%s", newPtr, temp_str);
   }
   else 
   {
     VDtrget_nodePath( &model_obj.obj_id, newName );
   }

   oldPtr = strstr(oldName, ":ref:");
   if( oldPtr != NULL )	oldPtr = oldPtr + 5;
   else			oldPtr = oldName;

   if( !strcmp( oldPtr, newName ) ) {
     isModified = 0;
   }
   else {
     newPtr = strstr(newName, ":usr:");
     if(newPtr != NULL) newPtr = newPtr + 5;
     else		newPtr = newName;

     if(strcmp( oldPtr, newPtr ) )	isModified = 1;
     else				isModified = 0;
   }

   vd$ppl_set_size( which_info = OUTPUT_INFO,
                    size       = 1              );

   vd$ppl_setarg_at_index( which_info = OUTPUT_INFO,
                           index = 0,
                           type  = VD_int,
                           value = &isModified );
#ifdef MY_DEBUG
   printf("model_obj: ");vdobj$Print(objOE=&model_obj);
   printf("row_obj:   ");vdobj$Print(objOE=&row_obj);
   printf("objOE if:  ");vdobj$Print(objID=&objOE.obj_id);
   printf("oldName: [%s]\n", oldName);
   printf("newName: [%s]\n", newName);
   if(oldPtr) printf("oldPtr:  [%s]\n", oldPtr);
   if(newPtr) printf("newPtr:  [%s]\n", newPtr);
   printf("isModified: [%d]\n", isModified);

   printf("---- VDrow_info - check return ----\n");
#endif MY_DEBUG
   return 1;
}
