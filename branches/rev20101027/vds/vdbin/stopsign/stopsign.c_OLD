/* $Id: stopsign.c_OLD,v 1.1 2001/02/22 22:54:10 hans Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:   vds/vdbin/stopsign.c
 *
 * Description: Stop sign Implementation
 *		A process can be stopped if a button(mouse) click
 *		occurs inside the Stopsign window and the process
 *		has a handle for that. This is an independent X11
 *		application which just exchanges signals between
 *		ISDP. There is no image inside the Xwindow as it
 *		is found that if the presence os an image(.gif, .tiff)
 *		turns off the signal exchange after a while
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: stopsign.c_OLD,v $
 *      Revision 1.1  2001/02/22 22:54:10  hans
 *      Fix for TR# MP4704
 *
 *
 * Replaced: vdbin/stopsign/stopsign.c for:  by vsrivast for vds
 *
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 02/05/99  Vinit   Created the file.
 * 01/24/01  ah      The xil directory is obsolete, use Xutil.h
 *----------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>


/*  User Defined Signals  */
#ifndef SIGUSR1
#define SIGUSR1 16
#endif

#ifndef SIGUSR2
#define SIGUSR2 17
#endif

#define MAXCOLORS 256
#define NCOLORS   216		/* colormap entries uesd by this program */

unsigned int   width;
unsigned int   height;
unsigned int   nbands;

void 	 activate_sign( int sig);
void 	 deactivate_sign( int sig);
void 	 open_window ( );

Display*    xdisplay = NULL;
XEvent      xevent;
Window      xwindow;

main(int argc, char **argv)
{
  long ppid;  /* Process id of the Model */

  int  len;

  /*
   *  Get the pathname and the process id of Model from the command line.
   *  At present the Model process forks and starts the stopsign when it just
   *  starts up. The pid of the Model is obtained only in the following manner.
   *  Care should be taken when the program is involved in any other way (if it
   *  is needed!
   */

  ppid = atoi(argv[3]);

  /* Open the XDisplay */

  xdisplay = XOpenDisplay(NULL);

  /* Create the window */

  open_window();

  /* Map the window */

  XMapWindow(xdisplay, xwindow);

  while(1)
  {
    XNextEvent(xdisplay, &xevent);

    if(xevent.xany.type == Expose)
    {
      break;
    }
  }

  /*  Trap the signals from isdp  */

  sigset(SIGUSR1, activate_sign);
  sigset(SIGUSR2, deactivate_sign);

  /*  Wait for Inputs */

  while(1)
  {
    fprintf(stderr, "stopsign: inside 2nd loop BEFORE XNextEvent()\n");

    XPeekEvent(xdisplay, &xevent);
    XNextEvent(xdisplay, &xevent);

    fprintf(stderr, "stopsign: inside 2nd loop AFTER  XNextEvent()\n");

    if(xevent.xany.type == ButtonPress)
    {
        kill(ppid, SIGUSR1);

    } else if(xevent.xany.type == Expose && xevent.xexpose.window == xwindow )
    {
      /* Expose Event */
    }
  }

  /* Close the Xdisplay. But control doesn't reach here. The process gets
     killed when Model process id terminated */

  /* XCloseDisplay(xdisplay); */
}

void deactivate_sign(int sig)
{
  XStoreName( xdisplay, xwindow, "Stop Inactive");
  XFlush(xdisplay);
}

void activate_sign(int sig)
{
  XStoreName( xdisplay, xwindow, "Stop Active");
  XFlush(xdisplay);
}

void open_window ()
{
  unsigned long        bg;
  unsigned long        bd;
  int screen;
  int depth;

  XSetWindowAttributes attrs;
  XSizeHints hints;
  unsigned long mask;

  int bwidth = 2;

  /*
   *  Create the X Window
   */
  screen = DefaultScreen(xdisplay);
  depth  = DefaultDepth(xdisplay, screen);

  bg = WhitePixel(xdisplay, screen);
  bd = BlackPixel(xdisplay, screen);

  attrs.border_pixel      = bd;
  attrs.background_pixel  = bg;
  attrs.override_redirect = True;

  mask = CWBackPixel | CWBorderPixel ;

  xwindow = XCreateWindow(xdisplay, RootWindow(xdisplay, screen),0, 60, 25,25,
                          bwidth, depth, InputOutput, CopyFromParent, mask, &attrs);

  hints.flags = USPosition | USSize;
  hints.x = 0;
  hints.y = 60;

  hints.width = 25;
  hints.height = 25;

  XStoreName( xdisplay, xwindow, "Stop");

  if(xwindow == NULL)
  {
    fprintf(stderr, "Unable to create window\n");
    return;
  }

  XSelectInput(xdisplay, xwindow, ExposureMask | ButtonPressMask | KeyPressMask);
  XSetWMNormalHints(xdisplay, xwindow, &hints);
}
