#include <FI.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "CIforms.h"
#include "msdef.h"
#include "msmacros.h"
#include "grmessage.h"
#include "lcdef.h"

/* form information */
#define FormName                "GRLocInfo"
#define FormLabel               100
#define OutputStdout            12
#define OutputFile              14
#define FileName                15
#define VerboseLocateInfo       23
#define ObjectHit               18
#define ObjectEligible          19
#define ObjectIneligible        20
#define OwnerInfo               24
#define LocateFilterOutput      25

/* ci notification function */
extern int ci_notification();

/* structure required for form notification */
struct CIform_st form_st;

/* form pointer */
Form info_form;

/* global data set on form */
IGRchar info_file[128];
IGRint info_flags, info_stdout;

init()
{
    int sts;

    /* initialize */

    info_form = NULL;
    info_flags = 0;
    info_stdout = FALSE;
    info_file[0] = NULL;

    /* create the information form */

    sts = FIf_new(FormLabel, FormName, ci_notification, &info_form);
    if ((sts != FI_SUCCESS) || (info_form == NULL))
    {
        ex$message(msgnumb = GR_E_FailCrForm);
/*        status("Failed to create form"); */
        printf("sts = %d\n", sts);
        exit;
    }

    /* associate the form with this command object */

    FIf_set_cmd_oid_os(info_form, MY_ID, OM_Gw_current_OS);
}

wakeup()
{
    IGRint state, on, off;

    if (info_form)
    {

        /* set the form to reflect the current settings */

        GRGetLocateInfoOutput(&info_stdout, info_file);
        if (info_stdout)
        {
            on = OutputStdout;
            off = OutputFile;
        }
        else
        {
            on = OutputFile;
            off = OutputStdout;
        }
        FIg_set_state_on(info_form, on);
        FIg_set_state_off(info_form, off);
        FIfld_set_text(info_form, FileName, 0, 0, info_file, FALSE);

        GRGetLocateInfoFlags(&info_flags);
        if (info_flags & GRVerboseLocateInfo) state = TRUE; else state= FALSE;
        FIg_set_state(info_form, VerboseLocateInfo, state);
        if (info_flags & GRObjectHit) state = TRUE; else state= FALSE;
        FIg_set_state(info_form, ObjectHit, state);
        if (info_flags & GRObjectEligible) state = TRUE; else state= FALSE;
        FIg_set_state(info_form, ObjectEligible, state);
        if (info_flags & GRObjectIneligible) state = TRUE; else state= FALSE;
        FIg_set_state(info_form, ObjectIneligible, state);
        if (info_flags & GROwnerInfo) state = TRUE; else state= FALSE;
        FIg_set_state(info_form, OwnerInfo, state);
        if (info_flags & GRLocateFilterOutput) state = TRUE; else state= FALSE;
        FIg_set_state(info_form, LocateFilterOutput, state);

        FIf_display(info_form);
    }
}

sleep()
{
    if (info_form) FIf_erase(info_form);
}

delete()
{
    if (info_form) FIf_delete(info_form);
}

main()
{
    int response, sts;

    if (info_form)
    {
        ex$message(msgnumb = GRC_M_LocInfo);
/*        message("Locate Information"); */

        /* wait for input */

        while (1)
        {
            ci$getevent(response = &response,
                        stackable = TRUE,
                        msgnum = GR_P_SelFrForm);

            if ((response == EX_FORM_FINISHED) || (response == EX_RJT_MOVEON))
            {
                break;
            }
            else
            {
                ex$message(msgnumb = GR_I_InpDiscard);
            }
        }
    }
}

form_notification()
{
    int sel, pos;

    switch (form_st.gadget_label)
    {
      case FI_ACCEPT:
        /* make changes */
        GRPutLocateInfoFlags(info_flags);
        GRPutLocateInfoOutput(info_stdout, info_file);
        /* no break! */

      case FI_CANCEL:
        /* terminate this command */
        ci$put(response = EX_FORM_FINISHED);
        FIf_erase( info_form );
        break;

      case OutputStdout:
        info_stdout = TRUE;
        FIg_set_state_on(info_form, OutputStdout);
        FIg_set_state_off(info_form, OutputFile);
        break;

      case FileName:
        /* no break */

      case OutputFile:
        info_stdout = FALSE;
        FIg_set_state_off(info_form, OutputStdout);
        FIg_set_state_on(info_form, OutputFile);
        FIfld_get_text(info_form, form_st.gadget_label, 0, 0, 128,
                       info_file, &sel, &pos);
        if (info_file[0] == NULL)
            FIg_start_seq(info_form, FileName);
        break;

      case VerboseLocateInfo:
        if (form_st.value)
            info_flags = info_flags | GRVerboseLocateInfo;
        else
            info_flags = info_flags & ~GRVerboseLocateInfo;
        break;

      case ObjectHit:
        if (form_st.value)
            info_flags = info_flags | GRObjectHit;
        else
            info_flags = info_flags & ~GRObjectHit;
        break;

      case ObjectEligible:
        if (form_st.value)
            info_flags = info_flags | GRObjectEligible;
        else
            info_flags = info_flags & ~GRObjectEligible;
        break;

      case ObjectIneligible:
        if (form_st.value)
            info_flags = info_flags | GRObjectIneligible;
        else
            info_flags = info_flags & ~GRObjectIneligible;
        break;

      case OwnerInfo:
        if (form_st.value)
            info_flags = info_flags | GROwnerInfo;
        else
            info_flags = info_flags & ~GROwnerInfo;
        break;

      case LocateFilterOutput:
        if (form_st.value)
            info_flags = info_flags | GRLocateFilterOutput;
        else
            info_flags = info_flags & ~GRLocateFilterOutput;
        break;

      default:
        ex$message(msgnumb = GR_I_InpDiscard);
        break;
    }
}
