
		General Purpose Symbol Table Package

			 Paul L. Hammond
		 	November  6, 1986

0.0	Abstract

	The general purpose symbol table package provides three kinds of
	symbol tables with a uniform functional interface.  These are
	archived in "symtab.a".

	The functional interface is provided by "symtab.h" which provides
	object oriented "virtual functions" for any implementation of
	the symbol table interface.

	The basic symbol table class is provided by "basictab.h",
	The only external symbol defined by this class is "new_basictab".

	A hierarchical symbol table class is provided by "hiersymtab.h",
	This package makes use of the basic symbol table package.

	A usage-recording symbol table class is provided by "usagetab.h",
	This is a subclass of hiersymtab.

1.0	Abstract Symbol Table "Class" Interface

1.1	Symbol Structures

	Items that may be placed in a symbol table must be allocated by the
	caller.  The symbol table package does allocation for the table
	itself but not for the items that are stored in it.

	There is a standard symbol table structure defined in symtab.h.

	  typedef struct symbol *symbol_ptr;
	  struct symbol
	   {
	    char	*name;	   /* The key by which the symbol searched */
	    symbol_ptr	next;	   /* Used internaly by the symbol package */
	    short	level;     /* (see increment_symbol_level 1.2.4)   */
	    short	hash_value;/* result of hashing the name	   */
	   };
           
	This provides storage only for those fields required by the symbol
	table package.  The user of the package would normally need more
	information in the records stored in the table.  This is accomplished
	by making an assumption about the way that C places fields in
	structures.  It is assumed that the first field in the declaration
	of the structure will be the first in the physical structure.
	A pointer to a structure is assumed to be the same as a pointer
	to the first field in the structure.

	To use this, the user declares some other structure containing
	whatever information is needed.  For example :

	 struct tokensymbol
	  {
	   struct symbol s;	/* from symtab.cls */
	   int tokenvalue;	/* info needed by user */
	  };

	The presence of the "struct symbol" as the first field of the
	structure is required for structures of this type to be placed
	in the symbol table.  The name given to this field has no effect
	on the symbol table package.  The user must allocate the structure
	and assign a value to the "name" field in the "struct symbol"
	field ("s" in this case).  Having done this, the structure can
	be entered into a symbol table by invoking "enter_symbol".

1.2	Functional Interface via symtab.h

	To use the basic symbol table package, you must 

	 #include "basictab.h"

	before calling any of the symbol table functions.

	This is required because all of these "functions" are actually
	macros.

1.2.1   Creating a new symbol table

	It is possible to have many symbol tables in existance at one time.
	When any operation is performed on a symbol table, a pointer to
	the table must be passed as a parameter.  The user must declare
	a pointer to be used to point to the symbol table.

	  basictab_ptr my_table;

	To construct a new symbol table, call the "new_basictab" function.
	
	  my_table = new_basictab (251, stderr);

	The first parameter to the "new_basictab" function is the table
	size.  For best performance, this should be a prime number.  The
	size of the table determines the performance of the table.  A larger
	table will produce faster lookup on average.  If you intend to put
	only a few symbols in the table, there is no need for a large table.
	The minimum size is 1.  A table size of 1 results in a simple
	linked list.

	The second parameter to the "new_basictab" function is the log
	stream to be used to log all symbol table operations.  If a zero
	is passed, no logging will be done.  This is intended to be used
	as a debugging feature.

1.2.2   Entering a symbol

	To enter a symbol in the table, allocate it, fill in the "name"
	field (and whatever information YOU require) and call "enter_symbol".

	 enter_symbol (my_table, pointer_to_my_symbol);

	A symbol can be entered into only one table at a time.  Entering
	a symbol into two tables will currupt both tables.

	Note that the the "name" field is a pointer.  This is to provided
	for maximum flexiblility.  The name string may be shared with
	some other data structure as long as it does not change while the
	symbol is in the table.

	Here is an example of an easy way to allocate storage for the name
	and the structure at the same time.

	 enter_new_token (tokname, tok)
          char *tokname;
	  int  tok;
	  {
	   struct tokensymbol *p;

	   p = (struct tokensymbol *) malloc(sizeof(*p) + strlen(tokname)+1);
	   p->s.name = strcpy (p+1,tokname);/*ain't pointer 'rithmatic neat!*/
	   p->tokenvalue = tok;

	   enter_symbol (my_table, p);
	  }

1.2.2.4	Entering a symbol again

	Once a symbol has been entered into a table, its hash_value has
	been calculated.  If it is removed from the table and is to be 
	entered into the table again, the "enter_prehashed_symbol"
	function can be used.

	  enter_prehashed_symbol (my_table, pointer_to_my_symbol);

	This will be slightly faster than "enter_symbol" - particularly
	if the name is long.

	Any symbol entered in this fashion must have been previously entered
	into a table with the same size.
	
1.2.3   Looking up a symbol

	To lookup a symbol call "lookup_symbol".  It returns a pointer to
	the symbol.  If no symbol is found with the given name, a NULL
	pointer is returned.

	 struct tokensymbol *p;

	 p = lookup_symbol (my_table, "the_name");

	The second parameter to the lookup_symbol function is a pointer
	to a string.

1.2.4   Symbol table level

	It is often usefull to have a symbol table with "levels".  This
	is most often used when a group of symbols is to have a limited
	scope.  Only nested scopes can be handled by this mechanism.
	Interlocking scopes would require something more elaborate.

  	If a symbol is entered which has the same name as a symbol 
	previously entered, it will take precedence over the previous
	symbol - only the most recently entered symbol will be found
	by "lookup_symbol".

	This characteristic may be used to achieve scope by the use
	of symbol table level.  The symbol table has a property called
	"level".  When the table is created, the level is set to zero.
	When a symbol is entered into the symbol table it is entered
	at the current level.  Higher level is interpreted as more
	local scope.  When entering a new scope, call 

	 increment_symbol_level (my_table);

	To remove symbols entered at the current level and reduce
	the level,
	
	 decrement_symbol_level (my_table, my_dealloc_function);

	The second parameter of decrement_symbol_level is a pointer
	to a deallocation function.  This function will be called
	for each symbol record purged from the table.  If a NULL
	is passed, the symbols will be purged but no deallocation
	will be performed.

	The deallocation function is passed a pointer to the symbol.
	The dealloc_function might do anything to the symbols.  It
	might simply put then in a linked list for later use.

	To determine the current symbol table level, call

	 symbol_table_level (my_table); 

	This returns an integer.
	

1.2.5   Looking up a local symbol

	If the levels feature of the symbol table is being used, it may
	be desirable to look up a symbol which was entered at the current
	symbol table level.  This would be used to lookup a symbol which
	must be in local scope or to determine if a name has already
	been entered in the local scope.  The function "lookup_local_symbol"
	works like "lookup_symbol" except that it only looks for symbols
	at the current level.  If the name is not found at the current
	level, it returns NULL.

1.2.6   Removing a symbol

	To remove a symbol from the table you must have a pointer to the
	symbol.  If you have only the name, you must first lookup the symbol
	in the table.

	 struct tokensymbol *p;

	 p = lookup_symbol (my_table, "my_name");

	 remove_symbol (my_table, p);

	If the symbol is not in the table, this will have no effect.

1.2.7	Processing the symbols in a symbol table

	To perform some function on all symbols in a symbol table, the
	"process_symbol_table" or "process_local_symbols" function
	may be used.

	 process_symbol_table (my_table, my_function);

	This call will result in "my_function" being called for
	each symbol in "my_table".  This function will be passed
	a pointer to each symbol in the table.  If a NULL function
	pointer is passed, nothing will be done.

	The "process_local_symbols" function will process only those
	symbols at the current symbol table level.

1.2.8   Deleting a symbol table

	To delete a symbol table, call delete_symbol_table.

	 delete_symbol_table (my_table, dealloc_function);

	The dealloc_function will be called for each symbol in
	the table.  If a NULL function pointer is passed, the
	symbols will be purged from the table but they will not
	be deallocated.

	The symbol table itself will be deallocated.  The pointer
	to the symbol table is then invalid and can no longer be
	used unless it is assigned a new value.

1.2.9	Write protection

	A symbol table may be write protected by invoking

	 symtab_write_protect (my_table);

	This will inhibit

	 delete_symbol_table
	 enter_symbol
	 enter_prehashed_symbol
	 remove_symbol
	 increment_symbol_level
	 decrement_symbol_level

	The write protection may be removed by invoking

	 symtab_write_enable (my_table);


1.3	"Message" Interface via symtab.cls

	Each of the function described above can be invoked via
	a "message" style inteface.  For example, "lookup_symbol"
	can be invoked as :

	 my_table->send->lookup (my_table, "my_symbol");

	Consult "symtab.h" for the names of the "messages".
	These are fields in struct symtab_class.

2.0	Basic Symbol Table Class

	The basic symbol table class provides the functionality described
	above.  It is implemented in "basictab.c".

3.0	Hierarchical Symbol Table Class

	The hierarchical symbol table class provides some additional
	functionality.  It uses the basic symbol table class (you must
	link with both).  The difference are described below.

	new_hiersymtab - takes the same arguments as new_symbol_table
			 and should be called instead.

	hiersymtab_attach - This virtual function is used to attach one
			    hierarchical symbol table to another.  The
		 	    newly attached table is inserted just above
			    the existing one.

	process_local_symbols - processes a whole basic symbol table
				without regard for level.

	lookup_local_symbol   - search only to lowest basic symbol table.

	process_symbol_table  - invokes the caller-supplied function on
				all symbols with unique names starting
				from the bottom of the hierarchy.

	delete_symbol_table   - deletes all the hierarchy structure but
				only deletes the lowest basic symbol
				table in the hierarchy.

	increment_symbol_level,
	decrement_symbol_level,
	symbol_table_level    - all of these apply only to the lowest basic
				symbol table in the hierarchy.
	
4.0	Usage-Recording Symbol Tables

	The usage-recording symbol table class is a subclass of hiersymtab.
	These tables have the ability to record which symbols have looked up
	in the table.  This is used by opp to record compilation dependencies
	when linked with discos to produce a data dictionary.

5.0	Customized Symbol Tables Using Abstract Interface

	Other symbol table packages can be added using the same interface
	provided by "symtab.h" and "symtab.cl".  They need only provide
	a unique "new" function which can be called to create instances
	of the symbol table.
