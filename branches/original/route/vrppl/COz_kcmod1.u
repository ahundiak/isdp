/* $Id: COz_kcmod1.u,v 1.6 2001/09/21 20:14:50 anand Exp $  */

/***************************************************************************
 * I/ROUTE
 *
 * File:        vrppl/COz_kcmod1.u
 *
 * Description:
 *     Added for macro maintenance and 2.2 - 2,3 conversions
 *      formerly known as k_cache_mod.u
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COz_kcmod1.u,v $
 *      Revision 1.6  2001/09/21 20:14:50  anand
 *      Set NbObj to zero whenever objects pointer is set to NULL.
 *
 *      Revision 1.5  2001/08/21 17:44:25  anand
 *      *** empty log message ***
 *
 *      Revision 1.4  2001/08/20 23:47:43  anand
 *      JTS TRs MP5417 and MP5485
 *
 *      Revision 1.3  2001/02/20 01:16:01  build
 *      Replaced v_dbgmacros.h with product specific dbgmacros.h
 *
 *      Revision 1.2  2001/01/12 23:40:55  anand
 *      SP merge
 *
# Revision 1.1  2000/05/17  22:55:22  pinnacle
# Created: route/vrppl/COz_kcmod.u by apazhani for Service Pack
#
# Revision 1.1  1998/04/30  10:52:34  pinnacle
# ROUTE 2.5.1
#
# Revision 1.1  1997/07/17  18:30:54  pinnacle
# route 2.5
#
# Revision 1.1  1996/07/25  18:25:44  pinnacle
# Creation of Route 241 project
#
# Revision 1.2  1996/05/28  21:15:56  pinnacle
# Replaced: vrppl/COz_kcmod.u for:  by hverstee for route240
#
# Revision 1.1  1996/05/24  19:58:04  pinnacle
# Created: vrppl/COz_kcmod.u by hverstee for route240
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/24/96         hv             creation date
 *      05/17/00         Alwin          Fixed the crash due to the wrong
 *					arguments passed for ACreturn_foot Msg
 *   Aug 20 2001	Anand		Revamped PPL for TR 5417. Also tested
 *					against TR 5485. Renamed PPL to
 *					COz_kcmod1.u in order to avoid
 *					accidentally being called by remcache.
 *   Aug 21 2001	Anand		Streamline process of checking for
 *					non-dangle/non-hanger/non-nozzle/valid
 *					component.
 *
 ***************************************************************************/

#include "VDppl.h"
#include "ndmacros.h"
#include "AS_status.h"
#include "vrparameters.h"
#include "vrmacros.h"
#include "VRdef.h"
#include "VRcompdef.h"
#include "vrdbgmacros.h"

IGRboolean VRVrfyOK4kcmod(CompId)
struct GRid *CompId;
{
    IGRshort	nType;
    IGRint	status;
    IGRlong	retmsg;
    GRclassid	ClassId;
    extern GRclassid	OPP_VRHanger_class_id, OPP_VRNozzle_class_id;

    SetProc(VRVrfyOK4kcmod); Begin
    __DBGpr_obj("Component being checked for kcmod",*CompId);

    /* Exclude the dangles and supports from the list supports not yet
     * supported */
    status = om$get_classid( osnum	= CompId->osnum,
			     objid	= CompId->objid,
			     p_classid	= &ClassId );
    if( !(status&1) )
    {
	__DBGpr_com(" Not a valid obj id");
	End
	return FALSE;
    }

    if( om$is_ancestry_valid( subclassid	= ClassId,
			      superclassid	= OPP_VRHanger_class_id ) 
				  == OM_S_SUCCESS )
    {
	__DBGpr_com(" Not processing hangers");
	End
	return FALSE;
    }

    if( om$is_ancestry_valid( subclassid	= ClassId,
			      superclassid	= OPP_VRNozzle_class_id ) 
				  == OM_S_SUCCESS )
    {
	__DBGpr_com(" Not processing nozzles");
	End
	return FALSE;
    }

    /* Get the cmp's item number & check if it is a dangle */
    status = ci$send( msg	= message VRGeneric.VRGetSysType( &retmsg,
								  &nType ),
		      targetid	= CompId->objid,
		      targetos	= CompId->osnum );
    as$status();
    __DBGpr_int(" Item number of comp",nType);
    if ( nType == VR_DANGLING )
    {
	__DBGpr_com(" Not processing dangles");
	End
	return FALSE;
    }

    __DBGpr_com(" Comp okay for kcmod!");
    End
    return TRUE;
}

VRUpdCacheModel ( NbObj, objects, md_env )
IGRint 		NbObj;
struct GRid 	*objects;
struct GRmd_env	*md_env;
{
    IGRint	i, status, j, NbCaches, direct_index;
    IGRlong	retmsg;
    struct GRid	Header, ModelMgr, *CacheIds, PbId;
    IGRshort	nType;
    IGRdouble	dMat[16];
    GRclassid	ClassId;
    IGRboolean	*bProcessed;

    IGRchar	CurSpec[10], /* 10 is size of VR[PHR]DB_CHAR_CLASS */
    		szName[128];
    struct ret_struct	StrInfo;
    extern GRclassid	OPP_ACheader_class_id;

    __DBGpr_com("Entered VRUpdCacheModel");

    if( ( objects == NULL ) || ( NbObj == 0 ) )
    {
       __DBGpr_com( " Either NbObj == 0 or Memory not allocated " );
       __DBGpr_com("Leaving VRUpdCacheModel");
       return OM_S_SUCCESS;
    }

    /* allocate the memory */
    bProcessed = (IGRboolean *) calloc( NbObj, sizeof( IGRboolean ) );
    if( bProcessed == NULL )
    {
	printf("Could not allocate dynamic memory for bProcessed\n");
	goto wrapup;
    }


    NbCaches = 0;
    CacheIds = NULL;
    __DBGpr_obj(" Valid mod env?",md_env->md_id );

    /* Delete the Parameter box(es) */
    if( NbObj == 1 )
    {
	/* Use the comp's Model Id for getting the path of the DB cache */
	__DBGpr_obj(" Attempting to get PbId for",*objects);
	status =
	ci$send(msg	 = message VRGeneric.VRGetModel(&retmsg,&PbId,md_env),
		targetid = objects->objid,
		targetos = objects->osnum );
	__CheckRC( status, retmsg, "Failed to get PbId!", wrapup );
	__DBGpr_obj(" Parameter box Id for 0th object", PbId );

	NbCaches = 1;
	CacheIds = &PbId;
    }
    else
    {
	/* Use the Model ID of the first valid Component for getting the path
	 * of the DB cache */
	for( i=0 ; i<NbObj ; i=i+1 )
	    if( VRVrfyOK4kcmod(&objects[i]) == TRUE )
		break;

	__DBGpr_obj(" Attempting to get PbId for",objects[i]);
	status =
	ci$send(msg	 = message VRGeneric.VRGetModel(&retmsg,&PbId,md_env),
		targetid = objects[i].objid,
		targetos = objects[i].osnum );
	__CheckRC( status, retmsg, "Failed to get PbId!", wrapup );
	__DBGpr_obj(" Parameter box Id for 0th object", PbId );

	status = di$untranslate( objname= szName,
				 objid	= PbId.objid,
				 osnum	= PbId.osnum );
	for( j=strlen(szName) ; szName[j]!=':' ; j=j-1 )
	    ;
	szName[j]='\0';
	__DBGpr_str(" Path of DB cache", szName);

	status = di$find( start_dir	= szName,
			  regexp	= "*",
			  grids		= &CacheIds,
			  ptr		= &NbCaches );
	as$status();
    }

    for ( i=0; i<NbCaches; i=i+1 )
    {	
	__DBGpr_obj(" attempting to delete PB",CacheIds[i]);
	/* Check if valid object first */
	status = om$get_classid( osnum	= CacheIds[i].osnum,
				 objid	= CacheIds[i].objid,
				 p_classid	= &ClassId );
	as$status();
	if( ! (status&1) )
	    continue;

	status =
	ci$send( msg =	message ACrg_collect.ACset_list_attribute( &retmsg,
								   0, NULL ),
		 targetid = CacheIds[i].objid,
		 targetos = CacheIds[i].osnum );
	as$status()

	status =
	ci$send( msg = message GRvg.GRchgname( &retmsg, md_env, "" ),
		 targetid = CacheIds[i].objid,
		 targetos = CacheIds[i].osnum );
	as$status( );

	/*A set the state of pb to "delete if there are no children" */
	status = ci$send( msg	   = message NDnode.NDchg_state(
						  ( (IGRchar) ND_DEL_NO_CH ),
						  ( (IGRchar) ND_DEL_NO_CH ) ),
			  targetid = CacheIds[i].objid,
			  targetos = CacheIds[i].osnum );
	as$status() 
    }
    if( NbCaches>1 )
    {
	free( CacheIds );
	CacheIds=NULL;
    }

    /*A create the cache and edit the macro */
    __DBGpr_com(" create the cache and edit the macro");
    for (i=0; i<NbObj; i=i+1 )
    {	
	if( bProcessed[i] )
	    continue;

	if( VRVrfyOK4kcmod(&objects[i]) != TRUE )
	    continue;

	direct_index=-1;
	status =
	ci$send( msg = message ACncpx.ACgive_structure( (int *)&retmsg,
							 &direct_index,
							 VR_N_CLASS_AN,
							 &StrInfo, md_env ),
		 targetid = objects[i].objid,
		 targetos = objects[i].osnum );
	strcpy( CurSpec, StrInfo.var.text_st.text_string ); 
	__DBGpr_str("Processing for spec",CurSpec); 

	for( j=i ; j<NbObj ; j=j+1 )
	{
	    if( j != i )
	    {
		status =
		ci$send( msg = message ACncpx.ACgive_structure( (int *)&retmsg,
								 &direct_index,
								 VR_N_CLASS_AN,
								 &StrInfo,
								 md_env ),
			 targetid = objects[j].objid,
			 targetos = objects[j].osnum );
		if( strcmp( CurSpec, StrInfo.var.text_st.text_string ) != 0 )
		    continue;
	    }

	    __DBGpr_obj(" Component Id ", objects[i]);

	    /* -- Recompute Component -- */
	    /* -- to make sure that the macro is edited -- */
	    PbId.objid = NULL_OBJID;
	    status =
	    ci$send( msg      = message VRGeneric.VRGetMacro( &retmsg,
							szName,
							(char *)NULL,
							(IGRshort *) NULL, 
							&PbId,
							(IGRint *) NULL,
							(IGRchar ***) NULL,
							(char *) NULL,
							md_env ),
		     targetid = objects[j].objid,
		     targetos = objects[j].osnum );
	    as$status();
	    __DBGpr_str(" Macro name", szName );

	    bProcessed[j]=TRUE;

	    /* -- Get graphics (only ACheaders) -- */
	    __DBGpr_com(" Get  graphics - ACheader");
	    status = ci$send( msg = message ACncpx.ACreturn_foot( &retmsg,
								  "graphics",
								  &Header,
								  &nType,
								  dMat ),
			      targetid = objects[j].objid,
			      targetos = objects[j].osnum);
	    as$status();

	    __DBGpr_obj( " Graphics Id ", Header );

	    status = om$get_classid( osnum	= Header.osnum,
				     objid	= Header.objid,
				     p_classid	= &ClassId );
	    if( ! (status&1))
		continue;

	    if( om$is_ancestry_valid( subclassid   = ClassId,
				      superclassid = OPP_ACheader_class_id )
						  == OM_S_SUCCESS )
	    {
		/*		ShowObj ( &Header ); */

		/* -- Get ACmodel Mgr from ACheader -- */
		__DBGpr_com("Get Model mgr");
		status =
		ci$send( msg = message ACheader.ACget_model_mgr(&retmsg,
								&ModelMgr),
			 targetid = Header.objid,
			 targetos = Header.osnum);
		as$status();

		if (! (status & 1) )
		    continue;

		/*		ShowObj ( &ModelMgr ); */

		/* -- Delete Model Mgr -- */

		__DBGpr_com( " Delete Model Mgr " );
		status = ci$send( msg   = message ACmodel_mgr.delete(0),
				  targetid = ModelMgr.objid,
				  targetos = ModelMgr.osnum );
		as$status();

		if( szName[0] == '\0' )
		    continue;

		status = ci$send( msg	   = message ACcpx.ACattach( &retmsg,
								     szName ),
				  targetid = Header.objid,
				  targetos = Header.osnum );
		as$status();
	    }

	    /* -- Recompute Component -- */
	    status =
	    ci$send( msg	   = message VRGeneric.VRGetStatus( &retmsg,
								    &nType ),
			      targetid = objects[j].objid,
			      targetos = objects[j].osnum );
	    as$status();

	    if( nType & VR_CORRECTION )
		continue;

	    nType = ND_COMP;
	    nd$wait_batch( type		= GR_GEOM_POSTED,
			   l_object	= &objects[j],
			   l_obj_info	= &nType,
			   nb_obj	= 1 );

	    /*
	    status =
	    ci$send( msg      = message NDnode.NDs_compute_node( &retmsg,
								 0, md_env),
		     targetid = objects[j].objid,
		     targetos = objects[j].osnum );
	    as$status();
	    */
	}
    }

wrapup :
    if ( CacheIds )
    { 
	free( CacheIds ); 
	CacheIds = NULL; 
    }
    if ( bProcessed )
    { 
	free( bProcessed ); 
	bProcessed = NULL; 
    }
    __DBGpr_com("Leaving VRUpdCacheModel");
    return OM_S_SUCCESS;
}

int main( argc, argv )
int	argc;
char	*argv[];
{
    IGRboolean	doPipe, doHvac, doRway;
    IGRint	status, NbObj, response;
    IGRlong	retmsg;
    struct GRid	CompObj, *objects;
    struct GRmd_env	md_env;
    extern	VDchkIfMacsUptoDate(), VDobjInActiveSpace();
    extern GRclassid	OPP_VRPiping_class_id,
    			OPP_VRHvac_class_id,
			OPP_VRRway_class_id;

    __DBGpr_com("Entered PPL");

    if ( argc > 1 )
    {
	if ( *argv[1] == 'P'  ||  *argv[1] == 'p' )
	{
	    doPipe = TRUE;
	    doHvac = FALSE;
	    doRway = FALSE;
	}
	else if ( *argv[1] == 'H'  ||  *argv[1] == 'h' )
	{
	    doPipe = FALSE;
	    doHvac = TRUE;
	    doRway = FALSE;
	}
	else if ( *argv[1] == 'R'  ||  *argv[1] == 'r' )
	{
	    doPipe = FALSE;
	    doHvac = FALSE;
	    doRway = TRUE;
	}
	else if ( *argv[1] == 'A'  ||  *argv[1] == 'a' )
	{
	    doPipe = TRUE;
	    doHvac = TRUE;
	    doRway = TRUE;
	}
    }
    else
    {
	ci$locate( obj		= &CompObj.objid,
		   osnum	= &CompObj.osnum,
		   response	= &response,
		   owner_action = LC_RIGID_COMP | LC_RIGID_OWNER | LC_FLEX_COMP,
		   md_env	= &md_env,
		   classes	= "VRGeneric",
		   prompt	= "Identify component/Move-on for All" );

	if( response == DATA )
	{
	    __DBGpr_obj(" Component Selected", CompObj );
	    VRUpdCacheModel( 1, &CompObj, &md_env );
	    __DBGpr_com("Leaving PPL");
	    return OM_S_SUCCESS;
	}
	else if( response == RESET )
	{
	    doPipe = TRUE;
	    doHvac = TRUE;
	    doRway = TRUE;
	}
	else
	    exit;
    }

    ci$get_module_info( md_env = &md_env );
    objects = NULL;
    NbObj = 0;

    if( doPipe )
    {
	__DBGpr_com("vr$select_component for doPipe");
	/*
	status = vr$select_component( pMsg 	= &retmsg,
				      Product 	= VR_PIPING,
				      pAddrList	= &objects,
				      pNumber	= &NbObj );
	as$status();
	*/
	VDobjInActiveSpace( &retmsg, &NbObj, &objects, OPP_VRPiping_class_id );

	if( NbObj )
	    VRUpdCacheModel( NbObj, objects, &md_env );
	else
	    printf("No Piping objects found in file\n");
    }
    if( objects )
    {
	free( objects );
	objects = NULL;
	NbObj = 0;
    }

    if( doHvac )
    {
	__DBGpr_com("vr$select_component for doHvac");
	/*
	status = vr$select_component( pMsg 	= &retmsg,
				      Product 	= VR_HVAC,
				      pAddrList	= &objects,
				      pNumber	= &NbObj );
	as$status();
	*/
	VDobjInActiveSpace( &retmsg, &NbObj, &objects, OPP_VRHvac_class_id );

	if( NbObj )
	    VRUpdCacheModel( NbObj, objects, &md_env );
	else
	    printf("No HVAC objects found in file\n");
    }
    if( objects )
    {
	free( objects );
	objects = NULL;
	NbObj = 0;
    }

    if( doRway )
    {
	__DBGpr_com("vr$select_component for doRway");
	/*
	status = vr$select_component( pMsg 	= &retmsg,
				      Product 	= VR_RWAY,
				      pAddrList	= &objects,
				      pNumber	= &NbObj );
	as$status();
	*/
	VDobjInActiveSpace( &retmsg, &NbObj, &objects, OPP_VRRway_class_id );

	if( NbObj )
	    VRUpdCacheModel( NbObj, objects, &md_env );
	else
	    printf("No Raceway objects found in file\n");
    }
    if( objects )
    {
	free( objects );
	objects = NULL;
	NbObj = 0;
    }

    /* Added as an overkill */
    /* VDchkIfMacsUptoDate(2); */

    nd$exec_batch();

    __DBGpr_com("Leaving PPL");
    return OM_S_SUCCESS;
}
