/* $Id: COz_RmTolPl.u,v 1.1 2001/10/25 19:30:33 anand Exp $  */

/***************************************************************************
 * I/ROUTE
 *
 * File:	vrppl/COz_RmTolPl.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_RmTolPl.u,v $
 *	Revision 1.1  2001/10/25 19:30:33  anand
 *	JTS TRs 5649, 5651 and 5652.
 *	
 *	
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 *			Anand		creation
 *
 ***************************************************************************/

#include "VDppl.h"
#include "vrdbgmacros.h"
#include "AS_status.h"
#include "vdVALmacros.h"

main()
{
    /* Preliminaries - declare and initialise.*/
    IGRboolean	bWhichEnd;
    IGRint	i, j, k, l, NumCmps, NbSups, status, NbPlnChld, NumClean;
    IGRint	nWhatToDo, NumIdentPln, TotIdenPlan, IdenPlnIndx[24];
    IGRlong	msg;
    IGRchar	MsgStr[128];
    struct GRid	*CompId, SupId[4], *PlnId, *PlnChldId;
    struct GRmd_env	md_env;
    struct IGRplane	*PlnInfo;
    extern GRclassid	OPP_VRComponent_class_id;
    extern VDobjInActiveSpace();

    CompId  = NULL;
    PlnInfo = NULL;
    PlnId   = NULL;
    NumCmps = 0;
    NbSups  = 0;
    NumClean= 0;
    TotIdenPlan = 0;
    NumIdentPln = 0;

    /* Get module environment.*/
    ci$get_module_info( md_env = &md_env );

    vd$VAL_openLog();

    /* Get all VRComponents in file.*/
    VDobjInActiveSpace( &msg, &NumCmps, &CompId, OPP_VRComponent_class_id );
    __DBGpr_int(" Number of components in file", NumCmps );

    do
    {
	ci$get( prompt	= "Report [0]/Prompt [1]/Execute [2] <0/1/2>",
		value	= nWhatToDo );
	__DBGpr_int(" User entered", nWhatToDo );
    }
    while( nWhatToDo != 0 && nWhatToDo != 1 && nWhatToDo != 2 );

    /* For each Component ...*/
    for( i=0 ; i<NumCmps ; i=i+1 )
    {
	__DBGpr_obj(" Processing objid", CompId[i] );

	/* ... get all of its control segments,*/
	status = ci$send( msg = message VRGeneric.VRGetSupports( &msg, 4,
								 SupId,
								 &NbSups ),
			  targetid = CompId[i].objid,
			  targetos = CompId[i].osnum );
	as$status();

	/* ... if segmentS do not intersect at component, skip to next,*/
	if( NbSups < 2 )
	    continue;

	__DBGpr_int("\n\n\tAllocating storage for plane info", NbSups );
	PlnId = (struct GRid *) calloc( 3*NbSups, sizeof(struct GRid) );
	PlnInfo = (struct IGRplane *) calloc( 3*NbSups,
					      sizeof(struct IGRplane) );

	/* ... for each of those control segments ...*/
	for( j=0 ; j<NbSups ; j=j+1 )
	{
	    __DBGpr_obj(" Processing seg id", SupId[j] );
	    /* ... get topology (IGRplane structure) of all its planes,*/

	    for( k=0 ; k<3 ; k=k+1 )
	    {
		PlnInfo[3*j+k].point  = (double *) calloc( 3, sizeof(double) );
		PlnInfo[3*j+k].normal = (double *) calloc( 3, sizeof(double) );
	    }

	    status = ci$send( msg = message VRGeneric.VRGetIndex( &msg,
								  &SupId[j],
								  &bWhichEnd ),
			      targetid = CompId[i].objid,
			      targetos = CompId[i].osnum );

	    if( bWhichEnd == 0 )
	    {
		__DBGpr_com(" Take start plane, disregard end plane");
		status = ci$send( msg = message VRCnrlSeg.VRGetTopo( &msg, NULL,
								&PlnInfo[3*j+0],
								&PlnInfo[3*j+1],
								&PlnInfo[3*j+2],
								NULL, &md_env ),
			      targetid = SupId[j].objid,
			      targetos = SupId[j].osnum );
		as$status();

		status = ci$send( msg = message VRCnrlSeg.VRget_planes( &msg,
								&PlnId[3*j+0],
								&PlnId[3*j+1],
								&PlnId[3*j+2],
								NULL ),
				  targetid = SupId[j].objid,
				  targetos = SupId[j].osnum );
		as$status();
	    }
	    else
	    {
		__DBGpr_com(" Take end plane, disregard start plane");
		status = ci$send( msg = message VRCnrlSeg.VRGetTopo( &msg, NULL,
								&PlnInfo[3*j+0],
								&PlnInfo[3*j+1],
								NULL,
								&PlnInfo[3*j+2],
								&md_env ),
			      targetid = SupId[j].objid,
			      targetos = SupId[j].osnum );
		as$status();

		status = ci$send( msg = message VRCnrlSeg.VRget_planes( &msg,
								&PlnId[3*j+0],
								&PlnId[3*j+1],
								NULL,
								&PlnId[3*j+2] ),
				  targetid = SupId[j].objid,
				  targetos = SupId[j].osnum );
		as$status();
	    }

#if defined(vdsDEBUG)
    for( k=0 ; k<3 ; k=k+1 )
	printf("PLANE %d\n\tObjid %d,%5d\n\tOrigin: %lf, %lf, %lf\n\tNormal: %lf, %lf, %lf\n",
						3*j+k,
						PlnId[3*j+k].osnum,
						PlnId[3*j+k].objid,
						PlnInfo[3*j+k].point[0],
						PlnInfo[3*j+k].point[1],
						PlnInfo[3*j+k].point[2],
						PlnInfo[3*j+k].normal[0],
						PlnInfo[3*j+k].normal[1],
						PlnInfo[3*j+k].normal[2]);
#elif defined(DBG_PROD_NAME)
    if( DBG_Gb_dbg & DBG_PROD )
	for( k=0 ; k<3 ; k=k+1 )
	    fprintf( DBG_Gb_Fp, "PLANE %d\n\tObjid %d,%5d\n\tOrigin: %lf, %lf, %lf\n\tNormal: %lf, %lf, %lf\n",
						3*j+k,
						PlnId[3*j+k].osnum,
						PlnId[3*j+k].objid,
						PlnInfo[3*j+k].point[0],
						PlnInfo[3*j+k].point[1],
						PlnInfo[3*j+k].point[2],
						PlnInfo[3*j+k].normal[0],
						PlnInfo[3*j+k].normal[1],
						PlnInfo[3*j+k].normal[2]);

#endif
	}

	/* ... find all planes that are identical at this component,*/
	TotIdenPlan=0;
	for( j=0 ; j<NbSups-1 ; j=j+1 )
	{
	    for( k=j+1 ; k<NbSups ; k=k+1 )
	    {
		check_coin( &msg, 3, &PlnInfo[3*j], &PlnInfo[3*k],
			    &NumIdentPln, &IdenPlnIndx[TotIdenPlan] );

		for( l=TotIdenPlan ; l<TotIdenPlan+2*NumIdentPln ; l=l+2 )
		{
		    IdenPlnIndx[l+0] = IdenPlnIndx[l+0] + 3*j;
		    IdenPlnIndx[l+1] = IdenPlnIndx[l+1] + 3*k;
		    __DBGpr_int("Plane with index	  ", IdenPlnIndx[l+0]);
		    __DBGpr_obj(" whose objid is", PlnId[IdenPlnIndx[l+0]]);
		    __DBGpr_int("... is identical to plane", IdenPlnIndx[l+1]);
		    __DBGpr_obj(" whose objid is", PlnId[IdenPlnIndx[l+1]]);
		}
		TotIdenPlan = TotIdenPlan + 2*NumIdentPln;
	    }
	}

	/* Swap the planes that are identical on the children. */
	for( j=0 ; j<TotIdenPlan ; j=j+2 )
	{
	    if( PlnId[ IdenPlnIndx[j] ].objid ==
					PlnId[ IdenPlnIndx[j+1] ].objid &&
		PlnId[ IdenPlnIndx[j] ].osnum ==
					PlnId[ IdenPlnIndx[j+1] ].osnum )
		continue;

	    __DBGpr_obj("*** PLANE TO BE SWAPPED", PlnId[IdenPlnIndx[j]]);
	    __DBGpr_obj("WITH PLANE ***", PlnId[IdenPlnIndx[j+1]]);

	    vd$VAL_addObject( GRid	= PlnId[ IdenPlnIndx[j  ] ],
			      PreText	= "The plane with" );
	    vd$VAL_addObject( GRid	= PlnId[ IdenPlnIndx[j+1] ],
			      PreText	= "... replaced by plane with" );

	    status = ci$send( msg      = message NDnode.NDget_objects(
						       ND_CHILDREN | ND_IN_BUF,
						       NULL, 0, &PlnChldId,
						       0, OM_K_MAXINT,
						       &NbPlnChld ),
			      targetid = PlnId[ IdenPlnIndx[j] ].objid,
			      targetos = PlnId[ IdenPlnIndx[j] ].osnum );
	    as$status();

	    sprintf( MsgStr, "Swapping planes affect %d object(s)", NbPlnChld );
	    vd$VAL_addInfo( Text = MsgStr );
	    if( nWhatToDo == 0 )
		continue;

	    if( nWhatToDo == 1 )
	    {
		UI_status(MsgStr);
		sprintf(MsgStr,"Replace plane [%d,%d] with plane [%d,%d]? <y>",
					     PlnId[ IdenPlnIndx[j+0] ].osnum,
					     PlnId[ IdenPlnIndx[j+0] ].objid,
					     PlnId[ IdenPlnIndx[j+1] ].osnum,
					     PlnId[ IdenPlnIndx[j+1] ].objid );
		ci$get( prompt	= MsgStr,
			string	= MsgStr );
		__DBGpr_str(" String returned by user", MsgStr );
		if( MsgStr[0] == 'N' || MsgStr[0] == 'n' )
		    continue;
	    }

	    for( k=0 ; k<NbPlnChld ; k=k+1 )
	    {
		__DBGpr_obj("swapping parents on child", PlnChldId[k]);

		status = ci$send( msg      = message NDnode.NDchange_connect( 1,
						   &PlnId[ IdenPlnIndx[j+0] ],
						   &PlnId[ IdenPlnIndx[j+1] ] ),
				  targetid = PlnChldId[k].objid,
				  targetos = PlnChldId[k].osnum );
		as$status();
		if( !(status&1) )
		    printf("\nFAILED TO SWAP PLANE [%d,%d] WITH PLANE [%d,%d] USING NDchange_connect ON [%d,%d]\n\n",
			   PlnId[ IdenPlnIndx[j+0] ].objid,
			   PlnId[ IdenPlnIndx[j+0] ].osnum,
			   PlnId[ IdenPlnIndx[j+1] ].objid,
			   PlnId[ IdenPlnIndx[j+1] ].osnum,
			   PlnChldId[k].objid, PlnChldId[k].osnum );
	    }

	    /* Replace all further occurences of IdenPlnIndx[j] in the
	     * IdenPlnIndx list with IdenPlnIndx[j+1] to reflect the above
	     * change_connect. */
	    for( k=j+2 ; k<TotIdenPlan ; k=k+1 )
		if( PlnId[ IdenPlnIndx[k] ].objid ==
					PlnId[ IdenPlnIndx[j] ].objid &&
		    PlnId[ IdenPlnIndx[k] ].osnum ==
					PlnId[ IdenPlnIndx[j] ].osnum )
		{
		    __DBGpr_obj(" replaced plane exists ..", PlnId[IdenPlnIndx[k]] );
		    __DBGpr_int(" at index",k);
		    if( k%2 )
		    {
			__DBGpr_obj("Plane it would have replaced",
						      PlnId[IdenPlnIndx[k-1]]);
		    }
		    else
		    {
			__DBGpr_obj("Plane that would have replaced it",
						      PlnId[IdenPlnIndx[k+1]]);
		    }
		    IdenPlnIndx[k] = IdenPlnIndx[j+1];
		    __DBGpr_obj(" Plane that's taken its place",
							PlnId[IdenPlnIndx[k]]);
		}

	    NumClean = NumClean + 1;
	    status = ci$send( msg      = message NDnode.NDdelete( &md_env ),
			      targetid = PlnId[ IdenPlnIndx[j] ].objid,
			      targetos = PlnId[ IdenPlnIndx[j] ].osnum );
	    as$status();
	}


	/* Free and clean up for next segment-intersection.*/
	for( k=0 ; k<3*NbSups ; k=k+1 )
	{
	    free( PlnInfo[k].point );
	    free( PlnInfo[k].normal );
	}
	free( PlnInfo );
	free( PlnId );

	for( k=0 ; k<TotIdenPlan ; k=k+1 )
	    IdenPlnIndx[k]=0;
    }
    free( CompId );
    sprintf( MsgStr, "Number of tolerance-related duplicate planes fixed: %d",
								    NumClean );
    UI_status(MsgStr);
    fflush( VALlogfile );
    vd$VAL_closeLog();
}

