/* ###################   APOGEE COMPILED   ################## */
class implementation EMSsubbs;

#define ENVELOPE

/*
#define DEBUG
*/

#include "EMS.h"
#include <stdio.h>
%safe
#include <math.h>
%endsafe
#include <fcntl.h>
#include "OMminimum.h"
#include "OMmacros.h"
#include "OMprimitives.h"
#include "igrtypedef.h"
#include "igetypedef.h"
#include "igr.h"
#include "igrdp.h"
#include "dp.h"
#include "godef.h"
#include "madef.h"
#include "gr.h"
#include "go.h"
#include "bserr.h"
#include "bsparameters.h"
#include "emsdattyp.h"
#include "emsinter.h"
#include "EMSbnddef.h"
#include "EMSbnd.h"
#include "EMSprop.h"
#include "EMSmsgdef.h"
#include "emsdef.h"
#include "emsinterdef.h"
#include "emssfint.h"
#include "emsmacros.h"
#include "emserr.h"
#include "EMSopt.h"
#include "EMSfmtsf.h"
#include "transdef.h"
#include "translate.h"
#include "transmacros.h"
#include "transerr.h"
#include "grgsmacros.h"
#include "EMSsplitdef.h"
#include "lcmacros.h"
#include "exmacros.h"
#include "vsdef.h"
#include "griomacros.h"
#include "msdef.h"
#include <string.h>


/*
 ABSTRACT
            This file contains all of the functions needed in 
            splitting a surface with overflowing boundaries before
            translating it from EMS to IGDS

 HISTORY
            RC    04/04/89       Creation Date
	    SM	  05-Oct-89	 Made following fix in the function
				 EFwrite_envelope_and_igds_files() --
				 In the second call to env_write_design()
				 changed argument dgn_file to igds_file.
				 dgn_file was unused and was wiping out
				 the previously written igds file name.
				 Original code commented out.
	   SM	  06-Oct-89	 Added function EMget_unix_filename.
				 The user is expected to give filenames
				 corresponding to their location on VAX.
				 This function gives unix filename ignoring
				 the VAX path. The envelope file will record
				 VAX filename. Jim Bell wanted it this
				 way.
	  SM	  20-Oct-89	 The closure property of the surface was
				 having a discrepancy between IGDS and ENV
				 files. 
				 In IGDS there is no closure property. Periodic
				 is the only property which implies closure.
				 Solution - Pass periodic flags to ENV file
				 instead of closure flags.
	  SM	  26-Oct-89	 Set bdrys and num_bdrys to NULL before calling
				 BSactsplsf() and then reset to original
				 value upon return. BS routines like BScopy
				 have started looking at boundaries. However
				 BSallocsf does not allocate space for
				 bdrys. So core dump from BSactsplsf().
      RC      06/07/90 Use the scale factor from the env_matrix.
                       This sacle factor has already incorporated 
                       sace_factor coming in as an argument.
      PP      12/12/91 Removed the calls to envelope functions in
                       preparation for removing support for the same
      NP      08/26/92 Modified for ANSI compliance. Moved static 
		       functions to global scope and added lots of typecasts.
*/

from EMSloopset import EMpt_location, EMget_props, EMwindow, EMpack;
from EMSloop    import EMget_props;
from module     import GRmod_passon;
from OMindex    import pass;
from VSfeature	import VSgetResultType;
from ACncpx	import ACtest_consumed;
from NDmacro	import ACreturn_foot;

extern OMuword OPP_EMSsubbs_class_id;

                         
%safe
static void  EFget_cut_lines(), EFsplit_groups(), EFget_gr_splt_cut_lines();
static void  EFadd_bnd_to_grp(), EFsort_sbnds();
static void  EFmerge_groups_info(), EFsort_cut_lines();
static void  EMget_unix_filename(), EFmerge_sbnds();
static IGRboolean EFpt_lie_on_range_box();
%endsafe

static void  EFconvert_uvpt_to_parm (EFmsg, uv_pt, range, parm, par_tol)
 IGRlong        *EFmsg;
 IGRdouble      *uv_pt;
 IGRdouble      *range;
 IGRdouble      *parm;
 IGRdouble      par_tol;
{
  extern IGRdouble fabs();

  *EFmsg = EMS_S_Success;

  (*parm) = 0;
  if ( fabs(uv_pt[0] - range[0]) <= par_tol )
    (*parm) += (uv_pt[1] - range[1]);
  else
  {
    (*parm) += (range[3] - range[1]);
    if ( fabs(uv_pt[1] - range[3]) <= par_tol )
      (*parm) += (uv_pt[0] - range[0]);
    else
    {
      (*parm) += (range[2] - range[0]);
      if ( fabs(uv_pt[0] - range[2]) <= par_tol)
        (*parm) += (range[3] - uv_pt[1]);
      else
      {
        (*parm) += (range[3] - range[1] + range[2] - uv_pt[0]);
        
      }
    }
  }
 wrapup:
  return;

} /* EFconvert_uvpt_to_parm () */

/*
 * Given a group (one or many) of surface(s) generated by subdividing
 * a surface to meet the poles overflow limit, this function
 * further subdivides these surfaces, if needed, to avoid boundaries
 * overflow.
 */

 void EFsplit_sfs_to_accomodate_boundaries (EFmsg, in_sfs_geom,
              num_u_patches, num_v_patches, u_spl_pars, v_spl_pars,
              partolbasis, ls_id, cur_os, out_sfs_geom, num_out_sfs)

IGRlong               *EFmsg;
struct IGRbsp_surface **in_sfs_geom;
IGRlong               num_u_patches, num_v_patches;
IGRdouble             *u_spl_pars, *v_spl_pars;
struct EMSpartolbasis *partolbasis;
GRobjid               ls_id;
GRspacenum            cur_os;
struct IGRbsp_surface ***out_sfs_geom;
IGRint                *num_out_sfs;

{
  struct  IGRbsp_surface *sf_geom, *spl_sf_geom;
  struct  EMSbnd_info    *bnds_info = NULL;
  struct  EMSgr_info     **gd_grs_info = NULL, **ovf_grs_info = NULL,
                         **sp_grs_info = NULL, **trsh_grs_info = NULL,
                         *gr_info;
  struct  EMSgrbnd_info  *grbnd_info, **trsh_grbnds = NULL;
  struct  EMSsbnd_info   *sbnd_info, *nxt_sbnd_info, **trsh_sbnds = NULL;
  struct  EMSbint_info   *int_info;
  struct  IGRbsp_bdry_pts *bdry;
  IGRdouble              bnd_u_len, bnd_v_len, *gr_u_cuts = NULL,
                         *gr_v_cuts = NULL, *bnd_pts, par_cht, partol,
                         *path_beg_pt, *path_end_pt, path_beg_parm,
                         path_end_parm, range_pts_parm[4], range_len,
                         range_pts_dis[4], range_pts[8];
  IGRlong                rc;
  IGRint                 num_bnds, num_in_sfs, gd_grs_arrsz, 
                         ovf_grs_arrsz, num_gd_grs, num_ovf_grs,
                         num_sp_grs, sp_grs_arrsz, num_trsh_grs,
                         trsh_grs_arrsz, num_trsh_grbnds, 
                         trsh_grbnds_arrsz, num_trsh_sbnds, 
                         trsh_sbnds_arrsz,
                         num_bnd_pts, blk_size, count,
                         uix, vix, grix, bix, bnd_inx, i, j, 
                         num_gr_u_cuts, num_gr_v_cuts, num_cuts,
                         num_gr_u_ovf_cuts, num_gr_v_ovf_cuts,
                         num_u_cuts, num_v_cuts, gr_u_cuts_arrsz = 0,
                         gr_v_cuts_arrsz = 0, num_range_pts, min_inx;
  IGRboolean             split_sf, sf_found, end_pt_greater_than_beg_pt;

  extern void            EM2dbx(), EFmemory_allocation();
  extern void            BSallocsf(), BSactsplsf();
  extern IGRboolean      EFextract_par();
  extern IGRdouble       fabs();

/* ***************************************************************** */

*EFmsg = EMS_S_Success;

num_gd_grs = num_ovf_grs = 0;
num_sp_grs = num_trsh_grs = 0;
gd_grs_arrsz = ovf_grs_arrsz = 0;
sp_grs_arrsz = trsh_grs_arrsz = 0;
num_trsh_grbnds = trsh_grbnds_arrsz = 0;
num_trsh_sbnds = trsh_sbnds_arrsz = 0;

partol = partolbasis->tol;
EFextract_par (BSTOLCHRDHT, partol, &par_cht, &rc);

/*
 * o Group the boundaries. To start with, there will be one group
 *   per patch.
 * o Sort these groups into good groups (ones which are not
 *   overflowing) and overflow groups.
 * o For each overflow group, 
 *   o break the groups and sort these subgroups into good groups
 *     and overflow groups.
 * o Continue the above step until there is no more overflow groups.
 * o Break the surface using these groups and attach their
 *   respective boundaries.
 */

num_bnds = 0;
num_in_sfs = num_u_patches * num_v_patches;
for (i= 0; i < num_in_sfs; i++)
   num_bnds += in_sfs_geom[i]->num_boundaries;

bnds_info = (struct EMSbnd_info *) om$malloc (size = num_bnds *
                                         sizeof(struct EMSbnd_info));
EMerr_hndlr (!bnds_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
 
gd_grs_info = (struct EMSgr_info **) om$malloc (size = num_in_sfs *
                                      sizeof(struct EMSgr_info *));
EMerr_hndlr (!gd_grs_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

ovf_grs_info = (struct EMSgr_info **) om$malloc (size = num_in_sfs *
                                       sizeof(struct EMSgr_info *));
EMerr_hndlr (!ovf_grs_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

gd_grs_arrsz = ovf_grs_arrsz = num_in_sfs;
num_gd_grs = num_ovf_grs = 0;
num_bnds = 0;

for (vix = 0, grix = 0;  vix < num_v_patches; vix++)
{
 for (uix = 0; uix < num_u_patches; uix++, grix++)
 {
  if (in_sfs_geom[grix])
  {
   gr_info = (struct EMSgr_info *) om$malloc (size = 
                                             sizeof(struct EMSgr_info));
   EMerr_hndlr (!gr_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

   gr_info->range[0] = u_spl_pars[uix];
   gr_info->range[1] = v_spl_pars[vix];
   gr_info->range[2] = u_spl_pars[uix+1];
   gr_info->range[3] = v_spl_pars[vix+1];
   
   gr_info->grbnd_arrsz = gr_info->num_bnds = 0;
   gr_info->overflow = NULL;
   gr_info->num_type_25_needed = 0;
   gr_info->grbnd_info = NULL;

   if (in_sfs_geom[grix]->num_boundaries)
   {
    gr_info->grbnd_arrsz = in_sfs_geom[grix]->num_boundaries;
    gr_info->grbnd_info = (struct EMSgrbnd_info **) om$malloc (size = 
                  gr_info->grbnd_arrsz * sizeof(struct EMSgrbnd_info *));
    EMerr_hndlr(!gr_info->grbnd_info,*EFmsg,EMS_E_NoDynamicMemory,wrapup);

    for (i = 0; i < in_sfs_geom[grix]->num_boundaries; i++)
    {
     /*
      * Sometimes, the boundary does not have a point. This is a bug
      * somewhere. To avoid failures in this process, ignore this
      * kind of boundary.
      */

     if (in_sfs_geom[grix]->bdrys[i].num_points)
     {
      bnds_info[num_bnds].bdry = &in_sfs_geom[grix]->bdrys[i];

      int_info = &bnds_info[num_bnds].int_info;
      int_info->int_pts = NULL;
      int_info->ptinx = NULL;
      int_info->num_ints = int_info->int_arrsz = 0;

      EM2dbx (bnds_info[num_bnds].bdry->num_points,
              bnds_info[num_bnds].bdry->points,bnds_info[num_bnds].range);

      grbnd_info = (struct EMSgrbnd_info *) om$malloc (size = 
                                           sizeof(struct EMSgrbnd_info));
      EMerr_hndlr (!grbnd_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

      OM_BLOCK_MOVE (bnds_info[num_bnds].range, grbnd_info->range,
                     sizeof(IGRdouble) * 4);
      grbnd_info->num_pts = bnds_info[num_bnds].bdry->num_points;
      grbnd_info->whole_bnd = TRUE;
      sbnd_info = (struct EMSsbnd_info *) om$malloc (size = 
                                          sizeof(struct EMSsbnd_info));
      EMerr_hndlr (!sbnd_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

      grbnd_info->sbnd_info = sbnd_info;
      sbnd_info->bnd_info = &bnds_info[num_bnds];
      OM_BLOCK_MOVE (grbnd_info->range, sbnd_info->range,
                     sizeof(IGRdouble) * 4);
      sbnd_info->num_pts = grbnd_info->num_pts;
      sbnd_info->next = NULL;

      if (grbnd_info->num_pts > MAX_POINTS_PER_BOUNDARY)
        gr_info->overflow |= BND_PTS_OVERFLOW;

      count = grbnd_info->num_pts / MAX_PNTS_PER_TYPE_25;
      if(count * MAX_PNTS_PER_TYPE_25 != grbnd_info->num_pts)
          count++;
      gr_info->num_type_25_needed += count;
      gr_info->grbnd_info[gr_info->num_bnds++] = grbnd_info;
      num_bnds++;

     } /* if (in_sfs_geom[grix]->bdrys[i].num_points) */

    } /* for (i = 0; i < in_sfs_geom[grix]->num_boundaries; i++) */

   } /* if (in_sfs_geom[grix]->num_boundaries) */

   if (gr_info->num_type_25_needed > MAX_TYPE_25_ELEMENTS)
     gr_info->overflow |= BND_ELEMS_OVERFLOW;

   if (gr_info->overflow)
     ovf_grs_info[num_ovf_grs++] = gr_info;
   else
     gd_grs_info[num_gd_grs++] = gr_info;

  } /* if (in_sfs_geom[grix]) */

 } /* for (uix = 0; uix < num_u_patches; uix++, grix++) */

} /* for (vix = 0, grix = 0; vix < num_v_patches; vix++) */


 while (num_ovf_grs)
 {
  /*
   * There may be one of the following three cases:
   *  1. One or more boundaries of the group have more
   *     than allowed number of points.
   *  2. The group needs more than allowed no. of type_25 elememts.
   *  3. Combination of 1 and 2.
   *
   * Case 1 will be given precedence over case 2 as the splitting
   * of overflowing boundaries may automatically satisfy case 2.
   */

   gr_info = *ovf_grs_info;

   if (gr_info->overflow & BND_PTS_OVERFLOW)
   {
    /*
     * For each of the overflowing boundaries,
     *  o Find the splitting u/v lines such that the resultant
     *    pieces have pts less than the overflow limit. Also,
     *    at the same time the splitting lines chosen cut
     *    the minimum no. of inner loops. The criterion used in
     *    calculating the cutting lines is that it should return
     *    into pieces that are as squrish (aspect ratio as close
     *    to 1.) as possible.
     *
     *    n1 = no. of cutting lines along u.
     *    n2 = no. of cutting lines along v.
     *    n = n1 + n2. Total no. of cutting lines 
     *      = no. of bnd pts/ max_pts_per_type_25.
     *
     *    n2 = (ny + y - x)/(x+y)        
     */

    num_gr_u_cuts = num_gr_v_cuts = 0;

    for (bix = 0; bix < gr_info->num_bnds; bix++)
    {
     grbnd_info = gr_info->grbnd_info[bix];

     if (grbnd_info->num_pts > MAX_POINTS_PER_BOUNDARY)
     {
       count = grbnd_info->num_pts / MAX_POINTS_PER_BOUNDARY;
       if (count * MAX_POINTS_PER_BOUNDARY != grbnd_info->num_pts)
          count++;

       /*
        * Whole bnd is a closed bnd and n cuts of a whole bnd
        * will result into (2*n) pieces. 
        */

       num_cuts = count/2;
       if ((num_cuts * 2) != count) num_cuts++;
             
       bnd_u_len = grbnd_info->range[2] - grbnd_info->range[0];
       bnd_v_len = grbnd_info->range[3] - grbnd_info->range[1];

       num_v_cuts =(num_cuts * bnd_v_len + bnd_v_len - bnd_u_len) / 
                   (bnd_u_len + bnd_v_len);

       if (num_v_cuts < 0) num_v_cuts = 0;
       num_u_cuts = num_cuts - num_v_cuts;

       if (num_u_cuts)
       {
         EFget_cut_lines (&rc, num_u_cuts, CUT_ALONG_U, grbnd_info, 
             bnds_info, num_bnds, &gr_u_cuts, &num_gr_u_cuts, 
             &gr_u_cuts_arrsz);
         EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
       } 

       if (num_v_cuts)
       {
         EFget_cut_lines (&rc, num_v_cuts, CUT_ALONG_V, grbnd_info, 
             bnds_info, num_bnds, &gr_v_cuts, &num_gr_v_cuts, 
             &gr_v_cuts_arrsz);
         EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
       } 

     } /* if (grbnd_info->num_pts > MAX_POINTS_PER_BOUNDARY) */

    } /* for (bix = 0; bix < gr_info->num_bnds; bix++) */

   } /* if (gr_info->overflow & BND_PTS_OVERFLOW) */
   else
   {
    /*
     * o Get the cutting lines along u, if used, will split the group
     *   into subgroups with num_type_25_needed <= overflow limit.
     * o Get the cutting lines along v, if used, will split the group
     *   into subgroups with num_type_25_needed <= overflow limit.
     * o Keep which ever cutting direction results in minimum no.
     *   of splits.
     * o It should be noted that these cutting lines are calculated
     *   approximatley without performing any intersections. Thus,
     *   the resultant subgroups may still be overflowing.
     */

    num_gr_u_cuts = 0;
    num_gr_u_ovf_cuts = 0;
    EFget_gr_splt_cut_lines (&rc, gr_info, CUT_ALONG_U, &gr_u_cuts, 
      &num_gr_u_cuts, &gr_u_cuts_arrsz, &num_gr_u_ovf_cuts, par_cht);
    EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

    num_gr_v_cuts = 0;
    num_gr_v_ovf_cuts = 0;
    EFget_gr_splt_cut_lines (&rc, gr_info, CUT_ALONG_V, &gr_v_cuts, 
      &num_gr_v_cuts, &gr_v_cuts_arrsz, &num_gr_v_ovf_cuts, par_cht);
    EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

    if (num_gr_u_cuts && num_gr_v_cuts)
    {
     if (num_gr_u_ovf_cuts < num_gr_v_ovf_cuts)
       num_gr_v_cuts = 0;
     else 
     {
      if (num_gr_u_ovf_cuts == num_gr_v_ovf_cuts)
      {
       if (num_gr_u_cuts < num_gr_v_cuts) num_gr_v_cuts = 0; 
       else num_gr_u_cuts = 0;
      } 
      else    num_gr_u_cuts = 0;
     }

    } /* if (num_gr_u_cuts && num_gr_v_cuts) */

   } /* else for if (gr_info->overflow & BND_PTS_OVERFLOW) */

  /*
   * o Cutting lines have been calculated.
   * o Split each of the gd_grs and ovf_grs using these cutting lines.
   * o Sort the resultant split groups into good and overflowing 
   *   groups.
   */

  if (num_gr_u_cuts || num_gr_v_cuts)
  {
    if (num_gr_u_cuts)
     EFsort_cut_lines (&rc, num_gr_u_cuts, gr_u_cuts);

    if (num_gr_v_cuts)
     EFsort_cut_lines (&rc, num_gr_v_cuts, gr_v_cuts);

 
    EFsplit_groups (&rc, ovf_grs_info, &num_ovf_grs, bnds_info, num_bnds,
      num_gr_u_cuts, gr_u_cuts, num_gr_v_cuts, gr_v_cuts, 
      &num_sp_grs, &sp_grs_arrsz, &sp_grs_info, &num_trsh_grs,
      &trsh_grs_arrsz, &trsh_grs_info, &num_trsh_grbnds, 
      &trsh_grbnds_arrsz, &trsh_grbnds, &num_trsh_sbnds, 
      &trsh_sbnds_arrsz, &trsh_sbnds, ls_id, cur_os, partolbasis);
    EMerr_hndlr (!(1&rc),*EFmsg,EMS_E_Fail,wrapup);

    if (num_gd_grs)
    {
     EFsplit_groups (&rc, gd_grs_info, &num_gd_grs, bnds_info, num_bnds,
       num_gr_u_cuts, gr_u_cuts, num_gr_v_cuts, gr_v_cuts, 
       &num_sp_grs, &sp_grs_arrsz, &sp_grs_info, &num_trsh_grs,
       &trsh_grs_arrsz, &trsh_grs_info, &num_trsh_grbnds, 
       &trsh_grbnds_arrsz, &trsh_grbnds, &num_trsh_sbnds, 
       &trsh_sbnds_arrsz, &trsh_sbnds, ls_id, cur_os, partolbasis);
     EMerr_hndlr (!(1&rc),*EFmsg,EMS_E_Fail,wrapup);

    } /* if (num_gd_grs) */

    /*
     * sort the split groups into gd_grs and ovf_grs.
     */

    for (grix = 0; grix < num_sp_grs; grix++)
    {
      if (sp_grs_info[grix]->overflow)
      {
       if ( (num_ovf_grs+1) > ovf_grs_arrsz)
       {
        EFmemory_allocation (&rc, (IGRchar ***) &ovf_grs_info, 
          num_ovf_grs+1, &ovf_grs_arrsz, sizeof(struct EMSgr_info *), 
          num_sp_grs - grix, num_sp_grs - grix);
        EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);
       } /* if ( (num_ovf_grs+1) > ovf_grs_arrsz) */

       ovf_grs_info[num_ovf_grs++] = sp_grs_info[grix]; 

      } /* if (sp_grs_info[grix]->overflow) */
      else
      {
       if ((num_gd_grs+1) > gd_grs_arrsz)
       {
        EFmemory_allocation (&rc, (IGRchar ***) &gd_grs_info, 
          num_gd_grs+1, &gd_grs_arrsz, sizeof(struct EMSgr_info *), 
          num_sp_grs - grix, num_sp_grs - grix);
        EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);
       }
       gd_grs_info[num_gd_grs++] = sp_grs_info[grix]; 

      } /* else for if (sp_grs_info[grix]->overflow) */

    } /* for (grix = 0; grix < num_sp_grs; grix++) */

    num_sp_grs = 0;

  } /* if (num_gr_u_cuts || num_gr_v_cuts) */

 } /* while (num_ovf_grs) */

 /*
  * Try to merge these non_overflowing groups along the
  * cutting lines such that none of the resultant merged 
  * groups overflow.
  */

  EFmerge_groups_info (&rc, gd_grs_info, &num_gd_grs, (num_u_patches+1),
    u_spl_pars, (num_v_patches+1), v_spl_pars, &trsh_grs_info,
    &num_trsh_grs, &trsh_grs_arrsz, &trsh_grbnds, &num_trsh_grbnds,
    &trsh_grbnds_arrsz, &trsh_sbnds, &num_trsh_sbnds, &trsh_sbnds_arrsz,
    partolbasis);
  EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
  
  /*
   * Now we have good groups (non_overflowing) only.
   * Next task is,
   * o Split the surface using these groups' info.
   * o Extract the boundaries from the original surface relevant to
   *   each group and attach it to the relevant split surface.
   */

 *out_sfs_geom = (struct IGRbsp_surface **) om$malloc (size = num_gd_grs *
                                        sizeof(struct IGRbsp_surface *));
 EMerr_hndlr (!(*out_sfs_geom), *EFmsg, EMS_E_NoDynamicMemory, wrapup);

 *num_out_sfs = num_gd_grs;

 for (grix = 0; grix < num_gd_grs; grix++)
 {
  gr_info = gd_grs_info[grix];
  split_sf = TRUE;
  sf_found = FALSE;
  for (vix = 0; vix < num_v_patches; vix++)
  {
    for (uix = 0; uix < num_u_patches; uix++)
    {
     if (fabs(gr_info->range[0] - u_spl_pars[uix]) <= partol    &&
         fabs(gr_info->range[1] - v_spl_pars[vix]) <= partol    &&
         fabs(gr_info->range[2] - u_spl_pars[uix+1]) <= partol  &&
         fabs(gr_info->range[3] - v_spl_pars[vix+1]) <= partol )
     {
       split_sf = FALSE;
       sf_found = TRUE;           break;
     }         
     else if (gr_info->range[0] >= u_spl_pars[uix]    &&
              gr_info->range[1] >= v_spl_pars[vix]    &&
              gr_info->range[2] <= u_spl_pars[uix+1]  &&
              gr_info->range[3] <= v_spl_pars[vix+1] ) 
     {
       sf_found = TRUE;         break;
     }

    } /* for (uix = 0; uix < num_u_patches; uix++) */

    if (sf_found) break;

  } /* for (vix = 0; vix < num_v_patches; vix++) */

  sf_geom = in_sfs_geom[vix * num_u_patches + uix];

  if (split_sf)
  {
    IGRdouble u_pars[2], v_pars[2];
    struct IGRbsp_bdry_pts *saveptr = NULL;
    IGRshort save_numbdrys = 0;

    BSallocsf (sf_geom->u_order, sf_geom->v_order, 
      sf_geom->u_num_poles, sf_geom->v_num_poles, sf_geom->rational,
      0, &spl_sf_geom, &rc);
    EMerr_hndlr (rc != BSSUCC, *EFmsg, EMS_E_BSerror, wrapup);

    u_pars[0] = gr_info->range[0];
    u_pars[1] = gr_info->range[2];
    v_pars[0] = gr_info->range[1];
    v_pars[1] = gr_info->range[3];

    saveptr = sf_geom->bdrys;
    save_numbdrys = sf_geom->num_boundaries;
    sf_geom->bdrys = NULL;
    sf_geom->num_boundaries = 0;
    
    BSactsplsf (sf_geom, u_pars, v_pars, 2, spl_sf_geom, &rc);

    sf_geom->bdrys = saveptr;
    sf_geom->num_boundaries = save_numbdrys;

    EMerr_hndlr (rc != BSSUCC, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

    /*
     * Extract boundaries
     */

    if (gr_info->num_bnds)
    {
     IGRboolean    add_pt;

     spl_sf_geom->bdrys = (struct IGRbsp_bdry_pts *) om$malloc (size = 
                    gr_info->num_bnds * sizeof(struct IGRbsp_bdry_pts));
     EMerr_hndlr(!spl_sf_geom->bdrys,*EFmsg,EMS_E_NoDynamicMemory,wrapup);

     range_pts[0] = range_pts[2] = gr_info->range[0];
     range_pts[1] = range_pts[7] = gr_info->range[1];
     range_pts[4] = range_pts[6] = gr_info->range[2];
     range_pts[3] = range_pts[5] = gr_info->range[3];
     range_len = (gr_info->range[2] - gr_info->range[0] +
                  gr_info->range[3] - gr_info->range[1]) * 2;

     for (i = 0; i < 4; i++)
     {
       EFconvert_uvpt_to_parm (&rc, &range_pts[2*i], gr_info->range,
                               &range_pts_parm[i], partolbasis->tol);
       EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

     } /* for (i = 0; i < 4; i++) */

     for (bix = 0; bix < gr_info->num_bnds; bix++)
     {
      grbnd_info = gr_info->grbnd_info[bix];
      sbnd_info = grbnd_info->sbnd_info;

      if (grbnd_info->whole_bnd)
      { 
        bdry = sbnd_info->bnd_info->bdry;
        spl_sf_geom->bdrys[bix] = *bdry;
        bdry->points = NULL;
        bdry->num_points = 0;

      } /* if (grbnd_info->whole_bnd) */
      else
      {
        bnd_pts = (IGRdouble *) om$malloc (size = 
                    sizeof(IGRdouble) * 2 * (grbnd_info->num_pts+5));
        EMerr_hndlr (!bnd_pts, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
        num_bnd_pts = 0;

        while (sbnd_info)
        {
          bdry = sbnd_info->bnd_info->bdry;

          add_pt = TRUE;
          if (num_bnd_pts)
           if (EM2ddistptpt (&bnd_pts[(num_bnd_pts-1)*2], 
                            sbnd_info->beg_pt) <= partol)
            add_pt = FALSE;

          if (add_pt)
          {
            OM_BLOCK_MOVE (sbnd_info->beg_pt, &bnd_pts[num_bnd_pts*2],
                           sizeof(IGRdouble)*2);
            num_bnd_pts++;
           }

          /*
           * The beg_inx and end_inx are set such that in order to
           * extract the geometry of the sbnd, one has to travel from
           * beg_pt along the logical direction of the sbnd till it 
           * reaches end_pt. In order to determine if one has to cross
           * over begin pt of the original boundary is determined by 
           * examining beg_inx and end_inx.
           * a) beg_inx < end_inx -- No crossing over whole bnd begin pt.
           * b) beg_inx > end_inx -- Crossing over whole bnd begin pt.
           * c) beg_inx == end_inx ---
           *    i) (end_pt - bdry[end_inx]) >= (beg_pt - bdry[end_inx]) --
           *                 No crossing over whole bnd begin pt.
           *    ii) (end_pt - bdry[end_inx]) < (beg_pt - bdry[end_inx]) --
           *                 Crossing over whole bnd begin pt.
           */

          EFis_end_pt_greater_than_beg_pt(sbnd_info->beg_inx, 
             sbnd_info->end_inx, sbnd_info->beg_pt, sbnd_info->end_pt,
             sbnd_info->bnd_info->bdry, end_pt_greater_than_beg_pt);

          blk_size = end_pt_greater_than_beg_pt ?
                   (sbnd_info->end_inx - sbnd_info->beg_inx) :
                   (bdry->num_points - 1 - sbnd_info->beg_inx);


          if (blk_size)
          {
            OM_BLOCK_MOVE (&bdry->points[(sbnd_info->beg_inx+1)*2], 
              &bnd_pts[num_bnd_pts*2], blk_size * 2 * sizeof(IGRdouble));
            num_bnd_pts += blk_size;
          }

          if ((!end_pt_greater_than_beg_pt) && sbnd_info->end_inx)
          {
            OM_BLOCK_MOVE (&bdry->points[2], &bnd_pts[num_bnd_pts*2],
               sizeof(IGRdouble) * 2 * (sbnd_info->end_inx));
            num_bnd_pts += sbnd_info->end_inx;
          } /* if ((!end_pt_greater_than_beg_pt) && sbnd_info->end_inx) */

          if (EM2ddistptpt (&bdry->points[sbnd_info->end_inx*2],
                            sbnd_info->end_pt) > partol)
          {
           OM_BLOCK_MOVE (sbnd_info->end_pt, &bnd_pts[num_bnd_pts*2],
                          sizeof(IGRdouble)*2);
           num_bnd_pts++;
          }

          path_beg_pt = sbnd_info->end_pt;
          path_end_pt = sbnd_info->next ? sbnd_info->next->beg_pt :
                        grbnd_info->sbnd_info->beg_pt;
          
          EFconvert_uvpt_to_parm (&rc, path_beg_pt, gr_info->range,
                                  &path_beg_parm, partolbasis->tol);
          EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

          EFconvert_uvpt_to_parm (&rc, path_end_pt, gr_info->range,
                                  &path_end_parm, partolbasis->tol);
          EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

          if (fabs(path_end_parm - path_beg_parm) > partol)
          {
           num_range_pts = 0;
           for (i = 0; i < 4; i++)
           {
            if (path_end_parm > path_beg_parm)
            {
             if (range_pts_parm[i] > path_beg_parm  &&
                 range_pts_parm[i] < path_end_parm)
              range_pts_dis[i] = range_pts_parm[i] - path_beg_parm;
             else
               range_pts_dis[i] = MAXFLOAT;
            } /* if (path_end_parm > path_beg_parm) */
            else
            {
             if (range_pts_parm[i] > path_beg_parm)
               range_pts_dis[i] = range_pts_parm[i] - path_beg_parm;
             else
             {
              if (range_pts_parm[i] < path_end_parm)
                range_pts_dis[i] = range_len - path_beg_parm + 
                                  range_pts_parm[i];
              else
               range_pts_dis[i] = MAXFLOAT;
             }
            } /* else for if (path_end_parm > path_beg_parm) */

            if (range_pts_dis[i] != MAXFLOAT) num_range_pts++;

           } /* for (i = 0; i < 4; i++) */

           for (i = 0; i < num_range_pts; i++)
           {
            min_inx = -1;
            for (j = 0; j < 4; j++)
            {
             if (range_pts_dis[j] != MAXFLOAT)
             {
              if (min_inx != -1)
              {
                if (range_pts_dis[j] < range_pts_dis[min_inx])
                  min_inx = j;
              }
              else min_inx = j;
             }
            } /* for (j = 0; j < 4; j++) */

            OM_BLOCK_MOVE (&range_pts[min_inx*2], 
                        &bnd_pts[num_bnd_pts*2], sizeof(IGRdouble)*2);
            num_bnd_pts++;
            range_pts_dis[min_inx] = MAXFLOAT;

           } /* for (i = 0; i < num_range_pts; i++) */

          } /* if (fabs(path_end_parm - path_beg_parm) > partol) */

          sbnd_info = sbnd_info->next;

        } /* while (sbnd_info) */

        if (EM2ddistptpt (bnd_pts, &bnd_pts[(num_bnd_pts-1)*2]) > partol)
        {
           OM_BLOCK_MOVE (bnd_pts, &bnd_pts[num_bnd_pts*2],
                          sizeof(IGRdouble)*2);
           num_bnd_pts++;
        }

        spl_sf_geom->bdrys[bix].num_points = num_bnd_pts;
        spl_sf_geom->bdrys[bix].points = bnd_pts;

      } /* else for if (grbnd_info->whole_bnd) */

     }/* for (bix = 0; bix < gr_info->num_bnds; grix++) */

    } /* if (gr_info->num_bnds) */

    spl_sf_geom->num_boundaries = gr_info->num_bnds;

    /*
     * Set the on_off bit correctly
     *  o If spl_sf does not have any boundaries, on_off = TRUE.
     *  o If spl_sf has some boundaries,
     *    {
     *      o If gr_info has one or more non_whole boundaries (i.e.,
     *         pieces of these boundaries lie on the natural boundary
     *         of spl_sf), on_off = FALSE.
     *      
     *      o Else,
     *        Take the uv(0,0) point of the spl_sf and perform pt_location
     *        of this pt on the original sf's loopset.
     *        If this point lies in whole region, on_off = FALSE.
     *        Else, on_off = TRUE
     *     }
     */

    if (gr_info->num_bnds)
    {
      IGRboolean gr_with_non_whole_bnd = FALSE;

      for (bix = 0; bix < gr_info->num_bnds && !gr_with_non_whole_bnd; 
           bix++)
       if (!gr_info->grbnd_info[bix][0].whole_bnd)
          gr_with_non_whole_bnd = TRUE;

      if (gr_with_non_whole_bnd)
         spl_sf_geom->on_off = FALSE;
      else
      {
       IGRlong                 OM_stat;
       struct EMSptloc_info    pt_loc;

       pt_loc.options = EMS_PTLOC_LS_INFINITE;
       OM_stat = om$send (msg = message EMSloopset.EMpt_location (&rc,
                           gr_info->range, &pt_loc, partolbasis),
                          senderid = NULL_OBJID,
                          targetid = ls_id,
                          targetos = cur_os);
       EMerr_hndlr (!(1&rc&OM_stat),*EFmsg, EMS_E_LoopsetError,wrapup);

       switch (pt_loc.location)
       {

         case EMS_L_ONEDGE:
         case EMS_L_ONVRTX:
         {
          extern IGRint       EMsend_loops();
          IGRushort   lp_props;

          EMsend_loops (&rc, message EMSloop.EMget_props (&rc, &lp_props),
                        pt_loc.edge[0].edge_id, NULL, OM_K_MAXINT, 
                        EMLP_ACTIVE, NULL, NULL);
          EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

          spl_sf_geom->on_off = (lp_props & EMLP_NATURAL) ? TRUE :
                                ((lp_props & EMLP_PLOOP) ? FALSE : TRUE);

          break;
         }

         case EMS_L_INAREA:
          spl_sf_geom->on_off = TRUE;
          break;

         case EMS_L_INHOLE:
          spl_sf_geom->on_off = FALSE;
          break;

         default:
          *EFmsg = EMS_E_Fail;
          goto wrapup;

       } /* switch (pt_loc.location) */

      } /* else for if (gr_with_non_whole_bnd) */

    } /* if (gr_info->num_bnds) */
    else
     spl_sf_geom->on_off = TRUE;

    (*out_sfs_geom)[grix] = spl_sf_geom;

  } /* if (split_sf) */
  else
  {
    (*out_sfs_geom)[grix] = sf_geom;
    in_sfs_geom[vix * num_u_patches + uix] = NULL;
  }  
  
 } /* for (grix = 0; grix < num_gd_grs; grix++) */

 wrapup:
   EMWRAPUP (*EFmsg, *EFmsg, "In EFsplit_sfs_to_accomodate_boundaries");
 
   if (bnds_info) 
   { 
     for (bix = 0; bix < num_bnds; bix++) 
     { 
       if (bnds_info[bix].int_info.int_pts)  
          om$dealloc (ptr = bnds_info[bix].int_info.int_pts); 
       if (bnds_info[bix].int_info.ptinx)
          om$dealloc (ptr = bnds_info[bix].int_info.ptinx); 

     } /* for (bix = 0; bix < num_bnds; bix++) */

     om$dealloc (ptr = bnds_info);
   } /* if (bnds_info) */


  {
   struct EMSgr_info  **grs_info;
   IGRint             num_grs;

   for (i = 0; i < 4; i++)
   {
     switch (i)
     {
       case 0:
         grs_info = gd_grs_info;
         num_grs = num_gd_grs;
         break;

       case 1:
         grs_info = ovf_grs_info;
         num_grs = num_ovf_grs;
         break;
  
       case 2:
         grs_info = sp_grs_info;
         num_grs = num_sp_grs;
         break;

       case 3:
         grs_info = trsh_grs_info;
         num_grs = num_trsh_grs;
         break;

       default:
         break;
  
     } /* switch (i) */

     if (grs_info)
     {
       for (grix = 0; grix < num_grs; grix++)
       {
         if (grs_info[grix]->grbnd_info)
         {
           for (bix = 0; bix < grs_info[grix]->num_bnds; bix++)
           {
             grbnd_info = grs_info[grix]->grbnd_info[bix];
             if (grbnd_info)
             {
               sbnd_info = grbnd_info->sbnd_info;
               while(sbnd_info)
               {
                 nxt_sbnd_info = sbnd_info->next;
                 om$dealloc (ptr = sbnd_info);
                 sbnd_info = nxt_sbnd_info;
               }

               om$dealloc (ptr = grbnd_info);
             } /* if (grbnd_info) */

           } /* for (bix = 0; bix < grs_info[grix]->num_bnds; bix++) */

           om$dealloc (ptr = grs_info[grix]->grbnd_info);

         } /* if (grs_info[grix]->grbnd_info) */

         om$dealloc (ptr = grs_info[grix]);

        } /* for (grix = 0; grix < num_grs; grix++) */

        om$dealloc (ptr = grs_info);

      } /* if (grs_info) */

   } /* for (i = 0; i < 4; i++) */

  } /* free grs_info */

  /*
   * Free trash boundaries
   */

  if (trsh_grbnds)
  {
   for (bix = 0; bix < num_trsh_grbnds; bix++)
     if (trsh_grbnds[bix]) om$dealloc (ptr = trsh_grbnds[bix]);

   om$dealloc (ptr = trsh_grbnds);

  } /* if (trsh_grbnds) */

  if (trsh_sbnds)
  {
   for (bix = 0; bix < num_trsh_sbnds; bix++)
     if (trsh_sbnds[bix]) om$dealloc (ptr = trsh_sbnds[bix]);

   om$dealloc (ptr = trsh_sbnds);

  } /* if (trsh_grbnds) */

  if (gr_u_cuts) om$dealloc (ptr = gr_u_cuts);
  if (gr_v_cuts) om$dealloc (ptr = gr_v_cuts);

/*
 * The following code is for debugging purpose only
 */

#ifdef DEBUG

{
 FILE  *datfile;
 char  filename[20];
 int   workfunc();

  for (i = 0; i < *num_out_sfs; i++)
  {
   sprintf(filename, "sf%d", i);
   fprintf (stderr, "out_sf #%d, num_bnds - %d\n", 
                    i, (*out_sfs_geom)[i][0].num_boundaries);
   datfile = fopen (filename, "a");
   for (j = 0; j < (*out_sfs_geom)[i]->num_boundaries; j++)
   {
    workfunc (datfile, 2, (*out_sfs_geom)[i]->bdrys[j].num_points,
              (*out_sfs_geom)[i]->bdrys[j].points);
   }
   fclose (datfile);
  } 

}
#endif

   return;

}

static int workfunc (datfile, dim, num_points, points)
FILE *datfile;
int dim, num_points;
double *points;
{
  int i, funcval;
  double (*pts2d)[2], (*pts3d)[3];

  funcval = 1;
  fprintf (datfile, "%d\n", num_points);
  if (dim == 2)
    {
    pts2d = (double (*)[2])points;
    for (i=0; i<num_points; i++)
      fprintf (datfile, "%7.12lf %7.12lf\n", pts2d[i][0], pts2d[i][1]);
    }
  else if (dim == 3)
    {
    pts3d = (double (*)[3])points;
    for (i=0; i<num_points; i++)
      fprintf (datfile, "%7.12lf %7.12lf %7.12lf\n", 
       pts3d[i][0], pts3d[i][1], pts3d[i][2]);
    }
  else
    {
    funcval = 0;
    printf ("Not supported\n");
    }

return (funcval);
}

static void EFget_cut_lines (EFmsg, num_cuts, cut_type, grbnd_info, 
                      bnds_info, num_bnds, gr_cuts, num_gr_cuts, 
                      gr_cuts_arrsz)

 IGRlong              *EFmsg;
 IGRint               num_cuts;
 IGRint               cut_type;
 struct EMSgrbnd_info *grbnd_info;
 IGRint               num_bnds;
 struct EMSbnd_info   *bnds_info;
 IGRdouble            **gr_cuts;
 IGRint               *num_gr_cuts;
 IGRint               *gr_cuts_arrsz;
{
   struct  EMSsbnd_info    *sbnd_info;
   IGRdouble               delta, overlap_band, cut_line;
   IGRlong                 rc;
   IGRint                  i, cix, bix;
   IGRboolean              good_cut_line, is_sbnd;
   extern void             EFmemory_allocation ();
   extern IGRdouble        fabs();

   /* ************************************************************* */

   *EFmsg = EMS_S_Success;

   if (*gr_cuts_arrsz < (*num_gr_cuts + num_cuts) )
   {
     EFmemory_allocation (&rc, (IGRchar **) gr_cuts, 
        *num_gr_cuts + num_cuts, gr_cuts_arrsz, 
        sizeof(IGRdouble), num_cuts, num_cuts);
     EMerr_hndlr (!(1&rc),*EFmsg,EMS_E_Fail,wrapup);
   }               

   /*
    * If any of the already existing cuts are within 10%
    * of the delta of the new cut, ignore the current 
    * cut with the hope that the exisitng cut will fulfill
    * the requirement of breaking the boundary.
    * 
    * Also, if the cutting line is cutting through any of
    * the other boundaries of the group, check if by moving 
    * it by 10% will avoid it. If so, move the cutting line.
    */
 
   delta = (grbnd_info->range[cut_type+2] - grbnd_info->range[cut_type]) /
           (num_cuts+1);

   overlap_band = OVERLAP_ZONE * delta;

   for (cix = 0; cix < num_cuts; cix++)
   {
     cut_line = grbnd_info->range[cut_type] + (cix+1) * delta;
     good_cut_line = TRUE;
 
     for (i = 0; i < *num_gr_cuts; i++)
     {
       if (fabs( (*gr_cuts)[i] - cut_line) <= overlap_band)
       {
         good_cut_line = FALSE;
         break;
       }
     } /* for (i = 0; i < *num_gr_cuts; i++) */

     if (good_cut_line)
     {
       for (bix = 0; bix < num_bnds; bix++)
       {
         sbnd_info = grbnd_info->sbnd_info;
         is_sbnd = FALSE;
         while (sbnd_info && !is_sbnd)
         {
          if (sbnd_info->bnd_info == &bnds_info[bix]) is_sbnd = TRUE;
          else sbnd_info = sbnd_info->next;
        
         } /* while (sbnd_info && !is_sbnd) */

         if (!is_sbnd)
         {
          if (cut_line >= bnds_info[bix].range[cut_type] && 
              cut_line <= bnds_info[bix].range[cut_type+2])
          {
           if ( fabs(cut_line - bnds_info[bix].range[cut_type]) <=
                overlap_band )
             cut_line = bnds_info[bix].range[cut_type] - overlap_band/10.;

            else if ( fabs(cut_line - bnds_info[bix].range[cut_type+2]) <=
                      overlap_band)
             cut_line = bnds_info[bix].range[cut_type+2] +  
                        overlap_band/10.;

          } /* if (cut_line >= bnds_info[bix].range[cut_type] &&  */

         } /* if (!is_sbnd) */

       } /* for (bix = 0; bix < num_bnds; bix++) */

       for (i = 0; i < *num_gr_cuts; i++)
       {
         if (fabs( (*gr_cuts)[i] - cut_line) <= overlap_band)
         {
           good_cut_line = FALSE;
           break;
         }
       } /* for (i = 0; i < *num_gr_cuts; i++) */

       if (good_cut_line)  (*gr_cuts)[(*num_gr_cuts)++] = cut_line;

     } /* if (good_cut_line) */
 
   } /* for (cix = 0; cix < num_cuts; cix++) */

wrapup:
 return;

} /* EFget_cut_lines () */


/*
 * Given a set of groups and the cutting lines along U and/or V,
 * this function splits the groups along the cutting lines.
 * Using the split information, the resultant split groups are
 * extracted. 
 */

static void EFsplit_groups (EFmsg, grs_info, num_grs, bnds_info, 
                    num_bnds, num_gr_u_cuts, gr_u_cuts, 
                    num_gr_v_cuts, gr_v_cuts,  
                    num_sp_grs, sp_grs_arrsz, 
                    sp_grs_info, num_trsh_grs, trsh_grs_arrsz, trsh_grs,
                    num_trsh_grbnds, trsh_grbnds_arrsz, trsh_grbnds, 
                    num_trsh_sbnds, trsh_sbnds_arrsz, trsh_sbnds, 
                    ls_id, cur_os, partolbasis)

IGRlong              *EFmsg;
struct EMSgr_info    **grs_info;
IGRint               *num_grs;
struct EMSbnd_info   *bnds_info;
IGRint               num_bnds;
IGRint               num_gr_u_cuts;
IGRdouble            *gr_u_cuts;
IGRint               num_gr_v_cuts;
IGRdouble            *gr_v_cuts;
IGRint               *num_sp_grs;
IGRint               *sp_grs_arrsz;
struct EMSgr_info    ***sp_grs_info;
IGRint               *num_trsh_grs;
IGRint               *trsh_grs_arrsz;
struct EMSgr_info    ***trsh_grs;
IGRint               *num_trsh_grbnds;
IGRint               *trsh_grbnds_arrsz;
struct EMSgrbnd_info ***trsh_grbnds;
IGRint               *num_trsh_sbnds;
IGRint               *trsh_sbnds_arrsz;
struct EMSsbnd_info  ***trsh_sbnds;
GRobjid              ls_id;
GRspacenum           cur_os;
struct EMSpartolbasis *partolbasis;

{
 struct IGRpolyline     polyline;
 struct EMSgr_info      *cgr_info, *sp_gr;
 struct EMSgrbnd_info   *grbnd_info;
 struct EMSsbnd_info    *sbnd_info, **last_sbnd;
 struct EMSbnd_info     *bnd_info;
 struct IGRbsp_bdry_pts *bdry;
 struct EMSbint_info    *int_info;
 struct EMSsfintedpar   *gr_inters = NULL, *gr_inters_ptr;
 IGRdouble              uv_pts[4], *cgr_u_cuts = NULL, *cgr_v_cuts = NULL,
                        *pt_uv, *next_pt, *cut_parm, poly_range[4];
 IGRlong                rc;
 IGRint                 grix, cut_type, num_cgr_u_cuts, num_cgr_v_cuts,
                        num_gr_cuts, varying_parm, blk_size, cix, bix,
                        beg_int_inx, num_inters, arrsz, ptinx, int_inx, 
                        num_elems, num_res_sgrs, uinx, vinx, i, num_pts,
                        first_int_inx, num_type_25_needed, beg_inx, 
                        end_inx;
 IGRushort      trim_options;
 IGRboolean             is_cgr_split, first_int_found, first_int_pt_used,
                        add_pt;
 extern IGRboolean      EM2dpycutint();
 extern void            EMsfintedpar_free(), EFmemory_allocation();
 extern IGRdouble       fabs(); 

 /* ************************************************************** */

 *EFmsg = EMS_S_Success;
 
 polyline.num_points = 2;
 polyline.points = uv_pts;

 trim_options = EMS_INTER_CUTTING | EMS_INTER_STARTPT | EMS_INTER_STOPPT;

if (num_gr_u_cuts)
{
 cgr_u_cuts = (IGRdouble *) om$malloc (size = num_gr_u_cuts *
                                         sizeof(IGRdouble));
 EMerr_hndlr (!cgr_u_cuts, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
} /* if (num_gr_u_cuts) */

if (num_gr_v_cuts)
{
 cgr_v_cuts = (IGRdouble *) om$malloc (size = num_gr_v_cuts *
                                         sizeof(IGRdouble));
 EMerr_hndlr (!cgr_v_cuts, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
} /* if (num_gr_v_cuts) */

grix = 0;
while (grix < *num_grs)
{
  cgr_info = grs_info[grix];
  is_cgr_split = FALSE;

  for ( cut_type = 0; cut_type < 2; cut_type++)
  {
   if (cut_type == CUT_ALONG_U)
   {
    num_cgr_u_cuts = 0;
    for (i = 0; i < num_gr_u_cuts; i++)
     if (gr_u_cuts[i] > cgr_info->range[0]  && 
         gr_u_cuts[i] < cgr_info->range[2])
       cgr_u_cuts[num_cgr_u_cuts++] = gr_u_cuts[i];

    num_gr_cuts = num_cgr_u_cuts;
    cut_parm = cgr_u_cuts;
    varying_parm = CUT_ALONG_V;
   }
  else
  {
    num_cgr_v_cuts = 0;
    for (i = 0; i < num_gr_v_cuts; i++)
     if (gr_v_cuts[i] > cgr_info->range[1]    &&
         gr_v_cuts[i] < cgr_info->range[3])
      cgr_v_cuts[num_cgr_v_cuts++] = gr_v_cuts[i];

    num_gr_cuts = num_cgr_v_cuts;
    cut_parm = cgr_v_cuts;
    varying_parm = CUT_ALONG_U;           
  } 

  for (cix = 0; cix < num_gr_cuts; cix++)
  {
    polyline.points[cut_type] = polyline.points[cut_type+2] = 
                                                          cut_parm[cix];
    polyline.points[varying_parm] = 0.;
    polyline.points[varying_parm+2] = 1.0;

    OM_BLOCK_MOVE (polyline.points, poly_range, sizeof(IGRdouble)*4);
    EM2dbxinc (poly_range, partolbasis->tol);
    
    is_cgr_split = TRUE;

    for (bix = 0; bix < cgr_info->num_bnds; bix++)
    {
      grbnd_info = cgr_info->grbnd_info[bix];

      if ( EM2dbxbxint (poly_range, grbnd_info->range) )
      {
       sbnd_info = grbnd_info->sbnd_info;

       while (sbnd_info)
       {
         if ( EM2dbxbxint (poly_range, sbnd_info->range) )
         {
           bnd_info = sbnd_info->bnd_info;
           bdry = bnd_info->bdry;
           num_inters = NULL;
           gr_inters = NULL;

           EM2dpycutint (&rc, bdry->num_points, bdry->points, NULL, 
             sbnd_info->range, polyline.num_points, polyline.points,
             poly_range, trim_options, partolbasis->tol, NULL, NULL, 
             NULL_OBJID, NULL, &num_inters, &gr_inters, NULL);
           EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);  

           /*
            * Put the intersections in the corresponding bnds_info.
            */

           gr_inters_ptr = gr_inters;
           int_info = &bnd_info->int_info;
        
           if ( (int_info->num_ints + num_inters) > int_info->int_arrsz)
           {
             arrsz = int_info->int_arrsz * 2;
             EFmemory_allocation (&rc, (IGRchar **) &int_info->int_pts, 
                (int_info->num_ints + num_inters) * 2, &arrsz, 
                sizeof(IGRdouble), 20, 10);
             EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);

             EFmemory_allocation (&rc, (IGRchar **) &int_info->ptinx, 
               int_info->num_ints + num_inters, &int_info->int_arrsz, 
               sizeof(IGRint), 10, 5);
             EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);

           } /* if((int_info->num_ints+num_inters)>int_info->int_arrsz) */
       
           for (i = 0; i < num_inters; i++)
           {
            ptinx = gr_inters_ptr->edgepar.span_inx;
            add_pt = TRUE;

            for (int_inx = 0; int_inx < int_info->num_ints; int_inx++)
            {
              if (ptinx < int_info->ptinx[int_inx])    break;

              else if (ptinx == int_info->ptinx[int_inx])         
              {
               if (EM2ddistptpt (&int_info->int_pts[2*int_inx],
                     gr_inters_ptr->point) <= partolbasis->tol)
               {
                 add_pt = FALSE;      break;
               }
               else
               { 
                pt_uv = &bdry->points[ptinx*2];

                if ( (fabs(gr_inters_ptr->point[0]        - pt_uv[0]) <=
                      fabs(int_info->int_pts[int_inx*2]   - pt_uv[0]))  &&
                     (fabs(gr_inters_ptr->point[1]        - pt_uv[1]) <=
                      fabs(int_info->int_pts[int_inx*2+1] - pt_uv[1]) ) )
                 break;
               }
 
              } /* else if (ptinx == int_info->ptinx[int_inx]) */

            } /* for(int_inx = 0;int_inx<int_info->num_ints; int_inx++) */

            if (add_pt)
            {
             if (int_inx != int_info->num_ints)
             {
              num_elems = int_info->num_ints - int_inx;
              OM_BLOCK_MOVE (&int_info->int_pts[2*int_inx], 
                             &int_info->int_pts[2 * (int_inx+1)], 
                             num_elems * 2 * sizeof(IGRdouble));
              OM_BLOCK_MOVE (&int_info->ptinx[int_inx],
                             &int_info->ptinx[int_inx+1],
                             num_elems * sizeof(IGRint));

             } /* if (int_inx != int_info->num_ints) */
 
             OM_BLOCK_MOVE (gr_inters_ptr->point, 
                    &int_info->int_pts[2*int_inx], sizeof(IGRdouble) * 2);
             int_info->ptinx[int_inx] = ptinx;
             int_info->num_ints++;

            } /* if (add_pt) */

            gr_inters_ptr = gr_inters_ptr->next;

           } /* for (i = 0; i < num_inters; i++) */

           EMsfintedpar_free (gr_inters, NULL);
 
         } /* if ( EM2dbxbxint (poly_range, sbnd_info->range) ) */

         sbnd_info = sbnd_info->next;

       } /* while (sbnd_info) */

     } /* if ( EM2dbxbxint (poly_range, grbnd_info->range) ) */

   } /* for (bix = 0; bix < cgr_info->num_bnds; bix++) */

  } /* for (cix = 0; cix < num_gr_cuts; cix++) */

 } /* for ( cut_type = 0; cut_type < 2; cut_type++) */

 if (is_cgr_split)
 {
  /*
   * The incoming group is subdivided into subgroups using
   * cvgr_u_cuts and cgr_v_cuts. For each of the resultant subgroups,
   * the following information is extracted:
   *  o The boundary lying inside/overlapping the subgroup range.
   *  o The bounds of the above boundary.
   */

  num_res_sgrs = (num_cgr_u_cuts + 1) * (num_cgr_v_cuts + 1);

  if ( (*num_sp_grs + num_res_sgrs) > *sp_grs_arrsz)
  {
   EFmemory_allocation (&rc, (IGRchar ***) sp_grs_info, 
     (*num_sp_grs + num_res_sgrs), sp_grs_arrsz, 
     sizeof(struct EMSgr_info *), 10, 5);
   EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);
  }

  for (vinx = 0; vinx <= num_cgr_v_cuts; vinx++)
  {
   for (uinx = 0; uinx <= num_cgr_u_cuts; uinx++)
   {
    EFget_gr_info (*trsh_grs, num_trsh_grs, sp_gr);

    if (uinx == 0) sp_gr->range[0] = cgr_info->range[0];
    else sp_gr->range[0] = cgr_u_cuts[uinx-1];
    if (vinx == 0) sp_gr->range[1] = cgr_info->range[1];
    else sp_gr->range[1] = cgr_v_cuts[vinx-1];
    if (uinx == num_cgr_u_cuts) sp_gr->range[2] = cgr_info->range[2];
    else sp_gr->range[2] = cgr_u_cuts[uinx];
    if (vinx == num_cgr_v_cuts) sp_gr->range[3] = cgr_info->range[3];
    else sp_gr->range[3] = cgr_v_cuts[vinx];
    
    for (bix = 0; bix < cgr_info->num_bnds; bix++)
    {
     grbnd_info = cgr_info->grbnd_info[bix];

     if (grbnd_info)
     {
      if (EM2dbxbxnest (grbnd_info->range, sp_gr->range))
      {
        EFadd_bnd_to_grp (&rc, sp_gr, grbnd_info, NULL, TRUE, TRUE,
          NULL, NULL, NULL, NULL, num_trsh_grbnds, *trsh_grbnds, 
          num_trsh_sbnds, *trsh_sbnds);
        EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
        cgr_info->grbnd_info[bix] = NULL;

      }
      else if (EM2dbxbxint (grbnd_info->range, sp_gr->range))
      {
        sbnd_info = grbnd_info->sbnd_info;
        last_sbnd = &grbnd_info->sbnd_info;
        while (sbnd_info)
        {
         if (EM2dbxbxnest (sbnd_info->range, sp_gr->range))
         {
           *last_sbnd = sbnd_info->next;
           EFadd_bnd_to_grp (&rc, sp_gr, grbnd_info, sbnd_info, FALSE,
             TRUE, NULL, NULL, NULL, NULL, num_trsh_grbnds, *trsh_grbnds, 
             num_trsh_sbnds, *trsh_sbnds);
           EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
           sbnd_info = *last_sbnd;

         } /* if (EM2dbxbxnest (sbnd_info->range, sp_gr->range)) */
         else 
         {
          if (EM2dbxbxint (sbnd_info->range, sp_gr->range))
          {
           bnd_info = sbnd_info->bnd_info;
           int_inx = 0;
           int_info = &bnd_info->int_info;
           first_int_found = FALSE;
           beg_inx = grbnd_info->whole_bnd ? 0 : sbnd_info->beg_inx;
           end_inx = grbnd_info->whole_bnd ? (sbnd_info->num_pts -1 ) :
                                              sbnd_info->end_inx;

           while (int_inx < int_info->num_ints && !first_int_found)
           {
            if ((end_inx >= beg_inx) ?
                (int_info->ptinx[int_inx] >= beg_inx &&
                int_info->ptinx[int_inx] <= end_inx) :
                (int_info->ptinx[int_inx] >= beg_inx ||
                int_info->ptinx[int_inx] <= end_inx) )

            {
             if ( EFpt_lie_on_range_box (&int_info->int_pts[2*int_inx],
                        sp_gr->range, partolbasis->tol))
             {
              if (int_inx == (int_info->num_ints - 1) )
                next_pt = 
                  &bnd_info->bdry->points[(int_info->ptinx[int_inx]+1)*2];
              else
              {
               if (int_info->ptinx[int_inx] == int_info->ptinx[int_inx+1])
                 next_pt = &int_info->int_pts[2*(int_inx+1)];
               else
                 next_pt = 
                  &bnd_info->bdry->points[(int_info->ptinx[int_inx]+1)*2];
  
              }
 
              if (EM2dptinbx (sp_gr->range, next_pt) ||
                  EFpt_lie_on_range_box (next_pt, sp_gr->range, 
                                         partolbasis->tol) )
               first_int_pt_used = TRUE;
              else
              {
               first_int_pt_used = FALSE;
               first_int_inx = int_inx;
               int_inx++;
              }
              first_int_found = TRUE;

              }/* if (EFpt_lie_on_range_box (&int_info->int_pts .. */
              else
                int_inx++; 
            } /* if (int_info->ptinx[int_inx] >= beg_inx && ... */
            else 
             int_inx++;

           } /* while (int_inx< int_info->num_ints && !first_int_found) */

           if (first_int_found)
           {
            while (int_inx < int_info->num_ints)
            {
             if ( EFpt_lie_on_range_box (&int_info->int_pts[2*int_inx],
                         sp_gr->range, partolbasis->tol))
             {
               beg_int_inx = int_inx;
               for (int_inx = int_inx+1; int_inx < int_info->num_ints; 
                    int_inx++)
               {
                 if (EFpt_lie_on_range_box (&int_info->int_pts[2*int_inx],
                      sp_gr->range, partolbasis->tol))
                 {
                  if ((end_inx >= beg_inx) ?
                      (int_info->ptinx[int_inx] >= beg_inx &&
                       int_info->ptinx[int_inx] <= end_inx) :
                      (int_info->ptinx[int_inx] >= beg_inx ||
                       int_info->ptinx[int_inx] <= end_inx) )
                   {
                    EFadd_bnd_to_grp (&rc, sp_gr, grbnd_info, sbnd_info,
                     FALSE, FALSE, &int_info->int_pts[2*beg_int_inx], 
                     &int_info->int_pts[2*int_inx], 
                     int_info->ptinx[beg_int_inx], 
                     int_info->ptinx[int_inx], num_trsh_grbnds, 
                     *trsh_grbnds, num_trsh_sbnds, *trsh_sbnds);
                    EMerr_hndlr (!(1&rc),*EFmsg,EMS_E_Fail,wrapup);
                   }
                   int_inx++;
                   break;                 
                  }

               } /* for (int_inx = int_inx+1; int_inx < int_info */

             } /* if (EFpt_lie_on_range_box (&int_info->int_pts */
             else
              int_inx++;

            } /* while (int_inx < int_info->num_ints) */
           
            if (!first_int_pt_used)
            {
             EFadd_bnd_to_grp (&rc, sp_gr, grbnd_info, sbnd_info, FALSE,  
               FALSE, &int_info->int_pts[2*beg_int_inx], 
               &int_info->int_pts[2*first_int_inx], 
               int_info->ptinx[beg_int_inx], 
               int_info->ptinx[first_int_inx], num_trsh_grbnds, 
               *trsh_grbnds, num_trsh_sbnds, *trsh_sbnds);
             EMerr_hndlr (!(1&rc),*EFmsg,EMS_E_Fail,wrapup);
         
            } /* if (!first_int_pt_used) */

           } /* if (first_int_found) */

          } /* if (EM2dbxbxint (sbnd_info->range, sp_gr->range)) */

          last_sbnd = &sbnd_info->next;
          sbnd_info = sbnd_info->next;

         } /* else for if (EM2dbxbxnest(sbnd_info->range,sp_gr->range)) */

        } /* while (sbnd_info) */
        
      } /* else if (EM2dbxbxint (grbnd_info->range, sp_gr->range)) */

     } /* if (grbnd_info) */

    } /* for (bix = 0; bix < cgr_info->num_bnds; bix++) */
    
    /*
     * Check if the split group has any boundaries. If not, it can
     * either be completely in hole or in area region. If it is 
     * completely in hole region, do not add it to sp_grs returned.
     */

    if (sp_gr->num_bnds)
    {
     /*
      * sort the non_whole grbnd into grbnds that will close 
      * by linking its sbnds.
      */

     EFsort_sbnds (&rc, sp_gr, trsh_grbnds, num_trsh_grbnds,
      trsh_grbnds_arrsz, trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz,
      0.0, NULL, partolbasis);
     EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

     for (bix = 0; bix < sp_gr->num_bnds; bix++)
     {
      num_pts = sp_gr->grbnd_info[bix]->num_pts;
      if (num_pts > MAX_POINTS_PER_BOUNDARY) 
         sp_gr->overflow |= BND_PTS_OVERFLOW;
      
      num_type_25_needed = num_pts/MAX_PNTS_PER_TYPE_25;
      if ( (num_type_25_needed * MAX_PNTS_PER_TYPE_25) != num_pts)
        num_type_25_needed++;
      sp_gr->num_type_25_needed += num_type_25_needed;

     } /* for (bix = 0; bix < sp_gr->num_bnds; bix++) */

     if (sp_gr->num_type_25_needed > MAX_TYPE_25_ELEMENTS)
        sp_gr->overflow |= BND_ELEMS_OVERFLOW;

     (*sp_grs_info)[(*num_sp_grs)++] = sp_gr;

    } /* if (sp_gr->num_bnds) */
    else
    {
      IGRlong                 OM_stat;
      struct EMSptloc_info    pt_loc;
      IGRdouble               mid_pt[2];

      for (i = 0; i < 2; i++)
        mid_pt[i] = (sp_gr->range[i] + sp_gr->range[i+2]) / 2.;

      pt_loc.options = EMS_PTLOC_LS_INFINITE;
      OM_stat = om$send (msg = message EMSloopset.EMpt_location (&rc,
                          mid_pt, &pt_loc, partolbasis),
                          senderid = NULL_OBJID,
                          targetid = ls_id,
                          targetos = cur_os);
      EMerr_hndlr (!(1&rc&OM_stat),*EFmsg, EMS_E_LoopsetError,wrapup);

      switch (pt_loc.location)
      {

        case EMS_L_INAREA:
         (*sp_grs_info)[(*num_sp_grs)++] = sp_gr;
          break;

        case EMS_L_INHOLE:
          EFtrash_gr_info (trsh_grs, num_trsh_grs, trsh_grs_arrsz, 
                           sp_gr);
          break;

        default:
          *EFmsg = EMS_E_Fail;
          goto wrapup;

      } /* switch (pt_loc.location) */

    } /* else for if (sp_gr->num_bnds) */

   } /* for (uinx = 0; uinx <= num_gr_u_inx; uinx++) */

  } /* for (vinx = 0; vinx <= num_gr_v_cuts; vinx++) */

  /*
   * Remove the group that is split from the grs_info.
   * Move it and its grbnd_infos into reusable stack.
   */

  if ( (*num_trsh_grbnds + cgr_info->num_bnds) > *trsh_grbnds_arrsz)
  {
   EFmemory_allocation (&rc, (IGRchar ***) trsh_grbnds, 
     (*num_trsh_grbnds + cgr_info->num_bnds), trsh_grbnds_arrsz,
     sizeof(struct EMSgrbnd_info *), 10, 5);
   EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);
       
  }

  for (bix = 0; bix < cgr_info->num_bnds; bix++) 
  {
   if (cgr_info->grbnd_info[bix])
   {
    sbnd_info = cgr_info->grbnd_info[bix]->sbnd_info;

    while (sbnd_info)
    {
      EFtrash_sbnd (trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz, 
                    sbnd_info);
      sbnd_info = sbnd_info->next;

    } /* while (sbnd_info) */

    (*trsh_grbnds)[(*num_trsh_grbnds)++] = cgr_info->grbnd_info[bix];

   } /* if (cgr_info->grbnd_info[bix]) */

  } /* for (bix = 0; bix < cgr_info->num_bnds; bix++)  */

  EFtrash_gr_info (trsh_grs, num_trsh_grs, trsh_grs_arrsz, cgr_info);

  blk_size = (*num_grs - 1 - grix) * sizeof(struct EMSgr_info *);
  if (blk_size)
   OM_BLOCK_MOVE (&grs_info[grix+1], &grs_info[grix], blk_size);
  (*num_grs)--;

  } /* if (is_cgr_split) */
  else
   grix++;

 } /* while (grix < *num_grs) */
  
wrapup:
 EMWRAPUP (*EFmsg, *EFmsg, "EFsplit_groups");
 if (cgr_u_cuts) om$dealloc (ptr = cgr_u_cuts);
 if (cgr_v_cuts) om$dealloc (ptr = cgr_v_cuts);
 return;
  
} /* EFsplit_groups () */


static void EFget_gr_splt_cut_lines (EFmsg, gr_info, cut_type, gr_cuts, 
                    num_gr_cuts, gr_cuts_arrsz, num_ovf_cuts, par_cht)
 IGRlong           *EFmsg;
 struct EMSgr_info *gr_info;
 IGRint            cut_type;
 IGRdouble         **gr_cuts;
 IGRint            *num_gr_cuts;
 IGRint            *gr_cuts_arrsz;
 IGRint            *num_ovf_cuts; 
 IGRdouble         par_cht;
{
 struct    EMSgrbnd_info  *grbnd_info;
 IGRdouble                sgr_range[4], closest_parm, best_parm_so_far,
                          cm_area_range[2];
 IGRint                   bix, num_type_25_needed, num_pts, count;
 IGRboolean               cntinue, once_crossed_limit;
 extern void              EFmemory_allocation();

 /* ************************************************************ */

  *EFmsg = EMS_S_Success;

  OM_BLOCK_MOVE (gr_info->range, sgr_range, sizeof(IGRdouble)*4);
  sgr_range[cut_type+2] = sgr_range[cut_type];

  while (sgr_range[cut_type+2] < gr_info->range[cut_type+2])
  {
   closest_parm = gr_info->range[cut_type+2];
   for (bix = 0; bix < gr_info->num_bnds; bix++)
   {
    if ( ( gr_info->grbnd_info[bix]->range[cut_type+2] > 
           sgr_range[cut_type+2] )      &&
         ( gr_info->grbnd_info[bix]->range[cut_type+2] < closest_parm ) )
     closest_parm = gr_info->grbnd_info[bix]->range[cut_type+2];
   }

   closest_parm += par_cht;
   if (closest_parm < gr_info->range[cut_type]) 
      closest_parm = gr_info->range[cut_type];
   else if (closest_parm > gr_info->range[cut_type+2])
      closest_parm = gr_info->range[cut_type+2];

   sgr_range[cut_type+2] = closest_parm;
   best_parm_so_far = sgr_range[cut_type];
   cntinue = TRUE;
   num_type_25_needed = 0;
   once_crossed_limit = FALSE;

   while (cntinue)
   {
     for (bix = 0; bix < gr_info->num_bnds; bix++)
     {
       grbnd_info = gr_info->grbnd_info[bix];
       if (EM2dbxbxnest (grbnd_info->range, sgr_range) )
       {
         EFnum_type_25_needed(grbnd_info->num_pts, count);
         num_type_25_needed += count;
       }
       else if (EM2dbxbxint (grbnd_info->range, sgr_range))
       {
        /*
         * In case the sgroup range is intersecting with a 
         * boundary, need to find out how many boundary elements.
         * It is assumed that it will not result into more than 2
         * elements.
         */

        cm_area_range[0] = sgr_range[cut_type] <= 
                                  grbnd_info->range[cut_type] ? 
                   grbnd_info->range[cut_type] : sgr_range[cut_type];
        cm_area_range[1] = sgr_range[cut_type+2] <=
                                    grbnd_info->range[cut_type+2] ?
                   sgr_range[cut_type+2] : grbnd_info->range[cut_type+2];
        num_pts = (cm_area_range[1] - cm_area_range[0]) / 
         (grbnd_info->range[cut_type+2] - grbnd_info->range[cut_type]) *
         grbnd_info->num_pts / 2;
       
        EFnum_type_25_needed(num_pts, count);
        num_type_25_needed += (count * 2);
 
       } /* else if (EM2dbxbxint (grbnd_info->range, sgr_range)) */
    
     } /* for (bix = 0; bix < gr_info->num_bnds; bix++) */
  
     if (num_type_25_needed <= MAX_TYPE_25_ELEMENTS)
     {
      if ( once_crossed_limit ||
           ( fabs(sgr_range[cut_type+2] - gr_info->range[cut_type+2]) 
               <= par_cht) )
        cntinue = FALSE;
      else
      {
       closest_parm = gr_info->range[cut_type+2];
       for (bix = 0; bix < gr_info->num_bnds; bix++)
        if ( (gr_info->grbnd_info[bix]->range[cut_type+2] > 
               sgr_range[cut_type+2])            &&
             (gr_info->grbnd_info[bix]->range[cut_type+2] < closest_parm))
           closest_parm = gr_info->grbnd_info[bix]->range[cut_type+2];

       closest_parm += par_cht;
       if (closest_parm < gr_info->range[cut_type]) 
        closest_parm = gr_info->range[cut_type];
       else if (closest_parm > gr_info->range[cut_type+2])
         closest_parm = gr_info->range[cut_type+2];

       best_parm_so_far = sgr_range[cut_type+2];
       sgr_range[cut_type+2] = closest_parm;
       num_type_25_needed = 0;          
      }

     } /* if (num_type_25_needed <= MAX_TYPE_25_NEEDED) */
     else 
     {
       closest_parm = sgr_range[cut_type];
       for (bix = 0; bix < gr_info->num_bnds; bix++)
         if ((gr_info->grbnd_info[bix]->range[cut_type] < 
              sgr_range[cut_type+2])  &&
             (gr_info->grbnd_info[bix]->range[cut_type] >
              closest_parm))
           closest_parm = gr_info->grbnd_info[bix]->range[cut_type];

       closest_parm -= par_cht;
       if (closest_parm < gr_info->range[cut_type]) 
         closest_parm = gr_info->range[cut_type];
       else if (closest_parm > gr_info->range[cut_type+2])
         closest_parm = gr_info->range[cut_type+2];

       if ( fabs(closest_parm - sgr_range[cut_type]) <= par_cht    ||
            closest_parm <= best_parm_so_far )
       {
         if (best_parm_so_far == sgr_range[cut_type])
           (*num_ovf_cuts)++;
         else
           sgr_range[cut_type+2] = best_parm_so_far;          

        /*
         * Expand the sgr_range to an extent such that it 
         * does not intersect with any extra boundaries.
         */

        closest_parm = gr_info->range[cut_type+2];

        for (bix = 0; bix < gr_info->num_bnds; bix++)
        {
          if ( (gr_info->grbnd_info[bix]->range[cut_type] >= 
                sgr_range[cut_type+2]) &&
               (gr_info->grbnd_info[bix]->range[cut_type] <= 
                closest_parm) )
           closest_parm = gr_info->grbnd_info[bix]->range[cut_type];

        }

        if (fabs(closest_parm - gr_info->range[cut_type+2]) > par_cht)
         sgr_range[cut_type+2] = closest_parm;
        cntinue = FALSE;

       }/* if ( fabs(closest_parm - sgr_range[cut_type]) <= par_cht    &&
            closest_parm <= best_parm_so_far ) */
       else
       {
           sgr_range[cut_type+2] = closest_parm;
           num_type_25_needed = 0;
           once_crossed_limit = TRUE;
       }

     } /* if (num_type_25_needed <= MAX_TYPE_25_NEEDED) */

   } /* while (cntinue) */
   
   /*
    * Add the cutting line.
    */
   
   if (fabs(sgr_range[cut_type+2]-gr_info->range[cut_type+2]) >= par_cht)
   {
    if ((*num_gr_cuts + 1) > *gr_cuts_arrsz)
    {
      EFmemory_allocation (EFmsg, (IGRchar **) gr_cuts, 
        *num_gr_cuts+1, gr_cuts_arrsz, sizeof(IGRdouble),
        10, 5);
      EMerr_hndlr (!(1 & *EFmsg), *EFmsg, EMS_E_NoDynamicMemory, wrapup);
    }

    (*gr_cuts)[(*num_gr_cuts)++] = sgr_range[cut_type+2];
    sgr_range[cut_type] = sgr_range[cut_type+2];

   } /* if (sgr_range[cut_type+2] < gr_info->range[cut_type+2]) */

  } /* while (sgr_range[cut_type+2] < gr_info->range[cut_type+2]) */

 wrapup:
  return;

} /* void EFget_gr_splt_cut_lines () */



/*
 * The following function adds a boundary to a group
 */

static void EFadd_bnd_to_grp (EFmsg, gr_info, in_grbnd_info, in_sbnd_info,
                       is_grbnd, whole_sbnd, beg_pt, end_pt, beg_inx, 
                       end_inx, num_trsh_grbnds, trsh_grbnds,
                       num_trsh_sbnds, trsh_sbnds)

 IGRlong              *EFmsg;
 struct EMSgr_info    *gr_info;
 struct EMSgrbnd_info *in_grbnd_info;
 struct EMSsbnd_info  *in_sbnd_info;
 IGRboolean           is_grbnd;
 IGRboolean           whole_sbnd;
 IGRdouble            *beg_pt, *end_pt;
 IGRint               beg_inx, end_inx;
 IGRint               *num_trsh_grbnds;
 struct EMSgrbnd_info **trsh_grbnds;
 IGRint               *num_trsh_sbnds;
 struct EMSsbnd_info  **trsh_sbnds;

{
  struct EMSgrbnd_info *test_grbnd, *grbnd_info;
  struct EMSsbnd_info  *sbnd_info = NULL;
  struct EMSbnd_info   *bnd_info;
  IGRdouble            tmp_range[4];
  IGRlong              rc;
  IGRint               i, bix;
  IGRboolean           is_sbnd_processed, end_pt_greater_than_beg_pt;
  extern void          EFmemory_allocation(), EM2dbx();

  /* **************************************************************** */

  *EFmsg = EMS_S_Success;
  
  if ( (gr_info->num_bnds+1) > gr_info->grbnd_arrsz )
  {
    EFmemory_allocation (&rc, (IGRchar ***) &gr_info->grbnd_info,
      gr_info->num_bnds+1, &gr_info->grbnd_arrsz, 
      sizeof(struct EMSgrbnd_info *), MAX_TYPE_25_ELEMENTS, 5);
    EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
  }

  if (is_grbnd)
   gr_info->grbnd_info[gr_info->num_bnds++] = in_grbnd_info;
  else
  {
    if (whole_sbnd)
     sbnd_info = in_sbnd_info;
    else
    {
      EFget_sbnd (trsh_sbnds, num_trsh_sbnds, sbnd_info);
      sbnd_info->bnd_info = in_sbnd_info->bnd_info;
      bnd_info = sbnd_info->bnd_info;

      OM_BLOCK_MOVE (beg_pt, sbnd_info->beg_pt, sizeof(IGRdouble)*2);
      OM_BLOCK_MOVE (end_pt, sbnd_info->end_pt, sizeof(IGRdouble)*2);
      sbnd_info->beg_inx = beg_inx;
      sbnd_info->end_inx = end_inx;

      EFis_end_pt_greater_than_beg_pt(beg_inx, end_inx, beg_pt, end_pt,
           bnd_info->bdry, end_pt_greater_than_beg_pt);

      if (end_pt_greater_than_beg_pt)
        sbnd_info->num_pts = end_inx - beg_inx;
      else
        sbnd_info->num_pts = bnd_info->bdry->num_points - beg_inx - 1;

      if (sbnd_info->num_pts)
      {
        EM2dbx (sbnd_info->num_pts, 
           &(bnd_info->bdry->points[2*(beg_inx+1)]), sbnd_info->range);
      }
      else
      {
        sbnd_info->range[0] = sbnd_info->range[1] = MAXDOUBLE;
        sbnd_info->range[2] = sbnd_info->range[3] = MINDOUBLE;
      }

      if (!end_pt_greater_than_beg_pt && end_inx)
      {
        sbnd_info->num_pts += end_inx;
        EM2dbx (end_inx, &bnd_info->bdry->points[2], tmp_range);

        for (i = 0; i < 4; i ++)
        {
          if (tmp_range[i] < sbnd_info->range[i%2])
            sbnd_info->range[i%2] = tmp_range[i];
          if (tmp_range[i] > sbnd_info->range[i%2+2])
            sbnd_info->range[i%2+2] = tmp_range[i];
        }

      } /* if (!end_pt_greater_than_beg_pt && end_inx) */
   
      for (i = 0; i < 2; i++)
      {
        if (beg_pt[i] < sbnd_info->range[i])
           sbnd_info->range[i] = beg_pt[i];
        if (beg_pt[i] > sbnd_info->range[i+2])
           sbnd_info->range[i+2] = beg_pt[i];

        if (end_pt[i] < sbnd_info->range[i])
           sbnd_info->range[i] = end_pt[i];
        if (end_pt[i] > sbnd_info->range[i+2])
           sbnd_info->range[i+2] = end_pt[i];

      } /* for (i = 0; i < 2; i++) */

      sbnd_info->num_pts += 2;
    } /* else for if (whole_sbnd) */

    /*
     * If there is already a non_whole grbnd present in the 
     * gr_info, append this sbnd to it. Otherwise, create a
     * new grbnd and attach this sbnd to it.
     */

    sbnd_info->next = NULL;
    is_sbnd_processed = FALSE;
    for (bix = 0; bix < gr_info->num_bnds && !is_sbnd_processed; bix++)
    {
     test_grbnd = gr_info->grbnd_info[bix];
     if (!test_grbnd->whole_bnd)
     {
      sbnd_info->next = test_grbnd->sbnd_info;
      test_grbnd->sbnd_info = sbnd_info;
      is_sbnd_processed = TRUE;
     }
    } /* for (bix=0;bix< gr_info->num_bnds && !is_sbnd_processed;bix++) */

    if (!is_sbnd_processed)
    {
      EFget_grbnd (trsh_grbnds, num_trsh_grbnds, grbnd_info);
/*
      OM_BLOCK_MOVE (sbnd_info->range, grbnd_info->range, 
                     sizeof(IGRdouble)*4);
      grbnd_info->num_pts = sbnd_info->num_pts;
*/
      grbnd_info->whole_bnd = FALSE;
      grbnd_info->sbnd_info = sbnd_info;
      gr_info->grbnd_info[gr_info->num_bnds++] = grbnd_info;

    } /* if (!is_sbnd_processed) */

  } /* else for if (is_grbnd) */

wrapup:
  return;

} /* void EFadd_bnd_to_grp () */

/*
 * Given a set of non_overflowing groups, the following function
 * tries to merge these groups along the cutting lines. It should
 * be noted that the groups will be merged if and only if the
 * whole cutting line can be removed i.e., the resultant groups will
 * still have their range boxes match exactly with their adjacent groups.
 */

static void EFmerge_groups_info (EFmsg, grs_info, num_grs, 
     num_u_non_merge_pars, u_non_merge_pars, num_v_non_merge_pars,
     v_non_merge_pars, trsh_grs_info, 
     num_trsh_grs, trsh_grs_arrsz, trsh_grbnds, num_trsh_grbnds,
     trsh_grbnds_arrsz, trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz,
     partolbasis)

IGRlong              *EFmsg;
struct EMSgr_info    **grs_info;
IGRint               *num_grs;
IGRint               num_u_non_merge_pars;
IGRdouble            *u_non_merge_pars;
IGRint               num_v_non_merge_pars;
IGRdouble            *v_non_merge_pars;
struct EMSgr_info    ***trsh_grs_info;
IGRint               *num_trsh_grs;
IGRint               *trsh_grs_arrsz;
struct EMSgrbnd_info ***trsh_grbnds;
IGRint               *num_trsh_grbnds;
IGRint               *trsh_grbnds_arrsz;
struct EMSsbnd_info  ***trsh_sbnds;
IGRint               *num_trsh_sbnds;
IGRint               *trsh_sbnds_arrsz;
struct EMSpartolbasis *partolbasis;
{
 struct EMSgr_info     *temp_gr, **mrg_grs_info = NULL, *pr_gr[2], 
                       *mrg_gr, *buf_mrg_grs_info[MERGE_INFO_BUF_SIZE];

 struct EMSgrbnd_info  *mrg_grbnd, *grbnd_info;

 struct EMSsbnd_info   **mrg_sbnd_ptr, *sbnd_info, *mrg_sbnd, 
                       *next_mrg_sbnd;

 IGRdouble             *u_cuts = NULL, buf_u_cuts[MERGE_INFO_BUF_SIZE],
                       *v_cuts = NULL, buf_v_cuts[MERGE_INFO_BUF_SIZE],
                       *cuts, cut_value, *gr_range, mrg_gr_min_bnd,
                       mrg_gr_max_bnd, *non_merge_pars;
 IGRlong               rc;
 IGRint                i, j, sort_inx, num_u_cuts, num_v_cuts, *num_cuts,
                       num_pairs, cut_type, cix, prix, bix, grix, 
                       num_type_25_needed, num_pts, num_pts_inc, count, 
                       blk_size, num_mrg_grs, *pr_gr0_inx = NULL,
                       *pr_gr1_inx = NULL, cut_inx, num_non_merge_pars,
                       buf_pr_gr0_inx[MERGE_INFO_BUF_SIZE],
                       buf_pr_gr1_inx[MERGE_INFO_BUF_SIZE], varying_parm;


 IGRboolean            mrg_grs_info_malloced = FALSE, mrg_possible,
                       pr_gr_with_non_whole_bnds[2], insert_cut,
                       merging_was_performed, cuts_malloced = FALSE,
                       pr_gr1_found;

 extern void           EFmemory_allocation();

 /* **************************************************************** */

 *EFmsg = EMS_S_Success;

 /*
  * sort the groups such that they are ascending in v and for
  * each of the v limit are ascending in u.
  */

 for (i = 0; i < *num_grs; i++)
 {
   sort_inx = i;
   for (j = i+1; j < *num_grs; j++)
   {
    if ((grs_info[j]->range[1] < grs_info[sort_inx]->range[1]) ||
        (grs_info[j]->range[1] == grs_info[sort_inx]->range[1] &&
         grs_info[j]->range[0] < grs_info[sort_inx]->range[0]) )
      sort_inx = j;

   } /* for (j = i; j < *num_grs; j++) */

   if (sort_inx != i)
   {
     temp_gr = grs_info[i];
     grs_info[i] = grs_info[sort_inx];
     grs_info[sort_inx] = temp_gr;     
   }

 } /* for (i = 0; i < *num_grs; i++) */

 /*
  * Get the number of u_cuts and v_cuts
  */
 
 if ( (*num_grs) > MERGE_INFO_BUF_SIZE)
 {
  u_cuts = (IGRdouble *) om$malloc(size = sizeof(IGRdouble) * (*num_grs));
  EMerr_hndlr (!u_cuts, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

  v_cuts = (IGRdouble *) om$malloc(size = sizeof(IGRdouble) * (*num_grs));
  EMerr_hndlr (!v_cuts, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
  cuts_malloced = TRUE;

 } /* if ( (*num_grs) > MERGE_INFO_BUF_SIZE) */
 else
 {
  u_cuts = buf_u_cuts; 
  v_cuts = buf_v_cuts; 
 }

 num_u_cuts = num_v_cuts = 0;
 for (cut_type = 0; cut_type < 2; cut_type++)
 {
  if (cut_type == CUT_ALONG_U)
  {
   num_cuts = &num_u_cuts;
   cuts = u_cuts;
   num_non_merge_pars = num_u_non_merge_pars;
   non_merge_pars = u_non_merge_pars;
  
  } /*  if (cut_type == CUT_ALONG_U) */
  else
  {
   num_cuts = &num_v_cuts;
   cuts = v_cuts;
   num_non_merge_pars = num_v_non_merge_pars;
   non_merge_pars = v_non_merge_pars;
  
  } /*  else for if (cut_type == CUT_ALONG_U) */
 
  for (grix = 0; grix < (*num_grs); grix++)
  {
   for (i = 0; i < 2; i++)
   {
    insert_cut = TRUE;
    cut_inx = 0;
    cut_value = grs_info[grix]->range[cut_type + (i ? 2 : 0)];

    for (j = 0; j < num_non_merge_pars && insert_cut; j++)
     if (cut_value == non_merge_pars[j]) insert_cut = FALSE;

    if (insert_cut)
    {
     for (cut_inx = 0; cut_inx < *num_cuts && insert_cut; cut_inx++)
     {
      if (cut_value == cuts[cut_inx]) insert_cut = FALSE;
      else
       if (cut_value < cuts[cut_inx]) break;

     } /* for (cut_inx =0; cut_inx < *num_cuts && insert_cut;cut_inx++) */

     if (insert_cut)
     {
      if ((*num_cuts - 1 - cut_inx) > 0)
       OM_BLOCK_MOVE (&cuts[cut_inx], &cuts[cut_inx+1], 
                      sizeof(IGRdouble) * (*num_cuts - cut_inx));
      cuts[cut_inx] = cut_value;
      (*num_cuts)++;     

     } /* if (insert_cut) */

    } /* if (insert_cut) */

   } /* for (i = 0; i < 2; i++) */

  } /* for (grix = 0; grix < (*num_grs); grix++) */

 } /* for (cut_type = 0; cut_type < 2; cut_type++) */

 num_pairs = (num_u_cuts > num_v_cuts ? num_u_cuts : num_v_cuts) + 1;
 if (num_pairs > MERGE_INFO_BUF_SIZE)
 {
   mrg_grs_info = (struct EMSgr_info **) om$malloc (size = num_pairs
                      * sizeof(struct EMSgr_info *));
   EMerr_hndlr (!mrg_grs_info, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
   mrg_grs_info_malloced = TRUE;

   pr_gr0_inx = (IGRint *) om$malloc (size = num_pairs * sizeof(IGRint));
   EMerr_hndlr (!pr_gr0_inx, *EFmsg, EMS_E_NoDynamicMemory, wrapup);

   pr_gr1_inx = (IGRint *) om$malloc (size = num_pairs * sizeof(IGRint));
   EMerr_hndlr (!pr_gr1_inx, *EFmsg, EMS_E_NoDynamicMemory, wrapup);
 }  
 else
 { 
  mrg_grs_info = buf_mrg_grs_info;
  pr_gr0_inx = buf_pr_gr0_inx;
  pr_gr1_inx = buf_pr_gr1_inx;
 }

 for (cut_type = 0; cut_type < 2; cut_type++)
 {
  if (cut_type == CUT_ALONG_U)
  {
   num_cuts = &num_u_cuts;
   cuts = u_cuts;
   varying_parm = 1;
  }
  else
  {
   num_cuts = &num_v_cuts;
   cuts = v_cuts;
   varying_parm = 0;
  }

  for (cix = 0; cix < *num_cuts; cix++)
  {
   mrg_possible = TRUE;
   grix = num_pairs = 0;

   while (grix < *num_grs)
   {
    gr_range = grs_info[grix]->range;
    if (gr_range[2+cut_type] == cuts[cix])
    {
     pr_gr1_found = FALSE;
     for (i = grix+1; i < *num_grs; i++)
     {
      if (gr_range[varying_parm] == grs_info[i]->range[varying_parm] &&
          gr_range[2+cut_type] == grs_info[i]->range[cut_type])
      {
       pr_gr0_inx[num_pairs] = grix;
       pr_gr1_inx[num_pairs++] = i;
       grix = cut_type == CUT_ALONG_U ? (grix+2) : (grix+1);
       pr_gr1_found = TRUE;
       break;
      }

     } /* for (i = grix+1; i < *num_grs; i++) */

     if (!pr_gr1_found) grix++;

    } /* if (gr_range[2+cut_type] == cuts[cix]) */
    else
     grix++;

   } /* while (grix < *num_grs) */

   for (prix = 0, num_mrg_grs = 0; prix < num_pairs && mrg_possible; 
        prix++, num_mrg_grs++)
   {
     mrg_grs_info[prix] = NULL;

     pr_gr[0] = grs_info[pr_gr0_inx[prix]];
     pr_gr[1] = grs_info[pr_gr1_inx[prix]];

     num_type_25_needed = 0;
     pr_gr_with_non_whole_bnds[0] = pr_gr_with_non_whole_bnds[1] = FALSE;

     for (i = 0; i < 2 && mrg_possible; i++)
     {
      for (bix = 0; bix < pr_gr[i]->num_bnds && mrg_possible; bix++)
      {
       if (pr_gr[i]->grbnd_info[bix]->whole_bnd)
       {
        num_pts = pr_gr[i]->grbnd_info[bix]->num_pts;
        EFmrg_possible(0, num_pts, num_type_25_needed, count, 
                       mrg_possible);
       } /* if (pr_gr[i]->grbnd_info[bix]->whole_bnd) */
       else
         pr_gr_with_non_whole_bnds[i] = TRUE;

      } /* for (bix=0;bix<pr_gr[i]->num_bnds&&mrg_possible; bix++) */

     } /* for (i = 0; i < 2 && mrg_possible; i++) */

     if (mrg_possible)
     {
       if (pr_gr_with_non_whole_bnds[0] && pr_gr_with_non_whole_bnds[1])
       {
        EFget_gr_info (*trsh_grs_info, num_trsh_grs, mrg_gr);
        mrg_grs_info[prix] = mrg_gr;
        OM_BLOCK_MOVE (pr_gr[0]->range, mrg_gr->range, 
                                         sizeof(IGRdouble)*2);
        OM_BLOCK_MOVE (&pr_gr[1]->range[2], &mrg_gr->range[2],
                                             sizeof(IGRdouble)*2);

        EFget_grbnd (*trsh_grbnds, num_trsh_grbnds, mrg_grbnd);
        mrg_gr->grbnd_info[0] = mrg_grbnd;
        mrg_gr->num_bnds = 1;
        mrg_sbnd_ptr = &mrg_grbnd->sbnd_info;

        for (i = 0; i < 2; i++)
        {
         for (bix = 0; bix < pr_gr[i]->num_bnds; bix++)
         {
          if (!pr_gr[i]->grbnd_info[bix]->whole_bnd)
          {
           sbnd_info = pr_gr[i]->grbnd_info[bix]->sbnd_info;
           while (sbnd_info)
           {
             EFget_sbnd (*trsh_sbnds, num_trsh_sbnds, mrg_sbnd);
             *mrg_sbnd = *sbnd_info;
             *mrg_sbnd_ptr = mrg_sbnd;
             mrg_sbnd->next = NULL;
             mrg_sbnd_ptr = &mrg_sbnd->next;
             sbnd_info = sbnd_info->next;
             
           } /* while (sbnd_info) */

          } /* if (!pr_gr[i]->grbnd_info[bix]->whole_bnd) */

         } /* for (bix = 0; bix < pr_gr[i]->num_bnds; bix++) */

        } /* for (i = 0; i < 2; i++) */

        EFsort_sbnds (&rc, mrg_gr, trsh_grbnds, num_trsh_grbnds, 
               trsh_grbnds_arrsz, trsh_sbnds, num_trsh_sbnds, 
               trsh_sbnds_arrsz, pr_gr[0]->range[2+cut_type], cut_type,
               partolbasis);
        EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

        for (bix = 0; bix < mrg_gr->num_bnds && mrg_possible; bix++)
        {
          num_pts = mrg_gr->grbnd_info[bix]->num_pts;
          EFmrg_possible(0, num_pts, num_type_25_needed, count, 
                         mrg_possible);
        }
       
       } /* if (pr_gr_with_non_whole_bnds[0] && pr_gr_with_non_ */
       else
       {
        if (pr_gr_with_non_whole_bnds[0] || pr_gr_with_non_whole_bnds[1])
        {
          temp_gr = pr_gr_with_non_whole_bnds[0] ? pr_gr[0] : pr_gr[1];
          for (bix = 0; bix < temp_gr->num_bnds && mrg_possible; bix++)
          {
            if (!temp_gr->grbnd_info[bix]->whole_bnd)
            {
              num_pts = temp_gr->grbnd_info[bix]->num_pts;
              EFmrg_possible(0, num_pts, num_type_25_needed, count,
                             mrg_possible);
            } /* if (!temp_gr->grbnd_info[bix]->whole_bnd) */

          } /* for (bix = 0; bix < temp_gr->num_bnds && mrg_possible; */

        } /* if (pr_gr_with_non_whole_bnds[0] || pr_gr_with_non_whole_ */

       } /* else for if (pr_gr_with_non_whole_bnds[0]&& pr_gr_with_non_ */

     } /* if (mrg_possible) */

   } /* ( for (prix = 0,num_mrg_grs= 0; prix < num_pairs && mrg_possible; 
             prix++, num_mrg_grs++) */

   /*
    * If the gr_pairs across the cutting line under consideration is
    * possible,
    * o Replace each pair of groups with its merged counterpart.
    * o Remove the pair of groups.
    */

   if (mrg_possible)
   {
    for (prix = num_pairs - 1; prix >= 0; prix--)
    {
     pr_gr[0] = grs_info[pr_gr0_inx[prix]];
     pr_gr[1] = grs_info[pr_gr1_inx[prix]];

     mrg_gr = mrg_grs_info[prix];
     
     if (mrg_gr)   merging_was_performed = TRUE;
     else
     {
       mrg_gr = pr_gr[0];
       OM_BLOCK_MOVE (&pr_gr[1]->range[2], &mrg_gr->range[2],
                                           sizeof(IGRdouble)*2);
       merging_was_performed = FALSE;
     }
          
     if (mrg_gr->grbnd_arrsz < MAX_TYPE_25_ELEMENTS)
     {
       EFmemory_allocation (&rc, (IGRchar ***) &mrg_gr->grbnd_info,
         MAX_TYPE_25_ELEMENTS, &mrg_gr->grbnd_arrsz,
          sizeof(struct EMSgrbnd_info *), MAX_TYPE_25_ELEMENTS, 5);
       EMerr_hndlr(!(1&rc),*EFmsg,EMS_E_NoDynamicMemory,wrapup);
     }

     if (merging_was_performed)
     {
      for (i = 0; i < 2; i++)
      {
       for (bix = 0; bix < pr_gr[i]->num_bnds; bix++)
       {
        grbnd_info = pr_gr[i]->grbnd_info[bix];

        if (pr_gr[i]->grbnd_info[bix]->whole_bnd)
         mrg_gr->grbnd_info[mrg_gr->num_bnds++]= grbnd_info;
        else
        {
         sbnd_info = grbnd_info->sbnd_info;
         while (sbnd_info)
         {
          EFtrash_sbnd (trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz,
                        sbnd_info);
          sbnd_info = sbnd_info->next;
         }
        
         EFtrash_grbnd (trsh_grbnds, num_trsh_grbnds, trsh_grbnds_arrsz,
                       grbnd_info);

        } /* else for if (pr_gr[i]->grbnd_info[bix]->whole) */

       } /* for (bix = 0; bix < pr_gr[i]->num_bnds; bix++) */

      } /* for (i = 0; i < 2; i++) */

      EFtrash_gr_info (trsh_grs_info, num_trsh_grs, trsh_grs_arrsz, 
                       pr_gr[0]);

      grs_info[pr_gr0_inx[prix]] = mrg_gr;
 
      EFtrash_gr_info (trsh_grs_info, num_trsh_grs, trsh_grs_arrsz, 
                       pr_gr[1]);

     } /* if (merging_was_performed) */
     else
     {
      for (bix = 0; bix < pr_gr[1]->num_bnds; bix++)
        mrg_gr->grbnd_info[mrg_gr->num_bnds++]= pr_gr[1]->grbnd_info[bix];

      EFtrash_gr_info (trsh_grs_info, num_trsh_grs, trsh_grs_arrsz, 
                       pr_gr[1]);

     } /* else for if (merging_was_performed) */

     blk_size = (*num_grs) - pr_gr1_inx[prix] - 1;
     if (blk_size)
     {
      OM_BLOCK_MOVE (&grs_info[pr_gr1_inx[prix]+1], 
                     &grs_info[pr_gr1_inx[prix]],
                     blk_size * sizeof(struct EMSgr_info *));
     }
     (*num_grs)--;
     mrg_gr->overflow = FALSE;
     mrg_gr->num_type_25_needed = 0;
     for (bix = 0; bix < mrg_gr->num_bnds; bix++)
     {
       num_pts = mrg_gr->grbnd_info[bix]->num_pts;
       EFnum_type_25_needed(num_pts, num_type_25_needed);
       mrg_gr->num_type_25_needed += num_type_25_needed;
     }

    } /* for (prix = num_pairs - 1; prix >= 0; prix--) */

    /*
     * Some of the groups may have their range boundary along the cutting
     * line but were not merged as they did not have any adjacent 
     * groups. For these groups move their cutting line range boundary
     */

    mrg_gr_min_bnd = grs_info[pr_gr0_inx[0]]->range[cut_type];
    mrg_gr_max_bnd = grs_info[pr_gr0_inx[0]]->range[cut_type+2];

    for (grix = 0; grix < *num_grs; grix++)
    {
     if (grs_info[grix]->range[cut_type] == cuts[cix])
       grs_info[grix]->range[cut_type] = mrg_gr_min_bnd;
     else if (grs_info[grix]->range[cut_type+2] == cuts[cix])
       grs_info[grix]->range[cut_type+2] = mrg_gr_max_bnd;

    } /* for (grix = 0; grix < *num_grs; grix++) */

   } /* if (mrg_possible) */
   else
   {
    for (grix = 0; grix < num_mrg_grs; grix++)
    {
        mrg_gr = mrg_grs_info[grix];
        if (mrg_gr)
        {
         for (bix = 0; bix < mrg_gr->num_bnds; bix++)
         {
          mrg_grbnd = mrg_gr->grbnd_info[bix];
          mrg_sbnd = mrg_grbnd->sbnd_info;
          while (mrg_sbnd)
          {
            next_mrg_sbnd = mrg_sbnd->next;
            EFtrash_sbnd (trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz, 
                           mrg_sbnd);
            mrg_sbnd = next_mrg_sbnd;
          } /* while (mrg_sbnd) */

          EFtrash_grbnd (trsh_grbnds, num_trsh_grbnds, trsh_grbnds_arrsz, 
                         mrg_grbnd);

         } /* for (bix = 0; bix < mrg_gr->num_bnds; bix++) */

         EFtrash_gr_info (trsh_grs_info, num_trsh_grs, trsh_grs_arrsz, 
                          mrg_gr);
        } /* if (mrg_gr) */

       } /* for (grix = 0; grix < num_mrg_grs; grix++) */

   } /* else for if (mrg_possible) */

  } /* for (cix = 0; cix < *num_cuts; cix++) */

 } /* for (cut_type = 0; cut_type < 2; cut_type++) */

wrapup:
  if (mrg_grs_info_malloced)
  {
   om$dealloc (ptr = mrg_grs_info);
   om$dealloc (ptr = pr_gr0_inx);
   om$dealloc (ptr = pr_gr1_inx);
  }
  if (cuts_malloced)
  {
   om$dealloc (ptr = u_cuts);
   om$dealloc (ptr = v_cuts);
  }

  return; 
} /* EFmerge_groups_info () */



static void EFsort_sbnds (EFmsg, gr_info, trsh_grbnds, num_trsh_grbnds,
                     trsh_grbnds_arrsz, trsh_sbnds, num_trsh_sbnds,
                     trsh_sbnds_arrsz, cutting_parm, cut_type, 
                     partolbasis)
 IGRlong              *EFmsg;
 struct EMSgr_info    *gr_info;
 struct EMSgrbnd_info ***trsh_grbnds;
 IGRint               *num_trsh_grbnds;
 IGRint               *trsh_grbnds_arrsz;
 struct EMSsbnd_info  ***trsh_sbnds;
 IGRint               *num_trsh_sbnds;
 IGRint               *trsh_sbnds_arrsz;
 IGRdouble            cutting_parm;
 IGRint               cut_type;
 struct EMSpartolbasis *partolbasis;
{
  struct EMSgrbnd_info *test_grbnd = NULL, *grbnd_info;
  struct EMSsbnd_info  *sbnd_info, **sbnd_info_ptr, *test_sbnd, 
                       **test_sbnd_ptr, *closest_sbnd, **closest_sbnd_ptr,
                       *range_sbnd, *first_sbnd, *last_sbnd, 
                       *temp_sbnd, *next_temp_sbnd;
  struct EMSbint_info  *int_info;
  struct IGRbsp_bdry_pts *bdry;
  IGRdouble            path_beg_parm, path_end_parm, test_parm, 
                       test_dis, range_len, closest_dis, *grbnd_range;
  IGRlong              rc;
  IGRint               i, blk_size, bix, test_grbnd_inx, int_inx;
  IGRboolean           sbnd_merged, beg_pt_exists, 
                       end_pt_greater_than_beg_pt;
  extern void 	       EFmemory_allocation();
  

  /* ***************************************************************** */

  *EFmsg = EMS_S_Success;

  /*
   * Get the non_whole grbnd.
   */
  
  for (test_grbnd_inx = 0; test_grbnd_inx < gr_info->num_bnds; 
       test_grbnd_inx++)
  {
    if (!gr_info->grbnd_info[test_grbnd_inx]->whole_bnd)
    {
      test_grbnd = gr_info->grbnd_info[test_grbnd_inx];
      break;
    }

  } /* for (test_grbnd_inx = 0; test_grbnd_inx < gr_info->num_bnds; */

  /*
   * If there is a non_whole grbnd, 
   * o If some sbnds can close and make a closed bnd, convert it
   *   into whole grbnd.
   * o If two or more sbnds can be merged togehter such that the
   *   begin and end points of the merged boundary lie on the range box,
   *   merge them.
   * o The final result will be that test_grbnd will only have sbnds
   *   with their end points on the range box.
   * o Final step is to group the above sbnds into closed grbnds.
   */

  if (test_grbnd)
  {
   range_len = (gr_info->range[2] - gr_info->range[0] + 
                gr_info->range[3] - gr_info->range[1]) * 2;

   sbnd_info = test_grbnd->sbnd_info;
   sbnd_info_ptr = &test_grbnd->sbnd_info;

   while (sbnd_info)
   {
    if (!EFpt_lie_on_range_box(sbnd_info->end_pt, gr_info->range,
                               partolbasis->tol))
    {
     *sbnd_info_ptr = sbnd_info->next;
     first_sbnd = last_sbnd = sbnd_info;
     first_sbnd->next = NULL;

     test_sbnd = test_grbnd->sbnd_info;
     test_sbnd_ptr = &test_grbnd->sbnd_info;
     sbnd_merged = FALSE;

     while (!sbnd_merged) 
     {
      if (test_sbnd)
      {
       if (last_sbnd->bnd_info == test_sbnd->bnd_info)
       {
        if (EM2ddistptpt (last_sbnd->end_pt, test_sbnd->beg_pt) == 0.)
        {
         *test_sbnd_ptr = test_sbnd->next;
         last_sbnd->next = test_sbnd;
         last_sbnd = last_sbnd->next;
         last_sbnd->next = NULL;

         if (EM2ddistptpt(last_sbnd->end_pt, first_sbnd->beg_pt) == 0. ||
             EFpt_lie_on_range_box(last_sbnd->end_pt, gr_info->range,
                                   partolbasis->tol) )
         {
           EFmerge_sbnds (&rc, first_sbnd, last_sbnd, test_grbnd,
              gr_info, trsh_grbnds, num_trsh_grbnds, trsh_grbnds_arrsz,
              trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz, partolbasis);
           EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

           sbnd_merged = TRUE;

         } /* if (EM2ddistptpt(last_sbnd->end_pt,first_sbnd->beg_pt) == 0.
            || EFpt_lie_on_range_box(last_sbnd->end_pt,gr_info->range)) */
         else
         {
          test_sbnd = test_grbnd->sbnd_info;
          test_sbnd_ptr = &test_grbnd->sbnd_info;
         }

        } /* if(EM2ddistptpt (last_sbnd->end_pt,test_sbnd->beg_pt)==0.) */
        else
        {
         test_sbnd_ptr = &test_sbnd->next;
         test_sbnd = test_sbnd->next;
        }

       } /* if (last_sbnd->bnd_info == test_sbnd->bnd_info) */
       else
       {
        test_sbnd_ptr = &test_sbnd->next;
        test_sbnd = test_sbnd->next;
       }

      } /* if (test_sbnd) */
      else
      {
       /*
        * This is the case where the one or both end points of the
        * last_sbnd are lying on the cutting line to be removed 
        * and the pieces of the original bdry this is part of lie
        * along the cutting line.
        */

       int_info = &last_sbnd->bnd_info->int_info;
       bdry = last_sbnd->bnd_info->bdry;

       if (first_sbnd == last_sbnd)
       {
        if (last_sbnd->beg_pt[cut_type] == cutting_parm)
        {
         temp_sbnd = test_grbnd->sbnd_info;
         beg_pt_exists = FALSE;

         while(temp_sbnd && !beg_pt_exists)
         {
          if (last_sbnd->bnd_info == temp_sbnd->bnd_info)
           if (EM2ddistptpt (last_sbnd->beg_pt, temp_sbnd->end_pt) == 0.)
             beg_pt_exists = TRUE;

          temp_sbnd = temp_sbnd->next;
         } /* while(temp_sbnd && !beg_pt_exists) */

         if (!beg_pt_exists)
         {
          for (int_inx = 0; int_inx < int_info->num_ints; int_inx++)
          {
           if ( EM2ddistptpt(last_sbnd->beg_pt, 
                             &int_info->int_pts[2*int_inx]) == 0.) 
              break;
          } /* for (i = 0; i < int_info->num_ints; i++) */

          OM_BLOCK_MOVE ((int_inx ? &int_info->int_pts[2*(int_inx-1)]
                                 : bdry->points), 
                               last_sbnd->beg_pt,
                         sizeof(IGRdouble)*2);
          last_sbnd->beg_inx = int_inx ? int_info->ptinx[int_inx-1] : 0;

         } /* if (!beg_pt_exists) */

        } /* if (last_sbnd->beg_pt[cut_type] == cutting_parm) */

       } /* if (first_sbnd == last_sbnd) */

       for (int_inx = 0; int_inx < int_info->num_ints; int_inx++)
        if (EM2ddistptpt(last_sbnd->end_pt, &int_info->int_pts[2*int_inx])
                         == 0.) break;

       OM_BLOCK_MOVE ((int_inx == (int_info->num_ints - 1)) ? 
          (IGRchar *)&bdry->points[(bdry->num_points - 1)*2] : 
          (IGRchar *)&int_info->int_pts[(int_inx+1)*2], last_sbnd->end_pt,
          sizeof(IGRdouble)*2);
       last_sbnd->end_inx = (int_inx == (int_info->num_ints - 1)) ?
                 bdry->num_points - 2 : int_info->ptinx[int_inx+1];
                 
       if (EM2ddistptpt(last_sbnd->beg_pt, last_sbnd->end_pt) > 0.)
       {
         EFget_sbnd_num_pts (last_sbnd->beg_inx, last_sbnd->end_inx, 
           last_sbnd->beg_pt, last_sbnd->end_pt, bdry, 
           end_pt_greater_than_beg_pt,last_sbnd->num_pts);
       }
       else
         last_sbnd->num_pts = bdry->num_points;

       if (EM2ddistptpt(first_sbnd->beg_pt, last_sbnd->end_pt) == 0.)
       {
          EFmerge_sbnds (&rc, first_sbnd, last_sbnd, test_grbnd,
              gr_info, trsh_grbnds, num_trsh_grbnds, trsh_grbnds_arrsz,
              trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz, partolbasis);
          EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

          sbnd_merged = TRUE;

       } /* if (EM2ddistptpt(first_sbnd->beg_pt,last_sbnd->end_pt)==0.) */
       else
       {
        test_sbnd = test_grbnd->sbnd_info;
        test_sbnd_ptr = &test_grbnd->sbnd_info;
       }

      } /* else for if (test_sbnd) */

     } /* while (!sbnd_merged) */

     sbnd_info = test_grbnd->sbnd_info;
     sbnd_info_ptr = &test_grbnd->sbnd_info;

    } /*if (!EFpt_lie_in_range_box(sbnd_info->end_pt, gr_info->range) */
    else
    {
     sbnd_info_ptr = &sbnd_info->next;
     sbnd_info = sbnd_info->next;
    }
   } /* while (sbnd_info) */
    
   /*
    * Now the test_grbnd has only sbnds (if any) with end points 
    * lying on range box. Next them is to group them such they
    * close themselves.
    */

   sbnd_info = test_grbnd->sbnd_info;

   while (sbnd_info)
   {
    EFget_grbnd (*trsh_grbnds, num_trsh_grbnds, grbnd_info);

    grbnd_info->sbnd_info = sbnd_info;
    test_grbnd->sbnd_info = test_sbnd = sbnd_info->next;
    test_sbnd_ptr = &test_grbnd->sbnd_info;
    sbnd_info->next = NULL;

    if (test_sbnd)
    {
     
     EFconvert_uvpt_to_parm (&rc, sbnd_info->end_pt, gr_info->range, 
                             &path_beg_parm, partolbasis->tol);
     EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

     EFconvert_uvpt_to_parm (&rc, sbnd_info->beg_pt, gr_info->range,
                             &path_end_parm, partolbasis->tol);
     EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

     while (test_sbnd)
     {
      closest_sbnd = NULL;
      closest_dis = MAXFLOAT;
    
      while (test_sbnd)
      {
       EFconvert_uvpt_to_parm (&rc, test_sbnd->beg_pt, gr_info->range,
                              &test_parm, partolbasis->tol);
       EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);
 
       test_dis = MAXFLOAT;

       if (path_end_parm > path_beg_parm)
       {
        if (test_parm >= path_beg_parm && test_parm <= path_end_parm)
          test_dis = test_parm - path_beg_parm;
       }
       else
       {
        if (test_parm >= path_beg_parm)
         test_dis = test_parm - path_beg_parm;
        else if (test_parm <= path_end_parm) 
          test_dis = range_len - path_beg_parm + test_parm;

       } /* else for if (path_end_parm > path_beg_parm) */

       if (test_dis < closest_dis)
       {
        closest_sbnd = test_sbnd;
        closest_dis = test_dis;
        closest_sbnd_ptr = test_sbnd_ptr;
       } 

       test_sbnd_ptr = &test_sbnd->next;
       test_sbnd = test_sbnd->next;

      } /* while (test_sbnd) */

      if (closest_sbnd)
      {
       *closest_sbnd_ptr = closest_sbnd->next;
       sbnd_info->next = closest_sbnd;
       sbnd_info = sbnd_info->next;
       sbnd_info->next = NULL;
       test_sbnd = test_grbnd->sbnd_info;
       test_sbnd_ptr = &test_grbnd->sbnd_info;

       EFconvert_uvpt_to_parm (&rc, sbnd_info->end_pt, gr_info->range,
                               &path_beg_parm, partolbasis->tol); 
       EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

      } /* if (closest_sbnd) */

     } /* while(test_sbnd) */

    } /* if (test_sbnd) */

    if ((gr_info->num_bnds + 1) > gr_info->grbnd_arrsz)
    {
      EFmemory_allocation (&rc, (IGRchar ***) &gr_info->grbnd_info,
          gr_info->num_bnds+1, &gr_info->grbnd_arrsz, 
          sizeof(struct EMSgrbnd_info *), MAX_TYPE_25_ELEMENTS, 5);
      EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);

    } /* if ((gr_info->num_bnds + 1) > gr_info->grbnd_arrsz) */

    grbnd_info->num_pts = 0;
    grbnd_info->whole_bnd = FALSE;
    grbnd_range = grbnd_info->range;
    grbnd_range[0] = grbnd_range[1] = MAXFLOAT;
    grbnd_range[2] = grbnd_range[3] = MINFLOAT;
            
    range_sbnd = grbnd_info->sbnd_info;
    while (range_sbnd)
    {
      for (i = 0; i < 4; i ++)
      {
        if (range_sbnd->range[i] < grbnd_range[i%2])
            grbnd_range[i%2] = range_sbnd->range[i];
        if (range_sbnd->range[i] > grbnd_range[i%2+2])
            grbnd_range[i%2+2] = range_sbnd->range[i];
      }

      grbnd_info->num_pts += range_sbnd->num_pts;
      range_sbnd = range_sbnd->next;

    } /* while (range_sbnd) */

    gr_info->grbnd_info[gr_info->num_bnds++] = grbnd_info;

    sbnd_info = test_grbnd->sbnd_info;

   } /* while (sbnd_info) */

   EFtrash_grbnd (trsh_grbnds, num_trsh_grbnds, trsh_grbnds_arrsz,
                 gr_info->grbnd_info[test_grbnd_inx]);


   blk_size = gr_info->num_bnds - 1 - test_grbnd_inx;
   if (blk_size)
     OM_BLOCK_MOVE (&gr_info->grbnd_info[test_grbnd_inx+1],
                    &gr_info->grbnd_info[test_grbnd_inx],
                    sizeof(struct EMSgrbnd_info *) * blk_size);
   gr_info->num_bnds--;

  } /* if (test_grbnd) */

 wrapup:
  return;

} /* static EFsort_sbnds () */


static void EFmerge_sbnds (EFmsg, first_sbnd, last_sbnd, grbnd_info,
              gr_info, trsh_grbnds, num_trsh_grbnds, trsh_grbnds_arrsz,
              trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz, partolbasis)

 IGRlong              *EFmsg;
 struct EMSsbnd_info  *first_sbnd, *last_sbnd;
 struct EMSgrbnd_info *grbnd_info;
 struct EMSgr_info    *gr_info;
 struct EMSgrbnd_info ***trsh_grbnds;
 IGRint               *num_trsh_grbnds, *trsh_grbnds_arrsz;
 struct EMSsbnd_info  ***trsh_sbnds;
 IGRint               *num_trsh_sbnds, *trsh_sbnds_arrsz;
 struct EMSpartolbasis *partolbasis;
{
  struct EMSsbnd_info *mrg_sbnd, *temp_sbnd, *next_temp_sbnd;
  IGRlong             rc;
  IGRint              i;
  IGRboolean          end_pt_greater_than_beg_pt;
  extern void         EFmemory_allocation();

  /* ************************************************************ */

  *EFmsg = EMS_S_Success;

  EFget_sbnd (*trsh_sbnds, num_trsh_sbnds, mrg_sbnd);

  mrg_sbnd->bnd_info = first_sbnd->bnd_info;
  mrg_sbnd->range[0] = mrg_sbnd->range[1] = MAXFLOAT;
  mrg_sbnd->range[2] = mrg_sbnd->range[3] = MINFLOAT;

  temp_sbnd = first_sbnd;
  while (temp_sbnd)
  {
    for (i = 0; i < 4; i ++)
    {
      if (temp_sbnd->range[i] < mrg_sbnd->range[i%2])
         mrg_sbnd->range[i%2] = temp_sbnd->range[i];
      if (temp_sbnd->range[i] > mrg_sbnd->range[i%2+2])
         mrg_sbnd->range[i%2+2] = temp_sbnd->range[i];
    }
    temp_sbnd = temp_sbnd->next;
  } /* while (temp_sbnd) */

  if (EM2ddistptpt(last_sbnd->end_pt, first_sbnd->beg_pt) == 0.)
  {
     mrg_sbnd->next = NULL;
     mrg_sbnd->num_pts = mrg_sbnd->bnd_info->bdry->num_points;

     EFget_grbnd (*trsh_grbnds, num_trsh_grbnds, grbnd_info);
     OM_BLOCK_MOVE (mrg_sbnd->range, grbnd_info->range,
                    sizeof(IGRdouble) * 4);
     grbnd_info->num_pts = mrg_sbnd->num_pts;
     grbnd_info->whole_bnd = TRUE;
     grbnd_info->sbnd_info = mrg_sbnd;

     if ((gr_info->num_bnds + 1) > gr_info->grbnd_arrsz)
     {
       EFmemory_allocation (&rc, (IGRchar ***) &gr_info->grbnd_info,
         gr_info->num_bnds+1, &gr_info->grbnd_arrsz, 
         sizeof(struct EMSgrbnd_info *), MAX_TYPE_25_ELEMENTS, 5);
       EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_NoDynamicMemory, wrapup);

     } /* if ((gr_info->num_bnds + 1) > gr_info->grbnd_arrsz) */

     gr_info->grbnd_info[gr_info->num_bnds++] = grbnd_info;
 
  } /* if (EM2ddistptpt(last_sbnd->end_pt, first_sbnd->beg_pt) == 0.) */
  else
  {
     OM_BLOCK_MOVE (first_sbnd->beg_pt, mrg_sbnd->beg_pt,
                    sizeof(IGRdouble) * 2);
     mrg_sbnd->beg_inx = first_sbnd->beg_inx;

     OM_BLOCK_MOVE (last_sbnd->end_pt, mrg_sbnd->end_pt, 
                    sizeof(IGRdouble)*2);
     mrg_sbnd->end_inx = last_sbnd->end_inx;

     EFget_sbnd_num_pts (mrg_sbnd->beg_inx, mrg_sbnd->end_inx, 
       mrg_sbnd->beg_pt, mrg_sbnd->end_pt, mrg_sbnd->bnd_info->bdry, 
       end_pt_greater_than_beg_pt, mrg_sbnd->num_pts);
            
     mrg_sbnd->next = grbnd_info->sbnd_info;
     grbnd_info->sbnd_info = mrg_sbnd;

  } /* else for if(EMdistptpt(last_sbnd->end_pt,first_sbnd->beg_pt)==0) */

   temp_sbnd = first_sbnd;
   while (temp_sbnd)
   {
     next_temp_sbnd = temp_sbnd->next;
     EFtrash_sbnd (trsh_sbnds, num_trsh_sbnds, trsh_sbnds_arrsz, 
                   temp_sbnd);
     temp_sbnd = next_temp_sbnd;
   }

  wrapup:
   return;

} /* static void EFmerge_sbnds () */

static void EFsort_cut_lines (EFmsg, num_cuts, cuts)
 IGRlong     *EFmsg;
 IGRint      num_cuts;
 IGRdouble   *cuts;
{
  IGRdouble  temp_dbl;
  IGRint     i, j, min_dbl_inx;

  *EFmsg = EMS_S_Success;

  for (i = 0; i < (num_cuts-1); i++)
  {
   min_dbl_inx = i;
   for (j = i+1; j < num_cuts; j++)
   {
    if (cuts[j] < cuts[min_dbl_inx]) min_dbl_inx = j;    
   }
   if (i != min_dbl_inx)
   {
    temp_dbl = cuts[i];
    cuts[i] = cuts[min_dbl_inx];
    cuts[min_dbl_inx] = temp_dbl; 
   }
  }

 wrapup:
  return;

} /* static void EFsort_cut_lines () */

static IGRboolean EFpt_lie_on_range_box (pt, box, par_tol)
 IGRdouble     *pt, *box, par_tol;
{
 extern IGRdouble  fabs();

 if ( (fabs(pt[0] - box[0]) <= par_tol) &&
      (pt[1] >= (box[1] - par_tol))     &&
      (pt[1] <= (box[3] + par_tol)) )  return (TRUE);
 else
 {
   if ( (fabs(pt[0] - box[2]) <= par_tol) &&
        (pt[1] >= (box[1] - par_tol))     &&
        (pt[1] <= (box[3] + par_tol)) ) return (TRUE);
   else
   {
     if ( (fabs(pt[1] - box[1]) <= par_tol) &&
          (pt[0] >= (box[0] - par_tol))     &&
          (pt[0] <= (box[2] + par_tol)))  return (TRUE);
     else
     {
       if ( (fabs(pt[1] - box[3]) <= par_tol) &&
            (pt[0] >= (box[0] - par_tol))     &&
            (pt[0] <= (box[2] + par_tol)))  return (TRUE);
       else
        return (FALSE);
     }
   }
 }

} /* static IGRboolean EFpt_lie_on_range_box () */

/*
 * Given a surface, this function checks if its geometry is overflowing
 * IGDS limits. If so, it breaks the geomtetry and windows the loopset
 * for each patch. Further, if any of the resultant patches' boundaries
 * are overflowing IGDS limit, it further subdivides the patch such
 * that none of the resultant subpacthes have overflowing boundaries.
 */

void EFbreak_sf_to_avoid_IGDS_overflow (EFmsg, sf_id, cur_os, sf_geom, 
       md_env, scale_factor, is_sf_split, num_res_sfs, res_sfs_geom)
  IGRlong               *EFmsg;
  GRobjid               sf_id;
  GRspacenum            cur_os;
  struct IGRbsp_surface **sf_geom;
  struct GRmd_env       *md_env;
  IGRdouble             *scale_factor;
  IGRboolean            *is_sf_split;
  IGRint                *num_res_sfs;
  struct IGRbsp_surface ***res_sfs_geom;
{

 struct  IGRbsp_surface *tmp_srf, **geom_spl_sfs, **topl_spl_sfs;
 struct  EMSpartolbasis partolbasis;
 struct EMSdataselect   surf_data;
 OM_S_CHANSELECT        to_loopset;
 OM_S_OBJECT_LINKAGE    sf_ls_list;
 IGRdouble              *u_parameters, *v_parameters, *matrix, new_scale;
 IGRdouble		        savecht, newcht, u_par_buf[2], v_par_buf[2];
 IGRlong                sts, number_of_u_patches, number_of_v_patches;
 IGRlong                i, j, split_indicator, this_patch_number, rc,
                        OM_stat, mthd_stat;
 IGRint                 num_topl_spl_sfs, num_geom_spl_sfs;
 IGRuint     /*num_topl_spl_sfs, num_geom_spl_sfs,*/ num_ls;
 GRobjid                wind_ls_id;
 IGRushort      ls_props;
 IGRshort		        num_rc = 4;
 IGRboolean		        status, sf_spl_for_geom, 
                        sf_spl_for_topl, sf_has_bnds, sf_bnds_overflowing;
 extern  IGRboolean     BSchangepar();
 extern  IGRlong        EMmake_chanselect();
 
 /* ****************************************************************** */

 *EFmsg = EMS_S_Success;
 number_of_u_patches = 0;
 number_of_v_patches = 0;
 u_parameters = NULL;
 v_parameters = NULL;
 geom_spl_sfs = NULL;
 topl_spl_sfs = NULL;

 sf_spl_for_geom = sf_spl_for_topl = FALSE;
 sf_bnds_overflowing = FALSE;

 BSEXTRACTPAR(&rc, BSTOLCHRDHT, savecht);

 /*
  * It may be possible that the scale factor is already incorpoarted
  * in the env_matrix (As is the case for cells). In such a case,
  * Get the scaling factor out of the env_matrix and multiply
  * it with incoming scaling factor.
  */
 
 matrix = md_env->md_env.matrix;
 new_scale = matrix[0] * matrix[0] + matrix[4] * matrix[4] +
             matrix[8] * matrix[8];
 new_scale = sqrt(new_scale);

 status = BSchangepar(&rc, BSTOLCHRDHT, savecht * new_scale);

 surf_data.datatype = EMSdata_surface;
 surf_data.data.surface = (struct IGRbsp_surface *) *sf_geom;

 /*
  * Get the basis parameteric tolerance for this surface
  */

  partolbasis.is_valid = FALSE;
  partolbasis.in_world = TRUE;
  partolbasis.mattyp = &md_env->md_env.matrix_type;
  partolbasis.mat = md_env->md_env.matrix;

  sts = EFsspbtol_by_geom(EFmsg, *sf_geom, &partolbasis.tol);
  EMerr_hndlr (!(1 & sts & *EFmsg), *EFmsg, EMS_E_Fail, wrapup);

  partolbasis.is_valid = TRUE;

  /*
   * Check if the poles of the surface exceed either in u or v 
   * direction. If so, subdivide it.
   */

  if ( ((*sf_geom)->u_num_poles > MAX_POLES) || 
       ((*sf_geom)->v_num_poles > MAX_POLES) )
  {
   extern  void BSsubdivsf();
   IGRlong      bsrc, broken_in_u, broken_in_v;

   sf_spl_for_geom = TRUE;

   BSsubdivsf(*sf_geom, MAX_POLES, MAX_POLES, &number_of_u_patches,
              &number_of_v_patches, &geom_spl_sfs, &u_parameters,
              &v_parameters, &bsrc);
   if (bsrc != BSSUCC) 
   {
     *EFmsg = EMS_E_BSerror;
     geom_spl_sfs = NULL;   /* The math does not clean up it's garbage */
     goto wrapup;          /* and I have no way of knowing what's valid */
   }

   /*
    * Determine the split direction(s)
    */

   broken_in_u = (number_of_u_patches > 1);
   broken_in_v = (number_of_v_patches > 1);

   if (broken_in_u && broken_in_v)
    split_indicator = SPLIT_BOTH;
   else if (broken_in_v)
    split_indicator = SPLIT_V;
   else if (broken_in_u)
    split_indicator = SPLIT_U;
   else                         /* Impossible */
    goto wrapup;

  }
  else
  {
   /*
    * Emulate the BS return mechanism
    */

   geom_spl_sfs = sf_geom;
   number_of_u_patches = 1;
   number_of_v_patches = 1;
   u_parameters = u_par_buf;
   v_parameters = v_par_buf;
   u_parameters[0] = v_parameters[0] = 0.;
   u_parameters[1] = v_parameters[1] = 1.;
  }

  num_geom_spl_sfs = number_of_u_patches * number_of_v_patches;

  /*
   * Window the loopset, if needed and stroke the boundaries
   */

  EMmake_chanselect (EMSsubbs_to_loopset, &to_loopset);

  sf_has_bnds = FALSE;

  OM_stat = om$get_channel_count (osnum = cur_os, objid = sf_id,
               p_chanselect = &to_loopset, count = &num_ls);
  EMerr_hndlr (!(1&OM_stat), *EFmsg, EMS_E_OMerror, wrapup);

  if (num_ls)
  {
   OM_stat = om$get_channel_objects (osnum = cur_os, objid = sf_id,
                p_chanselect = &to_loopset, list = &sf_ls_list,
                size = 1, count = &num_ls);
   EMerr_hndlr (!(1&OM_stat), *EFmsg, EMS_E_OMerror, wrapup);

   OM_stat = om$send (msg = message EMSloopset.EMget_props (&mthd_stat,
                       &ls_props),
                      senderid = NULL_OBJID, 
                      targetid = sf_ls_list.S_objid, targetos = cur_os);
   EMerr_hndlr (!(1&OM_stat&mthd_stat), *EFmsg,EMS_E_LoopsetError,wrapup);

   if (!(ls_props & EMLS_NATURAL)) sf_has_bnds = TRUE;

  } /* if (num_ls) */

  /*
   * Loop around each patch, windowing out the boundaries 
   * within that patch
   */

  if (sf_has_bnds)
  {
   for (i = 0; i < number_of_v_patches; i++)
   {
    for (j = 0; j < number_of_u_patches; j++)
    {
     this_patch_number = i * number_of_u_patches + j;

     tmp_srf = geom_spl_sfs[this_patch_number];
     tmp_srf->num_boundaries = 0;
     tmp_srf->bdrys = NULL;

      if (sf_spl_for_geom)
      {
         BSpair  low_pair, hig_pair;

         low_pair[0] = u_parameters[j];
         low_pair[1] = v_parameters[i];
         hig_pair[0] = u_parameters[j + 1];
         hig_pair[1] = v_parameters[i + 1];

         wind_ls_id = NULL_OBJID;
         OM_stat = om$send(
           msg = message EMSloopset.EMwindow(
            &mthd_stat,
            low_pair,                  /* Low pair of patch */
            NULL,                      /* Never across seams */
            hig_pair,                  /* High pair of patch */
            NULL,                      /* Never across seams */
            split_indicator,           /* 0 for U, 1 for V, 2 for both */
            &wind_ls_id,               /* New loopset */
            *sf_geom,                   /* Original surface geometry */
            FALSE,                     /* Normalize new loopset? */
            NULL,                     /* New min (u,v) for normal. loop */
            NULL,                     /* New max (u,v) for normal. loop */
            &partolbasis,               /* Parameteric tolerance stuff */
            md_env,                   /* Module matrix stuff */
            FALSE),                   /* Want UI_status() stuff */
           senderid = NULL_OBJID,
           targetid = sf_ls_list.S_objid, targetos = cur_os);
          EMerr_hndlr (!(1&OM_stat&mthd_stat),*EFmsg,EMS_E_LoopsetError,wrapup);
          
      } /* if (sf_spl_for_geom) */
      else
        wind_ls_id = sf_ls_list.S_objid;

      if (mthd_stat != EMS_I_InHoleTrim)
      {
       if (mthd_stat != EMS_I_InAreaTrim)
       {
         /* 
          * The argument to EMpack is an IGRint for num_boundaries. 
          * When Allen changes it to IGRshort, this will be unnecessary.
          */

         IGRint    num_bdrys = 0;
        
         OM_stat = om$send( msg = message EMSloopset.EMpack(
                         &mthd_stat, &tmp_srf->on_off, &num_bdrys,
                         &tmp_srf->bdrys, &surf_data, 
                         &md_env->md_env.matrix_type,
                         md_env->md_env.matrix,
                         NULL,                        /* pack options */
                         &partolbasis),
                        senderid = NULL_OBJID,
                        targetid = wind_ls_id, targetos = cur_os);
         EMerr_hndlr (!(1&OM_stat&mthd_stat),*EFmsg,EMS_E_LoopsetError,wrapup);

         tmp_srf->num_boundaries = (IGRshort) num_bdrys;

         /*
          * delete the loopset if it is extracted by windowing
          */

         if (sf_spl_for_geom)
         {
           OM_stat = om$send( msg = message Root.delete(0),
                          senderid = NULL_OBJID,
                          targetid = wind_ls_id, targetos = cur_os);
           EMerr_hndlr (!(1&OM_stat), *EFmsg, EMS_E_OMerror, wrapup);
         } /* if (sf_spl_for_geom) */

         /*
          * Check if the boundaries are overflowing.
          */

         if (!sf_bnds_overflowing)
         {
           IGRlong       k, num_points, count, 
                         number_of_bnd_elements_needed = 0;

           for (k = 0; (k < tmp_srf->num_boundaries) && 
                       (!sf_bnds_overflowing); k++)
           {
             num_points = tmp_srf->bdrys[k].num_points;
             if (num_points > MAX_POINTS_PER_BOUNDARY)
               sf_bnds_overflowing = TRUE;
             else
             {
                count = num_points / MAX_PNTS_PER_TYPE_25;
                if ((count * MAX_PNTS_PER_TYPE_25) != num_points) count++;
                number_of_bnd_elements_needed += count;
                if (number_of_bnd_elements_needed > MAX_TYPE_25_ELEMENTS)
                  sf_bnds_overflowing = TRUE;
             }

           } /* for (k = 0; (k < tmp_srf->num_boundaries) &&  */

         } /* if (!sf_bnds_overflowing) */
         
       } /* if (*msg != EMS_I_InAreaTrim) */

      } /* if (*msg != EMS_I_InHoleTrim) */
      else
      {
        if (sf_spl_for_geom)
        {
          extern  IGRboolean  BSfreesf();
          IGRboolean          bsrc, status;

          status = BSfreesf(&bsrc, tmp_srf);
          geom_spl_sfs[this_patch_number] = NULL;
        }

      } /* else for if (*msg != EMS_I_InHoleTrim) */

    } /* for (j = 0; j < number_of_u_patches; j++) */

   } /* for (i = 0; i < number_of_v_patches; i++) */

  } /* if (sf_has_bnds) */

  /*
   * If any of the subsurfaces are overflowing, need to split them
   * further so as make them acceptable.
   * IGDS can support a maximum of 16 boundaries and they are limited
   * to 4 type 25 elements, i.e. a maximum of 604 points per boundary.
   */

  if (sf_bnds_overflowing)
  {

   EFsplit_sfs_to_accomodate_boundaries (&rc, geom_spl_sfs, 
      number_of_u_patches, number_of_v_patches, u_parameters,
      v_parameters, &partolbasis, sf_ls_list.S_objid, OM_Gw_current_OS,
      res_sfs_geom, num_res_sfs);
   EMerr_hndlr (!(1&rc), *EFmsg, EMS_E_Fail, wrapup);

   sf_spl_for_topl = TRUE;
   
  } /* if (sf_bnds_overflowing) */
  else
  {
   *num_res_sfs = num_geom_spl_sfs;
   *res_sfs_geom = geom_spl_sfs;
   geom_spl_sfs = NULL;
  }

  *is_sf_split = (sf_spl_for_geom || sf_spl_for_topl);

wrapup:
 status = BSchangepar(&rc, BSTOLCHRDHT, savecht);

 if (sf_spl_for_geom )
 {
  if (geom_spl_sfs)
  {
    for (i = 0; i < num_geom_spl_sfs; i++)
    {
      if (geom_spl_sfs[i]) 
      {
       extern  IGRboolean  BSfreesf();
       IGRboolean       bsrc, status;

       if (geom_spl_sfs[i]->num_boundaries)
       {
        for (j = 0; j < geom_spl_sfs[i]->num_boundaries; j++)
          if (geom_spl_sfs[i]->bdrys[j].points)
            free (geom_spl_sfs[i]->bdrys[j].points);

        free (geom_spl_sfs[i]->bdrys);
        geom_spl_sfs[i]->num_boundaries = 0;
        geom_spl_sfs[i]->bdrys = NULL;

       } /* if (geom_spl_sfs[i]->num_boundaries) */

       status = BSfreesf(&bsrc, geom_spl_sfs[i]);

      } /* if (geom_spl_sfs[i])  */

    } /* for (i = 0; i < num_geom_spl_sfs; i++) */

    free (geom_spl_sfs);

   } /* if (geom_spl_sfs) */

   if (u_parameters) free(u_parameters);
   if (v_parameters) free(v_parameters);

 } /* if (sf_spl_for_geom) */

 return;

} /* void EFbreak_sf_to_avoid_IGDS_overflow () */

/*
 * Given a surface, the following function writes it to Envelope 
 * file as a bspline shape.
 */

void EFwrite_sf_to_envelope_and_IGDS_files (EFmsg, sf_geom,
                   IGDS_filedesc, cvt_buffers, class_name, symbology, 
                   geometric_props, properties, bss_attr, has_name, 
                   name, cmpnt_tag)

 IGRlong                *EFmsg;
 struct IGRbsp_surface  *sf_geom;
 IGRlong                *IGDS_filedesc;
 struct  GUcvt_bufs     *cvt_buffers;
 IGRchar                *class_name;
 struct  GRsymbology    *symbology;
 struct  GRprops        *geometric_props;
 IGRushort      *properties;
 struct  IGResbs        *bss_attr;
 IGRboolean             *has_name;
 IGRchar                *name;
 IGRlong                cmpnt_tag;
{

 struct GUcommon_header_info    *ele_header;
 struct EMSinfo_linkage         info_linkage;
 struct IGDS_bssurf             *surface;

 IGRdouble    ige_range[6], min_u, max_u, diff_u, min_v, max_v, diff_v,
              max_weight, *dbl_ptr, dbl_value, *old_p, *new_p, *old_w, 
              *new_w, *double_ptr1, *double_ptr2,
              knots[(MAX_POLES + MAX_ORDER)*2];

 IGRlong      num_poles, num_knots, rc, new_num_poles, poles_lost, stat;

 IGRint       i, j, k, l, m, n, int_value, int_range[6], *int_ptr, 
              zerozero_solid, *igds_size,
              int_u_order, int_v_order, u_closed, v_closed, num_uv_pts, 
              num_bdry_pts, num_weights,
              int_poles[MAX_POLES*MAX_POLES*3], 
              int_weights[MAX_POLES*MAX_POLES],
              int_u_knots[MAX_POLES + MAX_ORDER], 
              int_v_knots[MAX_POLES + MAX_ORDER], 
            int_bdry_pts[(MAX_PNTS_PER_TYPE_25+1)*2*MAX_TYPE_25_ELEMENTS],
              block_ptr, byte_ptr;

 IGRshort     hard_soft, temp, type, write_mode;
 IGRboolean   status;

 IGRchar      *dgn_buf, *igds, *info_linkage_ptr;

 extern   IGRlong    GUnormalize_knots(), GUwrite_element();

 extern   IGRboolean BSbx2(), MAbcukunexpand(), MAbcupunexpand(),
                     GRadd_name();

#ifdef ENVELOPE
 extern IGRint env_write_bspline();
#endif
 extern   IGRint     GUload_IGDSheader(), 
                     GUotype26(), GUotype25(), GUotype21(), 
                     GUotype28();
 /* ********************************************************* */

 *EFmsg = EMS_S_Success;

 /*
  * If the surface has only one boundary with 3 point, return
  * as it will be a just a line boundary surafce.
  */

 if ( (sf_geom->num_boundaries == 1) && 
      (sf_geom->bdrys[0].num_points == 3) ) goto wrapup;

 /*
  * Change the number of rule lines that should
  * be displayed in IGDS file
  */

 bss_attr->u_rules = sf_geom->v_num_poles;
 bss_attr->v_rules = sf_geom->u_num_poles;

 /*
  * Get the range and convert it to IGDS format
  */

 num_poles = sf_geom->u_num_poles * sf_geom->v_num_poles;

 status = BSbx2 (&rc, &num_poles, sf_geom->poles, (sf_geom->rational ?
                 sf_geom->weights : NULL), &ige_range[0], &ige_range[3]);
 EMerr_hndlr (!status || rc != BSSUCC, *EFmsg, EMS_E_BSerror, wrapup);

 for (i = 0; i < 6; i++)
  int_range[i] = GUnint(ige_range[i]);

 /*
  * Convert knots to IGDS format.
  *  o Normalize knots
  *  o Compress knots
  */

 min_u = sf_geom->u_knots[sf_geom->u_order - 1];
 max_u = sf_geom->u_knots[sf_geom->u_num_knots - sf_geom->u_order];
 diff_u = max_u - min_u;

 min_v = sf_geom->v_knots[sf_geom->v_order - 1];
 max_v = sf_geom->v_knots[sf_geom->v_num_knots - sf_geom->v_order];
 diff_v = max_v - min_v;

 if (sf_geom->u_num_knots)
 {
  stat = GUnormalize_knots (sf_geom->u_knots, sf_geom->u_knots, 
                            &sf_geom->u_num_knots, &sf_geom->u_order);
  EMerr_hndlr (!(1&stat), *EFmsg, EMS_E_Fail, wrapup);

  status = MAbcukunexpand (&rc, &sf_geom->u_order, &sf_geom->u_num_knots,
               sf_geom->u_knots, &sf_geom->u_num_knots, sf_geom->u_knots);
  EMerr_hndlr (!status || !(1&rc), *EFmsg, EMS_E_BSerror, wrapup);

  if (!sf_geom->u_num_knots) sf_geom->u_non_uniform = 0;
 }
 else
  sf_geom->u_non_uniform = 0;

 if (sf_geom->v_num_knots)
 {
  stat = GUnormalize_knots (sf_geom->v_knots, sf_geom->v_knots, 
                            &sf_geom->v_num_knots, &sf_geom->v_order);
  EMerr_hndlr (!(1&stat), *EFmsg, EMS_E_Fail, wrapup);

  status = MAbcukunexpand (&rc, &sf_geom->v_order, &sf_geom->v_num_knots,
               sf_geom->v_knots, &sf_geom->v_num_knots, sf_geom->v_knots);
  EMerr_hndlr (!status || !(1&rc), *EFmsg, EMS_E_BSerror, wrapup);

  if (!sf_geom->v_num_knots) sf_geom->v_non_uniform = 0;
 }
 else
  sf_geom->v_non_uniform = 0;
                    
 
 for (i = 0; i < 2; i++)
 {
  if (!i)
  {
   dbl_ptr = sf_geom->u_knots;
   int_ptr = int_u_knots;
   num_knots = sf_geom->u_num_knots;
  }
  else
  {
   dbl_ptr = sf_geom->v_knots;
   int_ptr = int_v_knots;
   num_knots = sf_geom->v_num_knots;
  }
  
  for (j = 0; j < num_knots; int_ptr++, dbl_ptr++, j++)
  {
   dbl_value = (*dbl_ptr) * GRDGNLIMITS_MAX_D;
   *int_ptr = GUnint(dbl_value);
   
  } /* for (j = 0; j < num_knots; j++) */

 } /* for (i = 0; i < 2; i++) */

 /*
  * Compress poles, if the surface is periodic and 
  * convert them to IGDS format
  */

 if ( (sf_geom->u_periodic) && (sf_geom->u_order > 2) )
 {
   old_p = sf_geom->poles;
   new_p = old_p;
   old_w = sf_geom->weights;
   new_w = old_w;

   for ( i = 0 ; i < sf_geom->v_num_poles ; i++ )
   {
    status = MAbcupunexpand( &rc, &sf_geom->u_order, &sf_geom->rational,
                    &sf_geom->u_num_poles, old_p, old_w, &new_num_poles, 
                    new_p, new_w );
    EMerr_hndlr (!status || !(1&rc), *EFmsg, EMS_E_BSerror, wrapup);

    old_p += sf_geom->u_num_poles * 3;
    new_p += new_num_poles * 3;
    old_w += sf_geom->u_num_poles;
    new_w += new_num_poles;
   }

   sf_geom->u_num_poles = new_num_poles;

 } /* if ( (sf_geom->u_periodic) && (sf_geom->u_order > 2) ) */

 if ( (sf_geom->v_periodic) && (sf_geom->v_order > 2) )
 {
  /*
   * Compressing the poles in v is easy. In the end, we're just gonna
   * have the first (v_order / 2 - 1) rows removed and enough
   * rows left off at the end to make a total of (v_order - 2)
   * rows left off.
   */

  poles_lost = sf_geom->v_order - 2;
  sf_geom->v_num_poles -= poles_lost;

  if ( poles_lost > 1 )
  {
    /*
     * If poles_lost is 1, then the row lost is on the end
     * of the array and we don't have to do any moving.
     */

    old_p = sf_geom->poles + 
            (sf_geom->v_order / 2 - 1) * sf_geom->u_num_poles * 3;
    new_p = sf_geom->poles;

    new_num_poles = sf_geom->u_num_poles * sf_geom->v_num_poles;

    for ( i = 0 ; i < new_num_poles * 3 ; i++ )
      *new_p++ = *old_p++;

    if ( sf_geom->rational )
    {
      old_w = sf_geom->weights +
              (sf_geom->v_order / 2 - 1) * sf_geom->u_num_poles;
      new_w = sf_geom->weights;

      for ( i = 0 ; i < new_num_poles ; i ++ )
        *new_w++ = *old_w++;

    } /* if ( sf_geom->rational ) */

  } /* if ( poles_lost > 1 ) */

 } /* if ( (sf_geom->v_periodic) && (sf_geom->v_order > 2) ) */

 /*
  * unweight poles for IGDS and normalize weights if needed.
  */

 new_num_poles = sf_geom->u_num_poles * sf_geom->v_num_poles;
 if ( sf_geom->rational )
 {
   new_p = sf_geom->poles;
   new_w = sf_geom->weights;

   for ( i = 0 ; i < new_num_poles ; i++, new_w++ )
	for ( j = 0 ; j < 3 ; j++ )
      *new_p++ /= *new_w;

   /*
    * make sure all weight values are less than 1.
    */

   dbl_ptr = sf_geom->weights;
   GUarray_max(dbl_ptr, &max_weight, new_num_poles);

   if ( max_weight > 1.0 )
     for ( i = 0 ; i < new_num_poles ; i++ )
       sf_geom->weights[i] = sf_geom->weights[i] / max_weight;

 } /* if ( sf_geom->rational ) */

 /*
  * Convert poles and weights to IGDS format
  */
  
 dbl_ptr = sf_geom->poles;
 int_ptr = int_poles;

 for (i = 0; i < new_num_poles*3; int_ptr++, dbl_ptr++, i++)
   *int_ptr = GUnint(*dbl_ptr);

 if (sf_geom->rational)
 {   
  dbl_ptr = sf_geom->weights;
  int_ptr = int_weights;

  for (i = 0; i < new_num_poles; int_ptr++, dbl_ptr++, i++)
  {
   dbl_value = (*dbl_ptr) * GRDGNLIMITS_MAX_D;
   *int_ptr = GUnint(dbl_value);

  } /* for (i = 0;i<new_num_poles;int_ptr++,dbl_ptr++,i++) */
   
 } /* if (sf_geom->rational) */

 /*
  * If the surface has any boundaries, convert them to IGDS format
  */

 if (sf_geom->num_boundaries )
 {
   /*
    * We have to check and make sure the knot range is
    * appropriate, ie. 0-1. If it isn't, we have to scale
    * and translate as needed.
    */

   if ( (min_u  != 0.0) || (min_v  != 0.0) || 
        (diff_u != 1.0) || (diff_v != 1.0) )
   {
    for (i = 0; i < sf_geom->num_boundaries; i++)
    {
      dbl_ptr = sf_geom->bdrys[i].points;
      num_uv_pts = sf_geom->bdrys[i].num_points;

      for (j = 0; j < num_uv_pts * 2; j += 2)
      {
       dbl_ptr[j] = ( dbl_ptr[j] - min_u) / diff_u;
       dbl_ptr[j+1] = ( dbl_ptr[j+1] - min_v) / diff_v;

       /*  eliminate trailing digits in boundary parameters due to
        *  floating point arithmetic
        */

       for (k = j; k < (j+2); k++)
       {
         if (dbl_ptr[k] < 0.) dbl_ptr[k] = 0.;
         if (dbl_ptr[k] > 1.) dbl_ptr[k] = 1.;
       }

      } /* for (j = 0; j < num_uv_pts * 2; j += 2) */

    } /* for (i = 0; i < sf_geom->num_boundaries; i++) */

   } /* if ( (min_u  != 0.0) || (min_v  != 0.0) ||  */

   num_bdry_pts = 0;
   int_ptr = int_bdry_pts;

   for (i = 0; i < sf_geom->num_boundaries; i++)
   {
     dbl_ptr = sf_geom->bdrys[i].points;
     num_uv_pts = sf_geom->bdrys[i].num_points;

     for (j = 0; j < num_uv_pts * 2 ; j++, dbl_ptr++, int_ptr++)
     {
      dbl_value = (*dbl_ptr) * GRDGNLIMITS_MAX_D;
      *int_ptr = GUnint(dbl_value);

     } /* for (j = 0; j < num_uv_pts * 2 ; j++, dbl_ptr, int_ptr++) */

     num_bdry_pts += num_uv_pts;
     *int_ptr++ = -1;                /* To indicate that bdry is broken */

   } /* for (i = 0; i < sf_geom->num_boundaries; i++) */

 } /* if (sf_geom->num_boundaries ) */
 else
  num_bdry_pts = 0;

 /* 
  * Write surface as a bspline shape
  */

 num_weights = sf_geom->rational ? new_num_poles : 0;
 hard_soft = TRUE;

 /*
  * PDS u_order/v_order is same as EMS and not like IGDS where
  * IGDS order is EMS_order - 2.
  */

 int_u_order = (IGRint) sf_geom->u_order;
 int_v_order = (IGRint) sf_geom->v_order;
 u_closed = (IGRint) sf_geom->u_periodic; /*sf_geom->u_phy_closed;*/
 v_closed = (IGRint) sf_geom->v_periodic; /* sf_geom->v_phy_closed; */
 zerozero_solid = (IGRint) sf_geom->on_off;

#ifdef ENVELOPE
 stat = env_write_bspline (&hard_soft, int_range, &int_u_order, 
                    &int_v_order,
                    &sf_geom->u_num_poles, &sf_geom->v_num_poles, 
                    &sf_geom->u_num_knots, &sf_geom->v_num_knots, 
                    &num_weights, &num_bdry_pts, &u_closed,
                    &v_closed, &zerozero_solid, int_poles, int_u_knots,
                    int_v_knots, int_weights, int_bdry_pts);
 /*
  * PDS error reporting mechanism:
  * < 0    - error
  * > 0    - success
  */

 EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

 /*
  * write surface to IGDS file
  */

 EMerr_hndlr( sf_geom->u_num_poles > 101 || sf_geom->v_num_poles > 101,
              *EFmsg, MSFAIL, wrapup);

 write_mode = GUWRITE;

 dgn_buf = cvt_buffers->dgn_buf;
 igds = cvt_buffers->ele_buf;
 igds_size = &cvt_buffers->ele_size;

 surface = (struct IGDS_bssurf *)igds;

 /*
  * call function to load header data for surface header.
  */

 type = GU_BS_SURF_HEADER;

 stat = GUload_IGDSheader(EFmsg, class_name, &type, symbology, properties,
                         ige_range, surface );
 EMerr_hndlr (*EFmsg != GUsuccess, *EFmsg, MSFAIL, wrapup);

 /*
  *  Set the on/off bit (the H bit)
  */

 if ( sf_geom->num_boundaries )
 {
  if (sf_geom->on_off )
   surface->header.properties &= 0x7fff;
  else
   surface->header.properties |= 0x8000;
 }
 else
  surface->header.properties &= 0x7fff;

 /*
  * load necessary header data such as words in description.
  */

 surface->header.words_to_follow = 27;
 surface->header.index_to_ae	= 13;
 surface->surf.surf_type		= bss_attr->type;
 surface->surf.order_u		= sf_geom->u_order - 2;
 surface->surf.order_v		= sf_geom->v_order - 2;
 surface->surf.num_poles_u	= sf_geom->u_num_poles;
 surface->surf.num_poles_v	= sf_geom->v_num_poles;
 surface->surf.num_knots_u	= sf_geom->u_num_knots;
 surface->surf.num_knots_v	= sf_geom->v_num_knots;

 if ( bss_attr->is_surfdis )
  surface->surf.order_u      |= 0x10;

 if ( bss_attr->is_polydis )
  surface->surf.order_u      |= 0x20;

 if ( sf_geom->rational )
  surface->surf.order_u      |= 0x40;

 if ( sf_geom->u_periodic )
  surface->surf.order_u      |= 0x80;

 if ( bss_attr->is_slowdis )
  surface->surf.order_v      |= 0x40;

 if ( sf_geom->v_periodic )
  surface->surf.order_v      |= 0x80;

 surface->surf.rules_u		= bss_attr->u_rules;
 surface->surf.rules_v		= bss_attr->v_rules;

 surface->surf.num_boundaries	= sf_geom->num_boundaries;

 surface->surf.wds_in_descript = 9;

 if ( ! strncmp(class_name, "GR2", 3) )
  surface->surf.wds_in_descript +=
               sf_geom->v_num_poles * (19 + 4 * sf_geom->u_num_poles);
 else
  surface->surf.wds_in_descript +=
               sf_geom->v_num_poles * (19 + 6 * sf_geom->u_num_poles);

 if ( sf_geom->rational )
  surface->surf.wds_in_descript +=
               sf_geom->v_num_poles * (18 + 2 * sf_geom->u_num_poles);

 if ( sf_geom->u_non_uniform || sf_geom->v_non_uniform )
  surface->surf.wds_in_descript +=
             18 + 2 * (sf_geom->u_num_knots + sf_geom->v_num_knots);

 m = n = 0;

 for ( i = 0 ; i < sf_geom->num_boundaries && m < 16 ; i++ )
 {
  temp = sf_geom->bdrys[i].num_points;

  /*
   *  Check to make sure entire boundary will fit into 
   *  at the most four(4) IGDS type 25's
   */

  if ( temp <= 600 && ((m+(temp/150)) < 16) )
  {
   n++;
   j = 1;

   while ( j < temp && m < 16)
   {
    if ( temp >= j + 150 )
     surface->surf.wds_in_descript += 624;
    else
     surface->surf.wds_in_descript += 20 + (temp - j + 1) * 4;

    j += 150;
    m++;

   } /* while ( j < temp && m < 16) */

  } /* if ( temp <= 600 && ((m+(temp/150)) < 16) ) */

 } /* for ( i = 0 ; i < sf_geom->num_boundaries && m < 16 ; i++ ) */

 surface->surf.num_boundaries = n;
 surface->surf.wds_in_descript += 4;     /* for Information linkage */
 GUswapint( &surface->surf.wds_in_descript, 
            &surface->surf.wds_in_descript );

 /*  
  * If an element name is present, it will be added to the translated
  *  element's user data linkage in the igds design file.
  */

 GRadd_name_to_buf( &rc, has_name, name, igds );

 /*
  * If the information linkage is passed in, add to igds element.
  */

 ele_header = (struct GUcommon_header_info *) igds;
 info_linkage_ptr = (char *) (&ele_header->words_to_follow
                    + ele_header->words_to_follow + 1);
 ele_header->properties |= IGDSAttributeData;

 info_linkage.type = 0;
 info_linkage.props = 0x80;           /* Information linkage prop I */
 info_linkage.entity = ENTITY;        /* Envelope entity */
 info_linkage.occurrence = cmpnt_tag;

 OM_BLOCK_MOVE (&info_linkage, info_linkage_ptr, 
                sizeof(struct EMSinfo_linkage));

 ele_header->words_to_follow += 4;
     
 *igds_size = (ele_header->words_to_follow + 2) * 2;

 stat = GUwrite_element(&rc, dgn_buf, surface, &type, igds_size,
                        IGDS_filedesc, &write_mode, &block_ptr, &byte_ptr );
 EMerr_hndlr (rc != GUsuccess, *EFmsg, MSFAIL, wrapup);

 /*
  * if the surface is non-uniform, we have to write out a type 26 knot
  * element.
  */

 if ( sf_geom->u_non_uniform || sf_geom->v_non_uniform )
 {
  /*
   * We have to copy the knot vectors into one contiguous array.
   */

  double_ptr1 = knots;
  double_ptr2 = sf_geom->u_knots;

  for ( i = 0 ; i < sf_geom->u_num_knots ; i++ )
     *double_ptr1++ = *double_ptr2++;

  double_ptr2 = sf_geom->v_knots;

  for ( i = 0 ; i < sf_geom->v_num_knots ; i++ )
     *double_ptr1++ = *double_ptr2++;

  i = sf_geom->u_num_knots + sf_geom->v_num_knots;

  stat = GUotype26(&rc, IGDS_filedesc, dgn_buf, igds, igds_size,
                   class_name, sf_geom, ige_range, symbology,
                   geometric_props, properties, knots, &i );
  EMerr_hndlr (rc != GUsuccess, *EFmsg, MSFAIL, wrapup);

 } /* if ( sf_geom->u_non_uniform || sf_geom->v_non_uniform ) */

 /*
  * If the surface contains boundaries, we have to write out the
  * boundary elements now. The boundary points have already been 
  * normalized and trailing digits have also been removed.
  */

 if ( sf_geom->num_boundaries )
 {
  m = 0;
  for ( i = 0 ; i < sf_geom->num_boundaries && m < 16 ; i++ )
  {
   temp = sf_geom->bdrys[i].num_points;

   /*
    *  Check to make sure entire boundary can fit
    */

   if ( (temp <= 600 ) && ((m+(temp/150)) < 16) )
   {
    j = 1;

    while ( j < temp && m < 16 )
    {
      if ( temp >= j + 150 )
        k = 151;
      else
        k = temp - j + 1;

      /*
       * l is the boundary number we're working on.
       * j is the index into the array of boundary points.
       * k is the number of boundary points for this element.
       */

      l = i + 1;

      stat = GUotype25( &rc, IGDS_filedesc, dgn_buf, igds, igds_size, 
                       class_name, sf_geom, ige_range, symbology, 
                       geometric_props, properties, 
                       &sf_geom->bdrys[i].points[(j-1)*2 ], &k, &l);
      EMerr_hndlr (rc != GUsuccess, *EFmsg, MSFAIL, wrapup);

      j += 150;
      m++;

    } /* while ( j < temp && m < 16 ) */

   } /* if ( (temp <= 600 ) && ((m+(temp/150)) < 16) ) */
   
   else
   {
		    /* boundary will be skipped */
   }

  } /* for ( i = 0 ; i < sf_geom->num_boundaries && m < 16 ; i++ ) */

 } /* if ( sf_geom->num_boundaries ) */

 /*
  * write out pole elements.
  */

 new_p = sf_geom->poles;
 new_w = sf_geom->weights;

 for ( i = 0 ; i < sf_geom->v_num_poles ; i++ )
 {
   stat = GUotype21(&rc, IGDS_filedesc, dgn_buf, igds, igds_size,
                    class_name, sf_geom, ige_range, symbology,
                    geometric_props, properties, new_p, 
                    &sf_geom->u_num_poles );
   EMerr_hndlr (rc != GUsuccess, *EFmsg, MSFAIL, wrapup);

   /*
    * if the surface is rational, we have to write out a type 28
    * weight factor element.
    */

   if ( sf_geom->rational )
   {
     stat = GUotype28(&rc, IGDS_filedesc, dgn_buf, igds, igds_size,
                      class_name, sf_geom, ige_range, symbology,
                      geometric_props, properties, new_w,
                      &sf_geom->u_num_poles );
     EMerr_hndlr (rc != GUsuccess, *EFmsg, MSFAIL, wrapup);
   }

   new_p += sf_geom->u_num_poles * 3;
    new_w += sf_geom->u_num_poles;

 } /* for ( i = 0 ; i < sf_geom->v_num_poles ; i++ ) */



wrapup:
 EMWRAPUP (*EFmsg, *EFmsg, "EFwrite_sf_to_envelope_file");
 return;

} /* void EFwrite_sf_to_envelope_file () */


/*
 * The following function writes a single surface or surface owner
 * (solid/comp_surface/dpr_state) to the Envelope file. Also, it
 * updates the incoming file_range with its range.
 */

void EFwrite_component_to_envelope_file (EFmsg, cmpnt_id, cur_os, md_env,
                          cmpnt_tag, scale_factor, file_range)
  IGRlong          *EFmsg;
  GRobjid          cmpnt_id;
  GRspacenum       cur_os;
  struct GRmd_env  *md_env;
  IGRuint          *cmpnt_tag;
  IGRdouble        *scale_factor;
  IGRdouble        *file_range;
      
{
 IGRmatrix         scale_mat;
 struct GRmd_env   new_env;
 IGRdouble         cmpnt_ige_range[6];
 IGRlong           OM_stat, mthd_stat, rc;
 IGRint            i, cmpnt_env_range[6], int_value, stat;
 IGRboolean        status, world = TRUE;
 IGRshort          model_item = MODEL_ITEM, entity = ENTITY, 
                   number_cp = 0, four = 4;
 IGRchar           cmpnt_env_name[21], cmpnt_description[41],
                   approval_status = 0;
 GRname            cmpnt_name;
#ifdef ENVELOPE
 extern IGRint     env_write_component();
#endif
 extern IGRboolean MAmulmx(), MAtypemx();

 /* **************************************************************** */

  *EFmsg = EMS_S_Success;
  OM_stat = OM_S_SUCCESS;

  /*
   * Convert component's tag. If the component does not have a
   * tag, add a tag. I am not sure of how to determine whether
   * a tag can be added to a componen or not. It may not be possible
   * a tag for read_only file.
   */

  OM_stat = om$objid_to_tag (objid = cmpnt_id, osnum = cur_os, 
                             p_tag = cmpnt_tag);
  if (OM_stat == OM_W_NOTTAGGED)
  {
   OM_stat = om$add_tag (osnum = cur_os, objid = cmpnt_id,
                         p_tag = cmpnt_tag);

  } /* if (OM_stat == OM_W_NOTTAGGED) */

  EMerr_hndlr (!(1&OM_stat), *EFmsg, EMS_E_OMerror, wrapup);
  
  /* 
   * Generate new matrix with the scale factor
   */

  for(i = 0; i < 16; i++) scale_mat[i] = 0.0;
  scale_mat[0] = scale_mat[5] = scale_mat[10] = *scale_factor;
  scale_mat[15] = 1.0;

  new_env = *md_env;

  status = MAmulmx(&rc, &four, &four, &four, scale_mat, 
	  	   md_env->md_env.matrix, new_env.md_env.matrix);
  EMerr_hndlr (!status || !(1&rc), *EFmsg, EMS_E_BSerror, wrapup);

  status = MAtypemx(&rc, new_env.md_env.matrix, 
                    &new_env.md_env.matrix_type);
  EMerr_hndlr (!status || !(1&rc), *EFmsg, EMS_E_BSerror, wrapup);

  OM_stat = om$send (msg = message GRgraphics.GRgetrang (&mthd_stat, 
                      &new_env.md_env.matrix_type, new_env.md_env.matrix,
                      &world, cmpnt_ige_range),
                     senderid = NULL_OBJID,
                     targetid = cmpnt_id, targetos = cur_os);
  EMerr_hndlr (!(1&OM_stat&mthd_stat),*EFmsg, EMS_E_SurfaceError, wrapup);

  for (i = 0; i < 3; i++)
  {
   if (cmpnt_ige_range[i] < file_range[i]) 
     file_range[i] = cmpnt_ige_range[i];
   if (cmpnt_ige_range[i+3] > file_range[i+3]) 
      file_range[i+3] = cmpnt_ige_range[i+3];
  }  
  
  /*
   * convert component range to igds format
   */
  
  for (i = 0; i < 6; i++)
    cmpnt_env_range[i] = GUnint( cmpnt_ige_range[i]);

  /*
   * Get cmponent name and its description if any
   */

  cmpnt_description[0]=0;
  OM_stat = om$send (msg = message GRvg.GRgetname (&mthd_stat, 
                      cmpnt_name),
                     senderid = NULL_OBJID, targetid = cmpnt_id,
                     targetos = cur_os);
  if (!(1&mthd_stat))
  {
   cmpnt_env_name[0] = '\0';
   mthd_stat = EMS_S_Success;
  }
  else
  {
   (void) strncpy (cmpnt_env_name, cmpnt_name, 20);
/*   cmpnt_env_name[21] = '\0'; ###COMMENTED OUT and ADDED NEXT LINE - ASHOK */
   cmpnt_env_name[20] = '\0';
  }

  OM_stat = om$send (msg = message EMSsurface.EMgetDescription (
                      (EMSrc *)&mthd_stat, cmpnt_description, 40),
                     senderid = NULL_OBJID, targetid = cmpnt_id,
                     targetos = cur_os);
/*  EMerr_hndlr (!(1&OM_stat&mthd_stat),*EFmsg, EMS_E_SurfaceError, wrapup);*/
/* Commented out because structure doesn't carry this message */
  /*
   * write my self to the Envelope file
   */

#ifdef ENVELOPE
  stat = env_write_component (&approval_status, &model_item, &entity, 
                       cmpnt_tag, &number_cp, 
                       cmpnt_env_name, cmpnt_description, 
                       cmpnt_env_range, NULL);
  EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

wrapup:
 EMWRAPUP (*EFmsg, OM_stat, "EFwrite_component_to_envelope_file");
 return;

} /* void EFwrite_component_to_envelope_file () */
 
/*
 * Given the seed_file and module info, the following function
 * writes the surfaces in the module to an Envelope file and 
 * to a IGDS file. Note that the portions corresponding to 
 * IGDS file have been copied from function GUcreate_IGDSfile().
 */

/* Modified by Fred Arce for I/Struct Interference Envelope Generation */

static IGRdouble    uom_factor;

static IGRlong       Stat, msg, OM_stat, mthd_stat, rc, 
                    read_msg, num_bytes_read;

static IGRint       i, str_len, tag, file_env_range[6], int_value, inx,
                    uor_per_su, su_per_mu, global_origin[3],
                    begin_index, end_index,
                    cmpnt_tag, block_ptr, byte_ptr;

static IGRshort     mat_type, sys_of_unit, *ele_ptr, *musupu_ptr, 
                    sys_of_units, write_mode,
                    write_init;

static OMuword      rclass;

static IGRboolean   read_status, ext_type_nine, 
                    view_overflow;

static IGRchar      dgn_file[64], db_file[64], munit[3], sunit[3], 
		    igds_unix_file[64], env_unix_file[64];

void VSEFinit_envelope_and_igds_files (EFmsg, seed_file, env_file, 
              igds_file, view_setup, md_env, max_abs_overflow, scale_factor, 
	      cvt_buffers, IGDS_filedesc, file_ige_range)
 IGRlong           *EFmsg;
 IGRchar           *seed_file, *env_file, *igds_file;
 struct GRid       *view_setup;
 struct GRmd_env   *md_env;
 IGRdouble	   *max_abs_overflow, *scale_factor;
 struct GUcvt_bufs  **cvt_buffers;

 IGRlong	   *IGDS_filedesc;
 IGRdouble	   file_ige_range[6];
{

#ifdef ENVELOPE
 extern IGRint      env_open(), env_write_tolerances(), 
                    env_write_design(), env_close();
#endif

 extern IGRint      GUcpxinit(), GUotype9(), GUonamedvws(), GUotype5lv1();
 extern IGRlong     GUwrite_element();
 extern IGRboolean  GUget_next_ele();

 /* ***************************************************************** */
 *EFmsg = EMS_S_Success;

(*cvt_buffers)= ( struct GUcvt_bufs *) om$malloc(size = sizeof ( struct GUcvt_bufs ) );
ext_type_nine = FALSE;
view_overflow = FALSE;
begin_index = 0;
end_index = GRDGNLIMITS_MAX_I;
write_mode = GUWRITE;
write_init = GUWRITE_INIT;

 /* ***************************************************************** */

 mthd_stat = EMS_S_Success;
 OM_stat = OM_S_SUCCESS;
 Stat = EMS_S_Success;

 GUcpxinit ();

/************** SM 06-Oct-89 *****************/
 EMget_unix_filename(igds_file, igds_unix_file);
 EMget_unix_filename(env_file, env_unix_file);

 /* After this point use unix file names except when recording the igds file
    name in the envelope file.
 */


 /*
  * o Open the seed file (one provided by user, otherwise default 
  *   seedfile). 
  *  o Get uor_per_su, su_per_mu, sys_of_units, munit and
  *    sunit (these are needed for Envelope file). 
  *  o Write type 9 element to the IGDS file.
  */

 (*cvt_buffers)->file_des = -1;
 {
  char temp_seed_file[80];

  for ( i = 0; (1 & Stat); i++ )
  {
    if (Stat = ex$get_path(index = i, path = temp_seed_file, len = 80))
    {
      strcat ( temp_seed_file, "config/" );
      strcat ( temp_seed_file, seed_file );

      (*cvt_buffers)->file_des = open ( temp_seed_file, GUREAD_ONLY );
	
      if ( (*cvt_buffers)->file_des != -1 )
        break;

    } /* if (Stat = ex$get_path(index=i,path=temp_seed_file,len = 80)) */

  } /* for ( i = 0; (1 & Stat); i++ ) */

  if ( (*cvt_buffers)->file_des == -1  || !(1&Stat))
  {
    *EFmsg = GUNOSEEDFILE;

	printf("\nSeed file not found in product/config path");
    goto wrapup;
  }

 }


 /*
  *  Create the IGDS design file. The 'creat' function CANNOT be used 
  *  because it does not allow read privileges to the new file.
  */
   
 *IGDS_filedesc = open (igds_unix_file, O_CREAT | O_RDWR, GUACCESS_MODE );
	  
 if ( *IGDS_filedesc == -1 )
 {
  *EFmsg = GUNOFILE;

#ifdef DEBUG
  	printf("\nVSEFinit......  No igds file");
#endif

  goto wrapup;
 }

 /*
  * Reset the i/o pointers for multiple translations.
  */

 Stat = GUwrite_element (&rc, (*cvt_buffers)->dgn_buf, 
                           (*cvt_buffers)->ele_buf, &(*cvt_buffers)->ele_type,
                           &((*cvt_buffers)->ele_size), IGDS_filedesc,
                           &write_init, &block_ptr, &byte_ptr );

 (*cvt_buffers)->ele_type = -1;
 read_status = TRUE;
		
 while ( read_status == TRUE )
 {
   read_status = GUget_next_ele ( &read_msg, (*cvt_buffers) );
		
   if ( read_msg != GULAST_ELEMENT )
   {
    /*
     *  Check for type 9. If so, get active uor_per_su, su_per_mu,
     *  sunit, munit.
     */

    if ( (((*((IGRshort *) (*cvt_buffers)->ele_buf)) & 0x7f00) >> 8) == 9 )
    {
     if ( !ext_type_nine )
     {

       /* 
        * Get Envelope file parameters info
        */

       ele_ptr = (IGRshort *) (*cvt_buffers)->ele_buf;

       musupu_ptr = ele_ptr + 556;       /* pointer to su_per_mu */
       OM_BLOCK_MOVE (musupu_ptr, &su_per_mu, sizeof(IGRint));

       musupu_ptr += 2;                  /* pointer to uor_per_su */
       OM_BLOCK_MOVE (musupu_ptr, &uor_per_su, sizeof(IGRint));

       musupu_ptr += 2;                  /* pointer to munit */
       OM_BLOCK_MOVE (musupu_ptr, munit, 2 *sizeof(IGRchar));

       musupu_ptr += 1;                  /* pointer to sunit */
       OM_BLOCK_MOVE (musupu_ptr, sunit, 2 * sizeof(IGRchar));

       munit[2] = sunit[2] = '\0';

       GUswapint (&uor_per_su, &uor_per_su);
       GUswapint (&su_per_mu, &su_per_mu);

       /*
        * Get the scale factor for going from IGE to IGDS
        */
/*
       *scale_factor = uor_per_su * su_per_mu;

       Stat = co$cvt_exp_to_wrk (msg = &rc, 
                   osnum = md_env->md_id.osnum, 
                   unit_type = "UOM_DISTANCE", units = 1.0, 
                   alias = munit, result = &uom_factor);
       if (rc == MSSUCC)
         *scale_factor /= uom_factor;
        
*/
       /*
        * setup the view information and active parameters for IGDS file
        */
       
       GUotype9 (&rc, (*cvt_buffers)->ele_buf, view_setup, scale_factor);

       if (rc == GUVIEW_OVERFLOW)
       {
         view_overflow = TRUE;
       }

       ext_type_nine = TRUE;

     } /* if ( !ext_type_nine ) */

    } /* if ( (((*((IGRshort * (*cvt_buffers)->ele_buf))&0x7f00)>>8)==9) */

    Stat = GUwrite_element (&rc, (*cvt_buffers)->dgn_buf, 
                              (*cvt_buffers)->ele_buf, &((*cvt_buffers)->ele_type), 
                              &((*cvt_buffers)->ele_size), IGDS_filedesc,
                              &write_mode, &block_ptr, &byte_ptr );

   } /* if ( read_msg != GULAST_ELEMENT ) */

 } /* while ( read_stat == TRUE ) */

 if ( read_msg != GULAST_ELEMENT )
 {
   /*
    *  read error has occurred
    *  abort this function
    */
   *EFmsg = GUREAD_ERROR;
#ifdef DEBUG
   	printf("\nVSEFinit......  NGUread error from seed file"); 
#endif
   goto wrapup;
  }
 
  /*
   *  Set up named views for each view in the IGE object space.
   */

  Stat = GUonamedvws (&rc, IGDS_filedesc, (*cvt_buffers)->dgn_buf,
                        (*cvt_buffers)->ele_buf, md_env, scale_factor);
  if ( !(1 & Stat) && (rc == GUVIEW_OVERFLOW) )
  {
    view_overflow = TRUE;
  }

  sys_of_units = ((strncmp (munit, "FT", 2) == 0) ||
                  (strncmp (munit, "ft", 2) == 0) ||
                  (strncmp (munit, "IN", 2) == 0) ||
                  (strncmp (munit, "in", 2) == 0) ||
                  (strncmp (munit, "\'", 1) == 0) ||
                  (strncmp (munit, "\"", 1) == 0) ||
                  (strncmp (munit, "ML", 2) == 0) ||
                  (strncmp (munit, "ml", 2) == 0)) ? ENGLISH : METRIC;
/* debug */
#ifdef DEBUG
  printf ( "\ndesign file chosen is ");
  if (sys_of_units == ENGLISH) printf ("English \n");
  else printf ("Metric \n");
#endif

 /*
  * o Open the envolope file.
  * o Write tolerances to it.
  * o For each component,
  *   o Get its range. Add this range to the envelope file range.
  *   o Write the surfaces of this component to the envelope file.
  * o Write design information to the file.
  * o Close the envelope file.
  */

#ifdef ENVELOPE
  Stat = env_open (env_unix_file);
  EMerr_hndlr (Stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

{
   IGRdouble cyl_len_cone = 0., cyl_len_elipse = 0.,
             slicing_distance, construction_tolerance = 0.;
   IGRshort  no_cyl_90_degree = 0;

   slicing_distance = sys_of_units == METRIC ? 25. : 1.;
  
#ifdef ENVELOPE
   Stat = env_write_tolerances (&cyl_len_cone, &cyl_len_elipse, 
                         &no_cyl_90_degree,
                         &slicing_distance, &construction_tolerance);
   EMerr_hndlr (Stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif
                        
}

  for (inx = 0; inx < 3; inx++)
  {
   file_ige_range[inx] = MAXDOUBLE;
   file_ige_range[inx+3] = -MAXDOUBLE;
  } 

  /*
   * o Convert file range to IGDS format.
   * o write design info to the Envelope file. Envelope functions
   *   requires to write design before writing any components.
   *   Since file range is not available at this point, use maxlimits.
   *    Once, all of the components are written and true design limits
   *   are known, write design info again with correct design range.
   */

  for (i = 0; i < 6; i++)
   file_env_range[i] = GUnint (file_ige_range[i]);

  db_file[0] = NULL;
  for (i = 0; i < 3; i++)
   global_origin[i] = 0;

#ifdef ENVELOPE
  Stat = env_write_design (&uor_per_su, &su_per_mu, global_origin, 
                   file_env_range, &sys_of_units, 
                   munit, sunit, igds_file, db_file);
  EMerr_hndlr (Stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

wrapup:
 EMWRAPUP (*EFmsg, OM_stat, "VSEFinit_envelope_and_igds_files");
 return;

} /* VSEFinit_envelope_and_igds_files */

void VSEFwrite_envelope_and_igds_files (EFmsg, igds_file, max_abs_overflow, cvt_buffers, IGDS_filedesc, file_ige_range)
 IGRlong           *EFmsg;
 IGRchar           *igds_file;
 IGRdouble	   *max_abs_overflow;
 struct GUcvt_bufs  **cvt_buffers;
 IGRlong	   *IGDS_filedesc;
 IGRdouble	   file_ige_range[6];
{


#ifdef ENVELOPE
 extern IGRint      env_open(), env_write_tolerances(), 
                    env_write_design(), env_close();
#endif

 extern IGRint      GUcpxinit(), GUotype9(), GUonamedvws(), GUotype5lv1();
 extern IGRlong     GUwrite_element();
 extern IGRboolean  GUget_next_ele();

 *EFmsg = EMS_S_Success;

  /*
   * Perform a Rtree pass 
   */
 /*
  * o Convert file range to IGDS format.
  * o write design info to the Envelope file.
  */

 for (i = 0; i < 6; i++)
  file_env_range[i] = GUnint (file_ige_range[i]);


#ifdef ENVELOPE
 Stat = env_write_design (&uor_per_su, &su_per_mu, global_origin, 
                   file_env_range, &sys_of_units, 
                   munit, sunit, igds_file, db_file);
 EMerr_hndlr (Stat < 0, *EFmsg, EMS_E_Fail, wrapup);

 Stat = env_close();
 EMerr_hndlr (Stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

 /*
  * Insert color table type 5's into IGDS design
  * file and create IGDS color table file.
  */

 GUotype5lv1 (&rc, igds_unix_file, IGDS_filedesc, (*cvt_buffers)->dgn_buf, 
              (*cvt_buffers)->ele_buf, &(*cvt_buffers)->ele_size );
		
 /*
  *  write the end-of-file into the IGDS design file
  */

 num_bytes_read = 2;
 (*cvt_buffers)->ele_buf[0] = (*cvt_buffers)->ele_buf[1] = 0xFF;
 (*cvt_buffers)->ele_type = -1;

 Stat = GUwrite_element (&rc, (*cvt_buffers)->dgn_buf, (*cvt_buffers)->ele_buf, 
                           (*cvt_buffers)->ele_type, &num_bytes_read, 
                           IGDS_filedesc, &write_mode, &block_ptr,
                           &byte_ptr );



 /*
  * Flush the buffer containing the end-of-file before closing
  * the IGDS file
  */

 write_mode = GUFLUSH;
 Stat = GUwrite_element (&rc, (*cvt_buffers)->dgn_buf, (*cvt_buffers)->ele_buf, 
                           (*cvt_buffers)->ele_type, &num_bytes_read, 
                           IGDS_filedesc, &write_mode, &block_ptr,
                           &byte_ptr );

 /*
  * Increase the size of the IGDS design file.
  */

 write_mode = GUINCREASE;
 (*cvt_buffers)->ele_size = 10;
 Stat = GUwrite_element (&rc, (*cvt_buffers)->dgn_buf, (*cvt_buffers)->ele_buf, 
                           (*cvt_buffers)->ele_type, &((*cvt_buffers)->ele_size), 
                           IGDS_filedesc, &write_mode, &block_ptr,
					       &byte_ptr);

 /*
  * If views caused overflow, set the return code.
  */

 if (view_overflow ) *EFmsg = GUVIEW_OVERFLOW;

 /*
  * Check to see if elements were skipped due to
  *	overflow error. Element overflow takes 
  *	precedence over view overflow.
  */

 if ( *max_abs_overflow != 0 ) *EFmsg = GUELEMENT_OVERFLOW;

 /*
  *  close the seed file and the new IGDS file
  */

 close ( (*cvt_buffers)->file_des );
 om$dealloc (ptr = (*cvt_buffers));

 close ( *IGDS_filedesc );

wrapup:
 EMWRAPUP (*EFmsg, OM_stat, "VSEFwrite_envelope_and_igds_files");
 return;


} /* VSEFwrite_envelope_and_igds_files () */



/*
 * Given the seed_file and module info, the following function
 * writes the surfaces in the module to an Envelope file and 
 * to a IGDS file. Note that the portions corresponding to 
 * IGDS file have been copied from function GUcreate_IGDSfile().
 */

void EFwrite_envelope_and_igds_files (EFmsg, seed_file, env_file, 
              igds_file, view_setup, md_env)
 IGRlong           *EFmsg;
 IGRchar           *seed_file, *env_file, *igds_file;
 struct GRid       *view_setup;
 struct GRmd_env   *md_env;
{

 struct GUcvt_bufs  cvt_buffers;
 struct EMSsurface_EMcreate_envelope_and_igds_files_Msg  env_file_arglist;
 struct OMindex_pass_Msg rtree_pass_arglist;
 OM_S_CLASSLIST     rtree_classes;
 OM_S_MESSAGE       env_msg, rtree_pass_msg;
 OM_S_KEY_DESC      rtree_key, object_key;
 DB_3D_DBL_BOX      range_box, object_range;

 IGRdouble          file_ige_range[6], scale_factor, uom_factor,
                    max_abs_overflow = 0;

 IGRlong            stat, msg, OM_stat, mthd_stat, rc, 
                    read_msg, IGDS_filedesc, num_bytes_read;

 GRobjid            *processed_ids = NULL;

 IGRint             i, str_len, tag, file_env_range[6], int_value, inx,
                    uor_per_su, su_per_mu, global_origin[3],
                    num_processed_ids = 0, processed_ids_arrsz = 0,
                    begin_index = 0, end_index = GRDGNLIMITS_MAX_I, 
                    cmpnt_tag, block_ptr, byte_ptr;

 IGRshort           mat_type, sys_of_unit, *ele_ptr, *musupu_ptr, 
                    sys_of_units, write_mode = GUWRITE,
                    write_init = GUWRITE_INIT;

 OMuword            rclass;

 IGRboolean         read_status, ext_type_nine = FALSE, 
                    view_overflow = FALSE;

 IGRchar            dgn_file[64], db_file[64], munit[3], sunit[3], 
		    igds_unix_file[64], env_unix_file[64];

#ifdef ENVELOPE
 extern IGRint      env_open(), env_write_tolerances(), 
                    env_write_design(), env_close();
#endif

 extern IGRint      GUcpxinit(), GUotype9(), GUonamedvws(), GUotype5lv1();
 extern IGRlong     GUwrite_element();
 extern IGRboolean  GUget_next_ele();

 /* ***************************************************************** */

 *EFmsg = EMS_S_Success;
 mthd_stat = EMS_S_Success;
 OM_stat = OM_S_SUCCESS;
 stat = EMS_S_Success;

 GUcpxinit ();

/************** SM 06-Oct-89 *****************/
 EMget_unix_filename(igds_file, igds_unix_file);
 EMget_unix_filename(env_file, env_unix_file);

 /* After this point use unix file names except when recording the igds file
    name in the envelope file.
 */


 /*
  * o Open the seed file (one provided by user, otherwise default 
  *   seedfile). 
  *  o Get uor_per_su, su_per_mu, sys_of_units, munit and
  *    sunit (these are needed for Envelope file). 
  *  o Write type 9 element to the IGDS file.
  */

 cvt_buffers.file_des = -1;
 if ( strlen(seed_file) == 0 )
 {
  /*
   *  use the default seed file
   */

  for ( i = 0; (1 & stat); i++ )
  {
    if (stat = ex$get_path(index = i, path = seed_file, len = 80))
    {
      strcat ( seed_file, "config/seed3d.dgn" );
      cvt_buffers.file_des = open ( seed_file, GUREAD_ONLY );
	
      if ( cvt_buffers.file_des != -1 )
        break;

    } /* if (stat = ex$get_path(index=i,path=seed_file,len = 80)) */

  } /* for ( i = 0; (1 & stat); i++ ) */

  if ( cvt_buffers.file_des == -1  || !(1&stat))
  {
    *EFmsg = GUNOSEEDFILE;
    goto wrapup;
  }

 } /* if ( strlen(seed_file) == 0 ) */

 else
 {
  /*
   *  user has specified seed file
   */
	
  cvt_buffers.file_des = open ( seed_file, GUREAD_ONLY );

  if ( cvt_buffers.file_des == -1 )
  {
     *EFmsg = GUNOSEEDFILE;
     goto wrapup;
  }

 } /* else for if ( strlen(seed_file) == 0 ) */

 /*
  *  Create the IGDS design file. The 'creat' function CANNOT be used 
  *  because it does not allow read privileges to the new file.
  */
   
 IGDS_filedesc = open (igds_unix_file, O_CREAT | O_RDWR, GUACCESS_MODE );
	  
 if ( IGDS_filedesc == -1 )
 {
  *EFmsg = GUNOFILE;
  goto wrapup;
 }

 /*
  * Reset the i/o pointers for multiple translations.
  */

 stat = GUwrite_element (&rc, cvt_buffers.dgn_buf, 
                           cvt_buffers.ele_buf, &cvt_buffers.ele_type,
                           &cvt_buffers.ele_size, &IGDS_filedesc,
                           &write_init, &block_ptr, &byte_ptr );

 cvt_buffers.ele_type = -1;
 read_status = TRUE;
		
 while ( read_status == TRUE )
 {
   read_status = GUget_next_ele ( &read_msg, &cvt_buffers );
		
   if ( read_msg != GULAST_ELEMENT )
   {
    /*
     *  Check for type 9. If so, get active uor_per_su, su_per_mu,
     *  sunit, munit.
     */

    if ( (((*((IGRshort *) cvt_buffers.ele_buf)) & 0x7f00) >> 8) == 9 )
    {
     if ( !ext_type_nine )
     {

       /* 
        * Get Envelope file parameters info
        */

       ele_ptr = (IGRshort *) cvt_buffers.ele_buf;

       musupu_ptr = ele_ptr + 556;       /* pointer to su_per_mu */
       OM_BLOCK_MOVE (musupu_ptr, &su_per_mu, sizeof(IGRint));

       musupu_ptr += 2;                  /* pointer to uor_per_su */
       OM_BLOCK_MOVE (musupu_ptr, &uor_per_su, sizeof(IGRint));

       musupu_ptr += 2;                  /* pointer to munit */
       OM_BLOCK_MOVE (musupu_ptr, munit, 2 *sizeof(IGRchar));

       musupu_ptr += 1;                  /* pointer to sunit */
       OM_BLOCK_MOVE (musupu_ptr, sunit, 2 * sizeof(IGRchar));

       munit[2] = sunit[2] = '\0';

       GUswapint (&uor_per_su, &uor_per_su);
       GUswapint (&su_per_mu, &su_per_mu);

       /*
        * Get the scale factor for going from IGE to IGDS
        */
/*
       scale_factor = uor_per_su * su_per_mu;

       stat = co$cvt_exp_to_wrk (msg = &rc, 
                   osnum = md_env->md_id.osnum, 
                   unit_type = "UOM_DISTANCE", units = 1.0, 
                   alias = munit, result = &uom_factor);
       if (rc == MSSUCC)
         scale_factor /= uom_factor;
        
*/
       /*
        * setup the view information and active parameters for IGDS file
        */
       
       GUotype9 (&rc, cvt_buffers.ele_buf, view_setup, &scale_factor);

       if (rc == GUVIEW_OVERFLOW)
       {
         view_overflow = TRUE;
       }

       ext_type_nine = TRUE;

     } /* if ( !ext_type_nine ) */

    } /* if ( (((*((IGRshort * cvt_buffers.ele_buf))&0x7f00)>>8)==9) */

    stat = GUwrite_element (&rc, cvt_buffers.dgn_buf, 
                              cvt_buffers.ele_buf, &cvt_buffers.ele_type, 
                              &cvt_buffers.ele_size, &IGDS_filedesc,
                              &write_mode, &block_ptr, &byte_ptr );

   } /* if ( read_msg != GULAST_ELEMENT ) */

 } /* while ( read_stat == TRUE ) */

 if ( read_msg != GULAST_ELEMENT )
 {
   /*
    *  read error has occurred
    *  abort this function
    */
   *EFmsg = GUREAD_ERROR;
   goto wrapup;
  }
 
  /*
   *  Set up named views for each view in the IGE object space.
   */

  stat = GUonamedvws (&rc, &IGDS_filedesc, cvt_buffers.dgn_buf,
                        cvt_buffers.ele_buf, md_env, &scale_factor);
  if ( !(1 & stat) && (rc == GUVIEW_OVERFLOW) )
  {
    view_overflow = TRUE;
  }

  sys_of_units = ((strncmp (munit, "FT", 2) == 0) ||
                  (strncmp (munit, "ft", 2) == 0) ||
                  (strncmp (munit, "IN", 2) == 0) ||
                   (strncmp (munit, "in", 2) == 0) ||
                  (strncmp (munit, "ML", 2) == 0) ||
                  (strncmp (munit, "ml", 2) == 0)) ? ENGLISH : METRIC;

 /*
  * o Open the envolope file.
  * o Write tolerances to it.
  * o For each component,
  *   o Get its range. Add this range to the envelope file range.
  *   o Write the surfaces of this component to the envelope file.
  * o Write design information to the file.
  * o Close the envelope file.
  */

#ifdef ENVELOPE
  stat = env_open (env_unix_file);
  EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

  {
   IGRdouble cyl_len_cone = 0., cyl_len_elipse = 0.,
             slicing_distance, construction_tolerance = 0.;
   IGRshort  no_cyl_90_degree = 0;

   slicing_distance = sys_of_units == METRIC ? 25. : 1.;
  
#ifdef ENVELOPE
   stat = env_write_tolerances (&cyl_len_cone, &cyl_len_elipse, 
                         &no_cyl_90_degree,
                         &slicing_distance, &construction_tolerance);
   EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif
                        
  }

  for (inx = 0; inx < 3; inx++)
  {
   file_ige_range[inx] = MAXDOUBLE;
   file_ige_range[inx+3] = -MAXDOUBLE;
  } 

  /*
   * o Convert file range to IGDS format.
   * o write design info to the Envelope file. Envelope functions
   *   requires to write design before writing any components.
   *   Since file range is not available at this point, use maxlimits.
   *    Once, all of the components are written and true design limits
   *   are known, write design info again with correct design range.
   */

  for (i = 0; i < 6; i++)
   file_env_range[i] = GUnint (file_ige_range[i]);

  db_file[0] = NULL;
  for (i = 0; i < 3; i++)
   global_origin[i] = 0;

#ifdef ENVELOPE
  stat = env_write_design (&uor_per_su, &su_per_mu, global_origin, 
                   file_env_range, &sys_of_units, 
                   munit, sunit, igds_file, db_file);
  EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

  /*
   * Perform a Rtree pass 
   */

  env_file_arglist.EMmsg = &mthd_stat;
  env_file_arglist.md_env = md_env;
  env_file_arglist.scale_factor = &scale_factor;
  env_file_arglist.cvt_buffers = &cvt_buffers;
  env_file_arglist.IGDS_filedesc = &IGDS_filedesc;
  env_file_arglist.max_abs_overflow = &max_abs_overflow;
  env_file_arglist.cmpnt_tag = &cmpnt_tag;
  env_file_arglist.is_tag_good = FALSE;
  env_file_arglist.file_ige_range = file_ige_range;
  env_file_arglist.num_processed_ids = &num_processed_ids;
  env_file_arglist.processed_ids_arrsz = &processed_ids_arrsz;
  env_file_arglist.processed_ids = &processed_ids;

  OM_stat = om$make_message (classname = "EMSsurface",
               methodname = "EMcreate_envelope_and_igds_files",
               size = sizeof(env_file_arglist),
               p_arglist = &env_file_arglist,
               p_msg = &env_msg);
  EMerr_hndlr (!(1&OM_stat), *EFmsg, EMS_E_OMerror, wrapup);

  rtree_pass_arglist.msg = &env_msg;
  rtree_pass_arglist.p_select_key = &rtree_key;
  rtree_pass_arglist.classlist = &rtree_classes;
  rtree_pass_arglist.p_target_key = &object_key;
  rtree_pass_arglist.user_compare = NULL;
  rtree_pass_arglist.ret = (IGRint *)&msg;

  rtree_classes.w_count = 1;
  rtree_classes.w_flags = OM_CLST_subclass;
  rtree_classes.p_classes = &rclass;
  rclass = OPP_EMSsubbs_class_id;

  rtree_key.type = KEY_3D_DBL;
  rtree_key.key.p_3ddbl = &range_box;
  range_box.xmin = GRDGNLIMITS_MIN_D;
  range_box.ymin = GRDGNLIMITS_MIN_D;
  range_box.zmin = GRDGNLIMITS_MIN_D;
  range_box.xmax = GRDGNLIMITS_MAX_D;
  range_box.ymax = GRDGNLIMITS_MAX_D;
  range_box.zmax = GRDGNLIMITS_MAX_D;

  object_key.type = KEY_3D_DBL;
  object_key.key.p_3ddbl = &object_range;

  OM_stat = om$make_message (classname = "OMindex",
               methodname = "pass",
               size = sizeof(rtree_pass_arglist),
               p_arglist = &rtree_pass_arglist,
               p_msg = &rtree_pass_msg);
  EMerr_hndlr (!(1&OM_stat), *EFmsg, EMS_E_OMerror, wrapup);

  /*
   * Send a message to the module for 2 level pass to the objects
   */

  OM_stat = om$send (msg = message module.GRmod_passon (&msg,
                      &rtree_pass_msg, "primary", &begin_index, 
                      &end_index),
                     senderid = NULL_OBJID,
                     targetid = md_env->md_id.objid,
                     targetos = md_env->md_id.osnum);
  EMerr_hndlr (!(1&OM_stat&mthd_stat), *EFmsg, EMS_E_Fail, wrapup);

 /*
  * o Convert file range to IGDS format.
  * o write design info to the Envelope file.
  */

 for (i = 0; i < 6; i++)
  file_env_range[i] = GUnint (file_ige_range[i]);

/************************** SM 05-Oct-89 ***********************
 stat = env_write_design (&uor_per_su, &su_per_mu, global_origin, 
                   file_env_range, &sys_of_units, 
                   munit, sunit, dgn_file, db_file);
 EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
*********************************************************/

#ifdef ENVELOPE
 stat = env_write_design (&uor_per_su, &su_per_mu, global_origin, 
                   file_env_range, &sys_of_units, 
                   munit, sunit, igds_file, db_file);
 EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);

 stat = env_close();
 EMerr_hndlr (stat < 0, *EFmsg, EMS_E_Fail, wrapup);
#endif

 /*
  * Insert color table type 5's into IGDS design
  * file and create IGDS color table file.
  */

 GUotype5lv1 (&rc, igds_unix_file, &IGDS_filedesc, cvt_buffers.dgn_buf, 
              cvt_buffers.ele_buf, &cvt_buffers.ele_size );

		
 /*
  *  write the end-of-file into the IGDS design file
  */

 num_bytes_read = 2;
 cvt_buffers.ele_buf[0] = cvt_buffers.ele_buf[1] = 0xFF;
 cvt_buffers.ele_type = -1;

 stat = GUwrite_element (&rc, cvt_buffers.dgn_buf, cvt_buffers.ele_buf, 
                           cvt_buffers.ele_type, &num_bytes_read, 
                           &IGDS_filedesc, &write_mode, &block_ptr,
                           &byte_ptr );

 /*
  * Flush the buffer containing the end-of-file before closing
  * the IGDS file
  */

 write_mode = GUFLUSH;
 stat = GUwrite_element (&rc, cvt_buffers.dgn_buf, cvt_buffers.ele_buf, 
                           cvt_buffers.ele_type, &num_bytes_read, 
                           &IGDS_filedesc, &write_mode, &block_ptr,
                           &byte_ptr );

 /*
  * Increase the size of the IGDS design file.
  */

 write_mode = GUINCREASE;
 cvt_buffers.ele_size = 10;
 stat = GUwrite_element (&rc, cvt_buffers.dgn_buf, cvt_buffers.ele_buf, 
                           cvt_buffers.ele_type, &cvt_buffers.ele_size, 
                           &IGDS_filedesc, &write_mode, &block_ptr,
					       &byte_ptr);

 /*
  * If views caused overflow, set the return code.
  */

 if (view_overflow ) *EFmsg = GUVIEW_OVERFLOW;

 /*
  * Check to see if elements were skipped due to
  *	overflow error. Element overflow takes 
  *	precedence over view overflow.
  */

 if ( max_abs_overflow != 0 ) *EFmsg = GUELEMENT_OVERFLOW;

 /*
  *  close the seed file and the new IGDS file
  */

 close ( cvt_buffers.file_des );

 close ( IGDS_filedesc );


wrapup:
 EMWRAPUP (*EFmsg, OM_stat, "EFwrite_envelope_and_igds_files");
 if (processed_ids) om$dealloc (ptr = processed_ids);
 return;

} /* EFwrite_envelope_and_igds_files () */



static void EMget_unix_filename(infile, unix_file)
IGRchar *infile, *unix_file;
{
 char *ptr1, *ptr2, *ptr;
 ptr1 = ptr2 = ptr = NULL;

 ptr1 = strchr(infile, ':');
 ptr2 = strchr(infile, ']');
 ptr = ptr1 > ptr2 ? ptr1 : ptr2;
 if(ptr) strcpy(unix_file, ++ptr);
 else strcpy(unix_file, infile);
}
end implementation EMSsubbs;

