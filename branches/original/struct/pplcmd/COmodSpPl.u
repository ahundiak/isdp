/* *****************************************************************************
   Product :	I/STRUCT
   Author  :	Marc Fournier (COC shipbuilding, Paris)
   Date    :	02/29/2000
   Subject :	Split Plate
   Object  :    Add a track point parent to Avondale corrupted spilt plates
***************************************************************************** */

/*
#define	vsDEBUG		1
#define	vserrDEBUG	1
*/

#include	"VDppl.h"
#include	"VDobj.h"
#include	"asmacros.h"
#include	"ndmacros.h"
#include	"vsplatedef.h"
#include	"vsdbgmacros.h"

#define	theCommand	"Add/modify track point to 1st surface of Split Plate"
#define	thePrompt1	"Select a Split Plate (by Navigate Dependency Graph)"
#define	thePrompt2	"Select a Track Point"

extern			ASmake_source_from_env();
extern			NDget_mod_batch(),
			NDput_mod_batch(),
			NDwait_batch(),
			NDexec_batch();
extern	IGRboolean	ASbroadcast_in_progress;
extern			ems_dload();

extern	struct	GRid	NULL_GRID;
extern	OMuword		OPP_VSsplPlate_class_id;

IGRint compute ( SplitPlate, TrackPoint )
	struct	GRobj_env	*SplitPlate; 
	struct	GRobj_env	*TrackPoint; 
{
	IGRint			sts, cnt, cnType, wtBatch;
	struct	GRid		*Old, New;
	IGRboolean		svBroad;

	__DBGpr_com ( ">> COmodSpPl:compute" );

	Old = NULL;
	New.objid = NULL_OBJID;

	/* Get number of parents */
	sts = ci$send ( msg = message NDnode.NDget_objects (
				ND_IN_BUF | ND_ROOT,
				(struct GRid *)NULL,
				0,
				&Old,
				0,
				OM_K_MAXINT,
				&cnt ),
			targetid = SplitPlate->obj_id.objid,
			targetos = SplitPlate->obj_id.osnum );
	__CheckRC( sts, 1, "NDnode.NDget_objects", EndOfCompute ) ;
	__DBGpr_int ( "COmodSpPl:Number of parents ", cnt );

	/* Make source of TrackPoint */
	sts = as$make_source ( go_grid = TrackPoint->obj_id,
			       mod_env = &(TrackPoint->mod_env),	
			       as_grid = &New );
	__CheckRC( sts, 1, "as$make_source()", EndOfCompute ) ;
	__DBGpr_obj ( "COmodSpPl:Parent[2] will be ", New );

	/* Disconnect Parent[2] (if exist) */
	if (cnt > 2) {
		sts = ci$send ( msg = message NDnode.NDdisconnect
				( 1, &Old[2] ),
				targetid = SplitPlate->obj_id.objid,
				targetos = SplitPlate->obj_id.osnum );
		__CheckRC( sts, 1, "NDnode.NDdisconnect", EndOfCompute ) ;
		__DBGpr_obj ( "COmodSpPl:NDdisconnect ", Old[2] );
	}

	/* Free buffer */
	if (Old) {
		om$dealloc (ptr = Old);
		Old = NULL;
		__DBGpr_com ( "COmodSpPl:om$dealloc(Old)" );
	}

	/* Reconnect parents */
	sts = ci$send ( msg = message NDnode.NDconnect
			( 1, &New, NULL_GRID, ND_ADD ),
			targetid = SplitPlate->obj_id.objid,
			targetos = SplitPlate->obj_id.osnum );
	__CheckRC( sts, 1, "NDnode.NDconnect", EndOfCompute ) ;
	__DBGpr_obj ( "COmodSpPl:NDconnect ", New );

	/* Batch */
	__DBGpr_com ( ">> COmodSpPl:nd$mod_batch" );
	cnType = ND_COMP;
        nd$wait_batch(  type       = GR_GEOM_POSTED,
                        l_object   = &(SplitPlate->obj_id),
			l_obj_info = &cnType,
                        nb_obj     = 1 ) ;

	__DBGpr_com ( ">> COmodSpPl:nd$mod_batch" );
	nd$mod_batch(   request    = ND_INQ,
                        p_ret_mode = &wtBatch );

	svBroad = ASbroadcast_in_progress;
	ASbroadcast_in_progress = FALSE;

	if (wtBatch != ND_DEFER) {
		__DBGpr_com ( ">> COmodSpPl:nd$exec_batch" );
/*
ems_dload ( "/export/home/marc/dbg/send_on.so" );
*/
        	nd$exec_batch( mode = ND_DISP_ROOT|ND_DISP_BODY ) ;
	}

	ASbroadcast_in_progress = svBroad;

EndOfCompute:

	if (Old) {
		om$dealloc (ptr = Old);
		Old = NULL;
		__DBGpr_com ( "COmodSpPl:om$dealloc(Old)" );
	}

	__DBGpr_com ( "<< COmodSpPl:compute" );

	return (sts);
}

IGRint main () {

	IGRint			sts, response;
	struct	GRobj_env	SP, TP;

	__DBGpr_com ( ">> COmodSpPl:main" );

	while (1) {

StartOfLocate:
		/* Locate Split Plate */
		SP.obj_id.objid = NULL_OBJID;
		response = 0;
		UI_message (theCommand);
		sts = ci$locate ( prompt       = thePrompt1,
				  classes      = "VSsplPlate",
				  properties   = LC_LC_ONLY |
					         LC_DP_ONLY |
					         LC_RW,
				  owner_action = LC_RIGID_OWNER |
						 LC_RIGID_COMP  |
                                   	         LC_FLEX_COMP   |
                                   	         LC_FLEX_OWNER,
				  stackable    = 1,
				  response     = &response,
				  md_env       = &SP.mod_env,
				  obj	       = &SP.obj_id.objid,
				  osnum	       = &SP.obj_id.osnum );

		/* Navigate Dependency Graph can be hazardous */
		sts = vdobj$IsAncestryValid
			( objOE = &SP, superClassID = OPP_VSsplPlate_class_id );
		if (!(sts & 1))	response = 0;
		if (response == 0) goto StartOfLocate;
		__DBGpr_obj ( "COmodSpPl:Split Plate ", SP.obj_id );

		/* Locate Track Point */
		TP.obj_id.objid = NULL_OBJID;
		response = 0;
		UI_message (theCommand);
		sts = ci$locate ( prompt       = thePrompt2,
				  classes      = "GRpoint",
				  properties   = LC_LC_ONLY |
					         LC_DP_ONLY |
					         LC_RW,
				  owner_action = LC_RIGID_OWNER |
						 LC_RIGID_COMP  |
                                   	         LC_FLEX_COMP   |
                                   	         LC_FLEX_OWNER,
				  stackable    = 1,
				  response     = &response,
				  md_env       = &TP.mod_env,
				  obj	       = &TP.obj_id.objid,
				  osnum	       = &TP.obj_id.osnum );
		if (!(sts & 1))	response = 0;
		__DBGpr_obj ( "COmodSpPl:Track Point ", TP.obj_id );

		/* Add/change Track Point */
		sts = compute ( &SP, &TP );
		__CheckRC( sts, 1, "compute", EndOfLocate ) ;
	}

EndOfLocate:

	__DBGpr_com ( "<< COmodSpPl:main" );

	return (sts);
}

wakeup () { UI_message (theCommand); }
