/* Do not alter this SPC information: $Revision: 1.2.3.1 $ */
/*
**	NAME:							uldinter.rc
**	AUTHORS:						Jennifer Xia
**	CREATION DATE:					7/90
**	ABSTRACT:
**		It contains the main function of RISunload which invokes
**		RISuld_interactive_unload function in interactive mode
**		and RISuld_batch_unload function in batch mode.
**	
**	REVISION HISTORY:
**		August 6th, 1991 Hitesh Patel
** 	 	Ashley 7/9/96 - fix for 439402027 
*/
/* {{{ INCLUDES */

#if defined(WIN32S) && defined(ULD_EXE)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#include "risutl.h"
#include "prog32s.h"
#endif

#include <ctype.h>
#ifdef MM
#include "unlod.h"
#endif

exec sql include "unlod.h";

/* }}} */
/* {{{ FUNCTION PROTOTYPES */

#define uldinter_rc
#include "sys.prt"
#include "comdebug.prt"
#include "comwrap.prt"
#include "comjmp.prt"
#include "comumsg.prt"
#include "uldermsg.prt"
#include "uldgtsch.prt"
#include "uldinter.prt"
#include "uldmisc.prt"
#include "uldstspc.prt"
#include "uldtime.prt"
#include "uldwhat.prt"

/* }}} */
/**********************************************************************/
/* {{{ RISuld_interactive_unload() */

extern void RISuld_interactive_unload()
{
/* {{{ Local Variables */

	which_to_nld_type 	which_to_nld;
	sch_node_type		sch_node;
	int					retn;
	int					count = 0;
	char				ans;
	char				buffer[80];

/* }}} */

	ULD_DBG(("RISuld_interactive_unload:"));

/* {{{ Get BLANK STRIP mode (y/n) */

	for(;;)
	{
		RISuld_print_msg(MSG(RISUTL_I_PRESERVE_BLANKS));
#if defined(WIN32S)
		GETS(buffer);
#else
		RIScom_fgets(buffer,80,stdin);
 	/* Ashley 7/9/96 - fix for 439402027 */
        /* this is may not be valid for international code */
        /* but rislod/unlod is not internationalized on unix */
#if defined(unix)
                 if ( feof(stdin)) /* was control-D hit */
                      exit(0);
#endif
#endif
		ans = buffer[0];

		if (isupper(ans))
		{
			ans = _tolower(ans);
		}

		if (ans == DEFAULT)
		{
			ans = 'n';
		}

		if( (ans == 'y') ||	(ans == 'n') )
		{
			if (ans == 'y')
			{
				RISuld_blankstrip_mode(0);
			}
			break;
		}
		else
		{
            RISuld_print_msg(MSG(RISUTL_I_VALID_YES_OR_NO));
		}
	}

/* }}} */
/* {{{ Get the file mode: (w/a/e) */

    /* Get file mode */
	for(;;)
	{
		RISuld_print_msg(MSG(RISUTL_I_ENTER_FILE_MODE));
		RISuld_print_msg(MSG(RISUTL_I_FILE_MODE_OPTIONS));
#if defined(WIN32S)
		GETS(buffer);
#else
		RIScom_fgets(buffer,80,stdin);
	/* Ashley 7/9/96 - fix for 439402027 */
        /* this is may not be valid for international code */
        /* but rislod/unlod is not internationalized on unix */
#if defined(unix)
                if ( feof(stdin)) /* was control-D hit */
                      exit(0);
#endif
#endif
		RISuld_filemode = buffer[0];

		if (isupper(RISuld_filemode))
		{
			RISuld_filemode = _tolower(RISuld_filemode);
		}

		if (RISuld_filemode == DEFAULT)
		{
			RISuld_filemode = 'e';
		}

		if( RISuld_filemode == 'w'
		||  RISuld_filemode == 'a'
		||  RISuld_filemode == 'e')
		{
			break;
		}
		else
		{
			RISuld_print_msg(MSG(RISUTL_I_VALID_FILEMODE_OPT));
		}
	}

/* }}} */
/* {{{ Get the name for the unload file */

	for(;;)
	{
		RISuld_print_msg(MSG(RISUTL_I_MAIN_UNLOAD_FILE));
#if defined(WIN32S)
		GETS(RISuld_mfile);
#else
		RIScom_fgets(RISuld_mfile,RIS_MAX_PATH_SIZE-1,stdin);
 	/* Ashley 7/9/96 - fix for 439402027 */
        /* this is may not be valid for international code */
        /* but rislod/unlod is not internationalized on unix */
#if defined(unix)
                if ( feof(stdin)) /* was control-D hit */
                     exit(0);
#endif
#endif
		if (*RISuld_mfile == DEFAULT)
		{
			strcpy(RISuld_mfile, "ris.dmp");
		}
		else
		{
			RISuld_strip_newline(RISuld_mfile);
		}
	

		if( (RISuld_out_fp = RISuld_interactive_open_file(RISuld_mfile)) == NULL )
		{
			RISuld_prompt_quit_risunload();
		}
		else
		{
			break;
		}
	}	

/* }}} */
/* {{{ Loop for schemas */

	for(;;)
	{
		/* Get next schema */
		count++;
		retn = RISuld_get_next_sch(&sch_node);
		if(retn == FAILURE)
		{
			if(count == 1)
			{
				ULD_DBG(("1. RISuld_interactive_unload: end"));
				TERMINATE_RISUNLOAD	
			}
			else
			{
				ULD_DBG(("2. RISuld_interactive_unload: end"));
				return;
			}
		}

		RISuld_create_bsnode(sch_node.sch_name, sch_node.sch_pwd,
			 sch_node.os_name, sch_node.os_pwd, sch_node.db_name, sch_node.db_pwd);

		/* Get info for this schema */
		RISuld_find_nld_what(&which_to_nld, 
							RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sch_name); 
		RISuld_close_sch(sch_node.sch_name);

		ULD_DBG(("3. RISuld_interactive_unload: end"));
	}

/* }}} */
}

/* }}} */
/**********************************************************************/
/* {{{ RISuld_prompt_quit_risunload() */

extern void RISuld_prompt_quit_risunload()
{
	int 	ans;
	char	buffer[80];

	for(;;)
	{
		RISuld_print_msg(MSG(RISUTL_I_QUIT_RISUNLOAD));
#if defined(WIN32S)
		GETS(buffer);
#else
		RIScom_fgets(buffer,80,stdin);
 	/* Ashley 7/9/96 - fix for 439402027 */
        /* this is may not be valid for international code */
        /* but rislod/unlod is not internationalized on unix */
#if defined(unix)
                if ( feof(stdin)) /* was control-D hit */
                      exit(0);
#endif
#endif
		ans = buffer[0];

		if (isupper(ans))
		{
			ans = _tolower(ans);
		}

		if (ans == DEFAULT)
		{
			ans = 'n';
		}
		if( ans == 'y' ||  ans == 'n')
		{
			if( ans == 'y' )
			{
				TERMINATE_RISUNLOAD
			}
			else
			{
				return;
			}
		}
		else
		{
			RISuld_print_msg(MSG(RISUTL_I_VALID_YES_OR_NO));
		}
	}
}

/* }}} */
