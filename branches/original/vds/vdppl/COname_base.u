/* $Id: COname_base.u,v 1.1.1.1 2001/01/04 21:09:02 cvs Exp $  */

/***************************************************************************
 * I/VDS
 *
 * File:        vds/vdppl/COname_base.u
 *
 * Description: Name the base cs if it's name gets lost
 *
 * Dependencies: 
 *
 * Revision History:
 *      $Log: COname_base.u,v $
 *      Revision 1.1.1.1  2001/01/04 21:09:02  cvs
 *      Initial import to CVS
 *
# Revision 1.1  1999/10/13  17:02:20  pinnacle
# tr179900902
#
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 10/13/99  ah      TR179900902 Name base cs
 *
 ***************************************************************************/

#include "VDppl.h"
#include "VDobj.h"
#include "VDmem_ppl.h"

#include "coparamac.h"

extern ASstart_var_fence();
extern ASend_fence();
extern VD_bulkDisplayByGRobj_envs();

#define thePrompt  "Select Base CS"
#define theCommand "Name the BASEcoordsys"
#define theFilter  "GRcsbase"

IGRint traceFlag;

/* -------------------------------------
 * Process the selected unwrap
 */
int process(objOE)
TGRobj_env *objOE;

{
  IGRchar objName[1024];
  IGRchar buf[128];
  
  // vdobj$Print(objOE = objOE);
  
  // Check the name
  vdobj$Get(objOE = objOE, objName = objName);
  // printf("objName = %s\n",objName);
  if (*objName) {
    sprintf(buf,"Base CS is already named %s, objid is %d",objName,objOE->obj_id.objid);
    UI_status(buf);
    return 1;
  }
  
  // Adjust the name
  *objName = 0;
  di$give_pathname(osnum = objOE->obj_id.osnum, pathname = objName);
  
  // Add the explicit path(should tweak for transient space)
  DIstrcat(objName,"usr");    
  DIstrcat(objName,"BASEcoordsys");

  di$add_name(objname = objName, 
	      osnum   = objOE->obj_id.osnum, 
	      objid   = objOE->obj_id.objid);

  // Update display
  VD_bulkDisplayByGRobj_envs(GRbd, 1, objOE);
  
  sprintf(buf,"Base CS renamed to %s, objid is %d",objName,objOE->obj_id.objid);
  UI_status(buf);
  
  // Done
  return 1;
}

/* --------------------------------------
 * The main routine
 */
int main()
{
  int sts,msg;
  int response;
  
  TGRobj_env  objOE;
  TGRobj_env *locOEs;
  IGRint      locNum;
  IGRint      i;
  
  traceFlag = 0;
    
  while(1) {

    objOE.obj_id.objid = NULL_OBJID;
    
    response = 0;

    UI_message(theCommand);

    sts = ci$locate(prompt  = thePrompt,
                    classes = theFilter,
		    owner_action = LC_RIGID_OWNER | 
                                   LC_RIGID_COMP  |
                                   LC_FLEX_COMP   | 
                                   LC_FLEX_OWNER  |
                                   LC_REF_OBJECTS,

                    stackable    = 1,
		    response     = &response,
		    md_env       = &objOE.mod_env,
		    obj          = &objOE.obj_id.objid,
		    osnum	 = &objOE.obj_id.osnum);

    if (!(sts & 1)) response = 0;

    switch(response) {

    case EX_OBJID:   // Object Set

      printf("============= Object Set =============\n");
      
      /* Grab Located Objects */
      as$start_fence(
      set       = &objOE.obj_id,
      set_env   = &objOE.mod_env,
      nb_obj    = &locNum,
      p_obj_env = &locOEs);

      for(i = 0; i < locNum; i = i + 1) {
        process(&locOEs[i]);
      }

      ASend_fence();
      break;
      
    case EX_DATA:    // Single Object
      
      process(&objOE);
      break;

    } // Switch
  }

wrapup:
  return 1;
}

/* ------------------------------------------
 * Usual command object messages
 */
init()
{
}
sleep() 
{
}
wakeup()
{
  UI_message(theCommand); 
}
delete()
{
}
