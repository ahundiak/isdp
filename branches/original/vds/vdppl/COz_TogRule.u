/* $Id $  */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:                vdppl/COz_TogRule.u
 *
 * Description: PPL to set the "Rule Line Display" ON for all or 
 * 		selected windows.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      12/08/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "grmsg.h"

#define MAX_WINDOW      40

extern 	DPgetggid(), DPsetinqgragad();

main()
{
IGRlong			msg, num_bytes, which_error;
IGRint			i, response, num_ggid, mask, inq_flags, set_flags[2]; 
struct GRevent      	event;
struct GRid    		ggid[MAX_WINDOW];
struct var_list         varlist[2];

  message( "PPL: Toggle Rule Line Display" );

  ci$getevent( prompt   = 
		 "Identify Window/Key-in Window Name/Move on for All Windows",
               response = &response,
               mask     = mask,
               event    = &event,
               stackable= 1 );

  if( response == EX_DATA )
  {
     num_ggid = 1;
     ggid[0].osnum = event.event.button.osnum;
     ggid[0].objid = event.event.button.objid;
  }
  else if( response == EX_STRING )
  {
     if ( !strlen( event.event.keyin ) ) return 1;
     num_ggid = 0;
     dp$get_gragad_id(  msg         = &msg,
                        name        = event.event.keyin,
                        array_size  = MAX_WINDOW,
                        numberofids = &num_ggid,
                        found_GRids = ggid,
                        type_gragad = ALL_GG_CLASSES | GG_WIN_ON );
     if ( num_ggid == 0) {
         ex$message ( msgnumb = GR_E_WinNotFnd);
	 return 1;
     }
     else if( num_ggid > 1 && MAX_WINDOW == 1 )
     {
	 ex$message ( msgnumb = GR_E_AmbNme );
	 return 1;
     }
  }
  else if( response == EX_RJT_MOVEON )
  {
     num_ggid = 0;
     dp$get_gragad_id(  msg         = &msg,
                        name        = "*",
                        array_size  = MAX_WINDOW,
                        numberofids = &num_ggid,
                        found_GRids = ggid,
                        type_gragad = ALL_GG_CLASSES | GG_WIN_ON );
     if ( num_ggid == 0) {
         ex$message ( msgnumb = GR_E_WinNotFnd);
         return 1;
     }
     else if( num_ggid > 1 && MAX_WINDOW == 1 )
     {
         ex$message ( msgnumb = GR_E_AmbNme );
         return 1;
     }
  }
  if( !num_ggid )   return 1;

  for( i=0; i<num_ggid; i=i+1 )
  {
      varlist[0].var = GRAGAD_FLAGS;
      varlist[0].var_ptr = (IGRchar *)&inq_flags;
      varlist[0].num_bytes = sizeof(IGRint);
      varlist[0].bytes_returned = &num_bytes;
      varlist[1].var = END_PARAM;

      dp$inq_set_gragad( msg          = &msg,
                         inq0_set1    = 0, /* inquire only */
                         osnum        = ggid[i].osnum,
                         gragad_objid = ggid[i].objid,
                         which_error  = &which_error,
                         var_list     = varlist );
      if( !(msg&1) ) continue;

      if( inq_flags & DP_NO_RULE_LINES )
      {
  	  set_flags[0] = DP_NO_RULE_LINES;
  	  set_flags[1] = 0;

          varlist[0].var_ptr = (IGRchar *)set_flags;
          varlist[0].num_bytes = sizeof(IGRint) * 2;
          dp$inq_set_gragad( msg          = &msg,
                             inq0_set1    = 1, 		/* set */
                             update       = 1, 		/* update window */
                             osnum        = ggid[i].osnum,
                             gragad_objid = ggid[i].objid,
                             which_error  = &which_error,
                             var_list     = varlist);
      }
  }

  return 1;
}
