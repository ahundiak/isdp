/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*	Execute "ci=toggle [c] [f] [m]" for different levels of debug print	*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "cievent.h"
#include "msdef.h"
#include "bserr.h"

IGRchar                 loc_mes[80];
IGRint                  npols[2];

struct GRid             display_info, PREV, TEMP[2], *GRid_pols0, *GRid_pols1;
struct GRmd_env         MOD_ENV[2];
struct GRvg_construct   cst;
struct IGRdisplay       dis;
struct IGRpolyline      geom;

extern unsigned short   OPP_EMSsubbs_class_id;

extern IGRint           init_cnst_list (),
                        GRfindmod (),
                        free ();

extern IGRchar         *malloc ();
extern IGRdouble        BSdistptpt ();
extern void             BSsfarrev0 ();

#ifndef	DEBUG
#define	DEBUG	0
#endif

extern			VDcomment, VDfunct, VDmethod;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*				 Beginning of code				*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

main ()
{
  OMuword                 classid[1];
  IGRchar                 str[2];
  IGRint                  resp, stat, mask;
  IGRint                  cnt, np0, np1;
  IGRlong                 sz[2];
  IGRlong                 OMsts;
  IGRdouble               max_dst;
  IGRdouble              *poles0, *poles1;

  struct GRid             NEW;
  struct GRsymbology      smb;
  struct GRpost_info      post_info;
  struct GRevent          event;
  struct OM_sd_classlist  classlist;
  struct IGRbsp_surface  *sf[2];

  poles0     = NULL;
  poles1     = NULL;
  classid[0] = OPP_EMSsubbs_class_id;

  classlist.w_count   = 1;
  classlist.w_flags   = OM_CLST_subclass;
  classlist.p_classes = classid;

  while ( 1 )
  {
step1:

    PREV = TEMP[0];

    ci$locate ( prompt		 = "Locate Reference Surface (1)",
                eligible_classes = &classlist,
                properties	 = LC_LC_ONLY    | LC_DP_ONLY     | LC_RW,
                owner_action	 = LC_RIGID_COMP | LC_RIGID_OWNER |
                                   LC_FLEX_COMP  | LC_FLEX_OWNER  | LC_REF_OBJECTS,
                obj		 = &TEMP[0].objid,
                osnum		 = &TEMP[0].osnum,
                md_env		 = &MOD_ENV[0],
                response	 = &resp );

    switch ( resp )
    {
      case DATA:
        break;
      case EX_OBJID:
        goto step1;
      case D_RESET:
        exit;
      case EX_RJT_MOVEON:
        {
          del_GRid ( &npols[0], GRid_pols0, TEMP[0], MOD_ENV[0] );
          goto step1;
        }
      case EX_BACK_UP:
        {
          goto step1;
        }
      default:
        message ( "Require <Backup> or <DATA> " );
        status  ( "Invalid user input" );
        exit;
    }

step2:

    PREV = TEMP[1];

    ci$locate ( prompt		 = "Locate Surface to Modify (2)",
                eligible_classes = &classlist,
                properties	 = LC_LC_ONLY    | LC_DP_ONLY     | LC_RW,
                owner_action	 = LC_RIGID_COMP | LC_RIGID_OWNER |
                                   LC_FLEX_COMP  | LC_FLEX_OWNER  |LC_REF_OBJECTS,
                obj		 = &TEMP[1].objid,
                osnum		 = &TEMP[1].osnum,
                md_env		 = &MOD_ENV[1],
                response	 = &resp );

    switch ( resp )
    {
      case DATA:
        break;
      case EX_OBJID:
        goto step2;
      case D_RESET:
        exit;
      case EX_RJT_MOVEON:
        {
          del_GRid ( &npols[1], GRid_pols1, TEMP[1], MOD_ENV[1] );
          goto step2;
        }
      case EX_BACK_UP:
        {
          goto step2;
        }
      default:
        message ( "Require <Backup> or <DATA> " );
        status  ( "Invalid user input" );
        exit;
    }

    ci$send ( msg = message GRvg.GRgetsymb ( &stat, &smb ),
              targetid = TEMP[0].objid,
              targetos = TEMP[0].osnum );

    dis.color = smb.display_attr.color;	/* Gives poles color of curve / surface */

    ci$send ( msg = message GRvg.GRgetsize ( &stat,
                                             &MOD_ENV[0].md_env.matrix_type,
                                              MOD_ENV[0].md_env.matrix,
                                             &sz[0] ),
              targetid = TEMP[0].objid,
              targetos = TEMP[0].osnum );

    ci$send ( msg = message GRvg.GRgetsize ( &stat,
                                             &MOD_ENV[1].md_env.matrix_type,
                                              MOD_ENV[1].md_env.matrix,
                                             &sz[1] ),
              targetid = TEMP[1].objid,
              targetos = TEMP[1].osnum );

    sf[0] = (struct IGRbsp_surface *) malloc ( sz[0] * ( sizeof ( char ) ) );
    sf[1] = (struct IGRbsp_surface *) malloc ( sz[1] * ( sizeof ( char ) ) );

    ci$send ( msg = message GRvg.GRgetgeom ( &stat,
                                             &MOD_ENV[0].md_env.matrix_type,
                                              MOD_ENV[0].md_env.matrix,
                                             ( char * ) sf[0] ),
              targetid = TEMP[0].objid,
              targetos = TEMP[0].osnum );

    ci$send ( msg = message GRvg.GRgetgeom ( &stat,
                                             &MOD_ENV[1].md_env.matrix_type,
                                              MOD_ENV[1].md_env.matrix,
                                             ( char * ) sf[1] ),
              targetid = TEMP[1].objid,
              targetos = TEMP[1].osnum );

    npols[0]   = sf[0]->u_num_poles * sf[0]->v_num_poles;
    npols[1]   = sf[1]->u_num_poles * sf[1]->v_num_poles;

    GRid_pols0 = (struct GRid *) malloc ( npols[0] * ( sizeof ( struct GRid ) ) );
    GRid_pols1 = (struct GRid *) malloc ( npols[1] * ( sizeof ( struct GRid ) ) );

    poles0     = ( IGRdouble * ) malloc(npols[0] * 24);
    poles1     = ( IGRdouble * ) malloc(npols[1] * 24);

//    if (VDcomment)
    {
      printf("##################################################################\n");
      printf("Surface_ID[0] = [%d,%d] : num_poles[0] = %d (%d x %d)\n",
             TEMP[0].osnum, TEMP[0].objid, npols[0], sf[0]->u_num_poles, sf[0]->v_num_poles);
      printf("Surface_ID[1] = [%d,%d] : num_poles[1] = %d (%d x %d)\n",
             TEMP[1].osnum, TEMP[1].objid, npols[1], sf[1]->u_num_poles, sf[1]->v_num_poles );
    }

    disp_sf_GRid ( sf[0], poles0, &MOD_ENV[0], GRid_pols0, &cst );
    disp_sf_GRid ( sf[1], poles1, &MOD_ENV[1], GRid_pols1, &cst );

    // ===========================================================================
    // This function perfoms all the required calculations for adjustment of poles
    // ===========================================================================
    get_common_edge_info( &cnt, &np0, &np1, &max_dst, poles0, poles1, sf );
    if (VDcomment)
    {
      printf("cnt = %d, np0 = %d, np1 = %d, max_dst = %lg\n", cnt, np0, np1, max_dst );
    }
    // Only allow surface [2] to be modified:
    // - if numbers of poles match                                 AND
    // - the 2 end-vertices of the common edge are nearly equal    AND
    // - the maximum distance between corresponding poles is in between 0.0 - 1.0
    if ( np0 == np1 && cnt == 2 && max_dst > 0.0 && max_dst < 1.0 )
    {
      ci$getevent( prompt    = "Copy Poles from Surface 1 to Surface 2 ? [Y/N]",
                   response  = &resp,
                   mask      = mask,
                   event     = &event,
                   stackable = 1 );

      if( resp == EX_STRING )
      {
        strcpy ( str, event.event.keyin );
        if ( str[0] == 'Y' || str[0] == 'y' )
        {
          post_info.construct_flag = FALSE;
          OMsts = ci$send ( msg = message GRvg.GRpostabsg ( &stat,
                                                            &MOD_ENV[1],
                                                            &post_info,
                                                            ( char * ) sf[1],
                                                            &NEW.objid ),
                            targetid = TEMP[1].objid,
                            targetos = TEMP[1].osnum );

          if ( max_dst > 0 )
            printf ( "<<<<< Number of poles       copied from sf[0] to sf[1] = %d\n", np0);

          if (VDmethod)
          {
            printf("Surface_ID[0]  = [%d,%d]\n", TEMP[0].osnum, TEMP[0].objid );
            printf("Surface_ID[1]  = [%d,%d]\n", TEMP[1].osnum, TEMP[1].objid );
            printf("Surface_ID NEW = [%d,%d], OMsts = %d, stat = %d\n", NEW.osnum, NEW.objid, OMsts, stat );
          }
        }
      }
    }

    del_GRid ( &npols[0], GRid_pols0, TEMP[0], MOD_ENV[0] );
    del_GRid ( &npols[1], GRid_pols1, TEMP[1], MOD_ENV[1] );

    if ( poles0 )
    {
      free(poles0);
      poles0 = NULL;
    }
    if ( poles1 )
    {
      free(poles1);
      poles1 = NULL;
    }
    if ( sf[0] )
    {
      free(sf[0]);
      sf[0] = NULL;
    }
    if ( sf[1] )
    {
      free(sf[1]);
      sf[1] = NULL;
    }
  }					/* end of while */

wrapup:

  if ( poles0 )
  {
    free(poles0);
    poles0 = NULL;
  }
  if ( poles1 )
  {
    free(poles1);
    poles1 = NULL;
  }
  if ( sf[0] )
  {
    free(sf[0]);
    sf[0] = NULL;
  }
  if ( sf[1] )
  {
    free(sf[1]);
    sf[1] = NULL;
  }

}					/* end of main */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

init ()
{
  IGRint           msg;

  init_cnst_list ();
  get_symb ();

  GRfindmod ( &display_info );

  strcpy  ( loc_mes, "Adjust Poles of Surface" );
  message ( loc_mes );

  dis.color      = cnst_list.color;
  dis.weight     = 3;
  dis.style      = cnst_list.style;

  cst.msg        = &msg;
  cst.properties = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display    = &dis;
  cst.env_info   = &MOD_ENV[0];
  cst.newflag    = FALSE;
  cst.level      = cnst_list.level;
  cst.geometry   = ( char * ) &geom;
  cst.class_attr = 0;
  cst.name       = 0;

  geom.points    = NULL;
  GRid_pols0     = NULL;
  GRid_pols1     = NULL;
  npols[0]       = 0;
  npols[1]       = 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

wakeup ()
{
  IGRint        i, msg, GRdpmode;
  IGRlong       OMsts;

  message ( loc_mes );

  if ( npols[0] != 0 )
  {
    GRdpmode = GRhd;

    for ( i = 0; i < npols[0]; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &MOD_ENV[0].md_env.matrix_type,
                                                  MOD_ENV[0].md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pols0[i].objid,
                        targetos = GRid_pols0[i].osnum );
    }
  }

  if ( npols[1] != 0 )
  {
    GRdpmode = GRhd;

    for ( i = 0; i < npols[1]; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &MOD_ENV[1].md_env.matrix_type,
                                                  MOD_ENV[1].md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pols1[i].objid,
                        targetos = GRid_pols1[i].osnum );
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

delete ()
{
  del_GRid ( &npols[0], GRid_pols0, TEMP[0], MOD_ENV[0] );
  del_GRid ( &npols[1], GRid_pols1, TEMP[1], MOD_ENV[1] );
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

sleep ()
{
  IGRint        i, msg, GRdpmode;
  IGRlong       OMsts;

  if ( npols[0] != 0 )
  {
    GRdpmode = GRbdhe;

    for ( i = 0; i < npols[0]; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &MOD_ENV[0].md_env.matrix_type,
                                                 MOD_ENV[0].md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pols0[i].objid,
                        targetos = GRid_pols0[i].osnum );
    }
  }
  if ( npols[1] != 0 )
  {
    GRdpmode = GRbdhe;

    for ( i = 0; i < npols[1]; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &MOD_ENV[1].md_env.matrix_type,
                                                  MOD_ENV[1].md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pols1[i].objid,
                        targetos = GRid_pols1[i].osnum );
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

del_GRid ( num_poles, GRid_pol, tmp_gr, modenv )

  IGRint                 *num_poles;
  struct GRid            *GRid_pol;
  struct GRid             tmp_gr;
  struct GRmd_env         modenv;

{
  IGRint        i, msg, GRdpmode;
  IGRlong       OMsts;

  if ( *num_poles != 0 )
  {
    GRdpmode = GRbehe;

    for ( i = 0; i < *num_poles; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &modenv.md_env.matrix_type,
                                                  modenv.md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pol[i].objid,
                        targetos = GRid_pol[i].osnum );

      ci$send ( msg = message GRgraphics.GRdelete ( &msg, &modenv ),
                targetid = GRid_pol[i].objid,
                targetos = GRid_pol[i].osnum );

    }
    *num_poles = 0;

    GRdpmode = GRbd;

    OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                               &msg,
                                               &modenv.md_env.matrix_type,
                                                modenv.md_env.matrix,
                                               &GRdpmode,
                                               &display_info ),
                      targetid = tmp_gr.objid,
                      targetos = tmp_gr.osnum );

    OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                               &msg,
                                               &modenv.md_env.matrix_type,
                                                modenv.md_env.matrix,
                                               &GRdpmode,
                                               &display_info ),
                      targetid = PREV.objid,
                      targetos = PREV.osnum );

    if ( GRid_pol )
    {
      free(GRid_pol);
      GRid_pol = NULL;
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

disp_sf_GRid ( bssf, trav, modenv, GRid_pols, cst )

  struct IGRbsp_surface  *bssf;
  IGRdouble              *trav;
  struct GRmd_env        *modenv;
  struct GRid            *GRid_pols;
  struct GRvg_construct  *cst;

{
  IGRint                  num_p;
  IGRint                  i, j, msg, GRdpmode;
  IGRlong                 OMsts;
  struct IGRpolyline      geom;

  geom.num_points = 1;
  cst->geometry = ( char * ) &geom;

  GRdpmode = GRhd;

  num_p = bssf->u_num_poles * bssf->v_num_poles;

  if ( bssf->rational == FALSE )
  {
    for ( i = 0; i < num_p; i = i + 1 )
    {
      j = 3 * i;
      trav[j+0] = bssf->poles[j+0];
      trav[j+1] = bssf->poles[j+1];
      trav[j+2] = bssf->poles[j+2];
    }
  }
  else
  {
    for ( i = 0; i < num_p; i = i + 1 )
    {
      j = 3 * i;
      trav[j+0] = bssf->poles[j+0] / bssf->weights[i];
      trav[j+1] = bssf->poles[j+1] / bssf->weights[i];
      trav[j+2] = bssf->poles[j+2] / bssf->weights[i];
    }
  }

  for ( i = 0; i < num_p; i = i + 1 )
  {
    j = 3 * i;
    geom.points = ( IGRdouble * ) & ( trav[j] );

    if (VDfunct) printf ( "geom.points[%d]= %lf %lf %lf\n", i, geom.points[0], geom.points[1], geom.points[2] );

    GRid_pols[i].objid = NULL_OBJID;
    GRid_pols[i].osnum = 2;

    OMsts = ci$send ( msg = message GR3dpoint.GRaltconstruct ( cst ),
                      targetid = GRid_pols[i].objid,
                      targetos = GRid_pols[i].osnum );

    OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                               &msg,
                                               &modenv->md_env.matrix_type,
                                                modenv->md_env.matrix,
                                               &GRdpmode,
                                               &display_info ),
                      targetid = GRid_pols[i].objid,
                      targetos = GRid_pols[i].osnum );
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

get_poles ( uv, unp, vnp, edgpols, poles )
  int     uv, unp, vnp;
  double *edgpols, *poles;
{
  int k, n, m;
  if ( uv == 1 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      edgpols[n]   = poles[n];
      edgpols[n+1] = poles[n+1];
      edgpols[n+2] = poles[n+2];
    }
  }
  else if ( uv == 2 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * unp * (vnp-1) + n;
      edgpols[n]   = poles[m];
      edgpols[n+1] = poles[m+1];
      edgpols[n+2] = poles[m+2];
    }
  }
  else if ( uv == 3 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * k * unp;
      edgpols[n]   = poles[m];
      edgpols[n+1] = poles[m+1];
      edgpols[n+2] = poles[m+2];
    }
  }
  else if ( uv == 4 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * ((k+1) * unp - 1);
      edgpols[n]   = poles[m];
      edgpols[n+1] = poles[m+1];
      edgpols[n+2] = poles[m+2];
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

set_poles ( uv, unp, vnp, edgpols, poles )
  int     uv, unp, vnp;
  double *edgpols, *poles;
{
  int k, n, m;
  if ( uv == 1 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      poles[n]   = edgpols[n]  ;
      poles[n+1] = edgpols[n+1];
      poles[n+2] = edgpols[n+2];
    }
  }
  else if ( uv == 2 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * unp * (vnp-1) + n;
      poles[m]   = edgpols[n]  ;
      poles[m+1] = edgpols[n+1];
      poles[m+2] = edgpols[n+2];
    }
  }
  else if ( uv == 3 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * k * unp;
      poles[m]   = edgpols[n]  ;
      poles[m+1] = edgpols[n+1];
      poles[m+2] = edgpols[n+2];
    }
  }
  else if ( uv == 4 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * ((k+1) * unp - 1);
      poles[m]   = edgpols[n]  ;
      poles[m+1] = edgpols[n+1];
      poles[m+2] = edgpols[n+2];
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

get_common_edge_info (    p_cnt,  p_np0,  p_np1, p_max, poles0, poles1, sf )
  IGRint                 *p_cnt, *p_np0, *p_np1;
  IGRdouble              *p_max, *poles0, *poles1;
  struct IGRbsp_surface  *sf[];
{
  IGRint         i, j, k, m, n;
  IGRint         idx0[4], idx1[4], uv[2];
  IGRint         uord0, vord0, unmp0, vnmp0, unmk0, vnmk0, nk0, nk1, revers;
  IGRint         uord1, vord1, unmp1, vnmp1, unmk1, vnmk1;
  IGRint         cnt, np0, np1;
  IGRlong        rc;
  IGRdouble      max_dst, dist, dst1, dst2, dst3, eps;
  IGRdouble      pt0[12], pt1[12];
  IGRdouble      upar[2], vpar[2];
  IGRdouble     *edgpol0, *edgpol1, *edgsav0, *edgrev0;

  eps     = 1e-3;

  cnt     = 0;
  max_dst = 0;

  upar[0] = 0.0;
  upar[1] = 1.0;
  vpar[0] = 0.0;
  vpar[1] = 1.0;

  uord0   = sf[0]->u_order;
  vord0   = sf[0]->v_order;
  unmp0   = sf[0]->u_num_poles;
  vnmp0   = sf[0]->v_num_poles;
  unmk0   = sf[0]->u_num_knots;
  vnmk0   = sf[0]->v_num_knots;

  uord1  = sf[1]->u_order;
  vord1  = sf[1]->v_order;
  unmp1  = sf[1]->u_num_poles;
  vnmp1  = sf[1]->v_num_poles;
  unmk1  = sf[1]->u_num_knots;
  vnmk1  = sf[1]->v_num_knots;

  *p_cnt = cnt;
  *p_np0 = np0;
  *p_np1 = np1;
  *p_max = max_dst;

  BSsfarrev0 ( &rc, sf[0], 2, upar, 2, vpar, pt0 ); if (BSERROR(rc)) goto wrapup;
  BSsfarrev0 ( &rc, sf[1], 2, upar, 2, vpar, pt1 ); if (BSERROR(rc)) goto wrapup;

  if (VDfunct)
  {
    for ( i=0; i < 12; i=i+3)
    {
      printf ( "BSsfarrev0: pt0[%d]= %lf %lf %lf\n", i/3, pt0[i], pt0[i+1], pt0[i+2] );
      printf ( "BSsfarrev0: pt1[%d]= %lf %lf %lf\n", i/3, pt1[i], pt1[i+1], pt1[i+2] );
    }
  }

  for ( i=0; i < 12; i=i+3)
  {
    for ( j=0; j < 12; j=j+3)
    {
      dist = BSdistptpt ( &rc, &pt0[i], &pt1[j] );

      if (VDfunct)
      {
        printf ( "i = %d, j = %d, cnt = %d, eps = %lf\n", i, j, cnt, dist );
      }
      if ( dist < eps )
      {
        idx0[cnt] = i;
        idx1[cnt] = j;
        if ( cnt > 0 )
        {
          if ( idx0[cnt] == idx0[cnt-1] || idx1[cnt] == idx1[cnt-1] )
          {
            continue;
          }
          if ( cnt > 1 )
          {
            if ( idx0[cnt] == idx0[cnt-2] || idx1[cnt] == idx1[cnt-2] )
            {
              continue;
            }
          }

          // Eliminate diagonal combinations: 0-9 or 3-6
          if ( idx0[cnt] == 0 && idx0[cnt-1] == 9 || idx0[cnt] == 9 && idx0[cnt-1] == 0 ||
               idx0[cnt] == 3 && idx0[cnt-1] == 6 || idx0[cnt] == 6 && idx0[cnt-1] == 3 ||
               idx1[cnt] == 0 && idx1[cnt-1] == 9 || idx1[cnt] == 9 && idx1[cnt-1] == 0 ||
               idx1[cnt] == 3 && idx1[cnt-1] == 6 || idx1[cnt] == 6 && idx1[cnt-1] == 3 )
          {
            continue;
          }
        }
        cnt = cnt + 1;
      }
    }
  }

  if (VDcomment)
  {
    for ( i=0; i < cnt; i=i+1)
    {
      {
        printf ( "idx0[%d] = %d, idx1[%d] = %d\n", i, idx0[i], i, idx1[i] );
      }
    }
  }

  if ( cnt != 2 ) 	// Need to fix this problem ?!?
    goto wrapup;

  uv[0] = 0;
  uv[1] = 0;
  for ( i=0; i < cnt; i=i+1)
  {
    j = idx0[i];
    k = idx1[i];

    if ( i == 0 )
    {
      m = idx0[i+1];
      n = idx1[i+1];

      if ( j == 0 && m == 3 || j == 3 && m == 0 )
      {
        uv[0] = 1;		// Case: V = 0
        np0 = unmp0;
        nk0 = unmk0;
      }
      else if ( j == 6 && m == 9 || j == 9 && m == 6 )
      {
        uv[0] = 2;		// Case: V = 1
        np0 = unmp0;
        nk0 = unmk0;
      }
      else if ( j == 0 && m == 6 || j == 6 && m == 0 )
      {
        uv[0] = 3;		// Case: U = 0
        np0 = vnmp0;
        nk0 = vnmk0;
      }
      else if ( j == 3 && m == 9 || j == 9 && m == 3 )
      {
        uv[0] = 4;		// Case: U = 1
        np0 = vnmp0;
        nk0 = vnmk0;
      }

      if ( k == 0 && n == 3 || k == 3 && n == 0 )
      {
        uv[1] = 1;		// Case: V = 0
        np1 = unmp1;
        nk1 = unmk1;
      }
      else if ( k == 6 && n == 9 || k == 9 && n == 6 )
      {
        uv[1] = 2;		// Case: V = 1
        np1 = unmp1;
        nk1 = unmk1;
      }
      else if ( k == 0 && n == 6 || k == 6 && n == 0 )
      {
        uv[1] = 3;		// Case: U = 0
        np1 = vnmp1;
        nk1 = vnmk1;
      }
      else if ( k == 3 && n == 9 || k == 9 && n == 3 )
      {
        uv[1] = 4;		// Case: U = 1
        np1 = vnmp1;
        nk1 = vnmk1;
      }

      if (VDcomment)
      {
        printf ( "Common pt0[%d]= %lf %lf %lf, dist = %lg\n", j/3, pt0[j], pt0[j+1], pt0[j+2], BSdistptpt ( &rc, &pt0[j], &pt1[k] ) );
        printf ( "Common pt1[%d]= %lf %lf %lf\n",             k/3, pt1[k], pt1[k+1], pt1[k+2] );
        printf ( "Common pt0[%d]= %lf %lf %lf, dist = %lg\n", m/3, pt0[m], pt0[m+1], pt0[m+2], BSdistptpt ( &rc, &pt0[m], &pt1[n] ) );
        printf ( "Common pt1[%d]= %lf %lf %lf\n",             n/3, pt1[n], pt1[n+1], pt1[n+2] );
        printf ( "Common UV edge: uv[0] = %d, uv[1] = %d\n", uv[0], uv[1] );
      }

      if ( uv[0] == 1 || uv[0] == 2 )		// Case: V = 0 (1st row) OR V = 1 (last row)
      {
        edgpol0 = ( IGRdouble * ) malloc ( unmp0 * 24 );
        get_poles ( uv[0], unmp0, vnmp0, edgpol0, poles0 );
      }
      else if ( uv[0] == 3 || uv[0] == 4 )	// Case: U = 0 (1st column) OR U = 1(last column)
      {
        edgpol0 = ( IGRdouble * ) malloc ( vnmp0 * 24 );
        get_poles ( uv[0], unmp0, vnmp0, edgpol0, poles0 );
      }

      if ( uv[1] == 1 || uv[1] == 2 )		// Case: V = 0 (1st row) OR V = 1 (last row)
      {
        edgpol1 = ( IGRdouble * ) malloc ( unmp1 * 24 );
        get_poles ( uv[1], unmp1, vnmp1, edgpol1, poles1 );
      }
      else if ( uv[1] == 3 || uv[1] == 4 )	// Case: U = 0 (1st column) OR U = 1(last column)
      {
        edgpol1 = ( IGRdouble * ) malloc ( vnmp1 * 24 );
        get_poles ( uv[1], unmp1, vnmp1, edgpol1, poles1 );
      }

      n = 3 * (np0 - 1);
      m = 3 * (np1 - 1);
      dist = BSdistptpt ( &rc, &edgpol0[0], &edgpol1[0] );
      dst1 = BSdistptpt ( &rc, &edgpol0[0], &edgpol1[m] );
      dst2 = BSdistptpt ( &rc, &edgpol0[n], &edgpol1[0] );
      dst3 = BSdistptpt ( &rc, &edgpol0[n], &edgpol1[m] );

      revers = 0;
      if ( ( dist > dst1 && dst3 > dst2 ) && ( dst1 < eps && dst2 < eps ) && np0 == np1 )	// Reversed edges !!!
      {
        if (VDcomment)
        {
          printf ( "edgpol0[0]=  %lf %lf %lf\n",        edgpol0[0],   edgpol0[1],   edgpol0[2] );
          printf ( "edgpol0[%d]= %lf %lf %lf\n", np0-1, edgpol0[n+0], edgpol0[n+1], edgpol0[n+2] );
          printf ( "edgpol1[0]=  %lf %lf %lf\n",        edgpol1[0],   edgpol1[1],   edgpol1[2] );
          printf ( "edgpol1[%d]= %lf %lf %lf\n", np1-1, edgpol1[m+0], edgpol1[m+1], edgpol1[m+2] );
          printf ( "dist = %lg, dst1 = %lg, dst2 = %lg, dst3 = %lg\n", dist, dst1, dst2, dst3 );
          printf ( "edgpol0[] & edgpol1[] are reversed\n" );
        }
        revers = 1;

        edgsav0 = ( IGRdouble * ) malloc ( np1 * 24 );
        edgrev0 = ( IGRdouble * ) malloc ( np1 * 24 );
        memcpy ( edgsav0, edgpol0, np1 * 24 );

        m = 3 * np1;
        for ( k = 0; k < np1; k = k + 1 )
        {
          n = 3 * k;
          m = m - 3;
          memcpy ( &edgrev0[n], &edgsav0[m], 24 );
          if (VDmethod)
          {
            dist = BSdistptpt ( &rc, &edgrev0[n], &edgpol0[n] );
            printf ( "edgrev0[%d]= %lf %lf %lf, n = %d, m = %d, dist = %lg\n", k, edgpol0[n+0], edgpol0[n+1], edgpol0[n+2], n, m, dist );
          }
        }
        memcpy ( edgpol0, edgrev0, np1 * 24 );	// edgpol0[] is now reversed !!!
      }

//      if (VDcomment)
      {
        max_dst = 0;
        for ( k = 0; k < np0; k = k + 1 )
        {
          m = 3 * k;
          dist = BSdistptpt ( &rc, &edgpol0[m], &edgpol1[m] );
          if ( dist > max_dst )
          {
            max_dst = dist;
          }
          printf ( "edgpol0[%d]= %lf %lf %lf, max_dst = %lg, dist = %lg\n", k, edgpol0[m+0], edgpol0[m+1], edgpol0[m+2], max_dst, dist );
        }
        if ( max_dst > 0 )
        {
          for ( k = 0; k < np1; k = k + 1 )
          {
            m = 3 * k;
            printf ( "edgpol1[%d]= %lf %lf %lf\n", k, edgpol1[m+0], edgpol1[m+1], edgpol1[m+2] );
          }
        }
      }

      // Print knot vectors
      if (VDmethod)
      {
        if ( uv[0] < 2 )
        {
          for ( k = 0; k < nk0; k = k + 1 )
          {
            printf ( "Surface[0] u_knots[%d] = %lf\n", k, sf[0]->u_knots[k] );
          }
        }
        else
        {
          for ( k = 0; k < nk0; k = k + 1 )
          {
            printf ( "Surface[0] v_knots[%d] = %lf\n", k, sf[0]->v_knots[k] );
          }
        }
        if ( uv[1] < 2 )
        {
          for ( k = 0; k < nk1; k = k + 1 )
          {
            printf ( "Surface[1] u_knots[%d] = %lf\n", k, sf[1]->u_knots[k] );
          }
        }
        else
        {
          for ( k = 0; k < nk1; k = k + 1 )
          {
            printf ( "Surface[1] v_knots[%d] = %lf\n", k, sf[1]->v_knots[k] );
          }
        }
      }

      if ( np0 == np1 && cnt == 2 )
      {
        // ===========================================
        // ***** Replace edpol1[] with edgpol0[] *****
        // ===========================================
        for ( k = 0; k < np0; k = k + 1 )
        {
          n = 3 * k;
          edgpol1[n+0] = edgpol0[n+0];
          edgpol1[n+1] = edgpol0[n+1];
          edgpol1[n+2] = edgpol0[n+2];
        }
        if ( max_dst > 0 && max_dst < 1.0 )
          printf ( ">>>>> Number of poles to be copied from sf[0] to sf[1] = %d\n", np0);

        set_poles ( uv[1], unmp1, vnmp1, edgpol1, poles1 );

        // Ignore rational for the time being ?!?!?
//        if ( sf[1]->rational == FALSE )
        {
          for ( k = 0; k < unmp1 * vnmp1; k = k + 1 )
          {
            n = 3 * k;
            sf[1]->poles[n+0] = poles1[n+0];
            sf[1]->poles[n+1] = poles1[n+1];
            sf[1]->poles[n+2] = poles1[n+2];
          }
        }
//          else
//          {
//            for ( k = 0; k < unmp1 * vnmp1; k = k + 1 )
//            {
//              n = 3 * k;
//              sf[1]->poles[n+0] = poles1[n+0] * sf[1]->weights[k];
//              sf[1]->poles[n+1] = poles1[n+1] * sf[1]->weights[k];
//              sf[1]->poles[n+2] = poles1[n+2] * sf[1]->weights[k];
//            }
//          }
      }
    }

    if ( edgpol0 )
    {
      free(edgpol0);
      edgpol0 = NULL;
    }
    if ( edgpol1 )
    {
      free(edgpol1);
      edgpol1 = NULL;
    }
    if ( edgsav0 )
    {
      free(edgsav0);
      edgsav0 = NULL;
    }
    if ( edgrev0 )
    {
      free(edgrev0);
      edgrev0 = NULL;
    }
  }

  *p_cnt   = cnt;
  *p_np0   = np0;
  *p_np1   = np1;
  *p_max   = max_dst;

wrapup:
  if ( edgpol0 )
  {
    free(edgpol0);
    edgpol0 = NULL;
  }
  if ( edgpol1 )
  {
    free(edgpol1);
    edgpol1 = NULL;
  }
  if ( edgsav0 )
  {
    free(edgsav0);
    edgsav0 = NULL;
  }
  if ( edgrev0 )
  {
    free(edgrev0);
    edgrev0 = NULL;
  }
}
