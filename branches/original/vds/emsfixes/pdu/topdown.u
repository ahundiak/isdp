/*
 *	All the #include directives, global variables definitions,
 *	extern function/variable declarations and macro definitions
 *	are pushed to the following file.
 */

#include "topdownhdr.h"

#include "go.h"
#include "grio.h"

extern		PALlocate_by_keyin();
extern		PALlocate_by_datapt();
extern		PDUverify_file();
extern		PDUtranslate_message();

/* TR# 139418100. 24/may/94 - raj.	*/
extern	FIf_is_displayed();

#include "tdlocate.h"

/* 13941 7706. */
int FileOpened;

main ()
{

  struct	GRid	*objects;
  IGRlong	num_obj;

  char		*checkin_save_catalog, *checkin_save_partid,
		*checkin_save_revision,	*checkin_save_filename,
		*checkin_save_description, *checkin_save_parttype;

  char		*PDU_save_act_catalog, *PDU_save_act_partid,
		*PDU_save_act_revision, *PDU_save_act_description,
		*PDU_save_act_filename;

  char		*current_catalog, *current_partid, *current_revision,
		*current_filename, *current_description, *current_parttype;


  int		total_part_count, part_index;

  /* 29/Dec/93 - raj.	TR# 13931 3235.	*/
  int		response;
		
  checkin_save_catalog	= NULL;
  checkin_save_partid	= NULL;
  checkin_save_revision	= NULL;
  checkin_save_filename	= NULL;
  checkin_save_description = NULL;
  checkin_save_parttype	= NULL;

  PDU_save_act_catalog	= NULL;
  PDU_save_act_partid	= NULL;
  PDU_save_act_revision	= NULL;
  PDU_save_act_description = NULL;
  PDU_save_act_filename	= NULL;

  current_catalog	= NULL;
  current_partid	= NULL;
  current_revision	= NULL;
  current_filename	= NULL;
  current_description	= NULL;
  current_parttype	= NULL;

  _pdm_debug ("Enter main () of topdown.u\n");

/*
 * #ifndef TEST
 */
  /* Erase design operations form.	*/
  if (forms.design_form_id){

        _pdm_debug("Deleting design form <%x>", forms.design_form_id);

        FIf_erase (forms.design_form_id);
//        FIf_delete (forms.design_form_id);
//        forms.design_form_id = 0;
  	PDU_design_form_display = FALSE;
  }


/*
 * #endif
 */

  /* Initialize poniters, set flags, e.t.c.,	*/
  TopDownInit ();

  ci$quiet();
  message (PDC_M_CREATE_TOP_DOWN);

  /* Get active module information */
  NumberOfBytes = sizeof(mod_env);
  sts = gr$get_module_env(
		msg = &msg,
		sizbuf = &NumberOfBytes,
		buffer = &active_mod_env,
		nret = &BytesReceived
		);

  /********************** SAVE REFRESH INFORMATION **************************/
  _pdm_debug("Saving refresh information", 0);

_pdm_debug ("What's the refresh info", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);


  PDUfill_in_string(&PDU_save_catalog, refresh->rev_catalog);
  PDUfill_in_string(&PDU_save_partid, refresh->rev_partid);
  PDUfill_in_string(&PDU_save_revision, refresh->rev_revision);
  PDUfill_in_string(&PDU_save_filename, refresh->rev_filename);

  if (refresh->rev_description != NULL) 
  {
      PDUfill_in_string(&PDU_save_description, refresh->rev_description);
  }
  else
  {
     PDUfill_in_string(&PDU_save_description, "");
  }


  PDUfill_in_string(&PDU_save_act_catalog, refresh->act_catalog);
  PDUfill_in_string(&PDU_save_act_partid, refresh->act_partid);
  PDUfill_in_string(&PDU_save_act_revision, refresh->act_revision);
  PDUfill_in_string(&PDU_save_act_filename, refresh->act_filename);

  if (refresh->act_description != NULL) 
  {
       PDUfill_in_string(&PDU_save_act_description, refresh->act_description);
  }
  else
  {
      PDUfill_in_string(&PDU_save_act_description, "");
  }

  /* clear out refresh fields */
  PDUfill_in_string(&refresh->rev_catalog,	"");
  PDUfill_in_string(&refresh->rev_partid,	"");
  PDUfill_in_string(&refresh->rev_revision,	"");
  PDUfill_in_string(&refresh->rev_description,	"");
  PDUfill_in_string(&refresh->rev_filename,	"");
  PDUfill_in_string(&refresh->rev_parttype,	"");


  /************************** BEGIN ADD PART ********************************/
  /*
   * This section of code prompts the user to add a part or identify an existing part.
  */

  _pdm_debug("prompting user for add part", 0);

create_topdown:

  message(PDP_P_PART_OPTION);

input_loop:

  prompt (PDP_P_ADD_PART);
  clear_input( confirm );

  ci$get(string = confirm);

  _pdm_debug("Confirm = <%s>", confirm);

  message("");

  if ( (strcmp(confirm, "Y") == 0) || (strcmp(confirm,"y") == 0) || 
       (strcmp(confirm,"") == 0))
  {
_pdm_debug ("Before Add Part", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);

     confirm[0] = 'Y';

  addpart:

     /* call the part form */
/*	29/Dec/93 - raj. TR# 13931 3235. Commented out following line.	*/
/*     add_part();			*/

/************************************************************************/
/*	29/Dec/93 - raj. TR# 13931 3235. Added code. BEGIN.		*/
     _pdm_debug("Entering the PDUpart_form function", 0);
     sts = PDUpart_form();

  process_add_part_form:

     /*  Pause the form to wait for user input  */
     do
     {
       ci$get(prompt = "", response = &response);
     }while((response != MOVE_ON) && (response != RESET));
     if (response == RESET)
     {
       pdu_check_exit();
     }

/*	29/Dec/93 - raj. TR# 13931 3235. Added code. END.		*/
/************************************************************************/

     _pdm_status("topdown add part", refresh->status);

     if ((refresh->status == PDM_I_FORM_CANCEL) ||
         (refresh->status != PDM_S_SUCCESS))
     {
       goto create_topdown;
     }

     if (refresh->status == PDM_S_SUCCESS)
     {
       _pdm_debug("beginning the add part command", 0);

       begincmd_key("PDAdPr");
       endcmd();

       _pdm_debug(" add part status = %d\n", refresh->status);

       if ( refresh->status != PDM_S_SUCCESS )
/*	29/Dec/93 - raj. TR# 13931 3235. Commented out following line.	*/
/*		goto create_topdown;					*/
/*					 Added following line.		*/
		goto process_add_part_form;
     }


     /* query for filenames */
     sts = PDMget_filenames(
		refresh->rev_catalog,
		refresh->rev_partid,
		refresh->rev_revision,
		&ret_bufr
                );

     _pdm_status("PDMget_filenames", sts);

     if ( sts != PDM_S_SUCCESS )
     {
       PDUmessage(sts, 's');
       MEMclose(&ret_bufr);
       refresh->status = sts;
       pdu_check_exit();
     }

     if ((ret_bufr == NULL) || (ret_bufr->rows == 0))
     {
       PDUmessage(PDM_I_NO_FILES_FOUND, 's');
       MEMclose(&ret_bufr);
       refresh->status = sts;
       pdu_check_exit();
     }

     MEMbuild_array(ret_bufr);

     _pdm_debug("Before PDUget_buffer_col", 0);

     PDUget_buffer_col(ret_bufr, "n_cofilename", &file_col);
     
     _pdm_debug("Before PDUsetup_buffer", 0);

     PDUsetup_buffer(ret_bufr, ROW, &data_row);

     PDUfill_in_string(&file, data_row[(ret_bufr->columns) * 0 + file_col]);

     if ((file != NULL) && (strcmp(file, "") != 0))
     {
       PDUfill_in_string(&refresh->rev_filename, file);
       _pdm_debug("refresh->rev_filename = <%s>", refresh->rev_filename);
     }

_pdm_debug ("After Add Part", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);


  }

  else if ( (strcmp(confirm,"N") == 0) || (strcmp(confirm,"n" ) == 0))
  {
     _pdm_debug("calling topdown form", 0);
      identify_part();
     _pdm_status("topdown identify part", refresh->status);

     if ((refresh->status == PDM_I_FORM_CANCEL) ||
         (refresh->status != PDM_S_SUCCESS))
       {
       goto create_topdown;
       }

     /*pdu_check_exit();*/
  }
  else 
  {
     goto input_loop;
  }

  /* Check to see if the file already exists. */

verify_filename:

  _pdm_debug("verifying filename", 0);

  message (PDC_M_CREATE_TOP_DOWN);

  sts = PDUverify_file (refresh->rev_filename);

  _pdm_status ("PDUverify_file", sts);
  
  if (sts == PDM_S_SUCCESS)	/* Part file exists.	*/ 
  {

      _pdm_debug (" <%s> is an existing file \n", refresh->rev_filename);

      /* No seed_file needed.	*/
      /* TBD - Where is seed_file freed?	*/
      if ((seed_file = (char *) malloc (3 * sizeof (char))) == NULL)
      {
		_pdm_debug ("Unable To Allocate Memory", 0);
		return (0);
      }

      strcpy (seed_file, "");

 }
 else				/* Part file does NOT exist.	*/
 {
_pdm_debug ("Before seedfile selection", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);

	if (!GetSeedfileSelection (&seed_file))
/*	20/Dec/93 - raj.		*/
/*		goto verify_filename;	*/
	{
	  _pdm_debug("GetSeedFileSelection() failed", 0);
	  goto input_loop;
        }

_pdm_debug ("After seedfile selection", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);
		/* TBD - Where is seed_file freed?	*/
 }
  /************************** END ADD_PART  *********************************/

  _pdm_debug ("Either Add Part Or Select Part", 0);
  PrintRefreshInfo ();
  _pdm_debug ("************************************************************", 0);

  _pdm_debug ("seed file name = <%s>\n", seed_file);

  /* Get id's of PDU GRparts */
  sts = PDUget_all_GRpart_ids(
                              active_mod_env.md_id.osnum,
                              &parts_ids,
                              &grpart_count
                             );
  _pdm_status("PDUget_all_GRpart_ids", sts);

  /* Get id's of PDU parametric parts */
  sts = PDUget_all_parametric_ids(
                                  active_mod_env.md_id.osnum,
                                  &parametric_ids,
                                  &parampart_count
                                 );
  _pdm_status("PDUget_all_parametric_ids", sts);

/*   printf ("Grparts + Parametric parts = %d + %d\n", grpart_count, parampart_count); */

  /********************** BEGIN IDENTIFY ELEMENTS ***************************/
  /*  This section of code prompts the user to select elements either by using
      a fence or individual selection.  */

  fence_prompt:
  message (PDC_M_CREATE_TOP_DOWN);

   option[0] = 'I';

   if (option[0] == 'I' || option[0] == 'i' )
   {
     /*
      * Turn LOCATE OFF for ALL the GRparts and Parametric parts. 

      if (!TurnOffGrpartsAndParametricParts ())
      	return (0);
      */

      if (!IdentifyObjectsNew (&objects, &num_obj))
	  return (0);

      if (!SaveElementsToFile (objects, &num_obj, refresh->rev_filename, seed_file))
      {
        status ("Save Element Command Failed");
        return (0);
      }
   }

  grpart_count = 0;
  parampart_count = 0;
  GetNumOfPDUGrpartsNParamparts (objects, num_obj, &active_mod_env, &parampart_count, &grpart_count);

  total_part_count = parampart_count + grpart_count;

/* printf ("total_part_count = parampart_count + grpart_count : %d = %d + %d\n", total_part_count, parampart_count, grpart_count); */

  option[0] = 'P';
  if (option[0] == 'P' || option[0] == 'p' )
  {
      if (total_part_count > 0)
      {
          /* Display message for user */
          sprintf(user_msg, "Pushing parts into %s", refresh->rev_filename);
          status(user_msg);

          /* Clear status field */
          _pdm_debug("Clear status field", 0);
          status("");
             
          /* Get active module information */
          _pdm_debug("get active module information", 0);
          NumberOfBytes = sizeof(mod_env);
          sts = gr$get_module_env(
                                  msg = &msg,
                                  sizbuf = &NumberOfBytes,
                                  buffer = &mod_env,
                                  nret = &BytesReceived
                                 );

          /* Construct file mount name */
          _pdm_debug("construct mount_name", 0);
          strcpy(mount_name, ":");
          strcat(mount_name, refresh->rev_filename);

          /* Get osnum of invis space */
          _pdm_debug("retrieve invisably", 0);
          sts = ex$retrieve_module (
                                    filename = refresh->rev_filename,
                                    file_no = &index,
                                    ftype = EX_invisible,
                                    flag = EX_overwrite,
                                    fstat = EX_default,
                                    type = EX_ACTINV,
                                    mount_name = mount_name,
                                    msg = &msg
                                   );

          if (!sts)
             {
              _pdm_debug("ex$retrieve_module failed on <%s>",
                         refresh->rev_filename);

              status("Failed to retrieve invisible file");

/*	      DispDgnOptsForm();*/
              exit;
             }

          /* Open object space */
          _pdm_debug("open invisably", 0);
          sts = ex$get_invis_info_by_index (
                                            index = index,
                                            mod_osnum = &newmod.osnum,
                                            mod_id = &newmod.objid,
                                            filed_id = &osid
                                           );

          if (!sts)
             {
              _pdm_debug("ex$get_invis_info_by_index failed on <%s>",
                         refresh->rev_filename);

              status("Failed to open invisible file");

/*	      DispDgnOptsForm();*/
              exit;
             }

	  /* 13941 7706.	*/
	  FileOpened = 1;

          mod_env.md_id.osnum = newmod.osnum;
          mod_env.md_id.objid = newmod.objid;

          /* Construct path to part directory */
          _pdm_debug("construct path to part dir", 0);
          di$give_pathname(
                           osnum = mod_env.md_id.osnum,
                           pathname = part_dir
                          );
      }

      _pdm_debug("before while head loop", 0);
      part_index = 0;
      while (part_index < total_part_count)
      {
          _pdm_debug("check for parametric or grpart", 0);
	  _pdm_debug("Part objid = %d\n", objects[part_index].objid);
	  _pdm_debug("Part osnum = %d\n", objects[part_index].osnum);
             /* Push parts into invisible file */ 
             if (PDUis_parametric_part(&objects[part_index]))
                {
                 _pdm_debug("pushing a parametric part to object space", 0);
		 
		 /* Save current refresh->rev_* information.	*/
		 SaveRefreshInfo (&current_catalog, &current_partid, &current_revision,
				&current_filename, &current_description, &current_parttype);

		 /* Get info from parametric part and update the refresh structure.	*/
		 /* This info needs to be available while making directory entries.	*/

		 GetParamPartRefreshInfo (&objects[part_index]);

		 /* Make the directory entries in the new file.	*/
		 MakeParamPartDirEntry (&active_mod_env, &mod_env);

		 /* Now that the entries are made restore refresh structure information.*/
		 RestoreRefreshInfo ( current_catalog, current_partid, current_revision,
					current_description, current_filename, current_parttype);

		 MyFree (current_catalog);
		 MyFree (current_partid);
		 MyFree (current_revision);
		 MyFree (current_filename);
		 MyFree (current_description);
		 MyFree (current_parttype);

                }

             else if (MYis_PDU_part (&objects[part_index], &active_mod_env))
                 {
                  _pdm_debug("pushing a GRpart to object space", 0);

		  /* Get values of ALL attributes of GRpart from design file. */
		  GetAllAttributeOfGRpart(&objects[part_index]);

                  /* Skip uniqueness attributes */
                  attributes = attributes + 4;
                  values = values + 4;
                  attribute_type = attribute_type + 4;
                  attribute_count = attribute_count - 4;

                  GRAPHIC = ( (strcmp(part_type, "G") == 0) ||
                              (strcmp(part_type, "g") == 0) ||
                              (strcmp(part_type, "D") == 0) ||
                              (strcmp(part_type, "d") == 0) ||
                              (strcmp(part_type, "P") == 0) ||
                              (strcmp(part_type, "p") == 0) );

                  POSITIONED = ( (strcmp(serial, "-1.000000") != 0) &&
                                 GRAPHIC );

                  ATTACHED = ( (strcmp(attach_flag, "-1.000000") != 0) &&
                               (strcmp(attach_flag, "-2.000000") != 0) &&
                               POSITIONED );

                    /* Get assembly structure of part */
                    sts = PDMget_assembly_structure(
                                                           catalog,
                                                           number,
                                                           revision,
                                                           MAX_LEVEL,
                                                           &part_asm_bufr
                                                          );
                    _pdm_status("PDMget_assembly_structure", sts);

/*
 * MEMprint_buffer ("part_asm_bufr", part_asm_bufr, PDU_DEBUG_FILE); 
 */                    
                    
                    if (part_asm_bufr == NULL)
                    {
                      _pdm_debug("SEVERE error:part_asm_bufr is empty", 0);

		      FreeLists ();
/*		      DispDgnOptsForm();*/
                      exit;
                    }

                    /* Add 1st-level assy part info only */
                    sts = PDUadd_assy_struct_from_buffer
                                                (
                                                 catalog,
                                                 number,
                                                 revision,
                                                 name,
                                                 quantity,
                                                 usage_id,
                                                 "",
                                                 mod_env.md_id.osnum,
                                                 child_no,
                                                 catno,
                                                 itemno,
                                                 part_asm_bufr,
                                                 1
                                                );
                    _pdm_status("PDUadd_assy_struct_from_buffer", sts);

                  if (ATTACHED)
                  {
                    _pdm_debug ("ATTACHED", 0);
PrintRefreshInfo ();
                      /* Get view name */
                      PDUfill_in_string(&PDU_viewname, view_name);
                      PDUunquote(PDU_viewname);

                      /* Check to see if background attachment */
                      if (strcmp(incl_asm, "N") == 0)
                         background = TRUE;

                      else
                          background = FALSE;

                      /* Get ref obj id from attach_flag */
                      sscanf(attach_flag, "%d", &tmprfid.objid);
                      tmprfid.osnum = active_mod_env.md_id.osnum;

                      if ( (strcmp(part_type, "D") == 0) ||
                           (strcmp(part_type,"d") == 0) )
                      {
                          /* Get ref file object id from drawing view */
                          stat = ci$send(
                                     msg = message GRdrawview.GRget_component_id
                                                               (
                                                                &msg,
                                                                selector,
                                                                1,
                                                                dv_refid,
                                                                id_type
                                                               ),
                                     targetid = tmprfid.objid,
                                     targetos = tmprfid.osnum
                                        );

                          tmprfid.objid = dv_refid[0].objid;
                          tmprfid.osnum = dv_refid[0].osnum;

                          _pdm_debug("tmprfid.objid = %d", tmprfid.objid);
                          _pdm_debug("tmprfid.osnum = %d", tmprfid.osnum);
                      }

                      /* Set ref. request */
                      ref_list[0].var = REFERENCE_FILE_NAME;
                      ref_list[0].var_ptr = ref_filename;
                      ref_list[0].num_requested = DI_PATH_MAX;
                      ref_list[1].var = END_REPORT_REQUEST;
                      pass_on = FALSE;
                      size = sizeof(DI_PATH_MAX);

                      /* Extract file name from ref. object */
                      sts = ci$send(
                                    msg = message GRreffile.GRinquireref
                                                           (
                                                            &msg,
                                                            &active_mod_env,
                                                            ref_list,
                                                            &size,
                                                            &pass_on,
                                                            NULL
                                                           ),
                                    targetid = tmprfid.objid,
                                    targetos = tmprfid.osnum
                                   );

                      _pdm_debug("extracted ref. file = <%s>", ref_filename);

                      PDUfill_in_string(&PDU_filename, ref_filename);
			
                      _pdm_debug("extracted ref. file PDU_filename = <%s>", PDU_filename);
                      _pdm_debug("refresh->rev_parttype = %s\n", refresh->rev_parttype);
                      
                      /* Check to see if attaching to a drawing part */
                      if ( (strcmp(refresh->rev_parttype, "D") == 0) ||
                           (strcmp(refresh->rev_parttype, "d") == 0) )
                      {
                            _pdm_debug("attaching a drawing part", 0);

                            /* Extract the origin of the part pointer */
                            sts = PDUmatrix_to_point (
                                                      matrix,
                                                      &origin_pt
                                                     );

                            /* Need to find x-axis point and y-axis points on
                               first alignment */
                            MAinvmx (
                                     &sts,
                                     &four,
                                     matrix,
                                     matrix
                                    );

                            stat = PDUadd_points (
                                                  matrix,
                                                  origin_pt,
                                                  &x_axis_pt,
                                                  0,
                                                  1,
                                                  2
                                                 );

                            sts = PDUadd_points (
                                                 matrix,
                                                 origin_pt,
                                                 &y_axis_pt,
                                                 4,
                                                 5,
                                                 6
                                                );

                            origin[0] = origin_pt.x;
                            origin[1] = origin_pt.y;
                            origin[2] = origin_pt.z;

                            x_point[0] = x_axis_pt.x;
                            x_point[1] = x_axis_pt.y;
                            x_point[2] = x_axis_pt.z;

                            y_point[0] = y_axis_pt.x;
                            y_point[1] = y_axis_pt.y;
                            y_point[2] = y_axis_pt.z;

                            /* Get coord. sys. rotation matrix */
                            sts = MA3protmx(
                                            &msg,
                                            origin,
                                            x_point,
                                            y_point,
                                            rot_matrix
                                           );

                           _pdm_debug("cs rotation matrix:", 0);
                           PDUdump_matrix(rot_matrix);

                           /* Attach drawing graphically */
                           sts = PDUattach_ref_to_GRpart(
                                                         part_id,
                                                         matrix,
                                                         mod_env,
                                                         catno,
                                                         itemno,
                                                         TRUE,
                                                         background,
                                                         rot_matrix,
                                                         origin,
                                                         &cs_id,
                                                         &refobjid
                                                        );
                            _pdm_status("PDUattach_ref_to_GRpart", sts);
                      }

                      else
                      {
                           _pdm_debug("attaching regular part graphically", 0);

				/*
				 * Alredy done by Save Element command.
				 */
                           /* Attach part graphically                            
*
*                           sts = PDUattach_ref_to_GRpart(
*                                                         part_id,
*                                                         matrix,
*                                                         mod_env,
*                                                         catno,
*                                                         itemno,
*                                                         FALSE,
*                                                         background,
*                                                         rot_matrix,
*                                                         origin,
*                                                         NULL,
*                                                         &refobjid
*                                                        );
*                           _pdm_status("PDUattach_ref_to_GRpart", sts);
*/
			    sts = PDM_S_SUCCESS;
                      }

                      if (sts != PDM_S_SUCCESS)
                      {
                          _pdm_debug("PDUattach_ref_to_GRpart failed", 0);

                          status("Part attachment failed");

                          /* Free values */
                          my_free_array(&values, attribute_count);

                          /* Free attributes */
                          my_free_array(&attributes, attribute_count);

                          /* Close invisible space */
                          sts = ex$close_module (
                                                 index = index,
                                                 flag = 0 | EX_ACTINV,
                                                 ftype = EX_invisible
                                                );
                          _pdm_status ("ex$close_module", sts);

	  		  /* 13941 7706.	*/
			  FileOpened = 0;

                          if (!sts)
                             {
                              _pdm_debug("ex$close_module failed", 0);

                              PDU_command = 0;

                              status("Close file failed");
                              exit;
                             }

			  FreeLists ();
/*			  DispDgnOptsForm();*/
                          exit;
                      }

                      if ( (strcmp(refresh->rev_parttype, "D") == 0) || 
                           (strcmp(refresh->rev_parttype, "d") == 0) )
                      {
                          /* Add disconnected coordinate system to GRpart */

                          _pdm_debug ("Add disconnected coordinate system to GRpart ", 0);

                          GRpart_objects[0].obj_id.objid = coord.objid;
                          GRpart_objects[0].obj_id.osnum = coord.osnum;
                          GRpart_objects[0].mod_env = mod_env;
                          own_index[0] = PDU_K_MAXINT;

                          sts = ci$send (
                                         msg = message GRowner.GRadd_components
                                                              (
                                                               &msg,
                                                               &mod_env,
                                                               &num_objects,
                                                               GRpart_objects,
                                                               own_index,
                                                               NULL
                                                              ),
                                         targetid = part_id.objid,
                                         targetos = part_id.osnum
                                        );
                      /* Need to update the attach flag in this GRpart */

                      _pdm_debug ("Need to update the attach flag in this GRpart %d", refobjid.objid);

                      sprintf(attr_value, "%d", refobjid.objid);
                      sts = co$part_put_attr (
                                              msg = &msg,
                                              mod_env = &mod_env,
                                              part = &part_id,
                                              attr = "attach_flag",
                                              value = attr_value,
                                              type = GR_DYNAMIC_ATTR
                                             );

                      }

                      /* Construct path to part assy structure */

                      _pdm_debug ("Construct path to part assy structure ", 0);

                      strcpy(assy_path, part_dir);
                      strcat(assy_path, ":ASSEMBLY:P");
                      strcat(assy_path, child_no);

                      _pdm_debug("part assy. path = <%s>", assy_path);

                      /* Update the part's attached flag in assy struct */

                      _pdm_debug ("Update the part's attached flag in assy struct", 0);

                      PDUmodify_exp(
                                    0,
                                    assy_path,
                                    "attached",
                                    "Y",
                                    mod_env.md_id.osnum
                                   );

                      /* Update the part's file_name in assy struct */

                      _pdm_debug ("Update the part's file_name in assy struct ", 0);

                      PDUmodify_exp(
                                    0,
                                    assy_path,
                                    "file_name",
                                    PDU_filename,
                                    mod_env.md_id.osnum
                                   );

                      /* Create ATTACH_INFO directory */

                      _pdm_debug ("Create ATTACH_INFO directory ", 0);

                      sprintf(part_no, "%s%s", "P", tag_no);
                      DIstmocpy(
                                attach_info_dir,
                                "ATTACH_INFO",
                                part_no,
                                "",
                                NULL,
                                mod_env.md_id.osnum
                               );

                      di$mkpath(pathname = attach_info_dir);

                      PDUstrip_dir_entry(attach_info_dir);

                      /* Create catalog no */

                      _pdm_debug ("Create catalog no ", 0);

                      PDUcreate_exp(
                                    TEXT,
                                    attach_info_dir,
                                    "catalog_no",
                                    catno,
                                    mod_env.md_id.osnum
                                   );

                      /* Create item no */

                      _pdm_debug ("Create item no ", 0);

                      PDUcreate_exp(
                                    TEXT,
                                    attach_info_dir,
                                    "item_no",
                                    itemno,
                                    mod_env.md_id.osnum
                                   );
                  }
                 } 

             /* Process next part */
	     part_index = part_index + 1;

      } /* end while loop */

      /* Save changes to invisible object space */

      _pdm_debug ("Save changes to invisible object space ", 0);

      if (grpart_count)
      { 
          /* Create a tag_no seed */
          PDUgenerate_tag_no(
                             &tag_seed,
                             active_mod_env.md_id.osnum
                            );

          strcpy(tag_dir, part_dir);
          strcat(tag_dir, ":PDU:tag_no:");
          strcat(tag_dir, tag_seed);
          strcat(tag_dir, ":");

          di$mkpath(pathname = tag_dir);

          /* Create a child_no seed */
          PDUgenerate_child_no(
                               &child_seed,
                               active_mod_env.md_id.osnum
                              );

          strcpy(child_dir, part_dir);
          strcat(child_dir, ":PDU:child_no:");
          strcat(child_dir, child_seed);
          strcat(child_dir, ":");

          di$mkpath(pathname = child_dir);

          /* Close and save invisible space */
          sts = ex$close_module (
                                 index = index,
                                 flag = 1 | EX_ACTINV,
                                 ftype = EX_invisible
                                );
          _pdm_status ("ex$close_module", sts);

	  		  /* 13941 7706.	*/
			  FileOpened = 0;

          if (!sts)
             {
              _pdm_debug("ex$close_module failed", 0);

              PDU_command = 0;

              status("Save file failed");
              exit;
             }
      }

      if (parampart_count)
      { 
          /* Close and save invisible space */
          sts = ex$close_module (
                                 index = index,
                                 flag = 1 | EX_ACTINV,
                                 ftype = EX_invisible
                                );
          _pdm_status ("ex$close_module", sts);

	  		  /* 13941 7706.	*/
			  FileOpened = 0;
          if (!sts)
             {
              _pdm_debug("ex$close_module failed", 0);

              PDU_command = 0;

              status("Save file failed");
              exit;
             }
      }
   }

  if (option[0] != 'I' && option[0] != 'i' && 
      option[0] != 'P' && option[0] != 'p') 
     {
      goto fence_prompt;
     }

  /*********************** END IDENTIFY ELEMENTS  ***************************/

  /**********************  CHECK OBJECT SPACE  ******************************/

  message (PDC_M_CREATE_TOP_DOWN);

  index = 0;
  osid = NULL_OBJID;

  /* Get active module information */
  NumberOfBytes = sizeof(mod_env);
  sts = gr$get_module_env(
                          msg = &msg,
                          sizbuf = &NumberOfBytes,
                          buffer = &mod_env,
                          nret = &BytesReceived
                         );

  /* Construct file mount name */
  strcpy(mount_name, ":");
  strcat(mount_name, refresh->rev_filename);

  /* Get osnum of invis space */
  sts = ex$retrieve_module (
                            filename = refresh->rev_filename,
                            file_no = &index,
                            ftype = EX_invisible,
                            flag = EX_overwrite,
                            fstat = EX_default,
                            type = EX_ACTINV,
                            mount_name = mount_name,
                            msg = &msg
                           );
  if (sts != 1)
     {
      _pdm_debug("SEVERE error: could not retrieve invis module", 0);

      PDU_command = 0;
      exit;
     }

  /* Open object space */
  sts = ex$get_invis_info_by_index (
                                    index = index,
                                    mod_osnum =&newmod.osnum,
                                    mod_id = &newmod.objid,
                                    filed_id = &osid
                                   );

  if (sts != 1)
     {
      _pdm_debug("SEVERE error: could not open invis module", 0);

      PDU_command = 0;
      exit;
     }

  /* 13941 7706. */
  FileOpened = 1;

  mod_env.md_id.osnum = newmod.osnum;
  mod_env.md_id.objid = newmod.objid;
  PDU_invis_newmod.osnum = newmod.osnum;
  PDU_invis_newmod.objid = newmod.objid;

  if (option[0] != 'P' && option[0] != 'p')
     {
      message (PDC_M_CREATE_TOP_DOWN);

	_pdm_debug ("      /* Check consistency between parts and assembly structure */");

      /* Check consistency between parts and assembly structure */
      sts = PDUremove_non_existent_parts_from_assy_struct(mod_env);
      _pdm_status("PDUremove_non_existent_parts_from_assy_struct", sts);

      /********************  CHECK FILE FOR ORIGINS ********************/
      /* If the user used a fence to select graphics from the active file,
         Open the file, check for an origin, and delete it if it exists. */

      sts = PDUdelete_origins(newmod.objid, newmod.osnum);
      _pdm_status("PDUdelete_origins", sts);

      /* Extarct all PDU saved view names from active obj space */
      sts = PDUload_view_info(
                              active_mod_env.md_id.objid,
                              active_mod_env.md_id.osnum,
                              &view_buffer
                             );
      _pdm_status("PDUload_view_info", sts);

      if (view_buffer)
         {
          sts = MEMbuild_array(view_buffer);
          _pdm_status("MEMbuild_array", sts);

          if (sts != MEM_S_SUCCESS)
             {
              sts = PDM_E_BUILD_BUFFER_ARRAY;
              PDUmessage(sts, 's');
              PDU_command = 0;
              exit;
             }

          PDUsetup_buffer(view_buffer, ROW, &data_row);
          PDUget_buffer_col(view_buffer, "p_viewname", &view_col);

          for (i = 0; i < view_buffer->rows; i = i + 1)
              {
               /* Delete PDU saved view in invisible space */
               sts = PDUdelete_svview(
                                  data_row[(view_buffer->columns*i)+view_col],
                                  &mod_env
                                     );
               _pdm_status("PDUdelete_svview", sts);
              }

          /* Close view buffer */
          MEMclose(&view_buffer);
         }

      /* Remove PDU_DESIGN_FILE stamp "directory", if any */
      sts = PDUremove_PDU_file_stamp(mod_env);
      _pdm_status("PDUremove_PDU_design_file_stamp", sts);

      /* Purge ATTACH_INFO directory */
      sts = PDUupdate_attach_info(
                                  mod_env,
                                  NULL
                                 );
      _pdm_status("PDUupdate_attach_info", sts);

      /* Construct path to part directory */
      di$give_pathname(
                       osnum = mod_env.md_id.osnum,
                       pathname = part_dir
                      );

      /* Remove "tag_no" directory value, if it exists */
      strcpy(tag_dir, part_dir);
      strcat(tag_dir, ":PDU:tag_no");

      di$find (
               start_dir = tag_dir,
               regexp = "*",
               lines = &entries,
               max_level = 1,
               ptr = &count
              );

      if (count > 0)
         {
          sts = PDUextract_dir_value(
                                     entries[0],
                                     "tag_no",
                                     &tag_no_value
                                    );

          strcat(tag_dir, ":");
          strcat(tag_dir, tag_no_value);
          strcat(tag_dir, ":");
 
          sts = PDUrmdir(tag_dir);
          /*
          sts = di$rmdir(dirname = tag_dir, path = NULL);
          */
          _pdm_status("di$rmdir", sts);
         }

      /* Remove the "tag_no" directory, if it exists */
      strcpy(tag_dir, part_dir);
      strcat(tag_dir, ":PDU:tag_no:");
 
      sts = PDUrmdir(tag_dir);
      /*
      sts = di$rmdir(dirname = tag_dir, path = NULL);
      */
      _pdm_status("di$rmdir", sts);

      /* Remove "child_no" directory value, if it exists */
      strcpy(child_dir, part_dir);
      strcat(child_dir, ":PDU:child_no");

      di$find (
               start_dir = child_dir,
               regexp = "*",
               lines = &entries,
               max_level = 1,
               ptr = &count
              );

      if (count > 0)
         {
          sts = PDUextract_dir_value(
                                     entries[0],
                                     "child_no",
                                     &child_no_value
                                    );

          strcat(child_dir, ":");
          strcat(child_dir, child_no_value);
          strcat(child_dir, ":");

          sts = PDUrmdir(child_dir);
          /*
          sts = di$rmdir(dirname = child_dir, path = NULL);
          */
          _pdm_status("di$rmdir", sts);
         }

      /* Remove the "child_no" directory, if it exists */
      strcpy(child_dir, part_dir);
      strcat(child_dir, ":PDU:child_no:");

      sts = PDUrmdir(child_dir);
      /*
      sts = di$rmdir(dirname = child_dir, path = NULL);
      */
      _pdm_status("di$rmdir", sts);

      /* Remove "mac_tag_no" directory value, if it exists */
      strcpy(tag_dir, part_dir);
      strcat(tag_dir, ":PDU:mac_tag_no");

      di$find (
               start_dir = tag_dir,
               regexp = "*",
               lines = &entries,
               max_level = 1,
               ptr = &count
              );

      if (count > 0)
         {
          for (i = 0; i < count; i = i + 1)
              {
               sts = PDUrmdir(entries[i]);
              }
         }

      /* Remove the "mac_tag_no" directory, if it exists */
      strcpy(tag_dir, part_dir);
      strcat(tag_dir, ":PDU:mac_tag_no:");

      sts = PDUrmdir(tag_dir);
      /*
      sts = di$rmdir(dirname = tag_dir, path = NULL);
      */
      _pdm_status("di$rmdir", sts);

      /* Free entries */
      if (entries)
         di$free(lines = entries, count = count);

      if (tag_no_value)
         free(tag_no_value);

      if (child_no_value)
         free(child_no_value);

      if (mac_tag_no_value)
         free(mac_tag_no_value);
     }

  /******************************  ORIGIN **********************************/
  /* This section of code prompts the user to define an origin or take the
     default origin. */ 

  origin_loop:
  message (PDC_M_CREATE_TOP_DOWN);
  prompt(PDP_P_DEFINE_OR_DEFAULT);
  clear_input( confirm );
  ci$get(string = confirm);

  if ( confirm[0] == 'U' || confirm[0] == 'u' )
     {
     origin:
     _pdm_debug("processing user_defined origin", 0);
     begincmd_key("PDDfIvOr");
     endcmd();
     pdu_check_exit ();
     }

  if ( confirm[0] == 'D' || confirm[0] == 'd' || confirm[0] == '\0')
     {
     confirm[0] = 'D';
     PDU_point[0] = 0.0;
     PDU_point[1] = 0.0;
     PDU_point[2] = 0.0;

     begincmd_key("PDDfIvOr");

     ci$put(string = "PDUtopdown");
     ci$put(point = PDU_point);

     endcmd();
     pdu_check_exit ();

     }
  if ( !(confirm[0] == 'U' || confirm[0] == 'u' ||
         confirm[0] == 'D' || confirm[0] == 'd' ) )
     {
     goto origin_loop;
     }

  /* Need to save close obj space */
  sts = ex$close_module (
                         index = index,
                         flag = 1 | EX_ACTINV,
                         ftype = EX_invisible
                        );
  _pdm_status ("ex$close_module", sts);

	  		  /* 13941 7706.	*/
			  FileOpened = 0;
  if (!sts)
     {
      _pdm_debug("ex$close_module failed", 0);
      
      PDU_command = 0;
      status("Save file failed");
      exit;
     }

  /************************************************************************/
  message (PDC_M_CREATE_TOP_DOWN);

  FreeLists ();

  /* Free values */
  my_free_array(&values, attribute_count);

  /* Free attributes */
  my_free_array(&attributes, attribute_count);

  /* Free buffers */
  if (part_asm_bufr)
     MEMclose(&part_asm_bufr);

_pdm_debug ("Before Checkin", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);


  SaveRefreshInfo (&checkin_save_catalog,&checkin_save_partid,
		&checkin_save_revision, &checkin_save_filename,
		&checkin_save_description, &checkin_save_parttype);


  /**************************************************************************/
  /* Prompt user to checkin part */

  checkin_loop:
  message (PDC_M_CREATE_TOP_DOWN);
  _pdm_debug("prompting user for checkin", 0);
  prompt (PDP_P_TOPDOWN_CHECKIN);
  clear_input( checkin );
  ci$get(string = checkin);
  if ( checkin[0] == 'Y' || checkin[0] == 'y' || checkin[0] == '\0' )
     {
     checkin[0] = 'Y';
     _pdm_debug("checking in topdown part", 0);
     get_part_spec("all");

     begincmd("check in part");
     endcmd();
     }

_pdm_debug ("After Check In", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);

  RestoreRefreshInfo (checkin_save_catalog,checkin_save_partid,
		checkin_save_revision, checkin_save_description,
		checkin_save_filename,checkin_save_parttype);


_pdm_debug ("After Check In - and Restore", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);

if ( refresh->status != PDM_S_SUCCESS )
{
	_pdm_debug ("Check In returns FAILURE", 0);
}

  if ( !(checkin[0] == 'Y' || checkin[0] == 'y' ||
         checkin[0] == 'N' || checkin[0] == 'n' ) )
     {
     goto checkin_loop;
     }

  pdu_check_exit();
  sts = PDM_S_SUCCESS;
  refresh->status = sts;

 /***************************************************************************/

   /* Prompt user to place and attach part if the part is checked in */

  if ( checkin[0] == 'Y' || checkin[0] == 'y' ) 
    {
    attach_loop:

    _pdm_debug("prompting for attach part graphics", 0);

    prompt (PDP_P_ATTACH_PART);
    clear_input( attach );
    ci$get(string = attach);
    if ( attach[0] == 'Y' || attach[0] == 'y' || attach[0] == '\0')
       {
       attach[0] = 'Y';
       _pdm_debug("setting flag for attach part to TRUE", 0);
       store_attach = PDU_attach;
       PDU_attach = TRUE;
       store_display = PDU_display_dyn_attr;
       PDU_display_dyn_attr = FALSE;

       /* Initialize PDU_usage_id */
        if (PDU_usage_id)
           {
            if (strlen(PDU_usage_id))
              free(PDU_usage_id);
            PDU_usage_id = NULL;
           }

_pdm_debug ("Before Attach", 0);
PrintRefreshInfo ();
_pdm_debug ("************************************************************", 0);

	_pdm_debug ("begincmd_key () for PDPPr", 0);

       begincmd_key("PDPPr");
                   ci$put(point = PDU_point);
       endcmd();

	_pdm_debug ("endcmd () for PDPPr", 0);

       PDU_display_dyn_attr = store_display;
       PDU_attach = store_attach;
       pdu_check_exit();
       }

     if ( attach[0] == 'N' || attach[0] == 'n')
       {
       _pdm_debug("setting flag for attach part to FALSE", 0);
       store_attach = PDU_attach;
       PDU_attach = FALSE;
       store_display = PDU_display_dyn_attr;
       PDU_display_dyn_attr = FALSE;

       /* Initialize PDU_usage_id */
        if (PDU_usage_id)
           {
            if (strlen(PDU_usage_id))
              free(PDU_usage_id);
            PDU_usage_id = NULL;
           }

	_pdm_debug ("begincmd_key () for PDPPr", 0);

       begincmd_key("PDPPr");
                   ci$put(point = PDU_point);
       endcmd();

	_pdm_debug ("endcmd () for PDPPr", 0);

       PDU_display_dyn_attr = store_display;
       PDU_attach = store_attach;

       pdu_check_exit();
       }

     if ( !(attach[0] == 'Y' || attach[0] == 'y' ||
           attach[0] == 'N' || attach[0] == 'n' ) )
       {
       goto attach_loop;
       }
     }

  if ( checkin[0] == 'N' || checkin[0] == 'n' )
    {
    _pdm_debug("setting flag for attach part to FALSE", 0);

    store_attach = PDU_attach;
    PDU_attach = FALSE;

    store_display = PDU_display_dyn_attr;
    PDU_display_dyn_attr = FALSE;

    /* Initialize PDU_usage_id */
    if (PDU_usage_id)
       {
        if (strlen(PDU_usage_id))
          free(PDU_usage_id);
        PDU_usage_id = NULL;
       }

	_pdm_debug ("begincmd_key () for PDPPr", 0);

    begincmd_key("PDPPr");
                ci$put(point = PDU_point);
    endcmd();

	_pdm_debug ("endcmd () for PDPPr", 0);

    PDU_display_dyn_attr = store_display;
    PDU_attach = store_attach;

    pdu_check_exit();
    }


  /* Restore refresh information */
  _pdm_debug("restoring refresh information", 0);
  PDUfill_in_string(&refresh->rev_catalog, PDU_save_catalog);
  PDUfill_in_string(&refresh->rev_partid, PDU_save_partid);
  PDUfill_in_string(&refresh->rev_revision, PDU_save_revision);
  PDUfill_in_string(&refresh->rev_description, PDU_save_description);
  PDUfill_in_string(&refresh->rev_filename, PDU_save_filename);

/*  DispDgnOptsForm();*/
  exit;
} /*  Close main program  */

  /*************************************************************************/


  /******************************* C Functions *****************************/

  /*  This function initializes certain variables. */

init ()
{
  strcpy(quantity, "1.0");
  strcpy(usage_id, "");
  strcpy(confirm, "NO");

  FENCE_ID = NULL_OBJID;
}


wakeup ()
{
  ci$quiet();
  message ( PDC_M_CREATE_TOP_DOWN );
  ci$get_module_info( md_env = &module_env );
}


delete ()
{

      int display; /* TR# 139418100. 24/may/94 - raj.	*/

      /* 28/Dec/93 - raj.	TR# 13931 2679.				*/
      /* Delete part operations form if comamnd is at Add Part stage.	*/
      if (forms.part_operations_form_id)
      {
	/* 24/may/94 - raj.	*/
	_pdm_debug("Deleting part operations form <%x>", forms.part_operations_form_id);
        FIf_erase (forms.part_operations_form_id);
        FIf_delete (forms.part_operations_form_id);
        forms.part_operations_form_id = 0;
      }

      if (FileOpened)
      {
      _pdm_debug("Closing open object space in delete()", 0);
      /* Need to save close obj space */
      sts = ex$close_module (
                         index = index,
                         flag = 1 | EX_ACTINV,
                         ftype = EX_invisible
                        );
      _pdm_status ("delete(): ex$close_module", sts);
      FileOpened = 0;
      }

      /* TR# 139418100. 24/may/94 - raj.	*/
      FIf_is_displayed(forms.design_form_id, &display);
      _pdm_debug("Is design operations form displayed = %d", display);
      if (!display)
      DispDgnOptsForm();
      exit;

}



/*  This function calls the PDUtopdown_form function, which prompts the user
    to key in a part.  - Mychelle Joiner, April 1991  */

int identify_part ()
{
  int   response;

  _pdm_debug("Entering the PDUtopdown_form function", 0);
  sts = PDUtopdown_form();

  /*  Pause the form to wait for user input  */
  ci$get(prompt = "", response = &response);
  if (response == MOVE_ON)
    {
    sts = PDM_S_SUCCESS;
    }
  else if (response == RESET)
    {
    pdu_check_exit();
    }
}

/*  This function checks the refresh form to see if the specified item is
    filled in.  If the item is blank, the user will be prompted to key it
    in, and the refresh form will be updated. */

get_part_spec (select)
  IGRchar  *select;
{
  part:
  sts = PDUverify_part ('r');
  _pdm_status ("PDUverify_part (review)", sts);

  if ( sts != PDM_S_SUCCESS )
     {
     if (select[0] != 'a' && (sts == PDM_E_PART_NULL || sts == PDM_E_REV_NULL))
	return;

     partspec:
     switch ( sts )
	{
	case PDM_E_CAT_NULL:
	     prompt (PDP_P_ENTER_CATALOG);
	     break;
	case PDM_E_PART_NULL:
	     prompt (PDP_P_ENTER_PART_ID);
	     break;
	case PDM_E_REV_NULL:
	     prompt (PDP_P_ENTER_PART_REV);
	     break;
	}

     clear_input( input_string );
     ci$get(string  = input_string);

     if ( strcmp(input_string,"") == 0 )
	{
	/*status( PDM_E_INVALID_INPUT );*/
	goto  partspec;
	}
     else
	{
        switch ( sts )
	   {
	   case PDM_E_CAT_NULL:
		sts = PDUverify_catalog(input_string);
		_pdm_status ("PDUverify_catalog", sts);

		if ( 1&sts )
		   {
		   PDUstrcpy(&refresh->rev_catalog, input_string);
		   }
		else
		   {
		   /*status( sts );*/
		   sts = PDM_E_CAT_NULL;
		   goto  partspec;
		   }
	        break;

	   case PDM_E_PART_NULL:
		   PDUstrcpy(&refresh->rev_partid, input_string);
		   PDUstrcpy(&refresh->rev_revision, "");
		   sts = PDM_E_REV_NULL;
		   goto  partspec;
	        break;

	   case PDM_E_REV_NULL:
		sts = PDUverify_element(refresh->rev_catalog,
					refresh->rev_partid,
					input_string);
		_pdm_status ("PDUverify_element (revision)", sts);

		if ( 1&sts )
		   {
		   PDUstrcpy(&refresh->rev_revision, input_string);
		   }
		else
		   {
		   status( sts );

		   sts = PDM_E_PART_NULL;
		   goto  partspec;
		   }
	        break;
	   }

	goto  part;
	}
     }
}


pdu_debug_point (string, point)
  IGRchar    *string;
  IGRdouble  point[3];
{
  if ( PDM_debug_on )
     {
     write("PDU -- ", string, " = ", point[0], point[1], point[2], "\n");
     }
}


get_view_name ()
{
  if ( (refresh->view == NULL) || (strcmp(refresh->view,"") == 0 ) )
     {
     view:
     prompt (PDP_P_PART_VIEW);			/* input view name */
     clear_input( input_string );
     ci$get(string  = input_string);

     if ( strcmp(input_string,"") == 0 )
	{
	status( PDM_E_INVALID_INPUT );
	goto  view;
	}
     else
	{
	PDUstrcpy(&refresh->view, input_string);
	}
     }
}


delete_obj (object_id)
  GRobj	object_id;
{
  mode = GRbehe;

  /* erase object */
  ci$send( msg = message GRgraphics.GRdisplay ( &sts, &(module_env.md_env.matrix_type),
						module_env.md_env.matrix, &mode,
						&(module_env.md_id) ),
	   targetid = object_id,
	   targetos = module_env.md_id.osnum );

  _pdm_status ("GRgraphics.GRdisplay", sts);

  /* delete object */
  ci$send( msg = message GRgraphics.GRdelete ( &sts, &module_env ),
	   targetid = object_id,
	   targetos = module_env.md_id.osnum );

  _pdm_status ("GRgraphics.GRdelete", sts);
}


/*  This function will cause the ppl program to be exited if the status
    is not PDM_S_SUCCESS.  */

pdu_check_exit ()
{
  _pdm_debug("In the function pdu_check_exit", 0);
  if ( refresh->status != PDM_S_SUCCESS )
     {
     status (refresh->status);
     PDUmessage(refresh->status, 's');
     _pdm_debug("Exiting topdown with errors", 0);
     PDUfill_in_string(&PDU_topdown_flag, "no");

     PDU_command = 0;

     PDUfill_in_string(&PDU_topdown_flag, "no");
  
     /* restore refresh information */
     _pdm_debug("restoring refresh information", 0);
     PDUfill_in_string(&refresh->rev_catalog, PDU_save_catalog);
     PDUfill_in_string(&refresh->rev_partid, PDU_save_partid);
     PDUfill_in_string(&refresh->rev_revision, PDU_save_revision);
     PDUfill_in_string(&refresh->rev_description, PDU_save_description);
     PDUfill_in_string(&refresh->rev_filename, PDU_save_filename);

     PDUdisplay_design_form();
     exit;
     }
   else
     {
     _pdm_status("pdu_check_exit", refresh->status);
     }
}


/*  This function sets the argument "string" to null. */


clear_input (string)
  IGRchar    *string;
{
  strcpy(string, "");
}


status_pause (message_key)
  IGRlong    message_key;
{
  status(message_key);
  sleep(3);
}

my_free_array(string_array, size)
  char ***string_array;
  int  size;
{
   int i;
  
   if (*string_array)
      { 
       for (i = 0; i < size; i = i + 1)
           {
            if ( ((*string_array)[i]) != NULL)
               free((*string_array)[i]);
           }

       *string_array = NULL;
      }  
}
 

SaveElementsToFile (objects, num_obj, filename, seedfile)
struct GRid       *objects;
IGRlong           *num_obj;
IGRchar           filename[32];
/* 25/jun/94 - raj.			*/
/* IGRchar		  seedfile[32]; */
IGRchar		  *seedfile;
{

/*
  Arguments

       IGRlong           *msg       (O)  Completion code
       struct GRmd_env   *mod_env   (I)  Module environment
       struct GRid       *objects   (I)  List of objects
       IGRlong           *num_obj   (I)  Number of objects
       IGRchar           *filename  (I)  Filename
       IGRchar           *seedfile  (I)  Seedfile name
       IGRboolean        *delete    (I)  Delete flag (TRUE/FALSE)

*/

       IGRlong           msg;
       struct GRmd_env   mod_env;
       IGRboolean        delete;
       IGRboolean        create;

	OMuword			classes[2], classid;
	OM_S_CLASSLIST		elig_classes;

	IGRlong sts;
	IGRint	ret_status;

	/* CR #:139424121. 06/sep/95 - raj. */
	IGRchar	confirm[5];
	
	_pdm_debug ("Enter SaveElementsToFile ()", 0);

	/* Get module environment.	*/
        ci$get_module_info ( md_env = &mod_env);

/*
 * CR #:139424121. 06/sep/95 - raj. Begin
 * Prompt user to leave/delete graphics identified for topdown, after save element.
 */
  prompt (PDP_P_DELETE_GRAPHICS);
  clear_input( confirm );

  ci$get(string = confirm);

  _pdm_debug("Delete graphics? = <%s>", confirm);

  message("");

  if ( (strcmp(confirm, "Y") == 0)
  	|| (strcmp(confirm,"y") == 0)
  	    || (strcmp(confirm,"") == 0))
   delete = TRUE;
  else
   delete = FALSE;
/*
 * CR #:139424121. 06/sep/95 - raj. End
 */

/* MJG - 11/13/95 - pass 0 for create */
        create = 0;
	sts = ASMSplitPart(&msg, &mod_env, objects, num_obj, filename,
				seedfile, &delete, &create);

	_pdm_debug ("ASMSplitPart() : sts = %ld", sts);
	_pdm_debug ("ASMSplitPart() : msg = %ld", msg);

	if (!(msg & 1))
	{
	  _pdm_debug ("Save Element Failed", 0);
          return (0);
        }
/*
	asm$save_element(msg = &msg,
			 objects = objects,
			 num_obj = &num_obj,
			 filename = filename);
*/
	_pdm_debug ("Exit SaveElementsToFile ()", 0);
	
	return (1);
}


GetSeedfileSelection (seedfile)
char	**seedfile;
{

	GRobjid	ppl_objid;
	int	response;
        char *cwd_dir,seedpath[80];

	char	*PDUseedform_save_catalog,*PDUseedform_save_partid,*PDUseedform_save_revision,
		*PDUseedform_save_filename,*PDUseedform_save_description, *PDUseedform_save_parttype;
		
	char	*PDUseedform_act_catalog,*PDUseedform_act_partid,*PDUseedform_act_revision,
		*PDUseedform_act_filename,*PDUseedform_act_description, *PDUseedform_act_parttype;
		
	SaveRefreshInfo (&PDUseedform_save_catalog,&PDUseedform_save_partid,
			&PDUseedform_save_revision, &PDUseedform_save_filename,
			&PDUseedform_save_description, &PDUseedform_save_parttype);

	SaveRefreshActInfo (&PDUseedform_act_catalog,&PDUseedform_act_partid,
			&PDUseedform_act_revision, &PDUseedform_act_filename,
			&PDUseedform_act_description, &PDUseedform_act_parttype);

	strcpy (topdown_seedfile_name, "");
	
/* 20/Dec/93 - raj.			*/
/*	DisplaySeedfileForm ();		*/
	if(!DisplaySeedfileForm ())
		goto wrapup;
	/*
	 * After the seed file form is accepted, the seed file name is
	 * stored in the global var 'topdown_seedfile_name'
	*/

	_pdm_debug ("Seed file selected is : <%s>\n", topdown_seedfile_name);

	/* Verify if file exists.	*/
	/* 
	 * Incase of default seed file option chosen by user,
	 * 'topdown_seedfile_name' contains NULL. In which case the following 
	 * function returns an unsuccessfull status.
	*/

	ret_status = PDUverify_file(topdown_seedfile_name);
	_pdm_status("PDUverify_file", ret_status);

	if (ret_status != PDM_S_SUCCESS)
	{
	  /*
	   * seed file was not selected. Get EMS default seed file name.
	   */
               /* ALR  Should use local seed_file if available */
                cwd_dir = (char *) PDUgetcwd((char *)NULL,64);
                sprintf(seedpath,"%s/seed_file",cwd_dir);
                _pdm_debug("Check for existance of %s \n",seedpath);
                ret_status = PDUverify_file(seedpath);
                if (ret_status == PDM_S_SUCCESS)
                {
                  *seedfile = (char *)malloc(sizeof(char) * (strlen(seedpath) +
1));
                  strcpy(*seedfile,seedpath);
                }
                else
	          if (!GetProductSeedFile (seedfile))
			return (0);
	}
	else
	{
	  /*
	   * seed file IS selected. Copy it into the function argument.
	   */
	  if ((*seedfile = (char *) malloc ((strlen (topdown_seedfile_name) + 1) * sizeof (char)))
	  	== NULL)
	  {
	  	  _pdm_debug ("Unable To Allocate Memory", 0);
	  	  return (0);
          }
          
          strcpy (*seedfile, topdown_seedfile_name);
	}

	_pdm_debug ("seed file is : <%s>\n", *seedfile);

	RestoreRefreshInfo ( PDUseedform_save_catalog, PDUseedform_save_partid,
				PDUseedform_save_revision, PDUseedform_save_description,
				PDUseedform_save_filename, PDUseedform_save_parttype);

	RestoreRefreshActInfo ( PDUseedform_act_catalog, PDUseedform_act_partid,
				PDUseedform_act_revision, PDUseedform_act_description,
				PDUseedform_act_filename, PDUseedform_act_parttype);
	
	MyFree (PDUseedform_save_catalog);
	MyFree (PDUseedform_save_partid);
	MyFree (PDUseedform_save_revision);
	MyFree (PDUseedform_save_description);
	MyFree (PDUseedform_save_filename);
	MyFree (PDUseedform_save_parttype);

	
	MyFree (PDUseedform_act_catalog);
	MyFree (PDUseedform_act_partid);
	MyFree (PDUseedform_act_revision);
	MyFree (PDUseedform_act_description);
	MyFree (PDUseedform_act_filename);
	MyFree (PDUseedform_act_parttype);

	return (1);

wrapup:

	RestoreRefreshInfo ( PDUseedform_save_catalog, PDUseedform_save_partid,
				PDUseedform_save_revision, PDUseedform_save_description,
				PDUseedform_save_filename, PDUseedform_save_parttype);	

	RestoreRefreshActInfo ( PDUseedform_act_catalog, PDUseedform_act_partid,
				PDUseedform_act_revision, PDUseedform_act_description,
				PDUseedform_act_filename, PDUseedform_act_parttype);
	
	MyFree (PDUseedform_save_catalog);
	MyFree (PDUseedform_save_partid);
	MyFree (PDUseedform_save_revision);
	MyFree (PDUseedform_save_description);
	MyFree (PDUseedform_save_filename);
	MyFree (PDUseedform_save_parttype);

	MyFree (PDUseedform_act_catalog);
	MyFree (PDUseedform_act_partid);
	MyFree (PDUseedform_act_revision);
	MyFree (PDUseedform_act_description);
	MyFree (PDUseedform_act_filename);
	MyFree (PDUseedform_act_parttype);

	return(0);
}

GetProductSeedFile (seedfile)
char	**seedfile;
{
	IGRint	ret_status;
	char	*tmp_seedfile;

	_pdm_debug ("Enter GetProductSeedFile ()", 0);

	/* Get product seed_file path */
	ret_status = PDUget_seed_file(&tmp_seedfile);
	if (ret_status != PDM_S_SUCCESS)
	{
	_pdm_debug("PDUget_seed_file failed", 0);
	return(ret_status);
	}

	/* Make sure the seed_file exists */
	ret_status = PDUverify_file(tmp_seedfile);
	_pdm_status("PDUverify_file", ret_status);

	if (ret_status != PDM_S_SUCCESS)
	{
		_pdm_debug("seed_file not found in running product", 0);
		return(ret_status);
	}

	*seedfile = (char *) malloc ((strlen(tmp_seedfile) + 1) * sizeof(char));
	if (*seedfile == NULL)
	{
          _pdm_debug ("Unable To Allocate Memory", 0);
          return (0);
        }
	strcpy (*seedfile, tmp_seedfile);

	_pdm_debug ("Exit GetProductSeedFile ()", 0);

	return (1);
}


int form_notification( )
{
  int     f_label;       /* The label of the form   */
  int     g_label;       /* The label of the gadget */
  double  value;         /* The value of the gadget */
  Form    fp;            /* Pointer to the form     */
/*
 * pid_t           child = 0;
 * short           delete_file = FALSE; 
 */  

  f_label = form_st.form_label;
  g_label = form_st.gadget_label;
  value = form_st.value;
  fp = form_st.form_ptr;


  /* Clear the message field at the bottom of the form. */
  FIg_set_text(forms.seed_form_form_id,FI_MSG_FIELD,"");

  PDU_list_filenames = FALSE;
  PDU_check_file_refresh = FALSE;
  PDU_form_id = fp;
  f_label = 0;
  value = 0;
  PDUmessage(PDM_E_CLEAR_FIELD, 's');


  switch ( g_label )
  {
    case FI_HELP:     /* Member of group FI_CTRL_GROUP */

         break;

    case FI_CVT_TO_PERM_WIN:     /* Member of group FI_CTRL_GROUP */

         break;

    case FI_CANCEL:     /* Member of group FI_CTRL_GROUP */

	PDUtopdown_cancel_seedfile_form ();
	ci$put (response = RESET);
         break;

    case FI_ACCEPT:     /* Member of group FI_CTRL_GROUP */

	PDUtopdown_accept_seed_file_form (fp, topdown_seedfile_name);
	ci$put (response = MOVE_ON);
         break;

    case SEED_FILE_TGL:     /* Sequenced to     */

	PDUtopdown_seed_file_toggle ();
         break;

    case NFC_CATALOG_FLD:     /* Member of group GROUP8  */
                             /* Field Type:    ASCII    */

	PDUtopdown_catalog_field (fp);
         break;

    case NFC_PART_FLD:     /* Member of group GROUP8  */
                             /* Sequenced to    */
                             /* Field Type:    ASCII    */
	PDUtopdown_part_field (fp);
         break;

    case NFC_REV_FLD:     /* Member of group GROUP8  */
                             /* Field Type:    ASCII    */

	PDUtopdown_revision_field (fp);
         break;

    case NFC_FILENAME_FLD:     /* Member of group GROUP8  */
                             /* Field Type:    ASCII    */


	PDUtopdown_filename_field (fp);
         break;

    case NFC_DESC_FLD:     /* Member of group GROUP8  */
                             /* Field Type:    ASCII    */

	PDUtopdown_desc_field (fp);
         break;

    case NFC_CATALOG_BTN:     /* Member of group GROUP8  */

	PDUtopdown_catalog_btn (fp);
         break;

    case NFC_PART_BTN:     /* Member of group GROUP8  */
                             /* Sequenced to    */

	PDUtopdown_part_btn (fp);
         break;

    case NFC_REV_BTN:     /* Member of group GROUP8  */
                             /* Sequenced to    */

	PDUtopdown_revision_btn (fp);
         break;

    case NFC_FILENAME_BTN:     /* Member of group GROUP8  */
                             /* Sequenced to    */

	PDUtopdown_filename_btn (fp);
         break;

    case NFC_SEARCH_BTN:     /* Member of group GROUP8  */
                             /* Sequenced to    */

	PDUtopdown_search_btn (fp);
         break;

  } /* END switch ( g_label ) */

return (1);

} /* END notification_routine() */

/* This function loads/creates, initializes, and displays the New File
   Creation Form (seed form) */

int PDUtopdown_seed_form()
{
	int  sts;

	_pdm_debug ("Enter PDUtopdown_seed_form()",0);

  topdown_seed_form_created = FALSE;
  topdown_seed_form_displayed = FALSE;

/* If SEED_FORM name is changed the actual form name in ../config/english/forms
   must be changed as well as in PDUform_def.h */

  if (sts = FIf_new(SEED_FORM, "seed_form", ci_notification, &forms.seed_form_form_id))
  {
	_pdm_debug ("Seed File Form creation error\n");
	return (0);
  };

  if ( sts = FIf_set_cmd_oid_os( forms.seed_form_form_id, MY_ID, OM_Gw_current_OS ) )
  {
	_pdm_debug( "Seed File Form : FIf_set_cmd_oid_os() Error\n",0);
	return( 0 );
  }

  _pdm_debug("Seed file form created %d", forms.seed_form_form_id);

  topdown_seed_form_created = TRUE;

  /* Call function to initialize the Part Operations Form */

  _pdm_debug("CALLING the function PDUtopdown_seed_form_init",0);
  PDUtopdown_seed_form_init();

  /* Display the seed_form form and set the displayed flag to TRUE. */
  _pdm_debug("Display the seed form",0);
  sts = FIf_display(forms.seed_form_form_id);
  topdown_seed_form_displayed = TRUE;
  PDU_form_id = forms.seed_form_form_id;

	_pdm_debug ("Exit PDUtopdown_seed_form()",0);

    return(sts);

}


DisplaySeedfileForm ()
{
	IGRint	ret_status;
	int   response;
	
	_pdm_debug ("Enter DisplaySeedfileForm ()", 0);

	/* Bring up seed file form. */
	ret_status = PDUtopdown_seed_form();

	_pdm_status("PDUseed_form", ret_status);

	/*  Pause the form to wait for user input  */
	do
	{
          ci$get(prompt = "", response = &response);
        }while(response != MOVE_ON && response != RESET);
	
	if (response == MOVE_ON)
	{
	  _pdm_debug ("Exit DisplaySeedfileForm () - 1 -", 0);  	
	  return (1);
	}
	else if (response == RESET)
	{
	  _pdm_debug ("Exit DisplaySeedfileForm () - 0 -", 0);  	
	  return (0);
    	}

	_pdm_debug("Some other response = %d", response);
/* 
* 	Let the notification routine finish.	
*	if ( ! WaitForEvent()  ) {
*		* Seed file form CANCELED.	*
*		return(0);
*	}
*
*	_pdm_debug ("Exit DisplaySeedfileForm ()", 0);
*
*	return (1);
*/

}

IdentifyObjects (objects, num_obj)
struct GRid       **objects;
IGRlong           *num_obj;
{
	int	response, owner_action, limit;
        char    *msg_str;

	_pdm_debug ("Enter IdentifyObjects ()", 0);

	limit = 16;
	if ((*objects = (struct GRid *) malloc (limit * sizeof (struct GRid))) == NULL)
	{
		status ("Unable To Allocate Memory");
		return (0);
	}

	/* Identify object.	*/
        owner_action = LC_FLEX_COMP | LC_RIGID_COMP  | LC_RIGID_OWNER ;

	*num_obj = -1;
	do
	{

		*num_obj = (*num_obj) + 1;

		if (*num_obj >= 16)
		{
			limit = limit + 16;
			/* Allocate for a larger array.	*/
			if ((*objects = (struct GRid *)
					realloc (*objects, (limit * sizeof (struct GRid)))) == NULL)
			{
				status ("Unable To Allocate Memory");
				return (0);
			}
		}

                msg_str = NULL;
                msg_str = (char *)PDUtranslate_message(PDP_P_LOCATE_PART_MOVE_ON);
		ci$locate(obj		= &(*objects)[*num_obj].objid,
			  osnum		= &(*objects)[*num_obj].osnum,
			  prompt	= msg_str, 
	                  owner_action	= owner_action,
	       		  response	= &response);
	} while (response != RESET);

        if((*num_obj) == 0)
        	return(0);

	_pdm_debug ("Exit IdentifyObjects ()", 0);

	return (1);
}

TurnOffGrpartsAndParametricParts ()
{
    if (grpart_count + parampart_count)
     {
      _pdm_debug("total parts found in os = %d", grpart_count + parampart_count);

      /* Turn locate off for all PDU GRparts */
      action = 0;
      props = GRIS_LOCATABLE;

      head = parts_ids;

      while (head)
            {
             sts = ci$send (
                            msg = message GRgraphics.GRchgprops (
                                                                 &msg,
                                                                 &action,
                                                                 &props
                                                                ),
                            targetid = head->part_id.objid,
                            targetos = head->part_id.osnum
                           );

             /* Process next part */
             head = head->next;
            }

      /* Turn locate off for all PDU parametric parts */
      head = parametric_ids;
      while (head)
            {
             sts = ci$send (
                            msg = message GRgraphics.GRchgprops (
                                                                 &msg,
                                                                 &action,
                                                                 &props
                                                                ),
                            targetid = head->part_id.objid,
                            targetos = head->part_id.osnum
                           );

             /* Process next part */
             head = head->next;
            }
     }
     
     return (1);
}

SaveRefreshInfo (current_catalog,current_partid,current_revision,
		current_filename,current_description, current_parttype)
char	**current_catalog,
	**current_partid,
	**current_revision,
	**current_filename,
	**current_description,
	**current_parttype;
{
  
  /********************** SAVE REFRESH INFORMATION **************************/

  _pdm_debug("Saving refresh information", 0);
  

  PDUfill_in_string(current_catalog, refresh->rev_catalog);
  PDUfill_in_string(current_partid, refresh->rev_partid);
  PDUfill_in_string(current_revision, refresh->rev_revision);
  PDUfill_in_string(current_filename, refresh->rev_filename);
  PDUfill_in_string(current_parttype, refresh->rev_parttype);

  if (refresh->rev_description != NULL) 
  {
       PDUfill_in_string(current_description, refresh->rev_description);
  }
  else
  {
      PDUfill_in_string(current_description, "");
  }
  
  return (1);
}



RestoreRefreshInfo ( saved_catalog, saved_partid, saved_revision,
					saved_description, saved_filename, saved_parttype)
char	*saved_catalog,
	*saved_partid,
	*saved_revision,
	*saved_description,
	*saved_filename,
	*saved_parttype;
{
  
  /* Restore refresh information */
  _pdm_debug("restoring refresh information", 0);
  PDUfill_in_string(&refresh->rev_catalog, saved_catalog);
  PDUfill_in_string(&refresh->rev_partid, saved_partid);
  PDUfill_in_string(&refresh->rev_revision, saved_revision);
  PDUfill_in_string(&refresh->rev_description, saved_description);
  PDUfill_in_string(&refresh->rev_filename, saved_filename);
  PDUfill_in_string(&refresh->rev_parttype, saved_parttype);

  return (1);
}

SaveRefreshActInfo (current_act_catalog,current_act_partid,current_act_revision,
		current_act_filename,current_act_description, current_act_parttype)
char	**current_act_catalog,
	**current_act_partid,
	**current_act_revision,
	**current_act_filename,
	**current_act_description,
	**current_act_parttype;
{					
  /********************** SAVE REFRESH ACTIVE INFORMATION **************************/

  _pdm_debug("Saving refresh active information", 0);
  
  PDUfill_in_string(current_act_catalog, refresh->act_catalog);
  PDUfill_in_string(current_act_partid, refresh->act_partid);
  PDUfill_in_string(current_act_revision, refresh->act_revision);
  PDUfill_in_string(current_act_filename, refresh->act_filename);
  PDUfill_in_string(current_act_parttype, refresh->act_parttype);

  if (refresh->act_description != NULL) 
  {
       PDUfill_in_string(current_act_description, refresh->act_description);
  }
  else
  {
      PDUfill_in_string(current_act_description, "");
  }

  return (1);
}


RestoreRefreshActInfo ( saved_act_catalog, saved_act_partid, saved_act_revision,
					saved_act_description, saved_act_filename, saved_act_parttype)
char	*saved_act_catalog,
	*saved_act_partid,
	*saved_act_revision,
	*saved_act_description,
	*saved_act_filename,
	*saved_act_parttype;
{
  
  /* Restore refresh active information */
  _pdm_debug("restoring refresh active information", 0);
  PDUfill_in_string(&refresh->act_catalog, saved_act_catalog);
  PDUfill_in_string(&refresh->act_partid, saved_act_partid);
  PDUfill_in_string(&refresh->act_revision, saved_act_revision);
  PDUfill_in_string(&refresh->act_description, saved_act_description);
  PDUfill_in_string(&refresh->act_filename, saved_act_filename);
  PDUfill_in_string(&refresh->act_parttype, saved_act_parttype);

  return (1);
}

PrintRefreshInfo ()
{

  _pdm_debug ("refresh->rev_catalog = <%s>", refresh->rev_catalog);
  _pdm_debug ("refresh->rev_partid = <%s>", refresh->rev_partid);
  _pdm_debug ("refresh->rev_revision = <%s>", refresh->rev_revision);
  _pdm_debug ("refresh->rev_description = <%s>", refresh->rev_description);
  _pdm_debug ("refresh->rev_filename = <%s>", refresh->rev_filename);
  _pdm_debug ("refresh->rev_parttype = <%s>", refresh->rev_parttype);
  
  _pdm_debug ("refresh->act_catalog = <%s>", refresh->act_catalog);
  _pdm_debug ("refresh->act_partid = <%s>", refresh->act_partid);
  _pdm_debug ("refresh->act_revision = <%s>", refresh->act_revision);
  _pdm_debug ("refresh->act_description = <%s>", refresh->act_description);
  _pdm_debug ("refresh->act_filename = <%s>", refresh->act_filename);
  _pdm_debug ("refresh->act_parttype = <%s>", refresh->act_parttype);

  return (1);
  
}

TopDownInit ()
{
  /* TR # 13931 2715 & 13931 3596.	30/Nov/93 - raj.	*/
/*  if (PDU_usage_id == NULL)
 *   _pdm_debug("PDU_usage_id is NULL", 0);
 * else if (strcmp(PDU_usage_id, "") == 0)
 *   _pdm_debug("PDU_usage_id is NULL", 0);
 * else
 *   PDUfill_in_string(&PDU_usage_id, NULL);
 */
  /* Initialize PDU_usage_id */
/* TR 139417695 - MJG added check for NULL_STRING to fix pointer message */
  if (PDU_usage_id)
  {
    if (strlen(PDU_usage_id))
      free(PDU_usage_id);
    PDU_usage_id = NULL;
  }

  /* 13941 7706. */
  FileOpened = 0;

  /* initialize pointers */
  file		= NULL;
  cwd		= NULL;
  delete_file	= NULL;
  windowname	= NULL;
  part_asm_bufr	= NULL;
  ret_bufr	= NULL;
  usageid	= NULL_STRING;

  parts_ids		= NULL;
  parametric_ids	= NULL;

  count			= 0;
  grpart_count		= 0;
  parampart_count	= 0;
  total_count		= 0;

  found		= 0;

  POSITIONED	= FALSE;
  ATTACHED	= FALSE;
  GRAPHIC	= FALSE;
 
  catno		= NULL;
  itemno	= NULL;

  four		= 4;
  num_objects	= 1;

  selector	= GR_DV_REFFILE;

  tag_seed	= NULL;
  child_seed	= NULL;
  view_buffer	= NULL;

  tag_no_value		= NULL;
  mac_tag_no_value	= NULL;
  child_no_value	= NULL;

  entries	= NULL;
  attributes	= NULL;
  values	= NULL;
  seed_file	= NULL;
  copyOS_path	= NULL;


  stat			= PDM_S_SUCCESS;
  PDU_topdown_flag	= NULL;
  PDU_command		= PDC_M_CREATE_TOP_DOWN;

  PDUfill_in_string(&PDU_topdown_flag, "yes");

}	/* End of TopDownInit()	*/


/* This function frees the linked lists used to hold the ids of parts.	*/

FreeLists ()
{
	/* Free PDU_parts_id_list */
	if (PDU_parts_id_list)
	{
		head = PDU_parts_id_list;

		while (PDU_parts_id_list)
		{
			PDU_parts_id_list = PDU_parts_id_list->next;
			free(head);
			head = PDU_parts_id_list;
		}

		PDU_parts_id_list = NULL; 
	}

	/* Free parts_ids list */
	if (parts_ids)
	{
		head = parts_ids;

		while (parts_ids)
		{
			parts_ids = parts_ids->next;
			free(head);
			head = parts_ids;
		}
	}

	/* Free parts_ids list */
	if (parametric_ids)
	{
		head = parametric_ids;

		while (parametric_ids)
		{
			parametric_ids = parametric_ids->next;
			free(head);
			head = parametric_ids;
		}
	}
}	/* End of FreeLists()	*/

GetAllAttributeOfGRpart(local_part_id)
struct	GRid	*local_part_id;
{
                  /* Extract part catalog */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "CATALOG",
                                    value = catalog,
                                    type = &type
                                   );

                  /* Extract part number */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "NUMBER",
                                    value = number,
                                    type = &type
                                   );

                  /* Extract part revision */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "REVISION",
                                    value = revision,
                                    type = &type
                                   );

                  /* Extract part name */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "NAME",
                                    value = name,
                                    type = &type
                                   );

                  /* Extract part type */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "part_type",
                                    value = part_type,
                                    type = &type
                                   );

                  /* Extract part serial no */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "serial",
                                    value = serial,
                                    type = &type
                                   );

                  /* Extract part attach flag */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "attach_flag",
                                    value = attach_flag,
                                    type = &type
                                   );

                  /* Extract part view name */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "view_name",
                                    value = view_name,
                                    type = &type
                                   );

                  /* Extract part usage id */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "usage_id",
                                    value = usage_id,
                                    type = &type
                                   );

                  PDUunquote(usage_id);

                  /* Extract part quantity */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "quantity",
                                    value = quantity,
                                    type = &type
                                   );

                  /* Extract incl_asm */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "incl_asm",
                                    value = incl_asm,
                                    type = &type
                                   );

                  /* Extract part child no */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "child_no",
                                    value = child_no,
                                    type = &type
                                   );

                  PDUunquote(child_no);

                  /* Extract part tag no */
                  co$part_get_attr (
                                    msg = &msg,
                                    mod_env = &active_mod_env,
                                    part = local_part_id,
                                    attr = "tag",
                                    value = tag_no,
                                    type = &type
                                   );

                  PDUunquote(tag_no);

                  /* Get catalog no and item no */
                  sts = PDMget_catno_partno(
                                            catalog,
                                            number,
                                            revision,
                                            &catno,
                                            &itemno
                                           );
                  _pdm_status("PDMget_catno_partno", sts);

                  /* Get GRpart attrs of part */
                  sts = PDUget_GRpart_all_attrs(
                                                active_mod_env,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &attributes,
                                                &values,
                                                &attribute_type,
                                                &attribute_count,
                                                local_part_id,
                                                0
                                               );
                  _pdm_status("PDUget_GRpart_all_attrs", sts);

                  if (PDM_debug_on)
                     {
                      /* Open debug file */
                      pdu_debug_file = fopen (PDU_DEBUG_FILE, "a");

                      for (i = 0; i < attribute_count; i = i + 1)
                          {
                           fprintf(
                                   pdu_debug_file,
                                   "PDU -- attributes[%d] = <%s> \n",
                                    i, attributes[i]
                                  );

                           fprintf(
                                   pdu_debug_file,
                                   "PDU -- values[%d] = <%s> \n",
                                   i,
                                   values[i]
                                  );

                           fprintf(
                                   pdu_debug_file,
                                   "PDU -- attribute_type[%d] = <%d>\n",
                                   i,
                                   attribute_type[i]
                                  );
                          }

                      /* Close debug file */
                      fclose(pdu_debug_file);
                     }

}	/* End of GetAllAttributeOfGRpart()	*/

GetNumOfPDUGrpartsNParamparts (objects, num_objets, mod_env, parampart_cnt, grpart_cnt)
struct	GRid		*objects;
int 			num_objets;
struct	GRmd_env	*mod_env;
int			*parampart_cnt, *grpart_cnt;
{
	int	ii;

	_pdm_debug ("Enter GetNumOfPDUGrpartsNParamparts ()", 0);

	for (ii = 0; ii < num_objects; ii = ii + 1)
	{
		_pdm_debug ("partid = %d %d\n", objects[ii].objid);
		if (PDUis_parametric_part(&objects[ii]))
		   {
			_pdm_debug ("Part is parmetric", 0);
			*parampart_cnt = *parampart_cnt + 1;
		   }
		else if (MYis_PDU_part (&objects[ii], mod_env))
		   {
			_pdm_debug ("Part is GRpart", 0);
			*grpart_cnt = *grpart_cnt + 1;
		   }
	}
 
	_pdm_debug ("Exit GetNumOfPDUGrpartsNParamparts ()", 0);

	return (1);            
}

MakeParamPartDirEntry (act_mod_env, new_mod_env)
struct	GRmd_env *act_mod_env, *new_mod_env;
{
	char	*pdu_tagno;

	pdu_tagno = NULL;

	PDUgenerate_tag_no (&pdu_tagno, act_mod_env->md_id.osnum);
	PDUupdate_parametric_tag(new_mod_env->md_id.osnum,pdu_tagno);
	PDUincrement_child_no(new_mod_env->md_id.osnum );

	MyFree (pdu_tagno);

	return (1);
}

GetParamPartRefreshInfo (parampart_id)
struct	GRid	*parampart_id;
{
	struct	GRid	mac_hdr, acdyncoll;
	struct	stemp	*temp_desc;
	int		num_temp, num_loc, num_coll, alloc_size;
	char		*cat_name, *part_id, *revnum;

	if( !GetMacroHeaderGivenGrid( *parampart_id, &mac_hdr ) )

	if (!GetOriginalMacroInfo (&mac_hdr, &temp_desc, &num_temp, &num_loc, num_coll))
		return (0);		

	/* TBD -  Free temp_desc from above ??? */

	/* The FIRST collection containing the catalog attributes	*/
	/* (that are not templates to the macro ) comes after the 	*/
	/* locatable templates and is at 'num_loc'eth position	*/
  	/* Fill with present parts info. */

	if (!get_acdyncol_temp(parampart_id, &acdyncoll, num_loc))
		return (0);

	_pdm_debug ("ACdyn_coll id : %d\n", acdyncoll.objid );


	alloc_size=20;
	cat_name = (char *) malloc (alloc_size * sizeof (char));
	cat_name[0] = '\0' ;

	if( !GetACrgAttribVal(&acdyncoll, "n_catalogname",&cat_name,
								&alloc_size))
		return(0);

	cat_name[strlen(cat_name)-1]= '\0';
	_pdm_debug("catalog name : %s", cat_name);

	alloc_size=20;
	part_id = (char *) malloc (alloc_size * sizeof (char));
	part_id[0] = '\0' ;

	if(!GetACrgAttribVal(&acdyncoll, "n_itemname",&part_id,&alloc_size))
		return(0);

	part_id[strlen(part_id)-1]= '\0' ;  

	alloc_size=20;
	revnum = (char *) malloc (alloc_size * sizeof (char));
	revnum[0] = '\0' ;

	if( !GetACrgAttribVal(&acdyncoll, "n_itemrev",&revnum,&alloc_size))
		return(0);

	revnum[strlen(revnum)-1]= '\0' ;


	PDUfill_in_string(&refresh->rev_catalog,	cat_name);
	PDUfill_in_string(&refresh->rev_partid,		part_id);
	PDUfill_in_string(&refresh->rev_revision,	revnum);
	PDUfill_in_string(&refresh->rev_description,	"");
	PDUfill_in_string(&refresh->rev_filename,	"");
	PDUfill_in_string(&refresh->rev_parttype,	"P");

	MyFree (cat_name);
	MyFree (part_id);
	MyFree (revnum);

	return (1);
}

/* 
 * This function checks to see if a GRpart is a PDU part.
 */
int  MYis_PDU_part (
                        part_id,
                        mod_env
                       )
 struct  GRid      *part_id;
 struct GRmd_env   *mod_env;
 {
  IGRlong    status;
  IGRlong    msg;
  IGRint     type;
  IGRchar    attr_value[MAX_VALUE];

  status = PDM_S_SUCCESS;

  _pdm_debug("In the MYis_PDU_part function", 0);

  /* Validate part pointer identity */
  status = co$part_get_attr (
                             msg = &msg,
                             mod_env = mod_env,
                             part = part_id,
                             attr = "attach_flag",
                             value = attr_value,
                             type = &type
                            );
/* printf ("status, msg & attr_value = %ld, %ld & %s\n", status, msg, attr_value); */

  if ( (msg != MSSUCC) || (strcmp(attr_value, "") == 0) )
      return(0);

  if (status & 1)
     return(1);
  else
     return (0);

 }



IdentifyObjectsNew (objects, num_obj)
struct GRid       **objects;
IGRlong           *num_obj;
{
int sts, msg, i, resp, owner_action, props, count;
OM_S_CLASSLIST elig_classes;
OMuword classes[2];
char mesg[512], temp[100];
struct GRid obj;
struct GRmd_env objenv;
int	ii;
char *msg_str;
char *msg_str2;

	_pdm_debug ("IN IdentifyObjectsNew ()", 0);

	*objects = NULL;
	*num_obj = 0;

        elig_classes.p_classes = classes;
        elig_classes.w_flags = OM_CLST_subclass;
        count = 1;

        props = LC_LC_ONLY | LC_DP_ONLY | LC_RW;

        owner_action =         LC_RIGID_OWNER | LC_RIGID_COMP |
                               LC_FLEX_COMP   | LC_FLEX_OWNER |
                               LC_REF_OBJECTS | LC_ASSOCIATIVE |
			       LC_EXTERN_CONSTRAINED ;

        msg_str = NULL;
        msg_str2 = NULL;
        msg_str = (char *)PDUtranslate_message(PDP_P_LOCATE_PART_MOVE_ON);
        msg_str2 = (char *)PDUtranslate_message(PDP_P_ACCEPT_PART);
        sts = td$locate( msg = msg, 
				locate_str = msg_str, 
                       		acc_str = msg_str2, 
                       		relocate_str = "Relocate Object", 
				locate_fence = TRUE,
/* TR# 139416284. Cycle flag is causing failure in displaying messages to
   the status strip.
				cycle_flag = TRUE,	*/
				cycle_flag = FALSE,
				response = resp, 
				obj_md_env = &objenv,
				objid = obj.objid, 
				osnum = obj.osnum,
				fence_objects = objects,
				num_fence_objects = num_obj);

	_pdm_debug("resp = %d", resp );
	_pdm_debug("objid = %d", obj.objid);
	_pdm_debug("osnum = %d", obj.osnum);

	if( resp == DATA || resp == SPECIFIED_OBJ )
	{
		if (*num_obj == 0)
		{
			*objects = (struct GRid *) malloc (1 * sizeof(struct GRid));
			if (*objects == NULL)
			{
				_pdm_debug ("Unable To Allocate Memory", 0);
				return (0);
			}
			(*objects)[0].objid = obj.objid;
			(*objects)[0].osnum = obj.osnum;
			*num_obj = 1;
		}
	}
	else if( resp == RESET || resp == D_RESET ) 
	{
		return (0);
	}
	else
		write("Unknown response during locate\n");

	for (ii = 0; ii < *num_obj; ii = ii + 1)
	{
		_pdm_debug ("Located Object.objid: %d", (*objects)[ii].objid);
		_pdm_debug ("Located Object.osnum: %d", (*objects)[ii].osnum);
	}

	return( 1 );
}

