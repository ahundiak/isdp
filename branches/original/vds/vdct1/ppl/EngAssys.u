
/***************************************************************************
 * I/VDS
 *
 * File:        vdct1/ppl/EngAssys.u
 *
 * Description: PPL for definition of Foundation Assemblies
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: EngAssys.u,v $
 *      Revision 1.2  2001/01/12 14:47:05  art
 *      sp merge
 *
# Revision 1.1  2000/04/20  18:46:32  pinnacle
# Created: vds/vdct1/ppl/EngAssys.u by pnoel for Service Pack
#
# Revision 1.3  2000/03/13  15:43:10  pinnacle
# ah
#
# Version: 1.0  2000/01/13  Initiation
# pn
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 02/25/00  pn      Creation
 * 
 * 
 ***************************************************************************/

#include "header.h"
#include "VDct1Attrs.h"
#include "VDfrm.h"

/* --------------------------------------------------
 * Activity Rules control
 * 
 * IGRstat          O -  ACTION_OK (0 or 1) 
 * TVDctBaseInfo    I/O  BASE_INFO
 * TVDctBaseInfo    I/O  BASE_INFO_PARENT
 * IGRchar          I -  LOCATION       The calling location or action sets rules 
 *
 */

// external functions
extern VDSverify_login();
extern GRconfirm_box();
extern VDnotify_box();


// ------------------------------------

IGRstat pplNodeRulesOK()
{ 
  IGRstat retFlag;

  retFlag = 1;

  // put rules for universal application here

  // location checks
  // -------------------  Rename Rules -----------------------------------
  // is renaming allowed for this item?
  if (!strcmp(LOCATION,VDCT1_ACTION_RENAME_NODE)) {

    // Rule:

    goto wrapup;
  }

  // ------------------- Duplicate Rename Rules --------------------------
  // duplicate Rename names prevented?
  if (!strcmp(LOCATION,VDCT1_ACTION_R_NODE_DUP)) {

    // Rule: 
    
    goto wrapup;
  }

  // ------------------ Deletion Rules -----------------------------------
  // do we delete?  uses BASE_INFO_PARENT only 
  if (!strcmp(LOCATION,VDCT1_ACTION_DELETE_NODE)) {

    // Rule: 

    goto wrapup;

  }  

  // ----------------- Creation of Duplicate Node Rules ------------------
  // do we test for duplicates in Create Node?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_NODE_DUP)) {

    // Rule:

    goto wrapup;
  } 

  // ----------------- Model Node Creation Rules ------------------------
  // do we test for duplicates in CreateModelNode?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_MODEL_NODE)) {
   
    // Rule: 
    goto wrapup;
  }

  // ----------------- Model Node Creation Attr Rules -----------------
  // do we create this node?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_MODEL_ATTRS)) { 
    
    // Rule: 

    }
    goto wrapup;
  

wrapup:
  // lets send back the baseInfo 
  ACTION_OK = retFlag;
  
  return retFlag;
}

/* --------------------------------------------------
 * I - NODE_PARENT_ID  (of ParentID)
 * I - PIECE_OE   (of *modelOE) 
 * O - NODE_TYPE  (of *nodeType)
 */


  
IGRstat getTypeForModelObject()
 {
   IGRint retFlag;           
   retFlag = 0;
// currently a no-op 
    retFlag = 1;
  
wrapup:

  return retFlag;
  
}

/* --------------------------------------------------
 * Validate child type
 * I - NODE_PARENT_ID (of the parent)
 * I - BASE_INFO (of the parent)
 * I - NODE_TYPE (of child)
 */
IGRstat isChildTypeValid()
{
  
  IGRstat retFlag;
  IGRstat traceFlag;
  
  IGRint sts;
  
  IGRchar        *parentType,*childType;
  IGRchar        *buf;
  
  // Init
  retFlag   = 1;
  traceFlag = 0;
  
  // set up data types to same type
  parentType = BASE_INFO.nodeType;
  childType  = NODE_TYPE;
  
  /*
   * Rules management for valid Child types 
   * Tells if making a certain type of node is acceptable
   * This logically says no except for exceptions which are sent to wrapup
   * Built this way to be easy to understand and alter quickly.
   */

   if (traceFlag) 
     printf(">>> isChildTypeValid\nParent Node Type %s \nChild Node Type %s\n",
	  parentType,childType);

   // Test for valid childType for GROUP parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_GROUP)){
     // OK ASSY2, ASSY6, ENGASSY, PARTS
     printf("Testing isChildTypeValid GROUP\n");
     
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_GROUP))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY6))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))   goto wrapup;
   }
   
   // Test for valid childType for ASSY2 parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ASSY2)){
     // OK ASSY2, ENGASSY, PARTS, PART
     printf("Testing isChildTypeValid ASSY2\n");
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))    goto wrapup;
   }

   // Test for valid childType for ASSY6 parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ASSY6)){
     // OK ASSY2, ASSY6, ENGASSY, PARTS, PART
     printf("Testing isChildTypeValid ASSY6^\n");
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY6))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))    goto wrapup;
   }
   
   // Test for valid childType for ENGASSY parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ENGASSY)){
     // OK ASSY2, ASSY6, ENGASSY, PARTS, PART
     printf("Testing isChildTypeValid ENGASSY\n");
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY6))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))    goto wrapup;
   }

   // Test for valid childType for PARTS parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ASSY6)){
     // OK ASSY2, PART
     printf("Testing isChildTypeValid ASSY^\n");
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))    goto wrapup;
   }

   //Test for valid childType for PART parentType (no valid types)

    // no acceptable conditions found!
  retFlag = 0;
  
// oh well  
wrapup:
  if (traceFlag)printf("<<< isChildTypeValid ,%d \n\n",retFlag);
  return retFlag;
}

/* --------------------------------------------------
 * Initialize the qty to 1
 */
IGRstat computeNodePartQty()
{
  IGRstat retFlag;
  IGRstat sts;
  
  TVDfld        qtyFld;
  IGRdouble     cutLen;
  TVDctBaseInfo baseInfo;
  // Init
  retFlag = 0;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_QTY, fld = &qtyFld);
  if (*qtyFld.name == 0) goto wrapup;
  strcpy(qtyFld.val.txt,"1");

  // Make sure have model object
  if (PIECE_OE.obj_id.objid == NULL_OBJID) goto wrapup;
  
  // Based on type
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSbeam");
  if (sts & 1) {
    cutLen = 0.0;
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name  = VDCT1_ISDP_ATTR_CUT_LENGTH,
		   dbl   = &cutLen);
    sprintf(qtyFld.val.txt,"%.2f",cutLen / 1000.0);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &qtyFld);
    retFlag = 1;
    goto wrapup;
  }
  printf("%s Field Val.txt\n\n",qtyFld.val.txt);
  
      
  // Update
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &qtyFld);
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

extern VDstrupr();

/*********************************************************************
 *  Compute the mino_isdp
 */
IGRstat computeNodePartMinoISDP()
{
  IGRstat     retFlag;
  IGRstat     sts;
  
  TVDfld      fld;
  IGRchar     partNum[128];     //beam pat_num
  IGRchar     matlGrade[128];   //plate or beam grade
  IGRchar     equipPartNum[128];    //equipment eqp_partnum
  IGRdouble   plateThk;    //plate thickness
  
  IGRchar     minoISDP[256]; 
  
  //init
  retFlag = 0;
  *partNum = 0;
  *matlGrade = 0;
  *minoISDP = 0;
  plateThk = 0.0;
  

  //check to see if we have an object
  if (PIECE_OE.obj_id.objid == NULL_OBJID) {
    retFlag = 1;
    goto wrapup;
  }
 

    // compute for Equipment
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VDequipment");
  
  if (sts & 1) {
    // get the eqp_partno
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_EQP_PARTNO,
		   txt = equipPartNum);

    // set equipment minoISDP
    strcat(minoISDP,equipPartNum);
    

    // update on tree
        vdcol$GetAttr(objID = &NODE_ID,
		  name = VDCT1_ATTR_MINO_ISDP,
		  fld = &fld);

    if (*fld.name) {
      strcpy(fld.val.txt,minoISDP);
      vdcol$UpdAttrs(objID = &NODE_ID,
		    cnt = 1,
		    fld = &fld);

    }
    }
  
  //compute for a beam
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSbeam");
  if (sts & 1) {
    strcpy(minoISDP,"BM ");
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_GRADE,
		   txt = matlGrade);
    strcat(minoISDP,matlGrade);
    strcat(minoISDP," ");
    // minoISDP should now equal BM GRADE
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_PART_NUM,
		   txt = partNum);
    strcat(minoISDP,partNum);
    // minoISDP is complete for beam

    // update on tree
    vdcol$GetAttr(objID = &NODE_ID,
		  name = VDCT1_ATTR_MINO_ISDP,
		  fld = &fld);
    if (*fld.name) {
      strcpy(fld.val.txt,minoISDP);
      vdcol$UpdAttrs(objID = &NODE_ID,
		    cnt = 1,
		    fld = &fld);
    }
    retFlag = 1;
    goto wrapup;
  }
  // compute for a plate
  printf("Testing for a plate\n");
  
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSplate");
  if (sts & 1) {
    //strcpy(minoISDP,"PL ");
    
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_GRADE,
		   txt = matlGrade);
    //strcat(minoISDP,matlGrade);
    //strcat(minoISDP," ");
    // minoISDP should now equal PL GRADE
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_PLATE_THK,
		   dbl = &plateThk);
    
    //strcat(minoISDP,plateThk);
    sprintf(minoISDP,"PL %s %.1f",matlGrade,plateThk);
    

    // minoISDP is complete for plate

    // update on tree
    vdcol$GetAttr(objID = &NODE_ID,
		  name = VDCT1_ATTR_MINO_ISDP,
		  fld = &fld);
    if (*fld.name) {
      strcpy(fld.val.txt,minoISDP);
      vdcol$UpdAttrs(objID = &NODE_ID,
		    cnt = 1,
		    fld = &fld);
    }
  
  
    retFlag = 1;
    goto wrapup;
  }

wrapup:
  return retFlag;
  
}

/* -------------------------------------------------
 * Compute a part node
 */
IGRstat computeNodePart()
{
  IGRstat retFlag;
  IGRstat sts;
  IGRchar buf[256],tmp[256];
  IGRchar partEquipNo[256];
  IGRchar unitEquipNo[256];
  TGRid   parentID, nodeID;
  TGRobj_env  parentOE;
  TVDctBaseInfo baseInfo;
  
  TVDfld  fld;
  
  // Init
  retFlag = 0;

  // Make sure got a model object
  if (PIECE_OE.obj_id.objid == NULL_OBJID) {
    retFlag = 1;
    goto wrapup;
  }

  
#if 0    
 //compute for a beam the Unit Number OK, CS
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSbeam");  
  if (sts & 1){ 
    // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  }
  
  // compute for Equipment
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VDequipment");
  if (sts & 1) {
    // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  }
  
  // compute for Plate
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSplate");
  if (sts & 1) {
    // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  }
#endif 

  // Build the isdp_name
  *buf = 0;
  vdsa$GetStruct(objOE = &PIECE_OE, name = VDCT1_ISDP_ATTR_EQP_FAMILY,  txt = tmp);
  strcpy(buf,tmp);
  strcat(buf,":");
  vdsa$GetStruct(objOE = &PIECE_OE, name = VDCT1_ISDP_ATTR_EQP_PARTNO,  txt = tmp);
  strcat(buf,tmp);
  strcat(buf,":");
  vdsa$GetStruct(objOE = &PIECE_OE, name = VDCT1_ISDP_ATTR_EQP_PARTREV, txt = tmp);
  strcat(buf,tmp);
  strcat(buf,":");
  vdobj$Get(objOE = &PIECE_OE, objName = tmp);
  strcat(buf,tmp);
  
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ISDP_NAME, fld = &fld);
  if (*fld.name) {
    VDstrupr(buf);
    strcpy(fld.val.txt,buf);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);
  }
  
  // Add the path
  vdobj$Get(objOE = &PIECE_OE, objPath = tmp);
  
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ISDP_PATH, fld = &fld);
  if (*fld.name) {
    VDstrupr(tmp);
    strcpy(fld.val.txt,tmp);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);
  }
  
  // Other attributes
  VDct1CopyAttributeFromModelToNode(&NODE_ID,
				    VDCT1_ATTR_UNIT,
				    &PIECE_OE,
				    VDCT1_ISDP_ATTR_UNIT);

  // VDct1CopyAttributeFromModelToNode(&NODE_ID,
  //    VDCT1_ATTR_COMPARTMENT,
				      //    &PIECE_OE,
  //    VDCT1_ISDP_ATTR_COMPARTMENT);



  // Pull zone from 
  sprintf(buf,"%s:%s:%s:%s:",
	  BASE_INFO.setType,
	  BASE_INFO.setName,
	  BASE_INFO.nodeType,
	  BASE_INFO.nodeName);

  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ZONE, fld = &fld);
  if (*fld.name) {
    VDstrupr(buf);
    strcpy(fld.val.txt,buf);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);
  }

  // Qty is based on object type
  computeNodePartQty();

  // MINO ISDP is based on grade and part_num for beams
  //                       grade and plate_thk for plates
  computeNodePartMinoISDP();
  

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* -------------------------------------------------
 * Compute the node
 */
IGRstat computeNode()
{
  IGRstat retFlag;
  
  // Init
  retFlag = 1;
  
  // Frozen nodes do not get recomputed

  // Is it a part?
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) {
    retFlag = computeNodePart();
    // stick update to CS node here
    goto wrapup;
  }
  
  // Failed
  retFlag = 0;

  // oh well
wrapup:
  return retFlag;
  
}

/* -------------------------------------------------
 * Returns the value for mbom assembly identifier
 */
IGRstat getAttributeValue_tmbom_assy()
{
  TGRid parentID;
  TGRid childID;
  
  TVDctBaseInfo baseInfo;

  // For assemblies (ENG) the mino
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY)) {
    vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO, fld = &FLD);
    strcpy(FLD.name,VDCT1_ATTR_MBOM_ASSY);
    return 1;
  }

  // For assemblies (2) the mino
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ASSY2)) {
    vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO, fld = &FLD);
    strcpy(FLD.name,VDCT1_ATTR_MBOM_ASSY);
    return 1;
  }

  // Not a part then not defined
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) {
    strcpy(FLD.val.txt,"");
    FLD.type = VDFLD_TYPE_TXT;
    return 1;
  }

  // Look up until an ASSY is found
  parentID = NODE_ID;
  
parent_loop:

  childID = parentID;
  
  vdct1$GetTree1Parent(objID = &childID, nth = 0, outID = &parentID);
  if (parentID.objid == NULL_OBJID) {
    parentID = NODE_ID; // Part has no assy parent
    goto got_it;
  }
  vdct1$GetBaseInfo(objID = &parentID, baseInfo = &baseInfo);

  if(strcmp(baseInfo.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY)) {
    if(strcmp(baseInfo.nodeType,VDCT1_ENG_NODE_TYPE_ASSY2)) goto parent_loop; 
  }

got_it:

  vdcol$GetAttr(objID = &parentID, name = VDCT1_ATTR_MINO, fld = &FLD);
  strcpy(FLD.name,VDCT1_ATTR_MBOM_ASSY);
  return 1;

}

/* -------------------------------------------------
 * Tree specific attribute processing
 */
IGRstat getAttributeValue()
{
  if (!strcmp(FLD.name,VDCT1_ATTR_MBOM_ASSY)) {
    return getAttributeValue_tmbom_assy();
  }
  return 0;
}

/* -------------------------------------------------
 * Individual stage information for NODE_INDEX
 */
IGRstat getNodeTypeInfo()
{
  NODE_CNT = 6;
  
  switch(NODE_INDEX) {

  case 0:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_PART);
    strcpy(NODE_TYPE_INFO.desc, "PART");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 1:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_PARTS);
    strcpy(NODE_TYPE_INFO.desc, "PARTS NODE");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 2:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ASSY2);
    strcpy(NODE_TYPE_INFO.desc, "STD ASSEMBLY[2]");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 3:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ASSY6);
    strcpy(NODE_TYPE_INFO.desc, "GEN ASSEMBLY[6]");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 4:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ENGASSY);
    strcpy(NODE_TYPE_INFO.desc, "ENG ASSEMBLY");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 5:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_GROUP);
    strcpy(NODE_TYPE_INFO.desc, "GROUP");
    strcpy(NODE_TYPE_INFO.level,"002");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  }

  memset(&NODE_TYPE_INFO,0,sizeof(TVDctNodeTypeInfo));

  return 0;
}

/* -------------------------------------------------
 * Class filters, all root
 */
IGRstar getFilter()
{
 
#if 0  
  om$get_classid(classname = "GRvg",
		 p_classid = &CLASS_LIST.p_classes[0]);
  CLASS_LIST.w_count = 1;
#endif
#if 1
  om$get_classid(classname = "VSplate",
		 p_classid = &CLASS_LIST.p_classes[0]);  
  om$get_classid(classname = "VSbeam",
		 p_classid = &CLASS_LIST.p_classes[1]);  
  om$get_classid(classname = "VDequipment",
		 p_classid = &CLASS_LIST.p_classes[2]);  
  om$get_classid(classname = "GRgencs",
		 p_classid = &CLASS_LIST.p_classes[3]);
  CLASS_LIST.w_count = 4;
#endif
  return 1;
}

/* -------------------------------------------------
 * Assorted information about the set type
 */
IGRstar getSetTypeInfo()
{

  strcpy(SET_TYPE_INFO.type,"Group");
  strcpy(SET_TYPE_INFO.rev, "000");
  strcpy(SET_TYPE_INFO.desc,"Group");
  
  strcpy(SET_TYPE_INFO.nodeTable,"vdct1_engassy");
  strcpy(SET_TYPE_INFO.leafTable,"vdct1_engassy");

  return 1;
}

/* -------------------------------------------------
 * Say something if ppl is run by user
 */
main()
{
  getSetTypeInfo();

  printf("%s %s %s\n",
    SET_TYPE_INFO.type,
    SET_TYPE_INFO.rev,
    SET_TYPE_INFO.desc);

  return 1;
}

/* --------------------------------------------------
 * Used to retrieve attribute information
 */
IGRint        ATTR_INDEX; // Attribute Index
TVDctAttrName ATTR_NAMEX; // Attribute Name
TVDctAttrInfo ATTR_INFO;  // Attribute Information

/* --------------------------------------------------
 * For a given set wide attribute name, fill in the info
 * I - ATTR_NAMEX
 * O - ATTR_INFO
 */
IGRstat getAttrInfo()
{ 
  IGRstat retFlag;
  
  // Init 
  retFlag = 1;
  memset(&ATTR_INFO,0,sizeof(TVDctAttrInfo));

  // Trick to allow sharing standard attributes
#include "attribute.h"

  // Not found
  retFlag = 0;
  
wrapup:
  return retFlag;
}

/* ---------------------------------------------------------------
 * Returns attribute name for a particular node type as
 * I - NODE_TYPE 
 * I - ATTR_INDEX
 * O - ATTR_NAMEX
 */

IGRstat getNodeAttrName()
{ 
  IGRstat retFlag;
  
  // Init 
  retFlag = 1;
  *ATTR_NAMEX = 0;
  
  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_PART)) {
  
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_COMPARTMENT);  goto wrapup;
    case  1: strcpy(ATTR_NAMEX,VDCT1_ATTR_MINO);         goto wrapup;
    case  2: strcpy(ATTR_NAMEX,VDCT1_ATTR_MINO_ISDP);    goto wrapup;
    case  3: strcpy(ATTR_NAMEX,VDCT1_ATTR_QTY);          goto wrapup;
    case  4: strcpy(ATTR_NAMEX,VDCT1_ATTR_ISDP_NAME);    goto wrapup;
    case  5: strcpy(ATTR_NAMEX,VDCT1_ATTR_ISDP_PATH);    goto wrapup;
    case  6: strcpy(ATTR_NAMEX,VDCT1_ATTR_UM);           goto wrapup;
    case  7: strcpy(ATTR_NAMEX,VDCT1_ATTR_LOCATION);     goto wrapup;
    case  8: strcpy(ATTR_NAMEX,VDCT1_ATTR_WEIGHT);       goto wrapup;
    case  9: strcpy(ATTR_NAMEX,VDCT1_ATTR_ASSY_DATE);    goto wrapup;
    case 10: strcpy(ATTR_NAMEX,VDCT1_ATTR_PART_DATE);    goto wrapup;
    case 11: strcpy(ATTR_NAMEX,VDCT1_ATTR_MAT1);         goto wrapup;
    case 12: strcpy(ATTR_NAMEX,VDCT1_ATTR_MAT2);         goto wrapup;
    case 13: strcpy(ATTR_NAMEX,VDCT1_ATTR_MAT3);         goto wrapup;
    case 14: strcpy(ATTR_NAMEX,VDCT1_ATTR_MAT4);         goto wrapup;

    }
    
  }

  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ENGASSY)) {
    
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_AV_HULL);      goto wrapup;
    case  1: strcpy(ATTR_NAMEX,VDCT1_ATTR_CONTRACT_JOB); goto wrapup;
    case  2: strcpy(ATTR_NAMEX,VDCT1_ATTR_COST_CODE);    goto wrapup;
    case  3: strcpy(ATTR_NAMEX,VDCT1_ATTR_COMPARTMENT);  goto wrapup;
    case  4: strcpy(ATTR_NAMEX,VDCT1_ATTR_MINO);         goto wrapup;
    case  5: strcpy(ATTR_NAMEX,VDCT1_ATTR_LINE_IDENT);   goto wrapup;
    case  6: strcpy(ATTR_NAMEX,VDCT1_ATTR_FIAN);         goto wrapup;
    case  7: strcpy(ATTR_NAMEX,VDCT1_ATTR_WEIGHT);       goto wrapup;
    case  8: strcpy(ATTR_NAMEX,VDCT1_ATTR_LOCATION);     goto wrapup;
    case  9: strcpy(ATTR_NAMEX,VDCT1_ATTR_REVISION);     goto wrapup;
    case 10: strcpy(ATTR_NAMEX,VDCT1_ATTR_VERSION);      goto wrapup;
    case 11: strcpy(ATTR_NAMEX,VDCT1_ATTR_ASSY_DATE);    goto wrapup;


    }
  }
  
  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ASSY2)) {
    
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_AV_HULL);      goto wrapup;
    case  1: strcpy(ATTR_NAMEX,VDCT1_ATTR_CONTRACT_JOB); goto wrapup;
    case  2: strcpy(ATTR_NAMEX,VDCT1_ATTR_COST_CODE);    goto wrapup;
    case  3: strcpy(ATTR_NAMEX,VDCT1_ATTR_COMPARTMENT);  goto wrapup;
    case  4: strcpy(ATTR_NAMEX,VDCT1_ATTR_MINO);         goto wrapup;
    case  5: strcpy(ATTR_NAMEX,VDCT1_ATTR_LINE_IDENT);   goto wrapup;
    case  6: strcpy(ATTR_NAMEX,VDCT1_ATTR_FIAN);         goto wrapup;
    case  7: strcpy(ATTR_NAMEX,VDCT1_ATTR_WEIGHT);       goto wrapup;
    case  8: strcpy(ATTR_NAMEX,VDCT1_ATTR_LOCATION);     goto wrapup;
    case  9: strcpy(ATTR_NAMEX,VDCT1_ATTR_REVISION);     goto wrapup;
    case 10: strcpy(ATTR_NAMEX,VDCT1_ATTR_VERSION);      goto wrapup;
    case 11: strcpy(ATTR_NAMEX,VDCT1_ATTR_ASSY_DATE);    goto wrapup;

    }
  }

#if 0 
  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_PARTS)) {
    
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_QTY);          goto wrapup;
 

    }
  }
#endif

  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_GROUP)) {
    
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_AV_HULL);      goto wrapup;
    case  1: strcpy(ATTR_NAMEX,VDCT1_ATTR_CONTRACT_JOB); goto wrapup;
    case  2: strcpy(ATTR_NAMEX,VDCT1_ATTR_GROUP_CODE);   goto wrapup;
    case  3: strcpy(ATTR_NAMEX,VDCT1_ATTR_COM_CODE);     goto wrapup;   
    case  4: strcpy(ATTR_NAMEX,VDCT1_ATTR_COST_CODE);    goto wrapup;
    case  5: strcpy(ATTR_NAMEX,VDCT1_ATTR_ZONE);         goto wrapup;
   
    }
    
  }
  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ASSY6)) {
    
    switch(ATTR_INDEX) {

    case  0: strcpy(ATTR_NAMEX,VDCT1_ATTR_AV_HULL);      goto wrapup;
    case  1: strcpy(ATTR_NAMEX,VDCT1_ATTR_CONTRACT_JOB); goto wrapup;
    case  2: strcpy(ATTR_NAMEX,VDCT1_ATTR_GROUP_CODE);   goto wrapup;
    case  3: strcpy(ATTR_NAMEX,VDCT1_ATTR_COM_CODE);     goto wrapup;
    case  4: strcpy(ATTR_NAMEX,VDCT1_ATTR_COST_CODE);    goto wrapup;
    case  5: strcpy(ATTR_NAMEX,VDCT1_ATTR_ZONE);         goto wrapup;
    case  6: strcpy(ATTR_NAMEX,VDCT1_ATTR_UNIT);         goto wrapup;
    case  7: strcpy(ATTR_NAMEX,VDCT1_ATTR_DWG_NUM);      goto wrapup;
    case  8: strcpy(ATTR_NAMEX,VDCT1_ATTR_SHORT_DRAW);   goto wrapup;     
    }
    
  }

  // Not found
  retFlag = 0;
    
wrapup:
  
  
  return retFlag;
}

/* --------------------------------------------------
 * Pull in standard helper functions
 */
#include "compute.h"

/* --------------------------------------------------
 * Computes pd node name
 */
IGRstat computeDescPD()
{
  IGRstat retFlag;
  TVDfld  descFld,hullFld,dwgFld,costFld;
  
  // Arg Check, only valid for pd assemblies
  retFlag = 0;
  if ( strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY)) goto wrapup;
  if (strncmp(BASE_INFO.nodeName,"PD",2)) goto wrapup;
  
  // Get the mino attribute
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_DESC, fld = &descFld);
  if (*descFld.name == 0) goto wrapup;
  
  // Add in drawing number and hull
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_DWG_NUM,   fld = &dwgFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_AV_HULL,   fld = &hullFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COST_CODE, fld = &costFld);

  // And build it
  sprintf(descFld.val.txt,"%s%s%s",
	  dwgFld.val.txt,
	  hullFld.val.txt,
	  costFld.val.txt);
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &descFld);
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Traffic director for computing the desc
 */
IGRstat computeDesc()
{
  IGRstat retFlag;
  IGRstat sts;
  
  TVDfld descFld;

  // Init
  retFlag = 0;
  
  // Get the mino attribute
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_DESC, fld = &descFld);
  if (*descFld.name == 0) goto wrapup;
  
  // See if it's a pd desc
  sts = computeDescPD();
  if (sts & 1) {
    retFlag = 1;
    goto wrapup;
  }
  
  // Just Leave for now

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
/* --------------------------------------------------
 * Computes pd node name
 */
IGRstat computeMinoPD()
{
  IGRstat retFlag;
  TVDfld  minoFld,hullFld,dwgFld;
  
  // Arg Check, only valid for pd assemblies
  retFlag = 0;
  if (!((!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY)) ||
	(!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ASSY2)))
      ) goto wrapup;

  if (strncmp(BASE_INFO.nodeName,"PD",2)) goto wrapup;
  
  // Get the mino attribute
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO, fld = &minoFld);
  if (*minoFld.name == 0) goto wrapup;
  
  // Add in drawing number and hull
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_DWG_NUM, fld = &dwgFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_AV_HULL, fld = &hullFld);

  // And build it
  sprintf(minoFld.val.txt,"%s-%s-%s",
	  BASE_INFO.nodeName,
	  dwgFld.val.txt,
	  hullFld.val.txt);
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &minoFld);
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Traffic director for computing the mino number
 */
IGRstat computeMino()
{
  IGRstat retFlag;
  IGRstat sts;
  IGRchar buf[128];
  
  TVDfld minoFld;
  TVDfld commodityFld;
  TVDfld shortFld;
  TVDfld hullFld;
  TVDfld unitFld;
  
  // Init
  retFlag = 0;
  
  // Get the mino attribute
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO, fld = &minoFld);
  if (*minoFld.name == 0) goto wrapup;
  
  // See if it's a pd mino
  sts = computeMinoPD();
  if (sts & 1) {
    retFlag = 1;
    goto wrapup;
  }

  // Only for the Unit
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY)){
   
    // get the values for a unit 
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_COM_CODE, fld = &commodityFld);  
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_UNIT, fld = &unitFld); 
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_SHORT_DRAW, fld = &shortFld); 
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_AV_HULL, fld = &hullFld);
 
  // Make up the MINO
    sprintf(minoFld.val.txt,"%s%s-%s-%s",
	  commodityFld.val.txt,
	  unitFld.val.txt,
	  shortFld.val.txt,
	  hullFld.val.txt
	    );
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &minoFld);
  }
  
  // Only for the Part
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)){
   
    // get the value for a unit 
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COM_CODE, fld = &minoFld);  
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &minoFld);
  }

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}



/* --------------------------------------------------
 * Set the av hull for the top node in the tree
 */
IGRstat setAttributeAvHull()
{
  IGRstat retFlag;
  TVDfld  hullFld;
  
  // Init
  retFlag = 0;

  // Only for the top
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_GROUP)) goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_AV_HULL, fld = &hullFld);
  if (*hullFld.name == 0) goto wrapup;
    
  // Update
  strcpy(hullFld.val.txt,"2484");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &hullFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Set the contract number for the top node in the tree
 */
IGRstat setAttributeContract()
{
  IGRstat retFlag;
  TVDfld  contractFld;
  
  // Init
  retFlag = 0;

  // NO PART 
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART))  goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_CONTRACT_JOB, fld = &contractFld);
  if (*contractFld.name == 0) goto wrapup;
    
  // Update
  strcpy(contractFld.val.txt,"C60017");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &contractFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}


/* --------------------------------------------------
 * Set the group Group for the Unit in the tree
 */
IGRstat setAttributeGroup()
{
  IGRstat retFlag;
  TVDfld  atFld;
  
  // Init
  retFlag = 0;

    // NO PART or PARTS
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART))  goto wrapup;
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_GROUP_CODE, fld = &atFld);
  if (*atFld.name == 0) goto wrapup;
    
  // Update
  strcpy(atFld.val.txt,"08");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &atFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
/* --------------------------------------------------
 * Set the group Commodity in the tree
 */
IGRstat setAttributeCommodity()
{
  IGRstat retFlag;
  TVDfld  commodityFld;
  
  // Init
  retFlag = 0;

  // NO PART or PARTS
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) goto wrapup;
 
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COM_CODE, fld = &commodityFld);
  if (*commodityFld.name == 0) goto wrapup;
    
  // Update from Databse
  strcpy(commodityFld.val.txt,"FN");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &commodityFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Set the group Compartment in the tree
 */
IGRstat setAttributeCompartment()
{
  IGRstat retFlag;
  TVDfld  compartmentFld;
  IGRchar nullString[256], compartmentNo[256];
  
  
  // Init
  retFlag = 0;
  sprintf(nullString,"");
  
  // only the PART
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) goto wrapup;

  // get the attribute data
  vdsa$GetStruct(objOE = &PIECE_OE,
		 name  = VDCT1_ISDP_ATTR_COMPARTMENT,
		 txt   = compartmentNo);

  printf("Compartment is : [%s]\n\n",compartmentNo);
  

  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COMPARTMENT, fld = &compartmentFld);
  //if (*compartmentFld.name == 0) goto wrapup;
    
  strcpy(compartmentFld.val.txt,compartmentNo);
  printf("compartmentFld.val.txt is: [%s],\n\n",compartmentFld.val.txt);
  
  
  // Update 
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &compartmentFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Set the group Unit in the tree
 */
IGRstat setAttributeUnit()
{
  IGRstat retFlag;
  TVDfld  unitFld;
  
  // Init
  retFlag = 0;

  // Only for the unit
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_UNIT)) goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_UNIT, fld = &unitFld);
  if (*unitFld.name == 0) goto wrapup;
    
  // Update
  strcpy(unitFld.val.txt,BASE_INFO.nodeName);
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &unitFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
/* --------------------------------------------------
 * Set the group ShortDraw in the tree
 */
IGRstat setAttributeShortDraw()
{
  IGRstat retFlag;
  TVDfld  shortFld;
  TVDfld  groupFld;
  TVDfld  unitFld;
  
  
  // Init
  retFlag = 0;

  // Only for the unit
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_UNIT)) goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_GROUP_CODE, fld = &groupFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_UNIT, fld = &unitFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_SHORT_DRAW, fld = &shortFld);
  if (*shortFld.name == 0) goto wrapup;
    
  // Update
  sprintf(shortFld.val.txt,"%s%s%s",groupFld.val.txt,unitFld.val.txt,"XX");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &shortFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}


/* --------------------------------------------------
 * Set the group DrawNum in the tree
 */
IGRstat setAttributeDrawNum()
{
  IGRstat retFlag;
  TVDfld  contractFld;
  TVDfld  drawnumFld;
  TVDfld  unitFld;
  TVDfld  groupFld;
  
  
  
  // Init
  retFlag = 0;

  // Only for the unit
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_UNIT)) goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_CONTRACT_JOB, fld = &contractFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_UNIT, fld = &unitFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_GROUP_CODE, fld = &groupFld);
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_DWG_NUM, fld = &drawnumFld);
  if (*drawnumFld.name == 0) goto wrapup;
    
  // Update
  sprintf(drawnumFld.val.txt,"%s-%s-%s-%s",
	  contractFld.val.txt,
	  groupFld.val.txt,
	  unitFld.val.txt,
	  "XX");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &drawnumFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}


/* --------------------------------------------------
 * Set the zone for the top node in the tree
 */
IGRstat setAttributeZone()
{
  IGRstat retFlag;
  TVDfld  zoneFld;
  IGRchar *p;
  
  // Init
  retFlag = 0;

  // Only for the top
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_GROUP)) goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ZONE, fld = &zoneFld);
  if (*zoneFld.name == 0) goto wrapup;
    
  // Assume part of the nodeName
  p = BASE_INFO.nodeName;
  if ((*p < '0') || (*p > '9')) goto wrapup;
  strcpy(zoneFld.val.txt,BASE_INFO.nodeName);
  p = strchr(zoneFld.val.txt,' ');
  if (p) *p = 0;
  
  // Update
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &zoneFld);

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* ---------------------------------------------------
 * Set the mat attributes to the location
 */
IGRstat setAttributeMAT()
{
  IGRstat retFlag;
  IGRstat sts;
  
  // Init
  retFlag = 0;
  
  // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  
  
  // Done
  retFlag = 1;
  
wrapup:

  return retFlag;
}


  
/* --------------------------------------------------
 * Set the mat(x) attribute for the CS  node in the tree
 * for the first time
 */
IGRstat setAttributeMATx()
{
  IGRstat retFlag;
  IGRstat sts;
  
  // Init
  retFlag = 0;

  // Only for the CS
  // if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_CS)) goto wrapup;
  
  // set the first time data to 0.0 each value
  //sts = vdct1$CSStartNodeMatrix(nodeID = &NODE_ID);

  
  // Do it
  //vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
  //csOE   = &PIECE_OE);
  
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Sets the Cost Code Attribute Value
 */

IGRstat setAttributeCostCode()
{

  IGRstat       retFlag;
  IGRstat       traceFlag;

  IGRchar       costCode[128];
  TVDfld        costCodeFld;
  TVDctBaseInfo parentBaseInfo, baseInfo;
  
  traceFlag = 1;
  retFlag = 0;


  vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &parentBaseInfo);
  vdct1$GetBaseInfo(objID = &NODE_ID, baseInfo = &baseInfo);
  // say hi
  if (traceFlag){
    printf(">>> setAttributeCostCode\n");
    printf("BASE_INFO.nodeType      = %s\n",BASE_INFO.nodeType);
    printf("baseInfo.nodeType       = %s\n",baseInfo.nodeType);
    printf("parentBaseInfo.nodeType = %s\n",parentBaseInfo.nodeType);
    
  }
  

 // Only for the ASSYS || UNIT || GROUP
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_GROUP)) {
  // set the Cost Code to 60000
  // get access to the Attribute COST_CODE
    printf("getting the attribute\n");
    
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COST_CODE, fld = &costCodeFld);  
  
  sprintf(costCodeFld.val.txt,"60000");
  
  if (traceFlag) printf("Cost Code Field set \n");
  
  // set the Attribute value
  vdcol$UpdAttrs(objID = &NODE_ID, fld   = &costCodeFld, cnt   = 1);
  if (traceFlag) printf("Cost Code Posted\n");
  
  // success
  retFlag = 1;
  goto wrapup;
  }
  
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_UNIT)) {
  // copy the Cost Code from the ParentNode
  // get access to the Attribute COST_CODE
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_COST_CODE, fld = &costCodeFld); 

  if (traceFlag) printf("UNIT: Cost Code is %s\n",costCodeFld.val.txt);
  
  // send the data to the new field
  vdcol$UpdAttrs(objID = &NODE_ID, fld   = &costCodeFld, cnt   = 1);

  //success 
  retFlag = 1;
  goto wrapup;
  }
  
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY)) {  
  // copy the Cost Code from the ParentNode

  // get access to the Attribute COST_CODE
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_COST_CODE, fld = &costCodeFld); 
  if (traceFlag) printf("ENGASSY: Cost Code is %s\n",costCodeFld.val.txt);
  
  // send the data to the new field
  vdcol$UpdAttrs(objID = &NODE_ID, fld   = &costCodeFld, cnt   = 1);

  retFlag = 1;
  goto wrapup;
  }
  // failed
  retFlag = 0;
  // oh well
wrapup:
// say bye
  if (traceFlag) printf("<<< setAttributeCostCode %d\n",retFlag);

  return retFlag;

}
/* ----------------------------------------------------
 * Set Attribute Weight
 */
IGRstat setAttributeWeight()
{
  IGRstat     retFlag;
  
  IGRchar     weight[256];
  TVDfld      weightFld;
  
  
    // this is a part issue or a ENG_ASSY issue
    if ((!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) || 
	(!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY))) {
      // get the attribute data
      vdsa$GetStruct(objOE = &PIECE_OE,
		     name  = VDCT1_ISDP_ATTR_WEIGHT,
		     txt   = weight); 

      vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_WEIGHT, fld = &weightFld); 
      // send the data to the new field
      strcpy(weightFld.val.txt,weight);
      vdcol$UpdAttrs(objID = &NODE_ID, fld   = &weightFld, cnt   = 1);
    }
  

    retFlag = 1;
  
wrapup:
  return retFlag;
  
}


/* --------------------------------------------------
 * Called when node is created
 * I - NODE_PARENT_ID       If NULL_OBJID, top node, use SET_ID
 * I - SET_ID               Used for top node in tree
 * I - NODE_TYPE
 * I - NODE_NAME
 * O - NODE_ID
 *
 * Not alot of error checking here, rely on the
 * calling program to do things right
 */
IGRstat createNodex()
{
  IGRstat       retFlag,sts;
  TVDfld        fld;
  IGRchar       buf[128];
  IGRint       *a_minoIndex;

  TVDfld        groupFld;
  TVDfld        hullFld;
  TVDfld        unitFld;  
  TVDctBaseInfo parentBaseInfo;
  

  // Init
  retFlag = 0;
  NODE_ID.objid = NULL_OBJID;

  if (NODE_PARENT_ID.objid == NULL_OBJID) NODE_ID.osnum = SET_ID.osnum;
  else                                    NODE_ID.osnum = NODE_PARENT_ID.osnum;
  
  // Make the set object
  vdct1$CreateBaseObject(osnum     = NODE_ID.osnum,
                         classType = VDCT1_CLASS_TYPE_NODE,
                         objID     = &NODE_ID);
  if (NODE_ID.objid == NULL_OBJID) goto wrapup;

  // Connect to parent or the set
  if (NODE_PARENT_ID.objid == NULL_OBJID) {
    
    vdct1$ConnectMgrChild(mgrID   = &SET_ID,
			  childID = &NODE_ID);

    vdct1$GetBaseInfo(objID = &SET_ID, baseInfo = &BASE_INFO);

  }
  else {
    vdct1$ConnectTree1Child(treeID  = &NODE_PARENT_ID,
			    childID = &NODE_ID);

    vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &BASE_INFO);
  }

  // Set info
  strcpy(BASE_INFO.nodeName,NODE_NAME);
  strcpy(BASE_INFO.nodeType,NODE_TYPE);

  if (!strcmp(VDCT1_ENG_NODE_TYPE_ENGASSY,BASE_INFO.nodeType)) {

  // Get it
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_UNIT, fld = &unitFld);
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_GROUP_CODE, fld = &groupFld);
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_AV_HULL, fld = &hullFld);
 
    // look up unique number from ost_mino_index (database lookup)
  vdct1$PostGetNextMinoIndex(hullNum     = hullFld.val.txt,
			     unitNum     = unitFld.val.txt,
			     groupCode   = groupFld.val.txt,
			     a_minoIndex = &a_minoIndex);
  vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &parentBaseInfo);
  
    // generate buf
  sprintf(buf,"ENG%4s_%03d",parentBaseInfo.nodeName,a_minoIndex);
  strcpy(BASE_INFO.nodeName,buf);
  }

  vdct1$SetBaseInfo(objID = &NODE_ID, baseInfo = &BASE_INFO);

  // Sets ATTR_NAMEX for each available attribute
  for(ATTR_INDEX = 0; getNodeAttrName(); ATTR_INDEX = ATTR_INDEX + 1) {
     
    // Get the full info
    getAttrInfo();

    // Check for setup error
    if (*ATTR_INFO.name != 0) {
	
      // printf("Adding Attribute %s\n",ATTR_INFO.name);
      
      vdfld$Set(fld  = &fld, 
		name = ATTR_INFO.name, 
		type = ATTR_INFO.type);

      vdcol$UpdAttrs(objID = &NODE_ID, 
		     fld   = &fld, 
		     cnt   = 1);
    }
  }

  // Pull down some values and set them
  pullDownAttribute(VDCT1_ATTR_AV_HULL);
  pullDownAttribute(VDCT1_ATTR_CONTRACT_JOB);
  pullDownAttribute(VDCT1_ATTR_HULL_JOB);
  pullDownAttribute(VDCT1_ATTR_GROUP_CODE);
  pullDownAttribute(VDCT1_ATTR_COM_CODE);
  pullDownAttribute(VDCT1_ATTR_COST_CODE);
  pullDownAttribute(VDCT1_ATTR_ZONE);
  pullDownAttribute(VDCT1_ATTR_UNIT);
  pullDownAttribute(VDCT1_ATTR_COMPARTMENT);
  pullDownAttribute(VDCT1_ATTR_DWG_NUM);
  pullDownAttribute(VDCT1_ATTR_SHORT_DRAW);
  pullDownAttribute(VDCT1_ATTR_PALLET);
  pullDownAttribute(VDCT1_ATTR_MINO);
  pullDownAttribute(VDCT1_ATTR_MINO_ISDP);
  pullDownAttribute(VDCT1_ATTR_QTY);
  pullDownAttribute(VDCT1_ATTR_LINE_IDENT);
  pullDownAttribute(VDCT1_ATTR_FIAN);
  pullDownAttribute(VDCT1_ATTR_ISDP_NAME);
  pullDownAttribute(VDCT1_ATTR_ISDP_PATH);
  pullDownAttribute(VDCT1_ATTR_UNIT_MEASURE);
  pullDownAttribute(VDCT1_ATTR_MATERIAL);
  pullDownAttribute(VDCT1_ATTR_SPEC_CODE);
  pullDownAttribute(VDCT1_ATTR_WEIGHT);
  pullDownAttribute(VDCT1_ATTR_LOCATION);
  pullDownAttribute(VDCT1_ATTR_REVISION);
  pullDownAttribute(VDCT1_ATTR_VERSION);
  pullDownAttribute(VDCT1_ATTR_ASSY_DATE);
  pullDownAttribute(VDCT1_ATTR_PART_DATE);
  pullDownAttribute(VDCT1_ATTR_MAT1);
  pullDownAttribute(VDCT1_ATTR_MAT2);
  pullDownAttribute(VDCT1_ATTR_MAT3);
  pullDownAttribute(VDCT1_ATTR_MAT4);  

  // Some initial setting
  setAttributeUM();
  setAttributeQty();
  setAttributeType();
  setAttributeZone();
  setAttributeAvHull();
  setAttributeContract();
  setAttributeUnit();
  setAttributeGroup();
  setAttributeCommodity();
  setAttributeCompartment();
  setAttributeShortDraw();
  setAttributeDrawNum();
  setAttributeCostCode();
  setAttributeMAT();
  setAttributeWeight();
  
  // Do some computing
  computeMino();
  computeDesc();
  computeDate   (VDCT1_ATTR_ENG_DATE);
  computeVersion(VDCT1_ATTR_VERSION);
 
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
/* ------------------------------------------------
 * Controls
 * createNodex() operation
 * I - NODE_PARENT_ID       If NULL_OBJID, top node, use SET_ID
 * I - SET_ID               Used for top node in tree
 * I - NODE_TYPE
 * I - NODE_NAME
 * O - NODE_ID
 */ 
IGRstat createNode()
{
  IGRint        retFlag;
  IGRint        sts, I;
  TGRid         fndNodeID, partNodeID, nodeID, parentID, parentNodeID;
  IGRchar       parentName[128], buf[256];
  TVDctNodeType a_nodeType;
  IGRchar       partEquipNo[256], unitEquipNo[256], nullString[256];
  TVDctBaseInfo baseInfo;

  retFlag   = 0;
  sts = 0;
  sprintf(nullString,"");
  
  // check if the dataBase is closed
  sts = VDSverify_login();

  // check the rules if the dataBase is closed
  if(!(sts & 1)){
  
  // Rule: if the dataBase is closed no making ENGASSY
    if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ENGASSY)) {
      printf("Error: Database Closed\nThis action requires an open Database\n\n");
      goto wrapup;
    }
    
  }

  // Rule: if a Part it must be correct unit_number in dynamic attributes
  // applied only to equipment
 // Make sure got a model object


  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_PART)) {
    
  printf("Rules Check for Unit Numbers \n\n");
  
  if (PIECE_OE.obj_id.objid == NULL_OBJID) {
    retFlag = 1;   
    NODE_ID.objid = NULL_OBJID;
    goto wrapup;
  }


   // ask for unit number of UNIT
  vdct1$GetTree1Parent(objID = &NODE_PARENT_ID, outID = &parentID);
  vdct1$GetBaseInfo(objID = &parentID, baseInfo = &baseInfo);

  // go get the UNIT Info.
  while (strcmp(baseInfo.nodeType,VDCT1_ENG_NODE_TYPE_UNIT))
    {
      // get the next tree parent 
      parentNodeID = parentID;
      vdct1$GetTree1Parent(objID = &parentNodeID, outID = &parentID);
      vdct1$GetBaseInfo(objID = &parentID, baseInfo = &baseInfo);
    }

  strcpy(unitEquipNo,baseInfo.nodeName);
  
  vdsa$GetStruct(objOE = &PIECE_OE,
		 name  = VDCT1_ISDP_ATTR_UNIT,
		 txt   = partEquipNo);
  // upper case compare
  VDstrupr(partEquipNo);
  VDstrupr(unitEquipNo);
  
    if ((strcmp(partEquipNo,unitEquipNo)) && (strcmp(partEquipNo,nullString))) {

      sprintf(buf,
	      "Rejected Part: %s\n\nIncorrect Unit Number\n\nBelongs to Unit: %s\n\nThis is Unit %s\n\n",
	      BASE_INFO.nodeName,
	      partEquipNo,
	      unitEquipNo);
      
      // spit the error message and get out of here
      sts = VDnotify_box(buf);

      // fail the node creation
      NODE_ID.objid = NULL_OBJID;
      goto wrapup;
    }
  }
  

  // save existing name
  vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &BASE_INFO); 
  strcpy(parentName,BASE_INFO.nodeName);
  

  // make the first node
  sts = createNodex(); 

  // Rule: if ENGASSY 
  //if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ENGASSY)) {
  // Rule: 
  //}
#if 0
     vdct1$SearchForNodeInTree(a_treeID      = &NODE_PARENT_ID,
			       a_nodeType    = VDCT1_ENG_NODE_TYPE_CS,
			       a_fld         = NULL,
			       a_descendFlag = 0,
			       a_nodeID      = &NODE_ID);
#endif  

  
  // all tests done
  retFlag = 1  ;

  // oh well
wrapup:

  return retFlag;
}

/* --------------------------------------------------
 * Called when set is created
 * I - MGR_ID       set is linked to it, created using mgr osnum
 * I - SET_TYPE     Little bit redundant, keep for now
 * I - SET_TYPE_REV Use unless blank then use default
 * I = SET_NAME
 * O - SET_ID       NULL_OBJID if fails
 *
 * Not alot of error checking here, rely on the
 * calling program to check things
 */

IGRstat createSet()
{
  IGRstat       retFlag;
  TVDctBaseInfo baseInfo;
  
  // Init
  retFlag = 0;
  SET_ID.objid = NULL_OBJID;
  printf("createSet PPL started\n");
  
  // Make the set object
  vdct1$CreateBaseObject(osnum     = MGR_ID.osnum,
                         classType = VDCT1_CLASS_TYPE_SET,
                         objID     = &SET_ID);
  printf("CreateBaseObject\n");
  
  if (SET_ID.objid == NULL_OBJID) {
    printf("SET_ID.objid == NULL_OBJID to wrapup\n");   
    goto wrapup;
  }
  

  // Connect to manager
  vdct1$ConnectMgrChild(mgrID   = &MGR_ID,
   		        childID = &SET_ID);

  // Set info
  memset(&baseInfo,0,sizeof(TVDctBaseInfo));
  strcpy(baseInfo.setName,SET_NAME);
  strcpy(baseInfo.setType,SET_TYPE);

  if (*SET_TYPE_REV) strcpy(baseInfo.setTypeRev,SET_TYPE_REV);
  else {
    getSetTypeInfo();
    strcpy(baseInfo.setTypeRev,SET_TYPE_INFO.rev);
  }
  
  vdct1$SetBaseInfo(objID = &SET_ID, baseInfo = &baseInfo);

  // Create Top Level Node
  strcpy(NODE_TYPE,VDCT1_ENG_NODE_TYPE_GROUP);
  strcpy(NODE_NAME,SET_NAME);
  NODE_PARENT_ID.objid = NULL_OBJID; 

  createNode();

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}












