/* $Id: VDhole2.u,v 1.1.1.1 2001/01/04 21:09:23 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vdspace/ppl / VDhole2.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDhole2.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:23  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bstypes.h"
#include "bserr.h"
#include "bsconic.h"
#include "emsedgedef.h"
#include "EMSmsgdef.h"
#include "EMS.h"
#include "EMScmacros.h"
#include "EMSopt.h"
#include "EMSbnddef.h"
#include "EMSbnd.h"
#include "emsmapdef.h"
#include "emsimpdef.h"
#include "macro.h"
#include "nddef.h"
#include "VDSutil_def.h"
#include "DIdef.h"
#include "acmacros.h"
#include "COmdef.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "EMSssprops.h"

#include "AS_status.h"

#define   VERBOSE 	1
#define   EPSILON	1.0E-10
#define   MAX_TEMP	10 	/* number of templates */
#define	  MAX_CHA_TEMP	7
#define	  MAX_CHA_ROOT	4

#define	  MAXINT	20
#define	  ORDER		2

#define ACkeep_template 1024
/*
#define   DEBUG 	1
#define   DEBUG3	1
#define   DEBUG1	1
#define   DEBUG4	1
#define   DEBUG5	1
#define   DEBUG6	1
*/

/* Different kind of intersections, the first word is for the support */

struct GRid		par_obj, CI_MACRO_ID,obj,mac, def_temp;
GRobj 			ci_mac_def1, ci_mac_def2;
IGRchar			*temp_names[MAX_TEMP], *feet_names[1];
IGRint			temp_types[MAX_TEMP];

struct IGRbsp_surface   **bsp_surf1,**bsp_surf2;
struct IGRbsp_curve	*bsp_curve,*curve[MAX_TEMP-2], *p_curve[MAX_TEMP], 
			**array, *bnd_curve, *line, *comp_cv ;
struct IGRplane		plane[2];
struct ret_struct	temp1_rts;
struct GRlc_info        entries[MAX_TEMP], final_curve;

struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct GRid		SPROJ, CP_SUR,SUR[MAX_TEMP] ,wrk_GRid, comp_id,
			GRid_list, GRid_cv[MAX_TEMP],GRid_feet;

IGRdouble		point_on[3*(MAX_TEMP-2)],range[6], v1[3], point[3],
			matrix[16], du[3], dv[3], dirvect[3],obj_range[6],
			q_pl[3], u_pl[3], u[2], q[2],us[2], qs[2], coef, fact,
			chrdht_tol,calc_tol,basis_tol,plane_space[12],v2[3],
			**par1,**par2, *over0 , *over1 ,pt0[3], pt1[3], pt2[3],
			pt3[3],*p_par1[MAX_TEMP-2], *p_par2[MAX_TEMP-2],
			save_pts[6*(MAX_TEMP-2)],d_par, par, parr1,parr2[2],
			*int_pts[MAX_TEMP-2],  intpts1[3], intpts2[3],*end_pts,
			**pts, *eval_pts,cht_tol,accuracy_factor,
			*param, **Xpts, **Xpar1, **Xpar2, dist1,dist2, value,
			*int_pts0,*int_pts1,*p_par10,*p_par11,*p_par20,*p_par21,
			upar,vpar, center[3], area;
			

IGRboolean 	        test_degeneracy, construct_loopset, world, in_range,
			orient_known, pos_orient, wind_loopset, msg_status,
			tst_plan,onsurf;

char			buff[MAX_TEMP*MAX_CHA_TEMP], path[80];

unsigned IGRchar	curve_type;

long			n_over, rotten_one, stat, status, msg, nput, nret;

IGRint			return_type,type_flag,snb_int,i_onecv,nb_merge,*Xnumpts,
			elem_type[MAX_TEMP],nb_retsf,nb_gpe,*nb_cvgp,added,
			nb_create, num_merge,num_alloc, num_ent, *numpts, Xnumgrps, 
                        numgrps, n_int, total_num_poles, size, num_pts, nb_sf1,
			nb_sf2, flag, two_intersect, rev, int_flag, open_cv, 
			close_cv, split_ind, i, j, k, l, index_open[2], nb_time,
			n_int0,n_int1, found, nb_poles, p_index,index_NULL,
			tab_cv[MAX_TEMP],no_intersect,num_temp,
			no_last_intersect,cv0pt0, cv0pt1,cv1pt0, cv1pt1,
			nb_sol;
			

BSrc			rc;

IGRshort		opt, opt1, order, mat_type[MAX_TEMP-1],matrix_type;

GRclassid		obj_classid;
struct GRprops		properties;

IGRdouble      		area_pt[2];
IGRlong        		number_of_points, number_of_bad_curves, 
			bad_curve_indices[50];
IGRdouble      		*points;
unsigned       IGRshort map_options, imp_options;

extern GRclassid	OPP_EMSplane_class_id, OPP_EMSsurface_class_id, 
			OPP_GRcurve_class_id,OPP_EMScompsurf_class_id,
			OPP_VDSInfPl_class_id, OPP_EMSsfimpbnd_class_id;

extern		GRdpb_put();
extern int 	init_cnst_list(), ASsuper_construct(),
		SMIsKindOf(),
		GRdpb_get(),
		sprintf(),
		printf(),
		BSmkvec(),
		free(),
		BSfreecv(),
		BScvcv_int(),
		BSprptsonsf(),
		BSprptonsf(),
		BSctrarplcv(),
		BSpartofcv(),
		BSrev_cv(),
		BSalloccv(),
                BSconstprcv(),
		BSpjcvtsf(),
	        BSsfptseval(),
		BSsfnormal(),
                BSprj_cv_pl(),
		SMelem_(),
		VDint(),
		VDSfree(),
		VDSdist2(),
		VDSfill_curve(),
		VDSorder_curves(),
		VDadd_cv_to_close(),
		VDSorder_gpe(),
		VDSorder_pt(),
		ACcreate_def_temp();

extern char        *malloc();
extern double      fabs(), BSdistptpt(), BSdotp();
extern		   BSpartofsf();
extern int	   EFmsgReport();
extern IGRboolean  BSfreesf();


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  struct ret_struct ret_str[MAX_TEMP];
  feet_names[0] = "surf";

  temp_names[0] = "accuracy_factor";  
  temp_types[0] = double_type;

  temp_names[1] = "support";  
  temp_types[1] = other_generic;

  for (i=2; i<MAX_TEMP; i=i+1)
  {
	strcpy (&buff[i*MAX_CHA_TEMP],"surf");
	sprintf(&buff[i*MAX_CHA_TEMP+MAX_CHA_ROOT],"%d",i);
	temp_names[i] = &buff[i*MAX_CHA_TEMP];
        temp_types[i] = other_generic | curve_generic | line_generic | conic_generic;
  }

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          	= ci_mac_def1,
		prop 		  	= ACvariable_template|ACkeep_template,
		status 	          	= &stat,
		name              	= "VDhole2",
             	temp_num  		= MAX_TEMP,
 		temp_names 		= temp_names,
                temp_types 		= temp_types,
	      	extern_feet_num 	= 1, 
		extern_feet_names 	= feet_names);

 /* Put the default value */
 ret_str[0].type = double_type;
 ret_str[1].type = other_generic;
 ret_str[2].type = other_generic;
 ret_str[3].type = other_generic;
 ret_str[4].type = other_generic;
 ret_str[5].type = other_generic;
 ret_str[6].type = other_generic;
 ret_str[7].type = other_generic;
 ret_str[8].type = other_generic;
 ret_str[9].type = other_generic;
 ret_str[0].var.root_pm_st.value = 1;
 mac.objid = ci_mac_def1;
 mac.osnum = AC_construct_id.osnum;
 
#if 0
 ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_temp	   = &def_temp,
		     value	   = ret_str);
#endif

/* Change for 2.0 */
  ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_col       = &def_temp,
		     temp_val	   = ret_str);

}

/* ========================================================================= */

place ()
{
IGRlong		msg, sts;
struct	GRid	my_as_sup;

  surf_intersect();
  if( GRid_list.objid == NULL_OBJID ) return(0);
 

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1, &GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );



  if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }

  return(1);
}


/* ========================================================================= */

compute ()
{
IGRlong		msg, sts;
struct	GRid	my_as_sup;

  surf_intersect();

  if( GRid_list.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }
  return(1);
}

/* ========================================================================= */

surf_intersect()
{
 unsigned IGRchar	props;

 /* init of pointers */

# ifdef DEBUG3
  printf("surf_intersect begin\n"); 
# endif

  over0        = NULL;
  over1        = NULL;
  end_pts      = NULL;
  numpts       = NULL;
  pts          = NULL;
  par1         = NULL;
  par2         = NULL;
  bsp_surf1    = NULL;
  bsp_surf2    = NULL;
  bsp_curve    = NULL;
  nb_cvgp      = NULL;
  array        = NULL;
  comp_cv      = NULL;
  line	       = NULL;
  bnd_curve    = NULL;
  snb_int      = 0;
  nb_gpe       = 0;
  nb_create    = 0;
  added        = 0;

  close_cv = 0;
  open_cv  = 0;

  index_open[0] = -1;
  index_open[1] = -1;

  plane[0].point  = &plane_space[0];
  plane[0].normal = &plane_space[3];
  plane[1].point  = &plane_space[6];
  plane[1].normal = &plane_space[9];



  GRid_list.objid = NULL_OBJID;
  GRid_list.osnum = MOD_ENV.md_id.osnum;

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&num_temp),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);

  if(stat == OM_E_ABORT)  return(0);

  num_ent = num_temp -1;
# ifdef DEBUG1
  printf("intersect surf, num_ent: %d\n", num_ent);
# endif

  if (num_ent ==0) goto wrapup;

  nput = sizeof(basis_tol);

  gr$get_basis_tolerance(msg    = &msg, 
                         sizbuf = &nput, 
                         buffer = &basis_tol, 
                         nret   = &nret);
  nput = sizeof(cht_tol);

  gr$get_chord_height_tolerance(msg    = &msg, 
                         	sizbuf = &nput, 
                         	buffer = &cht_tol, 
                         	nret   = &nret);

# ifdef DEBUG1
  printf("basis_tolerance: %lf\n",basis_tol);
  printf("cht tol : %lf\n",cht_tol);
# endif


/* ----------------------------------------------------------------------- 

  		Retrieve the templates 
  
  ----------------------------------------------------------------------- */

  status = ci$send(msg = message ACcpx.ACfind_temp_struct(&msg,
                                                  "accuracy_factor",
                                                  (char *)&temp1_rts,
                                                  &MOD_ENV),
                       verbose = VERBOSE,
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );
  as$status();
  accuracy_factor =  temp1_rts.var.root_pm_st.value;

  if(accuracy_factor <= 0 || accuracy_factor > 1) 
    {
	printf("accuracy_factor must be include in ]0, 1]\n");
	goto wrapup;
    }


# ifdef DEBUG1
  printf("accuracy_factor: %lf\n",accuracy_factor);
  printf("cht tol : %lf\n",cht_tol);
# endif

  cht_tol = cht_tol / accuracy_factor ;

# ifdef DEBUG1
  printf("new cht tol : %lf\n",cht_tol);
# endif

  nput = sizeof(cht_tol);

  gr$put_chord_height_tolerance
                        (msg    = &msg,
                         sizbuf = &nput,
                         buffer = &cht_tol);


 for(i=0;i<num_ent;i=i+1)
   {
#    ifdef DEBUG1
     printf("Retrieve the template for the template \n");
#    endif

     msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,i+1,&SPROJ),
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );

     if(stat == 0 ) return(0);
     if(stat == 3 ) SUR[i] = SPROJ;
     else
      {
       /* DOES NOT WORK WITH OBJECTS BELONGING TO DIFFERENTS OS */
        stat = ci$send( msg = message ASnode.ASreturn_go( 
                                          &SUR[i], &mat_type[i], matrix ),
	      	        targetid = SPROJ.objid,
	                targetos = SPROJ.osnum );
        if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
      }

     /* we retrieve informations in two steps because the free pb if object 
     /* has been consumed */

#    ifdef DEBUG1
     printf("Retrieve the type of the element: %d, %d\n", SUR[i].objid,  
                                                         SUR[i].osnum);
#    endif

   } /* end for(i=0 ....) */


/* ----------------------------------------------------------------------- 

   we have (num_ent) objects that will give (num_ent-1) intersection cv
   we make intersection between support and surface i and create the
   intersection curve => curve[i-1] 

   ----------------------------------------------------------------------- */

 for(i=0;i<num_ent;i=i+1)
  {
    if(mat_type[i]!=2 /* MAIDMX */) 
     { 
      	  stat = ci$send( msg = message GRvg.GRgeomprops(&msg, &mat_type[i], 
					matrix,&properties),
	      	        targetid = SUR[i].objid,
	                targetos = SUR[i].osnum );
      	  if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
     }

#   ifdef DEBUG3
    printf("Retrieve the topologie of: %d, %d\n", SUR[i].objid,  SUR[i].osnum);
#   endif

    if(i==0)
     {
      /*| Only for the support */

      stat = ci$send( msg = message EMSsubbs.EMget_props(&msg, &props),
		verbose = VERBOSE,
              targetid = SUR[0].objid,
 	      targetos = SUR[0].osnum );
      if (!(stat&1)){ props = 0x00; }

	/*| copy du graphic */
      stat = ci$send(msg          = message GRgraphics.GRcopy(&msg,
                	                  &MOD_ENV,&MOD_ENV,
                        	          &(GRid_list.objid)),
		   targetid = SUR[0].objid,
		   targetos = SUR[0].osnum);
      as$status( sts = stat );
      GRid_list.osnum	= MOD_ENV.md_id.osnum;
      type_flag = SURF;
      bsp_curve = NULL;
      nb_sf1 = 0;
      stat = SMelem_(type_flag, &GRid_list, mat_type[i], matrix, &elem_type[0], 
		     &plane[0], &bsp_surf1, &bsp_curve, &nb_sf1);
      if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
      if(elem_type[0] == CURV) 
          {printf("ERROR: support cannot be a curve\n");goto wrapup; } 
      if(nb_sf1>1) {printf("support composite not implemented\n");goto wrapup;}

#     ifdef DEBUG
      if(bsp_surf1 != NULL )
       {
         
    	for(k=0;k<nb_sf1;k=k+1)
         printf("bsp_sf1 u_num_poles: %d, v_num_poles: %d\n",bsp_surf1[k]->u_num_poles,
		bsp_surf1[k]->v_num_poles);
       }
#     endif

      if(elem_type[0] == PLAN)
       {
        printf("error no plane but surface\n");
        goto wrapup;
       }
     }
    else 
     {
      /* i<>0 */
      if(SMIsKindOf(&SUR[i], OPP_VDSInfPl_class_id) ) type_flag = PLAN;
      else type_flag = SURF;


      bsp_curve = NULL;
      bsp_surf2 = NULL;
      nb_sf2 = 0;
      stat = SMelem_(type_flag, &SUR[i], mat_type[i], matrix, &elem_type[i], 
		     &plane[1], &bsp_surf2, &bsp_curve, &nb_sf2);
      if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 


      if(elem_type[i] == PLAN && !(SMIsKindOf(&SUR[i], OPP_VDSInfPl_class_id) ))
      {
        	printf("error no plane but surface\n");
        	goto wrapup;
      }

#     ifdef DEBUG
      if(bsp_surf2 != NULL)
       {
    	for(k=0;k<nb_sf2;k=k+1)
         printf("bsp_sf2 u_num_poles: %d, v_num_poles: %d\n",bsp_surf2[k]->u_num_poles,
		bsp_surf2[k]->v_num_poles);
       }
      if(elem_type[i] == PLAN ){
	if(SMIsKindOf(&SUR[i], OPP_VDSInfPl_class_id) )
          {
         	printf("plane[1].point: %lf, %lf, %lf\n",plane[1].point[0],
                	plane[1].point[1],plane[1].point[2]);
        	 printf("plane[1].normal: %lf, %lf, %lf\n",plane[1].normal[0],
	        	plane[1].normal[1],plane[1].normal[2]);
         }
	else{
        	printf("error no plane but surface\n");
        	goto wrapup;
       	}
      }
      if(elem_type[i] == CURV) 
                printf("curve.num_poles: %d\n",bsp_curve->num_poles);
#     endif
     }/* end else ... */

        /* keep a point on a surface to extract curve in good sens */

        if(elem_type[i] == PLAN)
         {
           point_on[3*i]   = plane[1].point[0];
           point_on[3*i+1] = plane[1].point[1];
           point_on[3*i+2] = plane[1].point[2];
         }
        else if(elem_type[i] == CURV)
         {
           point_on[3*i]   = bsp_curve->poles[0];
           point_on[3*i+1] = bsp_curve->poles[1];
           point_on[3*i+2] = bsp_curve->poles[2];
         }
        else if(elem_type[i] == SURF)
         {
	   if(i==0)
	    {
           	point_on[3*i]   = bsp_surf1[0]->poles[0];
           	point_on[3*i+1] = bsp_surf1[0]->poles[1];
           	point_on[3*i+2] = bsp_surf1[0]->poles[2];
		
            }
	   else
            {
           	point_on[3*i]   = bsp_surf2[0]->poles[0];
           	point_on[3*i+1] = bsp_surf2[0]->poles[1];
           	point_on[3*i+2] = bsp_surf2[0]->poles[2];
	    }
       
         }
    if(i==0) continue;

    if (elem_type[i] == CURV )
	if( bsp_curve->phy_closed == TRUE && num_ent !=2)
     {
       printf("ERROR:the curve is closed and need to be alone on the support\n");
       goto wrapup;
     } 

#   ifdef DEBUG
    printf("\n\nCompute intersection between the support and the surface # %d\n", i);
    printf("elem_type[0]: %d\n",elem_type[0]);
    printf("elem_type[i]: %d\n",elem_type[i]);
#   endif
    numgrps = 0;
    num_pts = 0;
    par1 	 = NULL;
    par2         = NULL;
    numpts       = NULL;
    pts          = NULL;
    if(elem_type[0] == SURF)
     {
         if(elem_type[i] == PLAN)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, PLAN, NULL, &plane[1],1,
                         &numgrps, &numpts, &pts , &par1, NULL);
          }
         else if(elem_type[i] == SURF)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, SURF, bsp_surf2, NULL,1,
                         &numgrps, &numpts, &pts , &par1, &par2);

          }
         else if(elem_type[i] == COMP_SF)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, COMP_SF, bsp_surf2, NULL,nb_sf2,
                         &numgrps, &numpts, &pts , &par1, NULL);

          }
         else
          {
#           ifdef DEBUG3
            printf("project curve on surface\n");
#           endif

            BSsfnormal(bsp_surf1[0], dirvect, &rc);
            BSpjcvtsf(bsp_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
            if (rc!= BSSUCC)
             { 
               printf("surf_int, Bad projection on the surface: %d\n",rc);
               numgrps = 0;
             }
        
          }
     }
    else 
     {
        printf("invalid support, must be a surface\n");
        goto wrapup;
     } 
    if(!(stat&1))
     {
        printf("surf_int: ERROR in VDint function\n");
        goto wrapup;
     }
    if(numgrps < 1) 
     {
#       ifdef DEBUG3
        printf("surf_int: (numgrp<1)no intersection found with the %d surface\n",i);
#       endif
        curve[i-1] = NULL;
        VDSfree(nb_sf2,&bsp_surf2); 
        if(bsp_curve != NULL) {free(bsp_curve); bsp_curve = NULL;}
        if(numpts != NULL)    { free(numpts)  ; numpts    = NULL; }
        VDSfree(numgrps,&pts);
        VDSfree(numgrps,&par1);
        VDSfree(numgrps,&par2);
        continue;
     }
    num_pts = numpts[0];

#    ifdef DEBUG
     printf("surfaces intersect stat = %d, numgrps= %d\n",rc,numgrps);
     printf("num_pts: %d\n",num_pts);
     for (l=0; l<numgrps; l=l+1)
      {
        if(numpts != NULL)
         {  
  	   printf("num_pts[%d] = %d\n",l,numpts[l]);
	   for(k=0;k<numpts[l] ;k=k+1)
	    { 
	      if(pts != NULL) printf("point : %lf, %lf, %lf\n",
                                     pts[l][3*k],pts[l][3*k+1],pts[l][3*k+2]);
	    }
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
              if(par1 != NULL) printf("par1: %lf, %lf\n", par1[l][2*k], par1[l][2*k+1]);
              if(par2 != NULL) printf("par2: %lf, %lf\n", par2[l][2*k], par2[l][2*k+1]);
	    }
         }
       }
#    endif

if(numgrps > 1)
 {
   /* ----- 
     make a unique gpe if possible (because of bug in BS intersect function
     that returns sometimes 2 gpes of intersections that are contiguous instead 
     of giving only one gpe that will gather the 2)
      ------ */

   Xnumpts	= NULL;
   Xpts		= NULL;
   Xpar1	= NULL;
   Xpar2	= NULL;

   stat = VDSorder_pt(numgrps, &numpts[0], pts, par1, par2, &Xnumgrps, 
		       &Xnumpts, &Xpts, &Xpar1, &Xpar2);
   if(!(stat & 1)){printf("ERRROR VDSorder_pts\n"); goto wrapup;}

   if(Xnumgrps != 1)
    {
      /*|cannot make a unique gpe */
      if(Xnumpts != NULL) { free(Xnumpts); Xnumpts = NULL; }
      printf("WARNING: the intersection has more than one groupe, we only take the first one\n");
      VDSfree(Xnumgrps,&Xpts);
      VDSfree(Xnumgrps,&Xpar1);
      VDSfree(Xnumgrps,&Xpar2);
    }
   else
    {
      if(numpts != NULL) { free(numpts); numpts = NULL; }
      VDSfree(numgrps,&pts);
      VDSfree(numgrps,&par1);
      VDSfree(numgrps,&par2);
      numgrps = Xnumgrps;
      numpts  = Xnumpts;
      pts     = Xpts;
      par1    = Xpar1;      
      par2    = Xpar2;      
    }
#  ifdef DEBUG
   printf("total result ====================\n");
     for (l=0; l<numgrps; l=l+1)
      {
        if(numpts != NULL)
         {  
  	   printf("num_pts[%d] = %d\n",l,numpts[l]);
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
	      if(pts != NULL) printf("point : %lf, %lf, %lf\n",
                                     pts[l][3*k],pts[l][3*k+1],pts[l][3*k+2]);
	    }
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
              if(par1 != NULL) printf("par1: %lf, %lf\n", par1[l][2*k], par1[l][2*k+1]);
              if(par2 != NULL) printf("par2: %lf, %lf\n", par2[l][2*k], par2[l][2*k+1]);
	    }
         }
      }
#  endif
 }

 num_pts = numpts[0];

 save_pts[6*(i-1)]   = pts[0][0]; 
 save_pts[6*(i-1)+1] = pts[0][1];  		/* first point of curve[i-1] */
 save_pts[6*(i-1)+2] = pts[0][2]; 

 save_pts[6*(i-1)+3] = pts[0][3*(numpts[0]-1)]; 
 save_pts[6*(i-1)+4] = pts[0][3*(numpts[0]-1)+1]; /* last point of curve[i-1] */
 save_pts[6*(i-1)+5] = pts[0][3*(numpts[0]-1)+2]; 

#ifdef DEBUG
 printf("save_pts[%d]\n",6*(i-1));
 printf("save_pts: %lf, %lf, %lf\n",save_pts[6*(i-1)],
                                    save_pts[6*(i-1)+1],save_pts[6*(i-1)+2]);
 printf("save_pts: %lf, %lf, %lf\n",save_pts[6*(i-1)+3],
                                    save_pts[6*(i-1)+4],save_pts[6*(i-1)+5]);
 printf(" \n");
#endif

 VDSfree(nb_sf2,&bsp_surf2); 
 if(bsp_curve != NULL) {free(bsp_curve);bsp_curve = NULL;}
 curve[i-1] = NULL;

 /* ---------------
    Allocate the space for the bspline curve 
    WARNING, we always take only the first intersection 
    ------------ */
#   ifdef DEBUG3
    printf("define curve for surface/anything\n");
#   endif

    stat = VDSfill_curve(num_pts,  NULL, par1[0], &curve[i-1]);
    if(!(stat & 1)){printf("ERROR VDSfill_curve\n");goto wrapup;}
      
#ifdef DEBUG
 for(k=0;k<num_pts && k<10;k=k+1)
        printf("pts of curve: %lf, %lf, %lf\n", 
                curve[i-1]->poles[3*k],curve[i-1]->poles[3*k+1],curve[i-1]->poles[3*k+2]);
    
 for(k=0;k<num_pts + ORDER && k<10;k=k+1) printf("knot: %lf\n",curve[i-1]->knots[k]);

#endif

 if (close_cv)     	curve[i-1]->phy_closed  = TRUE; 
 else	      		curve[i-1]->phy_closed  = FALSE;   
 curve[i-1]->weights     = NULL;
 curve[i-1]->planar      = TRUE;
 curve[i-1]->non_uniform = FALSE;
 curve[i-1]->periodic    = FALSE;

 /* Deallocation of the pointeurs */

 if(numpts != NULL) { free(numpts); numpts = NULL; }
 VDSfree(numgrps,&pts);
 VDSfree(numgrps,&par1);
 VDSfree(numgrps,&par2);

 }  /* End of  for(i=0;i<num_ent;i=i+1) */

/* -------------------------------------------------------------------- 

   compute the intersection points between each curve and its successor
   in the parameter definition of the support when it is a surface, 
   in RxRxR for a plane.

   The intersection point (curve[i], curve[i+1]) will have p_par1[i+1]
   param on curve i and p_par2[i+1] on curve i+1. The last intersection 
   point (curve[num_ent-2], curve[0]) will have p_par1[0] on curve num_ent-2
   and p_par2[0] on curve 0.

   We don't treat multiple intersections except in the case of 2 curves
   intersecting each other 2 times (creating a loop) 

   -------------------------------------------------------------------- */


#ifdef DEBUG3
 for(i=0;i<num_ent-1;i=i+1)
    if(curve[i] == NULL) printf("curve[%d] est NULL\n",i);
#endif

 num_merge = 0;
 i_onecv = -1;
 k = 0;
 for(i=0;i<num_ent-1;i=i+1)
  { 
    if(curve[i] != NULL) 
       {tab_cv[k] = i;k = k+ 1;num_merge = num_merge + 1;i_onecv = i; }
#   ifdef DEBUG3
    printf("i_onecv: %d\n",i_onecv);
#   endif
  }

# ifdef DEBUG
  printf("num_merge: %d\n",num_merge);
  for(i=0;i<num_merge;i=i+1) printf("tab[%d]: %d\n",i,tab_cv[i]);
# endif


  if(num_merge == 0)
   {
    printf("ERROR:no intersection between support and any surface\n");
    goto wrapup;
   }
  if(num_merge == 1)
   {
    
#      	ifdef DEBUG
	printf("num_merge == 1  curve %d\n",i_onecv);
#       endif

    	coef = 0;
        for(k=0;k<3;k=k+1) 
        coef = coef + fabs(curve[i_onecv]->poles[k] - 
			      curve[i_onecv]->poles[3*(curve[i_onecv]->num_poles-1)+k]);
#      	ifdef DEBUG
	printf("close curve ?, coef: %lf\n",coef);
#       endif

	if (coef < basis_tol)
	  {
#       	  ifdef DEBUG
		  printf("close curve\n");
#       	  endif
		  close_cv = 1;
       	  }
   }
  two_intersect = 0;

no_intersect = 0;
no_last_intersect = 0;
open_cv  = 0;
i=-1;

#   ifdef DEBUG3
    printf("COMPUTE THE INTERSECTION POINTS of curves\n");
#   endif

while(i<num_merge-1)
  {
    p_par1[i+1]  = NULL;
    p_par2[i+1]  = NULL;
    int_pts[i+1] = NULL;
    over0        = NULL;
    over1        = NULL;
    end_pts      = NULL;

#   ifdef DEBUG4
    printf("i: %d, num_merge: %d ...................\n",i,num_merge);
    printf("no_int: %d, no_last: %d\n",no_intersect,no_last_intersect);
    printf("open_cv: %d\n",open_cv);
#   endif

    if(close_cv) break;
    if(num_merge == 1) break;



    /* ------------------------------------------------------------------

       if num_ent = 3 ie 2 curve on support, case of 2 intersections is
       treated with one cvcv_int 

       ------------------------------------------------------------------ */

    if(i==-1 && num_merge == 2) {i=i+1;continue;}/*2 cv on support */
    n_int = 0;
    if(i==-1 )
     {
#   	 ifdef DEBUG5
         printf("intersect cv[%d] et cv[%d]\n",tab_cv[num_merge-1],tab_cv[0]);
#   	 endif

         BScvcv_int(&rc, curve[tab_cv[num_merge-1]], curve[tab_cv[0]], &n_int, 
		    &int_pts[0], &p_par1[0], &p_par2[0], &n_over, &end_pts, 
		    &over0, &over1);
     }
    else 
     {
#   	 ifdef DEBUG5
         printf("intersect cv[%d] et cv[%d]\n",tab_cv[i],tab_cv[i+1]);
#   	 endif
         BScvcv_int(&rc, curve[tab_cv[i]], curve[tab_cv[i+1]], &n_int, 
		    &int_pts[i+1], &p_par1[i+1], &p_par2[i+1], &n_over, 
		    &end_pts, &over0, &over1);
     }


    if(rc != BSSUCC || n_over > 0 || (n_int < 1 && open_cv > 0))
     {
       printf("surf_int, ERROR bad curve intersection (%d)\n", i+1);
       printf("rc: %d, nb_int: %d\n",rc,n_int);

       /* WE must deallocate the stuff */

       for(k=0; k<=i+1; k=k+1)
        {
         if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
         if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	 if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
        }
       for(k=0; k<num_ent-1; k=k+1)
        {
	 if(curve[k] != NULL) 
          {
            BSfreecv(&rc, curve[k]);	
            curve[k]=NULL;
	    if (rc !=BSSUCC && rc!=BSNULL) 
		{printf("BSfreecv(curve) fail rc: %d\n",rc);goto wrapup;}
	  }
         }
       goto wrapup;
      }
    if(num_merge == 2 && n_int < 2)
      {
#       ifdef DEBUG4
        printf("num_merge == 2 && n_int < 2\n");
#       endif
        if(n_int < 1)
           {
	     printf("2 cv without any intersection,cannot close the curve\n");
	     goto wrapup;
           }
	open_cv = open_cv + 1;
	index_open[0] = tab_cv[i];
	index_open[1] = tab_cv[i+1];
        break;
      } 
    else if(n_int < 1 )
      {
#         ifdef DEBUG4
          printf("n_int < 1: %d\n",n_int);
          if(i != -1)printf("cv (%d) & cv (%d) n'ont pas d'intersection\n",tab_cv[i],tab_cv[i+1]);
#         endif

          if(i == -1)
           {
#            ifdef DEBUG4
             printf("i==-1\n");
#            endif
	     index_open[0] = tab_cv[0];
	     index_open[1] = tab_cv[num_merge-1];
             no_last_intersect = 1;
	     i = i+1;
	     continue;
           }
	  else if(no_intersect==0 && !(i == 0 && no_last_intersect) && i!=num_merge -2)
           {
#   	     ifdef DEBUG4
             printf("met no_intersect to 1\n");
#            endif
	     no_intersect = 1;
             index_open[0] = tab_cv[i];
             index_open[1] = tab_cv[i+1];
	     i = i+1;
	     continue;
           }
          else if((no_last_intersect && i==0) || no_intersect )
           {
#   	        ifdef DEBUG4
	        printf("consider curve [%d] as NULL\n",tab_cv[i]);
#   	        endif
                num_merge = num_merge - 1;
                for(k=i;k<num_merge; k=k+1) 
                 {
                  tab_cv[k] = tab_cv[k+1];
#   	          ifdef DEBUG4
                  printf("k: %d, tab[k]: %d\n",k,tab_cv[k]);
#   	          endif
                 }
#   	        ifdef DEBUG4
                printf("num_merge after suppressing 1 index: %d\n",num_merge); 
#   	        endif
		if(no_last_intersect && i==0) no_last_intersect = 0;
                if(no_intersect) no_intersect = 0;
	        i = i-1;
	        continue;
           } 
          else 
           {
#   	     ifdef DEBUG4
             printf("else\n");
#   	     endif
	     if(i== num_merge-2 && !no_last_intersect)
              {
#   	        ifdef DEBUG4
                printf("i== num_merge-2 && !no_last_intersect\n");
#   	        endif
                open_cv = open_cv + 1;
	        index_open[0] = tab_cv[i];
	        index_open[1] = tab_cv[i+1];
                i=i+1;
                break;
              }
	     else if(i== num_merge-2 && no_last_intersect)
              {
#   	        ifdef DEBUG4
                printf("suppress curve n-1 and make intersect (n-2 & 0)\n");
#   		endif
                no_last_intersect = 0;
                num_merge = num_merge - 1;
#   	        ifdef DEBUG4
                printf("num_merge: %d\n",num_merge);
                printf("intersect cv[%d] & cv [%d]\n",tab_cv[num_merge-1],tab_cv[0]);
#   		endif
                BScvcv_int(&rc, curve[tab_cv[num_merge-1]], curve[tab_cv[0]], 
			   &n_int, &int_pts[0], &p_par1[0], &p_par2[0], 
			   &n_over, &end_pts, &over0, &over1);

                if(rc != BSSUCC || n_over > 0 || (n_int < 1 && open_cv > 0))
                 {
                   printf("surf_int, ERROR bad curve intersection (%d)\n", i+1);
                   printf("rc: %d, nb_int: %d\n",rc,n_int);

                   for(k=0; k<=i+1; k=k+1)
                    {
                     if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
                     if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	             if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
                    }
                   for(k=0; k<num_ent-1; k=k+1)
                    {
	             if(curve[k] != NULL) 
                      {
                        BSfreecv(&rc, curve[k]);	
                        curve[k]=NULL;
	                if (rc !=BSSUCC && rc!=BSNULL) 
		            {printf("BSfreecv(curve) fail rc: %d\n",rc);goto wrapup;}
	              }
                     }
                   goto wrapup;
                  }
                 else if(n_int < 1 )
      		  {
#   	           ifdef DEBUG4
          	   printf("n-2  & 0  n'ont pas d'intersection\n");
#   		   endif
	           open_cv =  open_cv + 1;
	           index_open[0] = tab_cv[num_merge-1];
	           index_open[1] = tab_cv[0];
                   break;
                  }
                 else
                  {
#   		   ifdef DEBUG4
                   printf("n_int > 1\n");
#   		   endif
		   i = i+1;
                   break;
                  }
              }

           }
      }
     else 
      { 
#      ifdef DEBUG4
       printf(" n_int >= 1 : %d\n",n_int);
#      endif
       if(n_int > 2) 
        {
          printf("surf_int, Error more than two intersections\n");
          /* WE must deallocate the stuff */
          for(k=0; k<=i+1; k=k+1)
           {
             if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
             if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	     if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
           }
          for(k=0; k<num_ent-1; k=k+1)
           {
	     if(curve[k]!=NULL) 
              {
                BSfreecv(&rc, curve[k]); 
                curve[k]=NULL;
	        if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail\n");goto wrapup;}
              }
           }
          goto wrapup;
        }/* end n_int >2 */
       else if(n_int == 2)
        {
 #       ifdef DEBUG4
         printf(" n_int == 2 \n");
 #       endif
         if(num_merge > 2)
           {
             printf("surf_int, 2 intersections, NOT yet implemented\n");
             /* WE must deallocate the stuff */

             for(k=0; k<=i+1; k=k+1)
              {
   	       if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
               if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
               if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
              }
             for(k=0; k<num_ent-1; k=k+1)
              {
	       if(curve[k]!=NULL) 
                {
                  BSfreecv(&rc, curve[k]); 
                  curve[k]=NULL;
	          if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail\n");goto wrapup;}
                }
              }
             goto wrapup;
           }/* n_int =2 & more than 2 curves */
          else
           {
#           ifdef DEBUG4
            printf(" Specific case, two curves and two intersections \n");
#           endif

	    two_intersect=1;
            p_curve[0] = NULL;
            order 	   = curve[0]->order;
            BSalloccv(order, curve[0]->num_poles + 2 * order - 1, 
                      curve[0]->rational, curve[0]->num_boundaries ,&p_curve[0], 
                      &rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
               printf("surf_int, Bad allocation for the curves\n");
               for(k=0; k<=i+1; k=k+1)
                {
   	         if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
                 if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
                 if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
                }
               for(k=0; k<num_ent-1; k=k+1)
                {
	         if(curve[k] != NULL) 
                  {
                     BSfreecv(&rc, curve[k]); 
                     curve[k]=NULL;
	             if (rc !=BSSUCC && rc!=BSNULL) 
                        {printf("BSfreecv(curve) fail\n");goto wrapup;}
	          }
                }
               goto wrapup;
             }
            d_par=(p_par1[1][1]+p_par1[1][0])/2;
            if(p_par1[1][1] > p_par1[1][0]) rev = 1;
            else		                 rev = 0;

#           ifdef DEBUG4

            printf("p_par1[1][1]: %lf, p_par1[1][0]: %lf\n",p_par1[1][1],p_par1[1][0]);
            printf("curve 0 d_par: %lf\n",d_par);
#           endif

            BSpartofcv(&rc, curve[0], p_par1[1][1], d_par, p_par1[1][0], p_curve[0]);
            if(rc != BSSUCC) 
             { 
              printf("surf_int, Bad extraction of the part of curve 1\n");
	      if(p_curve[0]!=NULL)
               {
                 BSfreecv(&rc, p_curve[0]); 
                 p_curve[0]=NULL;
	         if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail\n");goto wrapup;}
               }
              goto wrapup;
             }
            if(p_par1[1]   != NULL) {free(p_par1[1]); p_par1[1] = NULL;}
	    if(curve[0]!=NULL)
             {
               BSfreecv(&rc, curve[0]);
               curve[0]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");goto wrapup;}
             }

            if(rev)   
	     {
	       BSrev_cv(&rc, p_curve[0]);
               if(rc != BSSUCC) 
                {
                  printf("surf_int, ERROR cannot reverse the curve\n");
       	          if(p_curve[0]!=NULL)
                   {
                     BSfreecv(&rc, p_curve[0]);
                     p_curve[0] = NULL;
       		     if (rc !=BSSUCC && rc!=BSNULL) 
			{printf("BSfreecv(curve) fail\n");goto wrapup;}
                   }
       	          goto wrapup;
                }
	     }
#           ifdef DEBUG4
            printf("\n\n");
            printf("num_poles: %d\n",p_curve[0]->num_poles);
            for(k=0;k<p_curve[0]->num_poles ;k=k+1)
            printf("poles of the part curve 0: %lf, %lf, %lf\n",p_curve[0]->poles[3*k],  
            p_curve[0]->poles[3*k+1],p_curve[0]->poles[3*k+2]);
#           endif
            if(p_curve[0]->rational)
             {
               for(k=0;k<p_curve[0]->num_poles;k=k+1)
	        {
		   p_curve[0]->poles[3*k]   = p_curve[0]->poles[3*k]/
						p_curve[0]->weights[k];
		   p_curve[0]->poles[3*k+1] = p_curve[0]->poles[3*k+1]/
						p_curve[0]->weights[k];
		   p_curve[0]->poles[3*k+2] = p_curve[0]->poles[3*k+2]/
						p_curve[0]->weights[k];
	        }
	       p_curve[0]->rational = 0;
	       if(p_curve[0]->weights)
	         {
		   free(p_curve[0]->weights);
		   p_curve[0]->weights  = NULL;
	         }
             }

            p_curve[1] = NULL;
            order = curve[1]->order;
            BSalloccv(order, curve[1]->num_poles + 2 * order - 1,
		   curve[1]->rational, curve[1]->num_boundaries, 
		   &p_curve[1], &rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
               printf("surf_int, Bad allocation for the curves\n");
               for(k=0; k<=i+1; k=k+1)
                {
   	         if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
                 if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
                 if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
                }
               for(k=0; k<num_ent-1; k=k+1)
                {
	         if(curve[k] != NULL) 
                   {
                      BSfreecv(&rc, curve[k]); 
                      curve[k]=NULL;
	              if (rc !=BSSUCC && rc!=BSNULL) 
			{printf("BSfreecv(curve) fail\n");goto wrapup;}
		   }
                }
               goto wrapup;
             }
            d_par=(p_par2[1][0]+p_par2[1][1])/2;
            if( p_par2[1][0]> p_par2[1][1]) rev = 1;
            else		                rev = 0;

# 	    ifdef DEBUG4
            printf("p_par2[1][0]: %lf, p_par2[1][1]: %lf\n",p_par2[1][0],p_par2[1][1]);
            printf("curve 1 d_par: %lf\n",d_par);
# 	    endif
     
            BSpartofcv(&rc, curve[1],p_par2[1][0], d_par,p_par2[1][1], p_curve[1]);
            if(rc != BSSUCC) 
             { 
              printf("surf_int, Bad extraction of the part of curve 0\n");
	      if(p_curve[1]!=NULL) 
                {
                  BSfreecv(&rc, p_curve[1]);
	          p_curve[1]=NULL;
	          if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail\n");goto wrapup;}
                }
              goto wrapup;
             }
            if(p_par2[1]   != NULL) {free(p_par2[1]); p_par2[1] = NULL;}
	    if(curve[1]!=NULL) 
             {
               BSfreecv(&rc, curve[1]);
               curve[1]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                  {printf("BSfreecv(curve) fail\n");goto wrapup;}
             }
            if(rev)     
	     {
	       BSrev_cv(&rc, p_curve[1]);
               if(rc != BSSUCC) 
                 { 
       		   printf("surf_int, ERROR cannot reverse the curve\n");
       		   if(p_curve[1]!=NULL) 
                     {
                       BSfreecv(&rc, p_curve[1]);
                       p_curve[1] = NULL;
       		       if (rc !=BSSUCC && rc!=BSNULL) 
                          {printf("BSfreecv(curve) fail\n");goto wrapup;}
		      }
       		   goto wrapup;
                 }
	     }
#           ifdef DEBUG4
            for(k=0;k<p_curve[1]->num_poles ;k=k+1)
            printf("poles of the part_curve 1: %lf, %lf, %lf\n", p_curve[1]->poles[3*k], p_curve[1]->poles[3*k+1],p_curve[1]->poles[3*k+2]);
#           endif
            if(p_curve[1]->rational)
             {
               for(k=0;k<p_curve[1]->num_poles;k=k+1)
	        {
		   p_curve[1]->poles[3*k]   = p_curve[1]->poles[3*k]/
						p_curve[1]->weights[k];
		   p_curve[1]->poles[3*k+1] = p_curve[1]->poles[3*k+1]/
						p_curve[1]->weights[k];
		   p_curve[1]->poles[3*k+2] = p_curve[1]->poles[3*k+2]/
						p_curve[1]->weights[k];
	        }
	       p_curve[1]->rational = 0;
	       if(p_curve[1]->weights)
	         {
		   free(p_curve[1]->weights);
		   p_curve[1]->weights  = NULL;
	         }
             }/* rational */

            if(p_par1[0] != NULL) {free(p_par1[0]) ; p_par1[0]  = NULL;}
            if(p_par2[0] != NULL) {free(p_par2[0]) ; p_par2[0]  = NULL;}
   	    if(int_pts[0]!= NULL) {free(int_pts[0]); int_pts[0] = NULL;}
   	    if(over0     != NULL) {free(over0)     ; over0      = NULL;}
   	    if(over1     != NULL) {free(over1)     ; over1      = NULL;}
   	    if(end_pts   != NULL) {free(end_pts)   ; end_pts    = NULL;}
            break;
           } /* end 2 cv, 2 intersections */
        } /* n_int == 2 */

       else if(( no_intersect && i!=0)|| (i==num_merge-2 && no_last_intersect))
        {
#         ifdef DEBUG4
	  printf("index %d a une intersect mais pas avec la pcdte\n",i);
#         endif
          open_cv =  open_cv + 1;
          if(i==num_merge-2 && no_last_intersect && no_intersect)
              {
		printf("more than one opening, cannot close cv\n");
		goto wrapup;
              }
	  else if(i==num_merge-2 && no_last_intersect)
            {
	     index_open[0] = tab_cv[num_merge-1];
	     index_open[1] = tab_cv[0];
            }
          else
            {
	     index_open[0] = tab_cv[i-1];
	     index_open[1] = tab_cv[i];
            }
          i=i+1;
#         ifdef DEBUG4
          printf("index_open: %d, %d\n",index_open[0],index_open[1]);
#         endif
	  if(i==num_merge-2 && no_last_intersect) no_last_intersect = 0;
          if( no_intersect && i!=0)               no_intersect = 0;
	}/* end if( no_intersect && i!=0||i==num_merge-2 && no_last_intersect)*/
      else
       {
#        ifdef DEBUG5
         printf("good intersection\n");
         printf("number of intersection: %d, de over: %d\n", n_int, n_over);
         for(k=0; k<n_int && k<10; k=k+1)
          {
            printf("coord sur le sup: %lf, %lf, %lf\n",int_pts[i+1][3*k],int_pts[i+1][3*k+1],int_pts[i+1][3*k+2]);
            printf("param: %lf\n",   p_par1[i+1][k]);
            printf("param: %lf\n\n", p_par2[i+1][k]);
          }
#        endif
	i=i+1;
       }
      }/* end else de n_int > 1*/

   if(over0   != NULL) {free(over0)  ; over0   = NULL;}
   if(over1   != NULL) {free(over1)  ; over1   = NULL;}
   if(end_pts != NULL) {free(end_pts); end_pts = NULL;}
   } /* End of   while i < num_merge-1 */

# ifdef DEBUG4
  printf("end while no_intersect: %d, no_last: %d, open_cv: %d\n",no_intersect,no_last_intersect, open_cv);
  for(i=0;i<num_merge;i=i+1) printf("tab[%d]: %d\n",i,tab_cv[i]);
# endif

  if(no_intersect ) open_cv =  open_cv + 1;
# ifdef DEBUG4
  printf("open_cv: %d\n",open_cv);
  if(open_cv)  printf("index_open: %d, %d\n",index_open[0],index_open[1]);
# endif
  if(open_cv > 1) 
      { 
        printf("more than one opening in the curve, cannot close\n");
        goto wrapup;
      }
  
nb_poles   =  0;
found      =  0;
index_NULL = -1;
cv0pt0	   =  1;
cv0pt1	   =  1;
cv1pt0	   =  1;
cv1pt1	   =  1;

if ((!two_intersect) && (open_cv || (num_merge == 1 && !close_cv)) )
{
#ifdef DEBUG5
 printf("\ntry to find the boundary of the surface that close the curve\n\n");
#endif

 p_par10  = NULL;
 p_par20  = NULL;
 int_pts0 = NULL;
 p_par11  = NULL;
 p_par21  = NULL;
 int_pts1 = NULL;
 over0    = NULL;
 over1    = NULL;
 end_pts  = NULL;
 nb_sol   = 1; 
 
 if(num_merge == 1 && !close_cv)
  {
#   ifdef DEBUG5
    printf("num_merge == 1 && !close_cv\n");
#   endif
    
    if(curve[tab_cv[0]]->poles[0] == 0 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)] == 0 )
     {
          	opt      = 1;		/* u cst */
          	value    = 0.; 
		order    = bsp_surf1[0]->v_order;
		nb_poles = bsp_surf1[0]->v_num_poles ;
     }
    else if(curve[tab_cv[0]]->poles[0] == 1 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)] == 1 )
     {
          	opt      = 1;		/* u cst */
          	value    = 1.;    
		order    = bsp_surf1[0]->v_order;
		nb_poles = bsp_surf1[0]->v_num_poles ;
     }
    else if(curve[tab_cv[0]]->poles[1] == 0 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)+1] == 0 )
     {
          	opt      = 2;		/* v cst */
          	value    = 0.;    
		order    = bsp_surf1[0]->u_order;
		nb_poles = bsp_surf1[0]->u_num_poles ;
     }
    else if(curve[tab_cv[0]]->poles[1] == 1 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)+1] == 1 )
     {
          	opt      = 2;		/* v cst */
          	value    = 1.;    
		order    = bsp_surf1[0]->u_order;
		nb_poles = bsp_surf1[0]->u_num_poles ;
     }
    else
     {
      		printf("cannot close the only curve\n");
		goto wrapup;
     }
    tst_plan = FALSE;
    bnd_curve = NULL;
    BSalloccv(order, nb_poles , bsp_surf1[0]->rational, 0,  &bnd_curve, &rc);
    if(rc != BSSUCC && rc!=BSNULL) 
       	  { 
            printf("surf_int, Bad allocation for bnd_curve\n");
	    goto wrapup;
	  }
    BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,bnd_curve);
    if(rc != BSSUCC){printf("ERROR  BSconstprcv: %d\n",rc);goto wrapup;}

#   ifdef DEBUG5
    printf("bnd_curve result ----------\n");
    printf("nb_pole: %d\n",bnd_curve->num_poles);
    for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#   endif

#   ifdef DEBUG5
    printf("transform curve %d to param by project \n",i);
#   endif
    numgrps = 0;
    numpts  = NULL;
    pts     = NULL;
    par1    = NULL;

    BSsfnormal(bsp_surf1[0], dirvect, &rc);
    BSpjcvtsf(bnd_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
    if (rc!= BSSUCC || numgrps >1)
            { 
               printf("surf_int, Bad projection on the surface: %d\n",rc);
               goto wrapup;
            } 	
    nb_poles = numpts[0];
    if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve);bnd_curve =NULL;}
    stat = VDSfill_curve(nb_poles, NULL, par1[0], &bnd_curve);
    if(!(stat & 1)){printf("ERROR VDSfill_curve\n");goto wrapup;}
    VDSfree(numgrps,&par1);
    VDSfree(numgrps,&pts);
    if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}

#   ifdef DEBUG5
    printf("bnd_curve result param ----------\n");
    printf("nb_pole: %d\n",bnd_curve->num_poles);
    for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#   endif

#   ifdef DEBUG5
    printf("intersect bnd avec curve[0] ----------\n"); 
#   endif

    BScvcv_int(&rc, bnd_curve, curve[tab_cv[0]], &n_int0, &int_pts0, 
     	       &p_par10, &p_par20, &n_over, &end_pts, &over0, &over1);

    if(rc != BSSUCC || n_over > 0)
	      {
                 printf(" ERROR in BScvcv_int \n");
	         goto wrapup;
	      }
    if(n_int0 < 2 )
              {
                printf("bnd_curve & cv[0] ont moins de 2 intersection\n");
 		printf("cannot close the curve\n");
		goto wrapup;
              }
    if(over0     != NULL) {free(over0)  ; over0   = NULL;}
    if(over1     != NULL) {free(over1)  ; over1   = NULL;}
    if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
    found = 1;
  }
 else
  {

#  ifdef DEBUG5
   printf("find the number of solution to close the curve\n");

   printf("index 0: %d\n",index_open[0]);
   printf("index 1: %d\n",index_open[1]);
   printf("cv0pt0: %lf, %lf\n",curve[index_open[0]]->poles[0],curve[index_open[0]]->poles[1]);
   printf("cv0pt1: %lf, %lf\n",curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)],
              curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)+1]);
   printf("cv1pt0: %lf, %lf\n",curve[index_open[1]]->poles[0],curve[index_open[1]]->poles[1]);
   printf("cv1pt1: %lf, %lf\n",curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)],
              curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)+1]);
#  endif

   if(curve[index_open[0]]->poles[0] != 0 && curve[index_open[0]]->poles[0] != 1
      && curve[index_open[0]]->poles[1] != 0 && curve[index_open[0]]->poles[1] != 1)
    {
#     ifdef DEBUG5
      printf("open 0 pt0 is not on the border of the surface\n");
#     endif

      cv0pt0 = 0;
    }
   if(curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)] != 0 
    && curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)] != 1
    && curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)+1] != 0
    && curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)+1] != 1)
    {
#     ifdef DEBUG5
      printf("open 0 pt1 is not on the border of the surface\n");
#     endif

      cv0pt1 = 0;
    }
   if(curve[index_open[1]]->poles[0] != 0 && curve[index_open[1]]->poles[0] != 1
      && curve[index_open[1]]->poles[1] != 0 && curve[index_open[1]]->poles[1] != 1)
    {
#     ifdef DEBUG5
      printf("open 1 pt0 is not on the border of the surface\n");
#     endif

      cv1pt0 = 0;
    }
   if(curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)] != 0 
    && curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)] != 1
    && curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)+1] != 0
    && curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)+1] != 1)

    {
#     ifdef DEBUG5
      printf("open 1 pt1 is not on the border of the surface\n");
#     endif

      cv1pt1 = 0;
    }


   if( (!cv0pt0 && !cv0pt1) || (!cv1pt0 && !cv1pt1) )
    {
      printf("one curve doesn't intersect the border of the surface\n");
      goto wrapup;
    }
   else if( cv0pt0 && cv0pt1 && cv1pt0 && cv1pt1) nb_sol = 2;
   else 					  nb_sol = 1;
  }

   if(nb_sol == 2)
    {
#       ifdef DEBUG5
      	printf("\n nb_sol = 2 close the curve with the bnd the nearest\n\n");
#       endif

      	if(index_open[0] != num_ent - 2) index_NULL = index_open[0]+1;
      	else			         index_NULL = 0;

#       ifdef DEBUG5
      	printf("index of a null curve: %d\n",index_NULL);
#       endif

       	pt0[0] = save_pts[6*index_open[0]];
       	pt0[1] = save_pts[6*index_open[0]+1];
       	pt0[2] = save_pts[6*index_open[0]+2];

       	pt1[0] = save_pts[6*index_open[0]+3];
       	pt1[1] = save_pts[6*index_open[0]+4];
       	pt1[2] = save_pts[6*index_open[0]+5];

#       ifdef DEBUG5
	printf("point_on: %lf, %lf, %lf\n",point_on[3*(index_NULL+1)],
		point_on[3*(index_NULL+1)+1],point_on[3*(index_NULL+1)+2]);
#       endif
 
       	dist1 = VDSdist2(&point_on[3*(index_NULL+1)], &pt1[0]);
       	dist2 = VDSdist2(&point_on[3*(index_NULL+1)], &pt0[0]);

#       ifdef DEBUG5
	printf("pt0: %lf, %lf, %lf\n",pt0[0],pt0[1],pt0[2]);
	printf("pt1: %lf, %lf, %lf\n",pt1[0],pt1[1],pt1[2]);
#       endif

       	if(dist1 > dist2)
	 { 
     	   pt2[0] = pt0[0];
     	   pt2[1] = pt0[1];
     	   pt2[2] = pt0[2];
	 }
       	else 
	 {
 	   pt2[0] = pt1[0];
 	   pt2[1] = pt1[1];
 	   pt2[2] = pt1[2];
	 }
#       ifdef DEBUG5
        printf("pt2 : %lf, %lf, %lf is the nearest\n",pt2[0],pt2[1],pt2[2]);
	printf("verify the second end point\n");
#       endif

           
       	pt0[0] = save_pts[6*index_open[1]];
       	pt0[1] = save_pts[6*index_open[1]+1];    /* pt u=0 of save_pts - 1*/
       	pt0[2] = save_pts[6*index_open[1]+2];

       	pt1[0] = save_pts[6*index_open[1]+3];
       	pt1[1] = save_pts[6*index_open[1]+4];
       	pt1[2] = save_pts[6*index_open[1]+5];

#       ifdef DEBUG5
	printf("pt0: %lf, %lf, %lf\n",pt0[0],pt0[1],pt0[2]);
	printf("pt1: %lf, %lf, %lf\n",pt1[0],pt1[1],pt1[2]);
	printf("point_on: %lf, %lf, %lf\n",point_on[3*(index_NULL+1)],
		point_on[3*(index_NULL+1)+1],point_on[3*(index_NULL+1)+2]);
#       endif
 
       	dist1 = VDSdist2(&point_on[3*(index_NULL+1)], &pt1[0]);
       	dist2 = VDSdist2(&point_on[3*(index_NULL+1)], &pt0[0]);
       
       	if(dist1 > dist2)
	 { 
     	   pt3[0] = pt0[0];
     	   pt3[1] = pt0[1];
     	   pt3[2] = pt0[2];
	 }
        else 
	 {
 	   pt3[0] = pt1[0];
 	   pt3[1] = pt1[1];
 	   pt3[2] = pt1[2];
	 }

#      	ifdef DEBUG5
       	printf("pt3 : %lf, %lf, %lf is the nearest\n",pt3[0],pt3[1],pt3[2]);
        printf("transform pt2 and pt3 to param\n");
#      	endif

       	BSprptonsf(&rc,bsp_surf1[0],pt2,&upar,&vpar,&onsurf);
       	if(rc != BSSUCC){printf("ERROR  BSprptonsf: %d\n",rc);goto wrapup;}
       	pt2[0] = upar; pt2[1] = vpar; pt2[2] =0.;

#      	ifdef DEBUG5
       	printf("pt2 : %lf, %lf, %lf \n",pt2[0],pt2[1],pt2[2]);
#      	endif

       	BSprptonsf(&rc,bsp_surf1[0],pt3,&upar,&vpar,&onsurf);
       	if(rc != BSSUCC){printf("ERROR  BSprptonsf: %d\n",rc);goto wrapup;}
       	pt3[0] = upar; pt3[1] = vpar; pt3[2] =0.;

#      	ifdef DEBUG5
       	printf("pt3 : %lf, %lf, %lf \n",pt3[0],pt3[1],pt3[2]);
#      	endif

        if(fabs(pt3[0]-pt2[0])< EPSILON)
            {
          	opt      = 1;		/* u cst */
          	value    = pt3[0];    
		order    = bsp_surf1[0]->v_order;
		nb_poles = bsp_surf1[0]->v_num_poles ;
            } 
       	else if (fabs(pt3[1]-pt2[1])< EPSILON)
            {
          	opt      = 2;		/* v cst */
          	value    = pt3[1];
		order    = bsp_surf1[0]->u_order;
		nb_poles = bsp_surf1[0]->u_num_poles ;
            } 
        else 
            {
	  	/* printf("cannot close the curve with this bnd\n");*/
                opt = 0;
            }
#       ifdef DEBUG5
        printf("opt: %d,value: %lf\n",opt,value);
#       endif

        if(opt)
	 {
	   tst_plan = FALSE;
	   bnd_curve = NULL;
     	   BSalloccv(order,nb_poles ,bsp_surf1[0]->rational, 0,&bnd_curve, &rc);
      	   if(rc != BSSUCC && rc!=BSNULL) 
       	       { 
                 printf("surf_int, Bad allocation for bnd_curve\n");
	         goto wrapup;
	       }
    	   BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,bnd_curve);
	   if(rc != BSSUCC){printf("ERROR  BSconstprcv: %d\n",rc);goto wrapup;}

#          ifdef DEBUG5
	   printf("bnd_curve result ----------\n");
	   printf("nb_pole: %d\n",bnd_curve->num_poles);
	   for(i=0;i<bnd_curve->num_poles;i=i+1)
	       printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#          endif

#          ifdef DEBUG5
  	   printf("transform curve %d to param by project\n",i);
# 	   endif
	   numgrps = 0;
	   numpts  = NULL;
           pts     = NULL;
           par1    = NULL;

           BSsfnormal(bsp_surf1[0], dirvect, &rc);
           BSpjcvtsf(bnd_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
           if (rc!= BSSUCC || numgrps > 1)
            { 
               printf("surf_int, Bad projection on the surface: %d\n",rc);
               goto wrapup;
            } 	
	   nb_poles = numpts[0];
  	   if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve);bnd_curve =NULL;}
  	   stat = VDSfill_curve(nb_poles, NULL, par1[0], &bnd_curve);
  	   if(!(stat & 1)){printf("ERROR VDSfill_curve\n");goto wrapup;}
           VDSfree(numgrps,&par1);
           VDSfree(numgrps,&pts);
           if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}
#          ifdef DEBUG5
	   printf("bnd_curve result param ----------\n");
	   printf("nb_pole: %d\n",bnd_curve->num_poles);
	   for(i=0;i<bnd_curve->num_poles;i=i+1)
	    printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#          endif

#          ifdef DEBUG5
           printf("intersect bnd avec curve[index_open[0]] ----------\n"); 
#          endif
  
           BScvcv_int(&rc, bnd_curve, curve[index_open[0]], &n_int0, &int_pts0, 
      		    &p_par10, &p_par20, &n_over, &end_pts, &over0, &over1);

    	   if(rc != BSSUCC || n_over > 0)
	    {
              printf(" ERROR in BScvcv_int \n");
	      goto wrapup;
	    }
           if(n_int0 < 1 )
            {
#             ifdef DEBUG5
              printf("bnd_curve & cv[index_open[0]] n'ont pas d'intersection\n");
#             endif
	      printf("this bnd doesn't intersect the curve \n");
	      if(over0     != NULL) {free(over0)   ; over0    = NULL;}
   	      if(over1     != NULL) {free(over1)   ; over1    = NULL;}
   	      if(end_pts   != NULL) {free(end_pts) ; end_pts  = NULL;}
              if(p_par10   != NULL) {free(p_par10) ; p_par10  = NULL;}
              if(p_par20   != NULL) {free(p_par20) ; p_par20  = NULL;}
   	      if(int_pts0  != NULL) {free(int_pts0); int_pts0 = NULL;}
            }
   	   else
	    {
#             ifdef DEBUG5
              printf("good intersection\n");
              printf("number of intersection: %d, de over: %d\n", n_int0, n_over);
              for(k=0; k<n_int0 ; k=k+1)
               {
                 printf("coord sur le sup: %lf, %lf, %lf\n",int_pts0[3*k],int_pts0[3*k+1],int_pts0[3*k+2]);
                 printf("param: %lf\n",   p_par10[k]);
                 printf("param: %lf\n\n", p_par20[k]);
               }
              printf("intersect bnd avec curve[index_open[1]] ----------\n"); 
#             endif

	      if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	      if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	      if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
  
              BScvcv_int(&rc, bnd_curve, curve[index_open[1]], &n_int1, &int_pts1, 
      		    &p_par11, &p_par21, &n_over, &end_pts, &over0, &over1);

    	      if(rc != BSSUCC || n_over > 0)
	       {
                 printf(" ERROR in BScvcv_int \n");
	         goto wrapup;
	       }
              if(n_int1 < 1 )
               {
#                ifdef DEBUG5
                 printf("bnd_curve & cv[index_open[1]] n'ont pas d'intersection\n");
#                endif
	         printf("this bnd doesn't intersect the curve\n");
                 if(p_par11 != NULL) {free(p_par11) ; p_par11  = NULL;}
                 if(p_par21 != NULL) {free(p_par21) ; p_par21  = NULL;}
   	         if(int_pts1!= NULL) {free(int_pts1); int_pts1 = NULL;}
               }
             else
	       {
#                ifdef DEBUG5
	         printf("bnd_curve intersect the 2 end curves\n");
                 printf("good intersection\n");
                 printf("number of intersection: %d, de over: %d\n", n_int1, n_over);
                 for(k=0; k<n_int1 ; k=k+1)
                  {
                    printf("coord sur le sup: %lf, %lf, %lf\n",int_pts1[3*k],int_pts1[3*k+1],int_pts1[3*k+2]);
                    printf("param: %lf\n",   p_par11[k]);
                    printf("param: %lf\n\n", p_par21[k]);
                  }
#                endif

	         found = 1;
	       }
   	     if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	     if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	     if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
  	    }
         }/* end opt !=0 */
    }
if( !found )
 {
   
# ifdef DEBUG5
  printf("\n try all bnd to close the curve\n\n");
# endif
   nb_time = 0;
   while(nb_time < 4)
    {

#       ifdef DEBUG5
        printf("nb_time: %d ................\n\n",nb_time);
#       endif

 	switch(nb_time)
         {
       		case 0:	opt      = 1;	/* u constant = 0. */
			value    = 0.;	
			order    = bsp_surf1[0]->v_order;
			nb_poles = bsp_surf1[0]->v_num_poles ;
			break;

		case 1:	opt      = 1;	/* u constant = 1. */
			value    = 1.;	
			order    = bsp_surf1[0]->v_order;
			nb_poles = bsp_surf1[0]->v_num_poles ;
			break;

		case 2:	opt      = 2;	/* v constant = 0. */
			value    = 0.;	
			order    = bsp_surf1[0]->u_order;
			nb_poles = bsp_surf1[0]->u_num_poles ;
			break;

		case 3:	opt      = 2;	/* v constant = 1. */
			value    = 1.;	
			order    = bsp_surf1[0]->u_order;
			nb_poles = bsp_surf1[0]->u_num_poles ;
			break;

		default: printf("no more boundary surface\n");
			 break;

         } /* end switch(nb_time) */
	tst_plan = FALSE;
	bnd_curve = NULL;
     	BSalloccv(order, nb_poles,bsp_surf1[0]->rational, 0,  &bnd_curve, &rc);
      	if(rc != BSSUCC && rc!=BSNULL) 
       	  { 
            printf("surf_int, Bad allocation for bnd_curve\n");
	    goto wrapup;
	  }
    	BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,bnd_curve);
	if(rc != BSSUCC){printf("ERROR  BSconstprcv: %d\n",rc);goto wrapup;}

#       ifdef DEBUG5
	printf("bnd_curve result ----------\n");
	printf("nb_pole: %d\n",bnd_curve->num_poles);
	for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#       endif

#       ifdef DEBUG5
  	printf("transform curve %d to param by project \n",i);
# 	endif
	numgrps = 0;
	numpts  = NULL;
        pts     = NULL;
        par1    = NULL;

        BSsfnormal(bsp_surf1[0], dirvect, &rc);
        BSpjcvtsf(bnd_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
        if (rc!= BSSUCC || numgrps >1)
            { 
               printf("surf_int, Bad projection on the surface: %d\n",rc);
               goto wrapup;
            } 	
	nb_poles = numpts[0];
  	if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve);bnd_curve =NULL;}
  	stat = VDSfill_curve(nb_poles, NULL, par1[0], &bnd_curve);
  	if(!(stat & 1)){printf("ERROR VDSfill_curve\n");goto wrapup;}
        VDSfree(numgrps,&par1);
        VDSfree(numgrps,&pts);
        if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}

#       ifdef DEBUG5
	printf("bnd_curve result param ----------\n");
	printf("nb_pole: %d\n",bnd_curve->num_poles);
	for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#       endif
        
#       ifdef DEBUG5
        printf("intersect bnd avec curve[index_open[0]] ----------\n"); 
#       endif
  
        BScvcv_int(&rc, bnd_curve, curve[index_open[0]], &n_int0, &int_pts0, 
      		    &p_par10, &p_par20, &n_over, &end_pts, &over0, &over1);

    	if(rc != BSSUCC || n_over > 0)
	  {
             printf(" ERROR in BScvcv_int \n");
	     goto wrapup;
	  }
        if(n_int0 < 1 )
          {
#           ifdef DEBUG5
            printf("bnd_curve & cv[index_open[0]] n'ont pas d'intersection\n");
#           endif

   	    nb_time = nb_time + 1;
            if(p_par10   != NULL) {free(p_par10)           ; p_par10  = NULL;}
            if(p_par20   != NULL) {free(p_par20)           ; p_par20  = NULL;}
   	    if(int_pts0  != NULL) {free(int_pts0)          ; int_pts0 = NULL;}
   	    if(over0     != NULL) {free(over0)             ; over0    = NULL;}
   	    if(over1     != NULL) {free(over1)             ; over1    = NULL;}
   	    if(end_pts   != NULL) {free(end_pts)           ; end_pts  = NULL;}
   	    if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve); bnd_curve= NULL;}
	    continue;
          }
   	if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}

#       ifdef DEBUG5
        printf("intersect bnd avec curve[index_open[1]] ----------\n"); 
#       endif
  
        BScvcv_int(&rc, bnd_curve, curve[index_open[1]], &n_int1, &int_pts1, 
      		    &p_par11, &p_par21, &n_over, &end_pts, &over0, &over1);

    	if(rc != BSSUCC || n_over > 0)
	  {
             printf(" ERROR in BScvcv_int \n");
	     goto wrapup;
	  }
        if(n_int1 < 1 )
          {
#           ifdef DEBUG5
            printf("bnd_curve & cv[index_open[1]] n'ont pas d'intersection\n");
#           endif

   	    nb_time = nb_time + 1;
            if(p_par11   != NULL) {free(p_par11)          ; p_par11   = NULL;}
            if(p_par21   != NULL) {free(p_par21)          ; p_par21   = NULL;}
   	    if(int_pts1  != NULL) {free(int_pts1)         ; int_pts1  = NULL;}
   	    if(over0     != NULL) {free(over0)            ; over0     = NULL;}
   	    if(over1     != NULL) {free(over1)            ; over1     = NULL;}
   	    if(end_pts   != NULL) {free(end_pts)          ; end_pts   = NULL;}
   	    if(bnd_curve != NULL){BSfreecv(&rc, bnd_curve); bnd_curve = NULL;}
	    continue;
          }
        else
	 {
#          ifdef DEBUG5
	   printf("bnd_curve intersect the 2 end curves\n");
#          endif

	   found = 1;
   	   if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	   if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	   if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
           break;
	 }
   	if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
        if(bnd_curve != NULL){BSfreecv(&rc, bnd_curve); bnd_curve=NULL;}
   	nb_time = nb_time + 1;
    }/* end while(nb_time) */


 }/* not found */
 if( !found)
    {
      	printf("ERROR: cannot close the curve \n");
      	goto wrapup;
    }
  else 
   {
#       ifdef DEBUG5
 	printf("intersection with curve[index0] result -------\n");
    	printf("number of intersection: %d\n", n_int0);
    	for(k=0; k<n_int0 ; k=k+1)
     	    {
       		printf("coord sur le sup: %lf, %lf, %lf\n",int_pts0[3*k],int_pts0[3*k+1],int_pts0[3*k+2]);
       		printf("param: %lf\n",   p_par10[k]);
       		printf("param: %lf\n\n", p_par20[k]);
     	    }
	if(!(num_merge == 1 && !close_cv))
         {
	   printf("intersection with curve[index1] result -------\n");
    	   printf("number of intersection: %d\n", n_int1);
    	   for(k=0; k<n_int1 ; k=k+1)
     	    {
       		printf("coord sur le sup: %lf, %lf, %lf\n",int_pts1[3*k],int_pts1[3*k+1],int_pts1[3*k+2]);
       		printf("param: %lf\n",   p_par11[k]);
       		printf("param: %lf\n\n", p_par21[k]);
     	    }
	  }
    printf("end close_cv found: %d\n",found);
#   endif
   }

 } /* end try to close */


p_index = 0;
if (!two_intersect && !close_cv )
  {
   for(i=0;i<num_merge ;i=i+1)
    {
      p_curve[p_index] = NULL;
      intpts1[0]	  = -1.;
      intpts1[1]	  = -1.;
      intpts1[2]	  = -1.;

      intpts2[0]	  = -1.;
      intpts2[1]	  = -1.;
      intpts2[2]	  = -1.;

#     ifdef DEBUG6
      printf("EXTRACT THE GOOD PARTS ...........\n");
#     endif


#     ifdef DEBUG6
      printf("Extract part of curve # %d\n",tab_cv[i]);
#     endif

      /* -------------------------------------------------------------------- 

         Compute of the direction parameter (for now simple case of none 
         close curve) 

         -------------------------------------------------------------------- */

      if(num_merge == 1 && !close_cv)
	{
#	 ifdef DEBUG6
         printf("num_merge == 1 && !close_cv\n");
#	 endif
         par   = p_par20[0];
         parr1 = p_par20[1];
	  
	}
      else if(tab_cv[i] == index_open[0])
       {
#	 ifdef DEBUG6
         printf("tab_cv[i] == index_open[0]\n");
#	 endif
         if(tab_cv[i] == tab_cv[0] && index_open[1] == tab_cv[num_merge - 1])
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] == tab_cv[0] && index_open[1] == tab_cv[num_merge - 1]\n");
#	    endif
	    par   = p_par1[1][0];
	    parr1 = p_par20[0];
	    intpts1[0] = int_pts0[0];
	    intpts1[1] = int_pts0[1];
	    intpts1[2] = int_pts0[2];

	    intpts2[0] = int_pts[1][0];
	    intpts2[1] = int_pts[1][1];
	    intpts2[2] = int_pts[1][2];
          }
         else if(tab_cv[i] == tab_cv[0] && index_open[1] != tab_cv[num_merge-1])
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] == 0 && index_open[1] != tab_cv[num_merge-1]\n");
#	    endif
	    par   = p_par2[0][0];
	    parr1 = p_par20[0];
	    intpts1[0] = int_pts0[0];
	    intpts1[1] = int_pts0[1];
	    intpts1[2] = int_pts0[2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
          }
         else
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] != tab_cv[0]\n");
#	    endif
            par   = p_par2[i][0];
	    parr1 = p_par20[0];
	    intpts1[0] = int_pts0[0];
	    intpts1[1] = int_pts0[1];
	    intpts1[2] = int_pts0[2];

	    intpts2[0] = int_pts[i][0];
	    intpts2[1] = int_pts[i][1];
	    intpts2[2] = int_pts[i][2];
          }
       }
      else if(tab_cv[i] == index_open[1])
       {
#	 ifdef DEBUG6
         printf("tab_cv[i] == index_open[1]\n");
#	 endif
         if(tab_cv[i] == tab_cv[num_merge-1] && index_open[0] == tab_cv[0])
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] == tab_cv[num_merge-1] && index_open[0] == tab_cv[0]\n");
#	    endif
	    par   = p_par2[num_merge-1][0];
	    parr1 = p_par21[0];
	    intpts1[0] = int_pts1[0];
	    intpts1[1] = int_pts1[1];
	    intpts1[2] = int_pts1[2];

	    intpts2[0] = int_pts[num_merge-1][0];
	    intpts2[1] = int_pts[num_merge-1][1];
	    intpts2[2] = int_pts[num_merge-1][2];
          }
         else if(tab_cv[i] == tab_cv[num_merge-1] && index_open[0] != tab_cv[0])
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] == tab_cv[num_merge-1] && index_open[0] != tab_cv[0]\n");
#	    endif
            par   = p_par1[0][0];
	    parr1 = p_par21[0];
	    intpts1[0] = int_pts1[0];
	    intpts1[1] = int_pts1[1];
	    intpts1[2] = int_pts1[2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
          }
         else
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] != tab_cv[num_merge-1]\n");
#	    endif
            par   = p_par1[i+1][0];
	    parr1 = p_par21[0];
	    intpts1[0] = int_pts1[0];
	    intpts1[1] = int_pts1[1];
	    intpts1[2] = int_pts1[2];

	    intpts2[0] = int_pts[i+1][0];
	    intpts2[1] = int_pts[i+1][1];
	    intpts2[2] = int_pts[i+1][2];
          }
       }
      else
       {
#	 ifdef DEBUG6
         printf("tab_cv[i] != index_open\n");
#	 endif
         if(tab_cv[i] == tab_cv[num_merge-1])
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] == tab_cv[num_merge-1]\n");
#	    endif
	    par   = p_par1[0][0];
	    parr1 = p_par2[num_merge-1][0];
	    intpts1[0] = int_pts[num_merge-1][0];
	    intpts1[1] = int_pts[num_merge-1][1];
	    intpts1[2] = int_pts[num_merge-1][2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
          }
         else
          {
#	    ifdef DEBUG6
            printf("tab_cv[i] != tab_cv[num_merge-1]\n");
#	    endif
            par   = p_par1[i+1][0];
	    parr1 = p_par2[i][0];
	    intpts1[0] = int_pts[i][0];
	    intpts1[1] = int_pts[i][1];
	    intpts1[2] = int_pts[i][2];

	    intpts2[0] = int_pts[i+1][0];
	    intpts2[1] = int_pts[i+1][1];
	    intpts2[2] = int_pts[i+1][2];
          }
       }


      d_par = (parr1 + par)/2.;
      if(parr1 > par) 	rev = 1;
      else		rev = 0;

      order = curve[tab_cv[i]]->order;
      BSalloccv(order, curve[tab_cv[i]]->num_poles + 2 * order - 1, 
		curve[tab_cv[i]]->rational,curve[tab_cv[i]]->num_boundaries, 
                &p_curve[p_index], &rc);
      if(rc != BSSUCC && rc!=BSNULL) 
       { 
        printf("surf_int, Bad allocation for the curves\n");
        for(k=0; k<num_ent-1; k=k+1)
         {
	  if(curve[k]!=NULL)
            {
               BSfreecv(&rc, curve[k]); 
               curve[k] = NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                   {printf("BSfreecv(curve) fail\n");goto wrapup;}
            }
   	  if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
          if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
          if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
         }
        goto wrapup;
       }
#     ifdef DEBUG6
      printf("BSpartofcv de curve %d\n",tab_cv[i]);
      printf("parms: %lf, %lf, %lf\n",parr1, d_par, par);
#     endif

      BSpartofcv(&rc, curve[tab_cv[i]], parr1, d_par, par, p_curve[p_index]);
      if(rc != BSSUCC) 
       { 
        printf("surf_int, Bad extraction of the part of curve # %d\n", tab_cv[i]);
        if(p_curve[p_index]!=NULL) 
         {
          BSfreecv(&rc, p_curve[p_index]); 
          p_curve[p_index]= NULL;
          if (rc !=BSSUCC && rc!=BSNULL) 
             {printf("BSfreecv(curve) fail\n");goto wrapup;}
         }
        goto wrapup;
       }
      /* don't free p_par1[0] because needed for partofcv (num_ent-2) */
      if(i!= 0 && p_par1[i]   != NULL) {free(p_par1[i]) ; p_par1[i]  = NULL;}
      if(i!= 0 && int_pts[i]  != NULL) {free(int_pts[i]); int_pts[i] = NULL;}
      if(p_par2[i]   != NULL)          {free(p_par2[i]) ; p_par2[i]  = NULL;}
      if(i>1)
       {
        /* previous curve to keep curve[i-1] at the next step */
        if(curve[tab_cv[i-1]]!=NULL  ) 
         {
           BSfreecv(&rc, curve[tab_cv[i-1]]); 
           curve[tab_cv[i-1]]= NULL;
           if (rc !=BSSUCC && rc!=BSNULL) 
            {printf("BSfreecv(curve) fail\n");goto wrapup;}
         }
       }
      if(rev)
       {
        BSrev_cv(&rc, p_curve[p_index]);
        if(rc != BSSUCC) 
         { 
          printf("surf_int, ERROR cannot reverse the curve\n");
          if(p_curve[p_index]!=NULL)
           {
             BSfreecv(&rc, p_curve[p_index]); 
             p_curve[p_index] = NULL;
             if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");goto wrapup;}
           }
          goto wrapup;
         }
       }
#     ifdef DEBUG6   

      printf("\n\nBSpartofcv de curve %d ......\n",i);
      printf("intpts1: %lf, %lf, %lf\n",intpts1[0],intpts1[1],intpts1[2]);
      printf("intpts2: %lf, %lf, %lf\n",intpts2[0],intpts2[1],intpts2[2]);
      printf("partofcv result %d\n",p_index);
      printf("pole0: %lf, %lf, %lf\n", p_curve[i]->poles[0],p_curve[i]->poles[1],
		p_curve[i]->poles[2]);     
      printf("pole1: %lf, %lf, %lf\n", p_curve[i]->poles[(p_curve[i]->num_poles-1)*3],
		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+1],
		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+2]);
#     endif

      if(fabs(intpts1[0]+1.) > EPSILON && fabs(intpts1[1]+1.) > EPSILON && 
					fabs(intpts1[2]+1.) > EPSILON )
       {
        if(fabs(p_curve[i]->poles[0]-intpts1[0]) > EPSILON )
	 	p_curve[i]->poles[0]= intpts1[0];
      	if(fabs(p_curve[i]->poles[1] - intpts1[1]) > EPSILON)
		p_curve[i]->poles[1]= intpts1[1];
      	if(fabs(p_curve[i]->poles[2] - intpts1[2]) > EPSILON)
	 	p_curve[i]->poles[2]= intpts1[2];
       }
      if(fabs(intpts2[0]+1.) > EPSILON && fabs(intpts2[1]+1.) > EPSILON && 
					fabs(intpts2[2]+1.) > EPSILON )
       {
        if(fabs(p_curve[i]->poles[(p_curve[i]->num_poles-1)*3]-intpts2[0]) > EPSILON )
	 	p_curve[i]->poles[(p_curve[i]->num_poles-1)*3]= intpts2[0];
      	if(fabs(p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+1] - intpts2[1]) > EPSILON)
		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+1]= intpts2[1];
      	if(fabs(p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+2] - intpts2[2]) > EPSILON)
	 	p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+2]= intpts2[2];
       }
#     ifdef DEBUG6
      printf("\n");
      printf("partofcv result %d\n",p_index);
            if(p_curve[p_index]->rational)
            {
              for(k=0;k< p_curve[p_index]->num_poles ;k=k+1)
               printf("weight: %lf\n", p_curve[p_index]->weights[k]);
            }
      for(k=0;k<p_curve[p_index]->num_poles ;k=k+1)
      printf("partof the curves: %lf, %lf, %lf\n", p_curve[p_index]->poles[3*k], p_curve[p_index]->poles[3*k+1], p_curve[p_index]->poles[3*k+2]);
#     endif
      if(p_curve[p_index]->rational)
          {
            for(k=0;k<p_curve[p_index]->num_poles;k=k+1)
	     {
		p_curve[p_index]->poles[3*k]   = p_curve[p_index]->poles[3*k]/
						p_curve[p_index]->weights[k];
		p_curve[p_index]->poles[3*k+1] = p_curve[p_index]->poles[3*k+1]/
						p_curve[p_index]->weights[k];
		p_curve[p_index]->poles[3*k+2] = p_curve[p_index]->poles[3*k+2]/
						p_curve[p_index]->weights[k];
	     }
	    p_curve[p_index]->rational = 0;
	    if(p_curve[p_index]->weights)
	      {
		free(p_curve[p_index]->weights);
		p_curve[p_index]->weights  = NULL;
	      }
          }
     p_index = p_index + 1;

    }/* end boucle i */
   if(p_par1[0]   != NULL) {free(p_par1[0]) ; p_par1[0]  = NULL;}
   if(int_pts[0]  != NULL) {free(int_pts[0]); int_pts[0] = NULL;}



if ((!two_intersect ) && (open_cv || (num_merge == 1 && !close_cv)) )
{
#  ifdef DEBUG6
   printf("\n\nfill last p_curve with partofcv de bnd_curve\n\n");
#  endif

   p_curve[p_index] = NULL;
   par   = p_par10[0];
   if(num_merge == 1 && !close_cv) parr1 = p_par10[1];
   else 			   parr1 = p_par11[0];

   d_par = (parr1 + par)/2.;
   if(parr1 > par) 	rev = 1;
   else			rev = 0;
   order = bnd_curve->order;
   BSalloccv(order, bnd_curve->num_poles + 2 * order - 1, bnd_curve->rational,
                bnd_curve->num_boundaries, 
                &p_curve[p_index], &rc);
   if(rc != BSSUCC && rc!=BSNULL) 
       { 
        printf("surf_int, Bad allocation for the curves\n");
	if(bnd_curve!=NULL)
            {
               BSfreecv(&rc, bnd_curve); 
               bnd_curve = NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                   {printf("BSfreecv(curve) fail\n");goto wrapup;}
            }
   	  if(int_pts0!= NULL) {free(int_pts0); int_pts0 = NULL;}
          if(p_par10 != NULL) {free(p_par10) ; p_par10  = NULL;}
          if(p_par20 != NULL) {free(p_par20) ; p_par20  = NULL;}
   	  if(int_pts1!= NULL) {free(int_pts1); int_pts1 = NULL;}
          if(p_par11 != NULL) {free(p_par11) ; p_par11  = NULL;}
          if(p_par21 != NULL) {free(p_par21) ; p_par21  = NULL;}
          goto wrapup;
       }
#     ifdef DEBUG6
      printf("parms: %lf, %lf, %lf\n",parr1, d_par, par);
#     endif

      BSpartofcv(&rc, bnd_curve, parr1, d_par, par, p_curve[p_index]);
      if(rc != BSSUCC) 
       { 
        printf("surf_int, Bad extraction of the part of curve # %d\n", i);
        if(p_curve[p_index]!=NULL) 
         {
           BSfreecv(&rc, p_curve[p_index]); 
           p_curve[p_index]= NULL;
           if (rc !=BSSUCC && rc!=BSNULL) 
             {printf("BSfreecv(curve) fail\n");goto wrapup;}
         }
        goto wrapup;
       }
      if(rev)
       {
        BSrev_cv(&rc, p_curve[p_index]);
        if(rc != BSSUCC) 
         { 
          printf("surf_int, ERROR cannot reverse the curve\n");
          if(p_curve[p_index]!=NULL)
           {
             BSfreecv(&rc, p_curve[p_index]); 
             p_curve[p_index] = NULL;
             if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");goto wrapup;}
           }
          goto wrapup;
         }
       }


#     ifdef DEBUG6
      printf("\n");
      printf("partofcv result %d\n",p_index);
            if(p_curve[p_index]->rational)
            {
              for(k=0;k< p_curve[p_index]->num_poles ;k=k+1)
               printf("weight: %lf\n", p_curve[p_index]->weights[k]);
            }
      for(k=0;k<p_curve[p_index]->num_poles ;k=k+1)
      printf("partof the curves: %lf, %lf, %lf\n", p_curve[p_index]->poles[3*k], p_curve[p_index]->poles[3*k+1], p_curve[p_index]->poles[3*k+2]);
#     endif

   if(bnd_curve!=NULL)
     {
        BSfreecv(&rc, bnd_curve); 
        bnd_curve = NULL;
	if (rc !=BSSUCC && rc!=BSNULL) 
                   {printf("BSfreecv(curve) fail\n");goto wrapup;}
     }
   p_index = p_index + 1;
   if(int_pts0!= NULL) {free(int_pts0); int_pts0 = NULL;}
   if(p_par10 != NULL) {free(p_par10) ; p_par10  = NULL;}
   if(p_par20 != NULL) {free(p_par20) ; p_par20  = NULL;}
   if(int_pts1!= NULL) {free(int_pts1); int_pts1 = NULL;}
   if(p_par11 != NULL) {free(p_par11) ; p_par11  = NULL;}
   if(p_par21 != NULL) {free(p_par21) ; p_par21  = NULL;}

}/* end partofcv  bnd_curve */
   for(k=0; k<num_ent-1; k=k+1)
    {
     if(curve[k]!=NULL)
      {
        BSfreecv(&rc, curve[k]); 
        curve[k] = NULL;
        if (rc !=BSSUCC && rc!=BSNULL) 
                   {printf("BSfreecv(curve) fail\n");goto wrapup;}
      }
     if(p_par1[k]  != NULL) {free(p_par1[k]); p_par1[k]   = NULL;}
     if(p_par2[k]  != NULL) {free(p_par2[k]); p_par2[k]   = NULL;}
     if(int_pts[k] != NULL) {free(int_pts[k]); int_pts[k] = NULL;}
    }

}/* end extract part of curve */

   if(p_index > 0) num_merge = p_index ;



      /* -------------------------------------------------------------------- 
  
  	 if more that one curve, put the curves in consecutive order and 
	 verify if it makes a unique groupe or not.

         -------------------------------------------------------------------- */

if (num_merge > 1)
{
  stat = VDSorder_gpe(num_merge, &p_curve[0], &nb_gpe, &nb_cvgp, &array);
  if(!(stat & 1)){printf("ERROR VDSorder_gpe\n");goto wrapup;}

# ifdef DEBUG3
  printf("nb_gpe: %d\n",nb_gpe);
  for(i=0;i<nb_gpe;i=i+1)
	   {
		printf("nb_cvgp[%d]: %d\n",i,nb_cvgp[i]);
		for(k=0;k<nb_cvgp[i];k=k+1)
		 {
			printf("array[k]->num_poles: %d\n",array[k]->num_poles);
			for(j=0;j<array[k]->num_poles;j=j+1)
			  printf("order array: %lf, %lf, %lf\n",array[k]->poles[3*j],
				array[k]->poles[3*j+1],array[k]->poles[3*j+2]);
		 }
	   }
# endif

  if(nb_gpe > 1) { printf(" ERROR, curves not contiguous \n"); goto wrapup;}
}


      /* -------------------------------------------------------------------- 
  
  	 if support is surface transform p_curve to points and not param 

         -------------------------------------------------------------------- */

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.class_attr	= NULL;
  cst.name		= NULL;

if(close_cv == 1)
{
  nb_gpe = 1;
  nb_cvgp = NULL;
  nb_cvgp = (int *)malloc(1 * sizeof (int ));
  if(nb_cvgp == NULL)
    {
        printf("surf_int, Bad allocation for nb_cvgp\n");
        goto wrapup;
    }
  nb_cvgp[0] = 1;
  array = NULL;
  array = (struct IGRbsp_curve **)
                malloc(1 * sizeof (struct IGRbsp_curve *));
  if(array == NULL)
    {
        printf("surf_int, Bad allocation for array\n");
        goto wrapup;
    }
  array[0] = curve[i_onecv];
}


/* find the center of this array of planar (u,v) curves */

    BSctrarplcv(nb_cvgp[0],array,center, &area ,&rc);
    if (rc!= BSSUCC)
             { 
               printf("error  BSctrarplcv\n");
               goto wrapup;
             }


# ifdef DEBUG4
  printf("center point: %lf, %lf, %lf\n",center[0],center[1],center[2]);
  printf("transform curve param to pts\n");
  printf("nb_cvgp[0]: %d\n",nb_cvgp[0]);
# endif

 for(i=0;i<nb_cvgp[0];i=i+1)
 {
  if(array[i] != NULL)
   {
#	ifdef DEBUG3
	printf("array non null : %d\n",i);
#	endif

        eval_pts = NULL;
        param    = NULL;
	param 	 = (IGRdouble *) malloc(2*array[i]->num_poles*sizeof(double));
     	if( param == NULL){printf("bad alloc of param\n");goto wrapup;}
      	for(k=0;k<array[i]->num_poles ;k=k+1)
		{
		  param[2*k]   = array[i]->poles[3*k];
		  param[2*k+1] = array[i]->poles[3*k+1];
		}
#	ifdef DEBUG3
      	for(k=0;k<array[i]->num_poles ;k=k+1)
        printf("param: %lf, %lf\n",param[2*k] ,param[2*k+1]);
#	endif

	eval_pts = (IGRdouble *) malloc(3*array[i]->num_poles*sizeof(double));
     	if( eval_pts == NULL){printf("bad alloc of evalpts\n");goto wrapup;}

#	ifdef DEBUG3
	printf("BSsfptseval\n");
#	endif

     	BSsfptseval(bsp_surf1[0],array[i]->num_poles,param,
			eval_pts,&rc);
     	if (rc!= BSSUCC)
             { 
               printf("error  BSsfptseval\n");
               goto wrapup;
             }
        else
	     {


#		ifdef DEBUG3
      		for(k=0;k<array[i]->num_poles ;k=k+1)
		  printf("eval_pts[k]: %lf, %lf, %lf\n",eval_pts[3*k],eval_pts[3*k+1],eval_pts[3*k+2]);
		printf("array = eval_pts\n");
#		endif
      		for(k=0;k<3*array[i]->num_poles ;k=k+1)
		  array[i]->poles[k] = eval_pts[k];
		if (eval_pts != NULL){free(eval_pts);eval_pts = NULL;}
		if (param != NULL)   {free(param)   ;param    = NULL;}

#  		ifdef DEBUG3
                printf("curve %d ............\n",i);
      		for(k=0;k<array[i]->num_poles ;k=k+1)
      		printf("eval poles : %lf, %lf, %lf\n", array[i]->poles[3*k], array[i]->poles[3*k+1], array[i]->poles[3*k+2]);
#		endif                
             }

   }/*if(array[i] != NULL)*/
 }/* for(i=0 to nb_cvgp[0]) */


for(i=0;i<nb_cvgp[0];i=i+1)
{
 if(array[i] != NULL)
  {
#  ifdef DEBUG3
   printf("construct the curve: %d\n",i);
#  endif

  GRid_cv[i].osnum = MOD_ENV.md_id.osnum;
  GRid_cv[i].objid = NULL_OBJID;

    	
  cst.geometry	= (char *) array[i];


  stat = ci$send(msg = message GRbcsubbc.GRconstruct( &cst),
		verbose = VERBOSE,
		construct = 1,
        	    targetid  = GRid_cv[i].objid,
 	            targetos  = GRid_cv[i].osnum );
#  ifdef DEBUG3
   printf("GRconstruct stat = %ld, GRid_cv = %d, %d\n",stat, GRid_cv[i].objid,
                                              GRid_cv[i].osnum);
#  endif
  
  entries[i].located_obj = GRid_cv[i];
  entries[i].module_info = MOD_ENV;
  if (!(stat&1)) 
   {
    printf("EMSsubbs.GRconstruct failed\n");
    GRid_cv[i].objid = NULL_OBJID;
    goto wrapup;
   }
 }/* array[i] != NULL */
}/* for(i=0 to nb_cvgp[0] */

for(i=0;i<nb_cvgp[0];i=i+1)
{
  if(p_curve[i]!=NULL) 
              {
                BSfreecv(&rc, p_curve[i]); 
                p_curve[i]= NULL;
	        if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail rc: %d\n",rc);goto wrapup;}
              }
}

if(nb_cvgp[0] == 1)
  comp_id = GRid_cv[0];
else
{
#ifdef DEBUG3
 printf("construct the composite curve\n");
#endif

 comp_id.osnum = MOD_ENV.md_id.osnum;
 comp_id.objid = NULL_OBJID;

 rotten_one = 0;
 stat = ci$send(msg = message GRcompcurve.EMmakecomp( &msg,&MOD_ENV,
			nb_cvgp[0],entries, &rotten_one),
		verbose = VERBOSE,
		construct = 1,
        	    targetid  = comp_id.objid,
 	            targetos  = comp_id.osnum );

  if (!(stat&1)) 
   {
    printf(" GRcompcurve.EMmakecomp failed\n");
    comp_id.objid = NULL_OBJID;
    goto wrapup;
   }

#ifdef DEBUG3
 printf("GRconstruct stat = %ld, comp_id = %d, %d\n",stat, comp_id.objid,
                                              comp_id.osnum);
#endif
 }/* else de nb_cvgp[0] == 1*/

  /* CREATE THE GRAPHIC OBJECT */

     BSalloccv(ORDER, 2, 0, 0, &line, &rc);
     if(rc != BSSUCC && rc!=BSNULL) 
           { 
            printf("Bad allocation for the line\n");
            goto wrapup;
           }
     line->order     = ORDER;
     line->num_poles = 2;
     line->num_knots = 2 + 2 * (ORDER - 1);

     /* Compute the line between center and the point (0,0) of the surface */

     line->poles[0] = upar;
     line->poles[1] = vpar;
     line->poles[2] = 0;

     line->poles[3] = 0;
     line->poles[4] = 0;
     line->poles[5] = 0;

     line->knots[0] = 0;
     line->knots[1] = 0;
     line->knots[2] = 1;
     line->knots[3] = 1;

/*   take geom of the composite to intersect with line in order to know if
     upar, vpar is inside area or not */

    stat = ci$send( msg = message GRvg.GRgeomprops(&msg, &matrix_type, 
					matrix,&properties),
	      	        targetid = comp_id.objid,
	                targetos = comp_id.osnum );
    if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 

    stat = ci$send(msg = message GRvg.GRgetsize(&msg, &matrix_type, matrix, 
						 &size ),
	  	   targetid = comp_id.objid,
	  	   targetos = comp_id.osnum );
    if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
    comp_cv = NULL;
    comp_cv = (struct IGRbsp_curve *) malloc(size);
    if(comp_cv == NULL) 
     {
      printf("bsp_cv, Bad memory allocation\n");
      goto wrapup;
     }
    status = ci$send(msg = message GRvg.GRgetgeom(&msg, &matrix_type, 
                                  matrix, (char *) comp_cv),
	  	    targetid = comp_id.objid,
	  	    targetos = comp_id.osnum );
    as$status(action = RET_STATUS);

#   ifdef DEBUG5
    printf("transform curve %d to param by project \n",i);
#   endif
    numgrps = 0;
    numpts  = NULL;
    pts     = NULL;
    par1    = NULL;

    BSsfnormal(bsp_surf1[0], dirvect, &rc);
    BSpjcvtsf(comp_cv, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
    if (rc!= BSSUCC || numgrps >1)
            { 
               printf("surf_int, Bad projection on the surface: %d\n",rc);
               goto wrapup;
            } 	
    nb_poles = numpts[0];
    if(comp_cv != NULL) {free(comp_cv);comp_cv =NULL;}
    stat = VDSfill_curve(nb_poles, NULL, par1[0], &comp_cv);
    if(!(stat & 1)){printf("ERROR VDSfill_curve\n");goto wrapup;}
    VDSfree(numgrps,&par1);
    VDSfree(numgrps,&pts);
    if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}
     p_par10  = NULL;
     p_par20  = NULL;
     int_pts0 = NULL;
     over0    = NULL;
     over1    = NULL;
     end_pts  = NULL;

     BScvcv_int(&rc, comp_cv, line, &n_int0, &int_pts0, &p_par10, &p_par20, 
	       &n_over, &end_pts, &over0, &over1);

     if(rc != BSSUCC || n_over > 0)
	  {
             printf(" ERROR in BScvcv_int \n");
	     goto wrapup;
	  }
#    ifdef DEBUG5
     printf("number of intersection : %d\n",n_int0);
     for(k=0;k<n_int0;k=k+1)
      printf("intpts: %lf,%lf, %lf\n",int_pts0[3*k],int_pts0[3*k+1],int_pts0[3*k+2]);
#    endif
     if(n_int0 % 2 == 0) onsurf = TRUE; 
     else 		 onsurf = FALSE; 
     if(comp_cv != NULL) {free(comp_cv)         ;comp_cv = NULL;}
     if(line    != NULL) {BSfreecv(&rc, line)   ;line    = NULL;}

     area_pt[0] = center[0];
     area_pt[1] = center[1];
     map_options = EMMapBnd_WantStatMsg | EMMapBnd_WantBadCurves |
               EMMapBnd_StrokeIfNeeded;

     imp_options = EMImpBnd_NoStateTree | EMImpBnd_WantStatMsg;
     number_of_points = 0;
     number_of_bad_curves = 0;
     points = NULL;
     final_curve.located_obj = comp_id;
     final_curve.module_info = MOD_ENV;

#    ifdef DEBUG3
     printf("VDbound final_curve: %d, %d\n",final_curve.located_obj.objid,
					final_curve.located_obj.osnum);
#    endif
     stat = ci$send(msg = message EMSsurface.EMimpose_boundaries(
                     &msg,
                     1,
                     NULL,                     
                     &final_curve,	
                     area_pt,           
                     FALSE,              
                     &MOD_ENV, 
                     &number_of_points,         
                     &points,
                     &number_of_bad_curves,
                     bad_curve_indices,
                     NULL,
                     NULL, 
                     NULL, 
                     NULL, 
                     map_options, 
                     imp_options),
/*		verbose = VERBOSE,*/
              targetid = GRid_list.objid,targetos=GRid_list.osnum);
     if (!(stat&1) || msg == EMS_I_NoMoreLoops)
	{ om$report_error(sts=stat);   
	  EFmsgReport(0,msg ,"return msg EMimpose_bnd");
          goto wrapup; 

	} 


#    ifdef DEBUG3
     printf("GRconstruct stat = %d, GRid_list = %d, %d\n",stat, GRid_list.objid,
                                              GRid_list.osnum);
     EFmsgReport(0,*(cst.msg),"return msg GRconstruct");
#    endif

  if(props & EMSIS_NRML_REVERSED)
   {
#   ifdef DEBUG
    printf("The support has a reversed normal\n");
#   endif
    stat = ci$send(msg = message EMSsubbs.EMset_props(&msg,
                                        (unsigned char) EMSIS_NRML_REVERSED, 
                                        (char)EMS_O_SET),
                        targetid = GRid_list.objid,
                        targetos = GRid_list.osnum);
    if(!(stat&1))
     {
#     ifdef DEBUG
      printf("VDhole2: Error EMSsubbs.EMset_props\n");
#     endif
      }
    }

     if(points    != NULL) {free(points);points = NULL;}  
     VDSfree(nb_sf1,&bsp_surf1); 
     VDSfree(nb_sf2,&bsp_surf2); 
     if(bsp_curve != NULL){free(bsp_curve)         ; bsp_curve = NULL;}
     if(bnd_curve != NULL){BSfreecv(&rc, bnd_curve); bnd_curve = NULL;}
     for(k=0;k<num_ent-1;k=k+1)
      {
	  if(curve[k]   != NULL) {BSfreecv(&rc, curve[k])  ; curve[k]   = NULL;}
          if(p_curve[k] != NULL) {BSfreecv(&rc, p_curve[k]); p_curve[k] = NULL;}
    	  if(p_par2[k]  != NULL) {free(p_par2[k])          ; p_par2[k]  = NULL;}
   	  if(int_pts[k] != NULL) {free(int_pts[k])         ; int_pts[k] = NULL;}
    	  if(p_par1[k]  != NULL) {free(p_par1[k])          ; p_par1[k]  = NULL;}
      }
     if(line     != NULL) {BSfreecv(&rc, line)     ; line     = NULL;}
     if(comp_cv  != NULL) {free(comp_cv)         ; comp_cv  = NULL;}
     if(int_pts0 != NULL) {free(int_pts0)          ; int_pts0 = NULL;}
     if(int_pts1 != NULL) {free(int_pts1)          ; int_pts1 = NULL;}
     if(p_par10  != NULL) {free(p_par10)           ;  p_par10 = NULL;}
     if(p_par11  != NULL) {free(p_par11)           ;  p_par11 = NULL;}
     if(p_par20  != NULL) {free(p_par20)           ;  p_par20 = NULL;}
     if(p_par21  != NULL) {free(p_par21)           ;  p_par21 = NULL;}
     if(array    != NULL) {free(array)             ;  array   = NULL;}
     if(numpts   != NULL) {free(numpts)            ;  numpts  = NULL;}
     if(over0    != NULL) {free(over0)             ;  over0   = NULL;}
     if(over1    != NULL) {free(over1)             ;  over1   = NULL;}
     if(end_pts  != NULL) {free(end_pts)           ;  end_pts = NULL;}
     if(eval_pts != NULL) {free(eval_pts)          ;  eval_pts= NULL;}
     if(param    != NULL) {free(param)             ;  param   = NULL;}
      VDSfree(numgrps,&pts);
      VDSfree(numgrps,&par1);
      VDSfree(numgrps,&par2);
   return(1);


wrapup:
   GRid_list.objid = NULL_OBJID;
   VDSfree(nb_sf1,&bsp_surf1); 
   VDSfree(nb_sf2,&bsp_surf2); 
   if(points    != NULL) {free(points)            ;points     = NULL;}  
   if(line      != NULL) {BSfreecv(&rc, line)     ;line       = NULL;}
   if(comp_cv   != NULL) {free(comp_cv)           ;comp_cv    = NULL;}
   if(bsp_curve != NULL) {free(bsp_curve)         ; bsp_curve = NULL;}
   if(eval_pts  != NULL) {free(eval_pts)          ;eval_pts   = NULL;}
   if(param     != NULL) {free(param)             ;param      = NULL;}
   if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve); bnd_curve = NULL;}
   for(k=0;k<num_ent-1;k=k+1)
    {
	  if(curve[k]   !=NULL)  {BSfreecv(&rc, curve[k])  ; curve[k]  = NULL;}
          if(p_curve[k] !=NULL)  {BSfreecv(&rc, p_curve[k]); p_curve[k]= NULL;}
    	  if(p_par2[k]  != NULL) {free(p_par2[k])          ; p_par2[k] = NULL;}
   	  if(int_pts[k] != NULL) {free(int_pts[k])         ; int_pts[k]= NULL;}
    	  if(p_par1[k]  != NULL) {free(p_par1[k])          ; p_par1[k] = NULL;}
    }
   if(int_pts0 != NULL) {free(int_pts0); int_pts0 = NULL;}
   if(int_pts1 != NULL) {free(int_pts1); int_pts1 = NULL;}
   if(p_par10  != NULL) {free(p_par10) ;  p_par10 = NULL;}
   if(p_par11  != NULL) {free(p_par11) ;  p_par11 = NULL;}
   if(p_par20  != NULL) {free(p_par20) ;  p_par20 = NULL;}
   if(p_par21  != NULL) {free(p_par21) ;  p_par21 = NULL;}
   if(array    != NULL) {free(array)   ;  array   = NULL;}
   if(nb_cvgp  != NULL) {free(nb_cvgp) ;  nb_cvgp = NULL;}
   if(numpts   != NULL) {free(numpts)  ;  numpts  = NULL;}
   if(over0    != NULL) {free(over0)   ;  over0   = NULL;}
   if(over1    != NULL) {free(over1)   ;  over1   = NULL;}
   if(end_pts  != NULL) {free(end_pts) ;  end_pts = NULL;}
    VDSfree(numgrps,&pts);
    VDSfree(numgrps,&par1);
    VDSfree(numgrps,&par2);

  return(0);

}

/* ***************** FCT consume_and_display () ***********************	*/

consume_and_display( as_sup, c_mod, d_mod, md_env )

struct	GRid		as_sup;
IGRshort		c_mod;
IGRshort		d_mod;
struct	GRmd_env	*md_env;

{
IGRlong			sts, msg;
struct	GRid		go_sup;
struct	GRmd_env	sup_env;
enum	GRdpmode	pen;

	sts = ci$send(	msg	 = message NDnode.ASreturn_go(
					&go_sup,
					&sup_env.md_env.matrix_type,
					sup_env.md_env.matrix ),
			targetid = as_sup.objid,
			targetos = as_sup.osnum );
	as$status( sts = sts );
	if( c_mod ){

		if( d_mod )	pen = GRbd;
		else		pen	= GRbehe;

		sts = ci$send(	msg	 = message GRgraphics.GRdisplay(
						&msg,
						&sup_env.md_env.matrix_type,
						sup_env.md_env.matrix,
						&pen,
						&md_env->md_id ),
				targetid = go_sup.objid,
				targetos = go_sup.osnum );
		as$status( sts = sts );

		sts = ci$send( msg	 = message NDmacro.ACconsume( 
						&msg,
						"",
						0,
						0,
						md_env ),
				targetid = as_sup.objid,
				targetos = as_sup.osnum );
		as$status( sts = sts );

	} else {
		sts = ci$send(	msg	 = message NDnodein.ACunconsume
						( &msg, "" ),
				targetid = as_sup.objid,
				targetos = as_sup.osnum );
		as$status( sts = sts );

		if( d_mod )	pen = GRbd;
		else		pen	= GRbehe;
	
		sts = ci$send(	msg	 = message GRgraphics.GRdisplay(
						&msg,
						&sup_env.md_env.matrix_type,
						sup_env.md_env.matrix,
						&pen,
						&md_env->md_id ),
				targetid = go_sup.objid,
				targetos = go_sup.osnum );
		as$status( sts = sts );
	  }

return	1;
}

