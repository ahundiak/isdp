/* $Id: VDcbound.u,v 1.1.1.1 2001/01/04 21:09:23 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vdspace/ppl / VDcbound.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDcbound.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:23  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*

 The VDbound macro create a bounded surface based on a given support,
 and limitated by surfaces or curves.
  
 The graphic template elements are the:

	- support,
	- curves (on the support) and/or surfaces.

 the algorithm is divided into 2 parts:
 	
 	- creation of a closed boundary.
 	- impose this boundary on the support (boolean diff between support
 	and a surface of projection based on the closed boundary ).
 
 ALGORITHM:
 	
	- From the surfaces, creating the intersection curves with the support.

 	- Find a dummy plane which should not be to far from the average plane.
	(The barycenter of the intersection points (curve/curve) and the 
	  normal of the surface at this point gives the plane) .

	- Projection of the curves on the plane, intersect the curves, take the
	partofcv and create the composite closed curve.

 	- Generate the surface of projection based on the composite curve in 
 	the direction of the normal and oriented in the same sense that the 
 	support.

 	- Make the boolean difference between the support and the surface of 
 	projection . 

	- compress tree
	
	- obtain the bounded surface by dropping the boolean into its components
	and keep only the support (Regenerate support if it was a composite).


	05-05-92 :	modif des mod_env :act_env.md_id.objid = NULL_OBJID
			for intermediate objects (no RTREE).		


******************************************************************/


#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"

#include "igr.h"
#include "igrtypedef.h"
#include "igrdp.h"
#include "grerr.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "exmacros.h"

#include "bstypes.h"
#include "bserr.h"
#include "bsconic.h"
#include "OMprimitives.h"

#include "EMSmsgdef.h"
#include "EMSopt.h"
#include "EMSssprops.h"
#include "EMSconstruct.h"
#include "emsdef.h"
#include "emssfintdef.h"
#include "emsbool.h"

#include "nddef.h"
#include "DIdef.h"

#include "macro.h"
#include "acmacros.h"
#include "COmdef.h"

#include "msmacros.h"
#include "msdef.h"
#include "madef.h"
#include "VDSutil_def.h"
#include "AS_status.h"

#include "DItypedef.h"
#include "DIdef.h"


#define   VERBOSE 	1
#define   EPSILON	1.0E-10
#define   MAX_TEMP	10 	/* number of templates */
#define	  MAX_CHA_TEMP	7
#define	  MAX_CHA_ROOT	4

#define	  ORDER		2

#define ACkeep_template 1024

/*
#define   DEBUG 	1
#define   DBG_TEMP 	1 
#define   DBG_PROJ 	1 
#define   DBG_INTSF 	1 
#define   DBG_INTCV 	1 
#define   DBG_PARTOF 	1 
#define   DBG_CENTER 	1 
#define   DBG_COMPCV 	1 
#define   DBG_IN 	1 
#define   DBG_BOOL 	1 
*/

/* Different kind of intersections, the first word is for the support */


struct GRid	 	CI_MACRO_ID, mac, def_temp;
GRobj 			ci_mac_def1, ci_mac_def2;
GRobj			SOLOBJ,new_objid;
GRobjid 		*return_id;
IGRchar			*temp_names[MAX_TEMP], *feet_names[1];
IGRint			temp_types[MAX_TEMP];
struct IGRbsp_curve	*bsp_curve,*curve[MAX_TEMP], *p_curve[MAX_TEMP], 
			*line,  *comp_cv, *plcurve[MAX_TEMP];
struct IGRplane		plane[2], bndpl, const_pl;
struct ret_struct	temp1_rts;
struct GRlc_info        final_curve, entries[MAX_TEMP], lc_obj[MAX_TEMP];
unsigned IGRshort       makecs_opt ;
struct         IGResbc curve_specific;

struct GRmd_env         act_env, OBJ_ENV[MAX_TEMP], MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct GRid		SPROJ, SUR[MAX_TEMP] ,comp_id,
			GRid_list, GRid_cv[MAX_TEMP], *GRint, *OBJECT, 
			INT_CURV[MAX_TEMP], PROJCV, *TODEL, TMP, TMP1;
short			*pos_orient;
enum	GRdpmode	DisplayMode;

IGRdouble		range[6],matrix[16], dirvect[3],obj_range[6],
			coef, fact,basis_tol,cht_tol, file_cht,
			plane_space[12],*over0 , *over1 ,*p_par1[MAX_TEMP], 
			*p_par2[MAX_TEMP], param,dis_fact, tangent[6],
			d_par, par, parr1,parr2[2],v1[3],v2[3],incr,
			*int_pts[MAX_TEMP],  intpts1[3], intpts2[3],*end_pts,
			accuracy_factor, dist1,dist2, dist3,value,
			*int_pts0,*int_pts1,*p_par10,*p_par11,*p_par20,*p_par21,
			center[3], *length,len,max_length, vect[3], out_vect[3],
			baryctr[3],min_dist, base[3], point1[3], point2[3],
			water_mark, test_pt[3],dir_point[3],proj_vect[3], 
			pt1[3],pt2[3],tgvect[3], dotp, q[3], u[3],left[6],
			bnd[6],right[6];
			
IGRboolean 	        eval_bound,bound,test_degeneracy, construct_loopset, 
			world, pos_orient_flag, err_flag, inside;

char			running[DI_PATH_MAX],infinite, 
			buff[MAX_TEMP*MAX_CHA_TEMP], path[80];


long			t1, t2,t, n_over, rotten_one, stat, msg, nput, 
			size, nret;
unsigned  IGRshort	trim;
IGRint			type_flag,i_onecv,nb_merge,num_deriv,nb_time,
			elem_type[MAX_TEMP],
			num_merge,num_ent,   
                        n_int,n_int1, total_num_poles, num_pts, nb_sf1,
			nb_sf2, flag, two_intersect, rev, int_flag,  
			close_cv, split_ind, i, j, k, l, index_cv[MAX_TEMP],
			found, nb_poles, tab_cv[MAX_TEMP],num_temp,
			n_pla,num_inter,nb_obj,count,max_index,min_index,
			num_pair, num_normals,nb_del,ssize, nb_cmp, ind,
			type; 

unsigned	char	props, c_props;
char			status_str[54];
BSrc			rc;

IGRshort		order, matrix_type, mat_type[MAX_TEMP-1];

OM_S_CHANSELECT   	to_comps;

unsigned       IGRshort option, map_options, imp_options;
GRclassid		obj_classid,sfid_class;


struct GRid		*list;

extern GRclassid	OPP_EMSplane_class_id, OPP_EMSsurface_class_id, 
			OPP_GRcurve_class_id,OPP_EMScompsurf_class_id,
			OPP_EMSsubbs_class_id,OPP_EMSsfimpbnd_class_id,
			OPP_GRgrgrp_class_id;

extern		EX_get_modid_given_osnum(),GRdpb_put(), UI_status(), 
		UI_message();
extern 		EMmake_chanselect();
extern void EFdraw_vector_on_screen();
extern int 	init_cnst_list(), ASsuper_construct(),
		GRdpb_get(),
		sprintf(),
		printf(),
		MAidmx(),
		BSmkvec(),
		free(),
		BScvarrevt(),
		BScvarrev0(),
		BSfreecv(),
		BScrossp(),
		BScveval_b(),
		BSmdstptcv(),
		BScvcv_int(),
		BSprptsonsf(),
	        BSsfevaln(),
		BSptperpsf(),
                BSctrarplcv(),
                BSmdistptsf(),
		BSprptonsf(),
		BSpartofcv(),
		BSpt_in_cv(),
		BSrev_cv(),
		BSalloccv(),
                BSconstprcv(),
		BSpjcvtsf(),
	        BSptlngen(),
	        BSsfptseval(),
		BSorthovec(),
		BSnorvec(),
		BSmdistcvcv(),
		BSmdstptcv(),
		BSpl_pl(),
		BSarclen(),
		BSprj_cv_pl(),
		SMelem_(),
		VDint(),
		VDSfree(),
		VDSdist2(),
		VDSfill_curve(),
		VDSorder_curves(),
		VDadd_cv_to_close(),
		VDSorder_gpe(),
		VDSorder_pt(),
		VDget_tangent_plane(),
		ACcreate_def_temp();

extern char        *malloc();
extern double      fabs(), BSdistptpt(), BSdotp();
extern		   BSpartofsf();
extern int	   EFmsgReport();
extern int         EMintersect_two_element();
extern IGRboolean  BSfreesf();


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  struct ret_struct ret_str[MAX_TEMP];
  feet_names[0] = "boundsurf";

  temp_names[0] = "accuracy_factor";  
  temp_types[0] = double_type;

  temp_names[1] = "is_infinite";
  temp_types[1] = text_type;

  temp_names[2] = "support";  
  temp_types[2] = other_generic;

  k = 3;
  for (i=0; i<MAX_TEMP-3; i=i+1)
  {
	strcpy (&buff[i*MAX_CHA_TEMP],"surf");
	sprintf(&buff[i*MAX_CHA_TEMP+MAX_CHA_ROOT],"%d",i);
	temp_names[k] = &buff[i*MAX_CHA_TEMP];
        temp_types[k] = other_generic | curve_generic | line_generic | conic_generic;
	k = k+ 1;
  }


  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          	= ci_mac_def1,
		prop 		  	= ACvariable_template|ACkeep_template,
		status 	          	= &stat,
		name              	= "VDcbound",
             	temp_num  		= MAX_TEMP,
 		temp_names 		= temp_names,
                temp_types 		= temp_types,
	      	extern_feet_num 	= 1, 
		extern_feet_names 	= feet_names);

 /* Put the default value */
 ret_str[0].type = double_type;
 ret_str[1].type = text_type;
 ret_str[2].type = other_generic;
 ret_str[3].type = other_generic;
 ret_str[4].type = other_generic;
 ret_str[5].type = other_generic;
 ret_str[6].type = other_generic;
 ret_str[7].type = other_generic;
 ret_str[8].type = other_generic;
 ret_str[9].type = other_generic;
 ret_str[0].var.root_pm_st.value= 1.;
 strcpy(ret_str[1].var.text_st.text_string, "y");
 mac.objid = ci_mac_def1;
 mac.osnum = AC_construct_id.osnum;

#if 0
 ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_temp	   = &def_temp,
		     value	   = ret_str);
#endif


  /* Modification for version 2.0 */
  ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_col       = &def_temp,
		     temp_val	   = ret_str);
}


/* ========================================================================= */

place ()
{
IGRlong		msg, sts;
struct	GRid	my_as_sup;

  surf_intersect();
  if( GRid_list.objid == NULL_OBJID ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
			(&stat, 1, &GRid_list, &MOD_ENV	),   
		targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }

  return(1);
}


/* ========================================================================= */

compute ()
{
  surf_intersect();

  //if( GRid_list.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
			(&stat,1 , &GRid_list, &MOD_ENV),
		targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }
  return(1);
}

/* ========================================================================= */

surf_intersect()

{


 /* init of pointers */

# ifdef DEBUG
  printf("surf_intersect begin\n"); 
# endif

  over0        	= NULL;
  over1        	= NULL;
  end_pts      	= NULL;
  bsp_curve    	= NULL;
  comp_cv      	= NULL;
  line	       	= NULL;
  OBJECT       	= NULL;
  length	= NULL;
  return_id 	= NULL;
  GRint     	= NULL;
  TODEL 	= NULL;
  list 		= NULL;
  
  comp_id.objid = NULL_OBJID;
  PROJCV.objid 	= NULL_OBJID;
  TMP.objid 	= NULL_OBJID;
  TMP1.objid 	= NULL_OBJID;
  GRid_list.objid = NULL_OBJID;
  
  comp_id.objid = NULL_OBJID;
  for(i=0;i<MAX_TEMP;i=i+1){
  	curve[i] 		= NULL;
  	p_curve[i] 		= NULL;
  	plcurve[i] 		= NULL;
  	p_par1[i]  		= NULL;
  	p_par2[i]  		= NULL;
  	int_pts[i]  		= NULL;
	SUR[i].objid 		= NULL_OBJID;
	INT_CURV[i].objid 	= NULL_OBJID;
	GRid_cv[i].objid 	= NULL_OBJID;
  }

  nput = sizeof(struct GRmd_env);

  gr$get_module_env(	msg    = &msg, 
                        sizbuf = &nput, 
                        buffer = &act_env, 
                        nret   = &nret);
  if(!(msg&1)){ 
    	printf("error gr$get_module_env\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }
  act_env.md_id.objid = NULL_OBJID;/* construct intermediate obj (no RTREE) */
  
  err_flag 	= FALSE;
  close_cv = 0;


  plane[0].point  = &plane_space[0];
  plane[0].normal = &plane_space[3];
  plane[1].point  = &plane_space[6];
  plane[1].normal = &plane_space[9];



  GRid_list.objid = NULL_OBJID;
  GRid_list.osnum = MOD_ENV.md_id.osnum;

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&num_temp),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);

  if(stat == OM_E_ABORT)  return(0);

  num_ent = num_temp -2;

# ifdef DEBUG
  printf("intersect surf, num_ent: %d\n", num_ent);
# endif

  if (num_ent ==0) {err_flag = TRUE;goto wrapup;}
  nput = sizeof(basis_tol);

  gr$get_basis_tolerance(msg    = &msg, 
                         sizbuf = &nput, 
                         buffer = &basis_tol, 
                         nret   = &nret);

  if(!(msg&1)){ 
    	printf("error gr$get_basis_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }

  nput = sizeof(file_cht);

  gr$get_chord_height_tolerance(msg    = &msg, 
                         	sizbuf = &nput, 
                         	buffer = &file_cht, 
                         	nret   = &nret);

  if(!(msg&1)){ 
    	printf("error gr$get_chord_height_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }

# ifdef DEBUG
  printf("basis_tolerance: %lf\n",basis_tol);
  printf("cht tol : %lf\n",file_cht);
# endif


  stat = ci$send(msg = message ACcpx.ACfind_temp_struct(&msg,
                                                  "accuracy_factor",
                                                  (char *)&temp1_rts,
                                                  &MOD_ENV ),
                       verbose = VERBOSE,
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );
  as$status(sts = stat);
  accuracy_factor =  temp1_rts.var.root_pm_st.value;


  if(accuracy_factor <= 0 || accuracy_factor > 1) 
    {
	UI_status("ERROR accuracy_factor must be include in  ]0, 1]");
	err_flag = TRUE;
	goto wrapup;
    }


# ifdef DEBUG
  printf("accuracy_factor: %lf\n",accuracy_factor);
  printf("cht tol : %lf\n",file_cht);
# endif
  cht_tol = file_cht / accuracy_factor;

# ifdef DEBUG
  printf("new cht tol : %lf\n",cht_tol);
# endif

  nput = sizeof(cht_tol);

  gr$put_chord_height_tolerance
                        (msg    = &msg,
                         sizbuf = &nput,
                         buffer = &cht_tol);

  if(!(msg&1)){ 
    	printf("error gr$put_chord_height_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }
  /*   Retrieve the template template :is_infinite  */

  stat = ci$send(msg = message ACcpx.ACfind_temp_struct(&msg,
                                                  "is_infinite",
                                                  (char *)&temp1_rts,
                                                  &MOD_ENV ),
                       verbose = VERBOSE,
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );
  as$status(sts=stat);

  infinite = temp1_rts.var.text_st.text_string[0];

# ifdef DEBUG
  printf("infinite: %c\n",infinite);
# endif



/* ----------------------------------------------------------------------- 

  Retrieve the templates and calculate the max range of the support
  
  ----------------------------------------------------------------------- */


 for(i=0;i<num_ent;i=i+1)
   {
#    ifdef DEBUG
     printf("Retrieve the template for the template \n");
#    endif

     msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,i+2,&SPROJ),
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );
#    ifdef DEBUG
     printf("SPROJ: %d, %d\n",SPROJ.objid,SPROJ.osnum );
#    endif


     if(stat != 1 ) return(0);
/*     if(stat == 3 ) SUR[i] = SPROJ;*/
     else
      {
       /* DOES NOT WORK WITH OBJECTS BELONGING TO DIFFERENTS OS */
#    	ifdef DEBUG
     	printf("ASnode.ASreturn_go\n");
#    	endif
        stat = ci$send( msg = message ASnode.ASreturn_go( 
                                          &SUR[i], 
                                          &OBJ_ENV[i].md_env.matrix_type, 
                                          OBJ_ENV[i].md_env.matrix ),
	      	        targetid = SPROJ.objid,
	                targetos = SPROJ.osnum );
        if (!(stat&1)){
		as$status(sts=stat); 
		err_flag = TRUE;
		goto wrapup; 
	}
      }
     OBJ_ENV[i].md_id = MOD_ENV.md_id;
      
     lc_obj[i].module_info = OBJ_ENV[i];
     lc_obj[i].located_obj = SUR[i];

     /* we retrieve informations in two steps because the free pb if object 
     /* has been consumed */

#    ifdef DEBUG
     printf("Retrieve the type of the element: %d, %d\n", SUR[i].objid,  
                                                         SUR[i].osnum);
#    endif

     if(i==0)
      {
        /* Only for the support */

#          ifdef DEBUG
           printf("Retrieve the range of the support\n");
#          endif

           world = TRUE;
           stat = ci$send( msg = message GRgraphics.GRgetrang(&msg, 
           					&OBJ_ENV[i].md_env.matrix_type, 
						OBJ_ENV[i].md_env.matrix, 
						&world, range),
		verbose = VERBOSE,
              targetid = SUR[0].objid,
 	      targetos = SUR[0].osnum );

	   as$status(sts=stat); 
           if (!(msg&stat&1)){ 
        	printf("ERROR in GRgraphics.GRgetrang\n" ); 
		err_flag = TRUE;
		goto wrapup; 
	   } 

#          ifdef DEBUG
           printf("range support: %lf, %lf, %lf, %lf, %lf, %lf\n",range[0],
                   range[1],range[2],range[3],range[4],range[5]);
#          endif


      }
     else 
      {
        /* i<>0 */
        /* Look for the max range : plan will be extended of that range */

        world = TRUE;
        stat = ci$send( msg = message GRgraphics.GRgetrang(&msg, 
        					&OBJ_ENV[i].md_env.matrix_type, 
						OBJ_ENV[i].md_env.matrix, 
						&world, obj_range),
		    verbose  = VERBOSE,
                    targetid = SUR[i].objid,
 	            targetos = SUR[i].osnum );
	as$status(sts=stat); 
        if (!(msg&stat&1)){ 
        	printf("ERROR in GRgraphics.GRgetrang \n"); 
		err_flag = TRUE;
		goto wrapup; 
	} 

#       ifdef DEBUG
        printf("range support: %lf, %lf, %lf, %lf, %lf, %lf\n",range[0],
                range[1],range[2],range[3],range[4],range[5]);
           
	printf("range %d: %lf, %lf, %lf, %lf, %lf, %lf\n",i,obj_range[0],
                obj_range[1],obj_range[2],obj_range[3],obj_range[4],obj_range[5]);
#       endif

	for(k=0;k<3;k=k+1)
	 {
	  if(range[k]   > obj_range[k]  ) range[k]   = obj_range[k];
	  if(range[k+3] < obj_range[k+3]) range[k+3] = obj_range[k+3];
	 }
      }
   } /* end for(i=0 ....) */

# ifdef DEBUG
  if(elem_type[0] == PLAN) printf("Max range: (%lf, %lf, %lf), (%lf, %lf, %lf)\n",range[0],range[1],range[2],range[3],range[4],range[5]);
# endif

/* ----------------------------------------------------------------------- 

   we have (num_ent) objects that will give (num_ent-1) intersection cv
   we make intersection between support and surface i and create the
   intersection curve => INT_CURVE[i-1] (geom curve[i-1] )

   ----------------------------------------------------------------------- */
 
for(i=0;i<num_ent;i=i+1){
#   ifdef DEBUG
    printf("Retrieve the topologie of: %d, %d\n", SUR[i].objid,  SUR[i].osnum);
#   endif

    if(i==0){
      /*| Only for the support */

      if (infinite != 'y' && infinite != 'Y') type_flag = SURF;
      else 				      type_flag = PLAN;

#     ifdef DEBUG
      printf("type_flag: %d\n",type_flag);
#     endif
      bsp_curve = NULL;
      nb_sf1 = 0;
      stat = SMelem_(type_flag, &SUR[0], OBJ_ENV[i].md_env.matrix_type, 
      			OBJ_ENV[i].md_env.matrix, &elem_type[0], 
		     	&plane[0], NULL, &bsp_curve, &nb_sf1);
      if (!(stat&1)){ 
      		UI_status("ERROR fonction SMelem_"); 
      		err_flag = TRUE;
      		goto wrapup; 
      	} 
      if(elem_type[0] == CURV) 
          {
          	UI_status("ERROR: support cannot be a curve");	
		err_flag = TRUE;
		goto wrapup; 
	  } 

      stat = ci$send( msg = message EMSsubbs.EMget_props(&msg, &props),
			verbose = VERBOSE,
              		targetid = SUR[0].objid,
 	      		targetos = SUR[0].osnum );
 	      
      if (!(stat&1)){ props = 0x00; }
      if(elem_type[0] != PLAN){

#          	 ifdef DEBUG
		 printf("SUR[0]: %d, %d\n",SUR[0].objid,SUR[0].osnum);
		 printf("OBJ_ENV.mat_type: %d\n",OBJ_ENV[0].md_env.matrix_type);
		 printf("OBJ_ENV: %d, %d\n",OBJ_ENV[0].md_id.objid,OBJ_ENV[0].md_id.osnum);
#          	 endif
	    	 stat = ci$send(msg = message GRgraphics.GRcopy(&msg,
                	                  &OBJ_ENV[0],&MOD_ENV, 
                	                  &(SUR[0].objid)),
		   	targetid = SUR[0].objid,
		   	targetos = SUR[0].osnum);
		as$status(sts=stat); 
     		if (!(msg&stat&1)){ 
        		printf("ERROR in GRgraphics.GRcopy \n"); 
			err_flag = TRUE;
			goto wrapup; 
     		}
     		SUR[0].osnum = MOD_ENV.md_id.osnum;
      	   	stat = ci$send (msg = message EMSsurface.EMputLsIfNotThere 
							      (	&msg, 
								&OBJ_ENV[i].md_env, 
								NULL,
								NULL,
								0,
								NULL), 
                         		targetid = SUR[0].objid, 
					targetos = SUR[0].osnum);
	   	as$status(sts=stat); 
      	   	if (!(msg&stat&1)){ 
        			printf("ERROR in EMSsurface.EMputLsIfNotThere\n"); 
				err_flag = TRUE;
				goto wrapup;
      	   	}
     		lc_obj[0].module_info = MOD_ENV;
     		lc_obj[0].located_obj = SUR[i];
      }

      if(elem_type[0] == PLAN){
#       ifdef DBG_TEMP
        printf("plane[0].point: %lf, %lf, %lf\n",plane[0].point[0],plane[0].point[1],
                 plane[0].point[2]);
        printf(" plane[0].normal: %lf, %lf, %lf\n",plane[0].normal[0],plane[0].normal[1],
		plane[0].normal[2]);
#       endif

	/* Compute the diagonal of the range */
        fact = 1.1 * BSdistptpt(&rc, range, &(range[3]));
	if(rc != BSSUCC) {printf("ERROR BSdistptpt,\n");err_flag = TRUE;goto wrapup;}
#       ifdef DBG_TEMP
	printf("fact range: %lf\n",fact);
#       endif
      }
    }
    else{
      /* i<>0 */
      if (infinite != 'y' && infinite != 'Y') type_flag = SURF;
      else 				      type_flag = PLAN;

#     ifdef DEBUG
      printf("type_flag: %d\n",type_flag);
#     endif
      GRint     = NULL;
      bsp_curve = NULL;
      nb_sf2    = 0;
      stat = SMelem_(type_flag, &SUR[i], OBJ_ENV[i].md_env.matrix_type, 
      			OBJ_ENV[i].md_env.matrix, &elem_type[i], 
		     	&plane[1], NULL, &bsp_curve, &nb_sf2);
      if (!(stat&1)){ 
      		UI_status("ERROR fct SMelem_"); 
      		err_flag = TRUE;
      		goto wrapup; 
      } 

#     ifdef DBG_TEMP
      if(elem_type[i] == PLAN){
         printf("plane[1].point: %lf, %lf, %lf\n",plane[1].point[0],
                plane[1].point[1],plane[1].point[2]);
         printf("plane[1].normal: %lf, %lf, %lf\n",plane[1].normal[0],
	        plane[1].normal[1],plane[1].normal[2]);
      }
      if(elem_type[i] == CURV) 
                printf("curve.num_poles: %d\n",bsp_curve->num_poles);
#     endif
    }/* end else ... */


    if(i==0) continue;
    index_cv[i-1] = 0;
    curve[i-1] = NULL;
    INT_CURV[i-1].objid = NULL_OBJID;
    INT_CURV[i-1].osnum = act_env.md_id.osnum;

#   ifdef DBG_INTSF
    printf("\n\nCompute intersection between the support and the surface # %d\n", i);
    printf("elem_type[0]: %d\n",elem_type[0]);
    printf("elem_type[i]: %d\n",elem_type[i]);
#   endif
    n_pla = 0;

    if(elem_type[i] == CURV) sprintf(running,"%s%d%s","Project curve ",i," on the support");
    else sprintf(running,"%s%d","intersect the support and the surface",i);
    UI_status(running);		

    if(elem_type[0] == PLAN) n_pla = 1;
    if(elem_type[i] == PLAN) n_pla = n_pla + 2;
    
#   ifdef DBG_INTSF
    printf("n_pla: %d\n",n_pla);
#   endif


    init_cnst_list();
    get_symb();

    dis.color             = cnst_list.color;
    dis.weight            = cnst_list.weight;
    dis.style             = cnst_list.style;

    cst.msg               = &msg;
    cst.env_info	  = &act_env;
    cst.newflag           = FALSE;
    cst.level             = cnst_list.level;
    cst.properties        = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
    cst.display           = &dis;
    cst.geometry          = NULL;
    cst.class_attr        = NULL;
    cst.name        	  = NULL;


    if(elem_type[i] == CURV){
#   	ifdef DBG_INTSF
    	printf("normally on surf\n");
#   	endif
    	INT_CURV[i-1].objid = SUR[i].objid;
    	INT_CURV[i-1].osnum = SUR[i].osnum;
    	continue;
    }
    else if( n_pla == 3 ){
#   	ifdef DBG_INTSF
    	printf("plan/plan intersect\n");
#   	endif
	index_cv[i-1] = 1; /* curve[i-1] must be dealloc by freecv */
      	BSpl_pl(plane[0].point, plane[0].normal, plane[1].point, plane[1].normal,
	      &int_flag, q, u, &rc);
     	if(rc != BSSUCC ){
             printf(" ERROR in BSpl_pl\n");
	     err_flag = TRUE;
	     goto wrapup;
     	}
      	if (int_flag != BSCINTERSECTING){
      		curve[i-1] = NULL;
        	if(bsp_curve != NULL) {free(bsp_curve); bsp_curve = NULL;}
		sprintf(path,"%s%d%s","WARNING: support and surface ",i," have no intersection");
		UI_message(path);
		UI_status("");
        	continue;
        }
#	ifdef DBG_INTSF
        printf("q : %lf, %lf, %lf\n",q[0],q[1],q[2]);
        printf("u : %lf, %lf, %lf\n",u[0],u[1],u[2]);
#	endif
        num_pts = 2;
        BSalloccv(ORDER, num_pts, 0, 0, &curve[i-1], &rc);
        if(rc != BSSUCC && rc!=BSNULL) 
           { 
            	UI_status("ERROR Bad dynamic allocation ");
            	err_flag = TRUE;
		goto wrapup;
           }
        curve[i-1]->order     = ORDER;
        curve[i-1]->num_poles = num_pts;
        curve[i-1]->num_knots = num_pts + 2 * (ORDER - 1);

       /* Compute the end points of the line to do the intersection */

        BSmkvec(&rc, v1, range    , q);
        BSmkvec(&rc, v2, &range[3], q);
       
        if(BSdotp(&rc,v1,v2) <= 0)
	 {
#	  ifdef DBG_INTSF
	  printf("The point of the infinit line is inside the range\n");
#	  endif
         }
        else
	 {
#	  ifdef DBG_INTSF
	  printf("The point of the infinit line is not inside the range\n");
#	  endif

	  fact = fact + BSdistptpt(&rc, q, range);
         }

        for(k=0;k<3;k=k+1)
          {
           curve[i-1]->poles[k]   = q[k] - fact * u[k];
           curve[i-1]->poles[k+3] = q[k] + fact * u[k];

#	   ifdef DBG_INTSF
	   printf("fact: %lf. Pole (q,u): %lf,%lf\n",fact,curve[i-1]->poles[k],curve[i-1]->poles[k+3]);
#	   endif

           curve[i-1]->knots[k+1] = (double) k/ (num_pts-1);
          }
        curve[i-1]->knots[0]         = 0;
        curve[i-1]->knots[num_pts+1] = 1;

	continue;
    }
    else if( n_pla == 0 ){
    		/*=========================================================*/
    		/* general routine to intersect any type of element        */
    		/*=========================================================*/
#   		ifdef DBG_INTSF
    		printf("EMintersect_two_element\n");
#   		endif
		curve_specific.is_polydis = TRUE;
     		curve_specific.is_curvedis = TRUE;

		cst.class_attr = (IGRchar *) &curve_specific;
  		trim = EMSINT_TRIM_HANDLESTOP | NULL; /* trimming option */
  		stat = EMintersect_two_element(&(lc_obj[0]),&(lc_obj[i]),trim,
  					&cst,
					&num_inter,&GRint,&msg);
		as$status(sts = stat);
		if(!(stat & msg & 1)){
        		printf("ERROR in EMintersect_two_element\n"); 
			om$report_error(sts=stat);
			err_flag = TRUE;
			goto wrapup; 
		}
    }
    else if( n_pla == 1 ){
		/*=========================================================*/
		/*  the first parent is a plane           		   */
		/*=========================================================*/
#   		ifdef DBG_INTSF
		printf("the first parent is a plane\n");
#   		endif

		stat = ci$send( msg      = message GRvg.EMintplane(
						      &cst,
        					      &plane[0], 
						      &lc_obj[i],
        					      &num_inter,
						      &GRint,
						      (int *)&msg ),
	   	 		targetid = lc_obj[i].located_obj.objid,
	   	 		targetos = lc_obj[i].located_obj.osnum );
		as$status(sts=stat); 
           	if (!(msg&stat&1)){ 
        		printf("ERROR in GRvg.EMintplane  \n"); 
			err_flag = TRUE;
			goto wrapup; 
	  	} 

    }
    else if( n_pla == 2 ){
		/*=========================================================*/
		/*  the second parent is a plane 			   */
		/*=========================================================*/

#   		ifdef DBG_INTSF
		printf("the second parent is a plane\n");
#   		endif

		stat = ci$send( msg      = message GRvg.EMintplane(
						      &cst,
        					      &plane[1], 
						      &lc_obj[0],
        					      &num_inter,
						      &GRint,
						      (int *)&msg ),
	   			targetid = lc_obj[0].located_obj.objid,
	   			targetos = lc_obj[0].located_obj.osnum );
		as$status(sts=stat); 
          	if (!(msg&stat&1)){ 
        		printf("ERROR in GRvg.EMintplane  \n"); 
			err_flag = TRUE;
			goto wrapup; 
	  	} 
    }
#   ifdef DBG_INTSF
    printf("num_inter: %d\n",num_inter);
#   endif

    if(num_inter < 1) {
#       	ifdef DBG_INTSF
        	printf("surf_int: (num_inter<1)no intersection found with the %d surface\n",i);
#       	endif
		sprintf(path,"%s%d%s","WARNING: support and surface ",i," have no intersection");
		UI_message(path);
		UI_status("");
        	curve[i-1] = NULL;
        	if(bsp_curve != NULL) {free(bsp_curve); bsp_curve = NULL;}
        	continue;
    }

#       ifdef DBG_INTSF
    	for(k=0;k<num_inter;k=k+1)
    		printf("GRint = %d, %d\n",GRint[k].objid, GRint[k].osnum);
#       endif
	
	if(num_inter > 1){
			/* -----------
			   normally impossible because the method and the 
			   function return the result as a graphic gpe or 
			   composite if nb_int > 1 
			  
			----------- */
			
			UI_status("ERROR EMintersect_two_element, nb_int > 1 ???");
          		printf("ERROR EMintersect_two_element, nb_int: %d \n",num_inter);
    			for(k=0;k<num_inter;k=k+1)
    			printf("GRint = %d, %d\n",GRint[k].objid, GRint[k].osnum);
			err_flag = TRUE;
			goto wrapup;
	}

 	stat = om$get_classid(	osnum     = GRint[0].osnum, 
			 	objid     = GRint[0].objid, 
			 	p_classid = &obj_classid);
 	if( om$is_ancestry_valid(subclassid   = obj_classid,
			  superclassid = OPP_GRgrgrp_class_id )
			   == OM_S_SUCCESS ){         	
#   		ifdef DBG_INTSF
   		printf("This is a GRgrgrp classe \n");
#       	endif
		sprintf(path,"%s%d%s","support and surface ",i," have more than one intersection");
		UI_message(path);
		UI_status("WARNING: only take longest intersection with support");
    		stat = ci$send( msg = message GRowner.GRget_number_components
							(&msg, &nb_obj), 
	      	        targetid = GRint[0].objid,
	                targetos = GRint[0].osnum );
		as$status(sts=stat); 
           	if (!(msg&stat&1)){ 
        		printf("ERROR in GRowner.GRget_number_components\n"); 
			err_flag = TRUE;
			goto wrapup; 
	  	} 

#   		ifdef DBG_INTSF
		printf("GRget_number_components nb_obj: %d\n",nb_obj);
#       	endif

		OBJECT = NULL;
		OBJECT =  (struct GRid *) malloc(nb_obj*sizeof(struct GRid));
		if(OBJECT == NULL){
			UI_status("ERROR Bad dynamic allocation ");
			err_flag = TRUE;
			goto wrapup;
		}

    		stat = ci$send( msg = message GRowner.GRget_components
					(&msg, &act_env,OBJECT, nb_obj, 
					 &count,0,nb_obj), 
	      	        targetid = GRint[0].objid,
	                targetos = GRint[0].osnum );
		as$status(sts=stat); 
           	if (!(msg&stat&1)){ 
        		printf("ERROR in GRowner.GRget_components \n"); 
			err_flag = TRUE;
			goto wrapup; 
	  	} 

#   		ifdef DBG_INTSF
		printf("GRget_components return count: %d\n",count);
		for(k=0;k<count;k=k+1) 
			printf("obj: %d, %d\n",OBJECT[k].objid, OBJECT[k].osnum);
#       	endif


		length = NULL;
		length =  (double *) malloc(nb_obj*sizeof(double));
		if(length == NULL){
			UI_status("ERROR Bad dynamic allocation ");
			err_flag = TRUE;
			goto wrapup;
		}
		for(k=0;k<count;k=k+1) {

			length[k] = 0;
	    		stat = ci$send( msg = message GRcurve.GRtotlength
	  					(&msg, 
						&act_env.md_env.matrix_type, 
						act_env.md_env.matrix, 
						&length[k]), 
	      	        targetid = OBJECT[k].objid,
	                targetos = OBJECT[k].osnum );
			as$status(sts=stat); 
           		if (!(msg&stat&1)){ 
        			printf("ERROR in GRcurve.GRtotlength \n"); 
				err_flag = TRUE;
				goto wrapup; 
	  		} 

#   		ifdef DBG_INTSF
		printf("length[%d]: %lf\n",k,length[k]);
#       	endif
		}
		max_length = 0;
		max_index  = 0;
		for(k=0;k<count;k=k+1) {
			if(length[k] > max_length) {
				max_length = length[k];
				max_index  = k;
			}
		}
#   		ifdef DBG_INTSF
		printf("max_index: %d,max_length: %lf\n" ,max_index,max_length);
#       	endif

		GRint[0] = OBJECT[max_index];
		for(k=0;k<count;k=k+1) {
			if(k != max_index){
			  	stat = ci$send(	msg = message GRgraphics.GRdelete(
			  				&msg, &act_env),
			  			targetid = OBJECT[k].objid ,
						targetos = OBJECT[k].osnum);
				OBJECT[k].objid = NULL_OBJID;
				as$status(sts=stat); 
				if (!(stat&1)){ 
    					printf("ERROR in GRgraphics.GRdelete \n"); 
					err_flag = TRUE;
					goto wrapup; 
		  
				}
			}
				
		}

#   		ifdef DBG_INTSF
		printf("new GRint[0]: %d, %d\n",GRint[0].objid,GRint[0].osnum);
#       	endif
	}/* end of treatement of group */

    	INT_CURV[i-1].objid = GRint[0].objid;
    	INT_CURV[i-1].osnum = GRint[0].osnum;
    	if(bsp_curve 	!= NULL){free(bsp_curve);bsp_curve = NULL;}
    	if(GRint 	!= NULL){free(GRint); GRint = NULL;}
    	if(OBJECT 	!= NULL){free(OBJECT); OBJECT = NULL;}
 
}  /* End of  for(i=0;i<num_ent;i=i+1) */


for(i=0;i<num_ent-1;i=i+1) {
	if(INT_CURV[i].objid == NULL_OBJID) continue;
#	ifdef DBG_INTCV
	printf("INT_CURV getgeom: %d\n",INT_CURV[i].objid);
#	endif

    	stat = ci$send(msg = message GRvg.GRgetsize(&msg, 
    						&act_env.md_env.matrix_type, 
    						act_env.md_env.matrix, 
						&size ),
	  	   targetid = INT_CURV[i].objid,
	  	   targetos = INT_CURV[i].osnum );
	as$status(sts=stat); 
    	if (!(stat&1)){ 
        	printf("ERROR in GRvg.GRgetsize \n"); 
    		err_flag = TRUE;
    		goto wrapup;
    	} 
    	curve[i] = NULL;
    	curve[i] = (struct IGRbsp_curve *) malloc(size);
    	if(curve[i] == NULL) {
      		UI_status("ERROR Bad dynamic allocation ");
      		err_flag = TRUE;
      		goto wrapup;
     	}
    	stat = ci$send(msg = message GRvg.GRgetgeom(&msg, 
    					&act_env.md_env.matrix_type, 
                                  	act_env.md_env.matrix, 
                                  	(char *) curve[i]),
	  	    targetid = INT_CURV[i].objid,
	  	    targetos = INT_CURV[i].osnum );
	as$status(sts=stat); 
    	if (!(stat&1)){ 
        	printf("ERROR in GRvg.GRgetgeom  \n"); 
		err_flag = TRUE;
		goto wrapup;
    	}
    
 }  /* End of  for(i=0;i<num_ent-1;i=i+1) */


#ifdef DBG_INTCV
for(i=0;i<num_ent-1;i=i+1) {
	if(INT_CURV[i].objid == NULL_OBJID) continue;
	printf("INT_CURV returned : %d\n",INT_CURV[i].objid);
	printf("num_poles: %d\n",curve[i]->num_poles);
}
#endif


#ifdef DBG_INTCV
 for(i=0;i<num_ent-1;i=i+1)
    if(curve[i] == NULL) printf("curve[%d] est NULL\n",i);
#endif

 num_merge = 0;
 i_onecv = -1;
 k = 0;
 for(i=0;i<num_ent-1;i=i+1)
  { 
    if(curve[i] != NULL) 
       {tab_cv[k] = i;k = k+ 1;num_merge = num_merge + 1;i_onecv = i; }
#   ifdef DBG_INTCV
    printf("i_onecv: %d\n",i_onecv);
#   endif
  }

# ifdef DBG_INTCV
  printf("num_merge: %d\n",num_merge);
  for(i=0;i<num_merge;i=i+1) printf("tab[%d]: %d\n",i,tab_cv[i]);
# endif

  if(num_merge == 0)
   {
    	UI_status("ERROR:no intersection between support and any surface");
    	err_flag = TRUE;
	goto wrapup;
   }
  if(num_merge == 1)
   {
    
#      	ifdef DBG_INTCV
	printf("num_merge == 1  curve %d\n",i_onecv);
 #       endif

    	coef = 0;
        for(k=0;k<3;k=k+1) 
        coef = coef + fabs(curve[i_onecv]->poles[k] - 
			      curve[i_onecv]->poles[3*(curve[i_onecv]->num_poles-1)+k]);
#      	ifdef DBG_INTCV
	printf("close curve ?, coef: %lf\n",coef);
#       endif

	if (coef < basis_tol)
	  {
#       	  ifdef DBG_INTCV
		  printf("close curve\n");
#       	  endif
		  close_cv = 1;
       	  }
   }

if(num_merge == 1 && !close_cv) 
 {
  UI_status("ERROR cannot create a bounded surface with an open curve");
  err_flag = TRUE;
  goto wrapup;
 }

if(elem_type[0] == PLAN){
	for(i=0; i<num_merge;i=i+1){
#		ifdef DBG_INTCV
		printf("project curve %d on support plan\n",i);
#		endif
 		sprintf(running,"%s%d%s","Project curve ",i," on plan support" );
		UI_status(running);		
	
		plcurve[i] = NULL;
        	BSalloccv(	curve[i]->order, 
			curve[i]->num_poles, 
			curve[i]->rational, 
			curve[i]->num_boundaries,
 			&plcurve[i], 
			&rc);
		if(rc != BSSUCC && rc!=BSNULL){ 
              		UI_status("ERROR Bad dynamic allocation ");
              		err_flag = TRUE;
	      		goto wrapup;
        	}
		BSprj_cv_pl(&rc, curve[i], &plane[0].point[0], &plane[0].normal[0], 
			plane[0].normal, plcurve[i]); 
		if(rc!=BSSUCC) {
    			printf("ERROR BSprj_cv_pl: no projection curve\n");
    			err_flag = TRUE;
    			goto wrapup;
		}
#		ifdef DBG_INTCV
 		for(k=0;k< plcurve[i]->num_poles&& k<5;k=k+1)
        		printf("pts: %lf, %lf, %lf\n", 
                	plcurve[i]->poles[3*k],plcurve[i]->poles[3*k+1],plcurve[i]->poles[3*k+2]);
#		endif
	}
	

}
else{

	/* ------------------------------------------------------------------- 
		We approximate the support with a plane (point and normal):
		Compute the minimum distance between each curve and its 
		successor and get the barycenter of these approximative
		intersection points in order to have a point in the area
		we want to extract, the plane taken will be the tangent plane 
		to the support at this point.
   	-------------------------------------------------------------------- */
	UI_status("Compute the dummy plane of projection");
#   	ifdef DBG_INTCV
    	printf("COMPUTE THE MINIMUM DISTANCE between curves\n");
#   	endif

	i = -1;
	two_intersect = 0;

	baryctr[0] = 0.;
	baryctr[1] = 0.;
	baryctr[2] = 0.;

	while(i<num_merge-1){
    		if(close_cv) 			break;
    		if(num_merge == 1) 		break;
	   	
    		p_par1[i+1]  = NULL;
    		p_par2[i+1]  = NULL;
    		int_pts[i+1] = NULL;
		int_pts1     = NULL;

#   		ifdef DBG_INTCV
    		printf("i: %d, num_merge: %d ...................\n",i,num_merge);
#   		endif
    		if(i==-1 && num_merge == 2) {i=i+1;continue;}/*2 cv on support */
    		n_int = 0;
    		if(i==-1 ){
#   	 		ifdef DBG_INTCV
         		printf("intersect cv[%d] et cv[%d]\n",tab_cv[num_merge-1],tab_cv[0]);
#   	 		endif

     	 		BSmdistcvcv(curve[tab_cv[num_merge-1]],curve[tab_cv[0]], &n_int, 
     		    		&p_par1[0], &p_par2[0] , &int_pts[0],
				&int_pts1, &dist1, &rc);
     		}
    		else{
#   	 		ifdef DBG_INTCV
         		printf("intersect cv[%d] et cv[%d]\n",tab_cv[i],tab_cv[i+1]);
#   	 		endif
     	 		BSmdistcvcv(curve[tab_cv[i]],curve[tab_cv[i+1]], &n_int, 
     		    		&p_par1[i+1], &p_par2[i+1] , &int_pts[i+1],
				&int_pts1, &dist1, &rc);
     		}
     		if(rc != BSSUCC ){
             		printf(" ERROR in BSmdistcvcv\n");
	     		err_flag = TRUE;
	     		goto wrapup;
     		}
#   		ifdef DBG_INTCV
     		printf("dist: %lf\n",dist1);
     		printf("nb: %d\n",n_int);

#   		endif
     		if(dist1 > 10*cht_tol || n_int < 1) {
             		UI_status("ERROR no intersection between 2 curves");
	     		err_flag = TRUE;
	     		goto wrapup;
     		}

      		else if(n_int > 2 || (n_int == 2 && num_merge > 2)){
	     		UI_status("ERROR ,curve with more than 2 intersections");
	     		err_flag = TRUE;
	     		goto wrapup;
		}
		else if(n_int == 2 && num_merge == 2){
	    		two_intersect=1;
#           		ifdef DBG_INTCV
            		printf(" Specific case, two curves and two intersections \n");
#           		endif

#   	    		ifdef DBG_INTCV
	    		printf("intpts0: %lf, %lf, %lf\n",int_pts[i+1][0],int_pts[i+1][1],int_pts[i+1][2]);
	    		printf("intpts1: %lf, %lf, %lf\n",int_pts[i+1][3],int_pts[i+1][3],int_pts[i+1][5]);
#   	    		endif
	    		baryctr[0] = (int_pts[i+1][3] + int_pts[i+1][0])/2;
	    		baryctr[1] = (int_pts[i+1][4] + int_pts[i+1][1])/2;
	    		baryctr[2] = (int_pts[i+1][5] + int_pts[i+1][2])/2;
	    		break;		
		}
			
#        	ifdef DBG_INTCV 
         	printf("good intersection\n");
         	printf("number of intersection: %d, de over: %d\n", n_int, n_over);
         	for(k=0; k<n_int && k<10; k=k+1){
            		printf("coord sur le sup: %lf, %lf, %lf\n",int_pts[i+1][3*k],int_pts[i+1][3*k+1],int_pts[i+1][3*k+2]);
            		printf("param: %lf\n",   p_par1[i+1][k]);
            		printf("param: %lf\n\n", p_par2[i+1][k]);
          	}
#        	endif
   		if(int_pts1   != NULL) {free(int_pts1)   ; int_pts1 = NULL;}
   		if(p_par1[i+1]!= NULL) {free(p_par1[i+1]); p_par1[i+1] = NULL;}
   		if(p_par2[i+1]!= NULL) {free(p_par2[i+1]); p_par2[i+1] = NULL;}
		i=i+1;

	}/* end while */

	if(!two_intersect && !close_cv){
#   		ifdef DBG_INTCV
    		printf("COMPUTE THE BARYCENTER POINTS \n");
#   		endif


		for(i=0;i<num_merge;i=i+1){
#   			ifdef DBG_INTCV
			printf("intpts: %lf, %lf, %lf\n",int_pts[i][0],int_pts[i][1],int_pts[i][2]);
#   			endif
			baryctr[0] = baryctr[0] + int_pts[i][0];
			baryctr[1] = baryctr[1] + int_pts[i][1];
			baryctr[2] = baryctr[2] + int_pts[i][2];
		}
		baryctr[0] = baryctr[0]/(num_merge);
		baryctr[1] = baryctr[1]/(num_merge);
		baryctr[2] = baryctr[2]/(num_merge);
	}
	for(i=0;i<num_merge;i=i+1)
   	  if(int_pts[i] != NULL) {free(int_pts[i]) ; int_pts[i] = NULL;}

	if(close_cv){
#		ifdef DBG_INTCV
 		printf("close_cv, baryctr will be the center of curve %d, %d\n",
 			INT_CURV[i_onecv].objid,INT_CURV[i_onecv].osnum);
#		endif
		stat = ci$send( msg = message GRvg.GRcenter( 
						 &msg, 
						 &act_env.md_env.matrix_type,
						 act_env.md_env.matrix,
           					 baryctr),
           	targetid = INT_CURV[i_onecv].objid,
	   	targetos = INT_CURV[i_onecv].osnum  );

		as$status(sts=stat); 
		if( !(msg&stat&1) ){
     			printf(" GRvg.GRcenter fail \n");
    			err_flag = TRUE;
    			goto wrapup;
		}

	}
#	ifdef DBG_INTCV
 	printf("baryctr: %lf, %lf, %lf\n",baryctr[0],baryctr[1],baryctr[2]);
#	endif

	const_pl.point  = &plane_space[0];
	const_pl.normal = &plane_space[3];


	
	stat = VDget_tangent_plane(elem_type[0], &SUR[0], &plane[0], &MOD_ENV,
			baryctr, &const_pl);
	if (stat != 1){ 
		UI_status("ERROR fct VDget_tangent_plane");
		err_flag = TRUE; 
		goto wrapup; 
	} 
#	ifdef DBG_INTCV
	printf("const_pl.point : %lf, %lf, %lf\n",const_pl.point[0],const_pl.point[1],const_pl.point[2]);
	printf("const_pl.normal: %lf, %lf, %lf\n",const_pl.normal[0],const_pl.normal[1],const_pl.normal[2]);
#	endif
	


	/* we must mv the plan totaly above or below the support */

#	ifdef DBG_INTCV
 	printf("range[0]: %lf, %lf, %lf\n",range[0],range[1],range[2]);
 	printf("range[3]: %lf, %lf, %lf\n",range[3],range[4],range[5]);
#	endif
 
 	fact = 1.1 ;
 	test_pt[0] = const_pl.point[0] - fact *const_pl.normal[0];
 	test_pt[1] = const_pl.point[1] - fact *const_pl.normal[1];
 	test_pt[2] = const_pl.point[2] - fact *const_pl.normal[2];

#	ifdef DBG_INTCV
	printf("test_pt: %lf, %lf, %lf\n",test_pt[0],test_pt[1],test_pt[2]);
#	endif

 	while( test_pt[0] > range[0] && test_pt[1] > range[1] && 
		test_pt[2] > range[2] && test_pt[0] < range[3] && 
		test_pt[1] < range[4] && test_pt[2] < range[5]){
#		ifdef DBG_INTCV
		printf("pt : %lf, %lf, %lf\n",test_pt[0],test_pt[1],test_pt[2]);
#		endif
		fact = 2*fact;
		test_pt[0] = test_pt[0] - fact *const_pl.normal[0];
 		test_pt[1] = test_pt[1] - fact *const_pl.normal[1];
 		test_pt[2] = test_pt[2] - fact *const_pl.normal[2];
 	}



	const_pl.point[0] = test_pt[0];
	const_pl.point[1] = test_pt[1];
	const_pl.point[2] = test_pt[2];

/****
 
   A PREVOIR : utiliser le pdt vectoriel pour obtenir le plus proche point en 
   dehors du range.

****/

#	ifdef DBG_INTCV
	printf("const_pl.point taken: %lf, %lf, %lf\n",const_pl.point[0],const_pl.point[1],const_pl.point[2]);
#	endif

	for(i=0; i<num_merge;i=i+1){
#		ifdef DBG_INTCV
		printf("project curve %d on const_pl\n",i);
#		endif
 		sprintf(running,"%s%d%s","Project curve ",i," on dummy plane" );
		UI_status(running);		
	
		plcurve[i] = NULL;
        	BSalloccv(	curve[i]->order, 
			curve[i]->num_poles, 
			curve[i]->rational, 
			curve[i]->num_boundaries,
 			&plcurve[i], 
			&rc);
		if(rc != BSSUCC && rc!=BSNULL){ 
              		UI_status("ERROR Bad dynamic allocation ");
              		err_flag = TRUE;
	      		goto wrapup;
             	}
		BSprj_cv_pl(&rc, curve[i], &const_pl.point[0], &const_pl.normal[0], 
			const_pl.normal, plcurve[i]); 
		if(rc!=BSSUCC) {
    			printf("ERROR BSprj_cv_pl: no projection curve\n");
    			err_flag = TRUE;
    			goto wrapup;
		}
#		ifdef DBG_INTCV
 		for(k=0;k< plcurve[i]->num_poles&& k<5;k=k+1)
        		printf("pts: %lf, %lf, %lf\n", 
                	plcurve[i]->poles[3*k],plcurve[i]->poles[3*k+1],plcurve[i]->poles[3*k+2]);
#		endif
	
	
	}

}/* elem_type[0] not plan */



for(i=0; i<num_merge; i=i+1){
     	if(curve[i]!=NULL){
     		if(index_cv[i] == 0) free(curve[i]); 
     		else{
               		BSfreecv(&rc, curve[i]);
	       		if (rc !=BSSUCC && rc!=BSNULL){ 
                		printf("BSfreecv(plcurve) fail\n");
                		err_flag = TRUE;
                		goto wrapup;
               		}
        	}
     		curve[i] = NULL;	
     	}
}

#   ifdef DBG_INTCV
    printf("COMPUTE THE INTERSECTION POINTS of curves in the plane\n");
#   endif

    UI_status("Compute the intpts of curves on the plane");		


for(i=0;i<num_merge-1;i=i+1){
    	p_par1[i]  = NULL;
    	p_par2[i]  = NULL;
    	int_pts[i] = NULL;
}	
i = -1;
two_intersect = 0;
while(i<num_merge-1){

    	over0      = NULL;
    	over1      = NULL;
    	end_pts    = NULL;
    	if(close_cv) 		break;
    	if(num_merge == 1) 	break;
    	if(i==-1 && num_merge == 2) {i=i+1;continue;}/*2 cv on support */

#   	ifdef DBG_INTCV
    	printf("i: %d, num_merge: %d ...................\n",i,num_merge);
#   	endif

    	n_int = 0;
    	if(i==-1 ){
#   	 ifdef DBG_INTCV
         printf("intersect cv[%d] et cv[%d]\n",tab_cv[num_merge-1],tab_cv[0]);
#   	 endif

         BScvcv_int(&rc, plcurve[tab_cv[num_merge-1]], plcurve[tab_cv[0]], &n_int, 
		    &int_pts[0], &p_par1[0], &p_par2[0], &n_over, &end_pts, 
		    &over0, &over1);
     	}
    	else{
#   	 ifdef DBG_INTCV
         printf("intersect cv[%d] et cv[%d]\n",tab_cv[i],tab_cv[i+1]);
#   	 endif
         BScvcv_int(&rc, plcurve[tab_cv[i]], plcurve[tab_cv[i+1]], &n_int, 
		    &int_pts[i+1], &p_par1[i+1], &p_par2[i+1], &n_over, 
		    &end_pts, &over0, &over1);
     	}


    	if(rc != BSSUCC || n_over > 0 ){
       		UI_status("ERROR bad curve intersection ");
       		err_flag = TRUE;
       		goto wrapup;
      	}

      	if(n_int < 1){
	     UI_status("ERROR ,2 cv without any intersection");
	     err_flag = TRUE;
	     goto wrapup;
	}
      	else if(n_int > 2 || (n_int == 2 && num_merge > 2)){
	     UI_status("ERROR ,curve with more than 2 intersections");
	     err_flag = TRUE;
	     goto wrapup;
	}
	else if(num_merge == 2 && n_int < 2){
	     UI_status("ERROR , 2 curves and only one intersection\n");
	     err_flag = TRUE;
	     goto wrapup;
	}
	else if(n_int == 2 && num_merge == 2){
	    two_intersect=1;
#           ifdef DBG_INTCV
            printf(" Specific case, two curves and two intersections \n");
#           endif

#   	    ifdef DBG_INTCV
	    printf("intpts0: %lf, %lf, %lf\n",int_pts[i+1][0],int_pts[i+1][1],int_pts[i+1][2]);
	    printf("intpts1: %lf, %lf, %lf\n",int_pts[i+1][3],int_pts[i+1][4],int_pts[i+1][5]);
#   	    endif
	    UI_status("Extract partof curves between intpts");
            p_curve[0] 	   = NULL;
            order 	   = plcurve[0]->order;
            BSalloccv(order, plcurve[0]->num_poles + 2 * order - 1, 
                      plcurve[0]->rational, plcurve[0]->num_boundaries ,
                      &p_curve[0], 
                      &rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
               UI_status("ERROR Bad dynamic allocation ");
               err_flag = TRUE;
	       goto wrapup;
             }
            d_par=(p_par1[1][1]+p_par1[1][0])/2;
            if(p_par1[1][1] > p_par1[1][0]) rev = 1;
            else		                 rev = 0;

#           ifdef DBG_PARTOF

            printf("p_par1[1][1]: %lf, p_par1[1][0]: %lf\n",p_par1[1][1],p_par1[1][0]);
            printf("plcurve 0 d_par: %lf\n",d_par);
#           endif

            BSpartofcv(&rc, plcurve[0], p_par1[1][1], d_par, p_par1[1][0], p_curve[0]);
            if(rc != BSSUCC) 
             { 
              printf("surf_int, Bad extraction of the part of plcurve 1\n");
              err_flag = TRUE;
	      goto wrapup;
             }
            if(p_par1[1]   != NULL) {free(p_par1[1]); p_par1[1] = NULL;}
	    if(plcurve[0]!=NULL)
             {
               BSfreecv(&rc, plcurve[0]);
               plcurve[0]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(plcurve) fail\n");err_flag = TRUE;goto wrapup;}
             }

            if(rev)   
	     {
	       BSrev_cv(&rc, p_curve[0]);
               if(rc != BSSUCC) 
                {
                  printf("surf_int, ERROR cannot reverse the curve\n");
       	          err_flag = TRUE;
		  goto wrapup;
                }
	     }
#           ifdef DBG_PARTOF
            printf("\n\n");
            printf("num_poles: %d\n",p_curve[0]->num_poles);
            for(k=0;k<p_curve[0]->num_poles && k < 5;k=k+1)
            printf("poles of the part curve 0: %lf, %lf, %lf\n",p_curve[0]->poles[3*k],  
            p_curve[0]->poles[3*k+1],p_curve[0]->poles[3*k+2]);
#           endif
            if(p_curve[0]->rational)
             {
               for(k=0;k<p_curve[0]->num_poles;k=k+1)
	        {
		   p_curve[0]->poles[3*k]   = p_curve[0]->poles[3*k]/
						p_curve[0]->weights[k];
		   p_curve[0]->poles[3*k+1] = p_curve[0]->poles[3*k+1]/
						p_curve[0]->weights[k];
		   p_curve[0]->poles[3*k+2] = p_curve[0]->poles[3*k+2]/
						p_curve[0]->weights[k];
	        }
	       p_curve[0]->rational = 0;
	       if(p_curve[0]->weights)
	         {
		   free(p_curve[0]->weights);
		   p_curve[0]->weights  = NULL;
	         }
             }

            p_curve[1] = NULL;
            order = plcurve[1]->order;
            BSalloccv(order, plcurve[1]->num_poles + 2 * order - 1,
		   plcurve[1]->rational, plcurve[1]->num_boundaries, 
		   &p_curve[1], &rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
               	UI_status("ERROR Bad dynamic allocation ");
               	err_flag = TRUE;
	       	goto wrapup;
             }
            d_par=(p_par2[1][0]+p_par2[1][1])/2;
            if( p_par2[1][0]> p_par2[1][1]) rev = 1;
            else		                rev = 0;

# 	    ifdef DBG_PARTOF
            printf("p_par2[1][0]: %lf, p_par2[1][1]: %lf\n",p_par2[1][0],p_par2[1][1]);
            printf("plcurve 1 d_par: %lf\n",d_par);
# 	    endif
     
            BSpartofcv(&rc, plcurve[1],p_par2[1][0], d_par,p_par2[1][1], p_curve[1]);
            if(rc != BSSUCC) 
             { 
              printf("surf_int, Bad extraction of the part of curve 0\n");
              err_flag = TRUE;
	      goto wrapup;
             }
            if(p_par2[1]   != NULL) {free(p_par2[1]); p_par2[1] = NULL;}
	    if(plcurve[1]!=NULL) 
             {
               BSfreecv(&rc, plcurve[1]);
               plcurve[1]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                  {
			printf("BSfreecv(plcurve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		  }
             }
            if(rev)     
	     {
	       BSrev_cv(&rc, p_curve[1]);
               if(rc != BSSUCC) 
                 { 
       		   printf("surf_int, ERROR cannot reverse the curve\n");
       		   err_flag = TRUE;
		   goto wrapup;
                 }
	     }
#           ifdef DBG_PARTOF
            for(k=0;k<p_curve[1]->num_poles && k< 5 ;k=k+1)
            printf("poles of the part_curve 1: %lf, %lf, %lf\n", p_curve[1]->poles[3*k], p_curve[1]->poles[3*k+1],p_curve[1]->poles[3*k+2]);
#           endif
            if(p_curve[1]->rational)
             {
               for(k=0;k<p_curve[1]->num_poles;k=k+1)
	        {
		   p_curve[1]->poles[3*k]   = p_curve[1]->poles[3*k]/
						p_curve[1]->weights[k];
		   p_curve[1]->poles[3*k+1] = p_curve[1]->poles[3*k+1]/
						p_curve[1]->weights[k];
		   p_curve[1]->poles[3*k+2] = p_curve[1]->poles[3*k+2]/
						p_curve[1]->weights[k];
	        }
	       p_curve[1]->rational = 0;
	       if(p_curve[1]->weights)
	         {
		   free(p_curve[1]->weights);
		   p_curve[1]->weights  = NULL;
	         }
             }/* rational */

            if(p_par1[0] != NULL) {free(p_par1[0]) ; p_par1[0]  = NULL;}
            if(p_par2[0] != NULL) {free(p_par2[0]) ; p_par2[0]  = NULL;}
   	    if(int_pts[0]!= NULL) {free(int_pts[0]); int_pts[0] = NULL;}
   	    if(over0     != NULL) {free(over0)     ; over0      = NULL;}
   	    if(over1     != NULL) {free(over1)     ; over1      = NULL;}
   	    if(end_pts   != NULL) {free(end_pts)   ; end_pts    = NULL;}

	    break;		
	}/* end n_int == 2 && num_merge == 2 */
	
#       ifdef DBG_INTCV 
        printf("good intersection\n");
        printf("number of intersection: %d, de over: %d\n", n_int, n_over);
        for(k=0; k<n_int && k<10; k=k+1)
          {
            printf("coord sur le sup: %lf, %lf, %lf\n",int_pts[i+1][3*k],int_pts[i+1][3*k+1],int_pts[i+1][3*k+2]);
            printf("param: %lf\n",   p_par1[i+1][k]);
            printf("param: %lf\n\n", p_par2[i+1][k]);
          }
#       endif
   	if(over0   != NULL) {free(over0)  ; over0   = NULL;}
   	if(over1   != NULL) {free(over1)  ; over1   = NULL;}
   	if(end_pts != NULL) {free(end_pts); end_pts = NULL;}
	i=i+1;

}/* end while */

#     ifdef DBG_PARTOF
      printf("EXTRACT THE GOOD PARTS ...........\n");
#     endif
      UI_status("Extract partof curves between intpts");

for(i=0;i<MAX_TEMP ;i=i+1) 
	if(!two_intersect) p_curve[i] = NULL;

for(i=0;i<num_merge ;i=i+1){
	if(two_intersect) 	break;
    	if(close_cv) 		break;
    	if(num_merge == 1) 	break;

      	intpts1[0]	  = -1.;
      	intpts1[1]	  = -1.;
      	intpts1[2]	  = -1.;

      	intpts2[0]	  = -1.;
      	intpts2[1]	  = -1.;
      	intpts2[2]	  = -1.;

#     	ifdef DBG_PARTOF
      	printf("Extract part of plcurve # %d\n",tab_cv[i]);
#     	endif

        if(tab_cv[i] == tab_cv[num_merge-1]){
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] == tab_cv[num_merge-1]\n");
#	    endif
	    par   = p_par1[0][0];
	    parr1 = p_par2[num_merge-1][0];
	    intpts1[0] = int_pts[num_merge-1][0];
	    intpts1[1] = int_pts[num_merge-1][1];
	    intpts1[2] = int_pts[num_merge-1][2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
        }
        else{
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] != tab_cv[num_merge-1]\n");
#	    endif
            par   = p_par1[i+1][0];
	    parr1 = p_par2[i][0];
	    intpts1[0] = int_pts[i][0];
	    intpts1[1] = int_pts[i][1];
	    intpts1[2] = int_pts[i][2];

	    intpts2[0] = int_pts[i+1][0];
	    intpts2[1] = int_pts[i+1][1];
	    intpts2[2] = int_pts[i+1][2];
        }
      	d_par = (parr1 + par)/2.;
      	if(parr1 > par) 	rev = 1;
      	else			rev = 0;
      	order = plcurve[tab_cv[i]]->order;
      	BSalloccv(order, plcurve[tab_cv[i]]->num_poles + 2 * order - 1, 
		plcurve[tab_cv[i]]->rational,plcurve[tab_cv[i]]->num_boundaries, 
                &p_curve[i], &rc);
      	if(rc != BSSUCC && rc!=BSNULL) { 
        	UI_status("ERROR Bad dynamic allocation ");
        	err_flag = TRUE;
		goto wrapup;
       	}
#     	ifdef DBG_PARTOF
      	printf("BSpartofcv de plcurve %d\n",tab_cv[i]);
      	printf("parms: %lf, %lf, %lf\n",parr1, d_par, par);
#     	endif
      	BSpartofcv(&rc, plcurve[tab_cv[i]], parr1, d_par, par, p_curve[i]);
      	if(rc != BSSUCC){ 
        	printf("surf_int, Bad extraction of the part of plcurve # %d\n", tab_cv[i]);
        	err_flag = TRUE;
		goto wrapup;
       	}
      	if(rev){
        	BSrev_cv(&rc, p_curve[i]);
        	if(rc != BSSUCC){ 
          		printf("surf_int, ERROR cannot reverse the curve\n");
          		err_flag = TRUE;
	  		goto wrapup;
         	}
       	}
#     	ifdef DBG_PARTOF   

      	printf("\n\nBSpartofcv de curve %d ......\n",i);
      	printf("intpts1: %lf, %lf, %lf\n",intpts1[0],intpts1[1],intpts1[2]);
      	printf("intpts2: %lf, %lf, %lf\n",intpts2[0],intpts2[1],intpts2[2]);
      	printf("partofcv result %d\n",i);
      	printf("pole0: %lf, %lf, %lf\n", p_curve[i]->poles[0],p_curve[i]->poles[1],
		p_curve[i]->poles[2]);     
      	printf("pole1: %lf, %lf, %lf\n", p_curve[i]->poles[(p_curve[i]->num_poles-1)*3],
		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+1],
		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+2]);
#     	endif
      	if(p_curve[i]->rational){
            for(k=0;k<p_curve[i]->num_poles;k=k+1)
	     {
		p_curve[i]->poles[3*k]   = p_curve[i]->poles[3*k]/
						p_curve[i]->weights[k];
		p_curve[i]->poles[3*k+1] = p_curve[i]->poles[3*k+1]/
						p_curve[i]->weights[k];
		p_curve[i]->poles[3*k+2] = p_curve[i]->poles[3*k+2]/
						p_curve[i]->weights[k];
	     }
	    p_curve[i]->rational = 0;
	    if(p_curve[i]->weights)
	      {
		free(p_curve[i]->weights);
		p_curve[i]->weights  = NULL;
	      }
        }

      	if(fabs(intpts1[0]+1.) > EPSILON && fabs(intpts1[1]+1.) > EPSILON && 
					fabs(intpts1[2]+1.) > EPSILON ){
        	if(fabs(p_curve[i]->poles[0]-intpts1[0]) > EPSILON )
	 		p_curve[i]->poles[0]= intpts1[0];
      		if(fabs(p_curve[i]->poles[1] - intpts1[1]) > EPSILON)
			p_curve[i]->poles[1]= intpts1[1];
      		if(fabs(p_curve[i]->poles[2] - intpts1[2]) > EPSILON)
	 		p_curve[i]->poles[2]= intpts1[2];
       	}
      	if(fabs(intpts2[0]+1.) > EPSILON && fabs(intpts2[1]+1.) > EPSILON && 
					fabs(intpts2[2]+1.) > EPSILON ){
        	if(fabs(p_curve[i]->poles[(p_curve[i]->num_poles-1)*3]-intpts2[0]) > EPSILON )
	 		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3]= intpts2[0];
      		if(fabs(p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+1] - intpts2[1]) > EPSILON)
			p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+1]= intpts2[1];
      		if(fabs(p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+2] - intpts2[2]) > EPSILON)
	 		p_curve[i]->poles[(p_curve[i]->num_poles-1)*3+2]= intpts2[2];
       	}
#     	ifdef DBG_PARTOF
      	printf("\n");
      	printf("partofcv result %d\n",i);
            if(p_curve[i]->rational){
              	for(k=0;k< p_curve[i]->num_poles && k<5 ;k=k+1)
               		printf("weight: %lf\n", p_curve[i]->weights[k]);
            }
      	for(k=0;k<p_curve[i]->num_poles ;k=k+1)
      	printf("partof the curves: %lf, %lf, %lf\n", p_curve[i]->poles[3*k], p_curve[i]->poles[3*k+1], p_curve[i]->poles[3*k+2]);
#     	endif
}/* end boucle i */


for(k=0; k<num_merge; k=k+1)
    {
     if(p_par1[k]  != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
     if(p_par2[k]  != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
     if(int_pts[k] != NULL) {free(int_pts[k]); int_pts[k] = NULL;}
     if(!close_cv)
     	if(plcurve[k] != NULL) {BSfreecv(&rc, plcurve[k]); plcurve[k] = NULL;}
}

UI_status("Construct the curves");



for(i=0;i<num_merge;i=i+1)
{
#  ifdef DEBUG
   printf("construct the curve: %d\n",i);
#  endif

  init_cnst_list();
  get_symb();

  dis.color             = cnst_list.color;
  dis.weight            = cnst_list.weight;
  dis.style             = cnst_list.style;

  cst.msg               = &msg;
  cst.env_info          = &act_env;
  cst.newflag           = FALSE;
  cst.level             = cnst_list.level;
  cst.properties        = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display           = &dis;
  cst.geometry          = NULL;
  cst.class_attr        = NULL;
  cst.name        	  = NULL;

  GRid_cv[i].osnum = act_env.md_id.osnum;
  GRid_cv[i].objid = NULL_OBJID;

  if(close_cv == 1)  	cst.geometry	= (char *) plcurve[i_onecv];
  else 			cst.geometry	= (char *) p_curve[i];

  stat = ci$send(msg = message GRbcsubbc.GRconstruct( &cst),
		verbose = VERBOSE,
		construct = 1,
        	    targetid  = GRid_cv[i].objid,
 	            targetos  = GRid_cv[i].osnum );
#  ifdef DEBUG
   printf("GRconstruct stat = %ld, GRid_cv = %d, %d\n",stat, GRid_cv[i].objid,
                                              GRid_cv[i].osnum);
#  endif
  
  as$status(sts=stat); 
  if (!(stat&1)){
    printf("EMSsubbs.GRconstruct failed\n");
    GRid_cv[i].objid = NULL_OBJID;
    err_flag = TRUE;
    goto wrapup;
  }
  entries[i].located_obj = GRid_cv[i];
  entries[i].module_info = act_env;
  
}/* for(i=0 to num_merge */


for(i=0;i<num_merge;i=i+1)
{
  if(p_curve[i]!=NULL) 
              {
                BSfreecv(&rc, p_curve[i]); 
                p_curve[i]= NULL;
	        if (rc !=BSSUCC && rc!=BSNULL) 
                 {
			printf("BSfreecv(curve) fail rc: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		 }
              }
}


if(close_cv == 1)
  comp_id = GRid_cv[0];
else
{
#ifdef DBG_COMPCV
 printf("construct the composite curve\n");
#endif
UI_status("Construct the composite curve");

 comp_id.osnum = act_env.md_id.osnum;
 comp_id.objid = NULL_OBJID;

 rotten_one = 0;
 stat = ci$send(msg = message GRcompcurve.EMmakecomp( &msg,&act_env, num_merge,
 							entries, &rotten_one),
		verbose = VERBOSE,
		construct = 1,
        	    targetid  = comp_id.objid,
 	            targetos  = comp_id.osnum );

  as$status(sts = stat);
  if (!(msg&stat&1)) 
   {
    printf("ERROR in GRcompcurve.EMmakecomp msg: %x\n",msg);
    if(msg == GRILLDEFINITION) UI_status("GRILLDEFINITION GRcompcurve.EMmakecomp");
    if(msg == MSFAIL) UI_status("MSFAIL GRcompcurve.EMmakecomp");
    err_flag = TRUE;
    goto wrapup;
   }
#ifdef DBG_COMPCV
 printf("GRconstruct stat = %ld, comp_id = %d, %d\n",stat, comp_id.objid,
                                              comp_id.osnum);
#endif
 }/* else de close_cv == 1*/


if(elem_type[0] == PLAN){
	
#	ifdef DEBUG
	printf("special treatment for plane support \n");
#	endif

	UI_status("Construct Plane on the composite curve");


    	init_cnst_list();
    	get_symb();

    	dis.color             = cnst_list.color;
    	dis.weight            = cnst_list.weight;
    	dis.style             = cnst_list.style;

    	cst.msg               = &msg;
    	cst.env_info          = &MOD_ENV;
    	cst.newflag           = FALSE;
    	cst.level             = cnst_list.level;
    	cst.properties        = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
    	cst.display           = &dis;
    	cst.geometry          = NULL;
    	cst.class_attr        = NULL;
    	cst.name        	  = NULL;
    	cst.geometry		= NULL;

    	test_degeneracy   = TRUE;
    	construct_loopset = TRUE;		
    	final_curve.located_obj = comp_id;
    	final_curve.module_info = act_env;
    	stat = ci$send( msg       = message EMSplane.EMplane_of_curve(&msg, 
    						&cst, &final_curve, NULL, NULL,
    						test_degeneracy,
    						construct_loopset, NULL, NULL),
		    verbose = VERBOSE,
        	    targetid  = GRid_list.objid,
 	            targetos  = GRid_list.osnum,
                    construct = 1 );

  	as$status(sts=stat); 
    	if (!(msg&stat&1)){     
    		printf("ERROR in EMSplane.EMplane_of_curve msg: %x\n",msg); 
    		if(msg == EMS_I_Degenerate) 
    			UI_status("EMS_I_Degenerate in EMplane_of_curve");
    		if(msg == EMS_E_InvalidArg) 
    			UI_status("EMS_E_InvalidArg in EMplane_of_curve");
    		else if(!(msg&1)) 
    			UI_status("Bad msg returned in EMplane_of_curve");
		err_flag = TRUE;
		goto wrapup; 
	} 
	stat = ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = comp_id.objid ,
		targetos = comp_id.osnum);
	comp_id.objid = NULL_OBJID;
  	as$status(sts=stat); 
	if (!(stat&1)){ 
    		printf("ERROR in GRgraphics.GRdelete \n"); 
		err_flag = TRUE;
		goto wrapup; 
		  
	}
    	goto wrapup;
}

stat = ci$send( msg = message GRvg.GRcenter( 
						 &msg, 
						 &act_env.md_env.matrix_type,
						 act_env.md_env.matrix,
           					 baryctr),
           	targetid = comp_id.objid,
	   	targetos = comp_id.osnum  );

as$status(sts=stat); 
if( !(msg&stat&1) ){
    	printf(" GRvg.GRcenter fail  \n");
	err_flag = TRUE;
    	goto wrapup;
}

#ifdef DBG_IN
 printf("baryctr: %lf, %lf, %lf\n",baryctr[0],baryctr[1],baryctr[2]);
#endif

#ifdef DBG_COMPCV
 printf("get geom of composite \n");
#endif

stat = ci$send(msg = message GRvg.GRgetsize(	&msg, 
						&act_env.md_env.matrix_type, 
						act_env.md_env.matrix, 
						&size ),
	  	   targetid = comp_id.objid,
	  	   targetos = comp_id.osnum );
as$status(sts=stat); 
if (!(stat&1)){     		
	printf("ERROR in GRvg.GRgetsize  \n"); 
	err_flag = TRUE;
	goto wrapup; 
} 

comp_cv = NULL;
comp_cv = (struct IGRbsp_curve *) malloc(size);
if(comp_cv == NULL){
      UI_status("ERROR Bad dynamic allocation ");
      err_flag = TRUE;
      goto wrapup;
}
stat = ci$send(msg = message GRvg.GRgetgeom(	&msg, 
						&act_env.md_env.matrix_type, 
                                  		act_env.md_env.matrix, 
                                  		(char *) comp_cv),
	  	 targetid = comp_id.objid,
	  	 targetos = comp_id.osnum );
as$status(sts=stat); 
if (!(stat&1)){ 
	printf("ERROR in GRvg.GRgetgeom \n"); 
	err_flag = TRUE;
	goto wrapup;
}
#ifdef DBG_COMPCV
 printf("comp_cv nb_poles: %d\n",comp_cv->num_poles);
 printf("closed: %d\n",comp_cv->phy_closed);
 for(i=0;i<comp_cv->num_poles ;i=i+1)
 	printf("poles: %lf, %lf, %lf\n",comp_cv->poles[3*i],comp_cv->poles[3*i+1],
 	comp_cv->poles[3*i+2]);
#endif


world = TRUE;
stat = ci$send( msg = message GRgraphics.GRgetrang(&msg, 
						&act_env.md_env.matrix_type, 
						act_env.md_env.matrix, 
						&world, obj_range),
              targetid = comp_id.objid,
 	      targetos = comp_id.osnum );

as$status(sts=stat); 
if (!(msg&stat&1)){ 
	printf("ERROR in GRgraphics.GRgetrang  \n"); 
	err_flag = TRUE;
	goto wrapup; 
} 

#ifdef DBG_IN
   printf("range comp_id: %lf, %lf, %lf, %lf, %lf, %lf\n",obj_range[0],
           obj_range[1],obj_range[2],obj_range[3],obj_range[4],obj_range[5]);
#endif


fact = BSdistptpt(&rc, obj_range, &(obj_range[3]));
if(rc != BSSUCC) {printf("ERROR BSdistptpt,\n");err_flag = TRUE;goto wrapup;}


coef = fact / 100;

#ifdef DBG_IN
 printf("coef: %lf\n",coef);
#endif

inside = FALSE;
n_int = 1;
nb_time = 0;

while(inside == FALSE && n_int != 0 && nb_time < 50){
	
 	BSmdstptcv(comp_cv,baryctr, &param, base, &dist2, &rc);
 	if(rc != BSSUCC ){
		printf(" ERROR in  BSmdstptcv\n");
		err_flag = TRUE;
		goto wrapup;
 	}

#	ifdef DBG_IN
 	printf("mdst bary: %lf, %lf, %lf\n",base[0],base[1],base[2]);
 	printf("dist bary: %lf, param: %lf\n",dist2,param);
#	endif
	
 	/* vect is bary to comp_cv */

 	BSmkvec(&rc,vect,baryctr,base);
 	if(rc != BSSUCC ){
		printf(" ERROR in BSmkvec\n");
		err_flag = TRUE;
		goto wrapup;
 	}
 	BSnorvec(&rc,vect);
 	if(rc != BSSUCC ){
		printf(" ERROR in BSnorvec\n");
		err_flag = TRUE;
		goto wrapup;
 	}
 
#	ifdef DBG_IN
 	printf("vect bary to cv: %lf, %lf, %lf\n",vect[0], vect[1],vect[2]);
#	endif

	for(i=0;i<3;i=i+1)
		dir_point[i] = baryctr[i] + 1.5*(fact+dist2)*vect[i];
		
	/* find vector ortho to vect */
	
 	BScrossp(&rc, vect, const_pl.normal,dirvect);
 	if(rc != BSSUCC ){
		printf(" ERROR in BScrossp\n");
		err_flag = TRUE;
		goto wrapup;
 	}
#	ifdef DBG_IN
  	printf("dirvect to translate bary: %lf, %lf, %lf\n",dirvect[0], dirvect[1],dirvect[2]);
#	endif

	for(i=0;i<3;i=i+1) baryctr[i] = baryctr[i] + coef * dirvect[i];
#	ifdef DBG_IN
 	printf("baryctr: %lf, %lf, %lf\n",baryctr[0],baryctr[1],baryctr[2]);
#	endif

    /* -------------------------------------------------------------------- 

	Take dir_point out of range of comp_cv (on plane) and create an 
	infinite segment from dir_point to the curve (min dist to not have 
	tangency) and intersect it with comp_cv; if nb_int > 2 the middle 
	point between intpt1 and intpt2 is inside comp_cv. 
	if nb_int < 2 chg dir_point to have more than 1 intersection.

      -------------------------------------------------------------------- */

#	ifdef DBG_IN
 	printf("create line fr dir_point to min dist point on curve \n");
 	printf("dir_point: %lf, %lf, %lf\n",dir_point[0],dir_point[1],dir_point[2]);
#	endif


	BSmdstptcv(comp_cv,dir_point, &param, base, &dist1, &rc);
	if(rc != BSSUCC ){
		printf(" ERROR in  BSmdstptcv\n");
		err_flag = TRUE;
		goto wrapup;
	}

#	ifdef DBG_IN
 	printf("mdstpt: %lf, %lf, %lf\n",base[0],base[1],base[2]);
 	printf("dist: %lf, param: %lf\n",dist1,param);
#	endif
	
	/* out_vect is dir_point to base */

	BSmkvec(&rc,out_vect,dir_point,base);
	if(rc != BSSUCC ){
		printf(" ERROR in BSmkvec\n");
		err_flag = TRUE;
		goto wrapup;
	}
	BSnorvec(&rc,out_vect);
	if(rc != BSSUCC ){
		printf(" ERROR in BSnorvec\n");
		err_flag = TRUE;
		goto wrapup;
	}

#	ifdef DBG_IN
 	printf("out_vect: %lf, %lf, %lf\n",out_vect[0],out_vect[1],out_vect[2]);
	printf("fact: %lf\n",fact );
#	endif
	
	for(i=0;i<3;i=i+1)
		pt1[i] = dir_point[i] + 2*(fact+dist1)*out_vect[i];

#	ifdef DBG_IN
 	printf("dir_point: %lf, %lf, %lf\n",dir_point[0],dir_point[1],dir_point[2]);
 	printf("pt1t: %lf, %lf, %lf\n",pt1[0],pt1[1],pt1[2]);
#	endif

	line = NULL;
	BSalloccv(	2, 
			2, 
			0, 
			0,
 			&line, 
			&rc);
	if(rc != BSSUCC && rc!=BSNULL){ 
		UI_status("ERROR Bad dynamic allocation ");
		err_flag = TRUE;
		goto wrapup;
	}
	BSptlngen(&rc, dir_point, pt1,line, &type);
	if(rc != BSSUCC ) { 
		printf("ERROR surf_int,  BSptlngen\n");
		err_flag = TRUE;
		goto wrapup;
	}
	p_par1[0]  = NULL;
	p_par2[0]  = NULL;
	int_pts[0] = NULL;
	over0        = NULL;
	over1        = NULL;
	end_pts      = NULL;
	n_int  	     = 0;

     	
	BScvcv_int(&rc, line, comp_cv, &n_int, &int_pts[0], &p_par1[0], 
		&p_par2[0], &n_over, &end_pts,  &over0, &over1);

	if(rc != BSSUCC ){ 
		printf("ERROR surf_int, BScvcv_int\n");
		err_flag = TRUE;
		goto wrapup;
	}

             
#	ifdef DBG_IN
 	printf("n_int: %d\n",n_int);
 	for(i=0;i<n_int;i=i+1) {
        	printf("int_pts: %lf, %lf, %lf\n",int_pts[0][3*i],
        			int_pts[0][3*i+1],int_pts[0][3*i+2]);
        	printf("par: %lf\n",p_par2[0][i]);
 	}
#	endif

	/* look if the first intersection point has the same right 
		and left derivative */

	num_deriv = 1;
	eval_bound = TRUE;

	BScveval_b(&rc, comp_cv,&p_par2[0][0],&num_deriv,&eval_bound,&bound,
			left,right);
	if(rc != BSSUCC){
		printf("ERROR BScveval_b rc : %d\n",rc);
		err_flag = TRUE;
		goto wrapup;
	}

#	ifdef DBG_IN
	printf("bound: %d\n",bound);
#	endif

	if(n_int > 1 && bound == FALSE){

#		ifdef DBG_IN
 		printf("take middle point between intpts\n");
#		endif
		for(i=0;i<3;i=i+1)
			dir_point[i] = (int_pts[0][i] + int_pts[0][i+3])/2;
#		ifdef DBG_IN
 		printf("new dir_point: %lf, %lf, %lf\n\n",dir_point[0],dir_point[1],dir_point[2]);
#		endif
		inside = TRUE;
	}
	if(line      != NULL) {BSfreecv(&rc, line) ;line       = NULL;}
	if(p_par1[0] != NULL) {free(p_par1[0]) ; p_par1[0]  = NULL;}
	if(p_par2[0] != NULL) {free(p_par2[0]) ; p_par2[0]  = NULL;}
	if(int_pts[0]!= NULL) {free(int_pts[0]); int_pts[0] = NULL;}
	if(over0     != NULL) {free(over0)     ; over0      = NULL;}
	if(over1     != NULL) {free(over1)     ; over1      = NULL;}
	if(end_pts   != NULL) {free(end_pts)   ; end_pts    = NULL;}
	nb_time = nb_time +1;
}/* end while */


#ifdef DBG_IN
 printf("point inside comp_cv: %lf, %lf, %lf\n",dir_point[0],dir_point[1],dir_point[2]);
#endif

if(inside == FALSE) {
	UI_status("Fail to find a point inside, result can be a hole ");
}


#ifdef DBG_PROJ
 printf("create surf of projection \n" );
#endif


    init_cnst_list();
    get_symb();

 dis.color             = cnst_list.color;
 dis.weight            = cnst_list.weight;
 dis.style             = cnst_list.style;

 cst.msg               = &msg;
 cst.env_info          = &act_env;
 cst.newflag           = FALSE;
 cst.level             = cnst_list.level;
 cst.properties        = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
 cst.display           = &dis;
 cst.geometry          = NULL;
 cst.class_attr        = NULL;
 cst.name        	  = NULL;
 cst.geometry  		= NULL;

 PROJCV.objid 	= NULL_OBJID;
 PROJCV.osnum 	= act_env.md_id.osnum;
 
 point1[0] = const_pl.point[0] ;
 point1[1] = const_pl.point[1] ;
 point1[2] = const_pl.point[2] ;

 point2[0] = const_pl.point[0] + 10*fact *const_pl.normal[0];
 point2[1] = const_pl.point[1] + 10*fact *const_pl.normal[1];
 point2[2] = const_pl.point[2] + 10*fact *const_pl.normal[2];
  
    /* -------------------------------------------------------------------- 
	
	the surface of projection must be constructed in the direction and
	sense of the normal of the support to have consistent boolean
	difference. If we want to construct the bounded surface, the normal
	of the surface of projection must be oriented to ouside 
	(inside for hole).
	The problem is that the pos_orient_flag in the 
	EMplace_surface_of_projection is only used if curve is not composite
	(The normal of the surface_of_projection is to outside if pos = TRUE). 
	
      -------------------------------------------------------------------- */



 /* find the orientation of the surface of projection */
 
 BSmkvec(&rc,proj_vect,point1,point2);
 if(rc != BSSUCC ){
	printf(" ERROR in BSmkvec\n");
	err_flag = TRUE;
	goto wrapup;
 }

#ifdef DBG_PROJ
 printf("proj_vect: %lf, %lf, %lf\n",proj_vect[0],proj_vect[1],proj_vect[2]);
#endif

 /* take point to the min dist of dir_point on comp_cv */

 BSmdstptcv(comp_cv,dir_point, &param, base, &dist1, &rc);
 if(rc != BSSUCC ){
	printf(" ERROR in  BSmdstptcv\n");
	err_flag = TRUE;
	goto wrapup;
 }
#ifdef DBG_PROJ
 printf("mdstpt: %lf, %lf, %lf\n",base[0],base[1],base[2]);
 printf("dist: %lf, param: %lf\n",dist1,param);
#endif
 
 BSmkvec(&rc,vect,base, dir_point);
 if(rc != BSSUCC ){
	printf(" ERROR in BSmkvec\n");
	err_flag = TRUE;
	goto wrapup;
 }

#ifdef DBG_PROJ
 printf("vect: %lf, %lf, %lf\n",vect[0],vect[1],vect[2]);
#endif

 /* find the tangent to base point */

 dis_fact = 1.; /* scale factor for tangent */
 BScvarrevt(comp_cv, &param, 1, dis_fact, tangent, &rc);
 if(rc != BSSUCC ){
	printf(" ERROR in  BScvarrevt\n");
	err_flag = TRUE;
	goto wrapup;
 }

#ifdef DBG_PROJ
 printf("tangent0: %lf, %lf, %lf\n", tangent[0],tangent[1],tangent[2]);
 printf("tangent1: %lf, %lf, %lf\n", tangent[3],tangent[4],tangent[5]);
#endif

 for(i=0;i<3;i=i+1){
 	pt1[i] = tangent[i];
 	pt2[i] = tangent[i+3];
 }


 BSmkvec(&rc,tgvect,pt1, pt2);
 if(rc != BSSUCC ){
	printf(" ERROR in BSmkvec\n");
	err_flag = TRUE;
	goto wrapup;
 }

#ifdef DBG_PROJ
 printf("tgvect: %lf, %lf, %lf\n",tgvect[0],tgvect[1],tgvect[2]);
#endif

 /* find the cross product of vect and the tg to cv at base */

 BScrossp(&rc, vect, tgvect, out_vect);
 if(rc != BSSUCC ){
	printf(" ERROR in BScrossp\n");
	err_flag = TRUE;
	goto wrapup;
 }
 
#ifdef DBG_PROJ
printf("out_vect: %lf, %lf, %lf\n",out_vect[0],out_vect[1],out_vect[2]);
#endif

/* find the dot product of out_vect and proj_vect */

dotp = BSdotp(&rc, out_vect, proj_vect);
 if(rc != BSSUCC ){
	printf(" ERROR in  BSdotp\n");
	err_flag = TRUE;
	goto wrapup;
 }

#ifdef DBG_PROJ
 printf("dotp: %lf\n",dotp);
#endif



if(dotp > 0.) {
#	ifdef DBG_PROJ
	printf("reverse the curve to have dotpt < 0 (for compcv)\n");
#	endif

	stat = ci$send(	msg = message GRcurve.GRrevparm(&msg, &act_env),
		targetid = comp_id.objid ,
		targetos = comp_id.osnum);
	as$status(sts=stat); 
	if (!(stat&1)){ 
		printf("ERROR in GRcurve.GRrevparm  \n"); 
		err_flag = TRUE;
		goto wrapup; 
		  
	}
        
}


pos_orient_flag = TRUE;

UI_status("Construct the surface of projection");

 
#ifdef DBG_PROJ
 printf("compid: %d, %d\n",comp_id.objid, comp_id.osnum);
 printf("pos_orient_flag: %d\n",pos_orient_flag);
 printf("point1: %lf, %lf, %lf\n",point1[0],point1[1],point1[2]);
 printf("point2: %lf, %lf, %lf\n",point2[0],point2[1],point2[2]);
#endif

 stat = ci$send( msg = message EMSproject.EMplace_surface_of_projection( 
						 &cst, 
						 &comp_id,
						 &act_env,
						 NULL,
						 NULL,
						 point1,
           					 point2,
						 pos_orient_flag,
						 &new_objid ),
           	targetid = PROJCV.objid,
	   	targetos = PROJCV.osnum  );


#ifdef DBG_PROJ
 printf("after EMSproject.EMplace_surface_of_projection PROJCV  = %d, %d\n",PROJCV.objid,PROJCV.osnum);
 printf("new_objid: %d\n",new_objid);
#endif
 
 as$status(sts=stat); 
 if( !(stat&1) ){
	printf("ERROR in EMSproject.EMplace_surface_of_projection\n"); 
        err_flag = TRUE;
        goto wrapup;
 }
PROJCV.objid = new_objid;


#ifdef DBG_PROJ
 printf("delete comp_id: %d, %d\n",comp_id.objid ,comp_id.osnum);
#endif

stat = ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = comp_id.objid ,
		targetos = comp_id.osnum);
comp_id.objid = NULL_OBJID;
as$status(sts=stat); 
if (!(stat&1)){ 
	printf("ERROR in GRgraphics.GRdelete \n"); 
	err_flag = TRUE;
	goto wrapup; 
		  
}


/* create natural boundary if no loopset exist on surface */

	
#	ifdef DEBUG
	printf("EMSsurface.EMputLsIfNotThere \n");
#	endif

      	stat = ci$send (msg = message EMSsurface.EMputLsIfNotThere 
							      (	&msg, 
								&act_env.md_env, 
								NULL,
								NULL,
								0,
								NULL), 
                         		targetid = PROJCV.objid, 
					targetos = PROJCV.osnum);
	as$status(sts=stat); 
      	if (!(msg&stat&1)){ 
				printf("ERROR in EMSsurface.EMputLsIfNotThere\n"); 
				err_flag = TRUE;
				goto wrapup;
      	}
      	
nb_del = 0;    
stat = om$get_classid (	objid = PROJCV.objid, 
                        osnum = PROJCV.osnum,
                        p_classid = &sfid_class);
as$status(sts=stat); 
if (!(stat&1)){ 
		err_flag = TRUE;
		goto wrapup;
} 

stat = om$is_ancestry_valid (	subclassid = sfid_class,
                               	superclassid = OPP_EMSsubbs_class_id);
if (stat == OM_S_SUCCESS) {
#	ifdef DEBUG
    	printf("it is OPP_EMSsubbs_class_id\n");
#	endif

	TODEL = NULL;
	TODEL = (struct GRid *)om$malloc(size = 1 * sizeof(struct GRid));
	if(TODEL == NULL){
		UI_status("ERROR Bad dynamic allocation ");
		err_flag = TRUE;
		goto wrapup;
	}
      
	TODEL[nb_del].objid = PROJCV.objid; 
	TODEL[nb_del].osnum = PROJCV.osnum; 
      	nb_del = nb_del+1;

}/* end OPP_EMSsubbs_class_id */
else {
#	ifdef DEBUG 
      	printf("elt is owner: %d\n",PROJCV.objid);
#	endif 
  	stat = ci$send(msg = message GRowner.GRget_number_components(
								&msg,
                             				     	&nb_del),
                       targetid = PROJCV.objid,
                       targetos = PROJCV.osnum);
	as$status(sts=stat); 
	if (!(msg&stat&1)){ 
			printf("ERROR in GRowner.GRget_number_components \n"); 
			err_flag = TRUE;
			goto wrapup;
	} 


	if(nb_del == 0 ){
		UI_status("ERROR, owner has no component");
		err_flag = TRUE;
		goto wrapup;
		
	}

#	ifdef DEBUG
	printf("get_number_components : %d\n",nb_del);
#	endif


	TODEL = NULL;
	TODEL = (struct GRid *)om$malloc(size = (nb_del) * sizeof(struct GRid));
	if(TODEL == NULL){
		UI_status("ERROR Bad dynamic allocation ");
		err_flag = TRUE;
		goto wrapup;
	}
	count = 0;
	stat = ci$send(msg = message GRowner.GRget_components(
								&msg,
								&act_env,
								TODEL,
                             				     	nb_del,
								&count,
								0,
								OM_K_MAXINT),
                       targetid = PROJCV.objid,
                       targetos = PROJCV.osnum);
	as$status(sts=stat); 
	if (!(msg&stat&1)){ 
			printf("ERROR in GRowner.GRget_components \n"); 
			err_flag = TRUE;
			goto wrapup; 
	}

}


#ifdef DEBUG
 for(i=0;i<nb_del;i=i+1)
	printf("TODEL to del: %d, %d\n",TODEL[i].objid, TODEL[i].osnum);
#endif



SOLOBJ = PROJCV.objid;

# ifdef DBG_BOOL
  printf("SOLOBJ: %d\n", SOLOBJ);
# endif

UI_status("Boolean Difference");

/**********************    boolean operation    *****************************/

init_cnst_list();
get_symb();

dis.color     	= cnst_list.color;
dis.weight	= cnst_list.weight;
dis.style 	= cnst_list.style;

cst.msg         = &msg;
cst.env_info   	= &MOD_ENV;
cst.newflag   	= FALSE;
cst.level     	= cnst_list.level;
cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
cst.display     = &dis;
cst.geometry    = NULL;
cst.class_attr  = NULL;
cst.name        = NULL;

TMP.objid = NULL_OBJID;
TMP.osnum = MOD_ENV.md_id.osnum;


option = /*EMSsfbool_opt_display | */EMSsfbool_opt_retryDisjoint |
  	 EMSsfbool_opt_HandleStop ;

#ifdef DBG_BOOL
 printf("option: %x\n",option);
 printf("SUR: %d, SOLOBJ: %d\n",SUR[0].objid, SOLOBJ);
 printf("const_ocj: %d, %d\n",TMP.objid,TMP.osnum  );
#endif

 stat = ci$send( msg = message EMSsfboolean.EMboolean( 
						 &msg, 
						 &MOD_ENV.md_env.matrix_type,
						 MOD_ENV.md_env.matrix,
           					 SUR[0].objid,
						 1,
						 &SOLOBJ,
           					 &cst,
						 EMSbool_difference,
						 option,
						 status_str,
						 NULL,
						 NULL,
						 NULL,
						 NULL ),
           	targetid = TMP.objid,
	   	targetos = TMP.osnum  );


#ifdef DBG_BOOL
 printf("after  EMSsfboolean.EMboolean TMP = %d, %d\n",TMP.objid,TMP.osnum);
#endif

 as$status(sts=stat); 
 if( !(msg&stat&1) ){
	printf("ERROR in EMSsfboolean.EMboolean  \n"); 
     	err_flag = TRUE;
        goto wrapup;
 }


#ifdef DBG_BOOL
 printf("add the compress tree \n");
#endif

 stat = ci$send(msg = message EMSdpr.EMmake_primitive1(
				&msg,
				&MOD_ENV,
				&TMP1 ),
	        targetid = TMP.objid,
		targetos = TMP.osnum);

 as$status(sts=stat); 
 if(  !(stat&msg&1) ) {

		stat = ci$send( msg = message Root.GRdelete(0),
	        		targetid = TMP.objid,
				targetos = TMP.osnum);
		as$status( sts = stat );
		TMP.objid = NULL_OBJID;
		err_flag = TRUE;
		goto wrapup;
 }
	
#ifdef DBG_BOOL
 printf("after EMSdpr.EMmake_primitive1: %d, %d\n",TMP1.objid,TMP1.osnum);
#endif

 stat = om$get_classid (	objid = TMP1.objid, 
                         	osnum = TMP1.osnum,
                         	p_classid = &sfid_class);
 as$status(sts=stat); 
 if (!(stat&1)){ 
		err_flag = TRUE; 
		goto wrapup; 
 } 
 
 
 stat = om$is_ancestry_valid (subclassid = sfid_class,
                               superclassid = OPP_EMSsubbs_class_id);

 if (stat == OM_S_SUCCESS){
#	ifdef DBG_BOOL
    	printf("new obj is OPP_EMSsubbs_class_id\n");
#	endif

	/*The remains of compressed tree is a single surface.*/
 	water_mark	= 0;

	stat = ci$send(msg = message EMSsubbs.EMreduce_range(&msg,
                             				     &MOD_ENV,
                             				     &TMP1.objid, 
							     water_mark),
                       targetid = TMP1.objid,
                       targetos = TMP1.osnum);
 	as$status(sts=stat); 
	if (!(msg&stat&1)){ 
		printf("ERROR in EMSsubbs.EMreduce_range  \n"); 
		err_flag = TRUE;
		goto wrapup; 
	} 
    	GRid_list.objid = TMP1.objid;    
    	GRid_list.osnum = TMP1.osnum;  

 }/* end OPP_EMSsubbs_class_id */
 else  {
#	ifdef DBG_BOOL
    	printf("new obj : %d, %d is not a OPP_EMSsubbs_class_id\n",
							TMP1.objid,
							TMP1.osnum);

#	endif

	/*The remains of compressed tree is a composite surface or solid.*/
	stat = ci$send(msg = message GRowner.GRget_number_components(
								&msg,
                             				     	&ssize),
                       targetid = TMP1.objid,
                       targetos = TMP1.osnum);
 	as$status(sts=stat); 
	if (!(msg&stat&1)){ 
		printf("ERROR in  GRowner.GRget_number_components \n"); 
		err_flag = TRUE;
		goto wrapup; 
	} 

	if(ssize == 0 ){
		UI_status("ERROR, owner has no component");
		err_flag = TRUE;
		goto wrapup;
	}

#	ifdef DBG_BOOL
	printf("get_number_components : %d\n",ssize);
#	endif

	return_id = NULL;
	return_id = (GRobjid *)om$malloc(size = (ssize) * sizeof(GRobjid));
	if(return_id == NULL){
		UI_status("ERROR Bad dynamic allocation ");
		err_flag = TRUE;
		goto wrapup;
	}

	list = NULL;
	list = (struct GRid *)om$malloc(size = (ssize) * sizeof(struct GRid));
	if(list == NULL){
		UI_status("ERROR Bad dynamic allocation ");
		err_flag = TRUE;
		goto wrapup;
	}
	count = 0;
	stat = ci$send(msg = message GRowner.GRget_components(
								&msg,
								&MOD_ENV,
								list,
                             				     	ssize,
								&count,
								0,
								OM_K_MAXINT),
                       targetid = TMP1.objid,
                       targetos = TMP1.osnum);
 	as$status(sts=stat); 
	if (!(msg&stat&1)){ 
		printf("ERROR in  GRowner.GRget_components \n"); 
		err_flag = TRUE;
		goto wrapup; 
	}

#	ifdef DBG_BOOL
        printf("GRdrop owner TMP1\n");
#	endif
	
        stat = ci$send(msg = message GRowner.GRdrop(&msg, &MOD_ENV),
        	   	targetid = TMP1.objid,
		   	targetos = TMP1.osnum);
 	as$status(sts=stat); 
  	if (!(msg&stat&1)){ 
			printf("ERROR in  GRowner.GRdrop  \n"); 
			err_flag = TRUE;
			goto wrapup;
  	}
	nb_cmp = 0;
	for (i=0;i<ssize;i=i+1){
#		ifdef DBG_BOOL
		printf("get classid de list : %d, %d\n",list[i].objid, list[i].osnum);
#		endif

  		stat = om$get_classid (objid = list[i].objid, 
                         osnum = list[i].osnum,
                         p_classid = &sfid_class);
 		as$status(sts=stat); 
  		if (!(stat&1)){ 
			err_flag = TRUE;
			goto wrapup; 
  		} 
		found = 0;
		for(k=0; k< nb_del;k=k+1){ 
#		  ifdef DBG_BOOL
		  printf(" is list %d equal to TODEL[%d]: %d ?\n",list[i].objid,k,TODEL[k].objid);
#		  endif
		  if(list[i].objid == TODEL[k].objid) {
#			ifdef DBG_BOOL
        		printf("delete %d, %d\n",list[i].objid ,list[i].osnum);
#			endif

        		stat = ci$send(msg = message GRgraphics.GRdelete
							(&msg, &MOD_ENV),
				targetid = list[i].objid ,
		   		targetos = list[i].osnum);
 			as$status(sts=stat); 
  			if (!(stat&1)){ 
				printf("ERROR in GRgraphics.GRdelete \n"); 
				err_flag = TRUE;
				goto wrapup;
  			}
			list[i].objid = NULL_OBJID;
			found = 1;
			break;		
		  }
		}
		if(found) continue;
  		stat = om$is_ancestry_valid (subclassid = sfid_class,
                               superclassid = OPP_EMSsubbs_class_id);

  		if (stat == OM_S_SUCCESS)
  		{

#		  ifdef DBG_BOOL
		  printf("EMSsubbs.EMreduce_range %d, %d\n",list[i].objid,list[i].osnum);
#		  endif

         	  stat = ci$send(msg = message EMSsubbs.EMreduce_range(&msg,
                             &MOD_ENV,&return_id[nb_cmp], water_mark),
                       targetos = list[i].osnum,  
                       targetid = list[i].objid);
 		  as$status(sts=stat); 
  	 	  if (!(msg&stat&1)){ 
			printf("ERROR in EMSsubbs.EMreduce_range \n"); 
			err_flag = TRUE;
			goto wrapup; 
  	 	  }
#		  ifdef DBG_BOOL
		  printf("return_id[%d]: %d\n",nb_cmp,return_id[nb_cmp]);
#		  endif
  	 	  
		  nb_cmp = nb_cmp+1;
		
		}
	}

#	ifdef DBG_BOOL
	printf("nb_cmp to make comp: %d\n",nb_cmp);
#	endif
	
	if(nb_cmp == 1){
		   GRid_list.objid = return_id[0];
		   goto wrapup;
	}
	else if(nb_cmp > 1){
  		GRid_list.objid = NULL_OBJID;
  		GRid_list.osnum = MOD_ENV.md_id.osnum;

    		init_cnst_list();
    		get_symb();

    		dis.color             = cnst_list.color;
    		dis.weight            = cnst_list.weight;
    		dis.style             = cnst_list.style;

    		cst.msg               = &msg;
    		cst.env_info          = &MOD_ENV;
    		cst.newflag           = FALSE;
    		cst.level             = cnst_list.level;
    		cst.properties        = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
    		cst.display           = &dis;
    		cst.geometry          = NULL;
    		cst.class_attr        = NULL;
    		cst.name        	  = NULL;
    
  		stat = ci$send( msg = message EMSsfstitch.GRconstruct(&cst),
                         targetid = GRid_list.objid,
                         targetos = GRid_list.osnum);
 		as$status(sts=stat); 
  		if(!(stat&1)){	
			printf("ERROR in EMSsfstitch.GRconstruct\n"); 
			err_flag = TRUE;
			goto wrapup;
  		}

#		ifdef DBG_BOOL
		printf("EMSsfstitch GRconstruct: %d, %d\n",GRid_list.objid,GRid_list.osnum);
#		endif
        
      		makecs_opt = NULL;

#		ifdef DBG_BOOL
		printf("make_comp with %d elt\n",nb_cmp);
#		endif

      		stat = ci$send(msg = message EMSsfstitch.EMmake_comp(&msg,
                          		nb_cmp, return_id,
                          		&MOD_ENV,NULL, NULL, 0,
                          		NULL, makecs_opt),
                    	targetid = GRid_list.objid,
                    	targetos = GRid_list.osnum);


      		if( (msg == EMS_E_NoDynamicMemory) || 
          		(msg == EMS_E_DynamicMemoryAllocated)){
        		UI_status("ERROR EMmake_comp bad dynamic memory allocated");
			err_flag = TRUE;
			goto wrapup;
		if(return_id != NULL){free(return_id);return_id = NULL;}
       		}
      		else {
        	   if(!(stat & 1)){
			   om$report_error(sts=stat);
			   err_flag = TRUE;
			   goto wrapup;
		   }
      
        	   if (msg == EMS_I_Fail) /*Stitch failed.*/ {
          		printf("ERROR mybool:Stitch failed\n");
          		stat = EMmake_chanselect (GRcmpowner_to_components, 
						 &to_comps);
	  		if(!(stat & 1)){
				printf("EMmake_chanselect fail \n");
				err_flag = TRUE;
				goto wrapup;
			}
          		stat = om$get_channel_count( objid = GRid_list.objid,
                                   		    osnum = GRid_list.osnum,
                                   		    p_chanselect = &to_comps,
                                   		    count = &count);
	  		if(!(stat & 1)){
				printf("om$get_channel_count fail \n");
				err_flag = TRUE;
				goto wrapup;
			}
          		if (!count){
            			/*Delete composite object.*/
            			stat = ci$send(msg = message Root.delete(0),
                        			targetos = GRid_list.osnum,
                        			targetid = GRid_list.objid);
	    			if(!(stat & 1)){
					printf("ERROR in Root.delete\n"); 
					om$report_error(sts=stat);
					err_flag = TRUE;
					goto wrapup;
				}
           		}
			GRid_list.objid = NULL_OBJID;

          	   }/*Stitch failed.*/
         	   else  /*It worked.*/{ 
 	   		/* Comp surf made */

#			ifdef DBG_BOOL
			printf("stitch is : %d, %d\n",GRid_list.objid,GRid_list.osnum);
#			endif

		   }
		}
	}
        
 }


wrapup:

UI_message("");
#ifdef DEBUG
printf("GRid_list: %d, %d\n",GRid_list.objid,GRid_list.osnum );
#endif
if(err_flag == FALSE && GRid_list.objid != NULL_OBJID){
#   	ifdef DEBUG
	printf("support props: %x\n",props);
#   	endif

      	stat = ci$send( msg = message EMSsubbs.EMget_props(&msg, &c_props),
			verbose = VERBOSE,
              		targetid = GRid_list.objid,
 	      		targetos = GRid_list.osnum );
 	      
 	as$status(sts=stat); 
      	if (!(stat&1)){ 
#   		ifdef DEBUG
      		printf("ERROR EMget_props grid_list\n"); 
#   		endif
		c_props = 0x00;
      	}

#   	ifdef DEBUG
	printf("GRid_list c_props: %x\n",c_props);
#   	endif

	if(elem_type[0] == PLAN){
		
    		bndpl.point = &bnd[0];
    		bndpl.normal= &bnd[3];

    		stat = ci$send (msg = message GRvg.GRdetplane(&msg,
                        &MOD_ENV.md_env.matrix_type,
                        MOD_ENV.md_env.matrix,
                        &bndpl),
                           targetid = GRid_list.objid,
                           targetos = GRid_list.osnum );
    		as$status(sts = stat);
    		if(!(stat & msg & 1)){
        		printf("ERROR in GRvg.GRdetplane\n" );
    			err_flag = TRUE;
    			goto wrapup; 
    		}
    		dotp =    BSdotp(&rc,bndpl.normal,plane[0].normal);
    
    		if( dotp < 0  ){
    			stat = ci$send(msg = message EMSsubbs.EMset_props(&msg,
                         	(unsigned char) EMSIS_NRML_REVERSED, 
                         	(char) EMS_O_TOGGLE),
                        	targetid = GRid_list.objid,
                        	targetos = GRid_list.osnum);
    			as$status(sts = stat);
    			if(!(msg&stat&1)){
        			printf("ERROR in EMSsubbs.EMset_props\n" );
    				err_flag = TRUE;
    				goto wrapup; 
        		}
        	}
    	
    	}
  	else if( ((props & EMSIS_NRML_REVERSED)&& (!(c_props & EMSIS_NRML_REVERSED)))
  	|| (!(props & EMSIS_NRML_REVERSED)&&(c_props & EMSIS_NRML_REVERSED))){
#   		ifdef DEBUG
    		printf("The support has not the same normal than bounded\n");
#   		endif
  		stat = om$get_classid (objid = GRid_list.objid, 
                         osnum = GRid_list.osnum,
                         p_classid = &sfid_class);
  		if (!(stat&1)){ 
 			as$status(sts=stat); 
			err_flag = TRUE;
  		} 
  		stat = om$is_ancestry_valid (subclassid = sfid_class,
                               superclassid = OPP_EMSsubbs_class_id);

  		if (stat == OM_S_SUCCESS)
  		{
    			stat = ci$send(msg = message EMSsubbs.EMset_props(&msg,
                                        (unsigned char) EMSIS_NRML_REVERSED, 
                                        (char) EMS_O_TOGGLE),
                        targetid = GRid_list.objid,
                        targetos = GRid_list.osnum);
    			if(!(stat&1)){
#     				ifdef DEBUG
      				printf("Error EMSsubbs.EMset_props  \n");
#				endif
 				as$status(sts=stat); 
      			}
    		}
    		else{
#     			ifdef DEBUG
      			printf("send EMset_props to all component\n");
#     			endif
          		stat = EMmake_chanselect (GRcmpowner_to_components, 
						 &to_comps);
	  		if(stat & 1){
    				stat = ci$send(msg = message EMSsubbs.EMset_props(&msg,
                                        (unsigned char) EMSIS_NRML_REVERSED, 
                                        (char) EMS_O_TOGGLE),
                        	p_chanselect = &to_comps, targetid = GRid_list.objid);
    				if(!(stat&1)){
 					as$status(sts=stat); 
#     					ifdef DEBUG
      					printf("Error EMSsubbs.EMset_props\n");
#     					endif
      				}
      			}
		}

	}	
	
}
   if(TODEL != NULL){free(TODEL);TODEL = NULL;}
   if(list  != NULL){free(list);list = NULL;}

   if(return_id  != NULL){free(return_id) ;return_id  = NULL;}

   if(OBJECT 	!= NULL) {free(OBJECT)		  ; OBJECT    = NULL;}
   if(GRint 	!= NULL) {free(GRint)		  ; GRint     = NULL;}
   if(line      != NULL) {BSfreecv(&rc, line)     ;line       = NULL;}
   if(comp_cv   != NULL) {free(comp_cv)           ;comp_cv    = NULL;}
   if(bsp_curve != NULL) {free(bsp_curve)         ; bsp_curve = NULL;}
   for(k=0;k<num_ent-1;k=k+1)
    {
	  if(curve[k]   != NULL) {
     		if(index_cv[k] == 0) free(curve[k]); 
     		else{
               		BSfreecv(&rc, curve[k]);
	       		if (rc !=BSSUCC && rc!=BSNULL){
                			printf("BSfreecv(plcurve) fail\n");
                			err_flag = TRUE;
                		}
        	}
     		curve[k] = NULL;	
	  }
          if(plcurve[k] != NULL) {BSfreecv(&rc, plcurve[k]); plcurve[k] = NULL;}
          if(p_curve[k] !=NULL)  {BSfreecv(&rc, p_curve[k]); p_curve[k] = NULL;}
    	  if(p_par2[k]  != NULL) {free(p_par2[k])          ; p_par2[k]  = NULL;}
   	  if(int_pts[k] != NULL) {free(int_pts[k])         ; int_pts[k] = NULL;}
    	  if(p_par1[k]  != NULL) {free(p_par1[k])          ; p_par1[k]  = NULL;}

	  /* delete temporary object */

	  if(INT_CURV[k].objid != NULL_OBJID){
	  	found = 0;
	  	for(i=0;i<num_ent;i=i+1)
	  	  if(INT_CURV[k].objid == SUR[i].objid) found = 1;
	  	if(!found){
          		ci$send(msg      = message GRgraphics.GRdelete(&msg,
          							    &act_env),
          	  		targetid = INT_CURV[k].objid, 
				targetos = INT_CURV[k].osnum );
 				 
  	  		INT_CURV[k].objid = NULL_OBJID;
  	  	}
  	  }
	  		
    }

    for(k=0;k<num_ent; k=k+1){
	if(om$is_objid_valid(osnum = GRid_cv[k].osnum,
			     objid = GRid_cv[k].objid) & 1){
#     		ifdef DEBUG
		printf("delete GRid_cv[k]: %d\n",GRid_cv[k].objid);
#     		endif
		ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = GRid_cv[k].objid ,
		targetos = GRid_cv[k].osnum);
		GRid_cv[k].objid = NULL_OBJID;
	}
    }
    if(om$is_objid_valid(osnum = comp_id.osnum,objid = comp_id.objid) & 1){
#     	ifdef DEBUG
	printf("delete comp_id: %d\n",comp_id.objid);
#     	endif
	ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = comp_id.objid ,
		targetos = comp_id.osnum);
	comp_id.objid = NULL_OBJID;
    }
    if(om$is_objid_valid(osnum = PROJCV.osnum,objid = PROJCV.objid) & 1){
#     	ifdef DEBUG
	printf("delete PROJCV: %d\n",PROJCV.objid);
#     	endif
	ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = PROJCV.objid ,
		targetos = PROJCV.osnum);
	PROJCV.objid = NULL_OBJID;
    }
    if(om$is_objid_valid(osnum = TMP.osnum,objid = TMP.objid) & 1){
#     	ifdef DEBUG
	printf("delete TMP: %d\n",TMP.objid);
#     	endif
	ci$send(	msg = message GRgraphics.GRdelete(&msg, &MOD_ENV),
		targetid = TMP.objid ,
		targetos = TMP.osnum);
	TMP.objid = NULL_OBJID;
    }
    if(om$is_objid_valid(osnum = TMP1.osnum,objid = TMP1.objid) & 1){
#     	ifdef DEBUG
	printf("delete TMP1: %d\n",TMP1.objid);
#     	endif
	ci$send(	msg = message GRgraphics.GRdelete(&msg, &MOD_ENV),
		targetid = TMP1.objid ,
		targetos = TMP1.osnum);
	TMP1.objid = NULL_OBJID;
    }

        
   if(int_pts0 != NULL) {free(int_pts0)         ; int_pts0 = NULL;}
   if(int_pts1 != NULL) {free(int_pts1)         ; int_pts1 = NULL;}
   if(p_par10  != NULL) {free(p_par10)          ;  p_par10 = NULL;}
   if(p_par11  != NULL) {free(p_par11)          ;  p_par11 = NULL;}
   if(p_par20  != NULL) {free(p_par20)          ;  p_par20 = NULL;}
   if(p_par21  != NULL) {free(p_par21)          ;  p_par21 = NULL;}

   if(over0    != NULL) {free(over0)            ; over0    = NULL;}
   if(over1    != NULL) {free(over1)            ; over1    = NULL;}
   if(end_pts  != NULL) {free(end_pts)          ; end_pts  = NULL;}

   /*| restore file cht */

   nput = sizeof(file_cht);

   gr$put_chord_height_tolerance
                        (msg    = &msg,
                         sizbuf = &nput,
                         buffer = &file_cht);

   if(!(msg&1)){ 
    	printf("error gr$put_chord_height_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
   }
   if(err_flag == TRUE) {
   	UI_status("Placement of bounded surface fail");
   	if( GRid_list.objid != NULL_OBJID){
          	ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
          	       	targetid = GRid_list.objid, 
			targetos = GRid_list.osnum );
  	  	GRid_list.objid = NULL_OBJID;
   	}
        if(elem_type[0] != PLAN){
    	  if(om$is_objid_valid(osnum = SUR[0].osnum,objid = SUR[0].objid) & 1){
#     		ifdef DEBUG
		printf("delete SUR[0]: %d\n",SUR[0].objid);
#     		endif
		ci$send(	msg = message GRgraphics.GRdelete(&msg,
								  &MOD_ENV),
				targetid = SUR[0].objid ,
				targetos = SUR[0].osnum);
		SUR[0].objid = NULL_OBJID;
    	  }
        }
	return(0);
    }
    else {
   	UI_status("Placement of bounded surface success");
    	return(1);
    }

}


