/* $Id: table05May.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/obsolete/macros / table05May.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: table05May.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
/*****************************************************************************

 $Header: /export/home/cvs/isdp/vds/cimacros/obsolete/macros/table05May.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $

 $Log: table05May.u,v $
 Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 Initial import to CVS

# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#

*****************************************************************************/
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "macro.h"
#include "AS_status.h"
#include "AS_debug.h"
#undef AS_DEBUG
#include <stdio.h>
#include <limits.h>
#include <sys/types.h>  // for reading unix dir
#include <dirent.h>     // for reading unix dir

extern int DB_debug();

IGRchar			*temp_names[2], *feet_names[20];
IGRint			temp_types[2];


IGRint			i,stat, msg, suc, size, rc;
int			ft_count;
double 			ft_values[20];
IGRchar			kv[20];   // key value, was float;

GRobj 			ci_mac_def1;

struct GRid		TEMP[2],CI_MACRO_ID, FEET[20], wrk_GRid;
char 			tname[20],tmp[20];

struct GRmd_env		MOD_ENV;
struct ret_struct	temp_rts[2];

struct var
{
// double old_key;
   IGRchar	old_key[20]	;
} *me;

extern int	CIexpand()	;
extern char	*strtok()	;
extern int	print()		;
extern int	sprint()	;
extern char 	*getenv()	;	
extern IGRchar			*malloc();
extern			ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

#undef DEBUG

main ()
{

  temp_names[0]  = "index";  
  temp_names[1]  = "table_name";  

  temp_types[0]  = parameter_generic;  
  temp_types[1]  = parameter_generic;  

  

  feet_names[0] = "P0";feet_names[1] = "P1";feet_names[2] = "P2";
  feet_names[3] = "P3";feet_names[4] = "P4";feet_names[5] = "P5";
  feet_names[6] = "P6";feet_names[7] = "P7";feet_names[8] = "P8";
  feet_names[9] = "P9";feet_names[10] = "P10";feet_names[11] = "P11";
  feet_names[12] = "P12";feet_names[13] = "P13";feet_names[14] = "P14";
  feet_names[15] = "P15";feet_names[16] = "P16";feet_names[17] = "P17";
  feet_names[18] = "P18";feet_names[19] = "P19";
  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          =  ci_mac_def1,
		status 	          = &stat,
	 	name              = "table",
      		temp_num          = 2,
		temp_names        = temp_names,
		temp_types        = temp_types,
		int_size          = sizeof( struct var),
		extern_feet_num   = 20,
	 	extern_feet_names = feet_names );
/*| out main */
}

/* ========================================================================= */

place ()
{

  construct_table();

  if( FEET[0].objid == NULL_OBJID ) return(0);

  ci$send( msg	    = message  ci_macro.set_all_extern_feet
		 		( &stat, ft_count,FEET, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
/*| out place*/
  return(1);


}

/* ========================================================================= */

compute ()
{

  construct_table();

  if( FEET[0].objid == NULL_OBJID ) return(0);

  ci$send( msg	    = message  ci_macro.set_all_extern_feet
		 		( &stat, ft_count,FEET, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
/*| out compute */
  return(1);

}

/* ========================================================================= */
int isspace( c ) char c ; {

/*| out isspace*/
	return c == ' ' || c == '\t' || c == 'n' ;
}
/*----------------------------------------------------------------------------*/
double strtod( ptr, next ) char *ptr, **next ; {

	double d ;

	while( isspace( *ptr ) ) ptr = ptr + 1 ;
	d = atof( ptr ) ;
	while( !isspace( *ptr ) ) ptr = ptr + 1 ;
	*next = ptr ;
	return d ;
/*| out strtod */
} // strtod

/*----------------------------------------------------------------------------*/
int pm_out(type,  key, feet_count, feet_values )

		char	*type		;
		int	*feet_count	;
		char    *key		;
		double	*feet_values	; {

	FILE	*pmfile			;
	char	pmpath[1+PATH_MAX]	,
		pmexpn[1+PATH_MAX]	,
		line[1+BUFSIZ]		,
		tmp[100]		,
		*ptr			,
		*next			,
		*dirpath		;
//		double  kvalue;
	
	int	i, rc			;
	dirpath = getenv("TABLE_PATH");
#if DEBUG
	write("Table directory path =",dirpath,'\n');
#endif
	if (  dirpath == NULL  || !strcmp( dirpath, "." ) )
	{
	  /*| SETTING Table Path = pwd */
	  dirpath = getenv("PWD"		) ;
	  strcpy( pmpath,dirpath		) ;
	  strcat(pmpath,"/"			) ;
	  strcat( pmpath, type			) ;
	  strcat( pmpath, ".t"			) ;
	}
	else 
	 find_file( dirpath, type, pmexpn );

	if( ( pmfile = fopen( pmexpn, "r" ) ) != NULL ) {

//		Use 1st line to count feet.
		if( fgets( line, BUFSIZ, pmfile ) == NULL ) {
			rc = FALSE	;
			goto WRAPUP	;
		}
		*feet_count = 0 ; ptr = line ;
		do {
			next = strtok( ptr, " \t\n" ) ;
			ptr = NULL ;
			if( next != NULL ) {
/*"pm_out: foot = <%s>\n", next */
				*feet_count = *feet_count + 1 ;
			}
		} while( next != NULL ) ;
/*"pm_out: feet-count %d\n", *feet_count */
//	Look for requested section name.
		do {
	  		if( fgets( line, BUFSIZ, pmfile ) == NULL ) {
				rc = FALSE ; goto WRAPUP ;
	  		}

	  		sscanf( line, "%s", tmp ) ;
// rob's float logic	                kvalue = atof( tmp ) ;
//**"pm_out: kvalue <%f>, name = <%f>\n",kvalue ,key */
// now ascii	  		if( key <= kvalue ) 
	  		if( !strcmp( key , tmp ) ) {
				i = 0 ; next = line + strlen( tmp ) ;

				do {
					feet_values[i] = strtod( next, &next ) ;
					i = i + 1 ;
				} while( next != NULL && i < *feet_count ) ;

//				Default the rest to zeros.
				for( ; i < *feet_count ; i = i + 1 ) {
					feet_values[i] = 0 ;
				}
				rc = TRUE 	;
				goto WRAPUP	;
	  		}

		} while( TRUE ) ;

		WRAPUP:
		fclose( pmfile ) ;
  	}
       else
        {
        write("Table.u can not find parameter file-",pmexpn,"\n");
	write(" is environment variable $TABLE_PATH defined \n");
  	return rc ;
	}
/*| out pm_out */
} // pm_out


construct_table()
{
   for(i=0;i<20;i=i+1)
    {
    FEET[i].objid=NULL_OBJID;
    FEET[i].osnum=MOD_ENV.md_id.osnum;
    }

/*--------------------------------------------------------------------------*/
/* 		get table value	 				    */
/*--------------------------------------------------------------------------*/

  ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( 
						&stat,
						0,
						(IGRchar *)&temp_rts[0],
						&MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  if( stat != 1 ){return;}
     
// float logic  kv=temp_rts[0].var.root_pm_st.value;
  strcpy(kv,temp_rts[0].var.text_st.text_string);
//  if(kv==me->old_key) 
  if( !strcmp( kv, me->old_key ) )
     {
	/*|No change in key */
      return;}
//  me->old_key=kv;
   strcpy( me->old_key,kv );

	/*" value of index%s\n",kv*/

/*--------------------------------------------------------------------------*/
/* 		get the table name 				    */
/*--------------------------------------------------------------------------*/
  ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( &stat,
							1,
							(IGRchar *)&temp_rts[1],
						   	&MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  if( stat != 1 ){return;}

   strcpy(tname,temp_rts[1].var.text_st.text_string);
/*" name of table %s\n",tname*/

   pm_out(tname,  kv, &ft_count, ft_values );

/*" number of feet%d\n",ft_count*/



   for(i=0;i<ft_count;i=i+1)
    {
        	tmp[0] = '\0';
  		sprintf( tmp, "%g", ft_values[i] );

  		stat = ci$send(  msg      = message Gexp.create
		 				( NULL,tmp , &msg ),
                   		targetid = FEET[i].objid,
		   		targetos = FEET[i].osnum);
/*" exit Gexp.create num =%d, stat = %d\n", i, stat*/
    		as$status(sts = stat);
    }

/*| out construct table */
}


find_file( dirpath, type, pmexpn )

char * dirpath	;		// table path var
char * type	;		// table name
char * pmexpn	;		// output full unix file name
{
  char * next	;
  char * ptr	;
  int    found	;
  DIR  * dirp	;  		// pointer to unix dir
  struct dirent *        dp;    // directory entry info
  FILE * pmfile	;
  char   fullname[PATH_MAX];

  found = FALSE;
  strcpy( pmexpn , dirpath );
  next = ptr = pmexpn;
  do {
	dirp	=	opendir( next );
	if ( dirp == NULL ) {
	  if ( next != pmexpn )  ptr =NULL;  // not first
	}
	else if ( ( dp = readdir( dirp ) ) != NULL ) {
	  closedir( dp );
	  strcpy( fullname, next );  
	  strcat( fullname, "/" );
	  strcat( fullname, type );
	  strcat( fullname, ".t" );
	  if( ( pmfile = fopen( fullname, "r" ) ) != NULL ) {
	    found = TRUE;
	    strcpy( pmexpn, fullname );
	    break;
	  }
	  else /*"couldn't find file %s\n", fullname */;
	  ptr = NULL;
        }
	else  {ptr = NULL; }
     } while ( ( next = strtok( ptr, ":" ) ) != NULL );
     if ( found ) return ( OM_S_SUCCESS );
     else {
       /*| didn't find it */
       strcpy( pmexpn, type );
       strcat( pmexpn, ".t" );
     }


}	// find_file
