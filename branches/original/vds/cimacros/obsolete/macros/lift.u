/* $Id: lift.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/obsolete/macros / lift.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: lift.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
	 92/08/13	This macro is OBSOLETE (to be removed)
 */
   


#include <stdio.h>
#include "cieveryone.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "OMprimindex.h"
#include "OMprimitives.h"
#include "parametric.h"
#include "OMindex.h"
#include "OMmacros.h"
#include "EMSopt.h"
#include "emsdef.h"
#include "ci_mac_def.h"
#include "lift.h"


#include "AS_status.h"
#include "bscmpcvoff.h"
#include "bserr.h"
#include "EMSlmdef.h"
#include "EMSasnuc.h"			/* EMS 2.0 */
#include "EMSlift.h"
#include "EMSerrordef.h"
#include "asbox.h"
#include "asdef.h"
#include "asmacros.h"

#include "ci_mac_bib.h"

  extern EMget_the_geometry ();
  extern BSsfarrevn();
  extern EFprepare_single_sf_lift();
  extern UI_prompt();
  extern EFmerge_single_sf_lift_states();
  extern char *malloc();
  extern free();
  extern init_cnst_list();
//  extern ASmake_source ();
  extern ASmake_source_from_env();
  extern printf();
extern			ASsuper_construct();
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               main function                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
  long	 stat;
  int    status;              /* Returned status of the definition       */
  struct GRmd_env  MOD_ENV;        /* Environment for construction            */
  struct GRmd_env  sav_ENV,sav1_ENV;/* Environment for fucking rang       */
  struct GRid      base_surf;      /* base surface of the lift solid          */
  struct GRid      base_solid;     /* base solid of the lift solid            */
  struct GRid      tmp_expr;       /* From point of the lift                  */
  struct GRid      lift_solid;     /* Lifted solid                            */

extern int	GRfindmod();

main()
  {
  /*
  Description : Create the definition of the macro
  Constraint  : none
  */ 
  /* Declare the template names */

  template_name[0] = BASE_SURF;
  template_name[1] = ANGLE;
  template_name[2] = HAUTEUR;
  template_name[3] = CHECK_COIN;
  template_name[4] = FILLET;

  /* Declare the feet names */

  feet_names[0] = LIFT_SOLID;

  /* Construct the macro definition */

  macro_def_id = NULL_OBJID;

  ac$cimacdef
    (cimacdef          = macro_def_id,
     status            = &status,
     name              = MACRO_NAME,
     temp_num          = NB_TEMPLATE,
     temp_names        = template_name,
     extern_feet_num   = NB_FEET,
     extern_feet_names = feet_names);
}/* end main */
  
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               place function                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

init()
{
  feet_names[0] = LIFT_SOLID;	
}


place()

  /*
  Description : Place an occurence of the macro definition
  Constraint  : none
  */ 
  {
  /* Construct the lifted solid */

  feet_obj[0].objid = NULL_OBJID;
  cons_lift_solid();

  /* Connect the feet of the occurence */


  status = ci$send
    (msg      = message ci_macro.set_all_extern_feet
                        (&status,NB_FEET,feet_obj,&MOD_ENV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
  as$status();
  return(1);
}/* end place */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               compute function                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

compute()

  /*
  Description : recompute an occurence of the macro definition
  Constraint  : none
  */ 
  {
  /* Construct the lifted solid */
  sav_ENV= MOD_ENV; 
  ci$get_module_info ( md_env	= &MOD_ENV );

  feet_obj[0].objid = NULL_OBJID;
  cons_lift_solid();

  /* Change the feet of the occurence */

  status = ci$send
    (msg      = message ci_macro.set_all_extern_feet
                        (&status,NB_FEET,feet_obj,&sav_ENV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
  as$status();
  return(1);
}/* end compute */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                          cons_lift_solid function                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    struct GRid                    active_state_GRid;

    struct GRlc_info sf_info;
    IGRpoint        sf_nrml;
    int    cur_lp;
    int    last_state_processed;
    int    last_dangle_state_processed;
    char   sf_hi;
    short  single_sf_lift;
    struct EMSdlft_info    dlift_info;
    struct EMSdlft_lp_info *lps_info;
    struct EMSdlft_ed_info *eds_info;

  int    num_sfs;                  /* Number of surfaces for the solid        */
  int    msg;                      /* Returned code of messages               */
  int    msg1;                      /* Returned code of messages               */
  int    i;                        /* Index for a loop                        */
  short  mat_type;                 /* Matrix type of the graphic object       */
  IGRmatrix matrix;                /* Matrix of the graphic object            */
  struct GRid temp_object;         /* Temporary object                        */
  double value;                    /* value of an expression                  */
  struct IGRdisplay display;       /* KLUDGE FOR CI                           */

  double angle; 	          /* Angle of the lift                       */
  int fillet;
  int check_coin;
  double hauteur;


  struct
   {
   int                   *msg;
   struct GRmd_env       *mod_env;
   struct GRvg_construct *cnst_list;
   struct EMSdlft_info   *ems_info;
  }KLUDGE;                         /* KLUDGE FOR CI                           */
  OM_S_MESSAGE mess;               /* KLUDGE FOR CI                           */
 
  struct GRvg_construct     construct_list;
  struct GRid               *ed_GRids;
  struct IGRbsp_surface     *sf_geom;
  struct EMSdlft_lp_info    *lp_info;
  struct EMSdlft_ed_info    *ed_info, *last_ed_info, *next_ed_info;
  union  IGRele_attr        ele_spec_att;
  struct IGResqbs           bsqsurf;
  OM_S_CLASSLIST            rtree_classes, elig_classes;
  OM_S_CHANSELECT           sf_ls_chan;
  OM_S_OBJECT_LINKAGE       ls_list;
  GRrange                   range;
  IGRdouble                   dotp,u, v, sf_pt[3], temp_vec[3];
 
  struct GRid               object, tmp_obj;
 IGRint                    size,  j, token, 
                           buf_size, array_size, count, depth, num_lps,
                           cum_num_eds, num_lp_eds, cur_ed;

 GRobjid                   *lp_ids;

 unsigned IGRshort         active_constraints;
 IGRshort                  deactivate_option, add_option;

 IGRboolean                sf_fillet, chk_coincidence, sf_ele_header_good,
                           nghbr_ed_lvarying;
  extern  IGRdouble  fabs();
  extern  IGRdouble                 BSdotp();

 int	keyindex;
 char classname[64];

cons_lift_solid()
  {
  /*-----------------*/
  /* Get the surface */
  /*-----------------*/

  ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&status,BASE_SURF,&temp_object),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

   ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						"",
						&base_surf,
						&sav_ENV.md_env.matrix_type, 
					        sav_ENV.md_env.matrix ),
	   targetid = temp_object.objid,
	   targetos = temp_object.osnum );

  if(!stat) return;


  sav_ENV.md_id.osnum = base_surf.osnum;

  /*---------------*/
  /* Get the solid */
  /*---------------*/
  status = ci$get_channel_objects(
		osnum		= base_surf.osnum,
 		objid		= base_surf.objid,
		channname	= "GRconnector.to_owners",
		obj_list	= &tmp_obj.objid,
		osn_list	= &tmp_obj.osnum,
		count		= &count );

#ifdef DEBUG
write("ci$get_channel_objects: count = ", count, '\n' );
#endif

  if ( !status ) {
	write("pbs in ci$get_channel_objects\n");
	return 0;
  }

  if(count)
    {
    /* if tmp_obj is not a solid, go one more level */
    om$get_classname ( objid= tmp_obj.objid,
		  osnum = tmp_obj.osnum,
                  classname = classname  );

#ifdef DEBUG
write("classname for tmp_obj:",classname, '\n' );
#endif


    if( om$is_ancestry_valid( subclassname     = classname,
			       superclassname = "EMSsolid" ) != 1 ){
#ifdef DEBUG
write("NOT subclass of EMSsolid", '\n' );
#endif
	  status = ci$get_channel_objects(
		osnum		= tmp_obj.osnum,
 		objid		= tmp_obj.objid,
		channname	= "GRconnector.to_owners",
		obj_list	= &base_solid.objid,
		osn_list	= &base_solid.osnum,
		count		= &count );
	  if ( !status || count <= 0 ) {
		write("pbs in ci$get_channel_objects\n");
		return 0;
	  }
    } else {
#ifdef DEBUG
write("subclass of EMSsolid", '\n' );
#endif
	 base_solid = tmp_obj;
    }

#ifdef DEBUG
write("base_solid:", base_solid.objid,base_solid.osnum,'\n' );
#endif

    	ASmake_source_from_env( &base_solid,&sav_ENV,&temp_object);	

        as$status(  );

    status=ci$send
      (msg = message  NDmacro.ACconsume(&msg,"",1,&object,&MOD_ENV),
       targetid = temp_object.objid,
       targetos = temp_object.osnum);
     as$status(  );

// Set displayable the copies
    i = 1;    // action set using mask
    count   = 0x40; // mask display bit

    ci$send( msg = message GRvg.GRchgprops( &msg, &i, &count),
	        targetid = object.objid,
		targetos = object.osnum );

#ifdef DEBUG
write("object:", object.objid,object.osnum, '\n' );
#endif

    if( base_solid.objid != object.objid ){
	  /* the object has been copied, the surface changes !!.. */

	  /* 1: get the index of the old surface in the old solid */
	  get_index_of_surf(base_solid, &keyindex, base_surf );
	  if( keyindex == -1 ){
		write("pbs in retrieving index of the old surface in the old solid \n");
		return 0;
	  }
#ifdef DEBUG
write("base_surf:", base_surf.objid,base_surf.osnum, '\n' );
write("index:", keyindex, '\n' );
#endif

	  /* 2: retrieve the new surface in the new solid at this index */
	  get_surf_at_index(object, keyindex,  &base_surf );
	  if( base_surf.objid == NULL_OBJID ){
		write("pbs in retrieving the new surface in the new solid\n");
		return 0;
	  }

#ifdef DEBUG
write("object:", object.objid,object.osnum, '\n' );
write("base_surf:", base_surf.objid,base_surf.osnum, '\n' );
#endif

	  base_solid = object;
       }
    }
  else
    {
    ci$send
    (msg = message  NDmacro.ACconsume(&msg,"",1,&object,&MOD_ENV),
     targetid = base_surf.objid,
     targetos = base_surf.osnum);

    base_solid.objid = NULL_OBJID;
    base_solid.osnum = 0;
  }/* if (count) */

  /*-----------------------------------*/
  /* Get the values of the expressions */
  /*-----------------------------------*/

  ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&status,ANGLE,&tmp_expr),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  ci$send
    (msg      = message NDnode.NDgive_value(&angle),
     targetid = tmp_expr.objid,
     targetos = tmp_expr.osnum);

  angle  = angle / 57.29577951;		// want radians
  ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&status,HAUTEUR,&tmp_expr),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  ci$send
    (msg      = message NDnode.NDgive_value(&hauteur),
     targetid = tmp_expr.objid,
     targetos = tmp_expr.osnum);

  ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&status,CHECK_COIN,&tmp_expr),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  ci$send
    (msg      = message NDnode.NDgive_value(&value),
     targetid = tmp_expr.objid,
     targetos = tmp_expr.osnum);
  check_coin = !value;	/* the opposite ... */

  ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&status,FILLET,&tmp_expr),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  ci$send
    (msg      = message NDnode.NDgive_value(&value),
     targetid = tmp_expr.objid,
     targetos = tmp_expr.osnum);
  fillet = !value;	/* the opposite ... */

#ifdef DEBUG
write("angle = ", angle, '\n' );
write("hauteur = ", hauteur, '\n' );
write("fillet = ", fillet, '\n' );
write("check_coin = ", check_coin, '\n' );
#endif

  /*--------------------------*/
  /* Compute the lifted solid */
  /*--------------------------*/

  if( base_surf.osnum < 2 ) /* some bug */
	  base_surf.osnum=MOD_ENV.md_id.osnum;

  status = ci$send
              (msg = message EMSsurface.EMgetactiveid (
                     &msg, &active_state_GRid, NULL),
               targetid = base_surf.objid,
               targetos = base_surf.osnum);
  as$status(action = RET_STATUS);
  as$status(test = !(msg&1),action = RET_STATUS);
 
  /*
   * It may be possible that it is a single sf state
   * tree. In such a case the sf_geometry at the current
   * state is to be used.
   */

  /*| Get the active id */

  if(active_state_GRid.objid == base_surf.objid)
    single_sf_lift = TRUE;
  else
    {
    status = ci$send
               (msg = message GRowner.GRget_number_components(
                        &msg,&num_sfs),
                targetid = active_state_GRid.objid,
                targetos = active_state_GRid.osnum);
    as$status(action = RET_STATUS);
    single_sf_lift = (num_sfs == 1);
  }/* end if */

  /*
   * Get a vector normal to the surface and passing
   * through uv = (0.5,.0.5).
  */

  sf_geom=NULL;
  sf_info.located_obj = base_surf;
  ci$get_module_info(md_env = &MOD_ENV);
  sf_info.module_info = MOD_ENV;

  status = EMget_the_geometry(&sf_info, FALSE, FALSE,
                FALSE, NULL_OBJID,&sf_geom, &msg);
  as$status(action = RET_STATUS);

  u = v = 0.5;
  BSsfarrevn(&stat,sf_geom,1,&u,1,&v,sf_pt,sf_nrml);
  as$status(test = !(stat==BSSUCC)/*, action = RET_STATUS*/);

  for (i = 0; i < 3; i=i+1)
       dlift_info.draft_vec[i] = hauteur * sf_nrml[i];

  /*
   * If there is no loopset attached to the surface,
   * make one and 
   * allocate space for lps_info and eds_info.
   */

  status = om$make_chanselect (
               channame = "EMSsubbs.to_loopset",
               p_chanselect = &sf_ls_chan);
  as$status(action = RET_STATUS);

  status = om$get_channel_count (
               objid = base_surf.objid,
               osnum = base_surf.osnum,
               p_chanselect = &sf_ls_chan,
               count = &count);
  as$status(action = RET_STATUS);

  if(!count)
    {
    status = ci$send
                (msg = message EMSsurface.EMmk_nat_bdry(
                       &msg,&MOD_ENV,NULL),
                 targetid = base_surf.objid,
                 targetos = base_surf.osnum);
    as$status(action = RET_STATUS);
  }/* if (!count) */

  status = om$get_channel_objects
             (
              objid = base_surf.objid,
              osnum = base_surf.osnum, 
              p_chanselect = &sf_ls_chan,
             list = &ls_list, size = 1, count = &count);
  as$status(action = RET_STATUS);
  if(count != 1)return(FALSE);

  depth    = MAXINT;
  buf_size = 0;
  num_lps  = 0;
  lp_ids   = NULL;
  status = ci$send (msg = message EMSloopset.EMget_loops(
                           &msg, EMS_OPT_ALL, &depth, &lp_ids, 
                           NULL, &buf_size, &num_lps),
                     targetid = ls_list.S_objid,
                     targetos = ls_list.osnum);
  as$status(action = RET_STATUS);

#ifdef DEBUG
  printf("%d loops\n",num_lps);
#endif

  lps_info = (struct EMSdlft_lp_info *)malloc(num_lps*sizeof( struct EMSdlft_lp_info));

  dlift_info.num_lps  = num_lps;
  dlift_info.lps_info = lps_info;
  dlift_info.sf_GRid  = base_surf;

  array_size = 0;
  cum_num_eds = 0;
  ed_GRids = NULL;

  for (i = 0; i < num_lps; i=i+1)
    {
    lp_info = &lps_info[i];
    lp_info->lp_GRid.objid = lp_ids[i];
    lp_info->lp_GRid.osnum = base_surf.osnum;
                   
    num_lp_eds = 0;
    status = ci$send
                (msg = message EMSboundary.EMget_edges(
                        &msg, 1, EMS_OPT_NONDEG_NONSEAM, 
                        (struct GRid **)0, &array_size, &num_lp_eds),
                 targetid = lp_ids[i],
                 targetos = base_surf.osnum);
    as$status(action = RET_STATUS);
    cum_num_eds = cum_num_eds + num_lp_eds;
  } /* for (i = 0; i < num_lps; i++) */

  dlift_info.num_ed_infos = cum_num_eds;

  eds_info=(struct EMSdlft_ed_info *)malloc(cum_num_eds*sizeof(struct EMSdlft_ed_info));

#ifdef DEBUG
 printf("cum_num_eds %d\n",cum_num_eds);
#endif

  cur_ed = 0;
  for(i = 0; i < num_lps; i=i+1)
    {
    num_lp_eds = 0;
    status = ci$send
                (msg = message EMSboundary.EMget_edges(
                        &msg, 1, EMS_OPT_NONDEG_NONSEAM, 
                        &ed_GRids,&array_size, &num_lp_eds),
                 targetid = lp_ids[i],
                 targetos = base_surf.osnum);
    as$status(action = RET_STATUS);
   lp_info = &dlift_info.lps_info[i];
   lp_info->eds_info = &eds_info[cur_ed];
   lp_info->num_eds = num_lp_eds;

#ifdef DEBUG
 printf("num_lp_eds %d\n",num_lp_eds);
#endif

   for(j = 0; j < num_lp_eds; j=j+1)
     {
#ifdef DEBUG
     printf("affecte %d avec %d\n",cur_ed,ed_GRids[j].objid);
#endif

     eds_info[cur_ed].ed_GRid = ed_GRids[j];
     cur_ed=cur_ed+1;
    }
  }/* for (i = 0; i < num_lps; i++) */

#ifdef DEBUG
for (i=0; i<cum_num_eds; i=i+1)
    printf("edge %d --> %d\n",i,eds_info[i].ed_GRid.objid); 
                 
  /*| COMPUTE THE DRAFT ANGLE */
  printf("num_lps %d\n",dlift_info.num_lps);
#endif
  for (i = 0; i < dlift_info.num_lps; i=1+1)
    { 
#ifdef DEBUG
    printf("boucle sur loop\n");
#endif
    lp_info = &lps_info[i];
    lp_info->is_uniform = TRUE;
    lp_info->draft_angle = angle;
              
    for (j = 0; j < lps_info[i].num_eds; j=j+1)
      {
#ifdef DEBUG
      printf("affecte angle\n");
#endif
      ed_info = &lp_info->eds_info[j];
      ed_info->draft_angle = angle;
      ed_info->offset_code = BSCONSTOFF;
    } /* for (j = 0; j < lps_info[i].num_eds; j++) */
  } /* for (i = 0; i < slift_info.num_lps; i++) */

#ifdef DEBUG
for (i=0; i<cum_num_eds; i=i+1)
     printf("edge %d --> angle  %lf\n",i,eds_info[i].draft_angle); 

for (i=0; i< dlift_info.num_lps; i = i+1)
     printf("loop %d --> angle %lf\n",i,lps_info[i].draft_angle);
#endif

for (i=0; i< dlift_info.num_lps; i = i+1)
     lps_info[i].draft_angle = angle;

for (i=0; i<cum_num_eds; i=i+1)
   { eds_info[i].draft_angle = angle;
     eds_info[i].offset_code = BSCONSTOFF;
#ifdef DEBUG
     printf("edge %d --> angle  %lf\n",i,eds_info[i].draft_angle); 
#endif
   }
  dlift_info.mx_exlp_dangle = angle;

  /* FILLET */
  lp_info->fillet = fillet;

  /*| CHK_COINCIDENCE */
  if (check_coin)
    {
    for (i = 0; i < dlift_info.num_lps; i=i+1)
      {
      lp_info = &dlift_info.lps_info[i];
    }/*for (i = 0; i < dlift_info.num_lps; i++) */
  }/* if (check_coin) */

  /*| PROCESS */
  if(check_coin)
      active_constraints = EMS_LC_AUTO_COINCIDENCE;
  else
      active_constraints = NULL;

  for (i = 0; i < dlift_info.num_lps; i=i+1)
  {
      lp_info = &dlift_info.lps_info[i];

      for (j = 0; j < lp_info->num_eds; j=j+1)
        lp_info->eds_info[j].ed_constraint_type = active_constraints;

  } /* for(i = 0; i < dlift_info.num_lps; i++)*/

  /* INITIALISER L'ACTIVE DISPLAY */
  init_cnst_list();
  display.weight = cnst_list.weight;
  display.style  = cnst_list.style;
  display.color  = cnst_list.color;

  construct_list.newflag    = FALSE;
  construct_list.display    = &display;
  construct_list.level      = cnst_list.level;
  construct_list.geometry   = NULL;
  construct_list.class_attr = NULL;
  construct_list.msg        = &msg;
  construct_list.env_info   = &MOD_ENV;
  construct_list.properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  construct_list.name       = NULL;

  /*
   * It may be possible that the surafce is by itself or
   * a part of single surface state tree. In such a case,
   * the lift process should result in solid with new
   * surfaces created for the edges even though the edges
   * do not have a common edge.
   */

  if(single_sf_lift)
    {
    EFprepare_single_sf_lift ( &status, base_surf,
            &MOD_ENV, &construct_list, 
            &active_state_GRid, dlift_info.draft_vec);
    as$status(action = RET_STATUS);
   }/* if (single_sf_lift) */

  KLUDGE.msg       = &msg;
  KLUDGE.mod_env   = &MOD_ENV;
  KLUDGE.cnst_list = &construct_list;
  KLUDGE.ems_info  = &dlift_info;

  status = om$make_message
    (classname  = "EMSsfdlift",
     methodname = "EMlift_face",
     size       = sizeof(KLUDGE),
     p_arglist  = &KLUDGE,
     p_msg      = &mess);
  as$status(action = RET_STATUS);
                 
  lift_solid.objid=NULL_OBJID;
  lift_solid.osnum=MOD_ENV.md_id.osnum;

  status = ci$send (msg = message EMSsurface.EMlift_face_w_draft(
                      &msg1,
                      &mess,
                     &lift_solid),
     targetid = active_state_GRid.objid,
     targetos = active_state_GRid.osnum);
    as$status(test = !(1&status&msg&msg1),action = RET_STATUS);

  /*| ADD_TO_TREE */
 
  /*
   * If it is a single surface lift, merge EMSsldlift class
   * object constructed in EFprepare_single_sf_lift() with 
   * EMSsldlift class object constructed above.
   */

  if(single_sf_lift)
    {
    EFmerge_single_sf_lift_states(&status, active_state_GRid,
                                  lift_solid, base_surf, &MOD_ENV);
    as$status(action = RET_STATUS);
    }/* if (single_sf_lift) */
  else
    {
    add_option = EMS_DO_DISPLAY;
    status = ci$send(msg = message EMSsfdpr.EMadd(&msg, 
                                  &active_state_GRid, NULL, 
                                  &MOD_ENV, &add_option),
                     targetid = lift_solid.objid,
                     targetos = lift_solid.osnum);
    as$status(test = !(1&status&msg), action = RET_STATUS);
    }
   sav1_ENV=MOD_ENV;
   sav1_ENV.md_id.objid=NULL_OBJID;
   status = ci$send(msg = message EMSdpr.EMmake_primitive1(
				&msg,
				&sav1_ENV,
                                feet_obj ),
	        targetid = lift_solid.objid,
		targetos = lift_solid.osnum);

#define SUC_SOL			2654217

    if( msg != SUC_SOL || !(1&status))
	feet_obj[0].objid = NULL_OBJID;

//feet_obj[0] =lift_solid;
#ifdef DEBUG
write("exiting construct func,  lift_solid ", lift_solid.objid,"\n");
write("exiting construct func,  feet_obj ", feet_obj[0].objid,"\n");
#endif

exception: 
  free(lps_info);
  if (lp_ids != NULL) om$dealloc (ptr = lp_ids);
  if (ed_GRids!= NULL) om$dealloc (ptr = ed_GRids);

}/* end cons_lift_solid */
/*=======================================================================*/
NDdelete(md_env)
  struct GRmd_env *md_env;
  {
	IGRint		 sts, GRdpmode;  
	struct GRid	display_info;
  	extern int	GRfindmod();
	struct GRmd_env	from_env;

        GRfindmod(&display_info);
        GRdpmode = 0;

  sts = ci$send
    (msg      = message ACcpx.ACfind_temp_obj(&status,BASE_SURF,&temp_object),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);
  as$status( action = RET_STATUS );
  if(!status) goto wrapup;

   ci$send( msg      = message NDmacro.ACreturn_foot(	
						&stat ,
						"",
						&base_surf,
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix ),
	   targetid = temp_object.objid,
	   targetos = temp_object.osnum );

  if(!stat) goto wrapup;

  from_env.md_id.osnum = base_surf.osnum;

  /*---------------*/
  /* Get the solid */
  /*---------------*/
  status = ci$get_channel_objects(
		osnum		= base_surf.osnum,
 		objid		= base_surf.objid,
		channname	= "GRconnector.to_owners",
		obj_list	= &tmp_obj.objid,
		osn_list	= &tmp_obj.osnum,
		count		= &count );

#ifdef DEBUG
write("NDdelete ci$get_channel_objects: count = ", count, '\n' );
#endif

  if ( !status ) {
	write("pbs in ci$get_channel_objects\n");
	return 0;
  }

  if(count)
    {
    /* if tmp_obj is not a solid, go one more level */
    om$get_classname ( objid= tmp_obj.objid,
		  osnum = tmp_obj.osnum,
                  classname = classname  );

#ifdef DEBUG
write("NDdelete classname for tmp_obj:",classname, '\n' );
#endif

    if( !om$is_ancestry_valid( subclassname     = classname,
			       superclassname = "EMSsolid" ) ){
#ifdef DEBUG
write("NDdelete NOT subclass of EMSsolid", '\n' );
#endif
	  status = ci$get_channel_objects(
		osnum		= tmp_obj.osnum,
 		objid		= tmp_obj.objid,
		channname	= "GRconnector.to_owners",
		obj_list	= &base_solid.objid,
		osn_list	= &base_solid.osnum,
		count		= &count );
	  if ( !status || count <= 0 ) {
		write("pbs in ci$get_channel_objects\n");
		return 0;
	  }
    } else {
#ifdef DEBUG
write("NDdelete subclass of EMSsolid", '\n' );
#endif
	 base_solid = tmp_obj;
    }
  } else
	 base_solid = base_surf;

  status = ASmake_source_from_env( &base_solid,&sav_ENV,&object);	

  as$status(  );

  status = ci$send( msg = message  NDmacro.ACunconsume(&msg,""),
           targetid =  object.objid,
           targetos =  object.osnum );
  as$status();

	   ci$send(msg      = message GRgraphics.GRdisplay(
					&msg,
					&from_env.md_env.matrix_type,
                                	from_env.md_env.matrix,
	                        	&GRdpmode,
					&display_info),
	           targetid = base_solid.objid,
		   targetos = base_solid.osnum);

wrapup:
  status = ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum,
           mode     = WRT_message );
  as$status();
  return 1;
}

