/* $Id: txt_on_crv.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/general/macros / txt_on_crv.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: txt_on_crv.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/06/27  21:14:50  pinnacle
# Created: cimacros/general/macros/txt_on_crv.u by mdong for vds
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	05/12/97	Ming Dong
 *
 * -------------------------------------------------------------------*/

   
#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "grdpb.h"
#include "grdpbmacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "drawparam.h"
#include "fontdef.h"
#include "font.h"
#include "gotext.h"
#include "asbox.h"
#include "AS_status.h"
#include "VDmem_ppl.h"
#include "OMmacros.h"
#include "nddef.h"
#include "gotextdef.h"

/*
 *  ANSI static prototype
 */
#if defined(__STDC__) || defined(__cplusplus)
#define __(args) args
#else
#define __(args) ()
#endif
#if defined(__cplusplus)
extern "C" {
#endif

#if defined(__cplusplus)
}
#endif
#undef __

//#define AS_DEBUG

/* to call change text attribute */


/* asked text position */

#define ASKED 0x3
#define ASKED_AUTO 0x0
#define ASKED_SAME 0x1
#define ASKED_OPPO 0x2

/* asked text justification change */

#define ASKED_FLIP 0x60
#define X_FLIP     0x0
#define XY_FLIP    0x20


/* obtained text position */

#define ACTUEL 0xc
#define ACTUEL_SAME 0x4
#define ACTUEL_OPPO 0x8

/* Do i need to change justification for this step */

#define FLIPPED 0x10
#define SAME    0x0


IGRchar *text_buffer;        		/* buffer to store text  */
IGRshort text_buffer_size;   		/* size of buffer        */
IGRshort text_buffer_len;    		/* len of text in buffer */


#define MAX_TEMP	100
#define MAX_TEXT_PAR	20
#define ASMV_INVERT 	1     		/* use the inverse matrix */
#define ASMV_VECTOR	2     		/* vector transformation  */
#define	TEMP_MAX	100


long			sts;          /* returned message from a function     */
long			msg;          /* returned message from a function     */
short   		osnum;        /* Current object space                 */
double			width_value;  /* Text width to be changed             */
double			height_value; /* Text height to be changed	      */
struct GRmd_env		MOD_ENV;
struct GRid		TEMP[TEMP_MAX];
int			i, j;
int			num_tmp;      /* Real number of template              */
IGRchar			*temp_names[MAX_TEMP], *feet_names[1];
IGRint			temp_types[MAX_TEMP];
GRobj           	ci_mac_def1;
struct GRid		COMP;         /* GRid of the component(text)          */
struct GRdpb_text_symb	text_symb;
short			active_level;
struct IGRdisplay 	active_display;
struct GRid		CI_MACRO_ID;


/* External functions */

extern 			ASget_active_symb();
extern 			GRdpb_get();
extern 			ASfind_font_info();
extern IGRboolean       GRjust_string();
extern IGRboolean      	GRnum_disp_char();
extern IGRboolean   	MAidmx();
extern void   		ASmatv();
extern 		   	AStrans_mat();
extern 		   	ASlineangl_vor();


/* Obtain my symbology in construction list */

get_my_symb()
{

 int	msg;
 int	NumberOfBytes;
 int	BytesReceived;


	ASget_active_symb(&active_level,&active_display);

	cnst_list.color = active_display.color;
	cnst_list.weight = active_display.weight;
	cnst_list.style = active_display.style;
	cnst_list.level = active_level;
	cnst_list.locatable = 1;
	cnst_list.displayable = 1;

	NumberOfBytes = sizeof( text_symb );
	gr$get_text_symb( msg    = &msg,
                   	  sizbuf = &NumberOfBytes,
                   	  buffer = &text_symb,
                   	  nret   = &BytesReceived );

	if ( !(msg&1) ) { write( "cannot get text symbology" ) ; return 0 ; }


	cnst_list.font = text_symb.Active_font;
	cnst_list.just = text_symb.Active_just;
	cnst_list.width = text_symb.Active_width;
	cnst_list.height = text_symb.Active_height;

	cnst_list.line_spac = text_symb.Active_linespac;
	cnst_list.char_spac = text_symb.Active_charspac;
}


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

	temp_names[0] = "ref";
	temp_types[0] = ref_generic;

	temp_names[1] = "wirefrm";
	temp_types[1] = point_generic | conic_generic |
			line_generic  | curve_generic;

	temp_names[2] = "text";
	temp_types[2] = parameter_generic;

	temp_names[3] = "index/height";
	temp_types[3] = point_generic | double_type;

	temp_names[4] = "height/width";
	temp_types[4] = double_type;

	temp_names[5] = "width";
	temp_types[5] = double_type;

  	feet_names[0] = "text";
  	ci_mac_def1   = NULL_OBJID;

	ac$cimacdef(cimacdef          = ci_mac_def1,
		    status 	      = &sts, 	
		    name              = "txt_on_crv",
		    int_size          = 0,
              	    temp_num          = 6, 	
		    temp_names        = temp_names,
		    temp_types        = temp_types,
	      	    extern_feet_num   = 1, 	
		    extern_feet_names = feet_names );
}

/* ========================================================================= */

place ()
{
  	construct_comp();
   
	if( COMP.objid == NULL_OBJID ) return(0);

  	ci$send( msg = message  ci_macro.set_all_extern_feet
				(&sts, 1, &COMP, &MOD_ENV ),
	   	 targetid = CI_MACRO_ID.objid,
	   	 targetos = CI_MACRO_ID.osnum);

  	return(1);
}


/* ========================================================================= */

compute ()
{
  	construct_comp();

	if( COMP.objid == NULL_OBJID ) return(0);

  	ci$send( msg = message  ci_macro.set_all_extern_feet
				(&sts, 1, &COMP, &MOD_ENV ),
	   	 targetid = CI_MACRO_ID.objid,
	   	 targetos = CI_MACRO_ID.osnum);

  	return(1);
}

/* ========================================================================= */

construct_comp()
{


	ci$get_module_info(md_os = &osnum,
			   md_env = &MOD_ENV);


/* Retrieve the template GRid and number of the template */

	COMP.objid = NULL_OBJID;
	COMP.osnum = MOD_ENV.md_id.osnum;

	sts =
	ci$send(msg = message NDnode.NDget_objects(ND_ROOT,
						   TEMP,
						   OM_K_MAXINT,
						   NULL,
                                                   0,
						   OM_K_MAXINT,
						   &num_tmp),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum) ; 
	as$status(sts = sts) ;

	if(!(sts&1)) return (OM_E_ABORT) ;

	if( num_tmp > TEMP_MAX ) return 0 ;


/* Get my symbology  */
 
	get_my_symb();


/* Construct the component of the macro */

	GRconstruct_comp();

}

/*=========================================================================*/

GRconstruct_comp()
{
	struct GRid		*list;
	IGRint			num, i, j, ic;
	struct GRid		ref, point, supp;
	IGRint			flipped, orient;
	struct ret_struct	suppdef;
	IGRdouble		origin[3];
	struct IGRlbsys		lbs_geom;
	struct IGResintx	*tx_attr;
	struct extents		ext;
	IGRint 			type[MAX_TEXT_PAR];
	struct ret_struct	def[MAX_TEXT_PAR];
	IGRdouble		*snap;
	IGRint			save_just, rc;
	IGRlong			status;
	struct IGRdisplay	*disp_attr;
	IGRchar			flag;
	IGRdouble		trans[3];
	IGRchar			text_buf[80], text[80];
	IGRdouble		value;
	struct vfont_entry	font_info;
	struct GRdpb_text_symb	dpb_ts;
	struct GRvg_construct	cst;


	text_buffer_size = 0;
	text_buffer_len = 0;


/* Allocate memory */

	tx_attr = _MALLOC(1,  struct IGResintx);
	tx_attr->estx = _MALLOC(1,  struct IGRestx);
	snap = _MALLOC(1,  IGRdouble);


/* get parents */

	list = TEMP;
	num = num_tmp;
	if(num >= MAX_TEXT_PAR) 
	 { 
	  printf("to many parents for a text\n");
	  _FREE(tx_attr->estx);
	  _FREE(tx_attr);
	  _FREE(snap);
          return(OM_W_ABORT);
	 }

	ref = NULL_GRID;
	point = NULL_GRID;
	supp = NULL_GRID;


/* Obtain the type of all templates */

	for (i=0 ; i<num ; i=i+1)
         {
	  status = ci$send(msg      = message NDnode.NDgive_structure(
			                    &msg, &def[i], &MOD_ENV),
                           targetid = list[i].objid,
                           targetos = list[i].osnum);
	  if((!status&1)) continue;

	  type[i] = def[i].type;
	 }


/* Retrieve info. of coordinate system */

	for(j=0; j<16; j=j+1) lbs_geom.matrix[j] = def[0].var.ref_st.t[j];
        ref.objid = list[0].objid;
        ref.osnum = list[0].osnum;


/* Retrieve info. of wireframes and get the base point of text for placing */

	if(def[1].type & point_generic)
         {
          v_equal(def[1].var.point_st.pt, origin);
          point.objid = list[1].objid;
          point.osnum = list[1].osnum;
         }

        else if(def[1].type & line_generic || def[1].type & conic_generic
                                           || def[1].type &curve_generic)
         {
          suppdef = def[1];
          supp.objid = list[1].objid;
          supp.osnum = list[1].osnum;
	  v_equal(def[3].var.point_st.pt, origin);
          point.objid = list[3].objid;
          point.osnum = list[3].osnum;
         }


/* get flag and translation in local coordinate if any */

	*snap = 0.0;
	flag = (IGRint) *snap & (ASKED | ASKED_FLIP);
	trans[0] = 0;
	trans[1] = 0;
	trans[2] = 0;


/* find the value and the parameter in the parent list */

	text_buf[0] = 0;

	if (type[2] == double_type)
         {
          if (def[2].var.root_pm_st.value !=  MAXDOUBLE)
           {
            value = def[2].var.root_pm_st.value;
           }
          else
           {
            def[2].var.root_pm_st.value = 0;
            value = def[2].var.root_pm_st.value;
           }

	  sts = sprintf(text_buf, "%10.3lf", value);

	  for(ic=0; ic<10 && text_buf[ic] == ' '; ic=ic+1);
	  strcpy(text, text_buf+ic);
	 }

	else if(type[2] == text_type)
         {
          strcpy(text, def[2].var.text_st.text_string);
         }


/* Get the height and width of text */

	if( num_tmp == 4 )
	 {
          height_value = def[3].var.root_pm_st.value;
	  width_value = height_value ;
	 }

	if( num_tmp == 5 )
	 {
	  if (def[3].type == point_generic)
	   {
            height_value = def[4].var.root_pm_st.value;
	    width_value = height_value ;
	   }
	  else
	   {
	    height_value = def[3].var.root_pm_st.value;
            width_value = def[4].var.root_pm_st.value;
	   }

	 }

	if( num_tmp == 6 )
	 {
	  height_value = def[4].var.root_pm_st.value;
          width_value = def[5].var.root_pm_st.value;
	 }


	tx_attr->estx->width = width_value;
	tx_attr->estx->height = height_value;
	tx_attr->estx->font = cnst_list.font;
	tx_attr->estx->just = cnst_list.just;
	tx_attr->estx->line_spac = cnst_list.line_spac;
	tx_attr->estx->char_spac = cnst_list.char_spac;
	tx_attr->estx->flag = VI_FLAG;

	text_buffer_len = strlen(text);
	text_buffer = _MALLOC(text_buffer_len+1,  IGRchar);
	for(i = 0 ; i < text_buffer_len ; i = i + 1)
	 text_buffer[i] = text[i];
	text_buffer[i] = '\0';

	tx_attr->text_string = text_buffer;
	tx_attr->estx->text_length = text_buffer_len;

	disp_attr = &active_display;


/*   get text extents in local coordinate            */

	status = ASfind_font_info(tx_attr->estx->font,&font_info);
        as$status(action = RET_STATUS);

        dpb_ts.Active_font = tx_attr->estx->font;
        dpb_ts.Active_just = tx_attr->estx->just;
        dpb_ts.Active_width = tx_attr->estx->width;
        dpb_ts.Active_height = tx_attr->estx->height;
        dpb_ts.Active_linespac = tx_attr->estx->line_spac;
        dpb_ts.Active_charspac = tx_attr->estx->char_spac;

        if (!GRjust_string(&sts,
			   &text_buffer,
			   &text_buffer_len,
			   &text_buffer_size,
                           &font_info,
			   disp_attr,
		   	   &dpb_ts,
			   0,
			   NULL,
			   &ext))
         {
          printf("error in just string\n");
          _FREE(tx_attr->estx);
          _FREE(tx_attr);
          _FREE(snap);
	  _FREE(text_buffer);
          return (OM_W_ABORT);
         }


/* calculate number of displayable characters */

	tx_attr->estx->num_char= 0;
	GRnum_disp_char(&sts,
			text_buffer,
			&text_buffer_len,
                        dpb_ts.Active_font,
			font_info.flags,
                        &tx_attr->estx->num_char);

	tx_attr->text_string = text_buffer;
	tx_attr->estx->text_length = text_buffer_len;


/* compute position and coordinate system */

	ASget_lbsys(ref,
		    point,
		    supp,
		    origin,
		    NULL,
		    trans,
		    &suppdef,
		    &ext,
		    flag,
		    &lbs_geom,
            	    &orient,
		    &flipped,
		    &MOD_ENV,
		    0);

	flag = flag | orient | flipped;
                                 /* to know if text is in same or reverse */
                                 /* position of curve */

	save_just = tx_attr->estx->just;
	if(flipped == FLIPPED)   /* I have to change justif due to iterations */
                                 /* in ASget_lbsys                            */
         {
          if((flag & ASKED_FLIP) == X_FLIP)
           {

      /*| only change x justif */
            if(tx_attr->estx->just<5)      
	     tx_attr->estx->just = tx_attr->estx->just+10;
            else if(tx_attr->estx->just>9) 
	     tx_attr->estx->just = tx_attr->estx->just-10;
            else
	     tx_attr->estx->just = tx_attr->estx->just;
            trans[0] = -trans[0];
           }
          else
           {

      /*| change x and y justif */
            tx_attr->estx->just  = 14 - tx_attr->estx->just;
            trans[0] = -trans[0];
            trans[1] = -trans[1];
           }

	  dpb_ts.Active_just = tx_attr->estx->just;

          if (!GRjust_string(&sts,
                             &text_buffer,
                             &text_buffer_len,
                             &text_buffer_size,
                             &font_info,disp_attr,
                             &dpb_ts,
                             0,
                             NULL,
                             &ext))
           {
            printf("error in just string\n");
            _FREE(tx_attr->estx);
            _FREE(tx_attr);
            _FREE(snap);
            _FREE(text_buffer);
            return (OM_W_ABORT);
           }


/* calculate number of displayable characters */

          tx_attr->estx->num_char= 0;
          GRnum_disp_char(&sts,
                          text_buffer,
                          &text_buffer_len,
                          dpb_ts.Active_font,
                          font_info.flags,
                          &tx_attr->estx->num_char);

          tx_attr->text_string = text_buffer;
          tx_attr->estx->text_length = text_buffer_len;
	 }

/* Fills in the instance data of text element and posts the object */

        cst.newflag = 0;
        cst.name = NULL;
        cst.properties = GRIS_DISPLAYABLE |
			 GRIS_NEW |
			 GRIS_LOCATABLE;

        cst.display = &active_display;
        cst.msg = &msg;
        cst.env_info = &MOD_ENV;
        cst.class_attr = (IGRchar *)tx_attr;
        cst.geometry = (IGRchar *)&lbs_geom;
        cst.level = active_level;

	sts = ci$send(msg      = message GR3dtext.GRconstruct( &cst ),
		      targetid = COMP.objid,
		      targetos = COMP.osnum);

	if( !(sts&1) ) COMP.objid = NULL_OBJID;

        _FREE(tx_attr->estx);
        _FREE(tx_attr);
        _FREE(snap);
        _FREE(text_buffer);


        return( 1 );
}
/*=======================================================================*/

/*****************************************************
   get lbsys definition corresponding to a text
******************************************************/

ASget_lbsys(ref,point,supp,real_origin,target,trans,
			suppdef,ext,in_flag,
                        lbs_geom,orient,flipped,md_env,cn_type)

struct GRid ref,point,supp;  /*  ref, point or support GRid or NULL_GRID     */
IGRdouble *real_origin;      /* coordinate of origine of text                */
IGRdouble *target;	     /* target position when AS_COMP_XF		     */
IGRdouble *trans;            /* translation of text in local coordinate      */
struct ret_struct  *suppdef; /* support definition 			     */
struct extents *ext;	     /* extents of text 			     */
IGRint in_flag;		     /* orientation mode text versus suport and ref  */
struct IGRlbsys *lbs_geom;   /* returned lbs_geom definition 		     */
IGRint *orient;	             /* text orientation versus support 	     */
IGRint *flipped;	     /* As text justification changed for this step  */
struct GRmd_env *md_env;
IGRint cn_type;

/*.ASget_lbsys*/
{
 IGRmatrix mat;
 IGRdouble  axex[3],axey[3],norm[3],new_origin[3],prov[3],scale,*origin,
	    x_positive;
 IGRint status,i,ix,iter,nter;
 IGRdouble one;
 IGRint prev_orient;
struct ret_struct ptprov,lineprov;

 one = 1.0;
/* compute position and coordinate system */

   if(IF_NULL_OBJID(ref.objid)) { MAidmx(&status,lbs_geom->matrix); } 
   if(IF_NULL_OBJID(point.objid)) { v_identity(real_origin) ; }
  
/* if support find tangency vector on support */
/* An iterative procedure is necessary a have tangent for middle text */

/*"box %lf %lf %lf %lf\n",ext->left,ext->right,ext->top,ext->bottom*/

   prev_orient = in_flag & ACTUEL;
   origin = real_origin;
   if(!IF_NULL_OBJID(supp.objid))
     {
      AStrans_mat(lbs_geom->matrix,mat);

      nter = 4;
      for(iter=0 ; iter<nter ; iter=iter+1)
	{
         if (suppdef->type & line_generic)
           {
	    /*| supp is a line */
	    scale = -v_dot(suppdef->var.line_st.v0,mat+8);
	    v_comb(one,suppdef->var.line_st.v0,scale,mat+8,axex);
	    scale = v_len(axex);
 	    if(scale != 0) { scale = 1/scale; v_scale(axex,scale,axex); }
		      else { v_equal(mat,axex); }
	    v_cross(mat+8,axex,axey);
           }

        
         else if (suppdef->type & conic_generic) 
	   {
	    /*| supp is a circle */
	    /* Modify jla 18-april-89 */
	   
	    /*
	       compute the direction vector from the center of the circle     
	       to the projection of the placement point into the plane
	       of the circle
	    */

	    v_sub(origin,suppdef->var.circle_st.cent_p,axey);

	    /*^ pr_point("cent_p",suppdef->var.circle_st.cent_p); */
            
 	    norm[0] = suppdef->var.circle_st.mat[2];
 	    norm[1] = suppdef->var.circle_st.mat[6];
 	    norm[2] = suppdef->var.circle_st.mat[10];

	    /*^ pr_point("normale",norm); */

	    scale = -v_dot(norm,axey);
	    /*"scale %lf\n",scale */
	    v_comb(one,axey,scale,norm,axey);
	    /*^ pr_point("axey",axey); */

	    /* find coresponding tangent vector to the circle */
         
	    scale = v_len(axey);
	    /*"scale %lf\n",scale */
	    
 	    if(scale != 0)
	      { scale = 1./scale;
		v_scale(axey,scale,axey);
	        v_cross(norm,axey,axex);
	      }
	    else
	      { /* The project point is the center of the circle */
		axex[0] = suppdef->var.circle_st.mat[0];
	        axex[1] = suppdef->var.circle_st.mat[4];
	        axex[2] = suppdef->var.circle_st.mat[8];
	      }


/* KLUDGE BECAUSE TEXT ON ARC USED TO BE WITH A REVERSE ORIENTATION 
   BEFORE MAY 89. TO BE MODIFIED WHEN DIM CAN DO THE CORRESPONDING 
   TRANSFORMATION
*/
            v_neg(axex,axex);

	  
	   /* Project now in Oxy plane */

            scale = -v_dot(axex,mat+8);
            v_comb(one,axex,scale,mat+8,axex);
            scale = v_len(axex);
            if(scale != 0) { scale = 1/scale; v_scale(axex,scale,axex); }
                      else { v_equal(mat,axex); }

   

	    v_cross(mat+8,axex,axey);
	    /*^ pr_point("axex",axex); */
	    /*^ pr_point("axey",axey); */
	   }

	 else if(suppdef->type & curve_generic)
	   {
	    v_equal(origin,ptprov.var.point_st.pt);
	    lineprov.type = curve_generic;
	    status = ASlineangl_vor(&ptprov,&lineprov,supp,md_env);
            scale = -v_dot(lineprov.var.line_st.v0,mat+8);
            v_comb(one,lineprov.var.line_st.v0,scale,mat+8,axex);
            scale = v_len(axex);
            if(scale != 0) { scale = 1/scale; v_scale(axex,scale,axex); }
                      else { v_equal(mat,axex); }
            v_cross(mat+8,axex,axey);
	   }


       /*"axex %lf %lf %lf\n",axex[0],axex[1],axex[2] */
   
      /*
         reverse vector
	 - if asked : in_flag & ASKED_OPPO
	 - if asked and necessary to have local and referential y axis in
           the same direction in_flag & ASKED_AUTO
      */

	 switch (in_flag & ASKED)
	   {
	    case ASKED_AUTO :
         	scale = v_dot(axey,mat+4);
         	if(scale<-1.e-2 || (scale < 1.e-2 && v_dot(axey,mat)>0.) )
           	  {
            	   v_neg(axex,axex);v_neg(axey,axey);
            	   *orient = ACTUEL_OPPO ;
           	  }
          	else *orient  = ACTUEL_SAME;
		break;

	
	    case ASKED_OPPO :
		v_neg(axex,axex); v_neg(axey,axey);
            	*orient = ACTUEL_OPPO ;
		break;


	    case ASKED_SAME :
            	*orient = ACTUEL_SAME ;
		break;
	  }

      /*
	 A change of the positive sens of the text will imply a justification
         changed and the change sign of me->trans[0] only if text orientation
         versus support orientation was already defined (call from compute or
         place afer first iteration).
      */
	 if((prev_orient != *orient) && (prev_orient != 0)) x_positive= -1;
						       else x_positive=  1;
	 if(prev_orient == 0) prev_orient = *orient;

	 /* evaluate origine from translation */
	 /*"cn_type %d\n",cn_type */
	 if( (cn_type&ND_COMP_TYPE) != ND_COMP_XF)
	    {
             for(i=0;i<3;i=i+1)
                {
                 lbs_geom->matrix[4*i]   = axex[i];
                 lbs_geom->matrix[4*i+1] = axey[i];
             	 lbs_geom->matrix[4*i+3] = real_origin[i] +
	    	     	      x_positive*axex[i]*trans[0] + axey[i]*trans[1] ;
		}
	    }


	 else
	    {
	     /* modify translation vector to  obtain real_origin */
             for(i=0;i<3;i=i+1)
                {
                 lbs_geom->matrix[4*i]   = axex[i];
                 lbs_geom->matrix[4*i+1] = axey[i];
             	 lbs_geom->matrix[4*i+3] = target[i];
		}
	     v_sub(target,real_origin,prov);
	     ASmatv(ASMV_VECTOR|ASMV_INVERT,lbs_geom,prov,trans);
	     trans[0] = trans[0]*x_positive;
	     /*^
		pr_mat("lbs",4,4,lbs_geom->matrix);
	        pr_point("target ",target);
	        pr_point("real_origin ",real_origin);
	        pr_point("prov ",prov);
	     */
	    }
	     

       /* control solution. Need to compute middle of box */

         if (suppdef->type & line_generic) 
	    {if(prev_orient == 0) prev_orient = *orient;
	     break;
	    }
	 if(iter == nter) break;
      
	

	 i = 0;
	 for(ix=0; ix<3 ; ix=ix+1) 
	  {
	   new_origin[ix] = lbs_geom->matrix[i]*(ext->left+ext->right);
	   i = i + 1;
	   new_origin[ix] = new_origin[ix] + 
			    lbs_geom->matrix[i]*(ext->top+ext->bottom);
	   i = i + 1;
	   new_origin[ix] = new_origin[ix] * x_positive * 0.5;
	   i = i + 1;
	   new_origin[ix] = new_origin[ix] + lbs_geom->matrix[i];
	   i = i + 1;
	  }

	 origin = new_origin;
	/*"origine %lf %lf %lf\n",origin[0],origin[1],origin[2] */

       } /* loop on iterations  */
     }

   /*^ pr_mat("placement matrix",4,4,lbs_geom->matrix); */
  

/* text is not on a support */
   else
     {
      *orient = ACTUEL_SAME;prev_orient = ACTUEL_SAME;
      lbs_geom->matrix[3]  = real_origin[0] + lbs_geom->matrix[0]*trans[0] +
      	       lbs_geom->matrix[1]*trans[1] + lbs_geom->matrix[2]*trans[2] ;

      lbs_geom->matrix[7]  = real_origin[1] + lbs_geom->matrix[4]*trans[0] +
      	       lbs_geom->matrix[5]*trans[1] + lbs_geom->matrix[6]*trans[2] ;

      lbs_geom->matrix[11] = real_origin[2] + lbs_geom->matrix[8]*trans[0] +
      	       lbs_geom->matrix[9]*trans[1] + lbs_geom->matrix[10]*trans[2] ;
     }

/* Will the text be flipped ? */

   if(prev_orient != *orient) *flipped = FLIPPED;
		          else    *flipped = SAME;

/*
   compute box (I don't understand why this compute is not done by
   the GRtext.Grconstruct or postabs method)
*/
    if(*flipped == SAME)
      {lbs_geom->diag_pt1[0] = ext->left;
       lbs_geom->diag_pt1[1] = ext->bottom;
       lbs_geom->diag_pt2[0] = ext->right;
       lbs_geom->diag_pt2[1] = ext->top;}
    else if ((in_flag&ASKED_FLIP) == X_FLIP)
      {lbs_geom->diag_pt1[0] = ext->right;
       lbs_geom->diag_pt1[1] = ext->bottom;
       lbs_geom->diag_pt2[0] = ext->left;
       lbs_geom->diag_pt2[1] = ext->top;}
     else
      {lbs_geom->diag_pt1[0] = ext->right;
       lbs_geom->diag_pt1[1] = ext->top;
       lbs_geom->diag_pt2[0] = ext->left;
       lbs_geom->diag_pt2[1] = ext->bottom;}

    lbs_geom->diag_pt1[2] = 0;
    lbs_geom->diag_pt2[2] = 0;

/*^ 
    pr_mat("lbs_mat",4,4,lbs_geom->matrix);
    pr_point("lbs_pt1",lbs_geom->diag_pt1);
    pr_point("lbs_pt2",lbs_geom->diag_pt2);
*/
}
