/* $Id: nboolean.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / nboolean.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: nboolean.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.2  1998/09/29  16:48:20  pinnacle
# Replaced: cimacros/wireframe/macros/nboolean.u for:  by vsrivast for vds
#
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.3  1998/02/20  17:40:58  pinnacle
# Replaced: cimacros/wireframe/macros/nboolean.u for:  by impd for vds
#
# Revision 1.2  1998/01/23  18:33:14  pinnacle
# Replaced: cimacros/wireframe/macros/nboolean.u for:  by azuurhou for vds
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1996/04/09  19:48:22  pinnacle
# Replaced: cimacros/wireframe/macros/nboolean.u for:  by azuurhou for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	04/08/96	adz		TR 17960133[267]
 *	01/23/97	ada		TR 179702535
 *      09/28/98        vini            TR 179800627
 *
 * -------------------------------------------------------------------*/

#ifdef CLOCK
extern clock();
#endif

/**************************************************************************/
/*
/*   jll  design date: june 88
/*
/*   Associative boolean operations on solid
/*
/*   may be used by the command object COsol_op
/*   
/*   Jan '90 modifications  R Patience
/*			    E Beeker
/*	. adapted to fit new macros
/*	. indexing on surfaces
/*	. ACgive_path, ACgive_foot, NDdelete overriden
/*	. macro now named "nboolean" not to interfere with previous one
/*	. some small bugs fixed
/*
/**************************************************************************/


#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "AS_status.h"
#include "madef.h"
#include "msdef.h"
#include "EMSmsgdef.h"
#include "emssfintdef.h"
#include "bstypes.h"

#include "macro.h"
#include "emsbool.h"
#include "dp.h"

/* Added for TR 179800627 */
#include "go.h"
#include "grmacros.h"
#include "grdpbmacros.h"

#define MAX_TEMP		33
#define MAX_CHA_TEMP		4


IGRint      		status;
IGRchar	 		txt[MAX_CHA_TEMP], buff[MAX_TEMP*MAX_CHA_TEMP];
IGRchar 		*temp_names[MAX_TEMP], *feet_names[1];
IGRint			temp_types[MAX_TEMP];

IGRshort		mat_type;
IGRdouble 		matrix[16];

IGRlong			msg;
IGRint 			j,i, k,kk, stat, display_count, num_par_sol,
			num_true_sol;
enum	GRdpmode	GRdpmode;
IGRint			placetime;
unsigned short  	option;

GRobj           	SOLOBJ[MAX_TEMP], ci_mac_def1,TrueSol[MAX_TEMP];
GRobj			RES1, RES2, *PRES2;
GRclassid		classid ;


struct IGRdisplay 	dis;
struct GRvg_construct 	cst;
struct GRmd_env 	MOD_ENV;
struct GRid 		S[MAX_TEMP], SOL, TMP, GRid_list[1], CI_MACRO_ID;
struct GRid      	display_info,wrk_GRid, *components ;
IGRint			count ;

char			status_str[54], mapping[66];

enum EMSbooltype  	bool_type;

struct xy
 {
  int               num_solid; /* number of solid to do operation 	  */
  enum EMSbooltype  booltype;  /* type de l'operation (union, inter, ...) */
 } *me;


extern int	GRfindmod(),
		init_cnst_list(),
		sprintf(),
		printf(),
		MAidmx(),
		sscanf();
extern	long	VD_getComponents();

extern GRclassid    OPP_EMSsolid_class_id ;
extern int      ACread();
extern 		ASsuper_construct();
extern	IGRchar	*malloc();
extern  IGRint	free();
extern	void	BSrgbxint();
extern	void	VD_ShowObj();

extern short _Pathway, _pathway_trim, _pathway_orient;
short        sav_pathway_trim, sav_pathway_orient;
/* Added for TR 179800627 */
extern long GRdisplay_object( ) ;
extern long GRsymbology_options( ) ;

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

  for (i=0; i<MAX_TEMP; i=i+1){
	sprintf(&buff[i*MAX_CHA_TEMP],"S%d",i+1);
	temp_names[i] = &buff[i*MAX_CHA_TEMP];
	temp_types[i] = other_generic;
  }

  feet_names[0] = "SOL";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat   , 	
		prop	          = ACwith_instances,
		name              = "nboolean",
		int_size          = sizeof(struct xy),
              	temp_num          = MAX_TEMP,	
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}

/* ========================================================================= */

place ()
{
  placetime = 1;
  construct_comp();

  if( SOL.objid == NULL_OBJID ) return(0);

#ifdef	DEBUG
	write(" Accept after placement \n");
#endif

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1, &SOL, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}

/* ========================================================================= */

compute ()
{

  placetime = 1;
  construct_comp();

  if( SOL.objid == NULL_OBJID ) return(0);
#ifdef	DEBUG
	write(" Accept after comnpute \n");
#endif

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, 1, &SOL, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}

/* ========================================================================= */

NDdelete(md_env)
struct GRmd_env *md_env;
{
	IGRint		stat1;
	struct GRid	GCV;
	IGRshort	matrix_type;
	IGRdouble	matrix[16];

        GRfindmod(&display_info);
        GRdpmode = 0;
	MOD_ENV=  *md_env;

        for( k=0; k<me->num_solid; k=k+1)
        {
           ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat1,k,&TMP),
                    targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );

	   if(!stat1) goto wrapup;

           stat = ci$send( msg = message  NDmacro.ACunconsume(&msg,""),
              		   targetid = TMP.objid,
	      		   targetos = TMP.osnum );

           as$status( sts = stat );

     	   ci$send( msg      = message NDmacro.ACreturn_foot(	
						&msg ,
						"",
						&GCV, 
						&mat_type, 
					        matrix ),
	            targetid = TMP.objid,
	      	    targetos = TMP.osnum );

	   ci$send(msg      = message GRgraphics.GRdisplay(
							&msg,
							&matrix_type,
                                			matrix,
	                        			&GRdpmode,
							&display_info),
	           targetid = GCV.objid,
		   targetos = GCV.osnum);


        }
wrapup:
        ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
	         targetid = CI_MACRO_ID.objid,
	         targetos = CI_MACRO_ID.osnum,
                 mode     = WRT_message );
 return(1);
}
/*==========================================================================*/
int ssize;
short set,props;
struct GRid		*list;

construct_comp()
{

  struct GRsymbology  symbology; /* For TR 179800627 */

  SOL.objid = NULL_OBJID;
  SOL.osnum = MOD_ENV.md_id.osnum;
  components = NULL ;

  kk = me->num_solid;

 for( k=0; k<me->num_solid; k=k+1) {

     status = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
							&stat, k, &S[k] ),
              targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
     as$status(  );

#ifdef DEBUG
	write("--> boolean.construct comp\n");
	om$get_classname ( objid = S[k].objid,
			   osnum = S[k].osnum,
                          classname = txt  );
 	write("template S[",k,"]:",S[k].objid, " class:", txt, '\n');
#endif


     status = ci$send( msg = message  
	      NDmacro.ACconsume(&msg,"",1,&wrk_GRid,&MOD_ENV),
              targetid = S[k].objid,
	      targetos = S[k].osnum );
     as$status(  );



    { /* start of ci_macro group read */

     om$get_classname ( objid= wrk_GRid.objid,
			osnum = wrk_GRid.osnum,
                        classname = txt  );

     if( om$is_ancestry_valid( superclassname = "ci_macro",
			      subclassname = txt ) == OM_S_SUCCESS )
      {
      status =om$get_channel_count( objid = wrk_GRid.objid,
				osnum = wrk_GRid.osnum,
				p_chanselect = &AC_mto_graf_chns,
				count = &ssize );
      as$status( action = RET_STATUS );
      if(ssize)
        {
        list = (struct GRid *)om$malloc(size = (ssize) * sizeof(struct GRid));
        ACread(wrk_GRid, &AC_mto_graf_chns, list, ssize);
        set = 0;
        props = GR_RIGID_RELATIONSHIP;
        for(i=0;i<ssize;i=i+1) 
         {
         SOLOBJ[k+i] = list[i].objid;
         status = ci$send(msg = message GRgraphics.GRchgprops(&msg,&set,&props),
		   targetid = list[i].objid,
		   targetos = list[i].osnum);
         as$status();
         }
        kk = ssize + 1;
        om$dealloc(ptr = list);
        status = ci$send(msg = message Root.wild_disconnect(AC_mto_graf_chns),
		   targetid = wrk_GRid.objid,
		   targetos = wrk_GRid.osnum);
        as$status();
        break; /* exit get solid loop */
        }
       else return(0);
      }
     else
      {
        SOLOBJ[k] = wrk_GRid.objid;

#ifdef DEBUG
	VD_ShowObj( & wrk_GRid );
#endif
      }
    } /* end of ci_macro group read */

  }/* end loop to retrieve solid */

/**********************    boolean operation    *****************************/



  mat_type = MAIDMX;
  MAidmx(&msg,matrix);

  init_cnst_list();
  get_symb();

  dis.color 		= cnst_list.color;
  dis.weight 		= cnst_list.weight;
  dis.style 		= cnst_list.style;
  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= FALSE;
  cst.level		= cnst_list.level;
  cst.geometry  	= NULL;
  cst.class_attr	= NULL;
  cst.name		= NULL;

/* For TR 179800627 */

GRfindmod(&display_info);
stat = ci$send( msg = message EMSslboolean.GRconstruct(&cst),
           targetid = SOL.objid, 
	   targetos = SOL.osnum );
 as$status( sts = stat );


num_par_sol = kk - 1;

 option =  EMSsfbool_opt_retryDisjoint | EMSsfbool_opt_noredraw | EMSsfbool_opt_doublecheck |
           EMSsfbool_opt_HandleStop;

 if( num_par_sol > 1 ){
	bool_type =  EMSbool_union;
	TrueSol[0] = SOLOBJ[1];
	for(k=1;k<num_par_sol;k=k+1)
		make_union( &msg, &TrueSol[0], &SOLOBJ[k+1], 
				       option, bool_type, &cst );
	num_true_sol = 1;

 }
 else{
	num_true_sol = num_par_sol;
	TrueSol[0] = SOLOBJ[1];
 }


  RES1 = NULL_OBJID;
  RES2 = NULL_OBJID;
  PRES2 = &RES2;


#ifdef DEBUG
	printf("_Pathway = %d, _pathway_trim = %d, _pathway_orient = %d\n", _Pathway, _pathway_trim, _pathway_orient );
	write("before  EMSslboolean.EMboolean \n");
	write(" first sol = ",SOLOBJ[0],"\n");
	for(k=0;k<num_true_sol;k=k+1)
		write("Truesol[",k,"] = ",TrueSol[k],"\n");

#endif

  if( me->booltype == EMSbool_intersect ){
 	option =  EMSsfbool_opt_noredraw | EMSsfbool_opt_HandleStop;
  }

  sav_pathway_trim   = _pathway_trim;
  sav_pathway_orient = _pathway_orient;
  _pathway_trim   = 1;
  _pathway_orient = 1;

  stat = ci$send( msg = message EMSslboolean.EMboolean( 
						 &msg, 
						 &mat_type,
						 matrix,
           					 SOLOBJ[0],
						 num_true_sol,
						 TrueSol,
           					 &cst,
						 me->booltype,
						 option,
						 status_str,
						 NULL,
						 NULL,
						 NULL,
						 NULL ),
           targetid = SOL.objid,
	   targetos = SOL.osnum  );

/* Added for TR 179800627 */

        stat = gr$display_object(object_id = &SOL,
                        md_env = &MOD_ENV ,
                        mode = GRbe);

/* the problem is with the symbology, so put the active symbology-tr179800627*/

symbology.display_attr = dis;
symbology.level = cnst_list.level;

gr$put_symbology ( object_id = &SOL,
		symb = &symbology);

/*****************************************/
  _pathway_trim   = sav_pathway_trim;
  _pathway_orient = sav_pathway_orient;

#ifdef DEBUG
	write("after  EMSslboolean.EMboolean status:", stat,"\n");
	write("after  EMSslboolean.EMboolean msg:", msg,"\n");
	write("after  EMSslboolean.EMboolean SOL = ",SOL.objid,SOL.osnum,"\n");
	
#endif
   
    if( !(msg&stat&1))
    {
#ifdef	DEBUG
     	write(" boolean failed\n");
#endif
        goto endend;
    }
    else{
	/*
	 * Check if the components are solids...
	 */
#ifdef	DEBUG
	VD_ShowObj( &SOL );
#endif
	/*
	 * Check if the object has any components defined.
	 * If not delete the object for safety reasons.
	 */
	VD_getComponents( &msg, &SOL, &MOD_ENV, &count, &components );

	if( !(msg& stat & 1) || ( count == 0 )){
		if( components ) free( components );
		components = NULL ;
		goto endend ;
	}

	/* add the compress tree */
   	stat = ci$send(msg = message EMSdpr.EMmake_primitive1(
				&msg,
				&MOD_ENV,
                                GRid_list ),
	        targetid = SOL.objid,
		targetos = SOL.osnum);
    	if(  !(stat&msg&1) ) {
#ifdef	DEBUG
		write("EMSdpr.EMmake_primitive1 failed");
#endif
		goto endend;
        }


/* at place time undisplay the parents */

    if( placetime == 1 ){

  	GRfindmod(&display_info);
  	GRdpmode = GRbeheo;

 	for( k=0; k<me->num_solid; k=k+1) {

     		ci$send( msg      = message NDmacro.ACreturn_foot(	
						&msg ,
						"",
						&wrk_GRid, 
						&mat_type, 
					        matrix ),
	      	 	 targetid = S[k].objid,
	      		 targetos = S[k].osnum );

	 	ci$send(msg      = message GRgraphics.GRdisplay(
							&msg,
							&mat_type,
                                			matrix,
	                        			&GRdpmode,
							&display_info),
	        	targetid = wrk_GRid.objid,
		 	targetos = wrk_GRid.osnum);
	}
    }
    /* end of undisplay */

    SOL.objid = GRid_list[0].objid;    
    SOL.osnum = GRid_list[0].osnum;    

    if( components ) free( components );
    components = NULL ;

    return;
  } 

endend:

    GRdpmode = 0;

    for( k=0; k<me->num_solid; k=k+1){

     		stat = ci$send( msg = message  NDmacro.ACunconsume(&msg,""),
              			targetid = S[k].objid,
	      			targetos = S[k].osnum );
     		as$status( sts = stat );

     		ci$send( msg      = message NDmacro.ACreturn_foot(	
						&msg ,
						"",
						&wrk_GRid, 
						&mat_type, 
					        matrix ),
	      		 targetid = S[k].objid,
	      		 targetos = S[k].osnum );

	   	ci$send(msg      = message GRgraphics.GRdisplay(
							&msg,
							&mat_type,
                                			matrix,
	                        			&GRdpmode,
							&display_info),
	           	targetid = wrk_GRid.objid,
		   	targetos = wrk_GRid.osnum);

     }

     if( SOL.objid != NULL_OBJID ){

	stat =
	ci$send(msg = message Root.delete(0),
	        targetid = SOL.objid,
		targetos = SOL.osnum);
     }

     if( components ) free( components );
     components = NULL ;

     SOL.objid = NULL_OBJID;

#ifdef	DEBUG
     write(" SOL set to NULL_OBJID ");
#endif
}

/*==========================================================================*/

#ifdef CLOCK
int clk;
my_clock()
{
	int tmp1, tmp2;
	tmp1 = clock();
	tmp2 = (clk - tmp1)/10000;
	clk = tmp1;
	write(clk/10000,"   ");
	return -tmp2;
}
#endif

/*==========================================================================*/
make_union( msg, sol1, sol2, option, bool_type, cst)

IGRlong			*msg ;
GRobj			*sol1;
GRobj			*sol2;
unsigned short  	option;
enum EMSbooltype  	bool_type;
struct GRvg_construct   *cst;

{

IGRint			num_sol;
char			status_str[54];
struct	GRid		SOL, PRIM;
IGRint			stat;
IGRshort		mat_type;
IGRdouble		matrix[16];


  num_sol = 1;

#ifdef DEBUG
	write("before  EMSslboolean.EMboolean \n");
#endif

  SOL.objid = NULL_OBJID;
  SOL.osnum = cst->env_info->md_id.osnum; 

  stat = ci$send( msg = message EMSslboolean.EMboolean( 
					msg,
					&cst->env_info->md_env.matrix_type,
					cst->env_info->md_env.matrix,
           				*sol1,
					num_sol,
					sol2,
           				cst,
					bool_type,
					option,
					status_str,
					NULL,
					NULL,
					NULL,
					NULL ),
           targetid = SOL.objid,
	   targetos = SOL.osnum  );

/* Added for TR 179800627 */
        stat = gr$display_object(object_id = &SOL,
                        md_env = &MOD_ENV ,
                        mode = GRbe);
/********************************************************/

#ifdef DEBUG
	write("in union after  EMSslboolean.EMboolean  msg:", *msg,"\n");
	write("in union SOL =",SOL.objid,SOL.osnum,"\n");
#endif

    as$status( sts = stat );

   if( !(*msg&stat&1) ){
#ifdef	DEBUG
     	write(" function union boolean failed\n");
#endif
	*msg = MSFAIL;
	return;
    }

    *sol1 = SOL.objid;
    *msg  = MSSUCC;
    return;

}
/*==========================================================================*/

__DBGpr_com(txt)

IGRchar  	*txt;
{
	printf(txt);
	printf("\n");
}
/*========================================================================*/

__DBGpr_vec(txt, val )

IGRchar  	*txt;
IGRdouble	val[];

{
	printf(txt);
	printf(" %f, %f, %f \n",val[0],val[1],val[2]);
}
/*========================================================================*/

__DBGpr_obj( txt, id )

IGRchar		*txt;
GRobj		*id;

{
	printf(txt);
	printf(" objid = %d \n",*id);
}



