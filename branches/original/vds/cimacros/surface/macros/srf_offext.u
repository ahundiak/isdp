/* $Id: srf_offext.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / srf_offext.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: srf_offext.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.1 - PPM macro library - (alc)

   History :
   92/07/09	Conversion to 2.0
   92/11/05	Use function extent_surface_geom(), and message 
		EMSsurface.EMoffset()
   94/09/25	adz:	Modif for EMoffset (negative offset values ).
 */
   

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "AS_status.h"
#include "EMSssprops.h"
#include "bserr.h"

extern printf();
extern ASsuper_construct();
extern IGRlong extent_surface_geom() ;
extern BSfreesf() ;

IGRchar 		*temp_names[3], *feet_names[1];
IGRint			temp_types[3];

IGRshort	 	mat_type, action, mask;

unsigned IGRchar	props;

IGRint			i, j, k;
IGRlong			stat, msg;
 
IGRdouble 	 	matrix[16];

GRobj 			ci_mac_def1;

struct GRid		GCV, CUV, EXT_SURF, GRid_list[1], CI_MACRO_ID;
struct GRmd_env		MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct IGRbsp_surface   *sf1, *sf2 ;
struct ret_struct	temp1_rts, temp2_rts, expr;

IGRlong			ext_val;
IGRdouble		offs_val;

IGRdouble		v1[3], v2[3], vn[3];
IGRdouble		p0[3], p1[3], p2[3], p3[3];
IGRdouble		p01[3], p12[3], p23[3], p30[3];
IGRdouble		p03[3], p10[3], p21[3], p32[3];


extern int 	init_cnst_list();
extern IGRboolean 	BSxln();
extern int 		BScrossp(),
			BSnorvec();

init()
{
  feet_names[0] = "ressur";
}

main ()
{
  temp_names[0]  = "extension";  
  temp_names[1]  = "offs";  
  temp_names[2]  = "surf";  

  temp_types[0]  = parameter_generic | double_type;
  temp_types[1]  = parameter_generic | double_type;
  temp_types[2]  = other_generic;

  ci_mac_def1 = NULL_OBJID;
  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &msg, 	
		name              = "srf_offext",
              	temp_num          = 3, 		
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}
/* ========================================================================= */

place ()
{

  construct_pjs();

  if( GRid_list[0].objid == NULL_OBJID ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &msg, 1,GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}
/* ========================================================================= */

compute ()
{
  construct_pjs();

  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &msg, 1,GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  return(1);
}

construct_pjs()
{

  int 		option, num_nooffsetsfs ;
  GRobjid	*nooffsetsfs ;
  char 		*status_str  ;	/* new arguments for EMoffset() in 2.1 */
  IGRboolean    is_natural_normal;

  #ifdef DEBUG
  write("Begin of macro srf_offext.u \n") ;
  #endif

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= NULL;
  cst.class_attr	= 0;
  cst.name		= 0;


  stat = ci$send( msg = message  ACcpx.ACfind_temp_struct(&msg,"extension",
						   &expr,&MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  as$status( sts= stat );
  ext_val = expr.var.root_pm_st.value;

  stat = ci$send( msg = message  ACcpx.ACfind_temp_struct(&msg,"offs",
						   &expr,&MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
  as$status( sts= stat );
  offs_val = expr.var.root_pm_st.value;

  stat = ci$send( msg = message  ACcpx.ACfind_temp_obj(&msg,"surf",&GCV),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  as$status( sts= stat );

  stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&msg,
						"",
						&CUV, 
						&mat_type, 
					        matrix ),
	   targetid = GCV.objid,
	   targetos = GCV.osnum );
  as$status( sts= stat );

  if(!(stat&msg&1)){
		status("Bad surface template") ;
		#ifdef DEBUG
		write("Bad surface template \n") ;
		#endif
		return;
  	}

/*
     ci$send( msg = message ASnode.ASreturn_go( &CUV, &mat_type, matrix ),
	      targetid = GCV.objid,
	      targetos = GCV.osnum );
*/

  stat = ci$send( msg	    = message GRvg.GRgenabsg(&msg,
					&mat_type,
					matrix,
					(char *)&sf1) ,
	     targetid = CUV.objid,
	     targetos = CUV.osnum );
  as$status( sts= stat );

/*
  BSsfxttpt(    ext,
		sf1,
		temp1_rts.var.point_st.pt,
		temp2_rts.var.point_st.pt,
		&sf2,
		&msg );
 */


  sf2 = NULL;
  stat = extent_surface_geom( sf1, ext_val, &sf2 );
  if( stat != 1 ) {
	as$status(sts = stat) ; goto wrapup ;
	}

  GRid_list[0].objid = NULL_OBJID;
  GRid_list[0].osnum = MOD_ENV.md_id.osnum;


  cst.geometry   = (char *)sf2;
  EXT_SURF.objid = NULL_OBJID;
  EXT_SURF.osnum = MOD_ENV.md_id.osnum;
  stat = ci$send( msg = message EMSgenbs.GRconstruct(&cst), 
           targetid = EXT_SURF.objid,
           targetos = EXT_SURF.osnum );
  as$status( sts= stat );

  if( ! (stat & 1) ) {
	#ifdef DEBUG
	write("EMSgenbs.GRconstruct() failed \n") ;
	#endif	
	goto wrapup ;
	}

  cst.geometry   = NULL;

  #ifdef DEBUG
  write("Before call to offset surface \n") ;
  #endif

  stat = ci$send( msg      = message  EMSsubbs.EMget_props( &msg,&props),
           targetid = EXT_SURF.objid,
           targetos = EXT_SURF.osnum );
  if( !(msg&stat&1) ) return;
  as$status( sts= stat );

   #ifdef DEBUG
   write("offs_val =",offs_val,"\n");
   #endif

   if( offs_val < 0.0 ){
           is_natural_normal = FALSE ;
           offs_val = fabs(offs_val);
   }
   else    is_natural_normal = TRUE;

   #ifdef DEBUG
   write("is_natural_normal =",is_natural_normal,"\n");
   #endif

   if( props & EMSIS_NRML_REVERSED ) {
      if( is_natural_normal )
              is_natural_normal = FALSE;
      else    is_natural_normal = TRUE;
   }

   option = 1 ;
   num_nooffsetsfs = 0 ;
   nooffsetsfs     = NULL ;
   status_str      = NULL ;	/* EMS 2.1 */
   stat = ci$send( msg      = message EMSsurface.EMoffset(
					&msg,
					option,
                           		&MOD_ENV.md_env.matrix_type,
                           		MOD_ENV.md_env.matrix,
					&cst,
					is_natural_normal,
					offs_val,
                                        0,
                                        NULL,
                                        NULL,
					num_nooffsetsfs,
					nooffsetsfs,
					status_str,
					&GRid_list[0].objid,
					NULL ),
            targetid = EXT_SURF.objid,
            targetos = EXT_SURF.osnum) ;

  as$status( sts= stat );

  stat = ci$send( msg = message GRgraphics.GRdelete(&msg, &MOD_ENV), 
           targetid = EXT_SURF.objid,
           targetos = EXT_SURF.osnum );
  as$status( sts= stat );

  
wrapup : 
	if( sf2 != NULL ){ BSfreesf(&msg,sf2); }
	return stat ;
}


