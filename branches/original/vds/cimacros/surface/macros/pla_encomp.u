/* $Id: pla_encomp.u,v 1.2 2001/01/19 21:21:04 hans Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / pla_encomp.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: pla_encomp.u,v $
 *	Revision 1.2  2001/01/19 21:21:04  hans
 *	SP16 modifications
 *	
# Revision 1.3  2000/11/26  17:06:26  pinnacle
# Replaced: vds/cimacros/surface/macros/pla_encomp.u for:  by jpulapar for Service Pack
#
# Revision 1.2  2000/10/24  21:10:38  pinnacle
# Replaced: vds/cimacros/surface/macros/pla_encomp.u for:  by jpulapar for Service Pack
#
# Revision 1.1  2000/10/24  20:54:36  pinnacle
# Created: vds/cimacros/surface/macros/pla_encomp.u by jpulapar for Service Pack
#
 # Revision 1.1  1998/04/29  16:27:20  pinnacle
 # VDS 2.5.1
 #
 # Revision 1.1  1997/05/08  13:20:44  pinnacle
 # New project VDS 250
 #
 # Revision 1.1  1996/07/19  20:33:52  pinnacle
 # Create VDS 241 project
 #
 # Revision 1.1  1994/11/14  22:42:32  pinnacle
 # Create vds.240 from vds.232
 #
 # Revision 1.1  1994/11/08  16:07:00  pinnacle
 # create vds.232
 #
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
  VDS 2.0 - PPM macro library - 92/07/09 (alc)
*/

/*
  File name :		pla_encomp.u
  Revision date :		92/05/14
  
  91/10/18	JLL	Design
  92/05/14	ALC	Compute an orientation point for the 
  encompassing plane in order to define deterministly a 
  normal (e.g. to ensure that beams won't switch sides 
  in a re-compute - TR 91W1760  C)
  
*/


#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "EMSmsgdef.h"
#include "emsmapdef.h"
#include "emsimpdef.h"
#include "growner.h"
#include "bserr.h"
#include "AS_status.h"


IGRchar		   	   *temp_names[1], *feet_names[1] ;
IGRint			   temp_types[1] ;
GRobj 			   ci_mac_def1 ;
struct GRid		   CI_MACRO_ID ;
struct GRmd_env            MOD_ENV ;

struct GRid		   PLANE     ;
IGRlong		   	   msg, stat ;

extern IGRint 		init_cnst_list()    ;
extern			ASsuper_construct() ;
extern			printf()   ;
extern char		*malloc()  ;
extern			free()     ;
extern			BSmkvec()  ;
extern IGRboolean 	BScrossp(), BSnorvec() ;
extern int VDplane_crv_pro_v();
extern long VD_bulkDeleteByGRids();
extern int VD_get_geometry();
extern void BSlsqptlnpl();

//#define DEBUG 1
/* ========================================================================= */


get_orientation_pt(curve_ptr, orientation_pt)
  struct GRlc_info	*curve_ptr     ; /* I */
IGRpoint		orientation_pt ; /* O */
/*
  Description :
  - 92/05/14 -
  Given a closed planar curve, this function computes a point which 
  indicates the orientation of the encompassing plane.  More precisely,
  the point is computed so that the curve is positively oriented according
  to the normal defined from the plane to this point.
  
  Algorithm :
  
  First, we build a list of points from the poles of the curve (note : the 
  curve may be also a composite one).  If the curve is a rational one, the 
  poles are divided by their weight.
  Secondly, we get the center of gravity of our list.
  Then, the area delimited by the linestring (defined by our list) is 
  computed by a sum of cross products.  Note that the area is an oriented
  one which allows us to obtain a point defining the encompassing plane
  orientation. 	
*/
{
  IGRpoint		center ;	/* barycenter of linestring */
  IGRvector		area, partial_area, vector1, vector2 ;
  struct IGRbsp_curve 	*curve_geom  ;	
  IGRdouble		*list     ; 	/* linestring of poles */
  IGRlong			num_bytes ;
  IGRlong 		msg, stat ;
  BSrc			bsrc ;
  IGRint			i, j, taille ;
  IGRint			rc_func   ;
  
#ifdef DEBUG
  printf("	---> Call to get_orientation_pt() \n") ;
#endif
  
  curve_geom = NULL ;
  list       = NULL ;
  
  /*
    1) Get points of linestring
  */
  
  stat = ci$send(	msg = message GRvg.GRgetsize(
						     &msg,
						     &curve_ptr->module_info.md_env.matrix_type,
						     curve_ptr->module_info.md_env.matrix,
						     &num_bytes),
			targetid = curve_ptr->located_obj.objid,
			targetos = curve_ptr->located_obj.osnum) ;
  as$status(sts = stat) ; 
  if (!(stat & msg & 1)) { rc_func = OM_E_ABORT ; goto wrapup ; }
  
  curve_geom = (struct IGRbsp_curve *) malloc(num_bytes) ;
  if (curve_geom ==  NULL) { rc_func = OM_E_ABORT ; goto wrapup ; }
  
  stat = ci$send( msg = message GRvg.GRgetgeom(
					       &msg,
					       &curve_ptr->module_info.md_env.matrix_type,
					       curve_ptr->module_info.md_env.matrix,
					       (IGRchar *)curve_geom),
		  targetid = curve_ptr->located_obj.objid,
		  targetos = curve_ptr->located_obj.osnum) ;
  as$status(sts = stat) ; 
  if (!(stat & msg & 1)) { rc_func = OM_E_ABORT ; goto wrapup ; }
  
  taille = curve_geom->num_poles * 3 * sizeof(IGRdouble) ;
  list   = (IGRdouble *) malloc(taille) ;
  if (list ==  NULL) { rc_func = OM_E_ABORT ; goto wrapup ; }
  
  if (! curve_geom->rational) {
    memcpy(	(char *) list, (char *) curve_geom->poles, (int) taille) ;
  }
  else {
    /* Rational B-spline curve */
#ifdef DEBUG
    printf("The given curve is a rational one \n") ;
#endif
    for (i = 0 ; i < curve_geom->num_poles ; i = i+1) {
      for (j = 0 ; j < 3 ; j = j+1) {
	list[3*i+j] = curve_geom->poles[3*i+j] / curve_geom->weights[i] ;
      }
    }
  } /* else */
  
  /*
    2) Compute barycenter of linestring
  */
  
  center[0] = 0 ; center[1] = 0 ; center[2] = 0 ;
  for (i = 0 ; i < curve_geom->num_poles ; i = i+1) {
    for (j = 0 ; j < 3 ; j = j+1) {
      center[j] = center[j] + list[3*i+j] ;
    }
  }
  for (j = 0 ; j < 3 ; j = j+1) {
    center[j] = center[j] / curve_geom->num_poles ;
  }
  
  /*
    3) Compute oriented area, and find an orientation point
  */
  
#ifdef DEBUG
  printf("num poles of curve is %d \n", curve_geom->num_poles) ;
  printf("First pole is %f/%f/%f \n",
	 curve_geom->poles[0], curve_geom->poles[1], curve_geom->poles[2]) ;
  i = (curve_geom->num_poles - 1) * 3 ;
  printf("Last  pole is %f/%f/%f \n",
	 curve_geom->poles[i], curve_geom->poles[i+1], curve_geom->poles[i+2]) ;
  printf("Center point is %f/%f/%f \n", center[0], center[1], center[2]) ;
#endif
  
  area[0] = 0 ; area[1] = 0 ; area[2] = 0 ;
  for (i = 0 ; i < curve_geom->num_poles-2 ; i = i+1) {
    
    /* 
       Start from the first pole to the last but one pole 
    */
    
    BSmkvec (&bsrc, vector1, center, &list[3*i])     ;
    if (bsrc != BSSUCC) { rc_func = OM_E_ABORT ; goto wrapup ; }
    BSmkvec (&bsrc, vector2, center, &list[3*(i+1)]) ;
    if (bsrc != BSSUCC) { rc_func = OM_E_ABORT ; goto wrapup ; }
    
    BScrossp(&bsrc, vector1, vector2, partial_area) ;
    if (bsrc != BSSUCC) { rc_func = OM_E_ABORT ; goto wrapup ; }
    
    for (j = 0 ; j < 3 ; j = j+1) {
      area[j] = area[j] + partial_area[j] ;
    }
  } /* for */
  
  BSnorvec(&bsrc, area) ;
  if (bsrc != BSSUCC) { rc_func = OM_E_ABORT ; goto wrapup ; }
  
  for (j = 0 ; j < 3 ; j = j+1) {
    orientation_pt[j] = center[j] + area[j] ;
  }
  
  rc_func = OM_S_SUCCESS ; /* success */
  
  wrapup :
    
    if (curve_geom != NULL)	free(curve_geom)  ;
  if (list != NULL)	free(list) ;
  
  return rc_func ;
} /* get_orientation_pt() */


/* ====================================================================== */
/*==========================================================================*/


construct_plane()
{
  IGRint		 retStat,code;
  struct GRprops         GRprops ;
  struct GRid	         TMP ;
  struct GRlc_info       ROOT_CURVE ,CURVE;
  struct IGRdisplay      dis ;
  struct GRvg_construct  cst ;
  struct GRobj_env       prjCurve;
  IGRboolean             prjFlag;
  IGRboolean 		 test_degeneracy, construct_loopset ;
  IGRpoint		 orientation_pt , pt;
  IGRvector              vec;
  struct IGRbsp_curve    *curveGeom ;
  IGRdouble              err;
  BSrc			 rc ;
  
  PLANE.objid = NULL_OBJID;
  PLANE.osnum = MOD_ENV.md_id.osnum;
  curveGeom = NULL;
  prjFlag   = 0;
  /*
    Retrieve the curve boundary
  */
  
  stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&msg,0,&TMP),
		  targetid = CI_MACRO_ID.objid,
		  targetos = CI_MACRO_ID.osnum );
  
  if( !(msg&stat&1) ) return(OM_E_ABORT) ;
  
  stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
							   &msg,
							   "",
							   &CURVE.located_obj, 
							   &CURVE.module_info.md_env.matrix_type, 
							   CURVE.module_info.md_env.matrix ),
		  targetid = TMP.objid,
		  targetos = TMP.osnum ) ; as$status(sts = stat) ;
  
  if( !(msg&stat&1) ) return(OM_E_ABORT) ;
  
  CURVE.module_info.md_id.osnum = CURVE.located_obj.osnum;
  
  /*
    Set the construct list
  */
  
  init_cnst_list();
  get_symb();
  
  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;
  
  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info	= &MOD_ENV;
  cst.newflag		= FALSE;
  cst.level		= cnst_list.level;
  cst.geometry	= NULL;
  cst.class_attr	= NULL;
  cst.name		= NULL;
  /*
    Check if the given curve is planar and physically closed
  */
  
  stat = ci$send( msg = message GRvg.GRgeomprops( 
						 &msg,
						 &CURVE.module_info.md_env.matrix_type, 
						 CURVE.module_info.md_env.matrix,
						 &GRprops ),
		  targetid = CURVE.located_obj.objid,
		  targetos = CURVE.located_obj.osnum ) ; as$status(sts = stat) ;
  if( !(msg&stat&1) ) return(OM_E_ABORT) ;
  
  
#ifdef DEBUG
  write("GRprops.planar =",GRprops.planar,"\n");
  write("GRprops.phy_closed =",GRprops.phy_closed,"\n");
#endif
  // get the bspline geometry for the input curve
  VD_get_geometry(&msg,&CURVE.located_obj,&CURVE.module_info,(IGRchar **)&curveGeom);
  if((!(msg&1)) || (curveGeom == NULL))
    {
#ifdef DEBUG
      printf("\n VD_get_geometry failed [%d,%d]\n",CURVE.located_obj.objid,CURVE.located_obj.osnum);
#endif
      return(OM_E_ABORT) ;
    }

  // get the point and vector defining the average plane
  BSlsqptlnpl(curveGeom->num_poles,curveGeom->poles,curveGeom->weights,3,&code,pt,vec,&err,&rc);
  if (rc != BSSUCC)
    {
#ifdef DEBUG
      printf("\n BSlsqptlnpl function failed \n");
#endif
      return(OM_E_ABORT) ;
    } 
#ifdef DEBUG
  printf("\n BSP phy_closed[%d] planar[%d] \n",curveGeom->phy_closed,curveGeom->planar);
  printf("\n GRprops phy_closed[%d] planar[%d] \n",GRprops.phy_closed,GRprops.planar);
#endif
  /*
    if (! GRprops.phy_closed){
    status("macro pla_encomp : curve is not physically closed") ; 
    return(OM_E_ABORT) ;
    }
  */
  if(!curveGeom->phy_closed){
    status("macro pla_encomp : curve is not physically closed") ;
    return(OM_E_ABORT) ;
  }
  
  /* if (! GRprops.planar)  */
  if(!curveGeom->planar){ 
    /*
      status("macro pla_encomp : curve is not planar") ; 
      return(OM_E_ABORT) ;
    */
    prjCurve.obj_id.objid = NULL_OBJID;
    retStat = VDplane_crv_pro_v(CURVE.located_obj,CURVE.module_info,curveGeom,pt,vec,vec,&cst,&prjCurve);
    if((!(retStat&1)) || (prjCurve.obj_id.objid == NULL_OBJID))
      {
#ifdef DEBUG
	printf("\n VDprojectedCurve failed for[%d,%d]\n",CURVE.located_obj.objid,CURVE.located_obj.osnum);
#endif
	status("macro pla_encomp : curve is not planar") ; 
	return(OM_E_ABORT) ;
      }
    CURVE.located_obj = prjCurve.obj_id;
    CURVE.module_info = prjCurve.mod_env;
    prjFlag           = 1;
  }
  ROOT_CURVE = CURVE;
  /*
    Get a point to orientate the plane, so that the curve is positively
    oriented according to the natural normal of the plane.
  */
  
  stat = get_orientation_pt(&ROOT_CURVE, orientation_pt) ;
  if (stat != OM_S_SUCCESS) {
#ifdef DEBUG
    printf("macro pla_encomp : get_orientation_pt() failed \n") ;
#endif
    return(OM_E_ABORT) ;
  }
  
  /*
    Compute the encompassing plane, oriented thanks to the orientation pt
  */
  
  test_degeneracy 	= TRUE ;
  construct_loopset 	= TRUE ;
  
  stat = ci$send(	msg = message EMSplane.EMplane_of_curve(
								&msg,
								&cst,
								&ROOT_CURVE,
								NULL,		/* ptr to geometry   */
								NULL,		/* ptr to curve_type */
								test_degeneracy,
								construct_loopset,
								orientation_pt,	/* deterministic !   */
								NULL),
			targetid = PLANE.objid,
			targetos = PLANE.osnum) ; as$status(sts = stat) ;
  
  if ( !(stat & 1) || (msg != EMS_S_Success) ) {
#ifdef DEBUG
    printf("macro pla_encomp : EMSplane.EMplane_of_curve() \n") ;
#endif
    PLANE.objid = NULL_OBJID ; return(OM_E_ABORT) ;
  }
  if( curveGeom != NULL ) free(curveGeom); curveGeom = NULL;
  if(prjFlag) VD_bulkDeleteByGRids(&MOD_ENV,1,&prjCurve.obj_id); 
  return(OM_S_SUCCESS) ;
} /* construct_plane() */


/* ========================================================================= */
/* the main function is the one implementing the definition creation
   /* ========================================================================= */

main ()
{
  temp_names[0] = "boundy";
  temp_types[0] = curve_generic | conic_generic | line_generic;
  feet_names[0] = "res_surf";
  
  ci_mac_def1 = NULL_OBJID;
  
  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat, 	
		name              = "pla_encomp",
              	temp_num          = 1, 		
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );
}


/* ========================================================================= */


place ()
{
  
  construct_plane();
  if( PLANE.objid == NULL_OBJID ) return(0);
  
  stat = ci$send( msg = message  ci_macro.set_all_extern_feet
		  ( &stat, 1, &PLANE, &MOD_ENV ),
		  targetid = CI_MACRO_ID.objid,
		  targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;
  return(1);
} /* place () */


/* ========================================================================= */


compute ()
{
  
  construct_plane();
  if( PLANE.objid == NULL_OBJID ) return(0);
  
  stat = ci$send( msg = message  ci_macro.set_all_extern_feet
		  ( &stat, 1, &PLANE, &MOD_ENV ),
		  targetid = CI_MACRO_ID.objid,
		  targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;
  return(1);
} /* compute () */




