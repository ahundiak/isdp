/* $Id: srf_merge.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $ *********************************************************************
 *
 * I/VDS
 *
 * File: $VDS/ci_macros/obsolete/macros/srf_merge.u
 *
 * Description:
 *
 * Revision History:
 *	$Log: srf_merge.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/03/03  22:55:42  pinnacle
# Replaced: cimacros/surface/macros/srf_merge.u for:  by impd for vds
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1995/10/26  21:51:42  pinnacle
# Replaced: cimacros/surface/macros/srf_merge.u for:  by azuurhou for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *   07/09/92     alc   VDS 2.0 - PPM macro library - 92/07/09 (alc)
 *   07/27/92	        Get rid of internal data (not used)
 *                      NOTE : this macro is OBSOLETE (not in the PPMmacro 
 *                             library, 1.4.5)
 *	                       Obviously, this macro has never worked...
 *   05/17/94     zhu   1.Changed EMmerge_surfaces message to EFmerge_surface
 *                        Function.
 *                      2.Added the NDdelete() function.
 *                      3.Added ACconsume message in construct_merge()
 *                      4.Added consume expression:  
 *                        consume expression = 1, consume and not display
 *                             lines between two surfaces
 *                        consume expression = 0, nonconsume and display the 
 *                             lines between two surfaces  
 *  10/23/95	adz	The recompute did not delete properly the existing
 *			occurence of the merged surface.
 *
 ****************************************************************************/

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "macro.h"
#include "nddef.h"
#include "AS_status.h"
#include "parametric.h"

#define MAX_TEMP	 33
#define MAX_CHA_TEMP	 7
#define EPSILON		 1.0E-5 

/*
#define DEBUG            1
 */

extern			 ASsuper_construct();

struct   GRid		 CUV, GCV, COMP, 
                         GRid_s[1],
                         saved_GRid[MAX_TEMP], 
                         display_info,
                         CI_MACRO_ID;
struct   GRlc_info	 entries[MAX_TEMP];
struct   GRmd_env        MOD_ENV;      
struct   GRvg_construct  cst;
struct   IGRdisplay	 dis;
struct	 IGRbsp_curve	 *bsp;


GRobj 	 		 CRV, ci_mac_def1;
IGRshort	 	 mat_type;
IGRlong			 EMSgenmsg, stat, msg, msg1;
IGRint      		 num_ent, i, j, k,rotten_one;
IGRint                   GRdpmode;
IGRchar 	 	 *temp_names[MAX_TEMP], 
                         *feet_names[1], 
			 buff[MAX_TEMP*MAX_CHA_TEMP], 
                         txt[40];
IGRdouble                matrix[16];
IGRint			 temp_types[MAX_TEMP];
OMuword	 		 ass_cl, 
   			 ft_cl, 
			 ln_cl, 
     			 pt_cl;

extern   int  		 init_cnst_list(),
                         printf(),
	      		 sprintf();
extern                   GRfindmod();
extern   IGRlong      	 EFmerge_surfaces();

extern int		VDcomment;

/* ========================================================================= */
/* the main function  is the one implementing the definition creation
/* ========================================================================= */

main ()
{

	temp_names[0] = "consume";
	temp_types[0] = parameter_generic | double_type ;

   	for ( k=1; k<MAX_TEMP; k=k+1)
  	{
		j = k * MAX_CHA_TEMP;
		sprintf(&buff[j],"srf%d", k);
		temp_names[k] = &buff[j];
		temp_types[k] = other_generic;
  	}


  	feet_names[0] = "rescrv";
  	ci_mac_def1 = NULL_OBJID;


  	ac$cimacdef( 	cimacdef          = ci_mac_def1,
		prop 		  = ACvariable_template,
		status 	          = &stat,
		name              = "srf_merge",
              	temp_num          = MAX_TEMP, 	
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );

}

/* ========================================================================= */
/* internal function compute()
/* ========================================================================= */
compute ()
{

  	construct_merge();

  	if( COMP.objid == NULL_OBJID ) return(0);

  	ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &COMP, &MOD_ENV ),
	   	targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum );
  	return(1);

}

/* ========================================================================= */
/* internal function place()
/* ========================================================================= */
place ()
{ 
  
  	construct_merge();

  	if( COMP.objid == NULL_OBJID ) return(0);

  	ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &COMP, &MOD_ENV ),
	   	targetid = CI_MACRO_ID.objid,
	   	targetos = CI_MACRO_ID.osnum );
  	return(1);

}

/* ========================================================================= */
/* internal function NDdelete()
/* ========================================================================= */
NDdelete(md_env)
struct GRmd_env *md_env;
{
	IGRint   	GRdpmode;
	struct GRid	display_info;
	IGRshort	matrix_type;
   	IGRdouble	matrix[16];
        struct ret_struct   con_exp;   

#ifdef  DEBUG
  	printf(" md_env->md_id.objid = %d\n", md_env->md_id.objid);
/**
  	if ( md_env->md_id.objid == NULL_OBJID ) goto wrapup;
 **/
#endif  

  	GRfindmod(&display_info);
  	GRdpmode = GRbd;
  	MOD_ENV = *md_env;
   
  	stat = ci$send(msg= message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					             0,OM_K_MAXINT,&num_ent),
	   	 targetid = CI_MACRO_ID.objid,
	   	 targetos = CI_MACRO_ID.osnum);

  	if (!(stat&1)) return;
        
	stat = ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
 	     	        targetid = CI_MACRO_ID.objid,
	     	 	targetos = CI_MACRO_ID.osnum,
             	 	mode     = WRT_message );
        

  	for (i = 1; i < num_ent; i = i +1)
   	 {
     	   msg = ci$send( msg      = message  ACcpx.ACfind_exp_temp_obj(
                                                               &stat,i,&CUV),
 	            targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );
    	   
           if (!(stat&msg&1)) goto wrapup;
    
           stat = ci$send(msg      = message NDmacro.ACunconsume(&msg,""),
                    targetid = CUV.objid,
                    targetos = CUV.osnum );
     	   as$status( sts = stat );

           if (!(stat&msg&1)) goto wrapup;

     	   msg = ci$send (msg      = message NDmacro.ACreturn_foot(
                               &stat,
                               "",
                               &GCV,
                               &matrix_type,
                               matrix ),
                    targetid = CUV.objid,
                    targetos = CUV.osnum );

     	   as$status( sts = msg );
     
	   if(!(stat&msg&1))
       	     {
      	      status( " bad element ");
              return;
             }
           
           stat = ci$send(msg       = message GRgraphics.GRdisplay(
                                &msg,
                                &matrix_type,
                                matrix, 
                                &GRdpmode,
                                &display_info),
                     targetid = GCV.objid,
                     targetos = GCV.osnum );                  

      	   as$status( sts = stat );

         }/* end for */

wrapup:

  return(1);

}
   


/* ========================================================================= */
/* internal function construct_merge()
/* ========================================================================= */
construct_merge()
{
struct	ret_struct      con_exp;     /* consume expression */
IGRboolean		ConsumeRequired;
IGRint                  num;
  	COMP.objid = NULL_OBJID;
  	COMP.osnum = MOD_ENV.md_id.osnum;

  	/* NDget_objects get REAL roots or children of an element
   	 * (connected by channel)
   	 */

	if ( VDcomment ) printf ( "Enter construct_merge : CI_MACRO_ID = [%d,%d]\n", CI_MACRO_ID.osnum, CI_MACRO_ID.objid );
	
  	stat = ci$send(	msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					        0,OM_K_MAXINT,&num_ent),
	   	 	targetid = CI_MACRO_ID.objid,
	   	 	targetos = CI_MACRO_ID.osnum);

	if ( VDcomment ) printf ( "After NDnode.NDget_objects : stat = %d, num_ent = %d\n", stat, num_ent );

        num  = num_ent -1 ;

  	if ( num == 0 || !(stat&1)) return;	// HF: 03/03/98 TR # 179702095

        /* find the con_exp value */
        msg = ci$send( 	msg = message  ACcpx.ACfind_exp_temp_struct(
                                         &stat,0,(char *)&con_exp,&MOD_ENV),
 	      		targetid = CI_MACRO_ID.objid,
	      		targetos = CI_MACRO_ID.osnum );
        as$status(sts = msg);
        if (!(msg & stat & 1 ))
           {
             #ifdef DEBUG
             printf(" Error in ACcpx.ACfind_exp_temp_struct() message \n");
             printf(" bad consume expression \n");
             #endif 
           }

        /* get consume flag from COsrf_merge.u */
        if ((IGRint)con_exp.var.root_pm_st.value == 1)
              ConsumeRequired = TRUE;
        else
              ConsumeRequired = FALSE; 

        #ifdef DEBUG
        	printf("ConsumeRequired in construct= %d\n",ConsumeRequired);
        #endif
 
  	for(k=0; k < num; k=k+1)
 	 {
step0:
          /* from the position in expanded template, to get object(GRid) by 
           * searching complex tmplate. 
           */
          msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
                                         &stat,k+1,&saved_GRid[k]),
 	      		targetid = CI_MACRO_ID.objid,
	      		targetos = CI_MACRO_ID.osnum );

          if( !(stat&msg&1) ) return;

          /* from object(GRid) to get foot(entity): entries[] */
          msg = ci$send( msg      = message NDmacro.ACreturn_foot(	
			&stat,
			"",
				&entries[k].located_obj, 
				&entries[k].module_info.md_env.matrix_type, 
				entries[k].module_info.md_env.matrix ),
	      		targetid = saved_GRid[k].objid,
	      		targetos = saved_GRid[k].osnum );

          if( !(stat&msg&1) )
            {
		strcpy(txt," bad surfaced " );
		strcat(txt,itoa(k));
		status(txt);
		return;
            }

          entries[k].module_info.md_id.osnum = 
			entries[k].located_obj.osnum;

          /*----------------------------
           consume all info from parent
           if ConsumeRequired = TRUE 
           *----------------------------*/
         if( ConsumeRequired == TRUE )
          {
          	msg= ci$send( msg = message NDmacro.ACconsume(
                                                   &stat,
                                                      "",
                                                       1,
                                                    &GCV,
                                                &MOD_ENV),
                        	targetid = saved_GRid[k].objid,
	                	targetos = saved_GRid[k].osnum );
          }
	} /* end for */
        
  	init_cnst_list();
  	get_symb();

  	dis.color	= cnst_list.color;
  	dis.weight	= cnst_list.weight;
  	dis.style	= cnst_list.style;

  	cst.msg		= &msg;
  	cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  	cst.display	= &dis;
  	cst.env_info	= &MOD_ENV;
  	cst.newflag	= 0;
  	cst.level	= cnst_list.level;
  	cst.geometry	= NULL;
  	cst.class_attr	= 0;
  	cst.name	= 0;
 
  	/* -----------------------------------------------------------
         1.  create a surface by merge together all the input surface.
         2.  using EMmerge_surface, the line between two merged surfaces 
             still keep there. 
         3.  using EFmerge_surface, the line between two merged surfaces
             is deleted
	   ------------------------------------------------------------*/
         if( ConsumeRequired == TRUE )
          {
        	stat = EFmerge_surfaces( num, 
                        entries,
                        &cst,
                        &COMP,
                        &msg);
          }
         else
          {
 	 	stat =
		ci$send(msg     = message EMSgenbs.EMmerge_surfaces(
                                          num,
                                          entries,
                                          &cst,
                                          &msg),
			targetid = COMP.objid,
			targetos = COMP.osnum);
          }

  	if(!(msg & stat & 1)) { goto endend ; }

  	/* erase half highlight */
  	GRfindmod(&display_info);
  	GRdpmode = GRbdhe;   
  	stat = ci$send(msg      = message GRgraphics.GRdisplay(
                            &msg,
                            &mat_type,
                            matrix,
                            &GRdpmode,
                            &display_info),
                 targetid = COMP.objid,
                 targetos = COMP.osnum );
        
  	return(1);
endend:
        /* recover consumed surface when merge is failed */
        if (ConsumeRequired == TRUE)
        {
     	GRfindmod(&display_info);
     	GRdpmode = GRhd;
     
     	for ( k=0; k< num; k=k+1)    
    	 {  
      	   stat = ci$send(msg      = message NDmacro.ACunconsume(&msg,""),
                     targetid = saved_GRid[k].objid,
                     targetos = saved_GRid[k].osnum );
           as$status( sts = stat );

           stat = ci$send (msg     = message NDmacro.ACreturn_foot(
                                 &msg,
                                 "",
                                 &GCV,
                                 &mat_type,
                                 matrix ),
                     targetid = saved_GRid[k].objid,
                     targetos = saved_GRid[k].osnum );
           as$status( sts = stat );
     
           stat = ci$send(msg      = message GRgraphics.GRdisplay(
                                &msg,
                                &mat_type,
                                matrix,
                                &GRdpmode,
                                &display_info),
                     targetid = GCV.objid,
                     targetos = GCV.osnum );
         } /* end for */
        } /* end if */
     	COMP.objid = NULL_OBJID; 
     	return(0);     
}
