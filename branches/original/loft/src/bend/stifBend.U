/*
	------------------------------------------------------------------

	File Name :		stifBend.u
	Creation date :		May 26, 1993,
	Author :		JL-LOSCHUTZ
				ISDC Paris

	Description :

		This macro evaluates the inverse bending lines for
		stiffeners.


	History :
	
	Mai 26, 1993  : creation date.
	May  3, 1994  : change printf format in the local CreStifText().
	July 4, 1994  : add NDdelete() function to undisplay the 
		        parent coordinate system.
	july 21, 1994 : modify VLcreStifBen() to have the coordinate system 
			placed at the lower left corner.
	------------------------------------------------------------------
*/

#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "godef.h"
#include "exmacros.h"
#include "macro.h"
#include "nddef.h
#include "macro.h"
#include "msdef.h"
#include "bserr.h"
#include "bstypes.h"
#include "msdef.h"
#include "EMSdpb.h"
#include "growner.h"
#include "igrdp.h"
#include "grmacros.h"
#include "parametric.h"
#include "AS_status.h"

#include "vspart.h"
#include "vsdpb.h"
#include "vssectiondef.h"
#include "vsbeam.h"
#include "vsbeamdef.h"
#include "vsbeammacros.h"
#include "cotxmacros.h"
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "DImacros.h"
#include "EMSssprops.h"

#define MACRO_NAME	"stifBend"
#define MAX_TEMP	3
#define MAX_FEET	102
#define MAX_CHAR_FEET	20


IGRlong			OMsts, stat, msg;

struct 	GRid		CI_MACRO_ID;
struct 	GRvg_construct	cst;
struct 	GRmd_env	MOD_ENV;
struct 	IGRdisplay	dis;
struct 	GRid		GRidList[MAX_FEET];
	IGRint		numFeet;
	IGRdouble	tab[6];
	IGRint		NumEdges;
struct	GRobj_env	Go3DSrf;



extern IGRlong  	VLgetGeometry();
extern IGRint 		init_cnst_list();
extern			ASsuper_construct();
extern IGRdouble	BSdotp();
extern			BSmkvec();
extern void		BSallocsf();
extern IGRboolean	BSfreesf();
extern IGRchar		*memcpy();
extern			ASmake_source_from_env();
extern 			EX_get_modid_given_osnum();
extern	IGRlong		POfndOneFib();

extern IGRdouble	BSdistptpt();
extern IGRboolean	BSruled_sfp();
extern void		BSalloccv();
extern void		BStst_plan();
extern void		BScvtstclsd();
extern IGRboolean	BSnorvec();
extern			POcvInsGreKt();
extern IGRlong		VLcnstOneFib();
extern IGRint		free();
extern			GRdisplay_object();
extern IGRboolean	BSfreecv();
extern IGRdouble	fabs();
extern IGRboolean 	BSconstprcv();
extern void	  	BSsfeval();
extern			GRang_place_text();
extern	char		*strrchr();
extern			DIsplit();
extern IGRint 		MAinvmx();
extern IGRint 		BSsfevaln();

/* ========================================================================= */
main (){

IGRlong			stat;
GRobj 			ci_mac_def1;
IGRchar	 		*temp_names[MAX_TEMP], *feet_names[MAX_FEET];
IGRchar	 		feetBuff[MAX_FEET*MAX_CHAR_FEET];
IGRint			temp_types[MAX_TEMP], j, k;


  temp_names[0] = "ref";
  temp_types[0] = ref_generic;
  temp_names[1] = "BaseSurface";
  temp_types[1] = other_generic;
  temp_names[2] = "srfIndexName";
  temp_types[2] = parameter_generic | text_type;


  feet_names[0] = "Contour";
  feet_names[1] = "Name";

  for (k=2; k<MAX_FEET; k=k+1){
	j = k * MAX_CHAR_FEET;
	sprintf(&feetBuff[j],"foot%d",(k-2));
	feet_names[k] = &feetBuff[j];
   }


  ci_mac_def1   = NULL_OBJID;


  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		prop		  = ACvariable_template,
		status 	          = &stat, 	
		name              = MACRO_NAME,
              	temp_num          = MAX_TEMP, 	
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = MAX_FEET, 	
		extern_feet_names = feet_names );
 
}

/* ========================================================================= */

place ()
{

IGRint	i;

  	constInvBendLines();

	if( GRidList[0].objid == NULL_OBJID ) return(0);

	#ifdef DEBUG
	printf("numFeet = %d\n",numFeet);
	for(i=0;i<numFeet;i=i+1)
	printf("GRidList[%d] = %d,%d\n",i,GRidList[i].objid,GRidList[i].osnum);
	#endif

  	OMsts = ci$send( msg = message  ci_macro.set_all_extern_feet
				(&stat, numFeet, GRidList, &MOD_ENV ),
	   	 targetid = CI_MACRO_ID.objid,
	   	 targetos = CI_MACRO_ID.osnum);
	as$status(sts=OMsts, action = RET_STATUS );

  	return(1);
}


/* ========================================================================= */

compute ()
{
IGRint i;


  	constInvBendLines();

	#ifdef DEBUG
	printf("compute\n");
	printf("numFeet = %d\n",numFeet);
	for(i=0;i<numFeet;i=i+1)
	printf("GRidList[%d] = %d,%d\n",i,GRidList[i].objid,GRidList[i].osnum);
	#endif

	if( GRidList[0].objid == NULL_OBJID ) return(0);

  	ci$send( msg = message  ci_macro.set_all_extern_feet
				(&stat, numFeet, GRidList, &MOD_ENV ),
	   	 targetid = CI_MACRO_ID.objid,
	   	 targetos = CI_MACRO_ID.osnum);

  	return(1);
}

/* ========================================================================= */

constInvBendLines()
{


	IGRlong		rc;
	IGRint		size3Double;
struct  ret_struct	Ref, exprName;
	IGRdouble	vdif[3];
	IGRint		i, k;
struct	GRid		AsTemp;
struct	GRobj_env	GoTemp;
struct  GRobj_env	BaseSrf;
struct	IGRbsp_surface  *srf;

	OMuword		beam_cl, GoTemp_cl;
	IGRdouble	Length, Width;

	IGRdouble	RefMat[16];
	IGRchar		srfName[256];
struct  IGRpolyline      geom;



  for(i=0;i<MAX_FEET;i=i+1){ 
	GRidList[i].objid = NULL_OBJID;
        GRidList[i].osnum = MOD_ENV.md_id.osnum;
  }

  srf = NULL;


  /*------------------------------------------*/
  /* Get the Lower left         referential   */
  /*------------------------------------------*/


  	OMsts = ci$send	(msg      = message ACcpx.ACfind_exp_temp_struct(
				    &stat,0,(IGRchar *)&Ref, &MOD_ENV ),  
     			 targetid = CI_MACRO_ID.objid,
     			 targetos = CI_MACRO_ID.osnum);
	if( !(OMsts&stat&1) ){
		printf("Error in stifBend\n");
		printf("error in ACfind_exp_temp_struct for ref\n");
		return;
	}



     	memcpy ( (IGRchar *)RefMat,(IGRchar *)Ref.var.ref_st.t,
	         (IGRint)  sizeof(IGRmatrix) );


  /*---------------------------------------------------------*/
  /*c retrieve the the footname of the surface I like to use */
  /*---------------------------------------------------------*/

  OMsts = ci$send	(msg      = message ACcpx.ACfind_exp_temp_struct(
				    &stat,2,(IGRchar *)&exprName, &MOD_ENV ),  
     		         targetid = CI_MACRO_ID.objid,
     			 targetos = CI_MACRO_ID.osnum);
  if( !(OMsts&stat&1) ){
	printf("Error in stifBend\n");
	printf("error in ACfind_exp_temp_struct for ref\n");
	return;
  }

  #ifdef DEBUG
  if( exprName.type == text_type ){
	printf("objet text=%s\n",exprName.var.text_st.text_string );
  }
  #endif

  /*---------------------------------------------------------*/
  /*c retrieve the support surface and retrieve the geometry */
  /*---------------------------------------------------------*/

  OMsts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,1,&AsTemp),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
  if( !(OMsts&stat&1) ){
	printf("Error in stifBend\n");
	printf("Error in ACcpx.ACfind_exp_temp_obj for second template\n");
	return;
  }

  OMsts = ci$send( msg      = message NDmacro.ACreturn_foot(	
					&stat ,
					"",
					&GoTemp.obj_id, 
					&GoTemp.mod_env.md_env.matrix_type, 
					GoTemp.mod_env.md_env.matrix ),
	         targetid = AsTemp.objid,
	         targetos = AsTemp.osnum );
  if(!(OMsts&stat&1)){
	printf("Error in stifBend\n");
	printf("Error in NDmacro.ACreturn_foot for second template\n");
	return;
  }

  GoTemp.mod_env.md_id.osnum = GoTemp.obj_id.osnum;
  ex$get_modid(	mod_osnum = GoTemp.mod_env.md_id.osnum,
	        mod_id    = &GoTemp.mod_env.md_id.objid) ;

  #ifdef DEBUG
	printf("AsTemp = %d, %d\n",AsTemp.objid, AsTemp.osnum);
	printf("GoTemp = %d, %d\n",GoTemp.obj_id.objid, GoTemp.obj_id.osnum);
  #endif

  om$get_classid ( classname = "VSbeam",     p_classid = &beam_cl);
  om$get_classid ( osnum     = GoTemp.obj_id.osnum,
		   objid     = GoTemp.obj_id.objid,
		   p_classid = &GoTemp_cl ) ;


  if( om$is_ancestry_valid( superclassid = beam_cl,
			    subclassid	 = GoTemp_cl ) == OM_S_SUCCESS ) {

	/*
	 * Get bottom side of plate because of this object.
	 */
	strcpy(srfName,VS_K_bmGrCmpName);
	strcat(srfName,":");
	strcat(srfName,VS_K_bmBody);
	strcat(srfName,":");
	strcat(srfName,exprName.var.text_st.text_string);
	#ifdef DEBUG
	printf("srfName=%s\n",srfName );
	#endif

	OMsts = ci$send( msg	= message NDmacro.ACreturn_foot(
					&stat,
					srfName,
					&BaseSrf.obj_id,
					&BaseSrf.mod_env.md_env.matrix_type,
					BaseSrf.mod_env.md_env.matrix ),
		       	       targetid = GoTemp.obj_id.objid,
		       	       targetos = GoTemp.obj_id.osnum ) ;

	if( !( OMsts & 1 & stat ) ) {
		printf("Error in stifBend\n");
		printf( "NDmacro.ACreturn_foot\n" ) ;
		goto wrapup ;
	}

  	#ifdef DEBUG
		printf( "BaseSrf.obj_id = %d,%d\n",BaseSrf.obj_id.objid,
						   BaseSrf.obj_id.osnum );
  	#endif




		

  }
  else{
	goto wrapup;
        	
  }






  /*c set up the cst */

  	init_cnst_list();
  	get_symb();


  	dis.color		= cnst_list.color;
  	dis.weight		= cnst_list.weight;
  	dis.style		= cnst_list.style;

  	cst.msg			= &msg;
  	cst.properties		= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  	cst.display		= &dis;
  	cst.env_info		= &MOD_ENV;
  	cst.newflag		= 0;
  	cst.level		= cnst_list.level;
  	cst.geometry		= NULL;
  	cst.class_attr		= 0;
  	cst.name		= 0;

  
   #ifdef DEBUG
   printf("enter VLcreStifBen \n"); 
   #endif

   VLcreStifBen( GoTemp.obj_id, &BaseSrf, &cst, RefMat, 
		  MAX_FEET, &numFeet, GRidList, &msg );
   

  return;


wrapup:

  	GRidList[0].objid = NULL_OBJID;
	return;

}

/*==========================================================================*/

VLcreStifBen( StifObj, SRF, cst, stifMat, maxNumCrvs, numBend, BendCrv, msg )

struct  GRid		StifObj;       /*I stiffener to retrieve the name */
struct 	GRobj_env	*SRF;		/*I support surface on which we
					    evaluate the inverse bend curves */
struct 	GRvg_construct	*cst;		/*I construction list */
	IGRdouble	*stifMat;	/*I matrix that defines where to place
					    the unwraped curves */
	IGRint		maxNumCrvs;	/*I maximun number of feet */
	IGRint		*numBend;	/*O number of curves created */
struct 	GRid		*BendCrv;	/*O the list of resulting curves */
	IGRlong		*msg;		/*O return code */


{

	IGRint			i, j, jM3, k; 
	IGRlong			OMsts;
struct	IGRbsp_surface		*ruledSf;
struct 	IGRbsp_curve		*cv[4], *isoCrv, *CvSol;
	IGRdouble		nvec[6], par1[2], par2[2];
	IGRdouble		len[4], *intPts, *u, *a, *b, *paPtSol;
	IGRint			itCou;
	IGRdouble		ratioCou;
	IGRdouble		org[3], xAxis[3], yAxis[3];
struct	IGRpolyline		poly;
	IGRint			stat;
	IGRint			i1, i2;
	IGRdouble		xAbs, yAbs;
    	IGRboolean		tst_planar;
    	IGRshort		option;
	IGRboolean		displayWanted;
	unsigned char		props ;
	IGRdouble		points[3];
	IGRint			num;


	ruledSf = NULL;
	for(i=0; i<4; i=i+1) cv[i] = NULL;
	isoCrv = NULL;
	CvSol  = NULL;
	intPts = NULL;
	u = NULL;
	a = NULL;
	b = NULL;
	paPtSol = NULL;
	tst_planar = FALSE;
	displayWanted = FALSE;
	/*c retrieve the bs geometry of the base surface on which we 
	    evaluate the inverse curves.( without boundary ) */

  	OMsts = VLgetGeometry( SRF, (IGRboolean) FALSE, NULL_OBJID, 
			       (IGRchar ** )&ruledSf, msg );
  	if( OMsts != MSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in VLgetGeometry for SRF object\n");
		goto wrapup;
  	}

	/*c test if the surface is planar and retrieve the normal of it */

	k = ruledSf->u_num_poles * ruledSf->v_num_poles;

    	BStst_plan(k,ruledSf->poles,ruledSf->weights,&ruledSf->planar,nvec,msg);
	if( !(ruledSf->planar&1) ){

	 	BSsfeval( ruledSf, 0.5, 0.5, 0, org, (BSrc) msg);

	 	cst->display->weight = 3;
	 	poly.num_points = 1;
	 	poly.points = org;
	 	cst->geometry = (char *)&poly;	

     	 	OMsts = ci$send( msg = message GR3dpoint.GRaltconstruct(cst),
	   	 	  targetid = BendCrv[0].objid,
	  	 	  targetos = BendCrv[0].osnum );

	 	*numBend = 1; 
	 	goto endok;
	}
	else{

		/*
		 * evaluate the surface of the surface at paramater (0.5,0.5)
		 */

  		BSsfevaln(ruledSf,0.5,0.5,1,&num,points,nvec,msg);
  		if (*msg != BSSUCC) {
			printf("Error in stifBend\n");
			printf("BSsfevaln Failed\n");
			goto wrapup;
  		}


	 	/*
	 	 * check the orientation of the surface. 
	 	 */

	 	OMsts = ci$send( msg	= message EMSsubbs.EMget_props( 
								msg,
								&props ),
	       	       targetid = SRF->obj_id.objid,
	       	       targetos = SRF->obj_id.osnum ) ;

		if( !( OMsts & 1 & (*msg) ) ) {
			printf("Error in stifBend\n");
			printf( "Error in EMSsubbs.EMget_props\n" ) ;
			goto wrapup ;
		}

		if( !(props & EMSIS_NRML_REVERSED) )
			 for(i=0;i<3;i=i+1) nvec[i] = -nvec[i];


		BSnorvec( msg, nvec );
		#ifdef DEBUG
		printf("nvec2 = %f,%f,%f\n",nvec[0],nvec[1],nvec[2]);
		#endif

	}

	
	/*c evaluate the iso curve constant in v, v = 0 */

	BSalloccv( (IGRshort) ruledSf->u_order,
		   (IGRlong)  ruledSf->u_num_poles,
		   (IGRshort) ruledSf->rational,
		   (IGRshort) 0,
		   &(cv[0]), (BSrc) msg );

	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSalloccv v = 0\n");
		goto wrapup;
	}

	option = 2;
	org[0] = 0.0;
	org[1] = 0.0;
        BSconstprcv( (BSrc) msg, ruledSf, &option, org, &tst_planar, cv[0] ); 
     	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSconstprcv v = 0\n");
		goto wrapup;
      	}


 
	/*c evaluate the iso curve constant in u, u = 0 */

	BSalloccv( (IGRshort) ruledSf->v_order,
		   (IGRlong)  ruledSf->v_num_poles,
		   (IGRshort) ruledSf->rational,
		   (IGRshort) 0,
		   &(cv[1]), (BSrc) msg );

	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSalloccv u = 0\n");
		goto wrapup;
	}

	option = 1;
	org[0] = 0.0;
	org[1] = 0.0;
        BSconstprcv( (BSrc) msg, ruledSf, &option, org, &tst_planar, cv[1] ); 
     	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSconstprcv u = 0\n");
		goto wrapup;
      	}

	/*c evaluate the iso curve constant in v, v = 1 */

	BSalloccv( (IGRshort) ruledSf->u_order,
		   (IGRlong)  ruledSf->u_num_poles,
		   (IGRshort) ruledSf->rational,
		   (IGRshort) 0,
		   &(cv[2]), (BSrc) msg );

	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSalloccv v = 1\n");
		goto wrapup;
	}

	option = 2;
	org[0] = 0.0;
	org[1] = 1.0;
        BSconstprcv( (BSrc) msg, ruledSf, &option, org, &tst_planar, cv[2] ); 
     	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSconstprcv v = 1\n");
		goto wrapup;
      	}
 
	/*c evaluate the iso curve constant in u, u = 1 */

	BSalloccv( (IGRshort) ruledSf->v_order,
		   (IGRlong)  ruledSf->v_num_poles,
		   (IGRshort) ruledSf->rational,
		   (IGRshort) 0,
		   &(cv[3]), (BSrc) msg );

	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSalloccv u = 1\n");
		goto wrapup;
	}

	option = 1;
	org[0] = 1.0;
	org[1] = 1.0;
        BSconstprcv( (BSrc) msg, ruledSf, &option, org, &tst_planar, cv[3] ); 
     	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSconstprcv v = 1\n");
		goto wrapup;
      	}

	/*c find the largest curve */
	i1 = 0;
	ratioCou = -1.0;

	for(i=0; i<4; i=i+1){

		len[i] = 0.0;
		jM3 = 3 * (cv[i]->num_poles - 1);

		for(j=0;j<jM3;j=j+3)
		len[i] = len[i] + BSdistptpt( msg,
					      &(cv[i])->poles[j],
					      &(cv[i])->poles[j+3]);
		if( len[i] > ratioCou ){
			i1 = i;
			ratioCou = len[i];
		}

		#ifdef DEBUG
		printf("len[%d] = %f, ratioCou = %f\n",i,len[i],ratioCou);
		#endif

	}


	/*c set the index of the curve that will be used now */

	if( i1 < 2 ) i2 = i1 + 2;
	else	     i2 = i1 - 2;


	/*c malloc the receiving iso structure */

	BSalloccv( (IGRshort) cv[i1]->order,
		   (IGRlong)  cv[i1]->num_poles,
		   (IGRshort) cv[i1]->rational,
		   (IGRshort) 0,
		   &isoCrv, (BSrc) msg );

	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSalloccv for midCurve\n");
		goto wrapup;
	}

	
	/*c evaluate the iso curve at parameter 0.5 in the 
	    apropriate direction*/

	if( (i1 == 0) || (i1==2) ){ option = 2; org[0] = 0.0; org[1] = 0.5;}
	else			  { option = 1; org[0] = 0.5; org[1] = 0.0;}

        BSconstprcv( (BSrc) msg, ruledSf, &option, org, &tst_planar, isoCrv ); 
     	if( *msg != BSSUCC ){
		printf("Error in VLcreStifBen\n");
		printf("Error in BSconstprcv v = 1\n");
		goto wrapup;
      	}


	/*c malloc the arrays I need to have for POfndOneFib */
	
	jM3 = 3 * cv[i1]->num_poles;
	k = cv[i1]->num_poles;

        intPts = (IGRdouble *)  om$malloc( size = jM3 * sizeof(IGRdouble) );
	u = (IGRdouble *)  om$malloc( size = k * sizeof(IGRdouble) );
	a = (IGRdouble *)  om$malloc( size = k * sizeof(IGRdouble) );
	b = (IGRdouble *)  om$malloc( size = k * sizeof(IGRdouble) );
	k = 8 * k;
	paPtSol = (IGRdouble *)  om$malloc( size = k * sizeof(IGRdouble) );
	par1[0] = 0.0;
	par2[0] = 1.0;

	j = 0;
	
	while(j<k){
	
		#ifdef DEBUG
		printf("*****> enter POfndOneFib j = %d\n",j);
		#endif

	   	POfndOneFib( cv[i1], cv[i2], isoCrv, nvec, par1[0], par2[0], 
			     &paPtSol[j], &paPtSol[j+2], intPts, 
			     u, a, b, msg );
		#ifdef DEBUG
		printf("---->parsol[%d] = %f,%f\n",j, paPtSol[j], paPtSol[j+1]);
		printf("ptSol=%f,%f,%f\n",paPtSol[j+2],paPtSol[j+3],paPtSol[j+4]);
		printf("ptSol=%f,%f,%f\n",paPtSol[j+5],paPtSol[j+6],paPtSol[j+7]);
		#endif

		if( (j >= 8 ) ){
		   if( ( fabs((paPtSol[j]-paPtSol[j-8])) < 0.01 ) &&
		       ( fabs((paPtSol[j+1]-paPtSol[j-7])) < 0.01 ) ) break;
		}

		par1[0] = paPtSol[j+1];
		j=j+8;
		if( fabs( (paPtSol[j-7]-par2[0]) ) < 0.0000001 ) break;
		
	}

	
	/* evaluate the total number of points to evaluate */

	POcvInsGreKt( isoCrv, (IGRdouble) 1.005, (IGRint)200, 
			       &CvSol, &itCou, &ratioCou, msg );

	/* check if the size of BendCrv is big enough */

	*numBend = j / 8;
	if( (*numBend+1) > maxNumCrvs ){
		printf("Error in VLcreStifBen\n");
		printf(" to many curves to create \n");
	}

	#ifdef DEBUG
	printf(" num de bend = %d\n",(*numBend)); 
	#endif

	itCou = CvSol->num_poles / (*numBend) + 2;
	#ifdef DEBUG
	printf(" num de poit de discretisation = %d\n",itCou);
	#endif

	if( itCou > 31 ) itCou = 31;

	/*c extract from the coordinate system the axis and the origin */

	for(i=0;i<3;i=i+1){
		k = 4*i;
		xAxis[i]  = stifMat[k];
		yAxis[i]  = stifMat[k+1];
		org[i] = stifMat[k+3];
	}


	poly.num_points = 2;

	/*c evaluate the hight of the web */

	yAbs = 0;

	for(i=0;i<3;i=i+1){	
		ratioCou = cv[i1]->poles[i] - cv[i2]->poles[i];
		yAbs = yAbs + ratioCou * ratioCou;
	}

	yAbs = sqrt(yAbs);
	yAbs = yAbs * 0.5;
	xAbs = 0.0;
	
	for(i=0; i<j; i=i+8){

		k = 2 + i/8;

		#ifdef BEBUG
		printf(" ++++> enter VLcnstOneFib i = %d\n",i);
		#endif

		VLcnstOneFib( isoCrv, CvSol, nvec, org, xAxis, yAxis, yAbs, 
			      &paPtSol[i], itCou, cst, displayWanted, 
			      &xAbs, &BendCrv[(*numBend)+k], msg );

		poly.points = &paPtSol[i+2];

		cst->geometry = (char *)&poly;	

		BendCrv[k].objid = NULL_OBJID;
		BendCrv[k].osnum = cst->env_info->md_id.osnum; 

   		stat = ci$send( msg = message GR3dlineseg.GRaltconstruct(cst),
                 		targetid = BendCrv[k].objid,
	         		targetos = BendCrv[k].osnum );

		if( !(stat&1) ) {
			printf("error in GR3dlineseg.GRconstruct\n");
			*msg = MSFAIL;
		}
		else{
			*msg = MSSUCC;
			if( displayWanted == TRUE )
			gr$display_object( 
				object_id = (struct GRid *) &BendCrv[k], 
			   	mode      =  GRbd	);
		}

	}/* end of loop on all the straight fibers */


	/*c create the contour of the stiffner */
	
	for(i=0;i<3;i=i+1){

		paPtSol[i]    = org[i];
		paPtSol[i+3]  = paPtSol[i] + xAbs * xAxis[i];
		paPtSol[i+6]  = paPtSol[i+3] + 2.0 * yAbs * yAxis[i];
		paPtSol[i+9]  = org[i] +  2 * yAbs * yAxis[i];
		paPtSol[i+12] = paPtSol[i];
	}
	
	*numBend = 2 * (*numBend);
	
	poly.num_points = 5;
	poly.points = paPtSol;

	cst->geometry = (char *)&poly;	

	BendCrv[0].objid = NULL_OBJID;
	BendCrv[0].osnum = cst->env_info->md_id.osnum; 


   	stat = ci$send( msg = message GR3dlinestr.GRaltconstruct(cst),
                 	targetid = BendCrv[0].objid,
	         	targetos = BendCrv[0].osnum );

	if( !(stat&1) ) {
		printf("error in GR3dlineseg.GRconstruct\n");
		*msg = MSFAIL;
	}
	else{
		*msg = MSSUCC;
		if( displayWanted == TRUE )
		gr$display_object( 
			object_id = (struct GRid *) &BendCrv[0], 
		   	mode      =  GRbd	);
	}

        /*c create the stiffener name as a text foot */

	CreStifText( StifObj, stifMat, xAbs, yAbs, &BendCrv[1], msg );

	*numBend = *numBend + 2;

endok:	
	for(i=0;i<4;i=i+1){
		if( cv[i] ) {BSfreecv(msg,cv[i]); cv[i] = NULL;}
	}

	if( ruledSf ) { BSfreesf(msg,ruledSf); ruledSf = NULL;}
	if( isoCrv ) { BSfreecv( msg,isoCrv); isoCrv = NULL;}
	if( intPts ) { om$dealloc( ptr = intPts ); intPts = NULL;}
	if( u ) { om$dealloc( ptr = u ); u = NULL;}
	if( a ) { om$dealloc( ptr = a ); a = NULL;}
	if( b ) { om$dealloc( ptr = b ); b = NULL;}
	if( paPtSol ) { om$dealloc( ptr = paPtSol ); paPtSol = NULL;}
    	if( CvSol ){ BSfreecv(msg,CvSol); CvSol = NULL;}

	*msg = MSSUCC;
	return;



wrapup:

	for(i=0;i<4;i=i+1){
		if( cv[i] ) {BSfreecv(msg,cv[i]); cv[i] = NULL;}
	}

	if( ruledSf ) { BSfreesf(msg,ruledSf); ruledSf = NULL;}
	if( isoCrv ) { BSfreecv( msg,isoCrv); isoCrv = NULL;}
	if( intPts ) { om$dealloc( ptr = intPts ); intPts = NULL;}
	if( u ) { om$dealloc( ptr = u ); u = NULL;}
	if( a ) { om$dealloc( ptr = a ); a = NULL;}
	if( b ) { om$dealloc( ptr = b ); b = NULL;}
	if( paPtSol ) { om$dealloc( ptr = paPtSol ); paPtSol = NULL;}
    	if( CvSol ){ BSfreecv(msg,CvSol); CvSol = NULL;}

	*msg = MSFAIL;
	return;

}

/*==========================================================================*/
CreStifText( PlateID, toMat, Length, Width, TextID, suc )

struct	GRid		PlateID;
	IGRdouble	*toMat;
	IGRdouble	Length;
	IGRdouble	Width;
struct	GRid		*TextID;
	IGRlong		*suc;

{


IGRlong			OmRet;
IGRdouble		COG[3];
IGRint			i, k;
IGRint			len;
IGRint			four;
IGRdouble		tmp_matrix[16];
IGRchar			name[1023];
IGRchar			dirname[1023];
IGRdouble		leng, wid;


	/*c Retrieve name of the plate */

	OmRet = ci$send( msg	= message GRgraphics.GRgetname( suc,
								name ),
	       	       targetid = PlateID.objid,
	       	       targetos = PlateID.osnum ) ;

	if( !( OmRet & 1 & (*suc) ) ) {
		sprintf(name,"elem_%d_%d",PlateID.objid,PlateID.osnum);
	}
	else{
                OmRet = di$split ( pathname = name,
				   dirname = dirname,
                                   name = name);
		#ifdef DEBUG
		printf("name = %s\n",name);
		printf("dirname = %s\n",dirname);
		#endif

	}

	len = strlen(name);

	four = 4;

	if( Length < Width )	leng = Length / 10;
	else			leng = Width / 10;

	#ifdef DEBUG
		printf("name = %s\n",name);
		printf("leng = %f, wid = %f\n",leng,wid); 
	#endif

	for(i=0;i<3;i=i+1){
		k = 4*i;
		COG[i] = toMat[k+3] + leng * toMat[k] + leng * toMat[k+1];
	}

  	MAinvmx ( suc, &four, toMat, tmp_matrix);
	tmp_matrix[3] = tmp_matrix[7] = tmp_matrix[11] = 0.0;

	OmRet = co$place_text (       msg         = suc,
			      	      text_string = name,
			      	      text_length = &len,
			      	      rot_matrix  = tmp_matrix,
			      	      origin      = COG,
			      	      flags       = 1,
			      	      buffer      = TextID );
		if( !(OmRet&1&(*suc)) ){
			printf("Error in CrePlateText\n");
			printf("co$place_text Failed\n");  
			goto wrapup;
		}

	*suc = MSSUCC;
	return;

wrapup:
	*suc = MSFAIL;
	TextID->objid = NULL_OBJID;
	return;


}
/*========================================================================*/

NDdelete(md_env)
struct GRmd_env *md_env;
{

IGRlong		stat, OMstat;
struct	GRid	ASobj;






  if( md_env->md_id.objid == -1 ){
	 printf("md_env->md_id.objid == -1\n"); 
	 goto wrapup ;
  }

  MOD_ENV=  *md_env;

  /*c retrieve the refrential and send an undisplay , without checking
      that other elements are dependant to it*/

  OMstat = ci$send( msg      = message  ACcpx.ACfind_exp_temp_obj(
							&stat,0,&ASobj),
 	      	    targetid = CI_MACRO_ID.objid,
      	 	    targetos = CI_MACRO_ID.osnum );
	if(!(OMstat&stat&1)) goto wrapup;

  gr$display_object ( object_id = (struct GRid *)&ASobj,
	     	      mode      = GRbehe);

wrapup:
   ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
         targetid = CI_MACRO_ID.objid,
         targetos = CI_MACRO_ID.osnum,
         mode     = WRT_message );
   return(1);
}

/* ========================================================================= */


