class implementation VLcoToAlCmd;

/****************************	VLconFormNi.I	*******************************

	Form notification method and get text function for the Alma Rimbaud
	command object.  These two functions were originally generated by 
	form builder (fb).


****************************	VLconFormNi.I	*******************************/

#include <stdio.h>
#include "FI.h"
#include "OMminimum.h"
#include "OMprimitives.h"
#include "OMerrordef.h"
#include "msdef.h"
#include "exmacros.h"
#include "grmacros.h"
#include "griodef.h"
#include "grio.h"
#include "vlalma.h"
#include "vlmsg.h"
#include "v_miscmacros.h"

/********************** for DEBUGGING*********************************

#ifndef CONVTOALDEBUG

#define CONVTOALDEBUG 1

#define vsDEBUG         1
#define vserrDEBUG      1

#endif

********************** end DEBUGGING*********************************/

#include "vldbgmacros.h"


/* Gadgets see vlalma.h ***************>

#define LOGFILEREQ    23
#define LOGFILENAME        24
#define GROUP1        21
#define GROUP2        22
#define FLATPLATES    12
#define FLATTENED    13
#define PLATETEMPLS    14
#define STIFFTEMPLS    15
#define FLATBARS    16
#define PLATEJIGS    17
#define AUTOFILE    25
#define FILEPREFIX        26
#define CIRCAPPROX        27
#define MESSAGES        10

***************   defines left for information only, see vlalma.h	*******/


/************* Externs defined in include files 

extern char * calloc();
extern char * realloc();
extern int FIg_get_text_length();
extern int FIg_get_text();

***************/

extern int VLrimbActHandler() ;

static int VLconGetText ( fp, g_label, text, text_size )
       Form    fp;            // Pointer to the form
       int     g_label;       // The label of the gadget
       char ** text;          // The text contained in the field
       int   * text_size;     // The space allocated for the text
{
    int status = FI_SUCCESS ;
    int text_len;
    int field_type;
    int select_flag;
    int row = 0;
    int col = 0;
    int pos = 0;

    status = FIg_get_type ( fp, g_label, &field_type );
    CheckRC( 1, !status ) ;
	
    if ( field_type == FI_MULTI_COL )
    {
        // Get the col for the MCF

        status = FImcf_get_active_col ( fp, g_label, &col, &pos );
	CheckRC( 1, !status ) ;

    }

    // Get the row for the field or MCF

    status = FIfld_get_active_row ( fp, g_label, &row, &pos );
    CheckRC( 1, !status ) ;
    status = FIfld_get_text_length ( fp, g_label, row, col, &text_len );
    CheckRC( 1, !status ) ;

    // Increment text_len because of NULL

    text_len++;

    if ( * text_size < text_len ) goto wrapup ;

/****** was as below, but this command has a fixed length string

    {
        if ( * text_size > 0 )
        {
           // Realloc space for larger string
           * text = realloc ( * text, text_len );
        }
        else
        {
           // Calloc space for string
           * text = calloc ( 1, text_len );
        }
        * text_size = text_len;
    }

    if ( ! * text )
    {
      * text_size = 0;

      status = FI_NO_MEMORY ;

      goto wrapup ;
    }
*******************/

    status = FIfld_get_text ( fp, g_label, row, col, * text_size,
                           (unsigned char *) * text, &select_flag, &pos );
    CheckRC( 1, !status ) ;

wrapup :
	return status ;

}	// end get text function 


method form_notification( 
  int     f_label;       /* The label of the form   */
  int     g_label;       /* The label of the gadget */
  double  value;         /* The value of the gadget */
  Form    fp;            /* Pointer to the form     */
			)
{

  static char     text[20],
		* TextPtr = text ;
  static int      text_size = 20;
  int             status = OM_E_INVARG ,
		  suc	= OM_E_INVARG ;

  switch ( g_label )
  {

    case FI_CVT_TO_PERM_WIN:     /* Member of group FI_CTRL_GROUP */

	status = FIf_cvrt_to_perm_win ( fp );
	CheckRC( 1, !status ) ;

	status = FIfld_set_text( fp, MESSAGES, 0, 0, 
				 "Form is now a standard window", FALSE ) ;
	CheckRC( 1, !status ) ;

    break;


    case FI_RESET:     // set all options back to the default setting
      {
	int label = FLATPLATES ;

					// locate everything 
	me->TransTypes =       FlatPlates | Flattened | FlatBars |
				StiffTempls | PinJigs | PlateTempls ;

	me->autofile	  = TRUE ;
	me->circleapprox  = TRUE ;
	me->LogFile       = TRUE ;

	for ( ; label <= PLATEJIGS ; ++label )
		status = FIg_set_state_on( fp , label ) ;
		CheckRC( 1, !status ) ;

	status = FIg_set_state_on( fp, AUTOFILE ) ;
	CheckRC( 1, !status ) ;
	status = FIg_set_state_on( fp, LOGFILEREQ ) ;
	CheckRC( 1, !status ) ;
	status = FIg_set_state_on( fp, CIRCAPPROX  ) ;
	CheckRC( 1, !status ) ;
	status = FIfld_set_text( fp, FILEPREFIX , 0, 0, "", FALSE ) ;
	CheckRC( 1, !status ) ;
	status = FIg_disable( fp, FILEPREFIX ) ;
	CheckRC( 1, !status ) ;

	
	status = FIfld_set_text( fp, MESSAGES , 0, 0, 
			"Options returned to the original settings", FALSE ) ;
			CheckRC( 1, !status ) ;

      }  // case reset pressed	

      break;

    case FI_ACCEPT:     // Member of group FI_CTRL_GROUP

	if( me->state == 1 )
	{
#define VL_FORM_MODIF 112
		IGRint 	sel;
		IGRlong msg;

		sel = VL_FORM_MODIF;
		ex$putque( msg = &msg, response = &sel ) ;
#undef VL_FORM_MODIF
	}

          // Erase the displayed form

	status = om$send ( msg = message CEO.erase_form_by_label
                                        ( STATUS_FORM, 0, &suc),
                                  targetid = my_id);

         CheckRC( status, suc ) ;

	status = FIfld_set_text( fp, MESSAGES , 0 , 0 , "", FALSE ) ;
	CheckRC( 1, !status ) ;
		

    break;


    case FLATPLATES:     // Member of group GROUP2


	   if ( me->TransTypes & FlatPlates ){
		me->TransTypes ^= FlatPlates ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Flat plates can no longer be located", FALSE );
		CheckRC( 1, !status ) ;
	   }
	   else	{
		me->TransTypes |= FlatPlates ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Flat plates can now be located", FALSE );
		CheckRC( 1, !status ) ;
	   }
	   __DBGpr_int( "FLATPLATES", (me->TransTypes & FlatPlates )) ;

    break;

    case FLATTENED:     // Member of group GROUP2


	   if ( me->TransTypes & Flattened ) {

		me->TransTypes ^= Flattened ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			   "Flattened (unwrap) plates can no longer be located",
				 FALSE );
		CheckRC( 1, !status ) ;
	   }
	   else	{
		me->TransTypes |= Flattened  ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Flattened (unwrap) plates can now be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "FLATTENED", ( me->TransTypes & Flattened ) ) ;

    break;

    case PLATETEMPLS:     // Member of group GROUP2


	   if ( me->TransTypes & PlateTempls ){

		me->TransTypes ^= PlateTempls ;

		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Template managers can no longer be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }
	   else {
		me->TransTypes |= PlateTempls ;

		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Template managers can now be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "PLATETEMPLS", (me->TransTypes & PlateTempls) ) ;
	   __DBGpr_int( "locate atts", (me->attributes.properties) ) ;

    break;

    case STIFFTEMPLS:     // Process stifener templates, Member of group GROUP2


	   if ( me->TransTypes & StiffTempls ){
	   
		me->TransTypes ^= StiffTempls ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Stiffener templates can no longer be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }
	   else	{
		me->TransTypes |= StiffTempls ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Stiffener templates can now be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "STIFFTEMPLS", (me->TransTypes & StiffTempls) ) ;

    break;

    case FLATBARS:     // Process flat bars, Member of group GROUP2


	   if ( me->TransTypes & FlatBars ){
		me->TransTypes ^= FlatBars ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Flat bars can no longer be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }
	   else	{
			me->TransTypes |= FlatBars    ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Flat bars can now be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "FLATBARS", (me->TransTypes & FlatBars) ) ;

    break;

    case PLATEJIGS:     // Process pin jigs, Member of group GROUP2


	   if ( me->TransTypes & PinJigs ) {
	   
		me->TransTypes ^= PinJigs     ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Plate jigs can no longer be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }
	   else	{
	   
	        me->TransTypes |= PinJigs     ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
			        "Plate jigs can now be located",
				FALSE );
		CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "PLATEJIGS", (me->TransTypes&PinJigs) ) ;
    break;

    case AUTOFILE:     // auto file name generation Sequenced to FILEPREFIX

	   if ( me->autofile ){
		me->autofile = FALSE ;
		status = FIg_enable( fp, FILEPREFIX ) ;
		CheckRC( 1, !status ) ;

		if ( me->fileprefix[0] ) {	// have a filename 

			status = FIfld_set_text( fp, FILEPREFIX, 0 , 0 , 
						     me->fileprefix , FALSE ) ;
			CheckRC( 1, !status ) ;
		}

		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
						       "Enter filename prefix ",
				FALSE );
		CheckRC( 1, !status ) ;
		
	   }		// if auto filename generation
	   else	{	
	   	me->autofile = TRUE ;
		status = FIfld_set_text( fp, FILEPREFIX, 0 , 0 , "", FALSE ) ;
		CheckRC( 1, !status ) ;
		status = FIg_disable( fp, FILEPREFIX ) ;
		CheckRC( 1, !status ) ;
		status = FIfld_set_text( fp, MESSAGES, 0, 0, 
				   "Prefix generated from a part's attributes",
				FALSE );
		CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "AUTOFILE", me->autofile ) ;

   break;


    case LOGFILEREQ:     // is a logfile required?, Sequenced to LOGFILENAME

	if ( me->LogFile ) {
	   me->LogFile = FALSE ;
	   status = FIg_disable( fp, LOGFILENAME ) ;
	   CheckRC( 1, !status ) ;
	   status = FIfld_set_text( fp, LOGFILENAME , 0 , 0 , "", FALSE ) ;
	   CheckRC( 1, !status ) ;
	   if ( me->LogFileId ){
		   fprintf( (FILE*)me->LogFileId , "conversion completed\n\n" );
		   fclose( (FILE*)me->LogFileId );
		   me->LogFileId = NULL ;
	   }
	   status = FIfld_set_text( fp, MESSAGES, 0, 0, 
						       "No log file generated ",
				FALSE );
	   CheckRC( 1, !status ) ;
		
	}	// if log file defined 
	else {
	   char LogFileName[15] ;
		me->LogFile = TRUE  ;
		status = FIg_enable( fp, LOGFILENAME ) ;
		CheckRC( 1, !status ) ;
		strcpy( LogFileName , me->fileprefix ) ;
		strcat( LogFileName, ".log" ) ;
		LogFileName[14] = 0 ;
		status = FIfld_set_text( fp, LOGFILENAME , 0 , 0 ,
							LogFileName , FALSE );
		CheckRC( 1, !status ) ;
	        status = FIfld_set_text( fp, MESSAGES, 0, 0, 
						"A log file will be generated ",
						FALSE );
	   	CheckRC( 1, !status ) ;
					
	}  // else define log file 

	__DBGpr_int( "LOGFILEREQ", me->LogFile ) ;

    break;

    case LOGFILENAME:  
                             // Field Type:    ASCII

	__DBGpr_int( "LOGFILENAME", LOGFILENAME ) ;
          // Get the text string

        status = VLconGetText ( fp, g_label, & TextPtr, & text_size );
	CheckRC( 1, !status ) ;

        if ( status != FI_SUCCESS ) {
              // Code to handle error

		status = FIfld_set_text( fp, LOGFILENAME, 0 , 0 , "", FALSE ) ;
		CheckRC( 1, !status ) ;
		status = FIfld_set_text( fp, MESSAGES, 0 , 0 , 
					"Problem with log filename", FALSE ) ;
		CheckRC( 1, !status ) ;
              goto wrapup;
        }

	if ( TextPtr && text_size ) {

	   if ( me->LogFileId ){
		   fprintf( (FILE*)me->LogFileId , "conversion completed\n\n" );
		   fclose( (FILE*)me->LogFileId );
		   me->LogFileId = NULL ;
	   }
           if(( me->LogFileId=(char*)fopen( text, "a" ))==NULL ){

                ex$message(  msgnumb = VL_E_FILEWRITE,
                                type = "%s",
                                var  = `text`,
                                buff = me->status);
                om$send( msg = message VLcoToAlCmd.status(me->status ),
                                        targetid   = my_id);

		status = FIfld_set_text( fp, MESSAGES, 0 , 0 ,
							me->status , FALSE ) ;
		CheckRC( 1, !status ) ;
				
	
	   } // if could not open the log file

	}	// if got some text from log filename field

    break;

    case FILEPREFIX:     // Sequenced to CIRCAPPROX
                             // Field Type:    ASCII 

	__DBGpr_int( "FILEPREFIX", FILEPREFIX ) ;
          // Get the text string

       status = VLconGetText ( fp, g_label, & TextPtr, & text_size );
	CheckRC( 1, !status ) ;

       if ( status != FI_SUCCESS ) {
              // Code to handle error
		status = FIfld_set_text( fp, FILEPREFIX, 0 , 0 , "", FALSE ) ;
		CheckRC( 1, !status ) ;
		status = FIfld_set_text( fp, MESSAGES, 0 , 0 , 
					"Problem with file prefix", FALSE ) ;
					CheckRC( 1, !status ) ;

              goto wrapup;
       }

	if ( text && text_size ) {

		strcpy( me->fileprefix, text ) ;
		me->ini_fileid = NULL ;	// to opened later 

	}

    break;

    case CIRCAPPROX:	// use approximation of bspline curves


	   if ( me->circleapprox ) {
		me->circleapprox = FALSE ;
	        status = FIfld_set_text( fp, MESSAGES, 0, 0, 
				     "Approximation of complex curves by lines",
						FALSE );
	   	CheckRC( 1, !status ) ;
	   }
	   else	{
		me->circleapprox = TRUE  ;
	        status = FIfld_set_text( fp, MESSAGES, 0, 0, 
				      "Approximation of complex curves by arcs",
						FALSE );
	   	CheckRC( 1, !status ) ;
	   }

	   __DBGpr_int( "CIRCAPPROX", me->circleapprox ) ;


    break;


    case MESSAGES:         // Field Type:    ASCII    */

          // Should not need to Get the text string

	   __DBGpr_int( "MESSAGES", MESSAGES ) ;

    break;

  } // END switch ( g_label )

wrapup:

	   if ( me->TransTypes & FlatBars ||		// flat bars
		me->TransTypes & Flattened ){		// flattened plates

			me->action_handler = (char (*)())VLrimbActHandler ;
			me->action_args	   = (char*)&me->TransTypes;
	   }
	   else	{
			me->action_handler = NULL ;
			me->action_args	   = NULL ;
	   }
	   __DBGpr_int( "action hand", (me->action_handler) ) ;


	return status ;

} // END notification_routine()

end implementation VLcoToAlCmd;
