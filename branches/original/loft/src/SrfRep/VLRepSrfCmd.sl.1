/*d-----------------------------------------------------------------------------


	Class Name:	VLRepSrfCmd

	Abstract:	Command to repair surfaces whose poles are too close

			This command looks at the surface in the u direction
			and then in the v direction to see whether the poles
			are closer than a CHT.  Should this be the case a new
			surface is created with the offending poles spread 
			out beyond CHT, the new layer for this surface is
			given by the operator.

------------------------------------------------------------------------------*/

command_string	VLC_M_REPAIR_SURFACE, 0, VLRepSrf
command_table	"vl.cmd"
class		VLRepSrfCmd
super_class	VLlocateCmd 
product_name	"$LOFT"

start_state	GetLevel

specification

instance {

/*c	Same as superclass + **/

  short	NewLevel ;

}

implementation

#include "OMminimum.h"
#include "OMprimitives.h"
#include "OMerrordef.h"
#include <stdio.h>
#include "EMSstruct.h"
#include "bserr.h"
#include "msdef.h"
#include "grdpbdef.h"
#include "grdpb.h"
#include "grdpbmacros.h"
#include "AS_status.h"
#include "exmacros.h"
#include "grmacros.h"
#include "growner.h"
#include "nddef.h"
#include "macro.h"
#include "asmacros.h"
#include "asbox.h"
#include "graph.h"
#include "ndmacros.h"
#include "vsplatedef.h"
#include "vsbmaxisdef.h"
#include "vsgeommacros.h"
#include "vsmiscmacros.h"
#include "EMSssprops.h"
#include "vlstructure.h"
#include "vlmark.h"
#include "vlmsg.h"

	//local defines for default type and value of edge attributes

#define		TYPE	"R"
#define		VALUE	"0"


/********************** start DEBUGGING*********************************

#define vsDEBUG         1
#define vserrDEBUG      1

********************** end DEBUGGING*********************************/

#include "vldbgmacros.h"

/*c	External Functions ****/
/*c defined in include files */

/*c  External Methods ****/

from  NDmacro		import	ACreturn_foot;
from  NDnode		import	ASreturn_go;

/*c	Extern variables ***/

/*c	threexternal vars.. ***/
extern GRclassid	OPP_EMSsubbs_class_id,
                        OPP_VSplate_class_id,
                        OPP_NDnode_class_id;

/*c	Define the state transitions... *****/

state_table

#include	"vlmsg.h"
#include	"vltemplate.h"
#include	"OMerrordef.h"

state GetLevel
        message			"Repair surface"
        status                  "Reset to take the default"
        prompt                  "Enter new layer for surface[99]"
        filter                  get_event

        on EX_STRING		do VLstoreLocate( &me->ret )
				do VLSetLevel( )
				state GETSURF

        on EX_RJT_MOVEON        do status "Taking default layer"
				state GETSURF


state GETSURF
	message			"Repair Surface"
	prompt_key		VL_P_SURFACE_OR_PLATE
	accept_key		VL_M_SURFACE_OR_PLATE
	locate_eligible		"+EMSsubbs"
	locate_owner		"LC_RIGID_COMP | LC_RIGID_OWNER |
				 LC_FLEX_COMP  | LC_FLEX_OWNER  | 
				 LC_REF_OBJECTS"
	filter			locate

	on EX_OBJID or EX_DATA	do VLstoreLocate( &me->ret )
				do VLstoreResponse( &me->ret )
				do VLstoreList( &me->ret, 1, 1)
				do VLProcessSrfs( &me->ret )
				on RETURN_CODE = OM_S_SUCCESS
				   do status "Surface repaired"
				   state .
				state .


at init do InitInstance()
at delete do status ""

/*c  That's all folks, now the actions (methods) ****/

action RepairSurface( struct GRobj_env * TheSurf ) extern 

action VLSetLevel ( )
{
   char StatusMessage[32] ;

   me->NewLevel = atoi( me->event1.event.keyin ) ;

   if ( me->NewLevel > 1023 ) me->NewLevel = 99 ;

   else if ( me->NewLevel <= 0 ) me->NewLevel = 99 ;

   __DBGpr_int( "New level is now ", me->NewLevel );

   StatusMessage[22] = me->status[23] = me->status[24] = me->status[25] = 0 ;

   sprintf( StatusMessage, "New surface on layer %d", me->NewLevel ) ;
   status = om$send ( msg = message VLRepSrfCmd.status( StatusMessage ),
		targetid  = my_id ) ;

   if (status&1) goto quit ;
   return status ;

}

action InitInstance( )
{
	me->NewLevel = 99 ;
	status = OM_S_SUCCESS ;
	goto quit ;
}

action VLProcessSrfs( IGRlong * ret )
{
 struct GRid
			 base_surf;		//the surf for the edge attribs

 struct GRobj_env	SurfObj;

 IGRint			
			current_obj;		//current obj being processed

 IGRlong		l_msg;	  // require int return, long for method!*/

 IGRchar		*	name = NULL;

 OMuword                TEMP_cl;		//classid of current object

 status	=	OM_E_INVARG;  // message return codes*/
 if ( !ret ) goto wrapup;			//no argument, so leave

 *ret		= VL_S_SUCCESS;
 
 for ( current_obj=0;current_obj<me->Cnt1;++current_obj ){
     SurfObj = me->Lst1[current_obj];
     base_surf = SurfObj.obj_id; 

    __DBGpr_int( "Locate returned objects",  me->Cnt1);
    __DBGpr_obj( "got object",  base_surf );


                // retrieve the support surface of the plate

     om$get_classid( osnum           = SurfObj._osnum  ,
                     objid           = SurfObj._objid  ,
                     p_classid       = &TEMP_cl      ) ;

   if( om$is_ancestry_valid( superclassid = OPP_NDnode_class_id,
                                  subclassid    = TEMP_cl ) == OM_S_SUCCESS ) {

        __DBGpr_obj( "got reference object before ret_go",SurfObj.obj_id );

        status = om$send( msg  = message NDnode.ASreturn_go(
                                        &base_surf,
                                        &SurfObj._matrix_type,
                                         SurfObj._matrix ),
                        senderid = NULL_OBJID,
                        targetid = SurfObj._objid,
                        targetos = SurfObj._osnum );

        __CheckRC( status, 1, "PlEd:return_go", next_object );

        status = om$get_classid( osnum   = base_surf.osnum  ,
                                 objid   = base_surf.objid  ,
                                 p_classid       = &TEMP_cl      ) ;
        __CheckRC( status, 1, "PlEd:get_classid", next_object );

    }  // end if its a reference object

    if( om$is_ancestry_valid( superclassid  = OPP_VSplate_class_id,
                                  subclassid    = TEMP_cl ) == OM_S_SUCCESS ) {

	__DBGpr_com( "It's a plate!!" );

                         //Get bottom side of plate

	name = VS_K_plBotSfPath;
			
        status= om$send( msg = message NDmacro.ACreturn_foot(
                                        &l_msg,
                                        name,
                                        &SurfObj.obj_id ,
                                        &SurfObj._matrix_type,
                                        SurfObj._matrix ),
			senderid = NULL_OBJID,
			targetid = base_surf.objid,
			targetos = base_surf.osnum ) ;

	__CheckRC( status, l_msg, "Plate:NDmacro.ACreturn_foot", wrapup );
       
     } // if it's a plate

     else if( om$is_ancestry_valid( superclassid  = OPP_EMSsubbs_class_id,
                                  subclassid    = TEMP_cl ) == OM_S_SUCCESS ) {

                __DBGpr_com("its a surface!");
		SurfObj.obj_id = base_surf;
     }

     else{
                __DBGpr_com("not a plate or EMSsubbs!");
		SurfObj.obj_id.objid = NULL_OBJID ;
     }


		// so, fix it.

     status = om$send( msg	= message VLRepSrfCmd.RepairSurface( &SurfObj ),
                       targetid = my_id );

     __CheckRC( status, 1, "Repair cmd:Repair Surface", next_object );


next_object:		////////////////// GOTO

	status = OM_S_SUCCESS;

 } //c end for on located objects


 if ( status&1 )	goto quit ;	// keep compiler quiet


wrapup:			////////////// cleanup GOTO

    return ( status );
    
} /*c end method Repair Surface*/

/*******++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*******/

/********************	end of command object 			***************/
