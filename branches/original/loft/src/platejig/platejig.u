/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/platejig/platejig.u
 *
 * Description: Plate Jigs Implementation.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      08/02/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "ci_mac_def.h"
#include "vsplatedef.h"
#include "vlpltjigset.h"

#define MACRO_NAME		"platejig"
#define MAX_TEMP                23
#define MAX_FEET                5 
#define MAX_CHAR_FEET   	10

GRobj		ci_mac_def1;
struct GRid	GRIDS[MAX_FEET], CI_MACRO_ID;

extern 	EX_get_modid_given_osnum(), VLpjCreatePlateJig(), VLpjCreateEdgeJig();

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{ 
   IGRint	i, msg, temp_types[MAX_TEMP];
   IGRchar	*temp_names[MAX_TEMP], *feet_names[MAX_FEET],
		temp_buffer[MAX_CHAR_FEET*MAX_TEMP], 
		feet_buffer[MAX_CHAR_FEET*MAX_FEET];

   temp_names[0] = "JigMgr";	   temp_types[0] = macro_generic;
   temp_names[1] = "Attributes";   temp_types[1] = macro_generic;
   temp_names[2] = "Frame";    	   temp_types[2] = macro_generic | double_type;
   for (i = 0 ; i < MAX_TEMP-3 ; i = i + 1)
   {
        sprintf(&temp_buffer[i*MAX_CHAR_FEET], "Plate%d", i+1 )  ;
        temp_names[i+3] = &temp_buffer[i*MAX_CHAR_FEET] ;
	temp_types[i+3] = macro_generic;
   }

   feet_names[0] = "TopCurve" ;
   feet_names[1] = "SideCurve1";
   feet_names[2] = "BottomCurve";
   feet_names[3] = "SideCurve2";
   feet_names[4] = "plane";

   ci_mac_def1 = NULL_OBJID;

   ac$cimacdef( cimacdef          = ci_mac_def1,
		status            = &msg,
		name              = MACRO_NAME,
		temp_num	  = MAX_TEMP,
		temp_names	  = temp_names,
		temp_types	  = temp_types,
		extern_feet_num   = MAX_FEET,
		extern_feet_names = feet_names );

}

place ()
{
IGRlong		msg;

  construct_platejig();

  if( GRIDS[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);
  return(1);
}


compute ()
{
IGRlong         msg;

  construct_platejig();

  if( GRIDS[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
                (&msg, MAX_FEET, GRIDS, &MOD_ENV ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum);

  return(1);

}

construct_platejig()
{
IGRint			i, retFlag, num_pl, frmCnt, direction;
IGRlong			sts, msg;
IGRdouble		pt[3];
struct ACrg_coll	attrib;
struct GRid		mgrID, boxID, frmID, pltID;
struct GRobj_env	mgrOE, boxOE, frmOE, pltOE[MAX_TEMP];

  retFlag = FALSE;

  for( i=0; i<MAX_FEET; i=i+1 )  GRIDS[i].objid = NULL_OBJID;  

  sts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
                                  &msg, 0, &mgrID ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Plate Jig Manager input\n");
            goto wrapup ;
  }

  sts = ci$send( msg = message  NDmacro.ACreturn_foot(
                                &msg, "", &mgrOE.obj_id,
                                &mgrOE.mod_env.md_env.matrix_type,
                                mgrOE.mod_env.md_env.matrix ),
                targetid = mgrID.objid,
                targetos = mgrID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Plate Jig Manager Graphic Input\n");
            goto wrapup ;
  }
  mgrOE.mod_env.md_id.osnum = mgrOE.obj_id.osnum;
  ex$get_modid( mod_osnum = mgrOE.mod_env.md_id.osnum,
                mod_id    = &mgrOE.mod_env.md_id.objid );

  sts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
                                  &msg, 1, &boxID ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Attribute input\n");
            goto wrapup ;
  }

  sts = ci$send( msg = message  NDmacro.ACreturn_foot(
                                &msg, "", &boxOE.obj_id,
                                &boxOE.mod_env.md_env.matrix_type,
                                boxOE.mod_env.md_env.matrix ),
                targetid = boxID.objid,
                targetos = boxID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Attribute Input\n");
            goto wrapup ;
  }
  boxOE.mod_env.md_id.osnum = boxOE.obj_id.osnum;
  ex$get_modid( mod_osnum = boxOE.mod_env.md_id.osnum,
                mod_id    = &boxOE.mod_env.md_id.objid );

  strcpy( attrib.name, NAM_PJS_DIRECTION );
  sts = ci$send(  msg      = message ACrg_collect.ACget_named_attribute(
                                                &msg, &attrib ),
                  targetid = boxOE.obj_id.objid,
                  targetos = boxOE.obj_id.osnum  );
  if( !(sts&msg&1) ) {
           printf("Can not get the Plate Side Attribute\n");
           goto wrapup ;
  }
  direction = (IGRint) attrib.desc.value.att_exp ;

  sts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
                                  &msg, 2, &frmID ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Frame input\n");
            goto wrapup ;
  }

  sts = ci$send( msg = message  NDmacro.ACreturn_foot(
                                &msg, "", &frmOE.obj_id,
                                &frmOE.mod_env.md_env.matrix_type,
                                frmOE.mod_env.md_env.matrix ),
                targetid = frmID.objid,
                targetos = frmID.osnum );
  if( !(sts&msg&1) ) {
            printf("Can not get the Frame Graphic Input\n");
            goto wrapup ;
  }
  frmOE.mod_env.md_id.osnum = frmOE.obj_id.osnum;
  ex$get_modid( mod_osnum = frmOE.mod_env.md_id.osnum,
                 mod_id   = &frmOE.mod_env.md_id.objid );

  if( direction == PJS_EDGE_JIG )
  {
     VLpjCreateEdgeJig(   &msg, &mgrOE, &boxOE, &frmOE, GRIDS );
     retFlag = TRUE;
     goto wrapup;
  }

  num_pl = 0 ;
  for( i=3; i<MAX_TEMP; i=i+1 )
  {
      sts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(
                                  &msg, i, &pltID ),
                targetid = CI_MACRO_ID.objid,
                targetos = CI_MACRO_ID.osnum );
      if( !(sts&msg&1) )  break;

      sts = ci$send( msg = message  NDmacro.ACreturn_foot(
                                &msg, "", &pltOE[i-3].obj_id,
                                &pltOE[i-3].mod_env.md_env.matrix_type,
                                pltOE[i-3].mod_env.md_env.matrix ),
                targetid = pltID.objid,
                targetos = pltID.osnum );
      if( !(sts&msg&1) ) {
            printf("Can not get the Plate[%d] Graphic Input\n", i );
            goto wrapup ;
      }
      pltOE[i-3].mod_env.md_id.osnum = pltOE[i-3].obj_id.osnum;
      ex$get_modid( mod_osnum = pltOE[i-3].mod_env.md_id.osnum,
                    mod_id    = &pltOE[i-3].mod_env.md_id.objid );
      num_pl = num_pl + 1 ;
  }

  VLpjCreatePlateJig( 	&msg, &mgrOE, &boxOE, &frmOE, num_pl, pltOE, GRIDS );

  retFlag = TRUE;

wrapup:
  return retFlag ;
}
