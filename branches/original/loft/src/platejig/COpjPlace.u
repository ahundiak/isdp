/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/platejig/COpjPlace.u
 *
 * Description: Plate Jigs Implementation.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      08/02/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "v_pplslc.h"
#include "v_slcdef.h"
#include "coparamac.h"
#include "vsplatedef.h"
#include "vlpltjigset.h"
#include "vldbgmacros.h"

#define vdsDEBUG	1
#define vdserrDEBUG	1

#define COMMAND_NAME            "Place Plate Jig Set"
#define FORM_NAME               "VLPlateJig.frm"

#define EXP_DOUBLE	0
#define EXP_TEXT   	4

Form                            form;
IGRint				form_displayed, form_exists, not_done, jig_cnt,
				num_plts, test_wakeup, form_labels[60], num_pl;
IGRchar				plt_name[128];
struct CIform_st                form_st;
struct GRid			platejig_mgr;
struct GRmd_env                 loc_env;
struct GRobj_env		plate, primary_frame, secondary_frame, 
				plt_list[20];
struct GRvg_construct           cnst;
struct ACrg_coll        	attr[NB_PJS_ATTR];

extern fabs();

extern FIg_is_valid(), FIg_get_attr(), FIg_set_state_off(), FIg_set_value();

extern 	VSbulkDisplayByGRobj_envs(), ASmake_source_from_env(), ASend_fence(),
	ASstart_var_fence(), VLpjGetFramesInFreeGrid(), VLpjGetNamedAttibute(),
	EXP_create_double(), VLpjGetFramesInPlatesRange(), VLinitCnst(),
	VD_is_ancestry_valid(), VSbulkDeleteByGRids(), VSisLoggedIntoRDB();

extern GRclassid 	OPP_EMSplane_class_id, OPP_expression_class_id,
			OPP_nci_macro_class_id;

IGRlong message_bar( inPrompt )
IGRchar         *inPrompt;
{
   FIg_set_text( form, G_MESSAGE_FIELD, inPrompt );
   return 1;
}

DisableAllLabels()
{
   IGRint       i, attrib ;

   for( i=0; i<60; i=i+1 )
   {
       form_labels[i] = 0 ;
       if( i == FI_CANCEL )     continue;
       if( ! ( FIg_is_valid( form, i )) )
       {
          FIg_get_attr( form, i, &attrib ) ;
          if( !( attrib & FI_NOT_DISPLAYED ) )
          {
             FIg_disable( form, i );
             form_labels[i] = 1 ;
          }
       }
    }
}

EnableAllLabels()
{
   IGRint       i, grid_type, is_selected;
   for( i=0; i<60; i=i+1 )
   {
       if( i == FI_CANCEL )     continue;
       if( form_labels[i] ) FIg_enable( form, i );
   }

   FIg_get_state( form, G_PRIMARY_GRID, &grid_type );
   if( grid_type == IDX_PJS_FIXED_GRID )
            FIg_disable( form, G_PRIMARY_SPACING );

   FIg_get_state( form, G_SECONDARY_DIR, &is_selected );
   if( is_selected )
   {
       FIg_disable( form, G_SECONDARY_GRID );
       FIg_disable( form, G_SECONDARY_SPACING );
       FIg_disable( form, G_SECONDARY_REFPLANE );
       FIg_disable( form, G_SECONDARY_REFNAME );
   }
   else
   {
       FIg_get_state( form, G_SECONDARY_GRID, &grid_type );
       if( grid_type == IDX_PJS_FIXED_GRID )
             FIg_disable( form, G_SECONDARY_SPACING );
   }
}

wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
        /* Display the form unless the command file is just starting */
        __DBGpr_int("I'm now waking up, test_wakeup",test_wakeup);
        if ( test_wakeup == 1 && not_done ) {
            if( form )
            {
                EnableAllLabels();
                form_displayed = TRUE; /* Set flag for sleep function */
            }
        }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
        /* Erase the form if it is displayed */
        if ( form_displayed == TRUE ) {
                DisableAllLabels();
                form_displayed = FALSE;
        }
}

delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
        int     i ;

        __DBGpr_int("form_displayed", form_displayed);
        __DBGpr_int("form_exists", form_exists);
        /* Erase the form if it is displayed */
        if ( form_displayed == TRUE ) {
                FIf_erase ( form );
                form_displayed = FALSE;
        }
        /* Delete the form if it exists */
        if ( form_exists ) {
                if( form ) {
                        VDahFrmSavePositionInFile(form);
                        if (form) VIf_delete(form);
                        form = NULL;
                }
        }
        not_done = 0 ;
}

IGRint  GetName( object, name )
struct GRid             object;
IGRchar                 *name;
{
   ci$send(  msg = message GRgraphics.GRgetname( &msg, name ),
                targetid = object.objid,
                targetos = object.osnum  );
}

IGRstat LocateFrame( inPrompt, selOE, objName, check)
IGRchar         *inPrompt;
TGRobj_env      *selOE;
IGRchar         *objName;
IGRint          check;
{
  IGRint                i, response, labels[60] ;
  OM_S_CLASSLIST        eligibleClasses ;
  OMuword               classids[2] ;

        if( selOE->obj_id.objid != NULL_OBJID ) {
                VSbulkDisplayByGRobj_envs( GRhd, 1, selOE );
        }

	DisableAllLabels();

        classids[0] = OPP_EMSplane_class_id ;

        eligibleClasses.w_count   = 1 ;
        eligibleClasses.w_flags   = OM_CLST_subclass ;
        eligibleClasses.p_classes = classids ;

        ci$locate(
                obj             = &selOE->obj_id.objid,
                osnum           = &selOE->obj_id.osnum,
                md_env          = &selOE->mod_env,
                response        = &response,
                eligible_classes= &eligibleClasses,
                prompt          = inPrompt,
                stackable       = TRUE ,
                properties      = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                owner_action    = LC_RIGID_COMP  | LC_RIGID_OWNER |
                                  LC_FLEX_COMP   | LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS );

	EnableAllLabels();

        if( selOE->obj_id.objid != NULL_OBJID ) {
                GetName( selOE->obj_id, objName );
                __DBGpr_str("Returned name is ",objName);
        }

wrapup:
   return TRUE;
}

IGRstat LocatePlates( inPrompt, num, list, single_pl )
IGRchar         *inPrompt;
IGRint          *num;
TGRobj_env      **list;
TGRobj_env      *single_pl;
{
IGRint          i, response, sts;
TGRobj_env      objOE;

   *num = 0;
   if( *list ) { free( *list ); *list = NULL; }
   single_pl->obj_id.objid = NULL_OBJID;

   DisableAllLabels();

   if( num_plts )
      VSbulkDisplayByGRobj_envs( GRhd, num_plts, plt_list );

   sts = ci$locate(prompt  = inPrompt,
                   classes = "VSplate",
                   owner_action = LC_RIGID_OWNER |
                                  LC_RIGID_COMP  |
                                  LC_FLEX_COMP   |
                                  LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS,
                   stackable    = 1,
                   response     = &response,
                   md_env       = &objOE.mod_env,
                   obj          = &objOE.obj_id.objid,
                   osnum        = &objOE.obj_id.osnum);

   dp$erase_hilite( msg = &msg );

   if (!(sts & 1)) response = 0;

   switch(response) {

    case EX_OBJID:   // Object Set

      /* Grab Located Objects */
      as$start_fence(   set       = &objOE.obj_id,
                        set_env   = &objOE.mod_env,
                        nb_obj    = num,
                        p_obj_env = list );
      ASend_fence();
      break;

    case EX_DATA:    // Single Object
      *single_pl = objOE ;
      break;

   } // Switch

   EnableAllLabels();

   return 1;

}

CreateAttribuiteCollector( boxID )
struct GRid	*boxID;
{
IGRint			is_selected;
IGRlong			msg;
IGRchar			stat[128];

   boxID->objid = NULL_OBJID;
   boxID->osnum = loc_env.md_id.osnum ;

   FIg_get_text( form, G_JIG_SIDE, stat );
   strcpy( attr[IDX_PJS_JIGSIDE].name, NAM_PJS_JIGSIDE );
   attr[IDX_PJS_JIGSIDE].desc.type = AC_ATTRIB_DOUBLE;
   if( !strcmp( stat, NAM_PJS_INSIDE ) )
       attr[IDX_PJS_JIGSIDE].desc.value.att_exp = (IGRdouble) IDX_PJS_INSIDE;
   else if( !strcmp( stat, NAM_PJS_BOTH ) )
       attr[IDX_PJS_JIGSIDE].desc.value.att_exp = (IGRdouble) IDX_PJS_BOTH;
   else attr[IDX_PJS_JIGSIDE].desc.value.att_exp = (IGRdouble) IDX_PJS_OUTSIDE;

   FIg_get_text( form, G_BASE_PLANE, stat );
   strcpy( attr[IDX_PJS_BASEPLANE].name, NAM_PJS_BASEPLANE );
   attr[IDX_PJS_BASEPLANE].desc.type = AC_ATTRIB_DOUBLE;

   if( !strcmp( stat, NAM_PJS_BASEPL ) )
       attr[IDX_PJS_BASEPLANE].desc.value.att_exp = (IGRdouble) IDX_PJS_BASEPL;
   else if( !strcmp( stat, NAM_PJS_CENTERLINE ) )
       attr[IDX_PJS_BASEPLANE].desc.value.att_exp
			= (IGRdouble)IDX_PJS_CENTERLINE;
   else attr[IDX_PJS_BASEPLANE].desc.value.att_exp=(IGRdouble)IDX_PJS_BALANCED;

   FIg_get_text( form, G_MINIMUM_HEIGHT, stat );
   strcpy( attr[IDX_PJS_MINHEIGHT].name, NAM_PJS_MINHEIGHT );
   attr[IDX_PJS_MINHEIGHT].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_MINHEIGHT].desc.value.att_exp =  atof( stat );

   FIg_get_text( form, G_EXTENSION, stat );
   strcpy( attr[IDX_PJS_EXTENSION].name, NAM_PJS_EXTENSION );
   attr[IDX_PJS_EXTENSION].desc.type = AC_ATTRIB_DOUBLE; 
   attr[IDX_PJS_EXTENSION].desc.value.att_exp =  atof( stat );

   FIg_get_text( form, G_CORNER_RADIUS, stat );
   strcpy( attr[IDX_PJS_CORNER_RADIUS].name, NAM_PJS_CORNER_RADIUS );
   attr[IDX_PJS_CORNER_RADIUS].desc.type = AC_ATTRIB_DOUBLE; 
   attr[IDX_PJS_CORNER_RADIUS].desc.value.att_exp =  atof( stat );

   FIg_get_text( form, G_POST_PLACEMENT, stat );
   strcpy( attr[IDX_PJS_POST_MACRO].name, NAM_PJS_POST_MACRO ); 
   attr[IDX_PJS_POST_MACRO].desc.type = AC_ATTRIB_TEXT;
   strcpy( attr[IDX_PJS_POST_MACRO].desc.value.att_txt, stat );

   FIg_get_state( form, G_PRIMARY_GRID, &is_selected );
   strcpy( attr[IDX_PJS_PRM_GRID_TYPE].name, NAM_PJS_PRM_GRID_TYPE );
   attr[IDX_PJS_PRM_GRID_TYPE].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_PRM_GRID_TYPE].desc.value.att_exp = (IGRdouble) is_selected;

   FIg_get_text( form, G_PRIMARY_SPACING, stat );
   strcpy( attr[IDX_PJS_PRM_SPACING].name, NAM_PJS_PRM_SPACING );
   attr[IDX_PJS_PRM_SPACING].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_PRM_SPACING].desc.value.att_exp = atof( stat );

   if( is_selected == IDX_PJS_FREE_GRID && 
	attr[IDX_PJS_PRM_SPACING].desc.value.att_exp < 0.1 )
   {
	message_bar("Enter Proper Primary Spacing Value" );
	return 1;
   }

   FIg_get_state( form, G_SECONDARY_DIR, &is_selected );
   if( is_selected )	is_selected = 0;
   else			is_selected = 1;
   if( is_selected && secondary_frame.obj_id.objid == NULL_OBJID )
   {
        message_bar( "Select Secondary Frame" );
        return 1;
   }

   strcpy( attr[IDX_PJS_SCD_SELCTED].name, NAM_PJS_SCD_SELECTED );
   attr[IDX_PJS_SCD_SELCTED].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_SCD_SELCTED].desc.value.att_exp =  is_selected;

   FIg_get_state( form, G_SECONDARY_GRID, &is_selected );
   strcpy( attr[IDX_PJS_SCD_GRID_TYPE].name, NAM_PJS_SCD_GRID_TYPE );
   attr[IDX_PJS_SCD_GRID_TYPE].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_SCD_GRID_TYPE].desc.value.att_exp = (IGRdouble) is_selected; 

   FIg_get_text( form, G_SECONDARY_SPACING, stat );
   strcpy( attr[IDX_PJS_SCD_SPACING].name, NAM_PJS_SCD_SPACING );
   attr[IDX_PJS_SCD_SPACING].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_SCD_SPACING].desc.value.att_exp = atof( stat );

   if( 	attr[IDX_PJS_SCD_SELCTED].desc.value.att_exp == 1.0 &&
	is_selected == IDX_PJS_FREE_GRID && 
        attr[IDX_PJS_SCD_SPACING].desc.value.att_exp < 0.1 )
   {
        message_bar("Enter Proper Secondary Spacing Value" );
        return 1;
   }

   FIg_get_state( form, G_EDGE_TEMPLATE, &is_selected );
   if( is_selected )    is_selected = 0;
   else                 is_selected = 1;
   strcpy( attr[IDX_PJS_SCD_EDGE_TEMP].name, NAM_PJS_SCD_EDGE_TEMP );
   attr[IDX_PJS_SCD_EDGE_TEMP].desc.type = AC_ATTRIB_DOUBLE;
   attr[IDX_PJS_SCD_EDGE_TEMP].desc.value.att_exp = (IGRdouble) is_selected;

   ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, NB_PJS_ATTR, attr ),
                targetid = boxID->objid,
                targetos = boxID->osnum );

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = boxID->objid,
                targetos = boxID->osnum );

   return 1;
}

FramesInDifferentDir()
{
BSrc			rc;
IGRdouble		dotp;
IGRpoint		point;
IGRvector		primary_vector, secondary_vector;
struct GRobj_env	footOE;
struct IGRplane		primary_plane, secondary_plane;

    primary_plane.point  = point;
    primary_plane.normal = primary_vector;

    secondary_plane.point  = point;
    secondary_plane.normal = secondary_vector;

    vdobj$GetFoot( objOE    = &primary_frame,
		   footName = "plane",
		   footOE   = &footOE );

    ci$send( msg = message GRvg.GRdetplane( &msg, 
				&footOE.mod_env.md_env.matrix_type, 
				footOE.mod_env.md_env.matrix,
				&primary_plane ),
		targetid = footOE.obj_id.objid,
                targetos = footOE.obj_id.osnum );

    vdobj$GetFoot( objOE    = &secondary_frame,
                   footName = "plane",
                   footOE   = &footOE );

    ci$send( msg = message GRvg.GRdetplane( &msg, 
                                &footOE.mod_env.md_env.matrix_type, 
                                footOE.mod_env.md_env.matrix,
                                &secondary_plane ),
                targetid = footOE.obj_id.objid,
                targetos = footOE.obj_id.osnum );

    dotp = BSdotp( &rc, primary_vector, secondary_vector ) ;
    if( dotp < 0.0 )	dotp = -1*dotp ;

    if( dotp > 0.5 )
    {
	message_bar( 
	   "Primary and Secondary Frames must be in Different Directions" );
	return 0;
    }

    return 1;

}

CreateJigAndApplySymb( numTemp, TemplList )
IGRint			numTemp;
struct GRid		*TemplList;
{
IGRlong			sts, msg;
struct GRid		platejig;
struct GRsymbology      loc_symb;

   platejig.objid = NULL_OBJID;
   platejig.osnum = loc_env.md_id.osnum;

   sts = ci$send(msg = message  nci_macro.init(
                  &msg, 0, "platejig", numTemp, TemplList,
                  NULL, &loc_env ),
         targetid = platejig.objid,
         targetos = platejig.osnum );
   if( sts&1&msg )
   {
       loc_symb.level               = 211;
       loc_symb.display_attr.color  =  20;
       loc_symb.display_attr.weight =   0;
       loc_symb.display_attr.style  =   0;

       ci$send ( msg = message GRvg.GRputsymb ( &msg, &loc_symb ),
                 targetid = platejig.objid,
                 targetos = platejig.osnum );
       jig_cnt = jig_cnt + 1 ;
   }
   else
   {
       VSbulkDeleteByGRids( &loc_env, 1, &platejig );
   }
}

CreateFreeJigs( frmOE, direction, spacing )
struct GRobj_env	*frmOE;
IGRint			direction;
IGRdouble		spacing;
{
IGRlong			sts, msg;
IGRint			i, j, negative, positive, locNum, jig_side;
IGRchar			stat[128];
struct GRobj_env	loc_plateOE[20];
struct GRid		singleBox, mulBox, TEMP[23];
struct ACrg_coll	pj_attr[2];

   ASmake_source_from_env( &platejig_mgr, &loc_env, &TEMP[0] );

   strcpy( pj_attr[0].name, NAM_PJS_JIGSIDE );
   VLpjGetNamedAttibute( &msg, &platejig_mgr, pj_attr );
   jig_side = (IGRint)pj_attr[0].desc.value.att_exp;

   strcpy( pj_attr[0].name, NAM_PJS_DIRECTION );
   pj_attr[0].desc.type = AC_ATTRIB_DOUBLE;
   pj_attr[0].desc.value.att_exp =  direction;

   strcpy( pj_attr[1].name, NAM_PJS_PLATESIDE );
   pj_attr[1].desc.type = AC_ATTRIB_TEXT;
   if( jig_side == IDX_PJS_INSIDE )
        strcpy( pj_attr[1].desc.value.att_txt, VS_K_plTopSfPath );
   else strcpy( pj_attr[1].desc.value.att_txt, VS_K_plBotSfPath );

   singleBox.objid = NULL_OBJID;
   singleBox.osnum = loc_env.md_id.osnum;

   ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 2, pj_attr ),
                targetid = singleBox.objid,
                targetos = singleBox.osnum );

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = singleBox.objid,
                targetos = singleBox.osnum );

  if( jig_side == IDX_PJS_BOTH )
  {
      strcpy( pj_attr[1].name, NAM_PJS_PLATESIDE );
      pj_attr[1].desc.type = AC_ATTRIB_TEXT;
      strcpy( pj_attr[1].desc.value.att_txt, VS_K_plTopSfPath );

      mulBox.objid = NULL_OBJID;
      mulBox.osnum = loc_env.md_id.osnum;

      ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 2, pj_attr ),
                targetid = mulBox.objid,
                targetos = mulBox.osnum );

      ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = mulBox.objid,
                targetos = mulBox.osnum );
  }

   VLpjGetFramesInFreeGrid( &msg, frmOE, num_plts, plt_list, spacing, 
		&negative, &positive, NULL, NULL, NULL );
   if( (negative<0) || (positive<0) )    goto wrapup;

   for( i=(-1*negative); i<(positive+1); i=i+1 )
   {
        if( direction == PJS_PRIMARY_DIR )
           sprintf( stat, "Creating Jigs in Primary Direction(Free Grid): %d / %d", i+negative+1, negative+positive+1 );
        else sprintf( stat, "Creating Jigs in Secondary Direction(Free Grid): %d / %d", i+negative+1, negative+positive+1 );
        message_bar( stat );

        locNum = 0;
        TEMP[1] = singleBox;
        VLpjGetFramesInFreeGrid( &msg, frmOE, num_plts, plt_list, spacing,
                                 NULL, NULL, &i, &locNum, loc_plateOE );
        if( locNum )
        {
            sts = exp$create( exp_value  = (IGRdouble) i,
                              osnum      = loc_env.md_id.osnum,
                              p_exp_id   = &TEMP[2].objid,
                              p_osnum    = &TEMP[2].osnum   );

            for( j=0; j<locNum; j=j+1 )
            {
               ASmake_source_from_env(  &loc_plateOE[j].obj_id,
                                        &loc_env, &TEMP[j+3]);
            }

	    CreateJigAndApplySymb( locNum+3, TEMP );

      	    if( jig_side == IDX_PJS_BOTH )
      	    {
         	TEMP[1] = mulBox;
		CreateJigAndApplySymb( locNum+3, TEMP );
      	    }
	}
   }

wrapup:
   return 1;
}

CreateFixedJigs( frmOE, direction )
struct GRobj_env	*frmOE;
IGRint			direction;
{
IGRlong			sts, msg;
IGRint			i, j, locNum, frmCnt, jig_side;
IGRboolean		in_range;
IGRchar			stat[128], side[40];
struct GRobj_env	loc_frmOE;
struct GRid		*frmList, singleBox, mulBox, TEMP[23];
struct ACrg_coll        pj_attr[2];

   frmCnt  = 0;
   frmList = NULL;

   ASmake_source_from_env( &platejig_mgr, &loc_env, &TEMP[0] );

   strcpy( pj_attr[0].name, NAM_PJS_JIGSIDE );
   VLpjGetNamedAttibute( &msg, &platejig_mgr, pj_attr );
   jig_side = (IGRint)pj_attr[0].desc.value.att_exp;

   strcpy( pj_attr[0].name, NAM_PJS_DIRECTION );
   pj_attr[0].desc.type = AC_ATTRIB_DOUBLE;
   pj_attr[0].desc.value.att_exp =  direction;

   strcpy( pj_attr[1].name, NAM_PJS_PLATESIDE );
   pj_attr[1].desc.type = AC_ATTRIB_TEXT;
   if( jig_side == IDX_PJS_INSIDE ) 
	strcpy( pj_attr[1].desc.value.att_txt, VS_K_plTopSfPath );
   else strcpy( pj_attr[1].desc.value.att_txt, VS_K_plBotSfPath );

   singleBox.objid = NULL_OBJID;
   singleBox.osnum = loc_env.md_id.osnum;

   ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 2, pj_attr ),
                targetid = singleBox.objid,
                targetos = singleBox.osnum );

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = singleBox.objid,
                targetos = singleBox.osnum );

  if( jig_side == IDX_PJS_BOTH )
  {
      strcpy( pj_attr[1].name, NAM_PJS_PLATESIDE );
      pj_attr[1].desc.type = AC_ATTRIB_TEXT;
      strcpy( pj_attr[1].desc.value.att_txt, VS_K_plTopSfPath );

      mulBox.objid = NULL_OBJID;
      mulBox.osnum = loc_env.md_id.osnum;

      ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 2, pj_attr ),
                targetid = mulBox.objid,
                targetos = mulBox.osnum );

      ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = mulBox.objid,
                targetos = mulBox.osnum );
  }

   VLpjGetFramesInPlatesRange( 	&msg, frmOE, num_plts, plt_list, NULL,
				&frmCnt, &frmList );

   for( i=0; i<frmCnt; i=i+1 )
   {
      in_range = FALSE;
      locNum   = 0;
      loc_frmOE.obj_id  = frmList[i];
      loc_frmOE.mod_env = frmOE->mod_env ;

      TEMP[1] = singleBox;

      if( direction == PJS_PRIMARY_DIR )
	 sprintf( stat, "Creating Jigs in Primary Direction(Fixed Grid): %d / %d", i+1, frmCnt );
      else sprintf( stat, "Creating Jigs in Secondary Direction(Fixed Grid): %d / %d", i+1, frmCnt );
      message_bar( stat );

      ASmake_source_from_env( &frmList[i], &loc_env, &TEMP[2] );
      for( j=0; j<num_plts; j=j+1 )
      {
          in_range = FALSE;
          VLpjGetFramesInPlatesRange( &msg, &loc_frmOE, 1, &plt_list[j],
                                      &in_range, NULL, NULL );

          if( in_range )
          {
             ASmake_source_from_env( &plt_list[j].obj_id,
                              &loc_env, &TEMP[locNum+3]);
             locNum = locNum + 1 ;
          }
      }

      if( !locNum ) continue;

      CreateJigAndApplySymb( locNum+3, TEMP );

      if( jig_side == IDX_PJS_BOTH )
      {
	 TEMP[1] = mulBox;
	 CreateJigAndApplySymb( locNum+3, TEMP );
      }
   }	
   
wrapup:
   if( frmList ) { free( frmList ); frmList = NULL; }
   return 1;
}

CreateJigsOnEdges()
{
IGRlong			sts;
IGRint			i, num_ft, jig_side;
IGRchar			foot_name[40], side[40];
struct ACrg_coll        pj_attr[2];
struct GRid		singleBox, mulBox, TEMP[3];
struct GRobj_env	footOE;

   ASmake_source_from_env( &platejig_mgr, &loc_env, &TEMP[0] );

   strcpy( pj_attr[0].name, NAM_PJS_JIGSIDE );
   VLpjGetNamedAttibute( &msg, &platejig_mgr, pj_attr );
   jig_side = (IGRint)pj_attr[0].desc.value.att_exp;

   strcpy( pj_attr[0].name, NAM_PJS_DIRECTION );
   pj_attr[0].desc.type = AC_ATTRIB_DOUBLE;
   pj_attr[0].desc.value.att_exp =  PJS_EDGE_JIG;

   strcpy( pj_attr[1].name, NAM_PJS_PLATESIDE );
   pj_attr[1].desc.type = AC_ATTRIB_TEXT;
   if( jig_side == IDX_PJS_INSIDE )
        strcpy( pj_attr[1].desc.value.att_txt, VS_K_plTopSfPath );
   else strcpy( pj_attr[1].desc.value.att_txt, VS_K_plBotSfPath );

   singleBox.objid = NULL_OBJID;
   singleBox.osnum = loc_env.md_id.osnum;

   ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 2, pj_attr ),
                targetid = singleBox.objid,
                targetos = singleBox.osnum );

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = singleBox.objid,
                targetos = singleBox.osnum );

   if( jig_side == IDX_PJS_BOTH )
   {
      strcpy( pj_attr[1].name, NAM_PJS_PLATESIDE );
      pj_attr[1].desc.type = AC_ATTRIB_TEXT;
      strcpy( pj_attr[1].desc.value.att_txt, VS_K_plTopSfPath );

      mulBox.objid = NULL_OBJID;
      mulBox.osnum = loc_env.md_id.osnum;

      ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 2, pj_attr ),
                targetid = mulBox.objid,
                targetos = mulBox.osnum );

      ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = mulBox.objid,
                targetos = mulBox.osnum );
   }

   sts = vdchn$GetList( objID   = &platejig_mgr,
                        chnName = VDCHN_NAME_TO_COMPONENTS,
                        maxCnt  = 100,
                        cnt     = &num_ft );

   for( i=0; i<num_ft; i=i+1 )
   {
      sprintf( foot_name, "Edge%d", i );
      vdobj$GetFoot( objID    = &platejig_mgr,
		     footName = foot_name,
		     footOE   = &footOE  );
      if( footOE.obj_id.objid == NULL_OBJID ) continue;

      if( VD_is_ancestry_valid( &footOE.obj_id, OPP_expression_class_id ) )
      {	
	 TEMP[1] = mulBox;
         continue;
      }
      else	TEMP[1] = singleBox;

      ASmake_source_from_env( &footOE.obj_id, &loc_env, &TEMP[2] );

      CreateJigAndApplySymb( 3, TEMP );
   }

wrapup:
   return 1;
}

CreateJigs()
{
IGRlong			sts, msg;
IGRint			i, grid_type;
IGRdouble		spacing;
struct GRid             TEMP[23];
struct GRobj_env	frmOE;
struct ACrg_coll	attrib;

    if( platejig_mgr.objid == NULL_OBJID ) goto wrapup;

    for( i=0; i<2; i=i+1 )
    {
	if( i == 0 )	
        {
	   frmOE = primary_frame;
           strcpy( attrib.name, NAM_PJS_PRM_GRID_TYPE );
           VLpjGetNamedAttibute( &msg, &platejig_mgr, &attrib );
           grid_type = (IGRint) attrib.desc.value.att_exp ;

	   if( grid_type == IDX_PJS_FREE_GRID )
	   {
              strcpy( attrib.name, NAM_PJS_PRM_SPACING );
              VLpjGetNamedAttibute( &msg, &platejig_mgr, &attrib );
              spacing = attrib.desc.value.att_exp ;
	   }
        } 
	else if( secondary_frame.obj_id.objid != NULL_OBJID ) 
	{
	   frmOE = secondary_frame;

           strcpy( attrib.name, NAM_PJS_SCD_GRID_TYPE );
           VLpjGetNamedAttibute( &msg, &platejig_mgr, &attrib );
           grid_type = (IGRint) attrib.desc.value.att_exp ;

	   if( grid_type == IDX_PJS_FREE_GRID )
	   {
	      strcpy( attrib.name, NAM_PJS_SCD_SPACING );
              VLpjGetNamedAttibute( &msg, &platejig_mgr, &attrib );
              spacing = attrib.desc.value.att_exp ;
	   }
	}
	else continue;

	if( grid_type == IDX_PJS_FREE_GRID )
		CreateFreeJigs(  &frmOE, i, spacing );
	else    CreateFixedJigs( &frmOE, i );
    }

    if( (IGRint) attr[IDX_PJS_SCD_EDGE_TEMP].desc.value.att_exp == 1 )
	CreateJigsOnEdges();

wrapup:
    return 1;
}

PlacePlateJigSet()
{
IGRint			i;
IGRchar			pplName[128], stat[128];
struct GRid             boxID, TEMP[23];
struct GRsymbology      loc_symb;
struct GRobj_env	MgrOE;

   if( num_plts < 1 )
   {
	message_bar( "Select Plates" );
	goto wrapup;
   }

   if( primary_frame.obj_id.objid == NULL_OBJID ) 
   {
	message_bar( "Select Primary Frame" );
	goto wrapup;
   }
   ASmake_source_from_env( &primary_frame.obj_id, &loc_env, &TEMP[0] );

   CreateAttribuiteCollector( &boxID );
   if( boxID.objid == NULL_OBJID ) goto wrapup;
   ASmake_source_from_env( &boxID, &loc_env, &TEMP[2] );

   if( attr[IDX_PJS_SCD_SELCTED].desc.value.att_exp == 1.0 )
   {
     if( !FramesInDifferentDir() ) goto wrapup;
     ASmake_source_from_env( &secondary_frame.obj_id, &loc_env, &TEMP[1] );
   }
   else
   {
       secondary_frame.obj_id.objid = NULL_OBJID;
       exp$create( exp_syntax = "dummy",
                   type_rq    = EXP_TEXT,
                   osnum      = loc_env.md_id.osnum,
                   p_exp_id   = &TEMP[1].objid,
                   p_osnum    = &TEMP[1].osnum   );
   }

   for( i=0; i<num_plts; i=i+1 )
	ASmake_source_from_env( &plt_list[i], &loc_env, &TEMP[i+3] );

   platejig_mgr.objid = NULL_OBJID;
   platejig_mgr.osnum = loc_env.md_id.osnum;

   ci$send(msg = message  nci_macro.init(
                        &msg, 0, "platejigmgr", num_plts+3, TEMP,
                        NULL, &loc_env ),
                targetid = platejig_mgr.objid,
                targetos = platejig_mgr.osnum );

   loc_symb.level               = 211;
   loc_symb.display_attr.color  =  20;
   loc_symb.display_attr.weight =   2;
   loc_symb.display_attr.style  =   0;

   ci$send ( msg = message GRvg.GRputsymb ( &msg, &loc_symb ),
                        targetid = platejig_mgr.objid,
                        targetos = platejig_mgr.osnum );

   CreateJigs();

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = platejig_mgr.objid,
                targetos = platejig_mgr.osnum );

   if( jig_cnt == 0 )
   {
      VSbulkDeleteByGRids( &loc_env, 1, &platejig_mgr );
      UI_status("Placement of Plate Jig Set Failed" );
      message_bar( "Placement of Plate Jig Set Failed" );
      goto wrapup;
   }

   if( VSisLoggedIntoRDB() )
   {
       MgrOE.obj_id  = platejig_mgr ;
       MgrOE.mod_env = loc_env;

       FIg_get_text( form, G_POST_PLACEMENT, pplName );

       sprintf( stat, "Executing %s", pplName );

       message_bar( stat );

       vd$ppl_set_size(  which_info = INPUT_INFO,
                         size       = 1              );

       vd$ppl_setarg_at_index( which_info = INPUT_INFO,
                               index = 0,
                               type  = VD_object,
                               value = &MgrOE );

       ci$exec( file_name = pplName );

       vd$ppl_free_args( which_info = INPUT_INFO );
   }

   return 1;

wrapup:
   return 0;
}

int main()
{
IGRlong         msg;
IGRint          sts, response, i, j, multi_select, row, col, pos, is_selected,
		grid_type;
IGRchar		frm_name[128], *p;
struct GRobj_env *list;

  test_wakeup = 1;              /* flag for wakeup function */
  form_exists = FALSE;          /* flag for delete function */
  form_displayed = FALSE;       /* flag for sleep  function */
  not_done  = TRUE;             /* Set this to FALSE when done with form */
  list = NULL;
  jig_cnt = 0;
  platejig_mgr.objid = NULL_OBJID ;
  primary_frame.obj_id.objid = NULL_OBJID ;
  secondary_frame.obj_id.objid = NULL_OBJID ;

  VLinitCnst( &cnst );
  ci$get_module_info( md_env = &loc_env);

  message( COMMAND_NAME );

  sts = init_form();
  if (!(sts & 1)) goto wrapup;

  while (not_done )
  {
    /* Suspend the command file and wait for the form */
    ci$get (  prompt   = "Fill in the form",
              response = &response );

    UI_status(""); /* clear the status field*/
    message_bar("");
    switch ( form_st.gadget_label )
    {
       case FI_CANCEL:
       {
           dp$erase_hilite( msg = &msg );
           not_done = FALSE;
           FIf_erase ( form );
           break;
       }

       case FI_ACCEPT:
       {
           dp$erase_hilite( msg = &msg );
           if( PlacePlateJigSet() )
           {
              not_done = FALSE;
              FIf_erase ( form );
           }
           else FIg_set_state_off( form, FI_ACCEPT );
           break;
       }

       case G_PLATE_LOCATE:
       {
           plate.obj_id.objid = NULL_OBJID ;
           num_pl = 0 ;
           j = 0;
           multi_select = 0 ;
           LocatePlates( "Identify Plate or Move on", &num_pl,
                         &list, &plate );
           if( plate.obj_id.objid != NULL_OBJID || num_pl != 0 )
           {
             if( plate.obj_id.objid == NULL_OBJID )
             {
                plate = list[j];
                j = j+ 1;
                multi_select = 1;
             }

pl_loop:
             for( i=0; i<num_plts; i=i+1 )
             {
                if( plt_list[i].obj_id.objid == plate.obj_id.objid &&
                    plt_list[i].obj_id.osnum == plate.obj_id.osnum )
                 break;
             }
             if( i != num_plts )
             {
                message_bar("Plate is already selected" );
                UI_status("Plate is already selected");
             }
             else if( num_plts == 20 )
             {
                message_bar("Maxinum number of plates locatable: 20" );
                UI_status("Maxinum number of plates locatable: 20");
             }
             else
             {
                GetName( plate.obj_id, plt_name );
                p = strstr( plt_name, ":ref:" );
                if( p ) strcpy( plt_name, p+4 );
                FIfld_set_text( form, G_PLATE_LIST, num_plts, 0,
                                plt_name, FALSE );
                plt_list[num_plts] = plate ;
                num_plts = num_plts + 1 ;
             }
             if( multi_select && j < num_pl )
             {
                plate = list[j];
                j = j + 1;
                goto pl_loop;
             }
           }
           FIg_set_state_off( form, G_PLATE_LOCATE );
           if( list ) { free ( list ); list = NULL; }
           break;
       }

       case G_PLATE_REMOVE:
       {
         dp$erase_hilite( msg = &msg );
         j = 0;
         for( i=0; i<num_plts; i=i+1 )
         {
           FIfld_get_select( form, G_PLATE_LIST, i, 0, &pos);
           if( !pos )
           {
                plt_list[j].obj_id.objid = plt_list[i].obj_id.objid;
                j = j + 1 ;
           }
         }

         FIfld_delete_rows( form, G_PLATE_LIST, 0, num_plts );
         num_plts = j ;

         for( i=0; i<num_plts; i=i+1 )
         {
           GetName( plt_list[i].obj_id, plt_name );
           p = strstr( plt_name, ":ref:" );
           if( p ) strcpy( plt_name, p+4 );
           FIfld_set_text( form, G_PLATE_LIST, i, 0,
                           plt_name, FALSE );
         }

         FIg_set_state_off( form, G_PLATE_REMOVE );
         break;
       }

       case G_PLATE_LIST:
       {
           VIfld_get_active_row( form, G_PLATE_LIST, &row, &pos);
           FIfld_get_select( form, G_PLATE_LIST, row, 0, &pos);
           if( pos )
           {
             FIfld_set_select( form, G_PLATE_LIST, row, 0, TRUE );
             VSbulkDisplayByGRobj_envs( GRhd, 1, &plt_list[row] );
           }
           else
           {
             FIfld_set_select( form, G_PLATE_LIST, row, 0, FALSE );
             VSbulkDisplayByGRobj_envs( GRhe, 1, &plt_list[row] );
           }
           break;
       }
       case G_PRIMARY_REFPLANE:
       {
           LocateFrame( "Identify Primary Frame / Move on",
                        &primary_frame, frm_name, FALSE );
           __DBGpr_obj("Located Primary Frame ", primary_frame.obj_id );
	   if( primary_frame.obj_id.objid != NULL_OBJID )
  	   {
               FIg_set_text( form, G_PRIMARY_REFNAME, 
				strrchr( frm_name, ':' )+1 );
 	   }
           FIg_set_state_off( form, G_PRIMARY_REFPLANE );
	   break;
       }
       case G_SECONDARY_REFPLANE:
       {
           LocateFrame( "Identify Secondary Frame / Move on", 
                        &secondary_frame, frm_name, FALSE );
           __DBGpr_obj("Located Secondary Frame ", secondary_frame.obj_id );
           if( secondary_frame.obj_id.objid != NULL_OBJID )
           {
               FIg_set_text( form, G_SECONDARY_REFNAME, 
                                strrchr( frm_name, ':' )+1 );
	   }
           FIg_set_state_off( form, G_SECONDARY_REFPLANE );
           break;
       }
       case G_SECONDARY_DIR:
       {
	   FIg_get_state( form, G_SECONDARY_DIR, &is_selected );
	   if( is_selected )
	   {
	       FIg_disable( form, G_SECONDARY_GRID );
	       FIg_disable( form, G_SECONDARY_SPACING );
	       FIg_disable( form, G_SECONDARY_REFPLANE );
	       FIg_disable( form, G_SECONDARY_REFNAME );
           }
	   else
           {
               FIg_enable( form, G_SECONDARY_GRID );
	       FIg_get_state( form, G_SECONDARY_GRID, &grid_type );
               if( grid_type == IDX_PJS_FREE_GRID )
			FIg_enable( form, G_SECONDARY_SPACING );
               FIg_enable( form, G_SECONDARY_REFPLANE );
               FIg_enable( form, G_SECONDARY_REFNAME );
           }
	   break;
       }
       case G_SECONDARY_GRID:
       {
	   FIg_get_state( form, G_SECONDARY_GRID, &grid_type );
	   if( grid_type == IDX_PJS_FREE_GRID ) 
			FIg_enable( form, G_SECONDARY_SPACING );
	   else		FIg_disable( form, G_SECONDARY_SPACING );
           break;
       }
       case G_PRIMARY_GRID:
       {
           FIg_get_state( form, G_PRIMARY_GRID, &grid_type );
           if( grid_type == IDX_PJS_FREE_GRID )
                        FIg_enable( form, G_PRIMARY_SPACING );
           else         FIg_disable( form, G_PRIMARY_SPACING );
           break;
       }
    }
  }

wrapup:
  if( list ) { free ( list ); list = NULL; }
  return 1;
}

init()
{
  form = NULL;
}

int init_form()
{
IGRint  sts, retFlag;
Form    existingForm;

  retFlag = 0;
  sts = VI_get_form_by_name(FORM_NAME, &existingForm);
  if (sts == FI_SUCCESS)
  {
      UI_status("Place Plate Jig Set command is active" );
      return 0;
  }

  VIf_new(100, FORM_NAME, ci_notification, &form);
  if (form == NULL)
  {
      printf("Can not Initialize the Form\n" );
      goto wrapup;
  }
  form_exists = TRUE;  /* Flag for delete function */
  VDahFrmLoadPositionFromFile( form );
  VIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );

  VIf_display( form );

  FIg_set_text( form, G_POST_PLACEMENT, "VLpppJig" );

  FIg_disable( form, G_SECONDARY_GRID );
  FIg_disable( form, G_SECONDARY_SPACING );
  FIg_disable( form, G_SECONDARY_REFPLANE );
  FIg_disable( form, G_SECONDARY_REFNAME );

  FIg_set_value( form, G_EXTENSION, 0.0 );
  FIg_set_value( form, G_CORNER_RADIUS, 0.0 );
  FIg_set_value( form, G_MINIMUM_HEIGHT, 4000.0 );

  form_displayed = TRUE;  /* Flag for sleep function */

  retFlag = 1;

wrapup:
  return retFlag;
}

/* ---------------------------------
 * Gadget handling
 */
form_notification()
{
  ci$put( response = MOVE_ON );  /* Give control to the main function */
  return 1;
}
