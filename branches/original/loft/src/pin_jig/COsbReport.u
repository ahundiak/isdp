/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/pin_jig/COreportSB.u
 *
 * Description: generate a STRUDEL driven report on ISDP\Loft Steel Bands.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/23/00        MF        	File Creation.
 *	06/14/00	RR		Modified the ppl to take steel_band.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "vscmd.h"
#include "coparamac.h"
#include "growner.h"
#include "AS_status.h"
#include "vlquerydef.h"

extern		ASstart_var_fence(), ASend_fence(), VScreateFileForm(),
		VLexecSteelBandList(), VLgetMacrosAtStep(),VLbrowseFctInTree(),
		VLfilterDef(), VDSloadMacroLibrary();

#define theCommand "Report Steel Bands"
#define thePrompt  "Select Neat Contour / Steel Bands"

IGRchar curPATH[MAXPATHLEN + 1];
IGRchar	curNAME[FILENAME_MAX+1];
IGRchar	curRGXP[VS_K_MAX_RGXP];

IGRint GetNeatContours( count, list )
	IGRint                  *count;
	struct GRobj_env	*list;
{
IGRint			i, j, loc_cnt;
IGRchar			macName[128];
struct GRobj_env	parentOE, neatOE;

   loc_cnt = 0;
   for( i=0; i<(*count); i=i+1 )
   {
	vdobj$Get( objID   = &list[i].obj_id,
		   macName = macName );

	if( !strcmp( macName, "neat_cont" ) ) 
	{
	   for( j=0; j<loc_cnt; j=j+1 )	
	   {
		if( list[i].obj_id.objid == list[j].obj_id.objid &&
		    list[i].obj_id.osnum == list[j].obj_id.osnum )
		break;
	   }
	   if( j != loc_cnt ) continue;
	   list[loc_cnt] = list[i] ;
	   loc_cnt = loc_cnt + 1 ;
	   continue;
	}

	if( strcmp( macName, "steel_band" ) ) continue;

	vdobj$GetTemplate( objOE      = &list[i],
			   nth        = 0,
			   templateOE = &parentOE );

         vdchn$GetList(  objOE   = &parentOE,
                         chnIDx  = VDCHN_IDX_TO_OWNERS,
                         maxCnt  = 1,
                         cnt     = &i,
                         outIDs  = &neatOE );

	for( j=0; j<loc_cnt; j=j+1 )
	{
            if( neatOE.obj_id.objid == list[j].obj_id.objid &&
                neatOE.obj_id.osnum == list[j].obj_id.osnum )
            break;
	}
        if( j != loc_cnt ) continue;

	list[loc_cnt] = neatOE;
	loc_cnt = loc_cnt + 1 ;
   }
   if( loc_cnt != (*count) ) *count = loc_cnt;
   return 1;
}

IGRint ExtractSteelBands ( numPB, neatOE, numSB, SteelBand )
	IGRint			numPB, *numSB;
	struct	GRobj_env	*neatOE, **SteelBand;
{
	IGRint			sts, i, j, tot, numObjects;
	struct GRobj_env	*list_obj;

	/* Initialize */
	*numSB = 0;
	if ((*SteelBand) != NULL) {
		om$dealloc (ptr = (*SteelBand));
		(*SteelBand) = NULL;
	}
	list_obj = NULL;

	/* Extract SteelBand */
	for ( i=0; i<numPB; i=i+1 ) {
		numObjects = 0;
	        if( list_obj ) { free( list_obj ); list_obj = NULL; } 
   	  	VLbrowseFctInTree( &neatOE[i], VL_Q_TOP_SOURCE, NULL, 
			VL_Q_DOWN_DIRECT, VLgetMacrosAtStep,
			&numObjects, &list_obj );
   	  	VLfilterDef(numObjects,list_obj,&numObjects,"steel_band" );
	
		tot = (*numSB) + numObjects;

		/* Allocate memory */
		if ((*SteelBand) == NULL) {
			(*SteelBand) = (struct GRobj_env *) om$calloc
				( num	    = tot,
				  structure = struct GRobj_env );
		}
		else {	(*SteelBand) = (struct GRobj_env *) om$realloc
				( ptr  = (*SteelBand),
				  size = tot * sizeof(struct GRobj_env) );
		}

		/* Load data */
		for ( j=0; j<numObjects; j=j+1 ) 
			(*SteelBand)[(*numSB) + j] = list_obj[j];

		/* Increment */
		(*numSB) = tot;
	}

wrapup:
	if( list_obj ) { free( list_obj ); list_obj = NULL; }
	return 1;
}

/* --------------------------------------
 * The main routine
 */
int main()
{
	int 			sts, msg, response;
 
	struct	GRobj_env  	oLocate, *oArray, *oSB;
	IGRint      		iArray, i, nSB;

	IGRlong			Sts, Msg;
	VSfileFormInfo		File;

	oSB = NULL;
	nSB = 0;
	Msg = OM_S_SUCCESS;

	strcpy ( curPATH, "." );
	File.curPATH = curPATH;
	strcpy ( curNAME, "" );
	File.curNAME = curNAME;
	strcpy ( curRGXP, "*" );
	File.curRGXP = curRGXP;
	File.callBack   = NULL;
	File.parentForm = NULL;
	strcpy ( File.openMode, "w" );

	VDSloadMacroLibrary( "band_av" );
 
	while(1) {

		VScreateFileForm ( 0, 100, &File);

		oLocate.obj_id.objid = NULL_OBJID;
 
    		response = 0;

		UI_message(theCommand);

		/* Locate plate_band ci_macro(s) */
		sts = ci$locate ( prompt  = thePrompt,
	                    	  classes = "ci_macro",
       		             	  owner_action = LC_RIGID_OWNER |
                                         	 LC_RIGID_COMP  |
                                         	 LC_FLEX_COMP   |
                                         	 LC_FLEX_OWNER  |
                                         	 LC_REF_OBJECTS,

                    	  	  stackable    = 1,
                    	  	  response     = &response,
                    	  	  md_env       = &oLocate.mod_env,
                    	  	  obj          = &oLocate.obj_id.objid,
                    	  	  osnum        = &oLocate.obj_id.osnum );

    		if (!(sts & 1)) response = 0;


    		switch(response) {

    		case EX_OBJID:   // Object Set
      			/* Grab Located Objects */
			as$start_fence( set       = &oLocate.obj_id,
					set_env   = &oLocate.mod_env,
					nb_obj    = &iArray,
					p_obj_env = &oArray);
			Sts = GetNeatContours( &iArray, oArray );
			Sts = ExtractSteelBands ( iArray, oArray, &nSB, &oSB );
			as$status ( sts    = Sts,
				    msg    = "ExtractSteelBands()",
				    test   = (!(Sts & 0x00000001)),
				    action = GOTO_VALUE,
				    value  = wrapup );
			ASend_fence();
      			break;

    		case EX_DATA:    // Single Object
			iArray = 1;
			Sts = GetNeatContours( &iArray, &oLocate );
			Sts = ExtractSteelBands ( 1, &oLocate, &nSB, &oSB );
			as$status ( sts    = Sts,
				    msg    = "ExtractSteelBands()",
				    test   = (!(Sts & 0x00000001)),
				    action = GOTO_VALUE,
				    value  = wrapup );
      			break;

    		} // Switch

		/* Kick-off report */
		Sts = VLexecSteelBandList ( nSB, oSB, &oLocate.mod_env ,
				    	    File ,"RPsetup", &Msg );
		as$status ( sts    = Sts,
			    msg    = "VLexecSteelBandList()",
			    test   = (!(Sts & 0x00000001 & Msg)),
			    action = GOTO_VALUE,
			    value  = wrapup );
		if (oSB == NULL) {
			om$dealloc (ptr = oSB);
			oSB = NULL;
		}
	}

wrapup:
	if (oSB == NULL) {
		om$dealloc (ptr = oSB);
		oSB = NULL;
	}
  	return 1;
}

/* ------------------------------------------
 * Usual command object messages
 */
init()
{
}
sleep()
{
}
wakeup()
{
	UI_message(theCommand);
}
delete()
{
}
