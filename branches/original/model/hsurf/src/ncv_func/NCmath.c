
/*
$Author: hans $
$Revision: 1.1.1.1 $
$Date: 2001/12/17 22:40:39 $
$Locker:  $
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "wl.h"

#include "hnmilling.h"
#include "OMminimum.h"
#include "igetypedef.h"
#include "igrtypedef.h"
#include "igr.h"
#include "hsdisplay.h"
#include "hstiler.h"
#include "hnmill.h"
#include "HSpr_ncv_fun.h"

#define ZERO_TOL   1.0e-5

#define ABS(x)     ( ( x > 0.0 ) ? ( x ) : ( - x ) )                  \

#define NORMALIZE(vector)                                             \
{                                                                     \
   length = sqrt( (vector[0]*vector[0]) + (vector[1]*vector[1]) +     \
             (vector[2]*vector[2]) );                                 \
   vector[0] /= length;                                               \
   vector[1] /= length;                                               \
   vector[2] /= length;                                               \
}

#define CROSS(va, vb, result)                                         \
{                                                                     \
   result[0] =   ( va[1] * vb[2] ) - ( va[2] * vb[1] );               \
   result[1] =   ( va[2] * vb[0] ) - ( va[0] * vb[2] );               \
   result[2] =   ( va[0] * vb[1] ) - ( va[1] * vb[0] );               \
}


/*-----create_rotation_matrix------------------------------------------------*/

void create_rotation_matrix( IGRpoint  x_axis,
                             IGRpoint  y_axis,
                             IGRpoint  z_axis,
                             IGRdouble rotation[3][3] )

/*
 * ABSTRACT:   Create_rotation_matrix creates the matrix that will rotate
 *             points into the given new coordinate system.
 *
 * HISTORY:   07/22/88   Created.         C. M. Jablonski
 *
 */

{
   rotation[0][0] = x_axis[0];
   rotation[0][1] = y_axis[0];
   rotation[0][2] = z_axis[0];

   rotation[1][0] = x_axis[1];
   rotation[1][1] = y_axis[1];
   rotation[1][2] = z_axis[1];

   rotation[2][0] = x_axis[2];
   rotation[2][1] = y_axis[2];
   rotation[2][2] = z_axis[2];
}


/*-----rotate_points---------------------------------------------------------*/

void rotate_points( IGRdouble  rotation[3][3],
                    IGRint     num_points,
                    IGRpoint   *point )

/*
 * ABSTRACT:   Rotate_points rotates the given number of points using the given
 *             rotation matrix.  The rotation matrix is assumed to be of the
 *             form generated by "setup_rotation_matrix."
 *
 * HISTORY:   07/22/88   Created.         C. M. Jablonski
 *
 */

{
   register int   index;
   IGRdouble      x_coord;
   IGRdouble      y_coord;
   IGRdouble      z_coord;

   for ( index=0; index<num_points; index++ )
   {
      x_coord = point[index][0];
      y_coord = point[index][1];
      z_coord = point[index][2];

      point[index][0] = x_coord*rotation[0][0] +
                        y_coord*rotation[1][0] +
                        z_coord*rotation[2][0];

      point[index][1] = x_coord*rotation[0][1] +
                        y_coord*rotation[1][1] +
                        z_coord*rotation[2][1];

      point[index][2] = x_coord*rotation[0][2] +
                        y_coord*rotation[1][2] +
                        z_coord*rotation[2][2];
   }
}


/*-----translate_points-------------------------------------------------------*/

void translate_points( IGRpoint  translation,
                       IGRint    num_points,
                       IGRpoint  *point )



/*
 * ABSTRACT:   Translate_points translates the given number of points using
 *             the given translation vector.
 *
 * HISTORY:   07/22/88   Created.         C. M. Jablonski
 *
 */

{
   register int   index;


   for ( index=0; index<num_points; index++ )
   {
      point[index][0] += translation[0];
      point[index][1] += translation[1];
      point[index][2] += translation[2];
   }
}


/*-----copy_points------------------------------------------------------------*/

void copy_points( IGRint    num_points,
                  IGRint    from_size,
                  IGRint    from_start,
                  IGRpoint  *from_arr,
                  IGRint    to_size,
                  IGRint    to_start,
                  IGRpoint  *to_arr )


/*
 * ABSTRACT: Copy_points copies the points from the given origin array into the
 *           given destination array.  The to and from indexes are given, as
 *           well as the numer of points to be copied and the number of points
 *           in each array.
 *
 * HISTORY:   07/22/88   Created.         C. M. Jablonski
 *
 */

{
   register int  index;
   register int  from_index;
   register int  to_index;
   IGRint        df;
   IGRint        dt;
   IGRint        these_points;

   from_index = from_start;
   to_index = to_start;

   do
   {
      df = from_size - from_index;
      dt = to_size - to_index;

      these_points = num_points;
      if ( df < these_points )
      {
         these_points = df;
      }

      if ( dt < these_points )
      {
         these_points = dt;
      }

      for ( index=0; index<these_points; index++ )
      {
         to_arr[to_index][0] = from_arr[from_index][0];
         to_arr[to_index][1] = from_arr[from_index][1];
         to_arr[to_index][2] = from_arr[from_index][2];

         from_index++;
         to_index++;
      }

      from_index %= from_size;
      to_index %= to_size;

      num_points -= these_points;
   }
   while ( num_points );
}


/*-----generate_orthogonal_basis------------------------------------------------------------*/

void generate_orthogonal_basis( IGRpoint vect,
                                IGRpoint x_axis,
                                IGRpoint y_axis,
                                IGRpoint z_axis )

/*
 * ABSTRACT: Generate_orthogonal_basis generates the unit vectors in a
 *           right-handed coordinate system with the original vector as the
 *           y_axis.
 *
 * HISTORY:   07/22/88   Created.         C. M. Jablonski
 *
 */

{
   IGRdouble   length;

   /* generate the y_axis */
   y_axis[0] = vect[0];
   y_axis[1] = vect[1];
   y_axis[2] = vect[2];
   NORMALIZE( y_axis )

   /* generate the x_axis */
   z_axis[0] = 0.0;
   z_axis[1] = 0.0;
   z_axis[2] = 1.0;

   CROSS( y_axis, z_axis, x_axis )

   if ( (ABS(x_axis[0])<ZERO_TOL) &&
        (ABS(x_axis[1])<ZERO_TOL) &&
        (ABS(x_axis[2])<ZERO_TOL) )
   {
      x_axis[1] = 1.0;
   }

   NORMALIZE( x_axis )

   /* generate the z_axis */
   CROSS( x_axis, y_axis, z_axis )
   NORMALIZE( z_axis )
}
