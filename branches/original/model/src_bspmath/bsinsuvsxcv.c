/*

Copyright (C) 1996, 1997, Intergraph Corporation. All rights reserved.

Name
    BSinsuvsxcv

Abstract
    This routine inserts points to be inserted between a set of points on an
    intersection curve, stroked to be within model space cht_tol, so that the 
    corresponding uv linestring will be within uv space cht_tol.

Synopsis
    void BSinsuvsxcv(sf, num_pts, uvpars, cv, cvpars, lgd_flag, lgd_cv,n,
                     insert, rc)
    struct BSgeom_bsp_surf  *sf
    IGRint                  num_pts
    BSpair                  *uvpars
    struct IGRbsp_curve     *cv
    IGRdouble               *cvpars
    IGRboolean              lgd_flag
    struct
       BScmplgd_cv            *lgd_cv
    IGRint                  n
    IGRint                  *insert
    BSrc                    *rc

Description
    Input:
       sf.............geometric surface structure
       num_pts........number of points 
       uvpars.........uv parameters corresponding to points
       cv.............B-spline curve structure for intersection curve
       cvpars.........curve parameters of pts on cv
       lgd_flag.......flag indicating if cv was generated by Legendre 
                      polynomials:
                       TRUE : Legendre 
                       FALSE: otherwise
       lgd_cv.........Legendre curve structure (BScmplgd_cv) corresponding 
                      to cv input only if lgd_flag = TRUE
       n..............The nth Legendre curve in lgd_cv to be processed

    Output:
       insert........array of number of points to insert between each point
                     of points array

Return Values
     BSSUCC is returned if all is successful.

Notes
     Memory for insert must be provided by calling routine. Maximum
     size = num_pts - 1.
    
    
Index
    em

Keywords

History
    S.C. Wood      12/02/92  : Creation date.
    S.C. Wood      12/18/92  : Modified to find the parametric distance from 
                               the line between uvpars[i] and uvpars[i+1] to 
                               the uv of the mid point based on pts[i] and
                               pts[i+1]. Previously, found parametric
                               distance from mid-paramter of uvpars[i] and
                               uvpars[i+1] to the mid point based on pts[i]
                               and pts[i+1].  Restructured loops used in
                               determining number of uv's to insert.
    Vivian Y.Hsu   01/24/95  : Changed structure of lgd_cv. Added one 
                               input argument "n" to indicate the nth
                               curve in lgd_cv to be processed.
    Vivian Y.Hsu   03/14/97  : For case of Legender curve as input,make 
                               same modification as S.C.Wood made to
                               B-spline curve on 12/18/92. So we are able
                               to get consistent results from both case.
*/
#include <math.h>
#include "bsdefs.h"
#include "bserr.h"
#define BSVOID
#define MAXNUM 100
#include "bsparameters.h"
#include "bsgeom_cvsf.h"
#include "bsstackalloc.h"
#include "bsplpchlgd.h"

void BSinsuvsxcv(
struct BSgeom_bsp_surf  *sf,
IGRint                  num_pts,
BSpair                  *uvpars,
struct IGRbsp_curve     *cv,
IGRdouble               *cvpars,
IGRboolean              lgd_flag,
struct BScmplgd_cv        *lgd_cv,
IGRint                  n,
IGRint                  *insert,
BSrc                    *rc)
{
#include "bsdbgrc.h"
#include "bsvalues.h"
#include "bscveval.h"
#include "bsdistptpt.h"
#include "bsprptsgmsf.h"
#include "bsprptsonsf.h"
#include "bssfkttol2.h"
#include "bschgdeppar.h"
#include "bsredwrkcv1.h"
#include "bsredstrcv1.h"
#include "bshornlgd.h"
#include "bsqdsfflag.h"
#include "bscvarrev0.h"
   IGRint     i, npts;
   IGRdouble  dist, cht_sf_kttol, chrdht_tol, basis_tol;
   BSpair     *midcvpt_uv=NULL, midcvpt_uv2[MAXNUM];
   IGRdouble  *mid_cvpar=NULL, mid_cvpar2[MAXNUM];
   IGRdouble  *midcv_pt=NULL, midcv_pt2[MAXNUM*3];
   IGRshort   *on_sf=NULL, on_sf2[MAXNUM];
   IGRboolean alloc_mid_cvpar=FALSE,
              alloc_midcv_pt=FALSE, alloc_midcvpt_uv=FALSE, alloc_on_sf=FALSE;
   IGRboolean all_on_sf;
   IGRdouble  mid_cvpar_lg, midcvpt_uv_lg[2];
   IGRdouble  temp0, temp1, ptemp0, ptemp1, len;
   struct
    IGRbsp_surface *tsf=NULL;

   IGRint             ii;
   IGRdouble          *knots = NULL,*uvlgd = NULL, t, w;
   IGRint             ndeg,rat,nbcv;
   IGRboolean         found, quadsf;

   *rc = BSSUCC;

   BSEXTRACTPAR(rc, BSTOLBASIS, basis_tol);  

   /* Get a parametric chord height tolerance */
   BSEXTRACTPAR(rc, BSTOLCHRDHT, chrdht_tol);
   BSchgdeppar(chrdht_tol, rc );
   if (BSERROR(*rc))
      goto wrapup;

   tsf = sf->bspsf;
   BSsfkttol2(tsf->u_order, tsf->v_order, tsf->u_knots, tsf->v_knots,
              tsf->u_num_poles, tsf->v_num_poles, tsf->poles, tsf->weights, 
              &cht_sf_kttol, rc);
   if (BSERROR(*rc))
      goto wrapup;

   BSchgdeppar(basis_tol, rc );
   if (BSERROR(*rc))
      goto wrapup;

   /* Check if sf is supported special surface */
   BSqdsfflag(sf, &quadsf, rc);
   if (BSERROR(*rc))
      goto wrapup;


   if (!lgd_flag)
   {
      /****************/
      /* NOT Legendre */
      /****************/

      if (num_pts > MAXNUM)
      {
         mid_cvpar = (IGRdouble *)BSstackalloc((unsigned) num_pts *
                        sizeof(IGRdouble ));
         if (!mid_cvpar)
         {
            *rc = BSNOSTKMEMORY;
            goto wrapup;
         } 
         alloc_mid_cvpar = TRUE;

         midcv_pt = (IGRdouble *)BSstackalloc((unsigned) num_pts * 3 *
                        sizeof(IGRdouble));
         if (!midcv_pt)
         {
            *rc = BSNOSTKMEMORY;
            goto wrapup;
         } 
         alloc_midcv_pt = TRUE;

         midcvpt_uv = (BSpair *)BSstackalloc((unsigned) num_pts *
                         sizeof(BSpair));
         if (!midcvpt_uv)
         {
            *rc = BSNOSTKMEMORY;
            goto wrapup;
         } 
         alloc_midcvpt_uv = TRUE;

         on_sf = (IGRshort *)BSstackalloc((unsigned)num_pts* sizeof(IGRshort));
         if (!on_sf)
         {
            *rc = BSNOSTKMEMORY;
            goto wrapup;
         } 
         alloc_on_sf = TRUE;
      }
      else
      {
         mid_cvpar = mid_cvpar2;
         midcv_pt = midcv_pt2;
         midcvpt_uv = midcvpt_uv2;
         on_sf = on_sf2;
      }

      for(i=0; i< num_pts-1; i++)
      {
         /* find the mid uv value and evaluate sf at this mid uv */

         /* Get mid curve parameter and evaluate curve at mid_cvpar */
         mid_cvpar[i] = (cvpars[i] + cvpars[i+1]) / 2;
      }

      npts = num_pts - 1;
      BScvarrev0(rc, cv, mid_cvpar, npts, midcv_pt);
      if (BSERROR(*rc))
         goto wrapup;

      if (quadsf  && sf->bounded)
      {
         BSprptsgmsf(sf, &npts, midcv_pt, (IGRdouble *)midcvpt_uv, on_sf,
                     rc);
         if (BSERROR(*rc))
            goto wrapup;
      }
      else
      {
         if (sf->bounded)
         {
            BSprptsonsf(npts, (IGRpoint *)midcv_pt, sf->bspsf, 
                        midcvpt_uv, &all_on_sf, rc);
            if (BSERROR(*rc))
               goto wrapup;
         }
      }

 
      for (i = 0; i < npts; ++i)
      {
         /* find the parametric distance from the line between uvpars[i]
            and uvpars[i+1] to the uv of the mid point based on pts[i] and
            pts[i+1] */

         temp0 = uvpars[i+1][0] - uvpars[i][0];
         temp1 = uvpars[i+1][1] - uvpars[i][1];

         ptemp0 = midcvpt_uv[i][0] - uvpars[i][0];
         ptemp1 = midcvpt_uv[i][1] - uvpars[i][1];

         len = sqrt(temp0 * temp0 + temp1 * temp1);
         if (len < BSSMALLRELTO1)
         {
            dist = sqrt(ptemp0 * ptemp0 + ptemp1 * ptemp1);
         }
         else
         {
            dist = fabs(temp0 * ptemp1 - temp1 * ptemp0) / len;
         }

         if (dist < cht_sf_kttol )
            insert[i] = 0;
         else
            insert[i] = (IGRint)(dist / (2*cht_sf_kttol) + .5);
      }   /* end i loop */
   }   
   else
   {
      /************/
      /* Legendre */
      /************/

      nbcv = lgd_cv->ncvs[n];
      knots = (IGRdouble *)BSstackalloc((unsigned)
               (nbcv + 1) * sizeof(IGRdouble));
      if (!knots)
      {
        *rc = BSNOSTKMEMORY;
        goto wrapup;
      }

      for (ii = 0; ii <= nbcv; ++ii)
        knots[ii] = (IGRdouble)ii/(IGRdouble)nbcv;
  

      for(i=0; i< num_pts-1; i++)
      {
         /* Get mid curve parameter and evaluate curve at mid_cvpar */
         mid_cvpar_lg = (cvpars[i] + cvpars[i+1]) / 2;

         ii = 0;
         found = FALSE;
         while (!found && ii < nbcv)
         {   
             ndeg = lgd_cv->ndegtab[n][ii];
             rat = lgd_cv->rattab[n][ii];
             uvlgd = lgd_cv->cvlgd[n][ii];
            
             if (mid_cvpar_lg <= knots[ii + 1])
             {  
                t = (2 * mid_cvpar_lg - knots[ii] - knots[ii + 1] )
                    / (knots[ii + 1] - knots[ii]);
                BShornlgd(ndeg,uvlgd,t,&(midcvpt_uv_lg[0]));
                BShornlgd(ndeg,&uvlgd[ndeg + 1],t,&(midcvpt_uv_lg[1]));
                if (rat == 1 || rat == 3)
                {
                   /* only u or u and v are rational */
                   BShornlgd(ndeg,&uvlgd[2 * (ndeg + 1)],t,&w);
                   midcvpt_uv_lg[0] /= w;
                }
                if (rat == 2)
                {
                   /* v is rational */
                   BShornlgd(ndeg,&uvlgd[2 * (ndeg + 1)],t,&w);
                   midcvpt_uv_lg[1] /= w;
                }
                if (rat == 3)
                {
                   /* u and v are rational */
                   BShornlgd(ndeg,&uvlgd[3 * (ndeg + 1)],t,&w);
                   midcvpt_uv_lg[1] /= w;
                }               

                if (midcvpt_uv_lg[0] < 0)
                    midcvpt_uv_lg[0] = 0.0;

                if (midcvpt_uv_lg[1] < 0)
                    midcvpt_uv_lg[1] = 0.0;

                if (midcvpt_uv_lg[0] > 1.0)
                    midcvpt_uv_lg[0] = 1.0;

                if (midcvpt_uv_lg[1] > 1.0)
                    midcvpt_uv_lg[1] = 1.0;
                found = TRUE;
             }  
             else
             {
               ii++;
             }

         }   /* end while (!found && ii < nbcv) */

         if (ii == nbcv)
         {
            /* something is wrong -- ERROR */
            *rc = BSFAIL;
            goto wrapup;
         }

         /* find the parametric distance from the line between uvpars[i]
            and uvpars[i+1] to the uv of the mid point based on pts[i] and
            pts[i+1] */

         temp0 = uvpars[i+1][0] - uvpars[i][0];
         temp1 = uvpars[i+1][1] - uvpars[i][1];

         ptemp0 = midcvpt_uv_lg[0] - uvpars[i][0];
         ptemp1 = midcvpt_uv_lg[1] - uvpars[i][1];

         len = sqrt(temp0 * temp0 + temp1 * temp1);
         if (len < BSSMALLRELTO1)
         {
            dist = sqrt(ptemp0 * ptemp0 + ptemp1 * ptemp1);
         }
         else
         {
            dist = fabs(temp0 * ptemp1 - temp1 * ptemp0) / len;
         }

         if (dist < cht_sf_kttol )
            insert[i] = 0;
         else
            insert[i] = (IGRint)(dist / (2*cht_sf_kttol) + .5);
      }   /* end i loop */

   }   /* end if (!lgd_flag)  */


   wrapup:

   if (knots)
     BSstackdealloc((char *) knots);

   if (on_sf && alloc_on_sf)
   {
      BSstackdealloc((char *)on_sf);
      on_sf = NULL;
   }

   if (midcvpt_uv && alloc_midcvpt_uv)
   {
      BSstackdealloc((char *)midcvpt_uv);
      midcvpt_uv = NULL;
   }

   if (midcv_pt && alloc_midcv_pt)
   {
      BSstackdealloc((char *)midcv_pt);
      midcv_pt = NULL;
   }

   if (mid_cvpar && alloc_mid_cvpar)
   {
      BSstackdealloc((char *)mid_cvpar);
      mid_cvpar = NULL;
   }
 
   if(BSERROR(*rc))
       BSdbgrc(*rc,"BSinsuvsxcv");
   return;
 
}
