#include "ciminimum.h"
#include "cimacros.h"
#include "cieveryone.h"
#include "FI.h"
#include "CIforms.h"
#include "msdef.h"
#include "growner.h"
#include "grgsdef.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "grsymdef.h"
#include "grsym.h"
#include <grerr.h>
#include "grsymmacros.h"
#include "nddef.h"
#include "ndmacros.h"
#include "assemdef.h"
#include "assem.h"
#include "assemmacros.h"

#define FINISHED       -1
#define START           0
#define GET_INSTANCE    1
#define UPDATE_FORM     2
#define EDIT_INSTANCE   3
#define CLEANUP         4

#define PART_FORM   2
#define NAME        25
#define PART_ATTRS  12
#define INST_ATTRS  15
#define MESSAGE     10
#define DELETE_ATTR 16
#define LINK_ATTR   18
#define ACCEPT      1
#define EXECUTE     2
#define CANCEL      4
#define TITLE       11

IGRint                  om_msg, msg, ok;
struct GRmd_env         mod_env;
struct GRid             part_id, instance_id, temp_id;
IGRint                  state, response;
IGRuint                 props;
IGRint                  num_attrs, num_part_attrs, num_inst_attrs;
EMattr                * part_attrs, * inst_attrs, attr;
IGRint                  part_attrs_size, inst_attrs_size;
struct CIform_st        form_st;
char                  * form_ptr;
int                     form_displayed;
IGRchar                 buffer[256];
IGRint                  sel, pos, i, j, size, mode, count;
IGRint                  delete_state, link_state;
IGRint                  row, delete_row, link_row, num_rows;
IGRboolean              attr_found;
IGRint                  batch_mode;
IGRint                  gadget_mask;
IGRchar                 name[40];

extern int GRdpb_get();
extern int FIf_new();
extern int FIfld_set_text();
extern int FIfld_get_text();
extern int FIfld_set_cmd_oid_os();
extern int FIf_display();
extern int FIf_erase();
extern int FIfld_get_num_rows();
extern int FIf_delete();
extern int Wait_timer();
extern int ci_notification();
extern int FIf_set_cmd_oid_os();
extern int FIf_reset();
extern int FIfld_set_list_default_text();
extern int FIf_is_displayed();
extern int FIfld_get_mode();
extern int FIfld_set_mode();
extern int FIfld_get_active_row();
extern int FIg_get_state();
extern int FIfld_get_num_rows ();
extern int FIg_display();
extern int printf();
extern int sprintf();

form_update ()
{
    FIg_reset (form_ptr, PART_ATTRS);
    FIg_reset (form_ptr, INST_ATTRS);
        
    if (instance_id.objid != NULL_OBJID)
    {
        /*
         * Fill in the instance's name.
         */
        om_msg = EMget_instance_name (&msg, &instance_id, name);
        
        if (!(om_msg & msg & 1))
        {
            printf ("Error: Couldn't get instance name\n");
        }
        
        FIfld_set_text (form_ptr, NAME, 0, 0, name, FALSE);
        
        /*
         * Get the instance's part definition.
         */
        asm$get_instance_part (msg = &msg,
                               instance_id = &instance_id,
                               part_id = &part_id);

        if (!(om_msg & msg & 1))
        {
            printf ("Error: Getting instance's part\n");
        }
              
        /*
         * Initialize the number of attributes to 0 and name 
         * to NULL.
         */
        num_part_attrs = 0;

        /*
         * Get all the part attributes.
         */
        om_msg = asm$attribute_count (msg = &msg,
                                      id = &part_id,
                                      count = &num_part_attrs);
        
        if (!(om_msg & msg & 1))
        {
            status ("Couldn't get the number of part attributes");
        }
        else
        {
            /*
             * Get some memory.
             */
            if (part_attrs == NULL)
            {
                part_attrs_size = num_part_attrs;
                part_attrs = (EMattr *)om$malloc(size = part_attrs_size * sizeof(EMattr));
            }
            else if (part_attrs_size < num_part_attrs)
            {
                part_attrs_size = num_part_attrs;
                part_attrs = (EMattr *)om$realloc(ptr = part_attrs, 
                                                  size = part_attrs_size * sizeof(EMattr));
            }

            if (part_attrs != NULL)
            {
                row = 0;
                num_attrs = num_part_attrs;
                num_part_attrs = 0;
                
                for (i=0; i<num_attrs; i=i+1)
                {
                    om_msg = asm$get_attribute (msg = &msg,
                                                index = i,
                                                id = &part_id,
                                                attribute = &part_attrs[row]);
                    if (om_msg & msg & 1)
                    {
                        if ((part_attrs[row].info.type & EM_PART_ATTR) ||
                            (part_attrs[row].info.type & EM_COMMON_ATTR))
                        {
                            FIfld_set_text (form_ptr, 
                                            PART_ATTRS, 
                                            row, 0, 
                                            part_attrs[row].info.name, 
                                            FALSE);
                            FIfld_set_text (form_ptr, 
                                            PART_ATTRS, 
                                            row, 1, 
                                            part_attrs[row].value.syntax,
                                            FALSE);
                            FIfld_set_text (form_ptr, 
                                            PART_ATTRS, 
                                            row, 2, 
                                            part_attrs[row].info.desc,
                                            FALSE);
                            row = row + 1;
                            num_part_attrs = num_part_attrs + 1;
                        }
                    }
                }
            }                
        }
        
        /*
         * Get all the instance attributes.
         */
        om_msg = asm$attribute_count (msg = &msg,
                                      id = &instance_id,
                                      count = &num_inst_attrs);
        
        if (!(om_msg & msg & 1))
        {
            status ("Couldn't get the number of instance attributes");
        }
        else
        {
            /*
             * Get some memory.
             */
            if (inst_attrs == NULL)
            {
                inst_attrs_size = num_inst_attrs;
                inst_attrs = (EMattr *)om$malloc(size = inst_attrs_size * sizeof(EMattr));
            }
            else if (inst_attrs_size < num_inst_attrs)
            {
                inst_attrs_size = num_inst_attrs;
                inst_attrs = (EMattr *)om$realloc(ptr = inst_attrs, 
                                                  size = inst_attrs_size * sizeof(EMattr));
            }

            if (inst_attrs != NULL)
            {
                row = 0;
                num_attrs = num_inst_attrs;
                num_inst_attrs = 0;
                
                for (i=0; i<num_attrs; i=i+1)
                {
                    om_msg = asm$get_attribute (msg = &msg,
                                                index = i,
                                                id = &instance_id,
                                                attribute = &inst_attrs[row]);
                    if (om_msg & msg & 1)
                    {
                        FIfld_set_text (form_ptr, 
                                        INST_ATTRS, 
                                        row, 0, 
                                        inst_attrs[row].info.name, 
                                        FALSE);
                        FIfld_set_text (form_ptr, 
                                        INST_ATTRS, 
                                        row, 1, 
                                        inst_attrs[row].value.syntax,
                                        FALSE);
                        FIfld_set_text (form_ptr, 
                                        INST_ATTRS, 
                                        row, 2, 
                                        inst_attrs[row].info.desc,
                                        FALSE);
                        row = row + 1;
                        num_inst_attrs = num_inst_attrs + 1;
                    }
                }
            }                
        }
    }
}

main ()
{
    om_msg = OM_S_SUCCESS;
    msg = MSSUCC;
    part_attrs = NULL;
    part_attrs_size = 0;
    inst_attrs = NULL;
    inst_attrs_size = 0;
    name[0] = '\0';
    
    message("Edit Instance");

    /*
     * Get the current module enviroment.
     */	
    ci$get_module_info( md_env = &mod_env );

    /*
     * Read in the form. EdInst must reside in one of the product
     * "config/english/forms" directories to be found.
     */
    form_ptr = NULL;
    FIf_new( PART_FORM, "EdInst", ci_notification, &form_ptr);

    if (!(int)form_ptr)
    {

        msg = MSFAIL;
    }
    else
    {
        /*
         * Associate the form with this command object.
         */
        FIf_set_cmd_oid_os( form_ptr, MY_ID, OM_Gw_current_OS );
        state = START;
    }

    if (!(om_msg & msg & 1))
    {
        state = CLEANUP;
    }
    
    /*
     * Loop until the state is set to FINISHED.
     */
    while (state != FINISHED)
    {
        /*
         * Goto the appropriate state.
         */                
        switch (state)
        {
            /*
             * (Re)initialize the command.
             */
        case START:
            /*
             * Reset the form.
             */
            FIf_erase (form_ptr);
            FIf_reset (form_ptr);
            
            link_state = 0;
            delete_state = 0;
            
            instance_id.objid = NULL_OBJID;
            
            state = GET_INSTANCE;
            break;

        case GET_INSTANCE:
            /*
             * Locate graphics ...
             */
            ci$locate (obj = &instance_id.objid,
                       osnum = &instance_id.osnum,
                       prompt = "Identify instance",
                       acc_prompt = "Accept/Reject",
                       relocate_prompt = "Element not found",
                       classes = "EMinstance",
                       stackable = 1,
                       owner_action = LC_GEOM_MOD | LC_REF_HEADER |
                                      LC_NO_REF_OBJECTS,
                       response = &response );

            switch (response)
            {
            case EX_DATA:
                state = UPDATE_FORM;
                break;
                
            case EX_RJT_MOVEON:
                break;

            case EX_BACK_UP:
                break;
            }
            break;
            
        case UPDATE_FORM:
            /*
             * Redisplay the form.
             */
            FIf_is_displayed (form_ptr, &form_displayed);
                
            if (!(int)form_displayed) FIf_display( form_ptr );
            
            /*
             * Update the form.
             */
            form_update();

            if (om_msg & msg & 1)
            {
                state = EDIT_INSTANCE;
            }
            else
            {
                state = CLEANUP;
            }
            break;
            
        case EDIT_INSTANCE:
            /*
             * Wait for the user to input the instance
             * attributes on the form.
             */
            while (state == EDIT_INSTANCE)
            {
                ci$getevent(response = &response, 
                            prompt = "Edit attributes on form" );

                if (om_msg & msg & 1)
                {
                    if (response == EX_FORM_FINISHED)
                    {
                        state = FINISHED;
                    }
                    else if (response == EX_RJT_MOVEON)
                    {
                        state = START;
                    }
                }
                else
                {
                    state = CLEANUP;
                }
            }
            break;

        case CLEANUP:
            if ( form_ptr ) 
            {
                FIf_delete( form_ptr );
                form_ptr = NULL;
            }
    
            if (part_attrs)
            {
                free (part_attrs);
                
                part_attrs = NULL;
            }

            if (inst_attrs)
            {
                free (inst_attrs);
                
                inst_attrs = NULL;
            }

            state = FINISHED;
            break;
        }
    }
}

form_notification()
{
    switch ( form_st.gadget_label )
    {
    case EXECUTE:
    case ACCEPT:

        om_msg = OM_S_SUCCESS;
        msg = MSSUCC;

        /*
         * See if the name changed.
         */
        om_msg = EMget_instance_name (&msg, &instance_id, name);
        
        if (!(om_msg & msg & 1))
        {
            printf ("Error: Couldn't get instance name\n");
        }
        
        FIfld_get_text (form_ptr, NAME, 0, 0, 40, buffer, &sel, &pos);

        if (strcmp(buffer, name))
        {
            om_msg = EMset_instance_name (&msg, &instance_id, buffer);
        }

        /*
         * See if any attributes have been deleted ...
         */
        FIfld_get_num_rows( form_ptr, INST_ATTRS, &num_attrs );

        for (i=0; i<num_inst_attrs; i=i+1)
        {
            attr_found = FALSE;
            
            for (j=0; j<num_attrs; j=j+1)
            {
                buffer[0] = '\0';
                
                FIfld_get_text (form_ptr,
                                INST_ATTRS,
                                j,0,256,
                                buffer,
                                &sel,&pos );

                if (!strcmp(buffer, inst_attrs[i].info.name))
                {
                    attr_found = TRUE;
                    break;
                }
            }
                
            if (attr_found == FALSE)
            {
                om_msg = asm$rem_attribute (msg = &msg,
                                            id = &instance_id,
                                            name = inst_attrs[i].info.name);

                if (!(om_msg & msg & 1))
                {
                    sprintf (buffer, 
                             "Couldn't remove attribute %s",
                             inst_attrs[i].info.name);
                    
                    FIfld_set_text (form_ptr,
                                    MESSAGE,
                                    0, 0,
                                    buffer,
                                    FALSE);
                    
                    om_msg = OM_S_SUCCESS;
                    msg = MSSUCC;
                }
            }
        }            

        /*
         * Modify/add/link any instance attributes ...
         */
        for (i=0; i<num_attrs; i=i+1)
        {
            FIfld_get_text (form_ptr,
                            INST_ATTRS,
                            i,0,MAX_NAME,
                            buffer,
                            &sel,&pos );

            if (buffer[0] != '\0')
            {
                attr.info.type = EM_INSTANCE_ATTR;
                attr.value.type = EM_CALCULATED;
                
                strcpy(attr.info.name, buffer);
                
                FIfld_get_text (form_ptr,
                                INST_ATTRS,
                                i,1,MAX_VALUE,
                                attr.value.syntax,
                                &sel,&pos );
                
                FIfld_get_text (form_ptr,
                                INST_ATTRS,
                                i,2,MAX_DESC,
                                attr.info.desc,
                                &sel,&pos );

                attr_found = 0;
                    
                for (j=0; j<num_inst_attrs; j=j+1)
                {
                    if (!strcmp(buffer, inst_attrs[j].info.name))
                    {
                        attr_found = 1;
                        break;
                    }
                }

                if (attr_found == 1)
                {
                    om_msg = asm$mod_attribute (msg = &msg,
                                                id = &instance_id,
                                                name = inst_attrs[j].info.name,
                                                attribute = &attr);

                    if (!(om_msg & msg & 1))
                    {
                        sprintf (buffer, 
                                 "Couldn't update attribute %s",
                                 inst_attrs[j].info.name);
                        
                        FIfld_set_text (form_ptr,
                                        MESSAGE,
                                        0, 0,
                                        buffer,
                                        FALSE);

                        FIfld_set_text (form_ptr,
                                        INST_ATTRS,
                                        i, 1,
                                        inst_attrs[j].value.syntax,
                                        FALSE);

                        FIfld_set_text (form_ptr,
                                        INST_ATTRS,
                                        i, 2,
                                        inst_attrs[j].info.desc,
                                        FALSE);

                        om_msg = OM_S_SUCCESS;
                        msg = MSSUCC;
                    }            
                }
                else /* Determine if it's a link or addition. */
                {
                    attr_found = 0;
                    
                    for (j=0; j<num_part_attrs; j=j+1)
                    {
                        if (!strcmp(attr.info.name, 
                                    part_attrs[j].info.name))
                        {
                            attr_found = 1;
                            break;
                        }
                    }
                    
                    if (attr_found)
                    {
                        om_msg = ci$send (msg = message EMinstance.EMlink_part_attr
                                                            (&msg,
                                                             attr.info.name,
                                                             &attr),
                                          targetid = instance_id.objid,
                                          targetos = instance_id.osnum);
                    }
                    else
                    {
                        om_msg = asm$add_attribute (msg = &msg,
                                                    id = &instance_id,
                                                    attribute = &attr);
                    }
                    
                    if (!(om_msg & msg & 1))
                    {
                        sprintf (buffer, 
                                 "Couldn't add attribute %s",
                                 attr.info.name);

                        FIfld_set_text (form_ptr,
                                        MESSAGE,
                                        0, 0,
                                        buffer,
                                        FALSE);
                    
                        FIfld_delete_rows (form_ptr, INST_ATTRS, i, 1);

                        om_msg = OM_S_SUCCESS;
                        msg = MSSUCC;
                    }
                }                        
            }
        }

        /*
         * Update the modify batch if requested.
         */
        nd$mod_batch (request = ND_INQ, p_ret_mode = &batch_mode);
        
        if (batch_mode == ND_IMMEDIATE)
        {
            nd$exec_batch ();
        }
        
        if (form_st.gadget_label == EXECUTE)
        {
            form_update ();
        }
        else
        {
            FIf_erase (form_ptr);
            FIf_reset (form_ptr);
            ci$put( response = EX_RJT_MOVEON );
        }
        break;

    case CANCEL:
        FIf_erase (form_ptr);
        FIf_reset (form_ptr);
        ci$put( response = EX_FORM_FINISHED );
        break;

    case DELETE_ATTR:
        break;
        
    case LINK_ATTR:
        break;
        
    case PART_ATTRS:
        FIg_get_state (form_ptr, LINK_ATTR, &link_state);
        
        if ((form_st.value == -1) && (link_state == 1))
        {
            link_row = -1;
            FIfld_get_active_row (form_ptr, 
                                  form_st.gadget_label,
                                  &link_row,
                                  &pos );
            
            if (link_row >= 0)
            {
                FIfld_get_num_rows (form_ptr,
                                    INST_ATTRS,
                                    &num_rows);
                
                buffer[0] = '\0';
                
                for (i=num_rows-1; i>=0; i=i-1)
                {
                    FIfld_get_text (form_ptr,
                                    INST_ATTRS,
                                    i,0,256,
                                    buffer,
                                    &sel,&pos );
                    
                    if (buffer[0] != '\0')
                    {
                        break;
                    }
                }
                
                FIfld_get_text (form_ptr, 
                                PART_ATTRS,
                                link_row, 0, 256,
                                buffer,
                                &sel, &pos);

                FIfld_set_text (form_ptr,   
                                INST_ATTRS,
                                i, 0, buffer,
                                FALSE);
                
                FIfld_get_text (form_ptr, 
                                PART_ATTRS,
                                link_row, 1, 256,
                                buffer,
                                &sel, &pos);

                FIfld_set_text (form_ptr,   
                                INST_ATTRS,
                                i, 1, buffer,
                                FALSE);
                
                FIfld_get_text (form_ptr, 
                                PART_ATTRS,
                                link_row, 2, 256,
                                buffer,
                                &sel, &pos);

                FIfld_set_text (form_ptr,   
                                INST_ATTRS,
                                i, 2, buffer,
                                FALSE);
            }
        }
        break;
        
    case INST_ATTRS:
        FIg_get_state (form_ptr, DELETE_ATTR, &delete_state);
        
        if ((form_st.value == -1) && (delete_state == 1))
        {
            delete_row = -1;
            FIfld_get_active_row (form_ptr, 
                                  form_st.gadget_label,
                                  &delete_row,
                                  &pos );
            
            if (delete_row >= 0)
            {   
                /*
                 * Make sure we don't delete any necessary attributes.
                 */
                FIfld_get_text (form_ptr,
                                form_st.gadget_label,
                                delete_row,0,256,
                                buffer,
                                &sel,&pos );

                if (!strcmp(buffer, "number")     ||
                    !strcmp(buffer, "revision")   ||
                    !strcmp(buffer, "count")      ||
                    !strcmp(buffer, "filename")   ||
                    !strcmp(buffer, "catalog")    ||
                    !strcmp(buffer, "library")    ||
                    !strcmp(buffer, "entry")      ||
                    !strcmp(buffer, "database"))
                {
                    FIfld_set_text (form_ptr, MESSAGE, 0, 0, 
                                    "Can't delete that attribute", FALSE);
                }
                else
                {
                    FIfld_get_num_rows (form_ptr,
                                        form_st.gadget_label,
                                        &num_rows );
                
                    for (i=delete_row; i<num_rows-1; i=i+1)
                    {
                        for (j=0; j<3; j=j+1)
                        {
                            FIfld_get_text (form_ptr, 
                                            form_st.gadget_label, 
                                            i+1, j, 
                                            256, 
                                            buffer, 
                                            &sel, 
                                            &pos);
                        
                            FIfld_set_text (form_ptr,
                                            form_st.gadget_label,
                                            i, j,
                                            buffer,
                                            FALSE);
                        }       
                    }
                
                    for (i=0; i<3; i=i+1)
                    {
                        FIfld_set_text (form_ptr,
                                        form_st.gadget_label,
                                        num_rows-1, i,
                                        "",
                                        FALSE);
                    }   
                }
            }   
        }
        break;
    }
}

wakeup()
{
    if ( form_ptr )
    {
        if (form_displayed == 1) FIf_display( form_ptr );
    }
}

sleep()
{
    if ( form_ptr )
    {
        FIf_is_displayed (form_ptr, &form_displayed);
        if (form_displayed == 1) FIf_erase( form_ptr );
    }
}

delete()
{
    if ( form_ptr ) 
    {
        FIf_delete( form_ptr );
    }
    
    if ( part_attrs ) 
    {
        free (part_attrs);
    }

    if ( inst_attrs ) 
    {
        free (inst_attrs);
    }
}

