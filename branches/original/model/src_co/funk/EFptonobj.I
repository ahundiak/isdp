/* ###################   APOGEE COMPILED   ################## */
/*
 Description

 This function returns a point on an object given the
 located object and the event to be projected onto 
 the object.

 Algorithm

 First look at the event to see if it was generated by
 an event generator.  If so then it may already be on the object.
 Failing this, generate a boreline and perform a line project
 onto the object.

 History

 11/04/87 : rlw : Creation date
 01/06/88 : rlw : Modified such that the event returned looks exactly
                  like an event generator.
 */

class implementation Root;

%safe
#include <math.h>
%endsafe

#include "EMS.h"
#include "ems_m_inc.h"		/* Includes everything */
#include "OMmacros.h"

from GRgraphics import GRlnproject;

IGRlong EFpoint_on_object(
 located_object,		/* Contains the object */
 event,				/* Contains the point */
 my_stupid_id,
 msg)

struct		GRlc_info *located_object;
struct		GRevent *event;
OM_S_OBJID	my_stupid_id;
IGRlong		*msg;

{
 IGRlong	sts;
 struct		GRid *event_object_id;
 struct		GRid *located_object_id;
 struct		GRparms *parameters;
/*
 * Initialize
 */
 *msg = MSSUCC;
 event_object_id = &event->located_object[0].located_obj;
 located_object_id = &located_object->located_obj;
 parameters = &event->located_object[0].geom_parms;
/*
 * Is there an object associated with the input point
 */

 /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  * kludge with a capital K!  Intersection points no longer have
  * valid info about the projected Isect point.  Changing Point
  * At Intersection would screw up lots of other commands.  If an 
  * intersection point comes down (event->num_id == 2), we treat it
  * like a GRst_REGULAR point.  Shelley Heard 02/19/92
  */

 if ((event->subtype != GRst_REGULAR) &&
     ( event->num_id == 1) &&
     (located_object_id->objid == event_object_id->objid) &&
     (located_object_id->osnum == event_object_id->osnum) &&
     (parameters->polygon_inx == 0))
  {
/* noop; */
  }
 else
  {
   IGRboolean	status, EFboreline();
   IGRdouble	t;
   IGRpoint	point1, point2, line_point, *projected_point;
   struct	IGRline bore_line;
   struct	GRmdenv_info *mdenv_info;

   bore_line.point1 = &point1[0];
   bore_line.point2 = &point2[0];
   status = EFboreline(
    msg, 
    my_stupid_id, 
    event,
    &bore_line);
    if (! status) goto wrapup;
   mdenv_info = &located_object->module_info.md_env;
   projected_point = (IGRpoint *)&event->located_object[0].proj_pnt[0];
   sts = om$send(
    msg = message GRgraphics.GRlnproject(
     msg,
     &mdenv_info->matrix_type,
     mdenv_info->matrix,
     &bore_line, 
     line_point,
     *projected_point, 
     &t, 
     parameters),
    senderid = my_stupid_id,
    targetid = located_object_id->objid,
    targetos = located_object_id->osnum);
    if (! (1 & sts)) goto wrapup;
/*
 * Fill in the remaining fields such that this
 * event will look like an event generator.
 */
   OM_BLOCK_MOVE(
    projected_point,
    &event->event.button.x,
    sizeof(IGRpoint)),
   event->subtype = GRst_PROJECT;
   event->num_id = 1;
   event->num_val = 0;
   *event_object_id = *located_object_id;
   event->located_object[0].module_info = located_object->module_info;
  }
/*
 * eof
 */
wrapup:
 if (1 & *msg)
  return(TRUE);
 else
  return(FALSE);
}

end implementation Root;
