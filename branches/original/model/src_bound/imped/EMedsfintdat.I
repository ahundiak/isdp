/*
  ABSTRACT

    This method is activated on a very specific data-structure consisting
    of "xyz-edges" connected to "uv-edges". This method plays in tandem
    with the EMSsubbs.EMbdryint message used currently for coincident
    plane processing.

    The fundamental idea with coincident plane processing is the following:
    Coincident planes present a non-regular situation. Regularizing is
    done by working out the intersection-list as if the two surface-objects
    were not coincident but displaced infinitesimally such that one of
    the coincident planes "penetrates" into the volume of the other. From
    this fundamental notion the workings of thie method can be worked out.

    Via an option setting (EMSINT_TRIM_ONLYCUTTING) this notion of one
    of the coincident planes "penetrating" into the volume of the other
    can be reversed. In that, we can work out the intersections as if
    the coincident plane had moved "out" of the volume of the other.
    The set of intersections one would thus obtain may be different
    from the former case.

  RETURN VALUES

    - EMS_S_Success
       All went well
    - EMS_I_Intersect
       No output was desired but an indication requested whether an
       intersection occurred or not. Actually the existence of this
       edge itself indicates an intersection.
    - EMS_I_DegenerateEdge
       If a degenerate edge was given for processing. This is treated as
       a noop.
    - EMS_I_NoCommonEdge
       If the parent uv-edge of this edge had no common edge. This is 
       treated as a noop.

    - EMS_E_InvalidArg
       This is not a model-space edge, or
       the surfaces supplied on the argument list do not correspond
       with those determined to be associated with the edges.
    - EMS_E_InvalidCase
       This edge has more than one uv-edge correspond to it, or
    - EMS_E_Fail
       An error occurred during a call to an EMS-function
    - EMS_E_NoSolution
       Distance of a point from it's projection on an element which
       should be geometrically coincident, yielded a value greater than
       the allowable tolerance.
    - EMS_E_NoDynamicMemory
       Error while trying to allocate dynamic memory
    - EMS_E_EdgeError, EMS_E_LoopsetError, EMS_E_SurfaceError
       An error returned from a method invoked on the indicated object.
    - EMS_E_MAerror
       Error occurred while calling an MA-math function.
    - EMS_E_Intersect
       Error has probably occurred during the trimming phase that
       produced this loopset.

  ASSUMPTIONS

    This is a model-space edge and a part of a loopset that is
    generated by an operation similar in characteristics to
    EMlssplit. The edge is oriented such that the volume represented
    by the other surface is to the right of this edge.

    The uv-edges involved have common edge connections.

    This edge is not associated with more than one uv-edge either through
    the association channel connection (on this surface) or geometrically
    (on the other surface). 

  BUGS

    If no output is asked for, this method might wrongly construe an 
    intersection in cases of concave edges.

  HISTORY 
   
    SS  :  10/15/87  :  Creation
    SS  :  04/18/88  :  Modified to exclude the check for on-surface
                        after mapping the xyz-polylines to uv-space.
                        Also modified to project onto the other surface,
                        in case pushing-to-common edge fails. This should
                        take care of the case where the edges overlap in
                        model-space and the overlap includes a vertex.
    SS  :  05/31/88  :  Put in the logic to make concave edges work.
    SS  :  08/11/88  :  Changed the int-props setting of the "dup-other" bit
                        for both uv-edge1 and uv-edge2, such that it now gets
                        set only when the uv-data could have potentially been
                        pushed to common on the other side too. Previously,
                        uv-edge1 was being set regardless and uv-edge2
                        was being set only when uv-edge2 was pushed onto
                        common, successfully.
    SS  :  02/20/89  :  Set the edge-types and xyz-curve types
			correctly.
    SS  :  03/28/89  :  Modified the logic to push intersections in a 
			seam-edge situation. Ambiguous situations are resolved
			more meaningfully, using two internal points at times
			as opposed to always one (as was the case before).
    SS  :  07/13/89  :  If the potential output from this edge is found to be
                        degenerate - mark the intersection as deletable.
    SS  :  09/11/89  :  If a resulting intersection ends on a vertex,
                        mark that end as having no further continuity in
			uv-space, ie, if this intersection used to impose
			boundary, then a split must occur at this point.
    SS  :  10/20/89  :  Made pushtocommon a publicly accessible function -
			EMpushtocommon and added the nocheck-orientation
			option.
    SS  :  03/29/89  :  Changed the orientation logic in pushtocommon. Exactly,
                        replaced the variable "this_sf" in the computation
                        of "revdat" with "!push_edge_with_primary".
    ashok: 04/13/91  :  Declared static functions as "static". Some of them
			were declared as "extern" because of which APogee
		   	compiler was showing warnings
    Inasu: 05/01/91  :  The new function EMmapcvxyz_to_uv() is used instead of
			old EMmapxyzcv_uvcv()(which no longer exists).
    SM	:  10-Feb-92 : 	If no common edge return EMS_I_NoSolution from 
			EMpushtocommon().
    SM  :  27_Jan-93 :  Added argument 'thissfos' to EMpushtocommon (to be
                        further passed on as the new argument 'xyzedge_srfos'
                        to chkedconvex), to handle the fact that xyzedge's
                        surface may be in another os. Changed the name of
                        EMpushtocommon to EMpushtocommon_mod. Did not change
                        the name of chkedconvex, since it is static to this
                        file.
    NP  : 27-May-93 :   Function "EMmkintlist"'s name has been changed to 
                        "EMmakeintlist" since two new "curve_type" parameters
                        have been added. Also used "cvtype1" and "cvtype2" (the
                        curve types used in "EMmkintdata") as the additional 
                        inputs needed by "EMmakeintlist".
    Sudha 06/04/93      modified to include BSprototype header files

    Ramana  08/16/95    Removed values.h as bsvalues.h is changed.
*/

class implementation EMSedge;

#include "EMS.h"
%safe
#include <math.h>
%endsafe
#include "OMmacros.h"
#include "EMSbnddef.h"
#include "EMSbnd.h"
#include "emsdattyp.h"
#include "emsinter.h"
#include "emsinterdef.h"
#include "emssfintdef.h"
#include "emsinterdef.h"
#include "emssfint.h"
#include "emsdef.h"
#include "emsedgedef.h"
#include "emsoffptdef.h"
#include "bserr.h"
#include "bsparameters.h"
#include "marptsxfo.h"
#include "maptsxfor.h"
#include "bsdotp.h"
#include "bsdistptpts.h"
#include "bsvalues.h"

%safe
static void initaltdata(), initdata(), freealtdata();
static void swapptrs(), copydata();
static IGRboolean coincintdel(), intdel();
static IGRlong getendinfo_surf();
static IGRlong getendinfo_edge();
static IGRlong chkedconvex();
%endsafe


#define X 0
#define Y 1
#define Z 2

#define U 0
#define V 1

#define START        0
#define STOP         1
#define INTERNAL     2
#define INTERNAL_NXT 3

/*
 * The number of middle points to be generated on this edge. A larger
 * number will ensure that the middle-middle points are truly in the
 * middle. These gyrations have to be gone through as the middle point
 * generator divides paramteric space and not the true arc-length. The
 * FIRST and SECOND are indices of two of the more middle points.
 */

#define NUM_MIDDLE_PTS  4
#define FIRST  1
#define SECOND 2

/*
 * The angle measure of an included angle ranges from 0 to 4, indicating
 * a monotonically increasing scale corresponding to 0-deg to 360-deg.
 * The map is non-linear, but at the four nodal points [0(360), 90, 180 and
 * 270] it corresponds to [0(4), 1, 2 and 3]. With zero-tolerance an angle
 * measure less than 2.0 indicates a convex edge and otherwise a concave
 * edge.
 */

#define HALF_ANGLE_MEASURE 2.0
#define FULL_ANGLE_MEASURE 4.0
#define FLAT_ANGLE_MEASURE 2.0

#define EMomerr_exit(sts, label) if (EMSerror (sts)) goto label;

extern GRclassid OPP_EMSpartedge_class_id, OPP_EMSdumedge_class_id;

extern IGRboolean WANT_POST220_BEHAVIOR;

from GRvg import EMptatpr;
from EMSsubbs import EMpratmpt, EMpassloop, EMpartolbasis, EMaltparams;
from EMSsubbs import EMsftanorm, EMgetbsdef, EMgetabsgeom;
from EMSloopset import EMpt_location;
from EMSpartedge import EMpeinit;

method EMsfintdata (IGRlong *msg; 
                    struct GRid *sf1; IGRboolean sf1_rev;
                    struct GRmdenv_info *toxypln1, *towspace1;
                    struct GRid *sf2; IGRboolean sf2_rev;
                    struct GRmdenv_info *toxypln2, *towspace2;
                    IGRushort proc_info;
                    struct GRvg_construct *const_args;
                    IGRushort outworld_options;
                    IGRushort outparam_options;
                    IGRushort trim_options;
                    IGRlong *num_inters;
                    struct EMSinters **sf1_inters; 
                    struct EMSinters **sf2_inters)
{
  IGRboolean output_world, world_obj, output_param, param_obj;
  IGRboolean orient_output, orient_right, same_side;
  IGRboolean stat_func, onsrf, in_world, tmpbool;
  IGRboolean uv2_possibly_oncommon, this_edge_primary, output_deletable;
  IGRboolean reverse_data1, reverse_data2, this_reversed;
  IGRboolean edge_with_sf1, edge_with_sf2;
  IGRboolean edge_convex1, edge_convex2;
  IGRushort uv1_props, uv2_props, props;
  IGRuchar cvtype1, cvtype2;
  IGRshort surfplanar, location;
  IGRuint count;
  IGRlong send_rc, msg_loc, stat_OM, stat_tmp;
  IGRdouble samplept[NUM_MIDDLE_PTS][3], uvendpts[2][2], uvpt[2], dumpt[3];
  IGRdouble *xyzpts;
  IGRdouble lentol, chrdhttol, partol, tolfactor;
  IGRdouble dist, dist0, dist1;
  IGRdouble angmeas1, angmeas2;
  GRobjid this_uvedge, this_sf;
  GRobjid other_uvedge, other_sf;
  GRspacenum this_os, other_os;
  struct GRid uvsf1, uvsf2, tmpid;
  struct EMSpartolbasis this_ptol, other_ptol;
  struct EMSaltdataselect xyzgeom;
  struct EMSdataselect xyzdata, uvdata1, uvdata2;
  struct EMSdataselect xyzintdata, uvintdata1, uvintdata2;
  struct EMSsfintedpar *endinfo1, *endinfo2;
  struct EMSptloc_info loc_info;
  struct IGRpolyline *poly;
  struct IGRbsp_curve *curve;
  struct IGRbsp_surface *other_sfdata;
  struct EMSproj_info projinfo;
  enum EMSdatatype datatype;
  OM_S_CHANSELECT chan_to_assoc, chan_to_common;
  OM_S_OBJECT_LINKAGE objlist;
  extern void EMmakeintlist(), EM2dto3d(), EMmapcvxyz_to_uv();
  extern void EMdataselect_data_free();
  extern IGRlong EMpushtocommon_mod();
  extern IGRlong EMmkintdata(), EMgetvggeom(), EMinternalpt();
  
  /*
   * Initialization
   */

  *msg = EMS_S_Success;
  stat_OM = OM_S_SUCCESS;

  endinfo1 = NULL;
  endinfo2 = NULL;

  other_sfdata = NULL;
  xyzintdata.datatype = EMSdata_null;
  uvintdata1.datatype = EMSdata_null;
  uvintdata2.datatype = EMSdata_null;
  initaltdata (&xyzgeom);
  initdata (&uvdata1);
  initdata (&uvdata2);
  this_reversed = FALSE;
  output_deletable = FALSE;
  uv1_props = uv2_props = NULL;

  /*
   * Since this method is a very specific one, check if this
   * method could have been invoked on this edge, in the first
   * place. Also, if this is a degenerate edge, do not process it
   * any further.
   */

  props = ME.EMSedge->ed_props;
  EMerr_hndlr (!props & EMED_XYZ, *msg, EMS_E_InvalidArg, ret_end);
  EMerr_hndlr (props & EMED_DEGENERATE, *msg, EMS_I_DegenerateEdge, ret_end);

  /*
   * Obtain the various options that are required for 
   * making the intersection list.
   */

  param_obj = FALSE;
  world_obj = FALSE;
  if (sf1_inters || sf2_inters)
    {
    if (output_world = outworld_options & EMSINT_OUTPUT_WORLD)
      world_obj = outworld_options & EMSINT_WORLD_OBJECT;
    if (output_param = outparam_options & EMSINT_OUTPUT_PARAM)
      param_obj = outparam_options & EMSINT_PARAM_OBJECT;
    }
  else
    {
    output_world = FALSE;
    output_param = FALSE;
    }

  /*
   * Obtain information about this edges environment - the uv-edge and
   * the surface it is associated with. 
   */

  EMmake_chanselect (GRnotify_notification, &chan_to_assoc);
  stat_OM = om$get_channel_objects (object = me, p_chanselect = 
             &chan_to_assoc, list = &objlist, size = 1, count = &count);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (stat_OM == OM_I_LISTOVFLOW, *msg, EMS_E_InvalidCase,
   ret_end);
  this_uvedge = objlist.S_objid;
  this_os = objlist.osnum;

  /*
   * If this uv-edge has no common edge do not process any further
   */
  
  EMmake_chanselect (EMSedge_to_common_edge, &chan_to_common);
  count = 0;
  om$get_channel_count (objid = this_uvedge,  p_chanselect = &chan_to_common, 
   count = &count);
  EMerr_hndlr (!count, *msg, EMS_I_NoCommonEdge, ret_end);

  /*
   * Check to see if the associated uv-edge is a seam edge on this
   * coplanar surface. If so, then this intersection must be marked
   * as deletable. This because, along this edge there can be no valid
   * cutting intersections. The edge is marked deletable if the 'proc_info'
   * option specifies this unconditionally. There are other ways in which an
   * intersection can be construed as deletable. These involve determining a
   * measure of the included angle. At this time, this calculation is deeply
   * embedded in the rest of the code and cannot be brought up to this point.
   * But in the future, this needs to be done so that even if no intersection
   * output is demanded, the answer to the question whether there is an
   * intersection or not can be made accurately.
   */

  stat_OM = om$send (msg = message EMSedge.EMget_props_type (&msg_loc, &props,
             NULL), targetid = this_uvedge, targetos = this_os);
  EMomerr_exit (stat_OM, ret_end);
   
  if (props & EMED_SEAM || proc_info & EMSsfint_edge_deletable)
    output_deletable = TRUE;

  /*
   * Output the intersections as per the options specified. If no output
   * is desired, a return a code signifying that atleast one intersection
   * did occur, is returned, provided the intersection is not deletable.
   */

  if (output_world || output_param)
    {
    cvtype1 = EMfreeform_curve;
    cvtype2 = EMfreeform_curve;

    stat_OM = om$send (msg = message EMSboundary.EMgetsurface_info (&msg_loc,
               &this_sf, NULL), targetid = this_uvedge,
               targetos = this_os);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);

    edge_with_sf1 = (this_sf == sf1->objid && this_os == sf1->osnum);
    edge_with_sf2 = (this_sf == sf2->objid && this_os == sf2->osnum);

    /*
     * Determine if the surface to which this edge is associated is the
     * primary surface in the intersection operation. This information in
     * conjunction with whether the volumes bounded by the coincident planes
     * are on the same side or not and the measure of the included angle
     * at the involved edges (obtained later), will finally decide whether 
     * this intersection is deletable or not. See notes for explanation.
     */

    if (proc_info & EMSsfint_edge_primary1)
      this_edge_primary = edge_with_sf1 ? TRUE : FALSE;
    else
      this_edge_primary = edge_with_sf2 ? TRUE : FALSE;

    same_side = (proc_info & EMSsfint_edge_sameside ? TRUE : FALSE);
    uv2_possibly_oncommon = FALSE;
    
    /*
     * Rearrange the surfaces and associated data so that the uv-edges
     * surface is reflected as the first surface. Also, reverse the
     * edges if needed. Obtain all the local information needed.
     */

    if (edge_with_sf2)
      {
      swapptrs (&sf1, &sf2);
      tmpbool = sf1_rev;
      sf1_rev = sf2_rev;
      sf2_rev = tmpbool;
      swapptrs (&toxypln1, &toxypln2);
      swapptrs (&towspace1, &towspace2);
      swapptrs (&sf1_inters, &sf2_inters);
      }
    else if (!edge_with_sf1)
      EMerr_hndlr (TRUE, *msg, EMS_E_InvalidArg, ret_end);

    if (sf1_rev)
      {
      stat_OM = om$send (msg = message EMSedge.EMreverse (&msg_loc),
                 targetid = my_id);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
      this_reversed = TRUE;
      }

    reverse_data1 = FALSE;
    reverse_data2 = this_reversed ? !sf2_rev : sf2_rev;

    uvsf1 = *sf1;
    uvsf2 = *sf2;

    BSEXTRACTPAR (&msg_loc, BSTOLCHRDHT, chrdhttol);
    BSEXTRACTPAR (&msg_loc, BSTOLLENVEC, lentol);
    tolfactor = (chrdhttol / lentol);

    /*
     * This model-space edge's geometry is required for any 
     * further processing. Extract and convert it to 3D if needed.
     */

    stat_OM = om$send (msg = message EMSedge.EMgetgeom (&msg_loc, 0, MAXINT,
               FALSE, NULL, &xyzgeom), targetid = my_id);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
    copydata (&msg_loc, &xyzgeom, &xyzdata, FALSE);

    datatype = xyzdata.datatype;
    if (datatype == EMSdata_poly2d)
      {
      poly = xyzdata.data.poly;
      count = poly->num_points;
      xyzpts = (IGRdouble *) om$malloc (size = count * 3 * sizeof (IGRdouble));
      EMerr_hndlr (! xyzpts, *msg, EMS_E_NoDynamicMemory, ret_end);

      EM2dto3d (poly->points, count, xyzpts);
      om$dealloc (ptr = poly->points);
      poly->points = xyzpts;
      xyzdata.datatype = EMSdata_poly3d;
      }

    if (output_param)
      {
      /*
       * Obtain the parametric counterpart of this model-space edge
       * on the first surface. In the special environment in which this 
       * model-space edge has been generated (coincident planes), the
       * topology should be such that it appears as if this surface has
       * actually penetrated "into" the other. It can be achieved by
       * pushing this intersection onto the surface that is adjoining this
       * edge.
       */

      this_ptol.is_valid = FALSE;
      stat_OM = EMpushtocommon_mod (&msg_loc, &toxypln1->matrix_type, 
                 toxypln1->matrix, TRUE, this_edge_primary, my_id, NULL,
                 this_sf, this_os, this_uvedge, this_os,
                 tolfactor, same_side, this_reversed, param_obj,
                 trim_options & EMSINT_TRIM_ONLYCUTTING | EMSINT_ORIENT_OUTPUT,
                 &uvsf1, &uvdata1, &cvtype1,
                 &reverse_data1, &endinfo1, &edge_convex1, &angmeas1,
                 &this_ptol);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc) || msg_loc == EMS_I_NoSolution, *msg,
       EMS_E_Fail, ret_end);
     
      if (sf1_inters)
        {
        stat_OM = EMmkintdata (&msg_loc, &uvdata1, cvtype1, NULL,
                   FALSE, NULL, const_args, param_obj, &this_ptol.tol, NULL,
                   &uvintdata1);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);
        if (msg_loc == EMS_I_Degenerate)
          {
          uv1_props |= EMSintobj_uvdegenerate;
          output_deletable = TRUE;
          }

        if (uvintdata1.datatype == EMSdata_object && 
            uvdata1.datatype == EMSdata_object)
          uvdata1.data.object->objid = NULL_OBJID;
        }

      /*
       * Obtain the other parametric space intersection on the second
       * surface. Such an intersection might actually lie on the immediate
       * second surface or it too might have to be "pushed" onto an
       * adjoining surface. If this edge is not coincident with another on
       * surface-2, a simple projection will yield the second paramteric
       * intersection. If it is coincident then push this intersection
       * onto the surface adjoining this coincident edge.
       */
      
      stat_OM = EMinternalpt (&msg_loc, &toxypln2->matrix_type, 
                 toxypln2->matrix, &xyzdata, EMScvint_middle, NUM_MIDDLE_PTS, 
                 samplept);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);

      other_sf = sf2->objid;
      other_os = sf2->osnum;
      stat_OM = om$send (msg = message EMSsubbs.EMpratmpt (&msg_loc, 
                 &toxypln2->matrix_type, toxypln2->matrix, 1, samplept[FIRST],
                 uvpt, &dist, dumpt), targetid = other_sf, 
                 targetos = other_os);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);
      EMerr_hndlr (dist > chrdhttol, *msg, EMS_E_NoSolution, ret_end);

      in_world = TRUE;
      stat_OM = om$send (msg = message EMSsubbs.EMpartolbasis (&msg_loc,
                 &toxypln2->matrix_type, toxypln2->matrix, &in_world,
                 FALSE, &other_ptol.tol), targetid = other_sf,
                 targetos = other_os);
      other_ptol.is_valid = TRUE;

      /*
       * A parametric tolerance needs to be used that accounts for the
       * error due to stroking out curves within chord-height. This is done
       * by setting the option which causes each edge to compute it's
       * tolerance band. Mainly, the linear edge uses tolerance relative to
       * chord-height.
       * 
       * Since we are operating near boundary conditions, don't rely on 
       * range box checks.
       * SM 07/08/93.
       */

      loc_info.options = (WANT_POST220_BEHAVIOR ? NULL : EMS_PTLOC_BOXCHECK) |
                         EMS_PTLOC_ACTLOOP | EMS_PTLOC_USECHTTOL |
                         EMS_PTLOC_XYZ_ONEDGE;
      stat_OM = om$send (msg = message EMSsubbs.EMpassloop (&send_rc,
                 message EMSloopset.EMpt_location (&msg_loc, uvpt, &loc_info,
                 &other_ptol)), targetid = other_sf, targetos = other_os);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (send_rc), *msg, EMS_E_SurfaceError, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_LoopsetError, ret_end);

      location = loc_info.location;
      EMerr_hndlr (location != EMS_L_ONEDGE && location != EMS_L_ONVRTX &&
       location != EMS_L_INAREA, *msg, EMS_E_Intersect, ret_end);

      if (location == EMS_L_ONEDGE || location == EMS_L_ONVRTX)
        {
        uv2_possibly_oncommon = TRUE;

        /*
         * This edge is entirely coincident with an entire or atleast a
         * part of an edge on surface-2. Such a conclusion can be drawn from
         * a single point because if it wasn't so, this edge would have been
         * split into atleast two edges, which then in turn would satisfy this
         * condition. The loopset-split method used to generate
         * such a loopset with this edge as a part of it, is assumed to have
         * this characteristic. 
         */

        other_uvedge = NULL_OBJID;
        if (loc_info.num_located_edges > 1)
          {
          /*
           * This situation might happen because of very small edges or
           * very small spans close to the vertex. One out of these edges
           * is the edge being sought. Using the second internal point,
           * check which of these edges is closer and use that edge.
           */

          stat_OM = om$send (msg = message EMSsubbs.EMpratmpt (&msg_loc, 
                     &toxypln2->matrix_type, toxypln2->matrix, 1, 
                     samplept[SECOND], uvpt, &dist, dumpt),
                     targetid = other_sf, targetos = other_os);
          EMomerr_exit (stat_OM, ret_end);
          EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);

          if (dist <= chrdhttol)
            {
            stat_OM = om$send (msg = message EMSedge.EMptproject (&msg_loc,
                       uvpt, 1, &projinfo, NULL, &other_ptol), 
                       targetid = loc_info.edge[0].edge_id, 
                       targetos = other_os);
            EMomerr_exit (stat_OM, ret_end);
            EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
            dist0 = projinfo.dist;

            stat_OM = om$send (msg = message EMSedge.EMptproject (&msg_loc, 
                       uvpt, 1, &projinfo, NULL, &other_ptol), 
                       targetid = loc_info.edge[1].edge_id, 
                       targetos = other_os);
            EMomerr_exit (stat_OM, ret_end);
            EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
            dist1 = projinfo.dist;

            if (dist0 < dist1)
              other_uvedge = loc_info.edge[0].edge_id;
            else
              other_uvedge = loc_info.edge[1].edge_id;
            }
          }
        else
          other_uvedge = loc_info.edge[0].edge_id;

        if (!IF_NULL_OBJID (other_uvedge))
          {
          tmpid = uvsf2;
          tmpbool = reverse_data2;
          stat_OM = EMpushtocommon_mod (&msg_loc, &toxypln2->matrix_type, 
                     toxypln2->matrix, FALSE, !this_edge_primary, my_id, NULL,
                     this_sf, this_os, other_uvedge, other_os, tolfactor, 
                     same_side, this_reversed, param_obj, 
                     trim_options & EMSINT_TRIM_ONLYCUTTING |
                      EMSINT_ORIENT_OUTPUT, &uvsf2,
                     &uvdata2, &cvtype2, &reverse_data2, &endinfo2,
                     &edge_convex2, &angmeas2, &other_ptol);
          EMomerr_exit (stat_OM, ret_end);
          EMerr_hndlr (EMSerror (msg_loc), *msg, msg_loc, ret_end);

          if (msg_loc == EMS_I_NoSolution)
            {
            /*
             * For some reason the above operation did not succeed, it can be
             * concluded that a partial coincidence has occurred (eg:
             * splityourself did not really split up the edges to achieve
             * a one-to-one match, as was being assumed).
             * In this case, simply treat the condition as if the xyz-edge
             * lies entirely within area of the other surface. Some of the
             * data that was good on input to "EMpushtocommon_mod" may have 
             * got destroyed. Restore it. Also free memory that may have been
             * malloced.
             */

            uvsf2 =tmpid;
            reverse_data2 = tmpbool;
            EMdataselect_data_free (&msg_loc, &uvdata2, 1);
            location = EMS_L_INAREA;
            }
          else
            {
            /*
             * The above operation succeeded. It is left to determine whether
             * the intersection is truly a valid part of the output.
             * It is possible that a condition exists wherein the intersection
             * lies at a discontinuity such that "pushing" this intersection
             * onto the common edge will not retain a cutting intersection.
             * See notes for explanation. The coincident-intersection-delete
             * function is called to determine this.
             */

            if (!output_deletable)
              output_deletable = coincintdel (
                                  !(trim_options & EMSINT_TRIM_ONLYCUTTING),
                                  same_side,
                                  this_edge_primary ? angmeas1 : angmeas2,
                                  this_edge_primary ? angmeas2 : angmeas1);
            }
          }
        else
          location = EMS_L_INAREA;
        }
        
      if (location == EMS_L_INAREA)
        {
        /*
         * No coincident edge lies on the other surface. This geometry
         * is converted to the parametric space of the other surface and
         * end point information obtained. 
         */

        stat_OM = EMgetvggeom (&msg_loc, &toxypln2->matrix_type,
                   toxypln2->matrix, sf2, &other_sfdata, &datatype);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);

        EFextract_par (BSTOLLENVEC, other_ptol.tol, &partol, &msg_loc);
        surfplanar = EMS_O_Unknown;
        EMmapcvxyz_to_uv (&msg_loc, EMS_TRIM_AGAINST_NATBDRY, other_sfdata,
         &xyzdata, chrdhttol, partol, &surfplanar, &uvdata2, &onsrf);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);

        if (surfplanar != EMS_O_Planar)
          cvtype2 = uvdata2.data.poly->num_points > 2 ? 
                     EMplanar_linestring : EMlinesegment;
        else
          cvtype2 = ME.EMSedge->curve_type;

        stat_OM = EMinternalpt (&msg_loc, &toxypln2->matrix_type, 
                   toxypln2->matrix, &uvdata2, EMScvint_lfend, 1, 
                   uvendpts[START]);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);
     
        stat_OM = EMinternalpt (&msg_loc, &toxypln2->matrix_type, 
                   toxypln2->matrix,  &uvdata2, EMScvint_rtend, 1,
                   uvendpts[STOP]);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);

        getendinfo_surf (&msg_loc, uvendpts, other_sf, other_os, tolfactor,
         &other_ptol, &endinfo2);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);

        /*
         * The orientation of this resultant uv-data is based on the
         * assumption that the uv-edge which corresponds to this xyz-edge
         * is convex. But if the edge has been earlier determined to be
         * concave, then the orientation has to be toggled. This can be
         * understood by looking at the definition of orientation - say
         * we were to orient this intersection keeping volume of the other
         * solid to our right. The moment the edge goes from being convex
         * to concave or vice-versa the direction of the intersection must
         * change in order to maintain the other volume on the right.
         */

        if (! edge_convex1)
          reverse_data2 = !reverse_data2;

        /*
         * It is left to determine whether the intersection is truly a valid
         * part of the output. It is possible that a condition exists wherein
         * "pushing" this intersection into the other coincident surface
         * does not retain a cutting intersection. See notes for explanation.
         * The intersection-delete function is called to determine this.
         */

        if (!output_deletable)
          output_deletable = intdel (
                              !(trim_options & EMSINT_TRIM_ONLYCUTTING),
                              same_side, 
                              this_edge_primary, 
                              edge_convex1, angmeas1);
        /*
         *  Code added to optionally retain/delete intersections, specific 
         *  to Add and Remove material. ---knap (05/31/94)
         */
        if ( this_edge_primary )
          {
          if ( trim_options & EMSINT_TRIM_RETAIN_ON_PRIMARY )
            if (output_deletable && same_side)
            {
              output_deletable = !output_deletable;
              reverse_data1 = !reverse_data1;
            }
          }
        else
          {
          if (trim_options & EMSINT_TRIM_DELETE_ON_SECONDARY )
            if (!output_deletable && same_side)
            {
              output_deletable = !output_deletable;
              reverse_data1 = !reverse_data1;
            }
          }
        }
       
      if (sf2_inters)
        {
        stat_OM = EMmkintdata (&msg_loc, &uvdata2, cvtype2, NULL,
                   FALSE, NULL, const_args, param_obj, &other_ptol.tol, NULL,
                   &uvintdata2);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);
        if (msg_loc == EMS_I_Degenerate)
          {
          uv2_props |= EMSintobj_uvdegenerate;
          output_deletable = TRUE;
          }

        if (uvintdata2.datatype == EMSdata_object && 
            uvdata2.datatype == EMSdata_object)
          uvdata2.data.object->objid = NULL_OBJID;
        }
      }


    if (output_world)
      {
      /*
       * This edge's geometry is converted back to 3D-model-space geometry
       * using the inverse transformation matrix provided. 
       * This is then formatted for acceptance into the intersection list.
       */

      datatype = xyzdata.datatype;
      if (datatype == EMSdata_poly3d)
        {
        poly = xyzdata.data.poly;
        count = poly->num_points;
        xyzpts = poly->points;

        stat_func = MAptsxform (&msg_loc, (IGRlong *)&count, towspace1->matrix,
                     xyzpts, xyzpts);
        EMerr_hndlr (!stat_func || EMSerror (msg_loc), *msg, EMS_E_MAerror,
         ret_end);
        }
      else
        {
        curve = xyzdata.data.curve;
        count = curve->num_poles;
        xyzpts = curve->poles;
 
        stat_func = MArptsxform (&msg_loc, (IGRlong *)&count, &curve->rational,
                     curve->weights, towspace1->matrix, xyzpts, xyzpts);
        EMerr_hndlr (!stat_func || EMSerror (msg_loc), *msg, EMS_E_MAerror,
         ret_end);
        }

      stat_OM = EMmkintdata (&msg_loc, &xyzdata, ME.EMSedge->curve_type, NULL,
                 TRUE, NULL, const_args, world_obj, &chrdhttol, NULL,
                 &xyzintdata);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);
      if (msg_loc == EMS_I_Degenerate)
        {
        uv1_props |= EMSintobj_xyzdegenerate;
        uv2_props |= EMSintobj_xyzdegenerate;
        output_deletable = TRUE;
        }
      }

    /*
     * The intersection data might have to be oriented such that the volume
     * represented by the other surface is to left or right of this 
     * intersection. Again by the characteristics of the method that 
     * generated this loopset, the data is naturally oriented with 
     * volume on the right. If the orientation requested is to be left
     * then reverse the output data.
     */

    if (orient_output = (outparam_options & EMSINT_ORIENT_OUTPUT ||
                         outworld_options & EMSINT_ORIENT_OUTPUT))
      {
      orient_right = (outparam_options & EMSINT_ORIENT_OUTPUT &&
                      outparam_options & EMSINT_ORIENT_RIGHT) ||
                     (outworld_options & EMSINT_ORIENT_OUTPUT &&
                      outworld_options & EMSINT_ORIENT_RIGHT);
      if (!orient_right)
        {
        reverse_data1 = ! reverse_data1;
        reverse_data2 = ! reverse_data2;
        }
      }

    /*
     * All the components for making a node on the intersection lists are
     * present. Call the function that puts these together into an
     * EMSintobj-node in the list. Also set the props bits. Note that
     * if the option is to output only "cutting-volume" intersections, 
     * the "movement" of the coincident plane into the volume of the 
     * other is to be reversed, viz, it now moves AWAY from the volume of
     * the other. This means that the intersection that was previously 
     * deletable is now to be kept and vice versa.
     */
    
    props = EMSintobj_coincident | EMSintobj_dupthissurf |
             (uv2_possibly_oncommon ? EMSintobj_dupothersurf : NULL);
    if (output_deletable)
      props |= EMSintobj_deletable;

    uv1_props |= props;
    uv2_props |= props;

    if (!IF_NULL_OBJID (endinfo1->edgeid) &&
        endinfo1->intloc != EMScvint_middle)
      uv1_props |= reverse_data1 ?
       EMSintobj_fwd_noconnectuv : EMSintobj_bwd_noconnectuv;
    if (!IF_NULL_OBJID (endinfo1->next->edgeid) &&
        endinfo1->next->intloc != EMScvint_middle)
      uv1_props |= reverse_data1 ?
       EMSintobj_bwd_noconnectuv : EMSintobj_fwd_noconnectuv;
    if (endinfo2)
      {
      if (!IF_NULL_OBJID (endinfo2->edgeid) &&
          endinfo2->intloc != EMScvint_middle)
        uv2_props |= reverse_data2 ?
         EMSintobj_fwd_noconnectuv : EMSintobj_bwd_noconnectuv;
      if (!IF_NULL_OBJID (endinfo2->next->edgeid) &&
          endinfo2->next->intloc != EMScvint_middle)
        uv2_props |= reverse_data2 ?
         EMSintobj_bwd_noconnectuv : EMSintobj_fwd_noconnectuv;
       }

    EMmakeintlist (&msg_loc, sf1_inters, sf2_inters, &uvsf1, &uvsf2, NULL, 
     NULL, NULL,NULL,&xyzintdata, &uvintdata1, &uvintdata2, 
     reverse_data1, reverse_data2, endinfo1, endinfo2, 
     uv1_props, uv2_props, &cvtype1, &cvtype2, TRUE, FALSE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, msg_loc, ret_end);
    (*num_inters)++;
    }
  else if (!output_deletable)
    {
    *msg = EMS_I_Intersect;
    *num_inters = TRUE;
    stat_OM = OM_I_STOP_SENDING;
    }
               
ret_end:
  if (other_sfdata)
    om$dealloc (ptr = other_sfdata);
  freealtdata (&xyzgeom);
  EMdataselect_data_free (&msg_loc, &uvdata1, 1);
  EMdataselect_data_free (&msg_loc, &uvdata2, 1);
 
  if (this_reversed)
    {
    stat_tmp = om$send (msg = message EMSedge.EMreverse (&msg_loc),
                targetid = my_id);
    if (EMSerror (msg_loc))
      *msg = EMS_E_EdgeError;
    }
 
  EMWRAPUP (*msg, stat_OM, "EMSedge.EMsfintdata");
  return (stat_OM);
}





/*
 * A support function to the above method. It accepts a model-space
 * curve data and the uv-edge it corresponds to. It finds the corresponding
 * uv-data on the edge that is common with the input uv-edge. Also returns
 * information about the points on this common-edge at which the endpoints
 * lie.
 */

IGRlong EMpushtocommon_mod (msg, mattyp, mat, this_srf, push_edge_with_primary,
                            xyzedge, xyzgeom, thissfid, thissfos,
                            uvedge, uvos, tolfactor, same_side, xyzrev, 
                            outobj, options, commsf, commuvdat, cvtype,
                            revdat, endparms, edge_convex, angmeas, partolb)
IGRlong *msg;
IGRshort *mattyp;
IGRmatrix mat;
IGRboolean this_srf, push_edge_with_primary;
GRobjid xyzedge, thissfid, uvedge;
struct EMSdataselect *xyzgeom;
GRspacenum thissfos, uvos;
IGRdouble tolfactor;
IGRboolean same_side, xyzrev, outobj;
IGRushort options;
struct GRid *commsf;
struct EMSdataselect *commuvdat;
IGRuchar *cvtype;
IGRboolean *revdat;
struct EMSsfintedpar **endparms;
IGRboolean *edge_convex;
IGRdouble *angmeas;
struct EMSpartolbasis *partolb;
{
  IGRboolean revconn, revgeom, incommeddir, partedge;
  IGRushort commprops, bit_mask;
  IGRint ptinx, numpts, blksize;
  IGRuint count;
  IGRlong msg_loc, stat_OM;
  IGRdouble xyzendpts[4][3], uvpts[4][2], intpoints[2][3];
  IGRdouble lentol;
  GRobjid commedge;
  GRclassid classid;
  struct EMSpartedinfo partinfo, *partptr;
  struct EMSedgebound startpar, stoppar, temppar;
  struct EMSsfintedpar *epptr;
  struct EMSpartolbasis *ptolptr, xyztolbas;
  struct EMSaltdataselect geom_loc;
  struct EMSproj_info int_prjpts[2];
  struct GRid *object;
  enum EMScvinttype startloc, stoploc;
  OM_S_CHANSELECT chan_to_common, chan_to_edge, chan_to_owner;
  OM_S_OBJECT_LINKAGE objlist;
  void initaltdata(), copydata();
  extern void EFtoggle();
  extern IGRint EMgetendpts_xyz();
  extern IGRlong EFget_clipped_edge_type();
  extern struct EMSsfintedpar *EMmkeparlist();
  extern IGRlong EMinternalpt();
  
  *msg = EMS_S_Success;
  stat_OM = OM_S_SUCCESS;
 
  /*
   * Initialize working variables
   */

  BSEXTRACTPAR (&msg_loc, BSTOLLENVEC, lentol);

  stat_OM = EMmake_chanselect (EMSedge_to_common_edge, &chan_to_common);
  EMomerr_exit (stat_OM, ret_end);

  /*
   * Obtain information about the common edge
   */

  count = 0;
  stat_OM = om$get_channel_objects (objid = uvedge, osnum = uvos, 
             p_chanselect = &chan_to_common, list = &objlist, size = 1,
             count = &count);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (!count, *msg, EMS_I_NoSolution, ret_end);
  commedge = objlist.S_objid;

  if (! partolb->is_valid)
    {
    partolb->in_world = TRUE;
    partolb->mattyp = mattyp;
    partolb->mat = mat;
    ptolptr = partolb;
    }
  else
    ptolptr = NULL;
  stat_OM = om$send (msg = message EMSboundary.EMgetsurface_info (&msg_loc,
             &commsf->objid, ptolptr), targetid = commedge, targetos = uvos,
             senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
  commsf->osnum = uvos;

  partedge = FALSE;
  if (!IF_NULL_OBJID (xyzedge))
    {
    stat_OM = om$get_classid (objid = xyzedge, p_classid = &classid);
    EMomerr_exit (stat_OM, ret_end);

    if (classid == OPP_EMSpartedge_class_id)
      partedge = TRUE;
    }

  stat_OM = om$send (msg = message EMSedge.EMget_props_type (&msg_loc,
             &commprops, cvtype), targetid = commedge, targetos = uvos,
             senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
  revconn = commprops & EMED_REVERSE_CONNECT;
  if (partedge || IF_NULL_OBJID (xyzedge))
    EFget_clipped_edge_type (&msg_loc, *cvtype, cvtype);

  /*
   * The edge parameters on the common edge that match the endpoints
   * of the model space edge/geometry are determined.
   */

  if (partedge || !this_srf)
    {
    /*
     * The endpoints have to be obtained by projection as there is no
     * direct topology to these values. Special care needs to be taken
     * if the projected uvpts lie on some seam edge. An ambiguous situation
     * exists.
     *
     * N.B: If the xyz-geometry is in the form of an edge, the geometry
     * does not have to be reversed, as this would have already been done.
     * Admittedly, this is inconsistent, but passing in geometry in the
     * form of buffers was an afterthought and was simply patched in.
     */

    if (!IF_NULL_OBJID (xyzedge))
      stat_OM = om$send (msg = message EMSedge.EMendpts (&msg_loc, 
                 xyzendpts[START], xyzendpts[STOP], NULL, NULL, NULL),
                 targetid = xyzedge, senderid = NULL_OBJID);
    else
      stat_OM = EMgetendpts_xyz (&msg_loc, mattyp, mat, xyzgeom, xyzrev,
                 1, xyzendpts[START], xyzendpts[STOP]);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
    numpts = 2;

    if (commprops & EMED_XYZ_CLOSED)
      {
      /*
       * The common edge runs from one seam-line of the common-surface
       * to the other (eg, cylinder) or the common-edge is closed in uv itself.
       * In these cases, internal point(s) are required to differentiate the
       * true section of the edge. See update in next para.
       *
       * 03/28/89: Two internal points are generated if this is not a partedge,
       * that is, the xyz geometry to be converted to an intersection edge is
       * itself closed (may not be true if xyz is passed in in the form of a
       * buffer, but it really does not matter, just overkill). Note that
       * edge-props apply to the uv-edge and not to the xyz curve. The reason
       * why two internal points are required here is because, in this case
       * of a closed xyz curve, the end-points along with one internal point
       * are not sufficient to indicate direction. The two internal points
       * obtained are ordered in the direction of the xyz curve. And this gives
       * conclusive data to determine direction. These internal points will be
       * the third and the fourth points.
       *
       * Some explanation needs to be given about the condition when the
       * common-edge is closed in xyz AND in uv. This is not a seam-edge
       * situation. In this case, the geometry used to be extracted as if the
       * edge was open (right upto 10/25/89). It was later realized that
       * if an endpoint of the xyz geometry terminated at the endpoint
       * of the uv-commedge, ambiguity does arise. In this case internal
       * points area generated to take care of the ambiguity. But the condition
       * when the section to be extracted spans across the endpoints should
       * never arise. It would mean, the creation of two separate geometries,
       * one for each portion on either side of the endpoint. Implying that to
       * start with, two separate xyz-geometries/edge should have been
       * generated. 
       */

      if (!IF_NULL_OBJID (xyzedge))
        {
        xyztolbas.tol = lentol;
        xyztolbas.is_valid = TRUE;
        stat_OM = om$send (msg = message EMSedge.EMinternalpt (&msg_loc,
                   !partedge ? 2 : 1, int_prjpts, NULL, NULL, &xyztolbas), 
                   targetid = xyzedge, senderid = NULL_OBJID);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);

        blksize = 2 * sizeof (IGRdouble);
        OM_BLOCK_MOVE (int_prjpts[0].proj_pt, xyzendpts[INTERNAL], blksize);
        numpts++;
        if (!partedge)
          {
          OM_BLOCK_MOVE (int_prjpts[1].proj_pt, xyzendpts[INTERNAL_NXT],
           blksize);
          numpts++;
          }
        }
      else
        {
        stat_OM = EMinternalpt (&msg_loc, mattyp, mat, xyzgeom,
                   EMScvint_middle, 2, (IGRdouble *)intpoints);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);

        if (xyzrev)
          {
          OM_BLOCK_MOVE (intpoints[1], xyzendpts[INTERNAL],
           sizeof (IGRpoint));
          OM_BLOCK_MOVE (intpoints[0], xyzendpts[INTERNAL_NXT],
           sizeof (IGRpoint));
          }
        else
          {
          blksize = 2 * sizeof (IGRpoint);
          OM_BLOCK_MOVE (intpoints, xyzendpts[INTERNAL], blksize);
          }
        numpts += 2;
        }
      }

    if (!IF_NULL_OBJID (xyzedge))
      for (ptinx=START; ptinx<numpts; ptinx++)
        xyzendpts[ptinx][Z] = 0.0;

    stat_OM = om$send (msg = message EMSsubbs.EMpratmpt (&msg_loc, 
               mattyp, mat, numpts, (IGRdouble *) xyzendpts,
               (IGRdouble *) uvpts, NULL, NULL),
               targetid = commsf->objid, targetos = uvos,
               senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);
    EMerr_hndlr (msg_loc == EMS_I_OutOfBounds, *msg, EMS_I_NoSolution,
     ret_end);

    /*
     * The end-point information on the to-be-extracted part is formatted
     * into the EMSsfintedpar linked list for output.
     */

    getendinfo_edge (&msg_loc, mattyp, mat, numpts, uvpts, commedge, 
     commprops & EMED_OPEN, commsf, tolfactor, partolb, endparms, FALSE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, msg_loc, ret_end);
    EMerr_hndlr (msg_loc == EMS_I_NoSolution, *msg, msg_loc, ret_end);
    }
  else
    {
    /*
     * A more direct way of obtaining end-points is available. These are
     * simply the endpoints of the common-edge. These endpoints should
     * correspond to the endpoints of the xyz-edge. The xyz-edge is assumed
     * to be in a consistent direction w.r.t the incoming uv-edge (not
     * the common edge). To extract the common-edges geometry consistent with
     * the model-space geometry, the reverse-connect bit comes in handy.
     * If the edges are reverse-connected, the geometry should be extracted 
     * in reverse and vice versa.
     */

    stat_OM = om$send (msg = message EMSedge.EMendpts (&msg_loc, 
               revconn ? uvpts[STOP] : uvpts[START],
               revconn ? uvpts[START] : uvpts[STOP],
               revconn ? &stoppar : &startpar,
               revconn ? &startpar : &stoppar, NULL),
               targetid = commedge, targetos = uvos, senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
    startloc = revconn ? EMScvint_rtend : EMScvint_lfend;
    stoploc = revconn ? EMScvint_lfend : EMScvint_rtend;
    
    EMmkeparlist (&msg_loc, endparms, startloc, commedge, startpar.span_inx,
     startpar.param, uvpts[START], NULL, FALSE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);

    EMmkeparlist (&msg_loc, endparms, stoploc, commedge, stoppar.span_inx,
     stoppar.param, uvpts[STOP], NULL, FALSE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);
    }

  if (options & EMSINT_ORIENT_OUTPUT)
    {
    stat_OM = chkedconvex (&msg_loc, xyzedge, thissfid, thissfos, xyzrev, uvos,
               commedge, commsf->objid, this_srf, same_side, mattyp, mat,
               edge_convex, angmeas);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_Fail, ret_end);
    }

  /*
   * The orientation idea can be stated as the desire to orient the output
   * geometry (from this function) such that it will produce a Boolean
   * 'intersection' result on the surfaces. It would suffice to determine
   * if the portion of the surface onto which this geometry is being pushed
   * (commsf) lies within the other surface (belonging to the other operand)
   * volume or not. If it lies within, then the geometry traverses such that
   * it follows the edge in direction. If the surface portion does not
   * lie within, then the geometry should traverse in a direction opposite
   * to the edge's. (The edge being spoken of here is the edge onto which
   * the pushing is being done, ie, commedge). The intersection output
   * going along an edge would cause the loops to close such that the original
   * loop is maintained.
   *
   * A table of possible topological interactions between the volumes of
   * the two operands can be drawn up. The table is drawn up knowing that
   * planar surface of operand A (the first operand) is always "pushed" (moved
   * across common-edge) into the volume of B. There will be configurations
   * which imply that no intersection need be output for this case. Taking into
   * account only those cases where an output is to be made, one can see that
   * if the volumes of the two planes are facing in opposite directions then
   * the correct orientation for the output is when it traverses in the
   * opposite direction of the common-edge. If the two volumes are facing
   * the same way, then if this surface belongs to operand A, the orientation
   * needs to be opposite of the common-edge, else if it belongs to B,
   * the orientation needs to be the same as the common-edge's. To determine
   * this info two pieces of info are necessary: a) same_side, and
   * b) push_edge_with_primary. Note that the intersections that are to 
   * flagged eventaully as deletable are not correctly oriented. In the
   * case when only "cutting-volume" intersections are desired the planar
   * surface of A is always "pushed" OUT of the volume of B (opposite of
   * what happens normally). This causes the orientations to be opposite
   * of what they would have been otherwise.
   *
   * From the end-point information gathered above, the parameters for
   * extraction are set, such that the uv-data is in the same direction as
   * the xyz-data. Looking at the parameters and the incidence information
   * one can tell if the edge is going in the direction of the common-edge
   * or not. Then one can apply the rule of the previous paragraph to
   * dictate whether this geometry should be reversed ("revdat").
   */

  incommeddir = same_side && !push_edge_with_primary;
  if (options & EMSINT_TRIM_ONLYCUTTING)
    incommeddir = !incommeddir;

  epptr = *endparms;
  startloc = epptr->intloc;
  stoploc = epptr->next->intloc;
  if (startloc == EMScvint_middle || stoploc == EMScvint_middle)
    {
    bit_mask = EMED_NATURAL | EMED_DEGENERATE | EMED_ISO;
    partinfo.edprops = commprops & bit_mask;
    partinfo.edprops |= EMED_OPEN;
    partinfo.edprops &= ~EMED_XYZ_CLOSED;

    revgeom = FALSE;
    startpar = epptr->edgepar;
    stoppar = epptr->next->edgepar;
    if (startpar.span_inx + startpar.param >
        stoppar.span_inx + stoppar.param)
      {
      partinfo.edprops |= EMED_REVERSED;
      if (options & EMSINT_ORIENT_OUTPUT && revdat)
        {
        if (commprops & EMED_REVERSED)
          *revdat = incommeddir ? FALSE : TRUE;
        else
          *revdat = incommeddir ? TRUE : FALSE;
        }
      }
    else
      {
      if (options & EMSINT_ORIENT_OUTPUT && revdat)
        {
        if (! (commprops & EMED_REVERSED))
          *revdat = incommeddir ? FALSE : TRUE;
        else
          *revdat = incommeddir ? TRUE : FALSE;
        }
      }

    partinfo.edbdry[START] = startpar;
    partinfo.edbdry[STOP] = stoppar;
    partinfo.edid = NULL_OBJID;

    partptr = &partinfo;
    }
  else
    {
    bit_mask = EMED_NATURAL | EMED_OPEN | EMED_XYZ_CLOSED |
                EMED_REVERSED | EMED_DEGENERATE | EMED_ISO;
    partinfo.edprops = commprops & bit_mask;

    if (startloc == EMScvint_rtend)
      {
      revgeom = TRUE;
      if (options & EMSINT_ORIENT_OUTPUT && revdat)
        *revdat = incommeddir ? TRUE : FALSE;
      }
    else
      {
      revgeom = FALSE;
      if (options & EMSINT_ORIENT_OUTPUT && revdat)
        *revdat = incommeddir ? FALSE : TRUE;
      }

    stat_OM = om$send (msg = message EMSedge.EMgetbounds (&msg_loc,
               partinfo.edbdry), targetid = commedge, targetos = uvos,
               senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
    if (revgeom)
      {
      temppar = partinfo.edbdry[0];
      partinfo.edbdry[0] = partinfo.edbdry[1];
      partinfo.edbdry[1] = temppar;
      EFtoggle (EMED_REVERSED, &partinfo.edprops);
      }
    partinfo.edid = NULL_OBJID;

    partptr = NULL;
    }

  /*
   * Extract the parameteric space geometry within the bounds just computed.
   * A part-edge is created if the output requested is to be in the form of
   * an object.
   */

  if (!outobj)
    {
    initaltdata (&geom_loc);
    stat_OM = om$send (msg = message EMSedge.EMgetgeom (&msg_loc, 0, MAXINT,
               revgeom, partptr, &geom_loc), targetid = commedge, 
               targetos = uvos, senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
    copydata (&msg_loc, &geom_loc, commuvdat, TRUE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, msg_loc, ret_end);
    }
  else
    {
    stat_OM = EMmake_chanselect (EMSbd_owner_to_comps, &chan_to_edge);
    EMomerr_exit (stat_OM, ret_end);

    stat_OM = EMmake_chanselect (EMSedge_to_owner, &chan_to_owner);
    EMomerr_exit (stat_OM, ret_end);

    /*
     * Create the part edge and connect it to the commedge. This
     * object is returned as the function's output.
     */

    object = (struct GRid *) om$malloc (size = sizeof (struct GRid));
    EMerr_hndlr (!object, *msg, EMS_E_NoDynamicMemory, ret_end);
    commuvdat->datatype = EMSdata_object;
    commuvdat->data.object = object;

    stat_OM = om$construct (classid = OPP_EMSdumedge_class_id,
               p_objid = &object->objid, osnum = uvos,
               msg = message EMSpartedge.EMpeinit (&msg_loc,
               partinfo.edprops, partinfo.edbdry, *cvtype));
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
    object->osnum = uvos;

    stat_OM = om$get_channel_count (objid = commedge, osnum = uvos,
               p_chanselect = &chan_to_owner, count = &count);
    EMomerr_exit (stat_OM, ret_end);

    stat_OM = om$send (msg = message Root.connect (chan_to_edge, count,
               commedge, uvos, chan_to_owner, NULL), targetid = object->objid,
               targetos = uvos, senderid = commedge);
    EMomerr_exit (stat_OM, ret_end);
    }

ret_end:
  EMWRAPUP (*msg, stat_OM, "EMsfintdata.EMpushtocommon_mod");
  return (stat_OM);
}



/*
 * A support function that projects the two input uv-end-points onto an
 * edge and returns information about the projection in a linked list
 * of EMSsfintedpar
 */

static IGRlong getendinfo_edge (msg, mattyp, mat, numpts, pts, edge, open_edge,
                                surf, tolfactor, partolb, info, recurs_call)
IGRlong *msg;
IGRshort *mattyp;
IGRmatrix mat;
IGRint numpts;
IGRdouble pts[2][2];
GRobjid edge;
IGRboolean open_edge;
struct GRid *surf;
IGRdouble tolfactor;
struct EMSpartolbasis *partolb;
struct EMSsfintedpar **info;
IGRboolean recurs_call;
{
  IGRboolean endpts_obtd, alter[2];
  IGRboolean found;
  IGRint endinx, blksize, numaltpts;
  IGRlong msg_loc, stat_OM;
  IGRdouble plentol, sqlentol, lentol, chrdhttol;
  IGRdouble *uvpt, uvpts[2][2], altpts[2][2], xyzpts[2][3];
  IGRdouble pars[4];
  GRspacenum os;
  struct EMSedgebound param, bounds[2];
  struct EMSproj_info projinfos[4];
  enum EMScvinttype loc;
  extern struct EMSsfintedpar *EMmkeparlist();

  *msg = EMS_S_Success;

  os = surf->osnum;
  EFextract_par (BSTOLLENVEC, partolb->tol, &plentol, &msg_loc);
  plentol *= tolfactor;
  BSEXTRACTPAR (&msg_loc, BSTOLLENVEC, lentol);
  BSEXTRACTPAR (&msg_loc, BSTOLCHRDHT, chrdhttol);

  /*
   * Obtain the paramteric points on the edge that correspond to the
   * input points. The first two points are the primary points. In cases
   * where the surface is physically closed, some ambiguity might arise
   * when the parametric point lies on a seam edge. This is resolved here
   * as far as possible. 
   */

  stat_OM = om$send (msg = message EMSedge.EMptproject (&msg_loc, 
             (IGRdouble *) pts, numpts, projinfos, NULL, partolb),
             targetid = edge, targetos = os, senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);

  blksize = 2 * sizeof (IGRdouble);
  for (endinx=START; endinx<numpts; endinx++)
    {
    if (projinfos[endinx].dist > plentol)
      {
      /*
       * Check if the corresponding model-space points are within
       * tolerance. If so then there is no problem.
       */

      OM_BLOCK_MOVE (projinfos[endinx].proj_pt, uvpts[0], blksize);
      OM_BLOCK_MOVE (pts[endinx], uvpts[1], blksize);
      stat_OM = om$send (msg = message GRvg.EMptatpr (&msg_loc, mattyp, mat,
                 (IGRdouble *) uvpts, 4, (IGRdouble *) xyzpts),
                 targetid = surf->objid, targetos = surf->osnum,
                 senderid = NULL_OBJID);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);

      sqlentol = chrdhttol * chrdhttol;
      if (BSdistptpts (&msg_loc, xyzpts[0], xyzpts[1]) > sqlentol)
        {
        /*
         * If the model-space points are also not within tolerance, check
         * out the possibility that these points might be seam-points on
         * the surface. If so, obtain the alternate uv-points and retry.
         * Only one such retry is permitted.
         */

        EMerr_hndlr (recurs_call, *msg, EMS_I_NoSolution, ret_end);

        stat_OM = om$send (msg = message EMSsubbs.EMaltparams (&msg_loc,
                   pts[endinx], plentol, &numaltpts, (IGRdouble *) altpts),
                   targetid = surf->objid, targetos = surf->osnum,
                   senderid = NULL_OBJID);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);
        EMerr_hndlr (msg_loc == EMS_I_NotFound, *msg,
         EMS_I_NoSolution, ret_end);

        OM_BLOCK_MOVE (altpts[0], pts[endinx], blksize);
        stat_OM =  getendinfo_edge (msg, mattyp, mat, numpts, pts, edge,
                    open_edge, surf, tolfactor, partolb, info, TRUE);
        goto ret_end;
        }
      }
    }

  if (numpts > 2)
    {
    /*
     * If three uv-points have been input, it implies that a check needs to
     * be made to see if the internal, third point lies in the middle
     * of the start and the stop. If it does not, check if an alternate
     * uv-point can be found for the start or the stop. Only one such
     * alternate point is permitted. See update in next para.
     *
     * 03/28/89: If alternate uv-points exist for both, the start and the
     * stop points, there is still an ambiguity as to which one of these
     * needs to be moved. The criteria for resolving this has to be related
     * to the direction of the model-space curve (the uv endpoints for which
     * this hunt is being conducted). Previously, the choice used to be
     * arbitrary (always only one internal point was used), and when the 
     * choice was wrong it would cause a mismatch in the xyz curve direction
     * vis-a-vis the uv curve direction. As a measure of the xyz curve's
     * direction, two internal points (instead of one) are used in this case.
     * These two internal points are known to be in the direction of the xyz
     * curve. Looking at these two internal points, the end-point that is not
     * consistent with this direction gets replaced by it's alternate point.
     */

    for (endinx=START; endinx<=INTERNAL_NXT; endinx++)
      {
      param = projinfos[endinx].param;
      pars[endinx] = param.span_inx + param.param;
      }

    if (numpts == 3)
      {
      if (! (pars[START] > pars[INTERNAL] && pars[INTERNAL] > pars[STOP]) &&
          ! (pars[STOP] > pars[INTERNAL] && pars[INTERNAL] > pars[START]))
        {
        EMerr_hndlr (recurs_call, *msg, EMS_I_NoSolution, ret_end);

        found = FALSE;
        for (endinx=START; endinx<=STOP; endinx++)
          {
          if (open_edge)
            {
            stat_OM = om$send (msg = message EMSsubbs.EMaltparams (&msg_loc,
                       pts[endinx], plentol, &numaltpts, (IGRdouble *) altpts),
                       targetid = surf->objid, targetos = surf->osnum,
                       senderid = NULL_OBJID);
            EMomerr_exit (stat_OM, ret_end);
            EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError,
             ret_end);

            if (msg_loc != EMS_I_NotFound)
              {
              OM_BLOCK_MOVE (altpts[0], pts[endinx], blksize);
              found = TRUE;
              break;
              }
            }
          else
            {
            if (projinfos[endinx].location == EMScvint_rtend)
              {
              projinfos[endinx].location = EMScvint_lfend;
              found = TRUE;
              break;
              }
            else if (projinfos[endinx].location == EMScvint_lfend)
              {
              projinfos[endinx].location = EMScvint_rtend;
              found = TRUE;
              break;
              }
            }
          }
        EMerr_hndlr (!found, *msg, EMS_I_NoSolution, ret_end);
        
        if (open_edge)
          {
          stat_OM =  getendinfo_edge (msg, mattyp, mat, numpts, pts, edge,
                      open_edge, surf, tolfactor, partolb, info, TRUE);
          goto ret_end;
          }
        }
      }
    else
      {
      if (pars[INTERNAL] < pars[INTERNAL_NXT])
        {
        alter[START] = !(pars[START] < pars[INTERNAL]);
        alter[STOP] = !(pars[INTERNAL_NXT] < pars[STOP]);
        }
      else
        {
        alter[START] = !(pars[START] > pars[INTERNAL]);
        alter[STOP] = !(pars[INTERNAL_NXT] > pars[STOP]);
        }

      if (alter[START] || alter[STOP])
        {
        EMerr_hndlr (recurs_call, *msg, EMS_I_NoSolution, ret_end);
        
        for (endinx=START; endinx<=STOP; endinx++)
          {
          if (alter[endinx])
            {
            if (open_edge)
              {
              stat_OM = om$send (msg = message EMSsubbs.EMaltparams (&msg_loc,
                         pts[endinx], plentol, &numaltpts, (IGRdouble *)altpts),
                         targetid = surf->objid, targetos = surf->osnum,
                         senderid = NULL_OBJID);
              EMomerr_exit (stat_OM, ret_end);
              EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError,
               ret_end);
              EMerr_hndlr (msg_loc == EMS_I_NotFound, *msg, EMS_I_NoSolution,
               ret_end);
  
              OM_BLOCK_MOVE (altpts[0], pts[endinx], blksize);
              }
            else
              {
              if (projinfos[endinx].location == EMScvint_rtend)
                projinfos[endinx].location = EMScvint_lfend;
              else if (projinfos[endinx].location == EMScvint_lfend)
                projinfos[endinx].location = EMScvint_rtend;
              else
                {EMerr_hndlr (TRUE, *msg, EMS_I_NoSolution, ret_end);}
              }
            }
          }

        if (open_edge)
          {
          stat_OM =  getendinfo_edge (msg, mattyp, mat, numpts, pts, edge,
                      open_edge, surf, tolfactor, partolb, info, TRUE);
          goto ret_end;
          }
        }
      }
    }

  /*
   * If the topological location of the projected point on the edge is either
   * left or right end - the projected point is forced to the correct
   * end-point. The output is then formatted.
   */

  endpts_obtd = FALSE;
  for (endinx=START; endinx<=STOP; endinx++)
    {
    loc = projinfos[endinx].location;
    if (loc == EMScvint_lfend || loc == EMScvint_rtend)
      {
      if (!endpts_obtd)
        {
        stat_OM = om$send (msg = message EMSedge.EMendpts (&msg_loc, 
                   uvpts[START], uvpts[STOP], &bounds[START], &bounds[STOP],
                   NULL), targetid = edge, targetos = os,
                   senderid = NULL_OBJID);
        EMomerr_exit (stat_OM, ret_end);
        EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
        endpts_obtd = TRUE;
        }
      uvpt = (loc == EMScvint_lfend ? uvpts[START] : uvpts[STOP]);
      param = (loc == EMScvint_lfend ? bounds[START] : bounds[STOP]);
      }
    else
      {
      uvpt = projinfos[endinx].proj_pt;
      param = projinfos[endinx].param;
      }

    EMmkeparlist (&msg_loc, info, loc, edge, param.span_inx, param.param,
     uvpt, NULL, FALSE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, msg_loc, ret_end);
    }

ret_end:
  EMWRAPUP (*msg, stat_OM, "EMsfintdata.endinfo_edge");
  return (stat_OM);
}


/*
 * A support function that obtains the topological information about the two
 * input uv-end-points w.r.t. the input surface and returns information about
 * the projection in a linked list of EMSsfintedpar
 */

static IGRlong getendinfo_surf (msg, pts, surf, os, tolfactor, partolb, info)
IGRlong *msg;
IGRdouble pts[2][2];
GRobjid surf;
GRspacenum os;
IGRdouble tolfactor;
struct EMSpartolbasis *partolb;
struct EMSsfintedpar **info;
{
  IGRint endinx, blksize;
  IGRlong msg_loc, send_rc, stat_OM;
  IGRdouble pt[2], plentol;
  GRobjid edge;
  struct EMSedgebound param;
  struct EMSlocated_edge *edgeinfo;
  struct EMSptloc_info ptloc_info;
  enum EMScvinttype loc;
  extern struct EMSsfintedpar *EMmkeparlist();

  *msg = EMS_S_Success;
  stat_OM = OM_S_SUCCESS;

  EFextract_par (BSTOLLENVEC, partolb->tol, &plentol, &msg_loc);
  plentol *= tolfactor;
  blksize = 2 * sizeof (IGRdouble);
  ptloc_info.options = EMS_PTLOC_CLOSEST_EDGE | EMS_PTLOC_ACTLOOP;
  for (endinx=START; endinx<=STOP; endinx++)
    {
    stat_OM = om$send (msg = message EMSsubbs.EMpassloop (&send_rc,
               message EMSloopset.EMpt_location (&msg_loc, pts[endinx],
               &ptloc_info, partolb)), targetid = surf, targetos = os,
               senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (send_rc), *msg, EMS_E_SurfaceError, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_LoopsetError, ret_end);

    if (ptloc_info.location == EMS_L_ONVRTX ||
        ptloc_info.location == EMS_L_ONEDGE ||
        ptloc_info.edge[0].nst_pt.dist < plentol)
      {
      edgeinfo = &ptloc_info.edge[0];
      param = edgeinfo->nst_pt.param;
      OM_BLOCK_MOVE (edgeinfo->nst_pt.proj_pt, pt, blksize);
      edge = edgeinfo->edge_id;
      loc = edgeinfo->nst_pt.location;
      }
    else
      {
      param.param = 0.0;
      param.span_inx = 0;
      pt[U] = pt[V] = 0.0;
      edge = NULL_OBJID;
      loc = EMScvint_unknown;
      }

    EMmkeparlist (&msg_loc, info, loc, edge, param.span_inx, param.param,
     pt, NULL, FALSE);
    EMerr_hndlr (EMSerror (msg_loc), *msg, msg_loc, ret_end);
    }

ret_end:
  EMWRAPUP (*msg, stat_OM, "EMsfintdata.endinfo_surf");
  return (stat_OM);
}


/*
 * A local function that checks whether a given edge is convex or
 * concave.
 */

#define MAX_ITER 5
#define OFFSET_FACTOR 0.0001
#define ORDER_OF_MAGNITUDE 10

static IGRlong chkedconvex (msg, xyzedge,
                            xyzedge_srf, xyzedge_srfos, xyzedge_rev, 
                            uvos, other_uvedge, other_srf,
                            other_xyzedge_adjacent, other_xyzedge_sameside,
                            mattyp, mat,
                            convex, angmeas)
IGRlong *msg;
GRobjid xyzedge, xyzedge_srf;
IGRboolean xyzedge_rev;
GRspacenum xyzedge_srfos, uvos;
GRobjid other_uvedge, other_srf;
IGRboolean other_xyzedge_adjacent, other_xyzedge_sameside;
IGRshort *mattyp;
IGRmatrix mat;
IGRboolean *convex;
IGRdouble *angmeas;
{
  IGRboolean into_vol, good_uvpt_found;
  IGRushort flag1, flag2, offpt_options;
  IGRuint count;
  IGRint i, num_iter;
  IGRlong msg_loc, stat_OM;
  IGRdouble lentol, dottol, dotp, uvpt[2], *xyztan;
  IGRdouble xyzpt[3], normpt[2][3];
  IGRdouble this_outtan[3], other_orntnor[3], new_other_orntnor[3];
  IGRdouble offdist, urange, vrange, prange;
  GRobjid coinced;
  struct EMSpartolbasis tolbas;
  struct EMSproj_info intpoint, tmp_intpoint[NUM_MIDDLE_PTS];
  struct IGRbsp_surface sfdef, *srf;
  OM_S_CHANSELECT chan_to_common;
  OM_S_OBJECT_LINKAGE objlist;

  *msg = EMS_S_Success;
  stat_OM = OM_S_SUCCESS;

  dottol = cos ((90.0 - EMS_ZEROANGLE_DEG_MAX) * (M_PI/180.0));
  BSEXTRACTPAR (&msg_loc, BSTOLLENVEC, lentol);

  /*
   * Obtain an internal point on the model-space edge and the natural
   * tangent vector at that point. If the xyzedge was reversed, this
   * is taken into account.
   */

  tolbas.tol = lentol;
  tolbas.is_valid = TRUE;
  stat_OM = om$send (msg = message EMSedge.EMinternalpt (&msg_loc,
             NUM_MIDDLE_PTS, tmp_intpoint, NULL, NULL, &tolbas),
             targetid = xyzedge, senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
  intpoint = tmp_intpoint[FIRST];

  OM_BLOCK_MOVE (intpoint.proj_pt, xyzpt, 2 * sizeof (IGRdouble));
  xyzpt[Z] = 0.0;
  xyztan = intpoint.tangent;
  if (xyzedge_rev)
    {
    xyztan[X] = -xyztan[X];
    xyztan[Y] = -xyztan[Y];
    }

  /*
   * Find the normal to this xyzedge such that it points out of the 
   * area of which the edge is a boundary. Since the xyz-edge is oriented
   * w.r.t. the positive z-axis, crossing the z-axis with this tangent
   * gives the desired normal. 
   */

  this_outtan[X] = -xyztan[Y];
  this_outtan[Y] = xyztan[X];
  this_outtan[Z] = 0.0;

  /*
   * Obtain the oriented normal (pointing toward volume) of the other
   * surface at the internal point obtained above. The "geometric"
   * "other surface" may not be the same as the topological "other surface".
   * A case in point is when the input "other surface" is a degenerate
   * one. For this purpose, the geometrically adjacent surface may be 
   * required. Also, the point at which the normal is computed for this
   * "other surface" is slightly away from the edge as probability of having
   * tangential-surface conditions are greater, right along an edge. This
   * latter technique will provide a more useful picture of how the
   * other surface is behaving at this edge. 
   *
   * If this this_uvedge and the other_uvedge are seam-edges on the same
   * surface (inferred by xyzedge_srf and other_srf being one and the same),
   * there is no need to search for another geometrically adjacent surface,
   * because, none can exist in this situation. So break out of the loop
   * the moment the uv-point is obtained.
   *
   * To prevent this while loop from becoming an infinite one due to some
   * unforeseen circumstance, put in a check to not iterate more than 
   * MAX_ITER. This number is an indication of the maximum number of
   * "degenerate" loops that can be topologically adjacent to one another.
   * Theoretically, it would seem that this loop should never become infinite,
   * even without this check.
   */

  num_iter = 0;
  good_uvpt_found = FALSE;
  while (!good_uvpt_found && num_iter <= MAX_ITER)
    {
    num_iter++;
    stat_OM = om$send (msg = message EMSsubbs.EMpratmpt (&msg_loc, 
               mattyp, mat, 1, xyzpt, uvpt, NULL, NULL),
               targetid = other_srf, targetos = uvos, 
               senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);
    EMerr_hndlr (msg_loc == EMS_I_OutOfBounds, *msg, EMS_I_NoSolution,
     ret_end);

    if (IF_EQ_OBJID (xyzedge_srf, other_srf))
      break;

    tolbas.mat = mat;
    tolbas.mattyp = mattyp;
    tolbas.is_valid = FALSE;
    tolbas.in_world = TRUE;

    stat_OM = om$send (msg = message EMSedge.EMptcoinc (&msg_loc, uvpt,
               &coinced, NULL, NULL, NULL, &tolbas), targetid = other_uvedge,
               targetos = uvos, senderid = NULL_OBJID);
    EMomerr_exit (stat_OM, ret_end);
    EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);

    if (msg_loc == EMS_I_Found)
      {
      stat_OM = EMmake_chanselect (EMSedge_to_common_edge, &chan_to_common);
      EMomerr_exit (stat_OM, ret_end);

      stat_OM = om$get_channel_objects (objid = coinced, osnum = uvos, 
                 p_chanselect = &chan_to_common, list = &objlist, size = 1,
                 count = &count);
      EMomerr_exit (stat_OM, ret_end);
      other_uvedge = objlist.S_objid;

      stat_OM = om$send (msg = message EMSboundary.EMgetsurface_info (&msg_loc,
                 &other_srf, NULL), targetid = other_uvedge, targetos = uvos,
                 senderid = NULL_OBJID);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);
      }
    else
      good_uvpt_found = TRUE;
    }

  /*
   * Obtain the oriented unit-normal at the uv-point just computed. Also, if
   * the surface is non-planar the uv-point may have to be moved
   * inward into the surface somewhat to get a true representative
   * normal (further explanation below).
   */

  EMunlock_surf_absg_buffer();
  stat_OM = om$send (msg = message EMSsubbs.EMgetabsgeom (&msg_loc, mattyp,
             mat, (IGRchar **) &srf), targetid = other_srf, targetos = uvos, 
             senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);

  stat_OM = om$send (msg = message EMSsubbs.EMsftanorm (&msg_loc, mattyp,
             mat, NULL, 1, &uvpt[U], 1, &uvpt[V], 1.0, NULL, FALSE, TRUE,
             (IGRdouble *) normpt, NULL), targetid = other_srf, 
             targetos = uvos, senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);
  for (i=X; i<=Z; i++)
    other_orntnor[i] = normpt[1][i] - normpt[0][i];

  if (! srf->planar)
    {
    /*
     * If the surface is non-planar the point at which to determine
     * the normal might involve tangency (statistically speaking,
     * the chances for tangency-conditions to occur are greater at the
     * edges). So take a point slightly offset from the edge for this 
     * purpose. This will enable a more workable normal to be obtained.
     * Of course, the problem is to determine the amount of offset.
     * OFFSET_FACTOR times the smallest parametric range (either in u or
     * v direction) of the surface is used. If the normal now computed
     * does not differ from the previously computed one by atleast
     * the tolerance amount, the offset distance is increased by an order
     * of magnitude. This procedure is followed until the offset distance
     * exceeds the parametric range; at which point the normal so obtained
     * is itself used.
     */

    urange = srf->u_knots[srf->u_num_poles] - srf->u_knots[srf->u_order-1];
    vrange = srf->v_knots[srf->v_num_poles] - srf->v_knots[srf->v_order-1];
    if (urange < vrange)
      prange = urange;
    else
      prange = vrange;
    offdist = prange * OFFSET_FACTOR;

    good_uvpt_found = FALSE;
    offpt_options = EMSoffpt_Scalar | EMSoffpt_NoTravel | EMSoffpt_OffDistUv;
    while (!good_uvpt_found && offdist < prange)
      {
      stat_OM = om$send(msg = message EMSedge.EMoffpoint(&msg_loc, NULL, uvpt, 
		 NULL, offdist, NULL, srf, NULL, &tolbas, NULL, NULL, NULL, 
		 offpt_options, uvpt, NULL, NULL), targetid = other_uvedge,
                 targetos = uvos, senderid = NULL_OBJID);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_EdgeError, ret_end);

      stat_OM = om$send (msg = message EMSsubbs.EMsftanorm (&msg_loc, mattyp,
                 mat, NULL, 1, &uvpt[U], 1, &uvpt[V], 1.0, NULL, FALSE, TRUE,
              (IGRdouble *)normpt, NULL), targetid = other_srf, targetos = uvos,
                 senderid = NULL_OBJID);
      EMomerr_exit (stat_OM, ret_end);
      EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);
      for (i=X; i<=Z; i++)
        new_other_orntnor[i] = normpt[1][i] - normpt[0][i];

      dotp = BSdotp (&msg_loc, new_other_orntnor, other_orntnor);
      if (1.0 - dotp > dottol)
        {
        for (i=X; i<=Z; i++)
          other_orntnor[i] = new_other_orntnor[i];
        good_uvpt_found = TRUE;
        }
      offdist *= ORDER_OF_MAGNITUDE;
      }
    }

  if (!srf->pos_orient)
    {
    other_orntnor[X] = -other_orntnor[X];
    other_orntnor[Y] = -other_orntnor[Y];
    other_orntnor[Z] = -other_orntnor[Z];
    }

  /*
   * If the dot product between the outward-tangent and the inward normal
   * is negative, the edge is convex. If it is positive, the edge is 
   * concave. If the abs-value of the product is within tolerance, the
   * edge is neutral. In this latter case, the edge is treated as
   * convex. The tolerance is applied on the angle subtended by these two
   * vectors. Knowing that the vectors are normalized, the dot-product
   * tolerance then is the cosine of the zero-angle.
   */

  dotp = BSdotp (&msg_loc, this_outtan, other_orntnor);
  if (dotp > dottol)
    *convex = FALSE;
  else
    *convex = TRUE;

  /*
   * The value of the dot-product can be manipulated to be a measure of the
   * included angle (smaller) along this edge. To begin with, the raw value
   * is not monotonically increasing with increasing angle. For the same value
   * of the dot-product, two different positions of the other surface are
   * possible - one on either side of this surface. This can be seen with
   * the above dot-product. The dot-product values for a convex edge begin
   * from 0 to -1 to 0 with increasing included angle. Similarly, for a
   * concave edge it goes from 0 to 1 to 0 with increasing angle. 
   *
   * To derive the ang-measure of the small included angle the dot-product is
   * doctored as follows:- First "this_orntnor" is obtained (either the pos
   * or neg Z-axis). This vector - "this_orntnor" belongs to the surface
   * topologically adjacent to the "other_srf". If the surface corresponding
   * to "xyzedge_srf" is not the adjacent surface ("other_xyzedge_adjacent" is
   * FALSE), then the relationship of the "xyzedge_srf" to the true adjacent
   * surface is coded in "other_xyzedge_sameside". If this latter is TRUE then
   * the volume side of the adjacent side is the same as the "xyzedge_srf".
   * This can then be used to obtain the direction of the oriented normal
   * on the adjacent surface.
   *
   * The sign of the dot-product between "this_orntnor" and "other_orntnor"
   * tells whether "other_orntnor" points out of the volume region or into it.
   * This dot-product can be optimized to a single comparison. The sign tells
   * whether the dot-product computed above has crossed the half-way mark or
   * not. Now, the value of the dot-product can be easily transformed to read
   * monotonically increasing from 0 to 2 with increasing included angle.
   *
   * 10/22/88:
   * But the angle-measure to be output for the edge now needs to be a
   * measure ranging from 0 to 4. This is the new improved way of giving the
   * angle-measure. This is the included angle bounding the volume (and not
   * necessarily the smallest angle). Values less than 2 imply a convex vertex
   * and values greater than 2 imply a concave vertex.
   */

  stat_OM = om$send (msg = message EMSsubbs.EMgetbsdef (&msg_loc, &sfdef),
             targetid = xyzedge_srf, targetos = xyzedge_srfos,
             senderid = NULL_OBJID);
  EMomerr_exit (stat_OM, ret_end);
  EMerr_hndlr (EMSerror (msg_loc), *msg, EMS_E_SurfaceError, ret_end);

  if (!other_xyzedge_adjacent)
    flag1 = other_xyzedge_sameside ? 
             (sfdef.pos_orient ? 0x1 : 0x0) : (sfdef.pos_orient ? 0x0 : 0x1);
  else
    flag1 = sfdef.pos_orient ? 0x1 : 0x0;
  flag2 = xyzedge_rev ? 0x1 : 0x0;

  if (flag1 ^ flag2)
    into_vol = other_orntnor[Z] > 0.0;
  else
    into_vol = other_orntnor[Z] < 0.0;

  dotp = fabs (dotp);
  if (into_vol)
    *angmeas = HALF_ANGLE_MEASURE - dotp;
  else
    *angmeas = dotp;

  if (!*convex)
    *angmeas = FULL_ANGLE_MEASURE - *angmeas;

ret_end:
  EMWRAPUP (*msg, stat_OM, "EMsfintdata.chkedconvex");
  return (stat_OM);
}


/*
 * Local functions that checks whether the output of this edge is
 * deletable. See notes for more details. The primary logic has been
 * derived for the case where one surface "penetrates" into the volume
 * of the other. When the one surface is deemed to be moved "out" of the
 * volume of the other, the logic flips. But in the border-line case
 * where the criterion indicates equality with the tolerance, the 
 * logic that would have considered the intersection deletable is made
 * to prevail.
 */

static IGRboolean coincintdel (is_penetrating, sameside, angmeas1, angmeas2)
IGRboolean is_penetrating, sameside;
IGRdouble angmeas1, angmeas2;
{
  IGRboolean is_deletable;
  IGRdouble tol;
  IGRdouble angmeas2_compliment;

  tol = cos ((90.0 - EMS_ZEROANGLE_DEG_MAX) * (M_PI/180.0));

  if (sameside)
    {
    if (fabs (angmeas1-angmeas2) <= tol)
      is_deletable = TRUE;
    else
      {
      is_deletable = angmeas1 < angmeas2;
      if (!is_penetrating)
        is_deletable = !is_deletable;
      }
    }
  else
    {
    angmeas2_compliment = FULL_ANGLE_MEASURE-angmeas2;
    if (fabs (angmeas1-angmeas2_compliment) <= tol)
      is_deletable = TRUE;
    else
      {
      is_deletable =  angmeas1 > angmeas2_compliment;
      if (!is_penetrating)
        is_deletable = !is_deletable;
      }
    }

  return (is_deletable);
}

static IGRboolean intdel (is_penetrating, 
                          sameside,
                          edge_primary, 
                          edge_convex, angmeas)
IGRboolean sameside, edge_primary, edge_convex;
IGRdouble angmeas;
{
  IGRboolean is_deletable;
  IGRdouble tol;

  tol = cos ((90.0 - EMS_ZEROANGLE_DEG_MAX) * (M_PI/180.0));

  if (fabs (angmeas - FLAT_ANGLE_MEASURE) <= tol)
    is_deletable = TRUE;
  else if (sameside)
    {
    is_deletable = edge_primary ? edge_convex : !edge_convex;
    if (!is_penetrating)
      is_deletable = !is_deletable;
    }
  else
    {
    is_deletable = !edge_convex;
    if (!is_penetrating)
      is_deletable = !is_deletable;
    }
  return (is_deletable);
}


/*
 * Support functions that do simple tasks which are more or less
 * self evident. These exist in order to reduce the total amount of code
 * or to maintain some degree of readability in the main code.
 */

static void swapptrs (ptr1, ptr2)
IGRchar **ptr1, **ptr2;
{
  IGRchar *temp;

  temp = *ptr1;
  *ptr1 = *ptr2;
  *ptr2 = temp;
}

static void initaltdata (geom)
struct EMSaltdataselect *geom;
{
  struct IGRpolyline *py;
  struct IGRbsp_curve *crv;

  geom->datatype = EMSdata_null;
  py = &geom->data.poly;
  py->points = NULL;
  crv = &geom->data.curve;
  crv->poles = NULL;
  crv->knots = NULL;
  crv->weights = NULL;
  crv->bdrys = NULL;
}

static void initdata (data)
struct EMSdataselect *data;
{
  data->datatype = EMSdata_null;
  data->data.poly = NULL;
  data->data.curve = NULL;
}

static void copydata (msg, geom, data, tomalloc)
IGRlong *msg;
struct EMSaltdataselect *geom;
struct EMSdataselect *data;
IGRboolean tomalloc;
{
  struct IGRbsp_curve *cvin, *cvout;
  struct IGRpolyline *pyin, *pyout;

  if ((data->datatype = geom->datatype) == EMSdata_curve3d)
    {
    cvin = cvout = &geom->data.curve;
    if (tomalloc)
      {
      cvout = (struct IGRbsp_curve *) om$malloc (size = sizeof 
               (struct IGRbsp_curve));
      EMerr_hndlr (! cvout, *msg, EMS_E_NoDynamicMemory, ret_end);
      *cvout = *cvin;
      }
    data->data.curve = cvout;
    }
  else
    {
    pyin = pyout = &geom->data.poly;
    if (tomalloc)
      {
      pyout = (struct IGRpolyline *) om$malloc (size = sizeof 
               (struct IGRpolyline));
      EMerr_hndlr (! pyout, *msg, EMS_E_NoDynamicMemory, ret_end);
      *pyout = *pyin;
      }
    data->data.poly = pyout;
    }

ret_end:;
}


static void freealtdata (geom)
struct EMSaltdataselect *geom;
{
  IGRchar *p;
  struct IGRpolyline *py;
  struct IGRbsp_curve *crv;
  union EMSaltdata *data;
  enum EMSdatatype datatype;

  datatype = geom->datatype;
  data = &geom->data;
  if (datatype == EMSdata_poly2d || datatype == EMSdata_poly3d)
    {
    py = &data->poly;    
    if (p = (IGRchar *) py->points)
      om$dealloc (ptr = p);
    geom->datatype = EMSdata_null;
    }
  else if (datatype == EMSdata_curve3d)
    {
    crv = &data->curve;
    if (p = (IGRchar *) crv->poles)
      om$dealloc (ptr = p);
    if (p = (IGRchar *) crv->knots)
      om$dealloc (ptr = p);
    if (p = (IGRchar *) crv->weights)
      om$dealloc (ptr = p);
    if (p = (IGRchar *) crv->bdrys)
      om$dealloc (ptr = p);
    geom->datatype = EMSdata_null;
    }
}

end implementation EMSedge;
