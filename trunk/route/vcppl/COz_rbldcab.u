/* $Id: COz_rbldcab.u,v 1.3 2002/04/10 18:57:22 louis Exp $  */

/***************************************************************************
 * I/ROUTE
 *
 * File: vrppl/COz_rbldcab.u
 *
 * Description: Allows the selection of a single cable to rebuild-
 *              1) Assigning random cable set of collectors as parents
 *              2) Identifying the positions of the ends of the cable
 *              3) Scanning the terminal objects to identify if the
 *                 terminal position is identical to the position.
 *              4) If no terminal is available, or multiple possibilities exist,
 *                 the instance has to be reset for offset/vector.
 *              5) An error message needs to specify the problem.
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_rbldcab.u,v $
 *	Revision 1.3  2002/04/10 18:57:22  louis
 *	TR5649-standardize tolerances
 *	
 *	Revision 1.2  2002/01/15 19:46:33  louis
 *	extern function
 *	
 *	Revision 1.1  2001/12/20 23:36:14  louis
 *	Added for tr5927
 *	
 *	
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 *	12/20/01	L.Waddell	TR5927-bebuild the cable object
 *      04/05/02        law             TR5649-standardize tolerance with
 *                                       VRGetTol
 *
 ***************************************************************************/
#include "VDppl.h"
#include "VRMath.h"
#include "vrdbgmacros.h"
#include "VCCmdDef.h"
#include "vc_define.h"
#include "vc_structs.h"
#include "VCstructs.h"
#include "VCstructs2.h"
#include "VDmem_ppl.h"

main()
{
    IGRlong	sts,msg;
    struct GRid	a, list[4];
    GRclassid	class_array[2];
    IGRmatrix	Matrix;
    IGRdouble   dMat[16];
    IGRint i,count,state[4];
    IGRint retmsg,cn_type;
    struct GRid  context, new_objid, good_sys, good_usr;
    IGRint sys_usr;
    IGRint first_pick,goodsysnotfnd,goodusrnotfnd,good_notfound;
    struct GRid SysID, UsrID, *NewTemplates;
    struct GRmd_env	md_env;
    IGRint             status;
    GRspacenum nOS;
    struct GRid ObjParents[20], *loc_obj;
    OM_S_CLASSLIST	locate_eligible_thing;
    IGRint NbKids, NbParents, noclasses, off, loci, outnoterms, noparents;
    IGRshort NoOffsets, nCpNum;
    struct VCOffset *pOffset, nuOffset;
    IGRdouble   *pvert;
    struct VCCL_sectmap    *pOsect;
    IGRint locp, tcnt, missrbadterm, j, nOsect, nOvert;
    struct VCGenInfo        Instance;
    IGRlong      lngmsg;

    extern VCobjInActiveSpace();
    extern GRclassid   OPP_VCElCable_class_id;
    extern GRclassid   OPP_VCFoCable_class_id;
    extern GRclassid   OPP_VCElTerm_class_id;
    extern GRclassid   OPP_VCFoTerm_class_id;

    extern struct GRid NULL_GRID;
    struct loc_term_str
    {
	    IGRint offset_defined;
	    IGRint term_fnd_flg;
	    IGRint term_err_flg;
	    IGRshort endflg;
	    IGRdouble OffVec[3];
	    IGRdouble term_coord[3];
	    struct GRid term_fnd_id;
    } loc_cab_con[2];

    ci$get_module_info( md_env = &md_env );

    class_array[0] = OPP_VCElCable_class_id;
    class_array[1] = OPP_VCFoCable_class_id;
    locate_eligible_thing.w_count = 2;
    locate_eligible_thing.p_classes = &class_array[0];

    ci$locate ( prompt          = "Select Cable Object",
		eligible_classes= &locate_eligible_thing,
		obj             = &a.objid,
		osnum           = &a.osnum,
		md_env          = &md_env ) ;

    __DBGpr_obj(" object",a);

    /* Look for a cable object with collectors */
    /* Would prefer a collector used by more than 1 object */
    noclasses = 2;
    sts = VCobjInActiveSpace( &msg, &count, &loc_obj, class_array, noclasses );
    first_pick = 1;
    goodsysnotfnd = 1;
    goodusrnotfnd = 1;
    good_notfound = 1;
    for(i=0; i<count && good_notfound; i=i+1)
    {
       ci$send(msg = message NDnode.NDget_objects
                             ( ND_ROOT, ObjParents, 20, NULL,
                             0, OM_K_MAXINT, &NbParents ),
                  targetid = loc_obj[i].objid,
                  targetos = loc_obj[i].osnum);
       if(NbParents >= 2)
       {
         /* If first pickup - set flag */
         if(first_pick)
         {
           good_sys = ObjParents[0]; 
           good_usr = ObjParents[1];
           first_pick = 0;
         } 
         /* if collection on more than 1 object, will do */
         if(goodsysnotfnd)
         {
            sts = ci$send( msg = message NDnode.NDget_objects( ND_CHILDREN,
                                                           NULL, 0,
                                                           NULL, 0,
                                                           OM_K_MAXINT,
                                                           &NbKids ),
                  targetid = ObjParents[0].objid,
                  targetos = ObjParents[0].osnum );
            if(NbKids > 1)
            {
               goodsysnotfnd = 0;
               good_sys = ObjParents[0];
            }
         }
         if(goodusrnotfnd)
         {
            sts = ci$send( msg = message NDnode.NDget_objects( ND_CHILDREN,
                                                           NULL, 0,
                                                           NULL, 0,
                                                           OM_K_MAXINT,
                                                           &NbKids ),
                  targetid = ObjParents[1].objid,
                  targetos = ObjParents[1].osnum );
            if(NbKids > 1)
            {
               goodusrnotfnd = 0;
               good_usr = ObjParents[1];
            }

         }

         if(!goodsysnotfnd && !goodusrnotfnd) good_notfound = 0;
       } /* end collector present */
    } /* end loop for all cables */
    if( count )
    {
        free( loc_obj );
        loc_obj = NULL;
    }

    if(first_pick)
    {
      printf("No good collector set on any cable-please sketch a cable\n");
      UI_status("No good collector set on any cable-please sketch a cable");
      return;
    }


    ci$send(msg = message NDnode.NDget_objects(ND_ROOT, NULL, 0, NULL, 0,
                          OM_K_MAXINT, &count),
                  targetid = a.objid,
                  targetos = a.osnum);
      /* Get a random set of collectors */
    if(count == 0)
    {
      nOS = a.osnum;
      SysID = good_sys;
      UsrID = good_usr;
//printf("random sys-collect id %d --- user id %d\n",SysID.objid,UsrID.objid);
      if(SysID.objid == NULL_OBJID || UsrID.objid == NULL_OBJID)
      {
        /* Cable should not be rebuilt */ 
        printf("File missing active default collectors. Sketch a cable\n");
        return;
      }

      /* Get the cable end locations */
      /* Have to get instance twice to prevent malloc problems */
      Instance.Attr.Cable.pSect   = NULL;
      Instance.Attr.Cable.pVertex = NULL;
      status =
          ci$send(msg = message VCRoot.VCGetInstance (&lngmsg,&Instance),
                  targetid = a.objid,
                  targetos = a.osnum );

      nOsect = Instance.Attr.Cable.NbSections;  /* safeguard malloc  */
      nOvert = Instance.Attr.Cable.NbVertices;  /* safeguard malloc  */
//printf("novertices in cable %d\n",nOvert);

      /*   allocate temp space   */
      pvert = _MALLOC ((3 * (nOvert + 1)), IGRdouble);
      pOsect = _MALLOC ((nOsect+1), struct VCCL_sectmap);

      if (pvert==NULL || pOsect==NULL )
      {
        printf("No dynamic memory\n");
        return;
      }

      Instance.Attr.Cable.pSect   = pOsect;
      Instance.Attr.Cable.pVertex = pvert;
      status =
          ci$send(msg = message VCRoot.VCGetInstance (&lngmsg,&Instance),
                   targetid = a.objid,
                   targetos = a.osnum);
      /* count the number of offset values */
      /* Get the offset values for the cable */
      pOffset = NULL;
      status =
         ci$send( msg      = message VCCable.VCCGetOffset
                                       ( (void *)&pOffset, &NoOffsets),
                   targetid = a.objid,
                   targetos = a.osnum);

      __DBGpr_int(" NoOffsets",NoOffsets);
//printf("%d terminals attached to this cable\n",NoOffsets);

      /* For each offset value */
      for(off=0; off<2; off = off + 1)
      {
        loc_cab_con[off].offset_defined = 0;
        loc_cab_con[off].term_fnd_flg = 0;
        loc_cab_con[off].term_err_flg = 0;
        loc_cab_con[off].OffVec[0] = 0.;
        loc_cab_con[off].OffVec[1] = 0.;
        loc_cab_con[off].OffVec[2] = 0.;
      }
      if(NoOffsets)
      {
        loci = (pOffset)->Index;
        loc_cab_con[loci].offset_defined = 1;
        locp = (nOvert-1) * 3 * loci;
//printf("index of point at end %d is %d\n",loci,locp);
        loc_cab_con[loci].endflg = (pOffset)->Index;
        loc_cab_con[loci].OffVec[0] = pOffset->Offset[0];
        loc_cab_con[loci].OffVec[1] = pOffset->Offset[1];
        loc_cab_con[loci].OffVec[2] = pOffset->Offset[2];
        loc_cab_con[loci].term_coord[0] = pvert[locp] - pOffset->Offset[0];
        loc_cab_con[loci].term_coord[1] = pvert[locp+1] - pOffset->Offset[1];
        loc_cab_con[loci].term_coord[2] = pvert[locp+2] - pOffset->Offset[2];

/******
printf("cable end %d is at %f %f %f\n",loci,pvert[locp],pvert[locp+1],pvert[locp+2]);
printf("offsets for end %d is %f %f %f\n",loci,pOffset->Offset[0],pOffset->Offset[1],pOffset->Offset[2]);
printf("term for end %d should be at %f %f %f\n",loci,loc_cab_con[loci].term_coord[0],loc_cab_con[loci].term_coord[1],loc_cab_con[loci].term_coord[2]);
******/

        if(NoOffsets = 2)
        {
          loci = (pOffset+1)->Index;
          loc_cab_con[loci].offset_defined = 1;
          locp = (nOvert-1) * 3 * loci;
          loc_cab_con[loci].endflg = (pOffset+1)->Index;
//printf("index of point at end %d is %d\n",loci,locp);
          loc_cab_con[loci].term_coord[0] = pvert[locp] - (pOffset+1)->Offset[0];
          loc_cab_con[loci].term_coord[1] = pvert[locp+1] - (pOffset+1)->Offset[1];
          loc_cab_con[loci].term_coord[2] = pvert[locp+2] - (pOffset+1)->Offset[2];
          loc_cab_con[loci].OffVec[0] = (pOffset+1)->Offset[0];
          loc_cab_con[loci].OffVec[1] = (pOffset+1)->Offset[1];
          loc_cab_con[loci].OffVec[2] = (pOffset+1)->Offset[2];
/******
printf("cable end %d is at %f %f %f\n",loci,pvert[locp],pvert[locp+1],pvert[locp+2]);
printf("offsets for end %d is %f %f %f\n",loci,(pOffset+1)->Offset[0],(pOffset+1)->Offset[1],(pOffset+1)->Offset[2]);
printf("term for end %d should be at %f %f %f\n",loci,loc_cab_con[loci].term_coord[0],loc_cab_con[loci].term_coord[1],loc_cab_con[loci].term_coord[2]);
*******/
        }
      }
         /* Compute the terminal location */

      /* Get a list of all terminals */
      class_array[0] = OPP_VCElTerm_class_id;
      class_array[1] = OPP_VCFoTerm_class_id;
      noclasses = 2;
      tcnt = 0;
      sts = VCobjInActiveSpace(&msg, &tcnt, &loc_obj, class_array, noclasses );
      /* For each offset value */
      missrbadterm = 0;
      for(off = 0; off < 2; off = off + 1)
      {
        if(loc_cab_con[off].offset_defined)
        {
	 /* For all terminals */
         for(j = 0; j < tcnt; j = j+1)
         {
	    /* Get the location of the terminal */
            ci$send (msg = message VCRoot.VCGetMatrix (msg, 
                                                  nCpNum, dMat, &md_env),
                       targetid = loc_obj[j].objid,
                       targetos = loc_obj[j].osnum);

//printf("Terminal %d is at %f %f %f\n",loc_obj[j].objid,dMat[3],dMat[7],dMat[11]);
            /* Check if location where cable wants it to be */ 
            if((fabs(loc_cab_con[off].term_coord[0] - dMat[3]) <
                                                 VRGetTol(VR_DIST_TOL)) &&
               (fabs(loc_cab_con[off].term_coord[1] - dMat[7]) < 
                                                 VRGetTol(VR_DIST_TOL)) &&
               (fabs(loc_cab_con[off].term_coord[2] - dMat[11]) < 
                                                 VRGetTol(VR_DIST_TOL)))
            {
//printf("terminal found on end %d is %d\n",loc_cab_con[off].endflg,loc_obj[j].objid);
               /* If the terminal identified */
               if(loc_cab_con[off].term_fnd_flg)
               {
                  /* If already found-Set the error flag */
                  loc_cab_con[off].term_err_flg = 1;
               }
               else /* remember the terminal id */
               {
                  loc_cab_con[off].term_fnd_flg = 1;
                  loc_cab_con[off].term_fnd_id = loc_obj[j];
               }
            } /* end terminal found */
	 } /* End terminal loop */
         /* If an error or not found */
         if(!loc_cab_con[off].term_fnd_flg || loc_cab_con[off].term_err_flg)
         {
            /* set bad term flag */
            missrbadterm = 1;
            /* reset NoOffsets */
            NoOffsets = NoOffsets - 1;
         }
        } /* end if offset */
      } /* End offset processing */
      if( tcnt )
      {
          free( loc_obj );
          loc_obj = NULL;
          if (pvert) free (pvert);
          if (pOsect) free (pOsect);
      }
      /* Add the two as parents to the cable */
      if(missrbadterm)
      {
        outnoterms = 0;
        for(off=0; off<2; off = off + 1)
        {
          /* not using original pOffset pointer */
          if(loc_cab_con[off].term_fnd_flg || !loc_cab_con[off].term_err_flg)
          {
            /* If an error will be max of 1 term offset vector) */
//printf("store array %d has aterminal at end %d\n",off,loc_cab_con[off].endflg);
            nuOffset.Index = loc_cab_con[off].endflg;
            nuOffset.Offset[0]=loc_cab_con[off].OffVec[0];
            nuOffset.Offset[1]=loc_cab_con[off].OffVec[1];
            nuOffset.Offset[2]=loc_cab_con[off].OffVec[2];
          }
        }
        status =
          ci$send( msg = message VCCable.VCCSetOffset( (void *)(&nuOffset),
                                                         (IGRshort) NoOffsets ),
               targetid = a.objid,
               targetos = a.osnum);

      }
      if(pOffset) free(pOffset);
//printf("Number of offsets identified on object %d\n",NoOffsets);
      NewTemplates = NULL;
      NewTemplates = _MALLOC((NoOffsets + 2),struct GRid);
      NewTemplates[0].objid = SysID.objid;
      NewTemplates[0].osnum = SysID.osnum;
      NewTemplates[1].objid = UsrID.objid;
      NewTemplates[1].osnum = UsrID.osnum;
      j = 0;
      for(off=0; off<2; off = off + 1)
      {
        if(loc_cab_con[off].term_fnd_flg && !loc_cab_con[off].term_err_flg)
        {
           j = j + 1;
           if(j > NoOffsets)
           {
             printf("processing error should not occur\n");
             return 1;
           }
           NewTemplates[j+1] = loc_cab_con[off].term_fnd_id;
        }
      }
      noparents = NoOffsets + 2;
      status =
           ci$send( msg = message NDnode.NDconnect ( noparents, NewTemplates,
                                            NULL_GRID,ND_FULL),
               targetid = a.objid,
               targetos = a.osnum);

       _FREE (NewTemplates);
       status = 
                ci$send(msg      = message NDnode.NDs_compute_node
                                (&retmsg, 0, &md_env),
                        targetid = a.objid,
                        targetos = a.osnum );

    }
    /* Cable should not be rebuilt */ 
    else
    {
       printf("This cable already has parents\n");
    }
return 1;
}
