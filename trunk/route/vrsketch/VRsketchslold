/* $Id: VRsketchslold,v 1.2 2001/02/20 01:17:29 build Exp $  */

/***********************************************************************
 * I/ROUTE
 *
 * File:        vrsketch/VRsketch.sl
 *
 * Description:
 *  This file contains the commands : 
		Piping  sketch : VRSkPipeLine,0,VRSkPp
 *	        HVAC    sketch : VRSkDuctLine,1,VRSkDcLn
 *		Raceway sketch : VRSkRaceway,2,VRSkRw
 *
 *
 *  To start sketching a network the system asks user to identify element 
 *  or enter data point. To identify element user has two ways :
 *  he can select locate gadget on the sketch form and locate an element or
 *  gives a tentative point on the desired element.
 *  For the next step the system asks for the next point. This point can be 
 *  given by a tentative point, by locating a component ( in the two cases 
 *  system activate the construct point mecanism to construct all different
 *  ways to sketch from start point to the given one. In the locate case system
 *  connect the current network to the one who has got locating element ),
 *  by a regular point, by giving a distance along choissen direction. This
 *  point can be in the orthogonal mode or skewed mode ( skewed mode is 
 *  ( activated on the sketch form ).
 *  Between two given points system creates a segment, it connects 
 *  automatically two or more creating segments by component ( elbow, tee,..).
 *  the first segment starts with dangling and the end one finishs with a
 *  dangling. With the sketch user can connects two seperate networks. To
 *  connect network user can locate dangling, elbow or pipe to start from one
 *  of these network and the same to end to the other.
 *  In the sketch user gives attributes of automatic component to place using
 *  the active design parameters and the additiannal design parameters forms
 *  With the sketch command user is able to place reducer, flanges along 
 *a line and reducing elbow ( in HVAC ) or reducing branch component,
 *  he is able to place components fitting to fitting too ( fitting to 
 *  fitting mode is activated on the sketch form )
 *
 *  NB    :     
 *	the state is clearly to undestand the different possibilities 
 *	of the sketch command.
 * 
 *  VRsketch.sl ==> 
	this file contains the state table and the following methods :
 *
 *                    ==> init 
				   : is overridden to initialize the 
 *				     instance data particulary the product 
 *				     and locate filter eligible class.
 *                    ==> wakeup
 *                                 : is overridden to update sketch form gadgets
 *                    ==> delete
 *                                 : is overridden to terminate correctly the 
 *					current network.
 *                    ==> sleep
			 	   : is overridden to erase sketch form 
				    and undisplay construct point way 
 *				    if neccessary
 *                    ==> dynamics
 *                                 : is overridden to call funtion of 
 *					product the right dynamic function.
 *                    ==> form_notification
 *                                 : is overridden to ( gerer ) the sketch form.
 *		      ==> VRSkSetRetCode
 *                                 : set my_ret instance data
 *		 	==> VRSkFormBottonOff
 *                                 : set to off all sketch form gadgets
 *			==> VRSkPopupLocate
 *                                 : set to off sketch form locate gadget
 *			==> VRSkPopupSkewed
 *                                 : set to off sketch form skewed gadget
 * Dependencies:
 *
 * Log History:
 *	$Log: VRsketchslold,v $
 *	Revision 1.2  2001/02/20 01:17:29  build
 *	Replaced v_dbgmacros.h with product specific dbgmacros.h
 *	
 *	Revision 1.1.1.1  2001/01/04 21:13:10  cvs
 *	Initial import to CVS
 *	
# Revision 1.19  2000/02/21  20:53:10  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.18  2000/01/25  18:55:36  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.17  2000/01/04  14:42:00  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.16  2000/01/03  23:14:00  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.15  1999/11/05  20:00:02  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.14  1999/10/22  15:52:16  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.13  1999/10/01  16:37:48  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by aharihar for route
#
# Revision 1.12  1999/07/29  11:58:00  pinnacle
# Deleted the Sketch form from the memory .
#
# Revision 1.11  1999/05/28  14:43:32  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.10  1999/05/24  20:38:26  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.9  1999/05/14  14:02:12  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.3  1998/08/05  15:59:54  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.2  1998/05/20  22:15:24  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.12  1998/03/20  21:23:22  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.10  1998/01/21  06:54:34  pinnacle
# Replaced: vrsketch/VRsketch.sl for: some work on LLP by aharihar for route
#
# Revision 1.9  1998/01/14  18:58:24  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.8  1997/12/30  09:50:34  pinnacle
# Replaced: vrsketch/VRsketch.sl for: No TR - LLP Pbs by aharihar for route
#
## Revision 1.7  1997/11/30  19:01:28  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by impd for route
#
# Revision 1.5  1997/11/07  20:36:36  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by lawaddel for route
#
# Revision 1.2  1997/09/02  15:59:36  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by onayragu for route
#
# Revision 1.12  1997/06/27  14:06:00  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.11  1997/06/11  22:23:38  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by r241_int for route
#
# Revision 1.10  1997/05/29  07:59:44  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.9  1997/05/23  13:41:00  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.8  1997/04/16  10:58:50  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.6  1997/03/24  10:08:02  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by ashankar for route
#
# Revision 1.5  1997/03/06  06:46:04  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by ashankar for route
#
# Revision 1.4  1997/02/06  10:01:38  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.3  1996/09/19  10:08:20  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by apazhani for route
#
# Revision 1.2  1996/08/20  08:12:28  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by ashankar for route
#
# Revision 1.1  1996/07/25  18:25:44  pinnacle
# Creation of Route 241 project
#
# Revision 1.15  1996/05/21  20:04:34  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by hverstee for route240
#
# Revision 1.14  1996/05/16  23:00:12  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by hverstee for route240
#
# Revision 1.13  1996/03/05  23:20:14  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by hverstee for route240
#
# Revision 1.12  1996/03/05  16:30:30  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by hverstee for route240
#
# Revision 1.11  1996/03/04  22:48:24  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by hverstee for route240
#
# Revision 1.10  1996/02/19  04:28:56  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by ashankar for route240
#
# Revision 1.9  1996/02/05  05:48:32  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by ashankar for route240
#
# Revision 1.8  1996/01/19  15:10:28  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by r240_int for route240
#
# Revision 1.5  1995/12/08  21:24:06  pinnacle
# Replaced: vrsketch/VRsketch.sl for:  by r240_int for route240
#
 *
 * History:
 *      10/31/90 	momo	Rewrite date
 *	08/19/94	MM	Modification done to form notification
 *					due to addition of RW_T_SHAPE.
 *	12/06/95	tlb	Remove VRcmd.h
 *	01/15/96	tlb	Add VX_FIproto.h, prototypes
 *				Fix FIfld_set_value call
 *      Feb/06/97       Alwin   Modified form_notification to add 
 *                              cases HV_THROAT_RADIUS and HV_TRAN_LENGTH
 *                              for CR#179603184
 *      May/23/97       Alwin   Modification done to form_notification.
 *                              For providing different option codes for
 *                              pipes. CR#179300978
 *      May/30/97       Alwin   Modified state N_C, for TR179700865.
 *      Oct/10/97       Onay    Update line seq number to 14 char long
 *      Nov/07/97       law     CR179308634 - Livelookup of parts from db.
 *      Dec/30/97       Anand   No T.R - VRPlvlkfrm pops up even when the
 *                              piping_spec_eq table does not exist. Replaced
 *                              vdb$RisSelect by VdsVerifyRisTable in
 *                              action status_disp
 *      Jan/12/98       law     CR179701945- throat radius field
 *      Jan/12/98       law     CR179309874- New raceway shapes
 *      Jan/21/97       Anand   No T.R - Redefined the criteria to kick off LLP.
 *                              piping_spec_eq table need not exist anymore.
 *      Mar/06/98       law     TR179600988-Prevent sketch from wrong nozzle end
 *      May/18/98       law     CR179801061-Add width/depth computation
 *      25-Jul-1998     LAW     Added tiers for raceway - CR179801144
 *      March/1999      Reddy   TR179900116 - npd list was not being populated
 *                              properly for diameter field.
 *      Apr/19/99       law     CR179900491 - Variable tier spacing
 *      May/20/99       Reddy   CR179900491 - Shape coordination of the gadgets 
 *				for diff. shapes is being done ...
 *      May/28/99       Alwin   CR179900491 - Modified to support Shape 
 *				transition components. Added two instance 
 *				variables.
 *      July/29/99       Alwin  TR179900758 - Deleted the Sketch form from 
 *				the memory
 *      Sep/Oct 99	Anand   For TR 179900778, CR 179900060 and CR 179900837
 *      09/19/99        LAW     TR17900780/781- rway cleanup
 *      10/2/99         law     TR17900780&tr179900932-more cleanup
 *	1/3/2000	LAW	Minor cleanup delivered with TR179900934
 *      1/04/00         law     TR179801414 - CONRED sizes incorrect
 *      01/25/00        law     tr179900976 - transition failures
 *
 ***********************************************************************/

command_string       	VRC_M_SkPipeLine,0,VRSkPp
synonym			VRC_M_SkDuctLine,1,VRSkDcLn
synonym			VRC_M_SkRaceway,2,VRSkRw
class                	VRsketch
super_class          	VRCmpMgr
product_name         	"$ROUTE"
command_table		"route.cmd"

form "VRSkMissParams",0,0,"-1","-1"
status_display "VRConnectCmp","-1","-1"

specification

#include "igrtypedef.h"
#include "igr.h"
#include "gr.h"
#include "grdpbdef.h"
#include "grdpb.h"
#include "dpstruct.h"
#include "parametric.h"
#include "vdbmacros.h"
#include "VRstructs.h" 
#include "ACattrib.h"
#include "ACrg_collect.h"
/* Added for CR179308634 - Livelookup of parts from database */
#include "VRsketchdef.h"
#include "VRRwDimen.h"
#include "VRlivlkup.h"

instance
{
				/*************************************/
				/* TO PLACE COMPONENT BY AABBCC CODE */
				/*************************************/

  IGRshort			CmpFunction;	/* component function 			     */
  IGRboolean			ChangePocket;	/* TRUE if EMS pocket menu has been swapped  */
  IGRchar 			*PocketMenuName;/* active pocket menu name    		     */
  IGRboolean			IS_CONNECTABLE; /* located  component is connectable	     */
  IGRshort			FirstCptNum;	/* cpt number of first located connectable   */
						/* component				     */
  IGRshort			SecondCptNum;  	/* cpt number of second located connectable  */
						/* component				     */
  IGRint			EvalCompTopo;	/* component evalauted topo		     */
  IGRvector			PrevSegAxis;	/* Last created segment direction            */
  IGRvector			Cmp_Yaxis;  	/* to create component y axis                */
  struct	GRid		ListIds[VR_NB_ATTR + VR_MAX_CPTS];
						/* list of component template		     */
  struct	VRGenInfo	CmpStr;     	/* generic structure of component	     */
  struct	ACrg_coll	*p_MissingParamsList;
					 	/* list of the missing parameters returned by*/
						/* the evaluate   			     */

				/************************/
  				/* SKEWED WITH AN ANGLE */  
				/************************/

  IGRboolean			AngleFlag; 	/* to know if an angle has been setted in    */
						/* Skewed mode				     */

				/********************/
	  			/* NEW SKETCH FORMS */
				/********************/

  IGRchar			*form_name;	/* sketch form name	 		     */
  Form				form_ptr;	/* sketch form pointer			     */
  IGRint			shape_gadget;   /* active shape gadget ( HVAC, CABLING )     */


				/********************/
				/* Needed Instances */
				/********************/

  IGRshort			SketchMode;	/* AUTOMATIQUE or MANUAL sketch mode         */
  struct	GRmd_env	FirstLocatedElemMdEnv;
						/* first located compoent module info	     */
  struct	GRmd_env	SecondLocatedElemMdEnv;
						/* second located compoent module info	     */
  IGRboolean			PlaceDangling; 	/* if TRUE the system place dangling at the 
						/* end of the line at the current line route */
  IGRshort			first_pt_free;  /* used for the fitting to fitting           */
  IGRshort			next_pt_free;   /* used for the fitting to fitting           */
  IGRshort			CmpPosition;	/* Positin of component to replace	     */
  IGRshort                      CmpOrientation[VR_MAX_CPTS];
                                          	/* to place component we need t know its     */
						/* orientation on each supports              */
  IGRint			FirstType;	/* first located component type needed to    */
						/* know the component to place instead of the*/
						/* located one                               */
  IGRint			CmpFirstType;   /* first located component type needed when  */
			                        /* user deletes all added segment to an      */
						/* existant line route to know the type of   */
						/* the starting component to replace it      */
  IGRint			SecondType;     /* second component type needed to know the  */
						/* component to place instead of the located */
						/* one.		          	             */
  IGRint			num_of_seg;     /* number of added segments                  */
  IGRint			my_state; 	/* my current state                          */
  IGRlong			my_ret;         /* my return code                            */
  IGRpoint			prev_pt;        /* previous user given point                 */
  IGRpoint			first_pt;       /* first user given point : is the start     */
						/* point of the next created segment         */
  IGRpoint			next_pt;        /* next user given point : is the end point  */
       						/* of the next created segment               */
  IGRint			NbOfImpDirection;
						/* number of imposed direction		     */
  IGRdouble			ImpDirForDyn[3*VR_MAX_CPTS];
					        /* used for dynamics to propose only valid   */
						/* direction to sketch from located component*/
  IGRdouble			CmpAngle; 	/* needed to place in line cmp    	     */
  IGRboolean    		twist_orient;   /* TRUE if the current width is twedted      */
  IGRboolean    		twist_save;     /* used to know if we need to place a twisted*/
						/* component				     */
  IGRboolean    		ZwindowFlag;    /* if TRUE we need to get the Z window axis  */
						/* to calcul the next point 	 	     */
  IGRdouble			Z_Window[3];    /* Z window axis given by the dynamic funtion*/
  IGRdouble			section_matrix[9];
				          	/* section orientation matrix     	     */
                                          	/* X --> [0..2]; Y --> [3..5];    	     */
                                          	/* Z --> [6..8];                  	     */
  IGRboolean			orthogonal_sketch;
                                          	/* TRUE if sketch is orthogonal   	     */
  IGRboolean			LocateMode;	/* TRUE if user is locating a component 	     */

  IGRboolean			extend;   	/* to know if the user given next point      */
						/* corresponds to an extend or not of the    */
						/* last created segment			     */
  IGRboolean			act_param_change;
                                          	/* if TRUE user has changed the active       */
						/* parameters befor given the next point     */
  variable 	struct GRid	seg_GRid[MAX_SEG];
                                                /* list of all added segment on the current  */
						/* line					     */
  struct 	GRid		plane_to_move_id;
                                           	/* plan to move if is an extend              */
  struct 	GRid		prev_seg_id;    /* last created segment                      */
  struct	GRid		FirstLocatedElemId; 
                                          	/* first located component id     	     */
  struct	GRid		SecondLocatedElemId; 
                                          	/* second located component id    	     */
  struct 	GRid		ElbowSecSegId;  /* needed when we located an elbow to start  */
  struct 	GRas		assoc_list;     /* assoc construction list 		     */
  struct 	GRvg_construct	const_list;     /* segment graphic construction list 	     */
  struct 	GRvg_construct	cmp_const_list; /* component graphic construction list	     */
  struct	GRsymbology	LineSymbology;  /* current symbology for created segments    */
  struct	GRid		ActParamId;	/* active system collection parameters       */
						/* identifier				     */
  struct	GRid		BufParamId;     /* last collection paramters identifier befor*/
						/* user given the next point 		     */

				/********************************/
				/* CONSTRUCTION POINT GENERATOR */ 
				/********************************/

  IGRdouble 			cst_pts[12];	/* all proposed way points                   */
  IGRdouble			way_cst_pts[9]; /* all proposed way points without the first */
						/* segment                                   */
  struct 	IGRdisplay    	cst_display;    /* display attributes of all proposed line   */
  struct 	IGRdisplay	way_cst_display;/* display attributes of all proposed line   */
						/* without the first segment		     */
  struct 	IGRpolyline    	cst_poly;	/* geometry of all the proposed line         */
  struct 	IGRpolyline    	way_cst_poly;   /* geometry of all the proposed line without */
						/* the first segment                         */
  struct 	DPele_header	cst_buffer;	/* header element needed to display on       */
						/* dynamic all the proposed line             */
  struct 	DPele_header	way_cst_buffer; /* header element needed to display on       */
						/* dynamic all the proposed line without the */
						/* first segment			     */
				/************************/
  				/* ID MANAGEMENT	*/  
				/************************/
  IGRint	PrevLineNum;	/* previous line seq num */
  IGRboolean	bLineNumUsed;	/* whether the prev line seq num is used
				   or not				*/

  IGRboolean    bI_Need_Pick;   /* Locate of destination gives problems
                                   when either directly after inserting
                                   a component, or locating the origin
                                   component. Need at least one set of
                                   coordinates in between 

                                   Safest way is to keep track of this
                                   situation and block the locate
                                   button when necessary. 

                                      TR # 179600603                   */
  /* Next four added for CR179308634 - Livelookup of parts in db */
  IGRboolean	first_entry;   	/* first entry flag for livelookup     */
  IGRboolean	new_live;	/* new form for livelookup	       */
  IGRboolean    proc_livelook;
  struct VRlivoutbuff OB;
  /* Next was added for CR179801061-save width/depth for shape changes */
  IGRdouble width_sav;
  IGRdouble depth_sav;
  /* Next are dynamic depth additions-CR179900491 */
  IGRint active_cpt;
  struct VRRwCptDetails RWcptdata[10];

  /* added by alwin for handling 'shape transition components'. Currently used
  only for Raceways. If the bIsShapeTransition is set to TRUE, it means
  we should use the "nShapeCode" as the shape_code value, irrespective of what
  is displayed in the form. */

  IGRboolean    bIsShapeTransition;
  IGRint        nShapeCode;

}


implementation

#include <stdio.h>
#include <math.h>
#include <string.h>
#include "OMlimits.h"
#include "bserr.h"
#include "bsparameters.h"
#include "bsvalues.h"
#include "exdef.h"
#include "igrdef.h"
#include "dpdef.h"
#include "dpmacros.h"
#include "VRdef.h"
#include "VRact_params.h"
#include "VRattr_index.h"
#include "VRparamdef.h"
#include "dpdef.h"
#include "VRco.h"
#include "OMprimitives.h"
#include "OMmacros.h"
#include "FI.h"
#include "nddef.h"
#include "VRsketchdef.h"
#include "VRchgattrdef.h"
#include "ACattrib.h"
#include "VRpriv_attr.h"
#include "VRprivmacros.h"
#include "VRutildef.h"
#include "VRutilmacros.h"
#include "igewindef.h"
#include "igewindow.h"
#include "igewinmacros.h"
#include "VRPid.h"
#include "VDmacdef.h"
#include "vdsmacros.h"
#include "VRDbStruct.h"
#include "VRMcForm.h"
#include "VDDfEntCode.h"
#include "VDSutil.h"
#include "AS_status.h"
#include "vrinit_pto.h"
#include "vrtools_pto.h"
#include "vrpdu_pto.h"
#include "vrsketch_pto.h"
#include "bsdotp.h"

#include "exmacros.h"
#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "expression.h"
#include "expmacros.h"

/* Two header files below included by Anand */
#include "VDDbDef.h"
#include "vrdbgmacros.h"

%safe
#include "VX_FIproto.h"
%endsafe

#define DYN		1
#define DYNTEE		2
#define AS_DEBUG	1
#define NOT_VALID       100
#define VR_OPTCODE_LIST_NUM  400
#define VR_MANAGE_TAG	2
#define PIPING_OPTION 50

#define	VR_LINE_NUM	0
#define	VR_TAG_NUM	1

/* Redefined Raceway Depth gadget label in order to
   maintain consistency with other forms - Reddy */

#define	RW_DEPTH		718  
#define	RW_WIDTH		720  
#define	SMALL_RW_DEPTH		719  
#define	SMALL_RW_WIDTH		721  
#define	SMALL_RW_DEPTH_TXT	35  
#define	SMALL_RW_WIDTH_TXT	34  
			      
			

%safe
static X_SketchFormPosition 	= 0;
static Y_SketchFormPosition 	= 0;
static ScreenSketchFormNumber	= 0;
%endsafe

from	ACncpx	import	ACgive_structure;
/* from	VRRComp	import	ACgive_structure;  CR179801144 */
from    ACrg_collect import  ACget_named_attribute;
from	VRGeneric import VRGetMatrix;

/**********************************************************/

state_table

#include "VRmsg.h"
#include "ECmsg.h"
#include "VRdef.h"
#include "VRco.h"
#include "VRcompdef.h"
#include "grownerdef.h"
#include "VRsketchdef.h"

#define DYN 		1      /* dynamic is active at 1 */
#define DYNTEE		2      /* dynamic for orientation tee */
#define FALSE		0      /* */
#define TRUE		1      /* */
#define NOT_VALID       100    /* any thing */
#define	STOP		20
#define LLP_FLG         299

#define	VR_LINE_NUM	0
#define	VR_TAG_NUM	1
#define NO_MORE_SOLUTIONS 101   // added for TR179700865 --Alwin

state *
on  EX_DATA.GRst_PERPEND_FROM                        	state have_error
on  EX_DATA.GRst_ANGLE_FROM                          	state have_error
on  EX_DATA.GRst_TANGENT_FROM                        	state have_error
on  EX_DATA.GRst_PERPEND_TO                          	state have_error
on  EX_DATA.GRst_ANGLE_TO                            	state have_error


state main

   on CMD_TYPE = 0 do	message_key	VR_M_SkPipeLine	state init_start
   on CMD_TYPE = 1 do	message_key	VR_M_SkDuctLine	state init_start
   on CMD_TYPE = 2 do	message_key	VR_M_SkRaceway		state init_start


state init_start
   execute VRInitInstance( &me->ret )
   execute VRSkInitInstance( &me->ret )
   execute VRSkFormBottonOff( &me->ret )
   execute VRSkPopupStatusField( &me->ret )
   execute status_display_button(1)
   on ELSE
   state start

state start
   prompt_key		VR_P_IdElemDataPointToStart
   status_key		EMS_I_InvkStatusFrm
   dynamics		off
   filter		get_event

   on EX_BACK_UP or EX_RJT_MOVEON
	state init_start

   on EX_DATA.GRst_KEYPOINT
	do VRskfstelm( &me->ret )	
	do VRskupdate_event( &me->ret )
	state N_P

   on EX_DATA
	do VRskfstpt( &me->ret )
	do VRskupdate_event( &me->ret )
	state N_P

   on  EX_FORM_FINISHED
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = PP_LOCATE or RETURN_CODE = HV_LOCATE
		state LOC_CMP
	state .
   on EX_STRING
	do status_key	VR_S_VRSkNotPos
	state .


state N_P
   prompt_key	VR_P_NextPoint
   dynamics	DYN
   filter	get_event

   on EX_RJT_MOVEON
	do VRskendline( &me->ret )
	state init_start
      
   on EX_DATA.GRst_KEYPOINT
	do VRskgetnxtpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	state N_C

   on EX_DATA.GRst_REGULAR
	do VRsknextpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	do VRskcrseg( &me->ret )
	on RETURN_CODE = ADDITIONAL_PARAMS
	  do VRskupdate_form( &me->ret )
	  state ADD_MISS_PARAM
	do VRskupdate_event( &me->ret )
	state .

   on EX_DATA
	do VRskgetnxtpt( &me->ret )	
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	state N_C

   on DISTANCE
	do VRskdelta( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	do VRskcrseg( &me->ret )	
	do VRskupdate_event( &me->ret )
	state .

   on EX_BACK_UP
	do VRskdelseg( &me->ret )
		on RETURN_CODE = NO_PREVIOUS_SEG
		do VRskupdate_event( &me->ret )
		state init_start
	do VRskupdate_event( &me->ret )
	state .

  /* Modified for CR179308634 - Livelookup of parts in db */
   on  EX_FORM_FINISHED
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = LLP_FLG
		do VRInitInstance( &me->ret )
		do VRSkGetCmpCode( &me->ret )
		do VRSkActiveEmsPocket( &me->ret )
		do VRSwapSketchForm( VR_MANUAL )
		  state GET_PARAMS

		on RETURN_CODE = PP_SKEWED or RETURN_CODE = HV_SKEWED
		state SWD_ANG

		on RETURN_CODE = PP_LOCATE or RETURN_CODE = HV_LOCATE
		state LOC_CMP

                on RETURN_CODE = VR_BLOCK_LOCATE
                do status "LOCATE - need at least one set of coordinates first"
                state .

		on RETURN_CODE = VR_NOT_VALID
		do status_key VR_S_InvalidInput
		do VRSkPopupStatusField( &me->ret )
		do VRSkPartialInitInst( &me->ret )
		state .
	state .

   on EX_STRING
	do VRInitInstance( &me->ret )
	do VRSkGetCmpCode( &me->ret )
		on ERROR
		do status_key	VR_S_InvalidAABBCCcode
		state .
	do VRSkActiveEmsPocket( &me->ret )
	do VRSwapSketchForm( VR_MANUAL )
	state GET_PARAMS


state ADD_MISS_PARAM
   prompt	""
   status	""
   dynamics	off
   filter	wfi

   on EX_BACK_UP or EX_RJT_MOVEON
	do VRSkEraseMissingForm( &me->ret )
	state -
   on EX_FORM_FINISHED
	do VRSkEraseMissingForm( &me->ret )
	do VRskcrseg( &me->ret )
	state -
   on ELSE
	state .


state SWD_ANG
   prompt_key   VR_P_Angle
   dynamics	DYN
   filter	get_event

   on EX_RJT_MOVEON
	do VRSkPopupSkewed( &me->ret )
	do VRskendline( &me->ret )
	state init_start
      
   on EX_DATA.GRst_KEYPOINT  	
	do VRskgetnxtpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	state N_C

   on EX_DATA.GRst_REGULAR
	do VRsknextpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state N_P
	do VRskcrseg( &me->ret )
	do VRSkPopupSkewed( &me->ret )
	do VRskupdate_event( &me->ret )
	state N_P

   on EX_DATA
	do VRskgetnxtpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	state N_C

   on ANGLE
	do VRskgetangle( &me->ret )
	state SWD_LEN

   on EX_BACK_UP
	do VRSkPopupSkewed( &me->ret )
	do VRskdelangle( &me->ret )
	do VRskupdate_event( &me->ret )
	state -

   on  EX_FORM_FINISHED
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = PP_LOCATE or RETURN_CODE = HV_LOCATE
		state LOC_CMP

		on RETURN_CODE = PP_SKEWED or RETURN_CODE = HV_SKEWED
		do VRskdelangle( &me->ret )
		do VRskupdate_event( &me->ret )
		state N_P
		
		on RETURN_CODE = MAINTAIN_SKEW
		do VRIsPrevSegSkewed( &me->ret )
			on RETURN_CODE = VRNOT_OK
			state SWD_LEN
		do VRSkPopupSkewed( &me->ret )
		do VRskdelangle( &me->ret )
		do VRskupdate_event( &me->ret )
		state N_P

	state .

   on EX_STRING
	do VRskdelangle( &me->ret )
	do VRInitInstance( &me->ret )
	do VRSkGetCmpCode( &me->ret )
		on ERROR
		do status_key	VR_S_InvalidAABBCCcode
		state .
	do VRSkActiveEmsPocket( &me->ret )
   	do VRSwapSketchForm( VR_MANUAL )
	state GET_PARAMS

state SWD_LEN
   prompt_key	VR_P_Length
   dynamics	DYN
   filter	get_event

    on EX_RJT_MOVEON
	do VRSkPopupSkewed( &me->ret )
	do VRskendline( &me->ret )
	state init_start
      
   on EX_DATA.GRst_KEYPOINT
	do VRskgetnxtpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	state N_C

   on EX_DATA.GRst_REGULAR      
   	do VRsknextpt( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	do VRSkPopupSkewed( &me->ret )
	do VRskcrseg( &me->ret )
	do VRskupdate_event( &me->ret )
	state N_P

   on EX_DATA
	do VRskgetnxtpt( &me->ret )	
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	state N_C

   on DISTANCE
	do VRskdelta( &me->ret ) 
		on ERROR
		do VRskupdate_event( &me->ret )
		state .
	do VRSkPopupSkewed( &me->ret )
	do VRskcrseg( &me->ret )	
	do VRskupdate_event( &me->ret )
	state N_P

   on EX_BACK_UP
	do VRskdelangle( &me->ret )
	do VRskupdate_event( &me->ret )
	state -

   on  EX_FORM_FINISHED
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = PP_LOCATE or RETURN_CODE = HV_LOCATE
		state LOC_CMP

		on RETURN_CODE = PP_SKEWED or RETURN_CODE = HV_SKEWED
		do VRskdelangle( &me->ret )
		do VRskupdate_event( &me->ret )
		state N_P

		on RETURN_CODE = MAINTAIN_SKEW
		state SWD_ANG
	state .

   on EX_STRING
	do VRSkPopupSkewed( &me->ret )
	do VRskdelangle( &me->ret )
	do VRInitInstance( &me->ret )
	do VRSkGetCmpCode( &me->ret )
		on ERROR
		do status_key	VR_S_InvalidAABBCCcode
		state .
	do VRSkActiveEmsPocket( &me->ret )
	do VRSwapSketchForm( VR_MANUAL )
	state GET_PARAMS

state N_C
   prompt_key	VR_P_AccReject
   dynamics	off
   filter	get_event

   on EX_BACK_UP
        do VRSkPopupSkewed( &me->ret )
	do VRskupdate_event( &me->ret )
	do VRskinit_buffer( &me->ret )
	state N_P

   on EX_RJT_MOVEON
	do VRsknextchoice( &me->ret )
                on RETURN_CODE = NO_MORE_SOLUTIONS
                do VRSkPopupSkewed( &me->ret )
                do VRskupdate_event( &me->ret )
                do VRskinit_buffer( &me->ret )
                state N_P
	state .

   on EX_DATA.GRst_REGULAR
	do VRSkPopupSkewed( &me->ret )
	do VRskcstsol( &me->ret )
		on ERROR
		do VRskupdate_event( &me->ret )
		do VRskinit_buffer( &me->ret )
		state N_P
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = 10
		state N_C
	do VRskupdate_event( &me->ret )	
	do VRskinit_buffer( &me->ret )
	state N_P

   on  EX_FORM_FINISHED
	state .


state LOC_CMP
   prompt_key		VR_P_IdComp
   dynamics		off
   locate_owner         "LC_RIGID_COMP | LC_REF_OBJECTS"
   accept_key		VR_P_AccReject
   relocate_key		VR_S_CompNotFound
   filter		locate

   on EX_DATA
	do VRSkGetLocateState( &me->ret )
		on RETURN_CODE = NO_PREVIOUS_SEG
		do VRSkGetEvent( &me->ret )
			on ERROR
			do VRskupdate_event( &me->ret )
			state .
		do VRskfstelm ( &me->ret )
		do VRSkPopupLocate( &me->ret )
		do VRskupdate_event( &me->ret )
		state N_P
	do VRSkGetEvent( &me->ret )
		on ERROR
		do VRSkPopupSkewed( &me->ret )
		do VRSkPopupLocate( &me->ret )
		do VRskupdate_event( &me->ret )
		state -
	do VRskgetnxtpt( &me->ret )
		on ERROR
		do VRSkPopupSkewed( &me->ret )
		do VRSkPopupLocate( &me->ret )
		do VRskupdate_event( &me->ret )
		state -
	do VRSkPopupLocate( &me->ret )
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = STOP
		do VRskupdate_event( &me->ret )
		state init_start
	do VRSkPopupSkewed( &me->ret )
	do VRskupdate_event( &me->ret )
	state N_C



   on EX_BACK_UP or EX_RJT_MOVEON				
	do VRSkGetLocateState( &me->ret )
	do VRSkPopupSkewed( &me->ret )
	do VRSkPopupLocate( &me->ret )
		on RETURN_CODE = NO_PREVIOUS_SEG
		state init_start
	state N_P


   on  EX_FORM_FINISHED
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = PP_LOCATE or RETURN_CODE = HV_LOCATE	
		do VRSkPopupSkewed( &me->ret )
		state N_P
		on RETURN_CODE = PP_SKEWED or RETURN_CODE = HV_SKEWED
		state .
	state .

/* VRskformon/VRskformoff Added for CR179308634 - Livelookup of parts in db */

state GET_PARAMS
   prompt_key	VR_P_ChgPar
   dynamics	off
   filter	get_event

   on EX_RJT_MOVEON or EX_BACK_UP
	do VRSwapSketchForm( VR_AUTOMATIQUE )
	do VRSkPopupStatusField( &me->ret )
	do VRSkUnLockId( VR_TAG_NUM )
	state -

   on  EX_FORM_FINISHED
	do VRSkSetCmpInstance( &me->ret )
	do VREvaluateComp( &me->ret )
		on RETURN_CODE = VR_ADDED_PARAM
		do VRskupdate_form( &me->ret )
		state ADD_PARAM

		on RETURN_CODE = VR_NOT_VALID
		do VRSwapSketchForm( VR_AUTOMATIQUE )
		do VRSkUnLockId( VR_TAG_NUM )
		do VRDeleteGraphics( &me->ret )
		state N_P
	do VRGetReturnCode( &me->ret )
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = IS_NO_ORIENT						
                do VRskformoff(&me->ret)
       		do VRSkInitCmpOrient( &me->ret )
		state PL_CMP

		on RETURN_CODE = IS_ENDLINE_COMP
		do VRSkInitCmpOrient( &me->ret )
		do VRSkSetRetCode( 1 )
			on RETURN_CODE = VR_HVAC
			state HV_ORI_CMP
		do VRPlaceCmp( &me->ret )
			on ERROR
			state .
		do VRSkUpdateNetWork( &me->ret )
		do VRSkEndLineRoute( &me->ret )
		do VRSwapSketchForm( VR_AUTOMATIQUE )
		do VRSkEraseMissingForm( &me->ret )	
		do VRSKEraseHvacTee( &me->ret )			
		do VRSkPopupStatusField( &me->ret )
		state init_start
	do VRSkInitCmpOrient( &me->ret )		
	do VRSkSetRetCode( 1 )
		on RETURN_CODE = VR_PIPING
		state REVERSE_PP_CMP

	state REVERSE_HV_CMP


state ADD_PARAM

   prompt_key	VR_P_EnterDesignParameters
   status	""
   dynamics	off
   filter	wfi

   on EX_BACK_UP or EX_RJT_MOVEON						
	do VRSkEraseMissingForm( &me->ret )
	state -

   on EX_FORM_FINISHED
	do VREvaluateComp( &me->ret )
		on RETURN_CODE = VR_ADDED_PARAM
		do VRskupdate_form( &me->ret )
		state .

		on ERROR
		do VRDeleteGraphics( &me->ret )
		state .
	do VRskupdate_form( &me->ret )
	do VRGetReturnCode( &me->ret )
	do VRSkSetRetCode( 0 )
		on RETURN_CODE = IS_NO_ORIENT
		do VRSkInitCmpOrient( &me->ret )
		state PL_CMP

		on RETURN_CODE = IS_ENDLINE_COMP
		do VRSkInitCmpOrient( &me->ret )
   		do VRPlaceCmp( &me->ret )
			on ERROR
			state .

		do VRSkUpdateNetWork( &me->ret )
		do VRSkEndLineRoute( &me->ret )
		do VRSwapSketchForm( VR_AUTOMATIQUE )
		do VRSkEraseMissingForm	( &me->ret )		
		do VRSkPopupStatusField( &me->ret )
		state init_start

	do VRSkInitCmpOrient( &me->ret )		
		on RETURN_CODE = NO_PREV_SEG
		state MX_ORI 
	do VRSkSetRetCode( 1 )
		on RETURN_CODE = VR_PIPING
		state REVERSE_PP_CMP
	state REVERSE_HV_CMP


state MX_ORI
   prompt	" Data to accept moveon to continue"
   dynamics	DYNTEE
   filter	get_event

  on EX_DATA
	state REVERSE_PP_CMP

  on EX_RJT_MOVEON
	state . 


state REVERSE_HV_CMP

   execute VRSkDisplayOrientTee( &me->ret )

   prompt_key	VR_P_DefineOrientationReverse
   dynamics	off
   filter	get_event

   on EX_DATA
	do VRSkDisplayOrientTee( &me->ret )
	state HV_ORI_CMP

   on EX_RJT_MOVEON
	do VRReverseComponent( &me->ret )
	state .

   on EX_BACK_UP
	do VRSKEraseHvacTee( &me->ret )
	state -


state REVERSE_PP_CMP

   execute VRSkDisplayOrientTee( &me->ret )
   execute VRskformoff(&me->ret)

   prompt_key	VR_P_DefineOrientationReverse
   dynamics	off
   filter	get_event

   on EX_DATA
	state PP_ORI_CMP

   on EX_RJT_MOVEON
	do VRReverseComponent( &me->ret )
	state .

   on EX_BACK_UP
	do VRSKEraseHvacTee( &me->ret )
	state -


state PP_ORI_CMP

   execute VRDisplayAngle ( &me->ret )

   prompt_key	VR_P_GiveDataOrKeyinToOrientCmp
   dynamics	DYNTEE
   filter	get_event

   on EX_DATA
	do VRComputeCmpAngle( &me->ret )		
	do VRRotateComponent( &me->ret )
        do VRskformon(&me->ret)
	state PL_CMP

   on DISTANCE
	do VROrientByAngle (&me->ret)
		on RETURN_CODE = VRNOT_OK
		do VRRotateComponent (&me->ret)
                do VRskformon(&me->ret)
		state PL_CMP
	do VRRotateComponent (&me->ret)
	state .

   on EX_BACK_UP
        do VRskformon(&me->ret)
	state -

   on EX_RJT_MOVEON
	do VRRotateQuadrant( &me->ret )
	state .

   on EX_FORM_FINISHED
	state .


state HV_ORI_CMP

   prompt_key	VR_P_AcceptOrientationReverse
   dynamics	off
   filter	get_event

   on EX_DATA
	do VRGetReturnCode(&me->ret)
		on RETURN_CODE = IS_ENDLINE_COMP
		state PL_CMP
	do VRSKEraseHvacTee( &me->ret )
	state PL_CMP

   on EX_BACK_UP
	do VRGetReturnCode(&me->ret)
		on RETURN_CODE = IS_ENDLINE_COMP
		state -
	do VRSKEraseHvacTee( &me->ret )
	state -

   on EX_RJT_MOVEON
	do VRGetReturnCode(&me->ret)
		on RETURN_CODE = IS_ENDLINE_COMP
		do VRRotateQuadrant( &me->ret )
		state .		
	do VRSKEraseHvacTee( &me->ret )
	do VRRotateQuadrant( &me->ret )
	state .

   on EX_FORM_FINISHED
	state .


state PL_CMP

   prompt       ""
   status	""
   dynamics	off

   on ELSE
        do VRskformon(&me->ret)
	do VRPlaceCmp( &me->ret )
	do VRSwapSketchForm( VR_AUTOMATIQUE )
	do VRSkEraseMissingForm( &me->ret )		
	do VRSkPopupSkewed( &me->ret )		
		on ERROR
		do VRSkPopupStatusField( &me->ret )
		do VRDeleteGraphics( &me->ret )
		do VRskendline( &me->ret )
		state init_start
	do VRSkPopupStatusField( &me->ret )
	do VRSkUpdateNetWork( &me->ret )
   	do VRskrestart( &me->ret )
		on RETURN_CODE = VR_NEED_CPT
			state GET_DATA
		on ERROR
		do VRSkEndLineRoute( &me->ret )
		state init_start
	state N_P

state GET_DATA

   prompt_key	VR_P_GiveDataNearCpt
   dynamics	off
   filter	get_event


   on EX_RJT_MOVEON
	do VRSkEndLineRoute( &me->ret )
	do VRSkPartialInitInst( &me->ret )
	state init_start

   on EX_BACK_UP
	do VRskdelseg( &me->ret )
	do VRskupdate_event( &me->ret )
	state N_P

   on EX_DATA
	do VRSkGetCptInfo( &me->ret )
	state N_P


state have_error
   
   status_key  VR_S_InvDataType

   on ELSE
	state -


  /* Added for CR179308634 - Livelookup of parts in db */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRskformon

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
action VRskformon
{
   FIf_display (me->form_ptr);
   goto quit;
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRskformoff

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
action VRskformoff
{
   FIf_erase (me->form_ptr);
   goto quit;
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method init

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action init
{
  IGRlong 		msg;
  IGRint		fi_status;
      IGRchar optcode_text[20];
      IGRchar pathname[OM_K_MAXOSNAME_LEN];
      struct GRid ExpressionId;

  extern int    	COB_FI_form_notification();
  extern int    	COB_FI_initial_form_notification();

  extern GRclassid OPP_VRPComp_class_id;
  extern GRclassid OPP_VRPNozz_class_id;
  extern GRclassid OPP_VRPCComp_class_id;
  extern GRclassid OPP_VRHComp_class_id;
  extern GRclassid OPP_VRHNozz_class_id;
  extern GRclassid OPP_VRHCComp_class_id;
  extern GRclassid OPP_VRRComp_class_id;
  extern GRclassid OPP_VRRNozz_class_id;
  extern GRclassid OPP_VRRCComp_class_id;

  me->ret = MSSUCC;
__DBGpr_com("*****************Came thru init*********************");

  /*| call VDB_LOCATE.init method with respect to message */
  status = om$send (mode     = OM_e_wrt_message,
                    msg      = message VDB_LOCATE.init( type, str_ptr ),
                    targetid = my_id);
  as$status( action = RET_STATUS );
  if (me->VDB_terminated) return (status);

  /*| call VRinit_products to load the macro object spaces */
  status = VRinit_products();
  as$status( action = RET_STATUS );

  me->locate_eligible_thing.w_count = 3;
  me->locate_eligible_thing.w_flags = OM_CLST_subclass;
  om$vla_set_dimension( varray = me->eligible_classids,
                        size   = me->locate_eligible_thing.w_count );


  fi_status = FI_SUCCESS;

  me->form_ptr = NULL;
  /* Added for CR179308634 - Livelookup of parts in db */
  me->first_entry = TRUE; /* needed for status display livelookup */
  me->new_live = TRUE; /* Bring up the livelookup form */
  me->proc_livelook = FALSE;

  switch( type )
  {
    case 0 : me->Product = VR_PIPING;
	     me->form_name = "VRPipSkParams";
             me->eligible_classids[0] = OPP_VRPComp_class_id;
             me->eligible_classids[1] = OPP_VRPNozz_class_id;
             me->eligible_classids[2] = OPP_VRPCComp_class_id;
             /* Added for CR179308634 - Livelookup of parts from database */
             /* Intended to reset the opt-code to 1 for start of sketch mode */
             strcpy(optcode_text,"1"); 
             /* Get the Current Working Directory */
             status = di$pwd( dirname = pathname );
 
             /* Change to the HOME directory */
             status = di$cd( dirname = DIR_G_home_name );
 
             /* Get the ExpressionId if it is already created
                              in the Directory Subsystem */
             status = di$translate(objname = "piping_option_code",
                                   p_objid = &ExpressionId.objid,
                                   p_osnum = &ExpressionId.osnum );
 
             if( status != DIR_S_SUCCESS )
             {
                ExpressionId.osnum = me->ModuleEnv.md_id.osnum;
                status = exp$create (exp_name   = "piping_option_code",
                                     exp_syntax = optcode_text,
                                     osnum      = ExpressionId.osnum,
                                     p_exp_id   = &ExpressionId.objid,
                                     p_osnum    = &ExpressionId.osnum,
                                     type_rq    = EXP_TEXT );
             }
             else
             {
             status = exp$modify ( exp_id = ExpressionId.objid,
                                   osnum  = ExpressionId.osnum,
                                   exp_syntax = optcode_text );
             }
 
             /* Re-Setting it to the PWD directory  */
             status = di$cd( dirname = pathname );
             UI_status( "Processing ..." );
 
             break;
    case 1 : me->Product = VR_HVAC;
	     me->form_name = "VRHVSkParams";
             me->eligible_classids[0] = OPP_VRHComp_class_id;
             me->eligible_classids[1] = OPP_VRHNozz_class_id;
             me->eligible_classids[2] = OPP_VRHCComp_class_id;
             /* Below added for CR179309874 - new RW shapes */  
             me->depth_sav = -1.; /* CR179801061 */
             me->width_sav = -1.; /* CR179801061 */
             me->shape_gadget = HV_R_SHAPE;
             break;
    case 2 : me->Product = VR_RWAY;
	     me->form_name = "VRRwaySkParams";
             me->eligible_classids[0] = OPP_VRRComp_class_id;
             me->eligible_classids[1] = OPP_VRRNozz_class_id;
             me->eligible_classids[2] = OPP_VRRCComp_class_id;
             /* Below added for CR179309874 - new RW shapes */  
             me->shape_gadget = RW_R_SHAPE;
             break;
    default: return OM_E_ABORT;
  }

  /*" me->form_name = %s \n", me->form_name */

  FIf_new ( MAIN, me->form_name, COB_FI_form_notification,&me->form_ptr);
  FIf_set_cmd_oid_os( me->form_ptr, my_id, OM_Gw_current_OS );

  /*| Set Form Configuration */
  
  /*"X_SketchFormPosition = %d\n", X_SketchFormPosition */
  /*"Y_SketchFormPosition = %d\n", Y_SketchFormPosition */

  if( X_SketchFormPosition && Y_SketchFormPosition )
  	FIf_set_location( me->form_ptr, X_SketchFormPosition, Y_SketchFormPosition );
  if( ScreenSketchFormNumber ) FIf_set_screen( me->form_ptr, ScreenSketchFormNumber );

  /*| Update eligible class for locate */
  me->locate_eligible_thing.p_classes = me->eligible_classids;
  me->locate_eligible = &me->locate_eligible_thing;

  FIf_set_initial_notification_routine ( me->form_ptr, 
					     COB_FI_initial_form_notification);
 
  /*| call VRskinit method */
  status = om$send( msg      = message VRsketch.VRskinit( &msg ),
                    targetid = my_id);
  as$status( action = RET_STATUS );
  as$status( sts = msg, action = RET_STATUS );
  FIg_erase  ( me->form_ptr, MAINTAIN_SKEW );
  goto quit;

}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action wakeup
{
  IGRboolean 		pt_type;    /* TRUE if last segment is the first and  */
  IGRint		i;
  IGRlong		msg;
  IGRdouble		cmp_pt[6];  /* termination points of last segment     */
  IGRshort		listsize;
  IGRdouble		*npdlist;
  IGRchar		*err_ptr;
  IGRchar 		Cnpdlist[VR_MAX_NPDLIST_SIZE][10];

  /*"pos           = %d\n", pos */
  /*"EX_suspend    = %d\n", EX_suspend */
  /*"EX_nonsuspend = %d\n", EX_nonsuspend */


  me->ret = MSSUCC;
  pt_type = FALSE;
  err_ptr = NULL;

  /*| call VDB_LOCATE.wakeup method with respect to message */
  status = om$send (mode     = OM_e_wrt_message,
                    msg      = message VDB_LOCATE.wakeup( pos ),
                    targetid = my_id);
  as$status( action = RET_STATUS );
  __DBGpr_com("******************Came thru wakeup ************************");
  if (me->VDB_terminated) goto quit;

  /* Bruno : 1-Dec-92 , Init Pid environment */

  if ( bVR_IS_PID_ACTIVE ) VRInitPid();

  status = VRSkSetFormMode( me->Product, FI_REVIEW );
  as$status();

  if( pos & EX_suspend )
  {
	if(  me->SketchMode == VR_AUTOMATIQUE || me->ListIds[0].objid != NULL_OBJID )
	{
  		status = om$send( msg      = message VRsketch.VRSwapSketchForm
						( me->SketchMode ),
            	  	  	  targetid = my_id );
		as$status();
	}
        FIf_display( me->form_ptr );
  }

  /*| -- Get Nominal Size List and initialize form -- */
  if( me->Product == VR_PIPING ){

	struct ret_struct	ParamAttr;
	IGRint 			FootIndex = -1, retstatus;

  	status = 
  	om$send( msg      = message ACncpx.ACgive_structure( &retstatus, 
							     &FootIndex, 
						       	     VR_N_CLASS_AN,
			     			       	     &ParamAttr, 
							     &me->ModuleInfo),
		 targetid = me->ActParamId.objid,
		 targetos = me->ActParamId.osnum );
  	as$status( action = RET_STATUS );

  	status = 
	VRget_npd_list(	&msg, me->Product,
			ParamAttr.var.text_st.text_string,
			&listsize , &npdlist, err_ptr);

        for( i = 0; i<listsize; i++) __DBGpr_dbl( " 2npdList[i]",npdlist[i]);
        /* TR179900116 - sprintf(Cnpdlist[i], "%f", npdlist[i]) was changed
           to sprintf(Cnpdlist[i], "%.3lf", npdlist[i]) */

 	if( status & 1 ){
		for( i = 0; i<listsize; i++)
			sprintf(Cnpdlist[i], "%.3lf", npdlist[i]);
  		FIfld_set_list_num_rows( me->form_ptr, PP_DIAM, 0,listsize );
  		FIfld_set_list_num_rows( me->form_ptr, SMALL_DIAMETER, 0,listsize );
  		for(i=0; i<listsize; i++)
  		{
			FIfld_set_list_text( me->form_ptr, PP_DIAM, i, 0, (unsigned char *) Cnpdlist[i], FALSE);
			FIfld_set_list_text( me->form_ptr, SMALL_DIAMETER, i, 0, (unsigned char *) Cnpdlist[i], FALSE);
  		}
  	}
  }
  else if( me->Product == VR_RWAY ){ /* Added for CR179801144 */
	struct ret_struct	ParamAttr;
	IGRint 			FootIndex = -1, retstatus;
        IGRint		row = 0, col = 0;
        IGRdouble		sp_tier, no_tier;
        if(me->shape_gadget == RW_R_SHAPE)
        {
           FIfld_set_mode(me->form_ptr, RW_DEPTH, 0, FI_REVIEW);
           FIg_display( me->form_ptr, RW_DEPTH );
           /*** Modified for CR179900491 ***/
           FIg_display(me->form_ptr,FRM_TIER_SP_1);
/*           FIg_display(me->form_ptr,FRM_TIER_SP_2);     */
           FIg_display(me->form_ptr,FRM_NO_TIER_1);
/*           FIg_display(me->form_ptr,FRM_NO_TIER_2);     */

           FIg_display (me->form_ptr,N_TIER_SK1_TEXT);
/*           FIg_display (me->form_ptr,N_TIER_SK2_TEXT);  */
           FIg_display (me->form_ptr,SP_TIER_SK1_TEXT);
/*           FIg_display (me->form_ptr,SP_TIER_SK2_TEXT); */
        }
        else
        {
           __DBGpr_com("erasing tiers");
           FIg_erase(me->form_ptr,FRM_TIER_SP_1);
           FIg_erase(me->form_ptr,FRM_TIER_SP_2);
           FIg_erase(me->form_ptr,FRM_NO_TIER_1);
           FIg_erase(me->form_ptr,FRM_NO_TIER_2);

           FIg_erase (me->form_ptr,N_TIER_SK1_TEXT);
           FIg_erase (me->form_ptr,N_TIER_SK2_TEXT);
           FIg_erase (me->form_ptr,SP_TIER_SK1_TEXT);
           FIg_erase (me->form_ptr,SP_TIER_SK2_TEXT);

           FIg_display( me->form_ptr, RW_DEPTH );// Reddy - Shape coordination
           FIg_display( me->form_ptr , RW_D_TXT );

	   if(me->shape_gadget == RW_C_SHAPE)
           {
                // Reddy - Shape coordination of gadgets
                /*  FIfld_set_mode(me->form_ptr, RW_DEPTH, 0, FI_INSERT); */
                FIg_erase( me->form_ptr , RW_DEPTH ) ;
                FIg_erase( me->form_ptr , RW_D_TXT ) ;
           }
           else if( me->shape_gadget == RW_RS_SHAPE) /* tr179900932 cleanup */
           {
                FIfld_set_mode(me->form_ptr, RW_DEPTH, 0, FI_INSERT);
           }
           else
           {
             FIfld_set_mode(me->form_ptr, RW_DEPTH, 0, FI_REVIEW);
           }
           FIg_display( me->form_ptr, RW_DEPTH );
       }
  }
  /* Update component construction */
  me->cmp_const_list.env_info = &me->ModuleInfo;
  me->cmp_const_list.display  = &me->ActiveDisplay;
  me->cmp_const_list.level    = me->ActiveLevel;

  /*"ActLevel = %d\n", me->ActiveLevel */

  /* if we interrupt the sketch command by the move command, we must update  */
  /* prev_pt and first_pt if we are created any segment. we must be carreful */
  /* if we begin the sketch from a dangling and we interrupt imediately this */
  /* command, end points of  last segment (parents of dangling in this case) */
  /* depend of dangling  type ( BEGIN OR END of segment )                    */
  /* me->CmpPosition is 0 if located component is not a dangling             */

  if( me->num_of_seg )
  {
    if( me->CmpFirstType == IS_DANGLING && me->num_of_seg == 1 && me->CmpPosition == BEGIN_OF_SEG )
    {
      pt_type = TRUE;
    }

    if( me->prev_seg_id.objid != NULL_OBJID )
    {
    	status = VRskgetendpt(&msg,pt_type,cmp_pt,&me->prev_seg_id,&me->ModuleInfo);
    	as$status( action = RET_STATUS );
    	as$status( sts = msg, action = RET_STATUS );

    	for( i=0; i< 3; i++ )
    	{
      		me->prev_pt[i]  = cmp_pt[i];
      		me->first_pt[i] = cmp_pt[i+3];
    	}
    }
  }

  if( me->cst_buffer.dis_att )
  {
	dp$display ( 	msg 	= &msg,
			osnum 	= me->ModuleInfo.md_id.osnum,
			mode	= GRhd,
			num_elem = 1,
			buffer	= &me->cst_buffer );
  }

  if( me->way_cst_buffer.dis_att )
  {
	dp$display ( 	msg 	= &msg,
			osnum 	= me->ModuleInfo.md_id.osnum,
			mode	= GRhd,
			num_elem = 1,
			buffer	= &me->way_cst_buffer );
  }

  /* active the current pocket menu if manual mode */
  if( me->ChangePocket ) VRChangePocketMenu( me->PocketMenuName );
  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action delete
{

  IGRlong  msg=MSSUCC;

  status = om$send (mode     = OM_e_wrt_message,
                    msg      = message VDB_LOCATE.delete( f_defer_flag ),
                    targetid = my_id);
  as$status( action = RET_STATUS );

  if (me->VDB_terminated) goto quit;

  status = om$send( msg      = message VRsketch.VRskendline( &msg ),
                    targetid = my_id);
  as$status( action = RET_STATUS );
  as$status( sts = msg, action = RET_STATUS );

  /*| get sketch form configuration */
  FIf_get_location( me->form_ptr, &X_SketchFormPosition, &Y_SketchFormPosition );
  FIf_get_screen( me->form_ptr, &ScreenSketchFormNumber );
  
  /*"X_SketchFormPosition = %d\n", X_SketchFormPosition */
  /*"Y_SketchFormPosition = %d\n", Y_SketchFormPosition */

	/* This line just removes the form display, and it does exists in the memory.
	So the continues usage of this command brings up new form and remains in the
	memory and fills up the form stack. Hence leading to undesirable results like
	blanking out all the forms. Alwin */

  FIf_erase( me->form_ptr );

	/* added this line for TR179900758. Alwin */
	if( me->form_ptr ) FIf_delete( me->form_ptr );

  goto quit;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action sleep
{

  IGRlong msg=MSSUCC;
  status = om$send (mode     = OM_e_wrt_message,
                    msg      = message VDB_LOCATE.sleep( pos ),
                    targetid = my_id);
  as$status( action = RET_STATUS );

  if (me->VDB_terminated) goto quit;

  status = VRSkSetFormMode( me->Product, FI_INSERT );
  as$status();

  dp$erase_hilite ( msg   = &msg, osnum = me->ModuleEnv.md_id.osnum);

  if( !me->SketchMode )
  {
	dp$erase_hilite( msg   = &msg,
                         osnum = me->ModuleInfo.md_id.osnum );

  	if( me->ChangePocket )
  	{
		status = om$send( msg      = message VRsketch.VRSkActiveEmsPocket( &msg ),
			  	  targetid = my_id );
  	}
  }

  /*"pos           = %d\n", pos */
  /*"EX_suspend    = %d\n", EX_suspend */
  /*"EX_nonsuspend = %d\n", EX_nonsuspend */

  if( pos & EX_suspend ) FIf_erase( me->form_ptr );
  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRSkFormBottonOff

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRSkFormBottonOff
{
  status = OM_S_SUCCESS;

  switch( me->Product )
  {
    case VR_PIPING  : FIg_set_state_off( me->form_ptr, PP_SKEWED );
		      FIg_set_state( me->form_ptr, MAINTAIN_SKEW, 0 );
		      FIg_erase( me->form_ptr, MAINTAIN_SKEW );
                      FIg_set_state_off( me->form_ptr, PP_LOCATE );
                      FIg_set_state_off( me->form_ptr, PP_FITOFIT);
                      break;

    case VR_HVAC    :
    case VR_RWAY : FIg_set_state_off( me->form_ptr, HV_SKEWED );
		      FIg_set_state( me->form_ptr, MAINTAIN_SKEW, 0 );
		      FIg_erase( me->form_ptr, MAINTAIN_SKEW );
                      FIg_set_state_off( me->form_ptr, HV_LOCATE );
                      FIg_set_state_off( me->form_ptr, HV_TWIST  );
                      FIg_set_state_off( me->form_ptr, HV_FITOFIT);
                      break;
  }

  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRSkPopupLocate

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRSkPopupLocate
{
  status = OM_S_SUCCESS;

  switch( me->Product )
  {
    case VR_PIPING  : FIg_set_state_off( me->form_ptr, PP_LOCATE );
                      break;

    case VR_HVAC    :
    case VR_RWAY : FIg_set_state_off( me->form_ptr, HV_LOCATE );
                      break;
  }
  me->LocateMode = FALSE;

  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRSkPopupSkewed

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRSkPopupSkewed
{
  status = OM_S_SUCCESS;

  switch( me->Product )
  {
    case VR_PIPING  : FIg_set_state_off( me->form_ptr, PP_SKEWED );
		      FIg_set_state( me->form_ptr, MAINTAIN_SKEW, 0 );
		      FIg_erase( me->form_ptr, MAINTAIN_SKEW );
                      break;

    case VR_HVAC    :
    case VR_RWAY : FIg_set_state_off( me->form_ptr, HV_SKEWED );
		      FIg_set_state( me->form_ptr, MAINTAIN_SKEW, 0 );
		      FIg_erase( me->form_ptr, MAINTAIN_SKEW );
                      break;
  }
  me->orthogonal_sketch = TRUE;
  me->AngleFlag = FALSE;

  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method dynamics

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action dynamics
{
  IGRint	action, i;
  IGRlong	retcode;
  IGRdouble 	Origin[3], XAxis[3];
  IGRdouble	ref_matrix[16];
  IGRdouble	*dummy;

  if( me->ChangePocket )
  {
	status = om$send( msg      = message VRsketch.VRSkActiveEmsPocket( &retcode ),
		  	  targetid = my_id );
  }

  if( dynamics == DYNTEE )
  {
	/* -- case we don't have any previous segment. Not finished implemented -- */
   	if ( me->prev_seg_id.objid == NULL_OBJID )
	{
		/*| Begin with placement of a component */
		for( i=0; i<3; i++ )
		{
			me->PrevSegAxis[i] = me->CmpMatrix[i*4];
			me->Cmp_Yaxis[i]   = me->CmpMatrix[(i*4)+1];
		}
	}

	/* -- update the origin of the axis for the dynamic display -- */
        Origin[0] =  me->CmpMatrix[3];
	Origin[1] =  me->CmpMatrix[7];
	Origin[2] =  me->CmpMatrix[11];

	XAxis[0] = me->PrevSegAxis[0] * me->CmpOrientation[0];
	XAxis[1] = me->PrevSegAxis[1] * me->CmpOrientation[0];
	XAxis[2] = me->PrevSegAxis[2] * me->CmpOrientation[0];

    	VRorient ( me->Product, Origin, XAxis, me->Cmp_Yaxis, 
	       	   &me->ActiveDisplay, &me->ModuleInfo
             	 );
  }
  else if( dynamics == DYN )
  {
    	me->ret       = MSSUCC;

	if( me->SketchMode == VR_MANUAL )
  	{
		status = om$send( msg      = message VRsketch.VRSkPartialInitInst( &retcode ),
			          targetid = my_id );
		as$status();
	}

    	me->ZwindowFlag = TRUE;
	if( me->FirstType == IS_NOZZLE )
        {
        status = om$send( msg      = message VRGeneric.VRGetMatrix
          ( &retcode,0,NULL,ref_matrix,&me->FirstLocatedElemMdEnv ),
                  targetid = me->FirstLocatedElemId.objid,
                  targetos = me->FirstLocatedElemId.osnum );
        as$status( action = RET_STATUS );
/*
dummy = &ref_matrix[0];
printf("sketch ref matrix\n");
printf("%f	%f	%f	%f\n",
ref_matrix[0],ref_matrix[1],ref_matrix[2],ref_matrix[3]);
printf("%f	%f	%f	%f\n",
ref_matrix[4],ref_matrix[5],ref_matrix[6],ref_matrix[7]);
printf("%f	%f	%f	%f\n",
ref_matrix[8],ref_matrix[9],ref_matrix[10],ref_matrix[11]);
printf("%f	%f	%f	%f\n",
ref_matrix[12],ref_matrix[13],ref_matrix[14],ref_matrix[15]);
printf("matrix address = %x",dummy);
*/
        }

	if( me->FirstType == IS_PIPE ) 	action = 0;
	else			       	action = 1;
    	switch( me->Product )
    	{
      		case VR_PIPING :  
                /* TR179600988 - prevent dynamics from wrong end of nozzle. */
			VRrblinear
                        ( action, me->prev_pt, me->first_pt, me->Z_Window, me->NbOfImpDirection,
			  me->ImpDirForDyn, me->orthogonal_sketch, &me->ActiveDisplay, 
			  me->Angle, me->AngleFlag,
                          ((me->FirstType==IS_COMP_TO_CONNECT ||
			    me->FirstType==IS_NOZZLE ||
			    me->FirstType==IS_CONC_COMP) ? TRUE : FALSE),
                            me->FirstType,
			    (IGRdouble *) &ref_matrix[0]
		        );
                  	break;

      		case VR_HVAC    :
      		case VR_RWAY : /*| HVAC dynamic */
                /* TR179600988- prevent dynamics from wrong end of nozzle. */
		    VRhvlinear
                    ( action, me->prev_pt, me->first_pt, me->Z_Window, me->NbOfImpDirection,
                    me->ImpDirForDyn, me->section_matrix, me->twist_orient,
                    me->orthogonal_sketch, &me->ActiveDisplay, me->Angle, me->AngleFlag,
                    ((me->FirstType==IS_COMP_TO_CONNECT ||
                      me->FirstType==IS_NOZZLE || 
		      me->FirstType==IS_CONC_COMP) ? TRUE : FALSE),
                      me->FirstType,
	              (IGRdouble *) &ref_matrix[0]);
                        break;

      		default : return OM_E_ABORT;
    	}
  }
  else me->ZwindowFlag = FALSE;

  goto quit;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRSkSetRetCode

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRSkSetRetCode( IGRshort type )
{
  status = OM_S_SUCCESS;

  switch ( type )
  {
	case 0: me->ret = me->my_ret;
		break;

	case 1: me->ret = me->Product;
		break;
  }

  /*"me->ret = %d\n", me->ret */

  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method status_disp

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action status_disp
{
  /*| call status_disp method with respect to message */

  /* Added for CR179308634 - Livelookup of parts in db */
#define LLP_FLG 299


IGRlong  msg=MSSUCC;
int rows;
char **results;

extern int    	COB_FI_initial_form_notification();
extern int FIf_set_initial_notification_routine();
extern int form_notification();
extern int    	COB_FI_form_notification();

IGRint		gadget_label;
IGRlong retcode;

SetProc( status_disp ); Begin

__DBGpr_int(" proc_livelook",me->proc_livelook);
__DBGpr_int(" first entry",me->first_entry);
__DBGpr_int(" new live",me->new_live);

if(me->proc_livelook)
  goto quit;

if(me->Product == VR_PIPING && !bVR_IS_PID_ACTIVE)
{


        rows = 0;
        status = vdb$RisSelect(  select      =      "distinct family_code",
                                 table_name  =      "piping_comps",
                                 where       =      "family_code!=0",
                                 order       =      NULL,
                                 group       =      NULL,
                                 numselect   =      1,
                                 p_numrows   =      &rows,
                                 p_buffer    =      &results );

	VdsRisFreeBuffer( results , rows );
	 
        if( status == 1 && rows )
        {
           me->proc_livelook = TRUE;
           __DBGpr_com(" piping_comps populated, me->proc_livelook is TRUE");

           if(me->new_live)
           {
              FIf_new ( 999, "VRPlvlkfrm", COB_FI_form_notification,
                                           &me->status_display_form_ptr);
              FIf_set_cmd_oid_os( 
                    me->status_display_form_ptr, my_id, OM_Gw_current_OS );
              me->new_live = FALSE;
           }
           if(me->first_entry)
           {
              status = VRPlvlkup(me->first_entry,&gadget_label,
                                      me->status_display_form_ptr,&me->OB);
              me->first_entry = FALSE;

           }

        FIf_display( me->status_display_form_ptr );
        }

}
  status = om$send (mode     = OM_e_wrt_message,
                    msg      = message super_cmd.status_disp(),
                    targetid = my_id);
  as$status( action = RET_STATUS );
  /* Added for CR179308634 - Livelookup of parts in db */
  if(me->proc_livelook)
  {
    /* Force the change of state to GET_PARAMS */
    me->my_ret = LLP_FLG;
    FIf_erase(me->form_ptr);

    /* Goto next state */
    _put_response( resp = EX_FORM_FINISHED );
    goto quit;
  }
  else    /*if(!me->proc_livelook)*/
  {
     switch( me->Product )
     {
	case VR_PIPING:
		FIg_erase  ( me->status_display_form_ptr, 19 );
		FIg_erase  ( me->status_display_form_ptr, 28 );
		FIg_display( me->status_display_form_ptr, 24 );
		break;

	case VR_HVAC:
		FIg_erase  ( me->status_display_form_ptr, 24 );
		FIg_erase  ( me->status_display_form_ptr, 28 );
		FIg_display( me->status_display_form_ptr, 19 );
		break;

	case VR_RWAY:
		FIg_erase  ( me->status_display_form_ptr, 19 );
		FIg_erase  ( me->status_display_form_ptr, 24 );
		FIg_display( me->status_display_form_ptr, 28 );
		break;
     }
     FIf_display( me->status_display_form_ptr );
  }

  __DBGpr_int(" my_ret",me->my_ret);
  __DBGpr_int(" proc_livelook",me->proc_livelook);
  __DBGpr_int(" first entry",me->first_entry);
  __DBGpr_int(" new live",me->new_live);

  End
  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method create_form

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRskupdate_form
{

  if( me->MissParamId.objid == NULL_OBJID ) return OM_S_SUCCESS;

  status = VR$DispCollAttr(	pForm	= me->forms[0].form_ptr,
				Gadget	= USER_ATTR_FLD,
				pCollId	= &me->MissParamId );
  as$status( action = RET_STATUS );

  FIg_erase( me->forms[0].form_ptr, 16 );
  FIg_display( me->forms[0].form_ptr, 15 );
  FIf_display( me->forms[0].form_ptr );

  goto quit;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

			method erase Missing parameter form

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRSkEraseMissingForm
{
  status =
  FIf_erase( me->forms[0].form_ptr );

  goto quit;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRSwapSketchForm

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRSwapSketchForm( IGRshort Mode )
{
  struct	GRid	*ParamId, locParamId; /* TR179900780 */
  IGRint		row = 0, col = 0, sel_flag = 0;
  IGRint		i;
  IGRlong		msg;
  IGRshort		listsize;
  IGRdouble		*npdlist;
  IGRchar 		Cnpdlist[VR_MAX_NPDLIST_SIZE][10];

  if ( me->Product == VR_PIPING )
  {	/* -- Display scale if Representation active is PID -- */

	if (bVR_IS_PID_ACTIVE)
	{
		FIg_display( me->form_ptr, SK_PID_SCALE );
		FIg_display( me->form_ptr, SK_PID_SCALE_LABEL );
	}
	else
	{
		FIg_erase( me->form_ptr, SK_PID_SCALE );
		FIg_erase( me->form_ptr, SK_PID_SCALE_LABEL );
	}

  }/* end of scale factor */

  if ( me->Product == VR_HVAC )
  {	/* -- Display scale if Representation active is PID -- */

	if (bVR_IS_PID_ACTIVE)
	{
		FIg_display( me->form_ptr, HV_SYMB_SCALE );
		FIg_display( me->form_ptr, HV_SYMB_SCALE_LABEL );
	}
	else
	{
		FIg_erase( me->form_ptr, HV_SYMB_SCALE );
		FIg_erase( me->form_ptr, HV_SYMB_SCALE_LABEL );
	}

  }/* end of scale factor */


  if( Mode == VR_MANUAL )
  {
	/*| Mode is MANUEL */
	ParamId = &me->ListIds[0];
	FIg_erase  ( me->form_ptr, AUTOMATIQUE_GRP );
	FIg_display( me->form_ptr, MANUAL_GRP );
  	switch( me->Product )
  	{
		case VR_PIPING:
			/* -- get the text corresponding to the option code of the comp -- */
			{
			  IGRchar	o_lname[16], p_error[30];

  		          status = vd$get_alias (    p_msg	= &msg,
		    			 product	= PIPING,
		    			 type		= VR_OPTCODE_LIST_NUM,
		    			 i_code		= me->CmpOption,
		    			 o_lname	= o_lname,
		    			 p_error	= p_error	);
			  if ( !strlen(o_lname) ) 
			    sprintf(o_lname, "%d", me->CmpOption );
    			  FIfld_set_text( me->form_ptr, OPTION, row, col, o_lname, sel_flag );
			}
		
		case VR_HVAC:
			/*A access the database for comp number */
			if ( bVR_IS_PID_ACTIVE )
			{
			  struct ret_struct	ParamAttr;
			  IGRint 		FootIndex = -1, retstatus;
			  IGRint		IdList[VDS_LIST_OF_IDS];
			  IGRint		gadget_label;

			  /*A get the comp category */
			  retstatus =
			  VRdbGetCompCat( &msg, (IGRshort)VR_PIPING, 
					me->CmpAABBCCcode, &me->CmpCat, 
					&me->CmpBehavior,NULL );
			  as$status();

			  if ( me->CmpBehavior == (int)VR_MANAGE_TAG )
			  {
			  /*C Get system name */
			  status = 
			  om$send( msg      = message ACncpx.ACgive_structure
						   ( &retstatus, 
						     &FootIndex, 
					       	     VR_N_SYST_NAME_AN,
		     			       	     &ParamAttr, 
						     &me->ModuleInfo),
				targetid = me->ActParamId.objid,
				targetos = me->ActParamId.osnum );
			  as$status();

			  /*C get the list of available line Ids */
			  status = 
			  VDGetListOfIDs( ParamAttr.var.text_st.text_string,
				me->CmpCat, IdList );
			  
			  for ( i=0; i<VDS_LIST_OF_IDS; i++ ) {			
			    /*C lock this Id*/
			    status = VDLockSelectedID ( 
				ParamAttr.var.text_st.text_string,
				me->CmpCat, IdList[i] );
			    if ( status&1 ) {
			      /*C place the first one in the list as default*/
			      sprintf(me->CmpNumber, "%05d", IdList[i] );
			      me->PrevTagNum = IdList[i];
			      me->bTagNumUsed = FALSE;
			      break;
			    }
			  }
			  }
			  
			  if ( me->Product == VR_PIPING )
				gadget_label = PP_CMP_NB;
			  else gadget_label = HV_CMP_NB;

    			  FIfld_set_text( me->form_ptr, gadget_label,
				row, col, me->CmpNumber, sel_flag );
			}/* end PID */
			break;

		case VR_RWAY: /* CR179801144 */

                        me->bIsShapeTransition = FALSE;
                        me->nShapeCode = -1;

                        /* function implemented in VRskfunk.I file. This fn
                        returns the given comp_code is a shape_transition comp.
                        or not. If it so, then returns the shape_code value
                        back in the instance variable me->nShapeCode. Alwin */

                        __DBGpr_com( " Calling Fn VRGetShapeFrmCompCode ..." );
                        /*** TR179900780-add check for null compcode ***/
                        if(me->CmpAABBCCcode)
                        {
                          /* tr179900985-added product to arguments */
                          IGRint locproduct;
                          locproduct = VR_RWAY;

                          status = VRGetShapeFrmCompCode( me->CmpAABBCCcode,
                                &me->bIsShapeTransition, &me->nShapeCode,
                                locproduct );
                        }
                        if( me->bIsShapeTransition )
                        {
                           __DBGpr_com( " Its a SHAPE TRANSITION COMPONENT " );
                           FIg_erase(me->form_ptr,ACTIVE_CPT_INDEX);
                           FIg_erase(me->form_ptr,ACTIVE_CPT_INDEX_TEXT);
                           FIg_erase(me->form_ptr,DECREASE_ACTIVE_CPT_INDEX);
                           FIg_erase(me->form_ptr,INCREASE_ACTIVE_CPT_INDEX);

                           FIg_erase(me->form_ptr,FRM_TIER_SP_2);
                           FIg_erase(me->form_ptr,FRM_NO_TIER_2);
                           FIg_erase (me->form_ptr,N_TIER_SK2_TEXT);
                           FIg_erase (me->form_ptr,SP_TIER_SK2_TEXT);

                           me->shape_gadget = me->nShapeCode;
                        }
                        else if(me->shape_gadget == RW_R_SHAPE)
	                 /* restore tier data */
                        {
			   FIfld_set_mode(me->form_ptr, SMALL_RW_DEPTH, 0,
                                        FI_REVIEW);
                       __DBGpr_com("VRSwapSketchForm- restore tier data display here");
                        /* Modified for CR179900491 */
                        }
			else
                        {
                           FIfld_set_mode(me->form_ptr, SMALL_RW_DEPTH, 0,
                                        FI_INSERT);
                           FIg_erase(me->form_ptr,FRM_TIER_SP_1);
                           FIg_erase(me->form_ptr,FRM_TIER_SP_2);
                           FIg_erase(me->form_ptr,FRM_NO_TIER_1);
                           FIg_erase(me->form_ptr,FRM_NO_TIER_2);

                           FIg_erase (me->form_ptr,N_TIER_SK1_TEXT);
                           FIg_erase (me->form_ptr,N_TIER_SK2_TEXT);
                           FIg_erase (me->form_ptr,SP_TIER_SK1_TEXT);
                           FIg_erase (me->form_ptr,SP_TIER_SK2_TEXT);

                        }
                        if( me->SketchMode == VR_MANUAL )
	                	FIg_display (me->form_ptr, SMALL_RW_DEPTH);

    		FIfld_set_text( me->form_ptr, RW_CMP_NB, row, col, me->CmpNumber, sel_flag );
		break;
           }
  }
  else
  {
        /* erasing and redisplaying form corrects left-over images */
	/*| Mode is AUTOMATIQUE */
        FIf_erase(me->form_ptr);
	FIg_erase  ( me->form_ptr, MANUAL_GRP );
	FIg_display( me->form_ptr, AUTOMATIQUE_GRP );
        FIf_display(me->form_ptr);
        __DBGpr_com("display AUTOMATIQUE_GRP group");

        /*** Modified for tr179900780 ***/
/*	ParamId = &me->ActParamId;  Apparent problems here *****/
        locParamId = me->ActParamId;
        ParamId = &locParamId;
        /**** TR179900780 KLUDGE ****/
        if ( me->Product == VR_RWAY || me->Product == VR_HVAC )
        {
                        /*TR179900985 - added product to VRGetShapeFrmCompCod*/
                        if(me->CmpAABBCCcode)
                        {
                          IGRint locproduct;
                          locproduct = me->Product;

                          status = VRGetShapeFrmCompCode( me->CmpAABBCCcode,
                                &me->bIsShapeTransition, &me->nShapeCode,
                                locproduct );

			  if(me->nShapeCode == 48)
			  {
			    FIg_display(me->form_ptr,CORN_RAD);
			    FIg_display(me->form_ptr,CORN_RAD_TXT);
			  }
        }
                        }
  	/* -- Replace Active parameters -- */
  	me->ActParamId.osnum = me->ModuleInfo.md_id.osnum;
  	status = VR$active_params(	operation    = VR_RETRIEVE,
					VRproduct    = me->Product,
                    	  		act_param_id = &me->ActParamId,
                    	  		status       = status );
  	as$status( action = RET_STATUS );
  }
 
  /*| -- Get Nominal Size List and initialize form -- */
  if( me->Product == VR_PIPING ){
    status =
    VRget_npd_list ( &msg, VR_PIPING, "NOZZLE", &listsize , &npdlist , NULL);
    if( status & 1 )
    {
        __DBGpr_int( " Listsize is " , listsize );
        __DBGpr_com( " After VRget_npd_list");
        for( i = 0; i<listsize; i++) __DBGpr_dbl("npdlist[i]", npdlist[i]);

        /* TR179900116 - sprintf(Cnpdlist[i], "%f", npdlist[i]) was changed 
            to sprintf(Cnpdlist[i], "%.3lf", npdlist[i]) */

	for( i = 0; i<listsize; i++)	sprintf(Cnpdlist[i], "%.3lf", npdlist[i]);

  	FIfld_set_list_num_rows( me->form_ptr, PP_DIAM, 0,listsize );
  	FIfld_set_list_num_rows( me->form_ptr, SMALL_DIAMETER, 0,listsize );
  	for(i=0; i<listsize; i++)
  	{
		FIfld_set_list_text( me->form_ptr, PP_DIAM, i, 0, (unsigned char *) Cnpdlist[i], FALSE);
		FIfld_set_list_text( me->form_ptr, SMALL_DIAMETER, i, 0, (unsigned char *) Cnpdlist[i], FALSE);
  	}
    } 
  } /* Product == VR_PIPING */
  __DBGpr_com("Call4 for VRSkUpdateForm");
  __DBGpr_str("CmpAABBCCcode",me->CmpAABBCCcode);
  status = VRSkUpdateForm( me->Product, me->form_ptr, &me-> shape_gadget,
			   ParamId, me->CmpAABBCCcode,
                           &me->active_cpt,me->RWcptdata,
		           &me->ModuleInfo, Mode );
  as$status();
  __DBGpr_com("Back from  VRSkUpdateForm");

/*  Reddy - Shape coordination of the gadgets   */
    if(me->Product == VR_RWAY) {

        if(me->shape_gadget != RW_R_SHAPE ) {
            FIg_erase( me->form_ptr, ACTIVE_CPT_INDEX_TEXT );
            FIg_erase( me->form_ptr, DECREASE_ACTIVE_CPT_INDEX );
            FIg_erase( me->form_ptr, ACTIVE_CPT_INDEX );
            FIg_erase( me->form_ptr, INCREASE_ACTIVE_CPT_INDEX );
          }
    }

    /* Below lines added by Anand for CR 179900060 and CR 179900837 */
    if( me->Product == VR_HVAC || me->Product == VR_RWAY )
    {
	struct ACrg_coll	Attr;

		/* Find shape code */
	strcpy(Attr.name, VR_N_SHAPE_IN); 
	status = om$send(msg = message ACrg_collect.ACget_named_attribute
							    ( &msg, &Attr ),
		    senderid = NULL_OBJID,  
		    targetid = ParamId->objid,
		    targetos = ParamId->osnum );
	as$status( action = RET_STATUS );
	__DBGpr_int(" Shape code",Attr.desc.value.att_exp);

/*	if( Attr.desc.value.att_exp == VR_CORNER )  Removed for service pack 4*/
	{
	    struct ret_struct	ParamAttr;
	    IGRint		FootIndex = -1;

            status =
            om$send( msg = message ACncpx.ACgive_structure( ((int *) &msg),
                                                            &FootIndex,
                                                            VR_N_CORN_RAD_DB,
                                                            &ParamAttr,
                                                            &me->ModuleInfo),
                targetid = me->ActParamId.objid,
                targetos = me->ActParamId.osnum );
            as$status( action = RET_STATUS );

            __DBGpr_dbl("corner radius",ParamAttr.var.root_pm_st.value);
            FIg_set_value( me->form_ptr, CORN_RAD,
                                              ParamAttr.var.root_pm_st.value );

	    FIg_display( me->form_ptr, CORN_RAD );
	    FIg_display( me->form_ptr, CORN_RAD_TXT );
	}
/*
	else
	{
	    FIg_erase( me->form_ptr, CORN_RAD_TXT );
	    FIg_erase( me->form_ptr, CORN_RAD );
	}
*/
    }
    /* Above lines added by Anand for CR 179900060 and CR 179900837 */

  goto quit;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method form_notification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action form_notification
{
  /* Below modified for CR179309874 - new RW shapes */  
  IGRint       row = 0, col = 0, sel_flag, r_pos, NbAttr, NBcnt;
  IGRlong      retcode;
  IGRdouble    value, w_value;
  IGRchar      text[30];

  struct  GRid       ParamId;
  struct  ACrg_coll  NewListAttr[VR_MAX_ATTR]; /* CR179801144 */
  extern int VRPlvlkup(); /* CR179308634 - Livelookup processor */
  IGRboolean  bNewPocket;
  char text_string[20];
  /* added for CR179801061 */
  IGRdouble max_depth;
  IGRdouble diameter;
  IGRdouble radius;
  IGRint shape_code, NbCpts, shpid;
  struct ret_struct ParamAttr;
  IGRint FootIndex = -1, retstatus;

  IGRchar spec_name[120];
  IGRlong longmsg;
  struct GRid my_grid; /* CR179801144 */
  
  __DBGpr_com("entering form_notification");
  /*"shape_gadget = %d \n",me->shape_gadget*/
  /* my_grid added for tier processing-CR179801144 */
  my_grid.objid = my_id;
  my_grid.osnum = OM_Gw_current_OS;
  if( me->SketchMode == VR_AUTOMATIQUE ) me->my_ret = MSSUCC;

  /* Added for CR179308634 - Livelookup of parts in database */
  if(me->proc_livelook && gadget_label == FI_CANCEL)
  {
     FIg_set_state_off( me->status_display_form_ptr, FI_CANCEL );
     FIf_erase(me->status_display_form_ptr );
     FIf_display(me->form_ptr);

     status = VRPlvlkup(1,&gadget_label, me->status_display_form_ptr,&me->OB);

     me->proc_livelook = FALSE;
     me->form_requested = 0;
     me->my_ret = VR_DEFAULT_VALUE;
     _put_response( resp = EX_BACK_UP );
     return OM_S_SUCCESS;
  }
  else if(me->proc_livelook && gadget_label == FI_ACCEPT)
  {
    FIg_set_state_off( me->status_display_form_ptr, FI_ACCEPT );

    me->proc_livelook = FALSE;

    VR$active_params( operation       = VR_RETRIEVE,
                   VRproduct          = me->Product,
                   act_param_id       = &me->ActParamId,
                         status       = status );

    ParamId.osnum = me->ModuleInfo.md_id.osnum;

    me->bTagNumUsed = TRUE;

    me->bI_Need_Pick = TRUE;

    strcpy(me->CmpAABBCCcode,me->OB.loc_cmp_code);

    me->CmpOption = (int)atoi(me->OB.opt_code_num);

    strcpy( me->CmpNumber,me->OB.comp_num_fld);
    status = FIg_set_text ( me->form_ptr,PP_CMP_NB, me->OB.comp_num_fld );
    NbAttr = 0;
    /* -- Set Green Diameter -- */
    /* Get PP_DIAM */
    strcpy( NewListAttr[NbAttr].name, VR_N_GDIAMETER_DB );
            NewListAttr[NbAttr].desc.type          = AC_ATTRIB_DOUBLE;
            NewListAttr[NbAttr].desc.value.att_exp = me->OB.default_Gdia;
    sprintf(text_string,"%lf",me->OB.default_Gdia);
    status = FIg_set_text ( me->form_ptr,PP_DIAM, text_string );
    NbAttr ++;

    /* -- Set Red Diameter -- */
    strcpy( NewListAttr[NbAttr].name, VR_N_RDIAMETER_DB );
            NewListAttr[NbAttr].desc.type          = AC_ATTRIB_DOUBLE;
     	    NewListAttr[NbAttr].desc.value.att_exp = me->OB.default_Rdia ;
    sprintf(text_string,"%lf",me->OB.default_Rdia);
    status = FIg_set_text ( me->form_ptr,SMALL_DIAMETER, text_string );

    NbAttr ++;

    strcpy( NewListAttr[NbAttr].name, VR_N_CLASS_AN);
            NewListAttr[NbAttr].desc.type = AC_ATTRIB_TEXT;
    strcpy(NewListAttr[NbAttr].desc.value.att_txt,me->OB.spec_nam_txt);
			NbAttr ++;

    {
      IGRchar optcode_text[20];
      IGRchar pathname[OM_K_MAXOSNAME_LEN];
      struct GRid ExpressionId;
 
       /* Get the Current Working Directory */
       status = di$pwd( dirname = pathname );
 
       /* Change to the HOME directory */
       status = di$cd( dirname = DIR_G_home_name );
 
       /* Get the ExpressionId if it is already created
       in the Directory Subsystem */
       status = di$translate(
                             objname = "piping_option_code",
                             p_objid = &ExpressionId.objid,
                             p_osnum = &ExpressionId.osnum );
 
       status = FIg_set_text ( me->form_ptr,PIPING_OPTION,me->OB.opt_code_num );
       if( status != DIR_S_SUCCESS )
       {
           ExpressionId.osnum = me->ModuleEnv.md_id.osnum;
           status = exp$create (
                    exp_name   = "piping_option_code",
                    exp_syntax = me->OB.opt_code_num,
                    osnum      = ExpressionId.osnum,
                    p_exp_id   = &ExpressionId.objid,
                    p_osnum    = &ExpressionId.osnum,
                    type_rq    = EXP_TEXT );
       }
       else
       {
           status = exp$modify ( exp_id = ExpressionId.objid,
                    osnum      = ExpressionId.osnum,
                    exp_syntax = me->OB.opt_code_num );
       }
 
           /* Re-Setting it to the PWD directory  */
           status = di$cd( dirname = pathname );
           UI_status( "Processing status disp..." );

    } 

	ParamId.objid = NULL_OBJID;
	ParamId.osnum = me->ModuleInfo.md_id.osnum;

  	status = VR$ModifyCollection(
				p_msg			= &retcode,
	      			p_InputCollectionId	= &me->ActParamId,
         			p_OutputCollectionId    = &ParamId );
	as$status();
  	as$status( sts = retcode );

	status = VR$ModifyCollection(
			 	p_msg			= &retcode,
	     			Operation               = VR_UPDATE_COLL,
        			p_ParamsListToModify   	= NewListAttr,
        			NbParamsToModify       	= NbAttr,
        			p_OutputCollectionId    = &ParamId );
	as$status();
  	as$status( sts = retcode );


        me->ListIds[0] = ParamId;

        FIf_erase(me->status_display_form_ptr );

        status = VRPlvlkup(1,&gadget_label,
                                      me->status_display_form_ptr,&me->OB);

        me->form_requested = 0;
        FIf_display( me->form_ptr );
        _put_response( resp = EX_FORM_FINISHED );
        goto quit;
  }

  else if( form_ptr == me->form_ptr )
  {
    __DBGpr_com("form_ptr is standard form ");
    /* Get equiv-diam for computing width/depth for CR179801061 */
    status = 
    VR$active_params( operation       = VR_RETRIEVE,
	              VRproduct       = me->Product,
	              act_param_id    = &me->ActParamId,
                      status          = status );

    status = 
        om$send( msg      = message ACncpx.ACgive_structure
                 ( &retstatus, 
                   &FootIndex, 
                   VR_N_MAX_DEPTH_DB,
                   &ParamAttr, 
                   &me->ModuleInfo),
        targetid = me->ActParamId.objid,
        targetos = me->ActParamId.osnum );
    max_depth = ParamAttr.var.root_pm_st.value;

    status = 
        om$send( msg      = message ACncpx.ACgive_structure
                 ( &retstatus, 
                   &FootIndex, 
                   VR_N_EQUIV_DIA_DB,
                   &ParamAttr, 
                   &me->ModuleInfo),
        targetid = me->ActParamId.objid,
        targetos = me->ActParamId.osnum );

    diameter = ParamAttr.var.root_pm_st.value;

    status = 
        om$send( msg      = message ACncpx.ACgive_structure
                 ( &retstatus, 
                   &FootIndex, 
                   VR_N_CORN_RAD_DB,
                   &ParamAttr, 
                   &me->ModuleInfo),
        targetid = me->ActParamId.objid,
        targetos = me->ActParamId.osnum );

    radius = ParamAttr.var.root_pm_st.value;
    __DBGpr_dbl(" corner radius", radius);

    __DBGpr_int("processing gadget",gadget_label);
    switch( gadget_label )
    {
      case PP_SKEWED:
        if ( me->FirstType == IS_ELBOW           ||
             me->FirstType == IS_COMP_TO_CONNECT ||
             me->FirstType == IS_CONC_COMP       ||
             me->FirstType == IS_NOZZLE )
        {
          me->orthogonal_sketch = TRUE;
          FIg_set_state_off( me->form_ptr, PP_SKEWED );
          FIg_set_state( me->form_ptr, MAINTAIN_SKEW, 0 );
	  FIg_erase( me->form_ptr, MAINTAIN_SKEW );
          ex$message( field   = ERROR_FIELD,
                      in_buff = "direction should be orthogonal !" );
          return OM_S_SUCCESS;
        }

        if( me->orthogonal_sketch )
	{
	   me->orthogonal_sketch = FALSE;
	   FIg_display( me->form_ptr, MAINTAIN_SKEW );
        }
        else
        {
          me->orthogonal_sketch = TRUE;
          FIg_set_state( me->form_ptr, MAINTAIN_SKEW, 0 );
	  FIg_erase( me->form_ptr, MAINTAIN_SKEW );
          FIg_set_state_off( me->form_ptr, PP_SKEWED );
        }

        me->my_ret = gadget_label;
        _put_response( resp = EX_FORM_FINISHED );
        /*"ortho_sketch = %d\n", me->orthogonal_sketch */
        break;

      case MAINTAIN_SKEW:
        if( ! me->AngleFlag )
        {
           me->AngleFlag = TRUE;
           me->Angle = 0.0;
        }
        else
           me->AngleFlag = FALSE;
 
        me->my_ret = gadget_label;
        _put_response( resp = EX_FORM_FINISHED );
        break;

      case PP_LOCATE:
        /*  see if we can allow a locate here   */
        /* VRHvskupdwd added for CR179801061 */
        /* Regardless of acceptability, cancel auto sizing */
        /* Note that no change of values, but VRHvskupdwd resets data fields */
        if( me->Product == VR_HVAC )
        {
            char temp_text[28];
            FIfld_get_list_text(form_ptr, SIZE_COMP_METHOD, 2, 0, 27, 
                          (unsigned char *) temp_text,
                          &sel_flag);
            FIfld_set_text( me->form_ptr, SIZE_COMP_METHOD,
                          row, col, temp_text, sel_flag );
            status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);
        }

        /*  TR # 179600603, corrupted correction after destination
            locate immediately following placement/locate of another
            component                                                  */
        if (me->bI_Need_Pick)
        {
          FIg_set_state_off( me->form_ptr, gadget_label);
          me->my_ret = VR_BLOCK_LOCATE; 
          _put_response( resp = EX_FORM_FINISHED );
          break;
        }

        if ( me->state != _LOC_CMP ) me->my_state = me->state;
        if( !me->LocateMode )
        {
          me->LocateMode = TRUE;
          me->next_pt_free = TRUE;
          me->first_pt_free = TRUE;
        }
        else
        {
          me->LocateMode = FALSE;
          FIg_set_state_off( me->form_ptr, gadget_label);
        }
        me->my_ret = gadget_label;
        _put_response( resp = EX_FORM_FINISHED );
        break;

      case PP_FITOFIT:
        me->first_pt_free = me->first_pt_free ? FALSE : TRUE;
        if( ! me->first_pt_free )
        {
          switch( me->Product )
          {
            case VR_PIPING  :
              FIg_set_state_off( me->form_ptr, PP_FITOFIT);
              break;
            case VR_HVAC    :
            case VR_RWAY :
              FIg_set_state_off( me->form_ptr, PP_FITOFIT);
              break;
          }
        }
        else
        {
          switch( me->Product )
          {
            case VR_PIPING  :
              FIg_set_state_on( me->form_ptr, PP_FITOFIT);
              break;
            case VR_HVAC    :
            case VR_RWAY :
              FIg_set_state_on( me->form_ptr, PP_FITOFIT);
              break;
          }
        }
        /*"fit to fit = %d\n", me->first_pt_free */
        me->my_ret = gadget_label;
        _put_response( resp = EX_FORM_FINISHED );
        break;

      case LINE_SEQ_NUM:

#ifdef  MANAGE_IDS
    if ( bVR_IS_PID_ACTIVE)
    {   
      /*A Verify unicity of LSN */
      IGRdouble    dValue;
      IGRchar      *sEnd=NULL;

      FIfld_get_text( me->form_ptr, LINE_SEQ_NUM,  row, col,
                             15, (unsigned char *) text, 
			     &sel_flag, &r_pos );

      /*C Verify that LNS is a value */
      dValue = strtod (text, &sEnd);
      if ( !text[0] || strlen (sEnd) )
      {
        ex$message( field   = ERROR_FIELD,
            in_buff = "Invalid LSN for UNICITY CHECK" );
      }
      else
      {
        /*C Get system name */
        status = 
        om$send( msg      = message ACncpx.ACgive_structure
                 ( &retstatus, 
                   &FootIndex, 
                          VR_N_SYST_NAME_AN,
                               &ParamAttr, 
                   &me->ModuleInfo),
        targetid = me->ActParamId.objid,
        targetos = me->ActParamId.osnum );

        status =
        VDVerifyIfIDisUsed( ParamAttr.var.text_st.text_string,
          (int)VD_C_PIPES, (IGRint) dValue );
        if ( status == VDS_ID_IS_USED )
        {
          ex$message( field   = ERROR_FIELD,
              in_buff = "LSN ALREADY USED !!!" );
        }
        else
        {
          VDLockSelectedID ( ParamAttr.var.text_st.text_string,
          (int)VD_C_PIPES, (IGRint) dValue   );
          me->PrevLineNum = (int) dValue;
          me->bLineNumUsed = FALSE;
        }
      }

    }/* end verify unicity */
#endif
    break;

  case PP_CMP_NB :
  case HV_CMP_NB :
    /* TR179900985 - Small width hvac coming here */
    if(me->Product == VR_HVAC && me->SketchMode == VR_MANUAL)
    {
       IGRdouble tmp_width;
       if(me->shape_gadget == HV_C_SHAPE)
       {
         /* SETTING DEPTH TO WIDTH */
         FIg_get_value( me->form_ptr, SMALL_HV_WIDTH, &tmp_width );
         FIg_set_value( me->form_ptr, SMALL_HV_DEPTH, tmp_width );
       }
    }


#ifdef  MANAGE_IDS
    if ( (me->Product == VR_PIPING || me->Product == VR_HVAC ) &&
      bVR_IS_PID_ACTIVE && me->CmpBehavior == VR_MANAGE_TAG )
    {
      /*A Verify unicity of LSN */
      IGRdouble    dValue;
      IGRchar      *sEnd=NULL;
      FIg_get_text( me->form_ptr, gadget_label,  text );

      /*C Verify that LNS is a value */
      dValue = strtod (text, &sEnd);
      if ( ! text[0] || strlen (sEnd) )
      {
                 ex$message( field   = ERROR_FIELD,
            in_buff = "Invalid NUMBER for UNICITY CHECK" );
      }
      else
      {
        /*C Get system name */
        status = 
        om$send( msg      = message ACncpx.ACgive_structure
                 ( &retstatus, 
                   &FootIndex, 
                          VR_N_SYST_NAME_AN,
                               &ParamAttr, 
                   &me->ModuleInfo),
        targetid = me->ActParamId.objid,
        targetos = me->ActParamId.osnum );

        status =
        VDVerifyIfIDisUsed( ParamAttr.var.text_st.text_string,
          me->CmpCat, (IGRint) dValue );
        if ( status == VDS_ID_IS_USED )
        {
          ex$message( field   = ERROR_FIELD,
              in_buff = "Comp Num is ALREADY USED !!!" );
        }
        else
        {
          VDLockSelectedID ( ParamAttr.var.text_st.text_string,
          me->CmpCat, (IGRint) dValue   );
          me->PrevTagNum = (int) dValue;
          me->bTagNumUsed = FALSE;
        }
      }
    }/* end verify unicity */
#endif
    break;

      case HV_TWIST :
        if( me->FirstType == IS_PIPE || me->FirstType == IS_ELBOW )
        {
          status = VR$ModifyHvacSection(  p_retmsg  = &retcode,
          Operation  = VR_SWITCH_SECTION,
          p_InPutSection  = me->section_matrix,
          p_OutPutSection  = me->section_matrix );
          as$status( action = RET_STATUS );
          as$status( sts = retcode, action = RET_STATUS );
        }
        else
        {
          /*"twist befor changement : %d\n", me->twist_orient */
          me->twist_orient = me->twist_orient ? FALSE : TRUE;
          /*"twist after changement : %d\n", me->twist_orient */
        }
        me->my_ret = gadget_label;
        _put_response( resp = EX_FORM_FINISHED );
        break;
  /* VRHvskupdwd and SIZE_COMP_METHOD added for CR179801061 */

  case SIZE_COMP_METHOD :  
        status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);

        break;

  case HV_WIDTH :  
    if( me->Product == VR_HVAC )
    {

        status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);
    }
        break;

  case HV_DEPTH :  
    if( me->Product == VR_HVAC )
    {
        status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);
    }
        break;

        case HV_O_SHAPE     :
    /****  case SMALL_RW_WIDTH **** dynamic depth *****/
    if( me->Product == VR_HVAC )
    {
      /* HVAC */
      FIfld_set_mode(form_ptr, HV_DEPTH, 0, FI_REVIEW);
      FIg_display( form_ptr, HV_DEPTH );
      FIg_erase( me->form_ptr, HV_R_SHAPE );
      FIg_erase( me->form_ptr, HV_RS_SHAPE );
      FIg_erase( me->form_ptr, HV_O_SHAPE );
      FIg_display( me->form_ptr, HV_C_SHAPE );
      /* Modified for CR179801061 */
      FIfld_get_value( me->form_ptr , HV_WIDTH, row, col,
                                         &me->width_sav, &sel_flag, &r_pos );
      FIfld_get_value( me->form_ptr , HV_DEPTH, row, col,
                                         &me->depth_sav, &sel_flag, &r_pos );
      me->shape_gadget =  HV_C_SHAPE;

      /* VRHvskupdwd added for CR179801061 */
      status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);

    }
    break;

    /* Below modified for CR179309874 - new RW shapes */  
    /* Below modified for CR179900491 - dynamic depth */  
    case RW_O_SHAPE     :
      /* RWAY Oval */
      FIfld_set_mode(form_ptr, RW_DEPTH, 0, FI_REVIEW);
      FIg_erase( form_ptr, RW_DEPTH ); //Reddy-no depth for circular shape
      FIg_erase( form_ptr, RW_D_TXT ); //Reddy-no depth label for circular shape
      FIg_erase( me->form_ptr, RW_R_SHAPE );
      FIg_erase( me->form_ptr, RW_O_SHAPE );
      FIg_erase( me->form_ptr, RW_RS_SHAPE );
      FIg_erase( me->form_ptr, RW_E_SHAPE );
      FIg_erase(me->form_ptr,FRM_TIER_SP_1);
      FIg_erase(me->form_ptr,FRM_TIER_SP_2);
      FIg_erase(me->form_ptr,FRM_NO_TIER_1);
      FIg_erase(me->form_ptr,FRM_NO_TIER_2);
      FIg_set_value(  form_ptr, FRM_DEPTH_1, me->RWcptdata[0].width);
      me->depth_sav = me->RWcptdata[0].depth;
      if( me->SketchMode == VR_MANUAL )
      {
        FIg_set_value(  form_ptr, FRM_DEPTH_2,
                                me->RWcptdata[me->active_cpt-1].width);
	FIg_erase( me->form_ptr, RW_R_SHAPE );

	// Added by Reddy - Removing small depth gadgets for circular shape 
	FIg_erase( me->form_ptr,SMALL_RW_DEPTH );
	FIg_erase( me->form_ptr,SMALL_RW_DEPTH_TXT );
      } 
      FIg_display( me->form_ptr, RW_C_SHAPE );
      me->shape_gadget =  RW_C_SHAPE;

// Reddy - Shape coordination
      FIg_erase( form_ptr, ACTIVE_CPT_INDEX_TEXT );
      FIg_erase( form_ptr, DECREASE_ACTIVE_CPT_INDEX );
      FIg_erase( form_ptr, ACTIVE_CPT_INDEX );
      FIg_erase( form_ptr, INCREASE_ACTIVE_CPT_INDEX );

    break;

  case HV_R_SHAPE: /* RW_R_SHAPE */
/*  case PP_DIAM:   same gadget number not allowed */
  case SMALL_DIAMETER:
    if( me->Product == VR_PIPING )
    {
      FIfld_get_value( me->form_ptr , PP_DIAM, row, col,
                                         &value, &sel_flag, &r_pos );
    
      FIfld_get_value( me->form_ptr , SMALL_DIAMETER, row, col,
                                             &w_value, &sel_flag, &r_pos );

      if( w_value > value )
      {
        FIfld_set_value( me->form_ptr , SMALL_DIAMETER,
             row, col, value, FALSE);

                 ex$message( field   = ERROR_FIELD,
              in_buff = "Second diameter should be greater than red !" );
      }
    }

    else if ( me->Product == VR_HVAC )
    {
      FIg_erase( me->form_ptr, HV_RS_SHAPE );
             FIg_erase( me->form_ptr, HV_C_SHAPE );
             FIg_erase( me->form_ptr, HV_R_SHAPE );
             FIg_display( me->form_ptr, HV_O_SHAPE );
	    me->shape_gadget =  HV_O_SHAPE;
      /* VRHvskupdwd added for CR179801061 */
      status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);
    }
    else if ( me->Product == VR_RWAY )
    {
      /* Below modified for CR179900491 - dynamic depth */  
      /* Below modified for CR179309874 - new RW shapes */  
      /* Added for CR179801144 */
      FIg_erase( form_ptr, N_TIER_SK1 );
      FIg_erase( form_ptr, SP_TIER_SK1 );
      FIg_erase( form_ptr, N_TIER_SK2 );
      FIg_erase( form_ptr, SP_TIER_SK2 );
      FIg_erase( form_ptr, N_TIER_SK1_TEXT );
      FIg_erase( form_ptr, SP_TIER_SK1_TEXT );
      FIg_erase( form_ptr, N_TIER_SK2_TEXT );
      FIg_erase( form_ptr, SP_TIER_SK2_TEXT );

      /* Below modified for CR179801144 */
      FIfld_set_mode(form_ptr, RW_DEPTH, 0, FI_INSERT);
      FIg_display( form_ptr, RW_DEPTH );
      FIg_display( form_ptr, RW_D_TXT );
      /* below modified for CR179801144 */
      FIfld_set_mode(form_ptr, SMALL_RW_DEPTH, 0, FI_INSERT);
      if( me->SketchMode == VR_MANUAL )
      {
         FIg_display( form_ptr, SMALL_RW_DEPTH );

         // Added by Reddy - Dispalying small depth gadgets for circular shape
	 FIg_display( me->form_ptr,SMALL_RW_DEPTH );
	 FIg_display( me->form_ptr,SMALL_RW_DEPTH_TXT );
         FIfld_set_mode(form_ptr, SMALL_RW_DEPTH, 0, FI_INSERT);

      }
      FIg_erase(me->form_ptr,FRM_TIER_SP_1);
      FIg_erase(me->form_ptr,FRM_TIER_SP_2);
      FIg_erase(me->form_ptr,FRM_NO_TIER_1);
      FIg_erase(me->form_ptr,FRM_NO_TIER_2);

      FIg_erase( me->form_ptr, RW_R_SHAPE );
      FIg_erase( me->form_ptr, RW_C_SHAPE );
      FIg_erase( me->form_ptr, RW_RS_SHAPE );
      FIg_erase( me->form_ptr, RW_E_SHAPE );
      FIg_display( me->form_ptr, RW_O_SHAPE );
      me->shape_gadget =  RW_O_SHAPE;

      //Reddy - Shape coordination
      FIg_erase( me->form_ptr, ACTIVE_CPT_INDEX_TEXT );
      FIg_erase( me->form_ptr, DECREASE_ACTIVE_CPT_INDEX );
      FIg_erase( me->form_ptr, ACTIVE_CPT_INDEX );
      FIg_erase( me->form_ptr, INCREASE_ACTIVE_CPT_INDEX );
    }
    break;

  case HV_C_SHAPE: // NOTE: RW_C_SHAPE=HV_C_SHAPE=16

	/* Below lines added by Anand for CR 179900060 and CR 179900837 */
		__DBGpr_com(" Setting up corner radius display");
		FIg_display( me->form_ptr, CORN_RAD );
		FIg_display( me->form_ptr, CORN_RAD_TXT );
		FIg_set_value( me->form_ptr, CORN_RAD, radius );
	/* Above lines added by Anand for CR 179900060 and CR 179900837 */

                /* Below modified for CR179309874 - new RW shapes */  
                if( me->Product == VR_HVAC )
                {
                   FIfld_set_mode(form_ptr, HV_DEPTH, 0, FI_INSERT);
                   FIg_display( form_ptr, HV_DEPTH );
                   FIg_erase( me->form_ptr, HV_O_SHAPE );
                   FIg_erase( me->form_ptr, HV_R_SHAPE );
                   FIg_erase( me->form_ptr, HV_C_SHAPE );
                   FIg_display( me->form_ptr, HV_RS_SHAPE );
                   me->shape_gadget =  HV_RS_SHAPE;

                   /* VRHvskupdwd added for CR179801061 */
                   if((me->width_sav > 0.0) && (me->depth_sav > 0.0))
                   {
                      FIfld_set_value( form_ptr, HV_WIDTH , row, col,
                                                 me->width_sav,sel_flag );
                      FIfld_set_value( form_ptr, HV_DEPTH , row, col,
                                                 me->depth_sav,sel_flag );
                   }

        status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);

                }
                /* Below modified for CR179309874 - new RW shapes */  
                /* Below modified for CR179900491 - Dynamic depth */
                else if ( me->Product == VR_RWAY )
                {
                   FIfld_set_mode(form_ptr, RW_DEPTH, 0, FI_INSERT);
                   FIg_display( form_ptr, RW_DEPTH );//Reddy -display Depth
		   FIg_display( form_ptr, RW_D_TXT );//Display depth label 
                   FIg_set_value(  form_ptr, FRM_DEPTH_1, me->depth_sav);
                   me->RWcptdata[0].depth = me->depth_sav;
                   if( me->SketchMode == VR_MANUAL )
                   {
                     FIg_set_value(  form_ptr, FRM_DEPTH_2, me->depth_sav);
                     me->RWcptdata[me->active_cpt].depth = me->depth_sav;

		      // Added by Reddy - Dispalying small depth gadgets 
		       FIg_display( me->form_ptr,SMALL_RW_DEPTH );
		       FIg_display( me->form_ptr,SMALL_RW_DEPTH_TXT );
                       FIfld_set_mode(form_ptr, SMALL_RW_DEPTH, 0, FI_INSERT);

                   } 
/* Redundant code deleted for tr179900780 ************
                   FIg_display( me->form_ptr, RW_C_SHAPE );
                   me->shape_gadget =  RW_C_SHAPE;
***************/
                   FIg_erase( me->form_ptr, RW_R_SHAPE );
                   FIg_erase( me->form_ptr, RW_O_SHAPE );
                   FIg_erase( me->form_ptr, RW_C_SHAPE );
                   FIg_erase( me->form_ptr, RW_E_SHAPE );
                   FIg_display( me->form_ptr, RW_RS_SHAPE );
                   me->shape_gadget =  RW_RS_SHAPE;
                   FIg_erase(me->form_ptr,FRM_TIER_SP_1);
                   FIg_erase(me->form_ptr,FRM_TIER_SP_2);
                   FIg_erase(me->form_ptr,FRM_NO_TIER_1);
                   FIg_erase(me->form_ptr,FRM_NO_TIER_2);

 
		}
    break;

  case CORN_RAD:
    {
	IGRdouble	tmp_rad=0.0;

	FIg_get_value( me->form_ptr, CORN_RAD, &tmp_rad );
/*
	__DBGpr_dbl(" Width",me->width_sav);
	__DBGpr_dbl(" Depth",me->depth_sav);
	if( (2*tmp_rad) > me->depth_sav || (2*tmp_rad) > me->width_sav )
	{
	    UI_status(" Corner radius value too big. Reset to old value");
	    FIg_set_value( me->form_ptr, CORN_RAD, radius );
	}
	else
*/
	if( me->Product == VR_HVAC )
	    status = VRHvskupdwd( me->form_ptr, me->shape_gadget, max_depth,
				  diameter, tmp_rad );
    }
    break;


  case HV_RS_SHAPE:  /* N_TIER_SK1 for VR_RWAY - CR179801144 */
    if ( me->Product == VR_HVAC )
    {
      FIg_erase( me->form_ptr, HV_RS_SHAPE );
             FIg_erase( me->form_ptr, HV_C_SHAPE );
             FIg_erase( me->form_ptr, HV_O_SHAPE );
             FIg_display( me->form_ptr, HV_R_SHAPE );
      me->shape_gadget =  HV_R_SHAPE;

      /* Below lines added by Anand for CR 179900060 */
      __DBGpr_com(" Removing corner radius display");
/* REMOVED FOR SERVICE PACK 4
      FIg_erase( me->form_ptr, CORN_RAD );
      FIg_erase( me->form_ptr, CORN_RAD_TXT );
*/
      /* Above lines added by Anand for CR 179900060 */

      /* VRHvskupdwd added for CR179801061 */
      if((me->width_sav > 0.0) && (me->depth_sav > 0.0))
      {
             FIfld_set_value( form_ptr, HV_WIDTH , row, col,
                                                 me->width_sav,sel_flag );
             FIfld_set_value( form_ptr, HV_DEPTH , row, col,
                                                 me->depth_sav,sel_flag );
      }
      status = VRHvskupdwd(me->form_ptr,me->shape_gadget,max_depth,
                                                         diameter,radius);
    }
    /* For rectangular raceway, depth computed at execute */
    break;

  /* Below added for CR179309874 - new RW shapes */  
  /* Below modified for CR179900491 - Dynamic depth */
  case RW_RS_SHAPE:
      FIg_erase( me->form_ptr, RW_R_SHAPE );
      FIg_erase( me->form_ptr, RW_O_SHAPE );
      FIg_erase( me->form_ptr, RW_C_SHAPE );
      FIg_erase( me->form_ptr, RW_RS_SHAPE );
      FIg_erase(me->form_ptr,FRM_TIER_SP_1);
      FIg_erase(me->form_ptr,FRM_TIER_SP_2);
      FIg_erase(me->form_ptr,FRM_NO_TIER_1);
      FIg_erase(me->form_ptr,FRM_NO_TIER_2);

      /* Below lines added by Anand for CR 179900837 */
      __DBGpr_com(" Removing corner radius display");
/* REMOVED FOR SERVICE PACK 4
      FIg_erase( me->form_ptr, CORN_RAD );
      FIg_erase( me->form_ptr, CORN_RAD_TXT );
*/
      /* Above lines added by Anand for CR 179900837 */
 
      FIg_display( me->form_ptr, RW_E_SHAPE );
      me->shape_gadget =  RW_E_SHAPE;
      FIfld_set_mode(me->form_ptr, RW_DEPTH, 0, FI_INSERT);/*CR179801144*/
      FIg_display( me->form_ptr, RW_DEPTH );
      FIg_display( form_ptr, RW_D_TXT ); //Reddy - Display Depth label
      if( me->SketchMode == VR_MANUAL )
      {
          FIfld_set_mode(me->form_ptr, SMALL_RW_DEPTH, 0, FI_INSERT);
      }
    break;

  case RW_E_SHAPE:
      FIg_erase( me->form_ptr, RW_O_SHAPE );
      FIg_erase( me->form_ptr, RW_C_SHAPE );
      FIg_erase( me->form_ptr, RW_RS_SHAPE );
      FIg_erase( me->form_ptr, RW_E_SHAPE );
      FIg_display( me->form_ptr, RW_R_SHAPE );
      /* Added for CR179801144 */
      /* Below modified for CR179900491 - Dynamic depth */
      __DBGpr_com("prepare for RW_R_SHAPE");
      FIg_display( form_ptr, FRM_TIER_SP_1 );
      FIg_display( form_ptr, FRM_NO_TIER_1 );
      FIg_display( form_ptr, N_TIER_SK1_TEXT );
      FIg_display( form_ptr, SP_TIER_SK1_TEXT );
      FIfld_set_mode(form_ptr, RW_DEPTH, 0, FI_REVIEW);

      if( me->SketchMode == VR_MANUAL )
      {
         FIg_display( form_ptr, FRM_TIER_SP_2 );
         FIg_display( form_ptr, FRM_NO_TIER_2 );
         FIg_display( form_ptr, N_TIER_SK2_TEXT );
         FIg_display( form_ptr, SP_TIER_SK2_TEXT );
         FIfld_set_mode(form_ptr, SMALL_RW_DEPTH, 0, FI_REVIEW);
         FIg_display( form_ptr, SMALL_RW_DEPTH );
         FIg_display( form_ptr, SMALL_RW_DEPTH_TXT );

         // Reddy - Shape coordination
         FIg_display( form_ptr, ACTIVE_CPT_INDEX_TEXT );
         FIg_display( form_ptr, DECREASE_ACTIVE_CPT_INDEX );
         FIg_display( form_ptr, ACTIVE_CPT_INDEX );
         FIg_display( form_ptr, INCREASE_ACTIVE_CPT_INDEX );
      }
      FIfld_set_mode(form_ptr, RW_DEPTH, 0, FI_REVIEW);
      FIg_display( form_ptr, RW_DEPTH ); /* CR179801144 */
      FIg_display( form_ptr, RW_D_TXT ); //Reddy - Display Depth label

      me->shape_gadget =  RW_R_SHAPE;
    break;

  case HV_THROAT_RADIUS:  /* gadget label = 51 */
  
       FIg_get_value(  me->form_ptr, gadget_label, &value );
       ex$message( field=ERROR_FIELD, in_buff= " " );
  
       if ( value <= 0 )
       {
           ex$message( field=ERROR_FIELD, in_buff= " Throat Radius Should be Greater than 0 " );
  
           /* Set the value to the default, from active parameters */
           status =
           om$send( msg = message ACncpx.ACgive_structure
                  ( &retstatus, &FootIndex, VR_N_THROAT_DB,
                    &ParamAttr, &me->ModuleInfo),
           targetid = me->ActParamId.objid,
           targetos = me->ActParamId.osnum );
  
           FIfld_set_value( form_ptr, gadget_label, row, col,
                          ParamAttr.var.root_pm_st.value,
                          sel_flag );
       }
     break;
  
   case HV_TRAN_LENGTH: /* gadget label = 53 */
  
       FIg_get_value(  me->form_ptr, gadget_label, &value );
       ex$message( field=ERROR_FIELD, in_buff= " " );
  
       if ( value <= 0 )
       {
           ex$message( field=ERROR_FIELD, in_buff= " Transition Length Should be Greater than 0 " );
  
           /* Set the value to the default, from active parameters */
  
           status =
           om$send( msg = message ACncpx.ACgive_structure
                  ( &retstatus, &FootIndex, VR_N_TRANS_L_DB,
                    &ParamAttr, &me->ModuleInfo),
           targetid = me->ActParamId.objid,
           targetos = me->ActParamId.osnum );
  
           FIfld_set_value( form_ptr, gadget_label, row, col,
                          ParamAttr.var.root_pm_st.value,
                          sel_flag );
        }
     break;

/* Removed T_SHAPE -law- CR179309874 */

  case FI_EXECUTE :

    FIbtn_set_auto_pop_up_on( form_ptr, gadget_label );
    status = 
    VR$active_params( operation       = VR_RETRIEVE,
	              VRproduct       = me->Product,
	              act_param_id    = &me->ActParamId,
                      status          = status );

    ParamId.osnum = me->ModuleInfo.md_id.osnum;

    NbAttr = 0;
    NBcnt = 0;
    if ( me->Product == VR_PIPING )
    {
      /* -- Set Green Diameter -- */
      FIfld_get_value( me->form_ptr , PP_DIAM, row, col,
                              &value,  &sel_flag, &r_pos );

      strcpy( NewListAttr[NbAttr].name, VR_N_GDIAMETER_DB );
              NewListAttr[NbAttr].desc.type          = AC_ATTRIB_DOUBLE;
              NewListAttr[NbAttr].desc.value.att_exp = value ;
      NbAttr ++;

			/*"SketchMode = %d\n", me->SketchMode */

			if( me->SketchMode == VR_MANUAL )
			{		
			 FIfld_get_value( me->form_ptr , SMALL_DIAMETER, row, col,
               			         &value,  &sel_flag, &r_pos );
			 /*A set this flag to true */
			 me->bTagNumUsed = TRUE;
			} else me->bLineNumUsed = TRUE;

			/* -- Set Red Diameter -- */
			strcpy( NewListAttr[NbAttr].name, VR_N_RDIAMETER_DB );
     			NewListAttr[NbAttr].desc.type          = AC_ATTRIB_DOUBLE;
     			NewListAttr[NbAttr].desc.value.att_exp = value ;
			NbAttr ++;

			/* -- Set Line Sequence Number -- */
			FIfld_get_text( me->form_ptr, LINE_SEQ_NUM,  row, col,
                       			15, (unsigned char *) text, 
					&sel_flag, &r_pos );

			strcpy( NewListAttr[NbAttr].name, VR_N_SEQ_NUMBER_AN);
                	NewListAttr[NbAttr].desc.type = AC_ATTRIB_TEXT;
                	strcpy(NewListAttr[NbAttr].desc.value.att_txt,text);
			NbAttr ++;

			/* -- Set Pid Scale Factor -- */
			FIfld_get_value( me->form_ptr , SK_PID_SCALE, row, col,
                       			 &value,  &sel_flag, &r_pos );

			strcpy( NewListAttr[NbAttr].name, VR_N_PID_SCALE_DB );
      			NewListAttr[NbAttr].desc.type          = AC_ATTRIB_DOUBLE;
     			NewListAttr[NbAttr].desc.value.att_exp = value ;
			NbAttr ++;

                        /* added by Alwin for CR179300978*/
                        /* Place the Piping Option Code Text, in the directory
                           structure. This may help us in retreiving the value
                           and constructing the Pipe easily. */
                        {
                           IGRchar optcode_text[20];
                           IGRchar pathname[OM_K_MAXOSNAME_LEN];
                           struct GRid ExpressionId;
 
                           FIfld_get_text( me->form_ptr, PIPING_OPTION, 0, 0,
                                           20, (unsigned char *) optcode_text,
                                           &sel_flag, &r_pos );
 
                           /* Get the Current Working Directory */
                           status = di$pwd( dirname = pathname );
 
                           /* Change to the HOME directory */
                           status = di$cd( dirname = DIR_G_home_name );
 
                           /* Get the ExpressionId if it is already created
                              in the Directory Subsystem */
                           status = di$translate(
                                                objname = "piping_option_code",
                                                p_objid = &ExpressionId.objid,
                                                p_osnum = &ExpressionId.osnum );
 
                           if( status != DIR_S_SUCCESS )
                           {
                              ExpressionId.osnum = me->ModuleEnv.md_id.osnum;
                              status = exp$create (
                                     exp_name   = "piping_option_code",
                                     exp_syntax = optcode_text,
                                     osnum      = ExpressionId.osnum,
                                     p_exp_id   = &ExpressionId.objid,
                                     p_osnum    = &ExpressionId.osnum,
                                     type_rq    = EXP_TEXT );
                           }
                           else
                           {
                              status = exp$modify ( exp_id = ExpressionId.objid,
                                                    osnum  = ExpressionId.osnum,
                                                    exp_syntax = optcode_text );
                           }
 
                           /* Re-Setting it to the PWD directory  */
                           status = di$cd( dirname = pathname );
                           UI_status( "Processing ..." );
 
                        }
                        /* END - added by Alwin for CR179300978*/
		}

		if( ( me->Product == VR_HVAC ) || ( me->Product == VR_RWAY ) )
		{
                        NBcnt = 0;
                        /* VRHvskupdwd added for CR179801061 */
/*** Major changes in loading NewListAttr for tr179900932 ***/
			if ( me->Product == VR_HVAC )
                        {
                           NbAttr = 10;
                           /* TR179900985 - skip VRHvskupdwd in manual mode */
                           if( me->SketchMode != VR_MANUAL )
                           {
                           status = VRHvskupdwd(me->form_ptr,me->shape_gadget,
                                            max_depth,diameter,radius);
                           }
                        /* Below modified for CR179309874 - new RW shapes */  
                        }
			else NbAttr = 13; /* CR179801144 - added tiers */

                        if ( me->Product == VR_HVAC )
                        {
			FIfld_get_value( me->form_ptr , HV_WIDTH, row, col,
                                         &value,  &sel_flag, &r_pos );
			strcpy( NewListAttr[NBcnt].name, VR_N_WIDTH1_DB);
                	NewListAttr[NBcnt].desc.type          = AC_ATTRIB_DOUBLE;
                	NewListAttr[NBcnt].desc.value.att_exp = value ;
                        NBcnt++;
                        /* Modified for CR179900491 */
			if( me->SketchMode == VR_MANUAL )
			{
					/*| manual mode */
			    FIfld_get_value( me->form_ptr, SMALL_HV_WIDTH,
				    	     row, col, &value, &sel_flag,
					     &r_pos);
			}

                	strcpy( NewListAttr[NBcnt].name, VR_N_WIDTH2_DB);
                	NewListAttr[NBcnt].desc.type          = AC_ATTRIB_DOUBLE;
                	NewListAttr[NBcnt].desc.value.att_exp = value ;
                        NBcnt++;

			  FIfld_get_value( me->form_ptr , HV_DEPTH, row, col,
                                 	 &value,  &sel_flag, &r_pos );
			  /* CR179801144-rway depth moved to tier processing */ 

                	  strcpy( NewListAttr[NBcnt].name, VR_N_DEPTH1_DB);
                	  NewListAttr[NBcnt].desc.type          = AC_ATTRIB_DOUBLE;
                	  NewListAttr[NBcnt].desc.value.att_exp = value ;
                        NBcnt++;

			  if( me->SketchMode == VR_MANUAL )
			  {
				/*| manual mode */
				if( me->Product == VR_HVAC )
				FIfld_get_value( me->form_ptr , SMALL_HV_DEPTH, row, col,
                                         	 &value,  &sel_flag, &r_pos
					       );
			  /* CR179801144-rway depth moved to tier processing */ 
			  }

                	  strcpy( NewListAttr[NBcnt].name, VR_N_DEPTH2_DB);
                	  NewListAttr[NBcnt].desc.type          = AC_ATTRIB_DOUBLE;
                	  NewListAttr[NBcnt].desc.value.att_exp = value ;
                          NBcnt++;

                        }		
                        shpid = NBcnt;
			strcpy( NewListAttr[NBcnt].name, VR_N_SHAPE_IN);
                	NewListAttr[NBcnt].desc.type = AC_ATTRIB_DOUBLE;

			if( me->shape_gadget == HV_O_SHAPE )
                		NewListAttr[NBcnt].desc.value.att_exp = VR_OVAL;

                         /* Below modified for CR179309874 - new RW shapes */  

			if( me->shape_gadget == RW_O_SHAPE )
                		NewListAttr[NBcnt].desc.value.att_exp = VR_OVAL;

			if( me->shape_gadget == HV_R_SHAPE ) /* RW_R_SHAPE */
                		NewListAttr[NBcnt].desc.value.att_exp = VR_RECT;

                        /* Below modified for CR179309874 - new RW shapes */  
			if( me->shape_gadget == HV_C_SHAPE ) /* RW_C_SHAPE */
                		NewListAttr[NBcnt].desc.value.att_exp = VR_CIRC;

			if( me->shape_gadget == HV_RS_SHAPE )
                		NewListAttr[NBcnt].desc.value.att_exp = VR_CORNER;

                        /* Below modified for CR179309874 - new RW shapes */  
			if( me->shape_gadget == RW_RS_SHAPE )
                		NewListAttr[NBcnt].desc.value.att_exp = VR_CORNER;

                        /* Below modified for CR179309874 - new RW shapes */  
			if( me->shape_gadget == RW_E_SHAPE )
                		NewListAttr[NBcnt].desc.value.att_exp = VR_ELLIPSE;
                          NBcnt++;

			/* -- Set Symb Scale Factor -- */
			if ( me->Product == VR_HVAC )
			{
				FIg_get_value( me->form_ptr , 
					HV_SYMB_SCALE, &value );

				strcpy( NewListAttr[NBcnt].name,VR_N_PID_SCALE_DB );
      				NewListAttr[NBcnt].desc.type = 
					AC_ATTRIB_DOUBLE;
     				NewListAttr[NBcnt].desc.value.att_exp = value ;
                                NBcnt++;
			} /* end of set symb scale */

			/*C get the line seq number */
			FIfld_get_text( me->form_ptr, LINE_SEQ_NUM,  row, col,
                       			15, (unsigned char *) text, 
					&sel_flag, &r_pos );

                        if ( me->Product == VR_HVAC )
                        {
                            strcpy( NewListAttr[NBcnt].name, VR_N_SEQ_NUMBER_AN);
                            NewListAttr[NBcnt].desc.type = AC_ATTRIB_TEXT;
                            strcpy(NewListAttr[NBcnt].desc.value.att_txt,text);
                        }
                        else
                        {
                          strcpy( NewListAttr[NBcnt].name, VR_N_SEQ_NUMBER_AN);
                          NewListAttr[NBcnt].desc.type = AC_ATTRIB_TEXT;
                          strcpy(NewListAttr[NBcnt].desc.value.att_txt,text);
                        }
                        NBcnt++;
  
                          /*C get the Throat Radius */
                           FIg_get_value( me->form_ptr, HV_THROAT_RADIUS, &value
 );
                           /* Below modified for CR179701945 - Throat radius */  
                           strcpy( NewListAttr[NBcnt].name, VR_N_THROAT_DB);
                           NewListAttr[NBcnt].desc.type = AC_ATTRIB_DOUBLE;
                           NewListAttr[NBcnt].desc.value.att_exp = value;

			   NBcnt++;
  
                           /*C get the Transition Length */
                           FIg_get_value( me->form_ptr, HV_TRAN_LENGTH, &value );
  
                           strcpy( NewListAttr[NBcnt].name, VR_N_TRANS_L_DB);
                           NewListAttr[NBcnt].desc.type = AC_ATTRIB_DOUBLE;
                           NewListAttr[NBcnt].desc.value.att_exp = value;

			   NBcnt++;
                           /* Tier processing added - CR179801144 */
                           if ( me->Product == VR_RWAY )
                           {
                              /* Modified for CR179900491 */
                              __DBGpr_com("tier data put into collection here");
                              FIfld_set_mode(form_ptr, RW_DEPTH, 0, FI_REVIEW);
                              FIg_display( form_ptr, RW_DEPTH );
			      if( me->SketchMode == VR_MANUAL )
                              {
                                FIfld_set_mode(form_ptr, SMALL_RW_DEPTH,
				                                 0, FI_REVIEW);
                                FIg_display( form_ptr, SMALL_RW_DEPTH );

				/* Below added by Anand for TR 179900778 */
				if( me->bIsShapeTransition )
				{
				    NewListAttr[shpid].desc.type = AC_ATTRIB_DOUBLE;
				    NewListAttr[shpid].desc.value.att_exp = me->nShapeCode;
				}
				/* Above added by Anand for TR 179900778 */


                              }
                           }
/******* TR179900780 *****/
		/* Below added by Anand for CR 179900060 and CR 179900837 */
                           strcpy(NewListAttr[NBcnt].name, VR_N_CORN_RAD_DB);
			   NewListAttr[NBcnt].desc.type = AC_ATTRIB_DOUBLE;
			   FIg_get_value( me->form_ptr, CORN_RAD, &radius );
			   NewListAttr[NBcnt].desc.value.att_exp = radius;
			   ++NBcnt;
		/* Above added by Anand for CR 179900060 and CR 179900837 */
/*moved to avoid conflict with piping-delivered with tr179900934 ***/
NbAttr = NBcnt;
		}
/* Below modified for TR179900780 & tr179900932 cleanup ***/
		ParamId.objid = NULL_OBJID;
		ParamId.osnum = me->ModuleInfo.md_id.osnum;
  	status = VR$ModifyCollection( 	p_msg			= &retcode,
	          				p_InputCollectionId	= &me->ActParamId,
        	 				p_OutputCollectionId    = &ParamId );
	  	as$status();
  		as$status( sts = retcode );

		status = VR$ModifyCollection( 	p_msg			= &retcode,
         					Operation               = VR_MERGE_COLL,
         					p_ParamsListToModify   	= NewListAttr,
         					NbParamsToModify       	= NbAttr,
         					p_OutputCollectionId    = &ParamId );
	  	as$status();
  		as$status( sts = retcode );

                /* Below modified for CR179900491 - Dynamic depth */
		if( me->SketchMode == VR_AUTOMATIQUE )
		{
                  if ( me->Product == VR_RWAY )
                  {
                     /** Modified for CR179900491 **/
                     if( me->shape_gadget == RW_O_SHAPE )
                        shape_code = VR_OVAL;
                     else if( me->shape_gadget == HV_C_SHAPE )
                        shape_code = VR_CIRC;
                     else if( me->shape_gadget == RW_RS_SHAPE )
                        shape_code = VR_CORNER;
                     else if( me->shape_gadget == RW_E_SHAPE )
                        shape_code = VR_ELLIPSE;
                     else
                        shape_code = VR_RECT;
		     /* get the spec name */

		     __DBGpr_int(" Shape code", shape_code );
		     __DBGpr_dbl(" Depth 1", me->RWcptdata[0].depth);
		     __DBGpr_dbl(" Depth 2", me->RWcptdata[1].depth);

                     /*** TR179801414 - labeled as a KLUDGE in test src ***/
                     __DBGpr_com("setting cpt0&1 equal to each other");
                     me->RWcptdata[1] = me->RWcptdata[0];

                     NbCpts = 2;
                     __DBGpr_int("no. of cpts to store",NbCpts);
                     status = VRRw_dimen_fields(NULL,NULL,&my_grid,
                              &me->ModuleInfo, NbCpts, NULL, 2,
                              shape_code, me->RWcptdata, &ParamId);

                  }

			/*| sketch mode is AUTOMATIQUE */
			me->ActParamId = ParamId;
			status = 
			VR$active_params( operation          = VR_REPLACE,
                                   	  update_flag        = VR_UPDATE,
                                   	  VRproduct          = me->Product,
                                   	  act_param_id       = &me->ActParamId,
                                   	  status             = status );

                        /* Modified for CR179900491 */
	  	 	status = VRSkUpdateForm( me->Product, me->form_ptr, 
						 &me->shape_gadget, &ParamId, 
						 me->CmpAABBCCcode,
						 &me->active_cpt,
						 me->RWcptdata,
                                                 &me->ModuleInfo,
 						 VR_AUTOMATIQUE );
                        __DBGpr_com("Back from VRSkUpdateForm");
	  	 	as$status();

                        /* Reddy - Shape coordination */
                        if(me->shape_gadget == RW_C_SHAPE) {
                          FIg_erase( me->form_ptr , RW_DEPTH) ;
                          FIg_erase( me->form_ptr , RW_D_TXT) ;
                        }
		}
                  /* Below modified for CR179900491 - Dynamic depth */
		else
		{
                  if ( me->Product == VR_RWAY )
                  {
                    /* Modified for CR179900491 */
                    if( me->shape_gadget == RW_O_SHAPE )
                       shape_code = VR_OVAL;
                    else if( me->shape_gadget == HV_C_SHAPE )
                       shape_code = VR_CIRC;
                    else if( me->shape_gadget == RW_RS_SHAPE )
                       shape_code = VR_CORNER;
                    else if( me->shape_gadget == RW_E_SHAPE )
                       shape_code = VR_ELLIPSE;
                    else
                       shape_code = VR_RECT;

		if( me->SketchMode == VR_AUTOMATIQUE )
                    {
                      NbCpts = 2;
                    }
                    else
                    {
		     /* get the spec name */
                     status = 
                        om$send( msg      = message ACncpx.ACgive_structure
                                 ( &retstatus, 
                                   &FootIndex, 
                                   VR_N_CLASS_AN,
                                   &ParamAttr, 
                                   &me->ModuleInfo),
                        targetid = me->ActParamId.objid,
                        targetos = me->ActParamId.osnum );
		     strcpy (spec_name,ParamAttr.var.text_st.text_string);

                     /* added by alwin to send proper shape_code value for
                     finding out "nb_cpts" */

                     if( me->bIsShapeTransition )
                       shape_code = me->nShapeCode;

		     /*** Get the number of cpts to store */
                     status = VRGetComp_NbCpt(
			&longmsg,(IGRshort) me->Product,shape_code,spec_name,
						 me->CmpAABBCCcode, &NbCpts);
                     /* NbCpts = some magic number */
                     if(NbCpts < 1 || NbCpts > 10)
                        NbCpts = 2;
                   }
                   /*****************************************************/ 
                   /*** REALLY BAD KLUDGE for COTRAN for TR179900976  ***/
                   /*** The new macro is reversed, but swaps the ends ***/
                   /*** in manual mode, so we swap the ends before    ***/
                   /*****************************************************/ 
                   if(shape_code == VR_OVAL_CIRC )
                   {
                       struct VRRwCptDetails tmpcptdata;
                       tmpcptdata = me->RWcptdata[0];
                       me->RWcptdata[0] = me->RWcptdata[1];
                       me->RWcptdata[1] = tmpcptdata;
                   }

                   __DBGpr_int("NbCpts",NbCpts);
                   __DBGpr_com("call3 of VRRw_dimen_fields");
                   status = VRRw_dimen_fields(NULL,NULL,&my_grid,
                              &me->ModuleInfo, NbCpts, NULL, 2,
                              shape_code, me->RWcptdata, &ParamId);

/**** tr179900932 cleanup ****/
                           strcpy(NewListAttr[0].name, VR_N_CORN_RAD_DB);
			   NewListAttr[0].desc.type = AC_ATTRIB_DOUBLE;
			   FIg_get_value( me->form_ptr, CORN_RAD, &radius );
			   NewListAttr[0].desc.value.att_exp = radius;

/**** Trying to update collection for corner radius-may not be successful ***/
		status = VR$ModifyCollection( 	p_msg			= &retcode,
         					Operation               = VR_MERGE_COLL,
         					p_ParamsListToModify   	= NewListAttr,
         					NbParamsToModify       	= 1,
         					p_OutputCollectionId    = &ParamId );
/*me->ActParamId = ParamId; Original did not have this -tr179900932 cleanup */
                   /*** Added for tr179900780 ***/
                   /*****************************/
                   if(! me->bIsShapeTransition )
                   {
                        me->RWcptdata[0] = me->RWcptdata[1];
                   }
                   status =
                        om$send( msg      = message ACncpx.ACgive_structure
                                 ( &retstatus,
                                   &FootIndex,
                                   VR_N_SHAPE_IN,
                                   &ParamAttr,
                                   &me->ModuleInfo),
                        targetid = me->ActParamId.objid,
                        targetos = me->ActParamId.osnum );
                   /*****************************/
                  }
			me->ListIds[0] = ParamId;
			/*^ VRprint_user_attr( &me->ListIds[0] ); */
			switch( me->Product )
			{
				case VR_PIPING:
					/* -- get the code corresponding the text -- */
                                         {
					  IGRlong	msg;
					  IGRint	o_code;
					  IGRchar	p_error[30];

					  FIfld_get_text( me->form_ptr, OPTION,
						row, col, 30, 
						(unsigned char *) text, 
						&sel_flag, &r_pos );
  		    			  status = vd$get_alias (    p_msg	= &msg,
		    			 			product	= PIPING,
		    			 			type	= VR_OPTCODE_LIST_NUM,
		    			 			i_lname	= text,
		    			 			o_code	= &o_code,
		    			 			p_error	= p_error	);
				          if ( status != OM_S_SUCCESS )
					    me->CmpOption = (int)atoi(text);
					  else
					    me->CmpOption = o_code;
                                        }
					FIfld_get_text( me->form_ptr, PP_CMP_NB,
						row, col, 10, 
						(unsigned char *) text, 
						&sel_flag, &r_pos );
					strcpy( me->CmpNumber, text );
					break;
				case VR_HVAC:
					FIfld_get_text( me->form_ptr, HV_CMP_NB,
						row, col, 10, 
						(unsigned char *) text, 
						&sel_flag, &r_pos );
					strcpy( me->CmpNumber, text );
					break;
				case VR_RWAY:
					FIfld_get_text( me->form_ptr, RW_CMP_NB,
						row, col, 10, 
						(unsigned char *) text, 
						&sel_flag, &r_pos );
					strcpy( me->CmpNumber, text );
					break;
				default:break;
			}

		}
        	_put_response( resp = EX_FORM_FINISHED );

		break;
	
	case FI_RESET:
		/* redisplay gadget */
		FIbtn_set_auto_pop_up_on( me->form_ptr, FI_RESET );
  		status = om$send( msg      = message VRsketch.VRSwapSketchForm( me->SketchMode ),
	            		  targetid = my_id );
  		as$status();
/*** Trying to stop crashes on reset tr179900780 ****/
me->active_cpt = 1;
                     status =
                        om$send( msg      = message ACncpx.ACgive_structure
                                 ( &retstatus,
                                   &FootIndex,
                                   VR_N_SHAPE_IN,
                                   &ParamAttr,
                                   &me->ModuleInfo),
                        targetid = me->ActParamId.objid,
                        targetos = me->ActParamId.osnum );

    shape_code = (IGRint) ParamAttr.var.root_pm_st.value;
    if(me->Product == VR_RWAY)  /** tr179900932 cleanup */
    {
             status = VRRw_dimen_fields(NULL, NULL, NULL,
                                &me->ModuleInfo,
                                2,
                                &me->active_cpt, 0, shape_code, me->RWcptdata,
                                &me->ActParamId);
             __DBGpr_com("back from VRRw_dimen_fields");
    }

/*** end of crash prevention ****/
		break;
        /* Added for TR179900985 HVAC transition processing */
        case SMALL_HV_DEPTH:
           break;
        default:
           /* Modified for CR179900491 */
           __DBGpr_com("trapped to unknown gadget");
           if( me->shape_gadget == RW_O_SHAPE )
              shape_code = VR_OVAL;
           else if( me->shape_gadget == HV_C_SHAPE )
              shape_code = VR_CIRC;
           else if( me->shape_gadget == RW_RS_SHAPE )
              shape_code = VR_CORNER;
           else if( me->shape_gadget == RW_E_SHAPE )
              shape_code = VR_ELLIPSE;
           else
              shape_code = VR_RECT;

           if(me->SketchMode == VR_MANUAL)
           {
		     /* get the spec name */
             status = 
                 om$send( msg      = message ACncpx.ACgive_structure
                          ( &retstatus, 
                            &FootIndex, 
                            VR_N_CLASS_AN,
                            &ParamAttr, 
                            &me->ModuleInfo),
                 targetid = me->ActParamId.objid,
                 targetos = me->ActParamId.osnum );
	     strcpy (spec_name,ParamAttr.var.text_st.text_string);

             /* added by alwin to send proper shape_code value for
             finding out "nb_cpts" */

             if( me->bIsShapeTransition )
               shape_code = me->nShapeCode;

	     /*** Get the number of cpts to store */
             status = VRGetComp_NbCpt(
			&longmsg,(IGRshort) me->Product,shape_code,spec_name,
						 me->CmpAABBCCcode, &NbCpts);
             __DBGpr_int("NbCpts ",NbCpts);
             __DBGpr_com("Call8 for VRRw_dimen_fields");
             if(NbCpts < 1 || NbCpts > 10)
                  NbCpts = 10;
           }
           else
             NbCpts = 2;

    if(me->Product == VR_RWAY) /* tr179900932 cleanup */
    {
             __DBGpr_int("NbCpts is a magic number here",NbCpts);
             status = VRRw_dimen_fields(me->form_ptr, gadget_label, NULL,
                                &me->ModuleInfo,
                                NbCpts,
                                &me->active_cpt, 1, shape_code, me->RWcptdata,
                                &ParamId);
             __DBGpr_com("back from VRRw_dimen_fields");
    }

            /* Reddy - Shape coordination */
            if(shape_code == VR_CIRC) {
              FIg_erase( me->form_ptr , RW_DEPTH) ;
              FIg_erase( me->form_ptr , RW_D_TXT) ;
            }
            if(me->SketchMode != VR_MANUAL){
                FIg_erase( me->form_ptr, ACTIVE_CPT_INDEX_TEXT );
                FIg_erase( me->form_ptr, DECREASE_ACTIVE_CPT_INDEX );
                FIg_erase( me->form_ptr, ACTIVE_CPT_INDEX );
                FIg_erase( me->form_ptr, INCREASE_ACTIVE_CPT_INDEX );
            }

            /*| Unknown Gadget */
	    break;
   	}
  } /* end of if */
  else if( form_ptr == me->forms[0].form_ptr )
  {
    IGRint	sel_flag, r_pos, row = 0, i, num_rows, length;
    IGRchar	VRbuffer_user_values[VR_MAX_CHAR*VR_MAX_ATTR];
    IGRchar	VRbuffer_user_names[VR_MAX_CHAR*VR_MAX_ATTR];
    IGRchar	*VRuser_names[VR_MAX_ATTR], *VRuser_values[VR_MAX_ATTR];

    for( i=0; i<VR_MAX_ATTR; i++ )
    {
	VRuser_names[i]  = &VRbuffer_user_names [ VR_MAX_CHAR * i];
	VRuser_values[i] = &VRbuffer_user_values[ VR_MAX_CHAR * i];
    }

    switch ( gadget_label )
    {
      	case USER_ATTR_FLD:
        	break;

      	case FI_EXECUTE:
		FIbtn_set_auto_pop_up_on( form_ptr, gadget_label );

       		FIfld_get_max_num_rows( form_ptr, USER_ATTR_FLD, &num_rows );
       		for ( row=0, length=0; row<num_rows; row++ )
       		{
        		FIfld_get_text_length( form_ptr, USER_ATTR_FLD, row, 0, &length );

          		if( length >1 )
          		{
            			FIfld_get_text( form_ptr, USER_ATTR_FLD, row, 0,
					    length,
 				            (unsigned char *)VRuser_names[row],
					     &sel_flag, &r_pos
					      );
			    	/*"parameter %d name = %s\n", row, VRuser_names[row] */
			    
            		    	FIfld_get_text_length( form_ptr, USER_ATTR_FLD, row, 1, &length );

            		    	if( length < 2 ) length = 10;
            		    	FIfld_get_text( form_ptr, USER_ATTR_FLD, row, 1,
					length, 
					(unsigned char *)VRuser_values[row], 
					&sel_flag, &r_pos
					       );
			    	/*"parameter %d value = %s\n", row, VRuser_values[row] */
          		}
          		else
          	 	{
        			status = VRchg_attributes
                 	   	         ( VR_ADD_OR_MOD_PARAM, me->MissParamId, row, VRuser_names, VRuser_values );
        		    	as$status( action = RET_STATUS );

    				_put_response( resp = EX_FORM_FINISHED );
				return OM_S_SUCCESS;
          		}
        	}
        	break;
    }
  }
  else if( form_ptr == me->status_display_form_ptr )
  {
    bNewPocket=TRUE;
    if(me->proc_livelook) /* Added for CR179708634 to setup next call */
    {
       bNewPocket=FALSE;
       status = VRPlvlkup(me->first_entry,&gadget_label,form_ptr,&me->OB);
       goto quit;
    }
    else if( ( me->prev_seg_id.objid == NULL_OBJID || !me->SketchMode ) &&
            gadget_label != FI_CANCEL )
    {
      ex$message( field   = ERROR_FIELD,
                  in_buff = "Cannot place component !" );

      status =
      om$send( msg = message VRsketch.VRSkPopupStatusField( &retcode ),
          targetid = my_id );

      return OM_S_SUCCESS;    
    }

    me->SketchMode = VR_MANUAL;
    __DBGpr_com("sketchmode set to VR_MANUAL");

    /* This form sets and activates specific pocket menus */

    switch( me->Product )
    {
      case VR_PIPING:
            switch( gadget_label )
        {
          case FI_CANCEL:
            FIf_erase( form_ptr );
            me->form_requested = 0;
            me->my_ret = VR_DEFAULT_VALUE;
            return OM_S_SUCCESS;

          case P_REDUCER_BUTTON :
            me->PocketMenuName = PREDUCERPKTMNU;
            me->CmpFunction = IS_REDUCER;
            break;

          case VALVE_BUTTON :
            me->PocketMenuName = PVALVEPKTMNU;
            me->CmpFunction = IS_VALVE;
            break;

          case ENDPIPE_BUTTON :
            me->PocketMenuName = PPIPEENDSPKTMNU;
            me->CmpFunction = IS_ENDPIPE;
            break;

          case P_ELBOW_BUTTON :
            me->PocketMenuName = PELBOWPKTMNU;
            me->CmpFunction = IS_ELBOW;
            break;

          case P_TEE_BUTTON :
            me->PocketMenuName = PTEEPKTMNU;
            me->CmpFunction = IS_TEE;
            break;

          case FLANGE_BUTTON :
            me->PocketMenuName = PFLANGEPKTMNU;
            me->CmpFunction = IS_FLANGE;
            break;

          case SPECIALITY:
            me->PocketMenuName = PSPECIALPKTMNU;
            me->CmpFunction = IS_SPECIALITY;
            break;

          case INSTRUMENT:
            me->PocketMenuName = PINSTRUPKTMNU;
            me->CmpFunction = IS_INSTRUMENT;
            break;

          case CONNECTOR:
            me->PocketMenuName = PCONNECPKTMNU;
            me->CmpFunction = IS_CONNECTOR;
            break;

          case P_USER :
            bNewPocket = FALSE;
            FIbtn_set_auto_pop_up_off( form_ptr, gadget_label );
            break;
        }
        break;
    case VR_HVAC:

          switch( gadget_label )
          {
              case FI_CANCEL:
          FIf_erase( form_ptr );
           me->form_requested = 0;
               me->my_ret = VR_DEFAULT_VALUE;
           return OM_S_SUCCESS;

        case H_ELBOW_BUTTON :
          me->PocketMenuName = HELBOWPKTMNU;
          me->CmpFunction = IS_ELBOW;
           break;

        case H_TEE_BUTTON :
          me->PocketMenuName = HTEEPKTMNU;
          me->CmpFunction = IS_TEE;
           break;

        case H_OFFSET_BUTTON:
          me->PocketMenuName = HOFFSETPKTMNU;
          me->CmpFunction = IS_OFFSET;
           break;


        case ENDDUCT_BUTTON:
          me->PocketMenuName = HDUCTENDSPKTMNU;
          me->CmpFunction = IS_ENDDUCT;
           break;

        case H_REDUCER_BUTTON:
          me->PocketMenuName = HREDUCERPKTMNU;
          me->CmpFunction = IS_REDUCER;
           break;

        case DEVICE_BUTTON:
          me->PocketMenuName = HTDEVICEPKTMNU;
          me->CmpFunction = IS_DEVICE;
          break;

        case TERMINATION:
          me->PocketMenuName = HTDEVICEPKTMNU;
          me->CmpFunction = IS_TERMINATION_DEVICE;
           break;

        case H_USER :
          bNewPocket = FALSE;
          FIbtn_set_auto_pop_up_off( form_ptr, gadget_label );
          break;

  /* Not yet implemented because we are unable to know wich shape is chosen */
        case TRANSITION_BUTTON :
          me->PocketMenuName = HTRANSITPKTMNU;
          me->CmpFunction = IS_TRANSITION;
           break;
            }
      break;

    case VR_RWAY:
      switch( gadget_label )
          {
        case FI_CANCEL:
          FIf_erase( form_ptr );
           me->form_requested = 0;
               me->my_ret = VR_DEFAULT_VALUE;
          return OM_S_SUCCESS;

        case R_REDUCER_BUTTON:
          me->PocketMenuName = HREDUCERPKTMNU;
          me->CmpFunction = IS_REDUCER;
           break;

        case R_ELBOW_BUTTON :
          me->PocketMenuName = HELBOWPKTMNU;
          me->CmpFunction = IS_ELBOW;
           break;

        case R_TEE_BUTTON :
          me->PocketMenuName = HTEEPKTMNU;
          me->CmpFunction = IS_TEE;
           break;

        case R_OFFSET_BUTTON:
          me->PocketMenuName = HOFFSETPKTMNU;
          me->CmpFunction = IS_OFFSET;
           break;

        case R_USER :
          bNewPocket = FALSE;
          FIbtn_set_auto_pop_up_off( form_ptr, gadget_label );
          break;

      }
      break;

    default : bNewPocket = FALSE; break;
    }/* end switch on products */
  if (bNewPocket)
  {
    VRChangePocketMenu( me->PocketMenuName );
    me->ChangePocket= TRUE;
  }
  if(!me->proc_livelook) /* CR179308634 - Livelookup */
  {
     _put_response( resp = EX_POCKET );
  }
  }/* end status display form */
  goto quit;
}/* end form_notification */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  			method initial_form_notification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action initial_form_notification
{

#ifdef	MANAGE_IDS

  int		i;

	if( form_ptr == me->form_ptr && bVR_IS_PID_ACTIVE )
        { 
__DBGpr_com("pid is active");
	  if ( gadget_label == LINE_SEQ_NUM )
	  {
		struct ret_struct	ParamAttr;
		IGRint 			FootIndex = -1, retstatus;
		IGRint			IdList[VDS_LIST_OF_IDS];
		IGRchar			LineIdStr[20];
			
		/*C Get system name */
		status = 
		om$send( msg      = message ACncpx.ACgive_structure
					   ( &retstatus, 
					     &FootIndex, 
				       	     VR_N_SYST_NAME_AN,
	     			       	     &ParamAttr, 
					     &me->ModuleInfo),
		targetid = me->ActParamId.objid,
		targetos = me->ActParamId.osnum );

		/*printf( " system name = %s \n", 
			ParamAttr.var.text_st.text_string ); */

		/*C unlock the previous unused id */
		if ( !me->bLineNumUsed && me->PrevLineNum != -1 )
		{
			status =
			VDUnLockID ( ParamAttr.var.text_st.text_string,
				(int)VD_C_PIPES, me->PrevLineNum );
		}/* end of unlock */

		/*C get the list of available line Ids */
		status = 
		VDGetListOfIDs( ParamAttr.var.text_st.text_string,
			(int)VD_C_PIPES, IdList );

		/*C set the associated list */
		for( i=0; i<VDS_LIST_OF_IDS; i++ )
		{
			sprintf( LineIdStr, "%05d", IdList[i] );
			FIfld_set_list_text( form_ptr, gadget_label, 
				i, 0, (unsigned char *) LineIdStr, FALSE);
		}
	  } 
	  else if ( ( (me->Product == VR_HVAC && gadget_label == HV_CMP_NB ) ||
		(me->Product == VR_PIPING && gadget_label == PP_CMP_NB ) )
			  && me->CmpBehavior == (int) VR_MANAGE_TAG )
	  {
		struct ret_struct	ParamAttr;
		IGRint 			FootIndex = -1, retstatus;
		IGRint			IdList[VDS_LIST_OF_IDS];
		IGRchar			LineIdStr[20];
			
		/*C Get system name */
		status = 
		om$send( msg      = message ACncpx.ACgive_structure
					   ( &retstatus, 
					     &FootIndex, 
				       	     VR_N_SYST_NAME_AN,
	     			       	     &ParamAttr, 
					     &me->ModuleInfo),
		targetid = me->ActParamId.objid,
		targetos = me->ActParamId.osnum );
		as$status();

		/*C unlock the previous unused id */
		if ( !me->bTagNumUsed && me->PrevTagNum != -1 )
		{
			status =
			VDUnLockID ( ParamAttr.var.text_st.text_string,
				me->CmpCat, me->PrevTagNum );
		}/* end of unlock */

		/*C get the list of available line Ids */
		status = 
		VDGetListOfIDs( ParamAttr.var.text_st.text_string,
			me->CmpCat, IdList );

		/*C set the associated list */
		for( i=0; i<VDS_LIST_OF_IDS; i++ )
		{
			sprintf( LineIdStr, "%05d", IdList[i] );
			FIfld_set_list_text( form_ptr, gadget_label, 
				i, 0, (unsigned char *) LineIdStr, FALSE);
		}
	  } 
	  else
	  if ( (me->Product == VR_HVAC && gadget_label == HV_CMP_NB ) ||
		(me->Product == VR_PIPING && gadget_label == PP_CMP_NB ) )
	  {
		/*A reset the associated list */
		FIfld_set_list_num_rows( form_ptr, gadget_label, 
				0, 0 );
	  }
          /* May need more work for CR179900491 */
          else if (me->Product == VR_RWAY)
          {
             /* Not supposed to be RWAY PID but may need init anyway */
             __DBGpr_com("Not supposed to be RWAY PID");
          }
          else return OM_S_SUCCESS;
       }
#else
  status = OM_S_SUCCESS;
#endif

  goto quit;
}

action VRSkUnLockId( IGRshort	Mode )
{

#ifdef	MANAGE_IDS

	struct ret_struct	ParamAttr;
	IGRint 			FootIndex = -1, retstatus;

	if ( ( me->Product == VR_PIPING || me->Product == VR_HVAC ) &&
				bVR_IS_PID_ACTIVE )
	{
		/*C Get system name */
		status = 
		om$send( msg      = message ACncpx.ACgive_structure
				   ( &retstatus, 
				     &FootIndex, 
			       	     VR_N_SYST_NAME_AN,
			       	     &ParamAttr, 
				     &me->ModuleInfo ),
			targetid = me->ActParamId.objid,
			targetos = me->ActParamId.osnum );
		as$status();

		/*C unlock the previous unused id */
		if ( Mode == VR_TAG_NUM && me->PrevTagNum != -1 )
		{
			status =
			VDUnLockID ( ParamAttr.var.text_st.text_string,
				me->CmpCat, me->PrevTagNum );
			as$status();
		} else if ( Mode == VR_LINE_NUM && me->PrevLineNum != -1 )
		{
			status =
			VDUnLockID ( ParamAttr.var.text_st.text_string,
				(int)VD_C_PIPES, me->PrevLineNum );
			as$status();
		}/* end of unlock */
	}
#else
  status = OM_S_SUCCESS;
#endif

  goto quit;
} /* end VRSkUnLockId	*/


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				method VRIsPrevSegSkewed

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

action VRIsPrevSegSkewed( IGRlong *sts )
{
       IGRdouble  tmp_vec[3], plane[3];
       BSrc	  bsretcode;

       BSmkvec(  &bsretcode, tmp_vec, me->prev_pt, me->first_pt );

       BSnorvec( &bsretcode, tmp_vec );

       plane[0] = 1.0;
       plane[1] = 0.0;
       plane[2] = 0.0;

       if( 1 - fabs( BSdotp(&bsretcode,tmp_vec,plane)) < BSBASISVAL )
       {
	   me->ret = VRALL_OK;
	   UI_status( "Prev Segment is already orthogonal !!!!" );
	   return OM_S_SUCCESS;
       }

       plane[0] = 0.0;
       plane[1] = 1.0;
       plane[2] = 0.0;

       if( 1 - fabs( BSdotp(&bsretcode,tmp_vec,plane)) < BSBASISVAL )
       {
	   me->ret = VRALL_OK;
	   UI_status( "Prev Segment is already orthogonal !!!!" );
	   return OM_S_SUCCESS;
       }

       plane[0] = 0.0;
       plane[1] = 0.0;
       plane[2] = 1.0;

       if( 1 - fabs( BSdotp(&bsretcode,tmp_vec,plane)) < BSBASISVAL )
       {
	   me->ret = VRALL_OK;
	   UI_status( "Prev Segment is already orthogonal !!!!" );
	   return OM_S_SUCCESS;
       }
       
       me->ret  = VRNOT_OK;
       return OM_S_SUCCESS;
}

action VRskdelangle		( IGRlong *sts  				) extern
action VRskgetangle		( IGRlong *sts 					) extern
action VRSkGetEvent		( IGRlong *sts 					) extern
action VRSkGetLocateState	( IGRlong *sts 					) extern
action VRskmerge		( IGRlong *sts 					) extern
action VRskinit_buffer 		( int * sts 					) extern
action VRskinit 		( IGRlong *sts 					) extern
action VRskfstpt 		( IGRlong *sts  				) extern
action VRsknextpt 		( IGRlong *sts 					) extern
action VRskcrseg 		( IGRlong *sts 					) extern
action VRskendline 		( IGRlong *sts					) extern
action VRSkEndLineRoute		( IGRlong *sts					) extern
action VRSkPlaceEndDangling	( IGRlong *sts					) extern
action VRskdelseg       	( IGRlong *sts 					) extern
action VRskdelta        	( IGRlong *sts 					) extern
action VRskgetnxtpt     	( IGRlong *sts 					) extern
action VRskget_valid_sol	( IGRlong *sts 					) extern
action VRskend_valid_sol	( IGRlong *sts 					) extern
action VRskdisp_all_way 	( IGRlong *sts 					) extern
action VRskfstchoice 		( IGRlong *sts 					) extern
action VRsknextchoice 		( IGRlong *sts 					) extern
action VRskcstpt 		( IGRlong *sts 					) extern
action VRskcstsol 		( IGRlong *sts 					) extern
action VRskfstelm 		( IGRlong *sts 					) extern
action VRskupdate_event 	( IGRlong *sts 					) extern
action VRskconnect 		( IGRlong *sts 					) extern
action VRSkGetElbowPrevSeg	( IGRlong 		*sts;
			     	  struct	GRid	*LocatedElbowId;
                                  struct	GRid	*ElbowPriSegId;
                                  struct	GRid	*ElbowSecSegId 		) extern
action VRSkGetElbowInfo		( IGRlong *sts 					) extern
action VRSkInitInstance		( IGRlong *sts 					) extern
action VRSKEraseHvacTee		( IGRlong *sts 					) extern
action VRSkSwitchFormParams	( IGRlong *sts 					) extern
action VRSkDisplayOrientTee	( IGRlong *sts 					) extern
action VRSkEraseStatusForm	( IGRlong *sts 					) extern
action VRSkPopupStatusField	( IGRlong *sts 					) extern
action VRSkGetCmpCode		( IGRlong *sts 					) extern
action VRSkActiveEmsPocket	( IGRlong *sts 					) extern
action VRGetReturnCode	        ( IGRlong *sts 					) extern
action VRPlaceCmp		( IGRlong *sts 					) extern
action VRSkUpdateNetWork	( IGRlong *sts 					) extern
action VRskrestart		( IGRlong *sts 					) extern
action VRSkGetCptInfo		( IGRlong *sts 					) extern
action VRSkInitCmpOrient	( IGRlong *sts 					) extern
action VRSkPartialInitInst	( IGRlong *sts 					) extern
action VRDeleteGraphics		( IGRlong *sts 					) extern
action VRSkSetCmpInstance	( IGRlong *sts 					) extern
