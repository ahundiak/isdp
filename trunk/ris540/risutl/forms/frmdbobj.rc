/* Do not alter this SPC information: $Revision: 1.1.54.1 $ */
/*
**	NAME:							frmdbobj.rc
**	AUTHORS:						Terry McIntyre
**	CREATION DATE:					11/90
**	ABSTRACT:
**		The code to process the table/view & index queries.
**	
**	REVISION HISTORY:
*/
 
/*
**	INCLUDES
*/
#include "risstjmp.h"
#include "forms.h"
exec sql include "rislimit.h";

/*
**	FUNCTION PROTOTYPES
*/
#define frmdbobj_rc
#include "comdebug.prt"
#include "comjmp.prt"
#include "comumsg.prt"
#include "frmerror.prt"
#include "frmdbobj.prt"
#include "ucosqlca.prt"
#include "ris.prt"
#include "sys.prt"

/*
**	DEFINES
*/
#define ERROR_CHECK \
if (SQLCODE != RIS_SUCCESS)	\
{	\
	FRM_DBG(("SQLCODE:%d\n", SQLCODE));	\
	LONGJMP(RISUTL_E_RIS_ERROR);	\
}

/*
**	VARIABLES
*/

/*
**	FUNCTIONS
*/

/******************************************************************************/

static int compare_dbms_objs(
	const void *a1,
	const void *a2)
{
	int sts;
	RISfrm_object **arg1 = (RISfrm_object **)a1;
	RISfrm_object **arg2 = (RISfrm_object **)a2;

	if ((sts = strcmp((*arg1)->name, (*arg2)->name)) != 0)
		return(sts);
	return((*arg1)->type - (*arg2)->type);
}

/******************************************************************************/

static void declare_cursors(
	char *schname,
	char *dbms_owner)
{
	exec sql begin declare section;
		char string[400];
	exec sql end declare section;

	FRM_DBG(("declare_cursors(schname:%s, dbms_owner)\n", STRING(schname),
		STRING(dbms_owner)));

/*
	sprintf(string,
		"select table_name from %s.ris5dbms_tables where dbms_owner = '%s'"
		"and table_name not in (select ext_table_name from ris5tables)",
		schname, dbms_owner);
*/
	sprintf(string,
		"select table_name from %s.ris5dbms_tables where dbms_owner = '%s'",
		schname, dbms_owner);

	FRM_DBG(("preparing statement <%s>\n", string));
	exec sql prepare dbms_table_stmt from :string;
	ERROR_CHECK;

	FRM_DBG(("declaring dbms_table_curs cursor\n"));
	exec sql declare dbms_table_curs cursor for dbms_table_stmt;
	ERROR_CHECK;

	sprintf(string,
		"select view_name from %s.ris5dbms_views where dbms_owner = '%s'",
		schname, dbms_owner);

	FRM_DBG(("preparing statement <%s>\n", string));
	exec sql prepare dbms_view_stmt from :string;
	ERROR_CHECK;

	FRM_DBG(("declaring dbms_view_curs cursor\n"));
	exec sql declare dbms_view_curs cursor for dbms_view_stmt;
	ERROR_CHECK;

	sprintf(string,
		"select index_name from %s.ris5dbms_indexes where dbms_owner = '%s'",
		schname, dbms_owner);

	FRM_DBG(("preparing statement <%s>\n", string));
	exec sql prepare dbms_index_stmt from :string;
	ERROR_CHECK;

	FRM_DBG(("declaring dbms_index_curs cursor\n"));
	exec sql declare dbms_index_curs cursor for dbms_index_stmt;
	ERROR_CHECK;
}

/******************************************************************************/

static void clear_cursors(
	int check_error)
{
	FRM_DBG(("clear dbms_table_curs cursor\n"));
	exec sql clear cursor dbms_table_curs;
	if (check_error)
	{
		ERROR_CHECK;
	}

	FRM_DBG(("clear dbms_view_curs cursor\n"));
	exec sql clear cursor dbms_view_curs;
	if (check_error)
	{
		ERROR_CHECK;
	}

	FRM_DBG(("clear dbms_index_curs cursor\n"));
	exec sql clear cursor dbms_index_curs;
	if (check_error)
	{
		ERROR_CHECK;
	}
}

/******************************************************************************/

extern int RISfrm_get_dbms_obj_list(
	char	*schname,
	char	*dbms_owner,
	void	(*update_msg_func)(),
	void	(*clear_msg_func)())
{
	int				i;
	int				sts;
	int				count;
	RISfrm_object	*dbms_obj, *list;
	RISfrm_object	**listp;

exec sql begin declare section;
	char			dbms_obj_name[RIS_MAX_ID_SIZE];
exec sql end declare section;


	FRM_DBG(("RISfrm_get_dbms_obj_list(schname:<%s> dbms_owner:<%s>)\n",
		STRING(schname), STRING(dbms_owner)));
	
	RISfrm_clear_dbms_obj_list();

	count = 0;
	list = NULL;
	listp = &list;

	if ((sts = SETJMP()) != 0)
	{
		int stack_sts;

		RESETJMP();

		if ((stack_sts = RISuco_push_risca_dbca()) != RIS_SUCCESS)
		{
			RISfrm_form_errhandle(stack_sts, 0);
			return RIS_forms_error.error;
		}

		RISfrm_clear_dbms_obj_list();

		clear_cursors(0);

		if (clear_msg_func)
		{
			clear_msg_func();
		}

		if ((stack_sts = RISuco_pop_risca_dbca()) != RIS_SUCCESS)
		{
			RISfrm_form_errhandle(stack_sts, 0);
			return RIS_forms_error.error;
		}
		RISfrm_form_errhandle(sts, 0);
		return RIS_forms_error.error;
	}

	if (update_msg_func)
	{
		update_msg_func(MSG(RISUTL_I_READING_DICTIONARY_TABLES));
	}

	declare_cursors(schname, dbms_owner);

	FRM_DBG(("opening dbms_table_curs\n"));
	exec sql open dbms_table_curs;
	ERROR_CHECK;

	FRM_DBG(("fetching\n"));
	while(1)
	{
		exec sql fetch dbms_table_curs into :dbms_obj_name;
		if (SQLCODE == END_OF_DATA)
		{
			FRM_DBG(("End of data\n"));
			break;
		}
		ERROR_CHECK;

		dbms_obj = (RISfrm_object *)malloc(sizeof(RISfrm_object));
		strcpy(dbms_obj->name, dbms_obj_name);
		dbms_obj->type = TABLE_CHAR;
		dbms_obj->next = NULL;
		*listp = dbms_obj;
		listp = &(dbms_obj->next);
		count++;
	}

	FRM_DBG(("closing dbms_table_curs\n"));
	exec sql close dbms_table_curs;
	ERROR_CHECK;

	FRM_DBG(("opening dbms_view_curs\n"));
	exec sql open dbms_view_curs;
	ERROR_CHECK;

	FRM_DBG(("fetching\n"));
	while(1)
	{
		exec sql fetch dbms_view_curs into :dbms_obj_name;
		if (SQLCODE == END_OF_DATA)
		{
			FRM_DBG(("End of data\n"));
			break;
		}
		ERROR_CHECK;

		dbms_obj = (RISfrm_object *)malloc(sizeof(RISfrm_object));
		strcpy(dbms_obj->name, dbms_obj_name);
		dbms_obj->type = VIEW_CHAR;
		dbms_obj->next = NULL;
		*listp = dbms_obj;
		listp = &(dbms_obj->next);
		count++;
	}

	FRM_DBG(("closing dbms_view_curs\n"));
	exec sql close dbms_view_curs;
	ERROR_CHECK;

	FRM_DBG(("opening dbms_index_curs\n"));
	exec sql open dbms_index_curs;
	ERROR_CHECK;

	FRM_DBG(("fetching\n"));
	while(1)
	{
		exec sql fetch dbms_index_curs into :dbms_obj_name;
		if (SQLCODE == END_OF_DATA)
		{
			FRM_DBG(("End of data\n"));
			break;
		}
		ERROR_CHECK;

		dbms_obj = (RISfrm_object *)malloc(sizeof(RISfrm_object));
		strcpy(dbms_obj->name, dbms_obj_name);
		dbms_obj->type = INDEX_CHAR;
		dbms_obj->next = NULL;
		*listp = dbms_obj;
		listp = &(dbms_obj->next);
		count++;
	}

	FRM_DBG(("closing dbms_index_curs\n"));
	exec sql close dbms_index_curs;
	ERROR_CHECK;

	clear_cursors(1);

	RESETJMP();

	RISfrm_dbms_objs_cnt = count;
	RISfrm_dbms_objs =
		(RISfrm_object **)malloc(RISfrm_dbms_objs_cnt*sizeof(RISfrm_object *));

	for (i = 0, dbms_obj = list;
		 i < RISfrm_dbms_objs_cnt && dbms_obj;
		 i++, dbms_obj = dbms_obj->next)
	{
		RISfrm_dbms_objs[i] = dbms_obj;
	}

	if (i < RISfrm_dbms_objs_cnt || dbms_obj)
	{
		LONGJMP(RISUTL_E_INTERNAL);
	}

	qsort((char *)RISfrm_dbms_objs, RISfrm_dbms_objs_cnt,
		sizeof(RISfrm_object *), compare_dbms_objs);

	strcpy(RISfrm_dbms_obj_owner, dbms_owner);
	strcpy(RISfrm_dbms_obj_schname, schname);
	RISfrm_dbms_obj_list_up_to_date = 1;

	if (clear_msg_func) clear_msg_func();

	CLEAR_ERROR;
	return RIS_SUCCESS;
}

/******************************************************************************/

extern void RISfrm_clear_dbms_obj_list()
{
	int	i;

	FRM_DBG(("RISfrm_clear_dbms_obj_list()\n"));

	if (RISfrm_dbms_objs)
	{
		for (i = 0; i < RISfrm_dbms_objs_cnt; i++)
			if (RISfrm_dbms_objs[i]) free(RISfrm_dbms_objs[i]);
		free(RISfrm_dbms_objs);
		RISfrm_dbms_objs = NULL;
	}
	RISfrm_dbms_objs_cnt = 0;
	RISfrm_dbms_obj_list_up_to_date = 0;
	RISfrm_dbms_obj_owner[0] = '\0';
}

/******************************************************************************/
