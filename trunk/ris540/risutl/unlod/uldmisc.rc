/* Do not alter this SPC information: $Revision: 1.2.9.1 $ */
/*
**	NAME:							uldmisc.rc
**	AUTHORS:						Jennifer Xia
**	CREATION DATE:					July 9, 1990
**	ABSTRACT:
**		It contains a number of miscellaneous functions.
**	
**	REVISION HISTORY:August 6th, 1991 Hitesh Patel
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>

#if defined(WIN32S) && defined(ULD_EXE)
#include <windows.h>
#include <windowsx.h>
#include "winport.h"
#include "winio.h"
#include "winhan.h"
#include "risutl.h"
#include "prog32s.h"
#endif 

#ifdef MM
#include "unlod.h"
#endif
#include "comisfn.prt"
exec sql include "unlod.h";

/*START_PRT_INCLUDE*/
#include "risapi.h"
/*STOP_PRT_INCLUDE*/

/*
**	VARIABLES
*/
#if !defined(WIN32)
 extern int errno;
 extern int sys_nerr;
 extern char *sys_errlist[];
#endif


/*
**	FUNCTIONS
*/

/*
**      FUNCTION PROTOTYPES
*/
#define uldmisc_rc
#include "sys.prt"
#include "comdebug.prt"
#include "comjmp.prt"
#include "comwrap.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "uldermsg.prt"
#include "uldmisc.prt"
#include "uldtime.prt"
#include "ucoerrbx.prt"
#include "ucoumsg.prt"

extern void RISuld_initialize_ris()
{
	int sts;
    char *language;

    if ((language = getenv("RIS_LANGUAGE")) != NULL)
    {
        ULD_DBG(("found RIS_LANGUAGE environment variable:<%s>\n", language));
    }
    else
    {
        ULD_DBG(("RIS_LANGUAGE environment variable not found\n"));
    }

    RISinitialize(language);
    if( SQLCODE != RIS_SUCCESS )
    {
        RISuld_fatal_err_handler(SQLCODE);
        TERMINATE_RISUNLOAD
    }

	if ((sts = SETJMP()) != 0)
	{
		RESETJMP();
        RISuld_fatal_err_handler(sts);
        TERMINATE_RISUNLOAD
	}

	RISuco_initialize_ums(INIT_UTL_UMS_FILE);

	RESETJMP();
}

extern void RISuld_blankstrip_mode(
	int blankstrip_mode)
{
	exec sql begin declare section;
		char 	blankstrip_stmt[STRING_MAX_LEN];
		char	*err_ptr;
	exec sql end declare section;

	ULD_DBG(("RISuld_blankstrip_mode(blankstrip_mode:%d)\n",blankstrip_mode));

	exec sql whenever sqlerror goto :BS_error;

	sprintf(blankstrip_stmt, "set mode blank strip %s",
		blankstrip_mode ? "on" : "off" );
		
	exec sql execute immediate :blankstrip_stmt;

	UNLOD_WARNING_CHECK(
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->ssqlwarnings);

	return;

BS_error:
	exec sql whenever sqlerror continue;

	if( RISuld_mode == EMBED )
	{
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sris_err_code 
			= risca->sqlcode;
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sdb_err_code 
			= dbca->sqlcode;
	}
	else
	{
		exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
		PUTS(err_ptr); 
#endif
	}

	TERMINATE_RISUNLOAD
	return;
}


/***
extern int RISuld_default_sch(
	char	*sch_name,
	char	*sch_pwd)
{
	exec sql begin declare section;
		char 	default_sch_stmt[STRING_MAX_LEN];  
		char	*err_ptr;
	exec sql end declare section;

	exec sql whenever sqlerror goto :DS_error;

	ULD_DBG(("RISuld_default_sch: <%s>\n",sch_name));

	if( strchr(sch_name,'.') )
	{
		if( RISuld_mode == EMBED )
		{
			RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->slnd_err_code = 
				RISUTL_E_INVALID_IDENTIFIER;
		}
		else
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_IDENTIFIER);
		}
		ULD_DBG(("1. RISuld_default_sch: end\n"));
		return(FAILURE);
	}
	strcpy(default_sch_stmt, "default schema ");
	strcpy(default_sch_stmt + 15, sch_name);
	if (sch_pwd[0] != '\0')
	{
		strcat(default_sch_stmt, ".");
		strcat(default_sch_stmt, sch_pwd);
	}
		
	exec sql execute immediate :default_sch_stmt;

	UNLOD_WARNING_CHECK(
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->ssqlwarnings);
	
	ULD_DBG(("2. RISuld_default_sch: end\n"));
	return(SUCCESS);

DS_error:
	exec sql whenever sqlerror continue;

	if( RISuld_mode == EMBED )
	{
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sris_err_code 
			= risca->sqlcode;
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sdb_err_code 
			= dbca->sqlcode;
	}
	else
	{
		exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
		PUTS(err_ptr); 
#endif
	}

	ULD_DBG(("3. RISuld_default_sch: end\n"));
	return(FAILURE);
}
***/


extern int RISuld_default_sch(
	char	*sch_name,
	char	*sch_pwd)
{
	char *err = NULL;
	int return_val;

	/* Execute the default schema statement */
	return_val = RISuld_default_sch_no_print(sch_name, sch_pwd, &err);

	if (return_val == SUCCESS)
	{
		ULD_DBG(("2. RISuld_default_sch: end\n"));
		return(SUCCESS);
	}

	/* If err is non-NULL, it was a RIS error. */
	if (err  &&  RISuld_mode != EMBED)
		/* Print the error string */
#if !defined(ULD_DLL)
		PUTS(err); 
#endif

	ULD_DBG(("3. RISuld_default_sch: end\n"));
	return(FAILURE);
}



/**==================================================
 ** FUNCTION: RISuld_default_sch_no_print
 ** DESCRIPTION: Executes a DEFAULT SCHEMA statement, but does not print the error message.
 ** RETURN: SUCCESS or FAILURE.  Examine error arguments for more info.
 ** ARGUMENTS:
 **		sch_name	I	Schema name.
 **		sch_pwd		I	Schema password.
 **		err			O	Pointer to RIS error string.  If this is returned NULL, no RIS errors
 **						occured.
 ** NOTES: If the error message in risca->sqlcode is RIS_E_NEED_DECLARE_SCHEMA, you must do a
 **		DECLARE SCHEMA statement and then try the DEFAULT SCHEMA statement again.
 ** AUTHOR(S): pmfitzge
 **==================================================*/
extern int RISuld_default_sch_no_print(
	char	*sch_name,
	char	*sch_pwd,
	char	**err)
{
	exec sql begin declare section;
		char 	default_sch_stmt[STRING_MAX_LEN];  
		char	*err_ptr;
	exec sql end declare section;

	exec sql whenever sqlerror goto :DS_error;

	/* If err pointer is NULL, no RIS errors occured */
	*err = NULL;

	ULD_DBG(("RISuld_default_sch_no_print: <%s>\n",sch_name));

	if( strchr(sch_name,'.') )
	{
		if( RISuld_mode == EMBED )
		{
			RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->slnd_err_code = 
				RISUTL_E_INVALID_IDENTIFIER;
		}
		else
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_IDENTIFIER);
		}
		ULD_DBG(("1. RISuld_default_sch: end\n"));
		return(FAILURE);
	}
	strcpy(default_sch_stmt, "default schema ");
	strcpy(default_sch_stmt + 15, sch_name);
	if (sch_pwd[0] != '\0')
	{
		strcat(default_sch_stmt, ".");
		strcat(default_sch_stmt, sch_pwd);
	}
		
	exec sql execute immediate :default_sch_stmt;

	UNLOD_WARNING_CHECK(
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->ssqlwarnings);
	
	ULD_DBG(("2. RISuld_default_sch_no_print: end\n"));
	return(SUCCESS);

DS_error:
	exec sql whenever sqlerror continue;

	exec sql report error into :err_ptr;
	*err = err_ptr;

	if( RISuld_mode == EMBED )
	{
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sris_err_code 
			= risca->sqlcode;
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sdb_err_code 
			= dbca->sqlcode;
	}

	ULD_DBG(("3. RISuld_default_sch_no_print: end\n"));
	return(FAILURE);
}



extern int RISuld_open_sch(
	char	*sch_name)
{
	exec sql begin declare section;
		char 	open_sch_stmt[STRING_MAX_LEN];  
		char	*err_ptr;
	exec sql end declare section;

	ULD_DBG(("RISuld_open_sch: <%s>\n",sch_name));

	exec sql whenever sqlerror goto :OS_error;

	strcpy(open_sch_stmt, "open schema ");
	strcpy(open_sch_stmt + 12, sch_name);
	
	exec sql execute immediate :open_sch_stmt;

	UNLOD_WARNING_CHECK(
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->ssqlwarnings);

	return(SUCCESS);

OS_error:
	exec sql whenever sqlerror continue;

	if( RISuld_mode == EMBED )
	{
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sris_err_code 
			= risca->sqlcode;
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sdb_err_code 
			= dbca->sqlcode;
	}
	else
	{
		exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
		PUTS(err_ptr); 
#endif
	}

	TERMINATE_RISUNLOAD
	return(FAILURE);
}
		

extern int RISuld_close_sch(
	char	*sch_name)
{
	exec sql begin declare section;
		char 	close_sch_stmt[STRING_MAX_LEN];  
		char	*err_ptr;
	exec sql end declare section;

	ULD_DBG(("RISuld_close_sch: <%s>\n",sch_name));

	exec sql whenever sqlerror goto :CS_error;
		
	strcpy(close_sch_stmt, "close schema ");
	strcpy(close_sch_stmt + 13, sch_name);
	
	exec sql execute immediate :close_sch_stmt;

	UNLOD_WARNING_CHECK(
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->ssqlwarnings);
	
	return(SUCCESS);

CS_error:
	exec sql whenever sqlerror continue;

	if( RISuld_mode == EMBED )
	{
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sris_err_code 
			= risca->sqlcode;
		RISuld_ptr_struct_ptr->bsnode_ptr->snode_ptr->sdb_err_code 
			= dbca->sqlcode;
	}
	else
	{
		exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
		PUTS(err_ptr); 
#endif
	}

	TERMINATE_RISUNLOAD
	/* make compiler :-) */
	return(FAILURE);
}
		

extern void RISuld_separate_sch_name_pwd(
	char	*sch_name_pwd,
	char	*sch_name,
	char	*sch_pwd)
{

	char	*period;

	if ((period = strchr(sch_name_pwd, '.')) != NULL)
	{
		*period = '\0';

		if ((period - sch_name_pwd) >= RIS_MAX_ID_SIZE)
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
			TERMINATE_RISUNLOAD
		}

		if (strlen(period + 1) >= RIS_MAX_ID_SIZE)
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
			TERMINATE_RISUNLOAD
		}

		strcpy(sch_name, sch_name_pwd);
		strcpy(sch_pwd, (period + 1));
		*period = '.';
	}
	else
	{
		if (strlen(sch_name_pwd) >= RIS_MAX_ID_SIZE)
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);
			TERMINATE_RISUNLOAD
		}

		strcpy(sch_name, sch_name_pwd);

		sch_pwd[0] = '\0';
	}
}

extern int RISuld_separate_gtor_rel(
	char	*sch_rel_name,
	char	*original_gtor,
	char	*rel_name)
{

	char	*period;

	ULD_DBG(("RISuld_separate_gtor_rel: sch_rel_name <%s> original_gtor <%s> rel_name <%s>\n",
						sch_rel_name, original_gtor, rel_name));

	if ((period = strchr(sch_rel_name, '.')) != NULL)
	{
		if ((period - sch_rel_name) >= RIS_MAX_ID_SIZE)
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);

			if( RISuld_mode == EMBED )
				*RISuld_general_err = RISUTL_E_INVALID_ID_SIZE;

			ULD_DBG(("1. RISuld_separate_gtor_rel: end"));
			return(FAILURE);
		}

		*period = '\0';

		if (strlen(period + 1) >= RIS_MAX_ID_SIZE)
		{
			*period = '.';

			RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);

			if( RISuld_mode == EMBED )
				*RISuld_general_err = RISUTL_E_INVALID_ID_SIZE;

			ULD_DBG(("2. RISuld_separate_gtor_rel: end"));
			return(FAILURE);
		}

		strcpy(original_gtor, sch_rel_name);
		strcpy(rel_name, (period + 1));
		*period = '.';
	}
	else
	{
		original_gtor[0] = '\0';

		if (strlen(sch_rel_name) >= RIS_MAX_ID_SIZE)
		{
			RISuld_unload_err_handler(RISUTL_E_INVALID_ID_SIZE);

			if( RISuld_mode == EMBED )
				*RISuld_general_err = RISUTL_E_INVALID_ID_SIZE;

			ULD_DBG(("3. RISuld_separate_gtor_rel: end"));
			return(FAILURE);
		}

		strcpy(rel_name, sch_rel_name);
	}

	ULD_DBG(("4. RISuld_separate_gtor_rel: end"));
	return(SUCCESS);
}


extern FILE *RISuld_interactive_open_file(
	char	*fname)
{
#if defined(WIN32)
	struct _stat status;
#else
	struct stat status;
#endif
	FILE 	*fp = (FILE *) NULL;

	switch( RISuld_filemode )
	{
		case 'w':
			fp = RIScom_fopen(fname,"w");
			if (fp == NULL)
			{
				RISuld_fatal_err_handler(RISUTL_E_CANT_OPEN_OUTPUT_FILE);
			}
			break;
		case 'a':
			fp = RIScom_fopen(fname,"a");
			if (fp == NULL)
			{
				RISuld_fatal_err_handler(RISUTL_E_CANT_OPEN_OUTPUT_FILE);
			}
			break;
		case 'e':
			if( RIScom_stat(fname, &status) == -1 )
			{
				fp = RIScom_fopen(fname,"w");
				if (fp == NULL)
				{
					RISuld_fatal_err_handler(RISUTL_E_CANT_OPEN_OUTPUT_FILE);
				}
			}
			else
			{
				RISuld_fatal_err_handler(RISUTL_E_OUTPUT_FILE_EXISTS);
			}
			break;
		default :
			RISuld_parse_err_handler(RISUTL_E_ILLEGAL_FILE_MODE);
			TERMINATE_RISUNLOAD
			
	}
	return(fp);
}


extern FILE *RISuld_batch_file_check(
		char	file_type,
		char	*fname)
{
	FILE 	*fp = (FILE *) NULL;
#if defined(WIN32)
	struct _stat status;
#else
	struct stat status;
#endif

	switch( RISuld_filemode )
	{
		case 'w':
			fp = RIScom_fopen(fname,"w");
			if( file_type == 'm' )
			{
				CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_OUTPUT_FILE)
			}
			else if( file_type == 'd')
			{
				CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_DATA_FILE)
			}
			break;
		case 'a':
			fp = RIScom_fopen(fname,"a");
			if( file_type == 'm' )
			{
				CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_OUTPUT_FILE)
			}
			else if( file_type == 'd')
			{
				CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_DATA_FILE)
			}
			break;
		case 'e':
			if( RIScom_stat(fname, &status) == -1 )
			{
				fp = RIScom_fopen(fname,"w");
				if( file_type == 'm' )
				{
					CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_OUTPUT_FILE)
				}
				else if( file_type == 'd')
				{
					CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_DATA_FILE)
				}
			}
			else
			{
				if( file_type == 'm' )
					RISuld_fatal_err_handler(RISUTL_E_OUTPUT_FILE_EXISTS);
				else if( file_type == 'd')
					RISuld_fatal_err_handler(RISUTL_E_DATA_FILE_EXISTS);
				TERMINATE_RISUNLOAD
			}
			break;
		default :
			RISuld_fatal_err_handler(RISUTL_E_ILLEGAL_FILE_MODE);
			TERMINATE_RISUNLOAD
			
	}
	return(fp);
}


extern FILE	*RISuld_batch_open_file(
	char	file_type,
	char	*token_buf)
{
	FILE	*fp = (FILE *) NULL;
	FILE	*RIScom_fopen();

	switch(file_type)
	{
		case 'm':
		case 'd':	
			fp = RISuld_batch_file_check(file_type, token_buf);
		break;
		case 's':
			fp = RIScom_fopen(token_buf, "r");
			CHK_OPEN_FILE_ERR(fp, RISUTL_E_CANT_OPEN_SPEC_FILE);
		break;
		default:
			RISuld_unload_err_handler(RISUTL_E_ILLEGAL_FILE_TYPE);
			TERMINATE_RISUNLOAD;
	}
	return(fp);
}

extern void RISuld_close_files()
{
	RIScom_fclose(RISuld_out_fp);
}

extern int RISuld_found_table(
	char *tab_name)
{
 	batch_tnode_type    *btnode_ptr;

    ULD_DBG(("RISuld_found_table: tab_name <%s>\n", tab_name));

    for(btnode_ptr = RISuld_ptr_struct_ptr->bthnode_ptr->btlink;
                btnode_ptr != NULL;
                        btnode_ptr = btnode_ptr->btlink)
    {
        if (strcmp(tab_name, btnode_ptr->tnode_ptr->tab_name) == 0)
        {
            ULD_DBG(("1. RISuld_found_table: end"));
            return(YES);
        }
    }

    ULD_DBG(("2. RISuld_found_table: end"));
    return(NO);
}

extern int RISuld_found_view(
	char *view_name)
{
 	batch_vnode_type    *bvnode_ptr;

    ULD_DBG(("RISuld_found_table: view_name <%s>\n", view_name));

    for(bvnode_ptr = RISuld_ptr_struct_ptr->bvhnode_ptr->bvlink;
                bvnode_ptr != NULL;
                        bvnode_ptr = bvnode_ptr->bvlink)
    {
        if (strcmp(view_name, bvnode_ptr->vnode_ptr->view_name) == 0)
        {
            ULD_DBG(("1. RISuld_found_view: end"));
            return(YES);
        }
    }

    ULD_DBG(("2. RISuld_found_view: end"));
    return(NO);
}

extern int RISuld_found_grant(
	char *original_gtor,
	char *tab_name)
{
 	batch_gnode_type    *bgnode_ptr;

    ULD_DBG(("RISuld_found_grant: original_gtor <%s> tab_name <%s>\n", 
			original_gtor,tab_name));

    for(bgnode_ptr = RISuld_ptr_struct_ptr->bghnode_ptr->bglink;
                bgnode_ptr != NULL;
                        bgnode_ptr = bgnode_ptr->bglink)
    {
        if ((strcmp(original_gtor, bgnode_ptr->gnode_ptr->original_gtor) == 0)
        &&	(strcmp(tab_name, bgnode_ptr->gnode_ptr->rel_name) == 0) )
        {
            ULD_DBG(("1. RISuld_found_grant: FOUND end"));
            return(YES);
        }
    }

    ULD_DBG(("2. RISuld_found_grant: NOT FOUND end"));
    return(NO);
}

extern grantee_s *RISuld_insert_gtee_in_list(
	grantee_s		*gtee_list_ptr,
	char			*gtee_name)
{
	grantee_s *prev = NULL;
	grantee_s *curr = NULL;

	ULD_DBG(("RISuld_insert_gtee_in_list: %s\n",gtee_name));

	prev = gtee_list_ptr;

	curr = (grantee_s *) calloc(1, sizeof(grantee_s));
	CHK_MEM_ALLOC_ERR(curr)
	strcpy(curr->gteename, gtee_name);
	curr->next = (grantee_s *) NULL;

	if( gtee_list_ptr == NULL)
	{
		gtee_list_ptr = curr;
	}
	else
	{
		gtee_list_ptr = curr;
		gtee_list_ptr->next = prev;
	}
	
	if (RISuld_debug)
	{
		for( prev = gtee_list_ptr; prev != NULL; prev = prev->next )
		{
			RIScom_output_debug("prev = %s\n",prev->gteename);
		}
		RIScom_output_debug("1. RISuld_insert_gtee_in_list: end\n");
	}
	return(gtee_list_ptr);
}


extern int RISuld_lookup_gtee_in_list(
	grantee_s	*gtee_list_ptr,
	char 		*gtee_name)
{
	grantee_s *curr;

	ULD_DBG(("RISuld_lookup_gtee_in_list: %s\n",gtee_name));

	for(curr = gtee_list_ptr; curr; curr = curr->next)
	{
		ULD_DBG(("against: %s\n",curr->gteename));
		if( strcmp(curr->gteename,gtee_name) == 0 )
		{
			ULD_DBG(("1. RISuld_lookup_gtee_in_list: end\n"));
			return 1;
		}
	}	
	ULD_DBG(("2. RISuld_lookup_gtee_in_list: end\n"));
	return 0;
}


extern void RISuld_free_gtee_list(
	grantee_s	*gtee_list_ptr)
{
	grantee_s *prev = NULL;
	grantee_s *curr = NULL;

	ULD_DBG(("RISuld_free_gtee_list: begin\n"));

	for( curr = gtee_list_ptr; curr != NULL; curr = prev )
	{
		prev = curr->next;
		/*
		**	calloced list
		*/
		free(curr);
	}	
	ULD_DBG(("1. RISuld_free_gtee_list: end\n"));
}



extern void RISuld_free_grantee_info_list(
	ris_grantee_info *risgrantee_ptr)
{
	ris_grantee_info *grantee_prev;
	ris_grantee_info *grantee_curr;

	ULD_DBG(("RISuld_free_grantee_info_list: begin"));
	for( grantee_curr = risgrantee_ptr; 
			grantee_curr != NULL; 
				grantee_curr = grantee_prev )
	{
		grantee_prev = grantee_curr->next;
		/*
		**	malloced list
		*/
		free(grantee_curr);
	}
	ULD_DBG(("RISuld_free_grantee_info_list: end"));
}

extern void RISuld_assign_nulls(
	char 	*name,
	int 	len)
{
	int	i;

	for (i = 0; i < len; i++)
		*name++ = '\0';
}


extern void RISuld_to_lower_case(
	char	*str)
{

	for(;*str != '\0';)
	{
		if (RIScom_isupper(*str))
		{
			*str = RIScom_tolower(*str);
		}
		str++;
	}
}


extern int RISuld_strcmp(
	char	*str1,
	char	*str2)
{

	int		i;
	char	chr1;
	char	chr2;

	for(i = 0; str1[i] != '\0'; i++)
	{
		if (RIScom_isupper(str1[i]))	
			chr1 = RIScom_tolower(str1[i]);	
		else
			chr1 = str1[i];	

		if (RIScom_isupper(str2[i]))	
			chr2 = RIScom_tolower(str2[i]);	
		else
			chr2 = str2[i];	

		if (chr1 != chr2) return(-1);
	}

	if (str1[i] == str2[i]) return(0);
	else return(-1);
}


extern void RISuld_strncpy(
	char	*to,
	char	*from,
	int		len1,
	int		len2)
{
	int	minlen;
	int	i; 

	if (len1 < len2) minlen = len1;
	else minlen = len2;	

	for (i = 0; (i < minlen) && (*(from + i) != '\0'); i++)
	{
		*(to + i) = *(from + i);
	}
	*(to + i) = '\0';
}



extern void RISuld_pri_batch_struct(
	int (*output_func)(const char *, ...))
{
	batch_snode_type	*bsnode_ptr;	
	batch_tnode_type	*btnode_ptr;	
	batch_inode_type	*binode_ptr;	
	batch_vnode_type	*bvnode_ptr;	
	batch_gnode_type	*bgnode_ptr;	

	output_func("RISuld_pri_batch_struct: begin\n");
	for (bsnode_ptr = RISuld_ptr_struct_ptr->bshnode_ptr;
				bsnode_ptr != NULL;
						bsnode_ptr = bsnode_ptr->bslink)
	{
		output_func("bsnode = 0x%x, snode = 0x%x\n", bsnode_ptr, bsnode_ptr->snode_ptr);

		output_func("schema = %s sch_pwd_ind = %d\n", bsnode_ptr->snode_ptr->sch_name, bsnode_ptr->snode_ptr->sch_pwd_ind);

		if (bsnode_ptr->bthlink)
		{
			output_func("\tbthnode = 0x%x\n", bsnode_ptr->bthlink);

			output_func("\ttab_select = <%c>\n", bsnode_ptr->bthlink->tab_select);
			output_func("\tdef_data_select = %d\n", bsnode_ptr->bthlink->def_data_select);
			output_func("\tdfile_select = %d\n", bsnode_ptr->bthlink->dfile_select);
			output_func("\tformat_select = %d\n", bsnode_ptr->bthlink->format_select);

			for (btnode_ptr = bsnode_ptr->bthlink->btlink;
						btnode_ptr != NULL;
								btnode_ptr = btnode_ptr->btlink)
			{
				output_func("\t\tbtnode = 0x%x, tnode = 0x%x, ", btnode_ptr, btnode_ptr->tnode_ptr);
				output_func("table = %s\n", btnode_ptr->tnode_ptr->tab_name);
				if( btnode_ptr->tnode_ptr->where_clause_ptr )
					output_func("\t\twhere:%s\n", btnode_ptr->tnode_ptr->where_clause_ptr);

			}

		}

		if (bsnode_ptr->bihlink)
		{
			output_func("\tbihnode = 0x%x\n", bsnode_ptr->bihlink);

			output_func("\tindx_select = <%c>\n", bsnode_ptr->bihlink->indx_select);

			for (binode_ptr = bsnode_ptr->bihlink->bilink;
						binode_ptr != NULL;
								binode_ptr = binode_ptr->bilink)
			{
				output_func("\t\tbinode = 0x%x, inode = 0x%x, ", binode_ptr, binode_ptr->inode_ptr);
				output_func("indx_tab = %s\n", binode_ptr->inode_ptr->indx_tab);
			}
		}

		if (bsnode_ptr->bvhlink)
		{
			output_func("\tbvhnode = 0x%x\n", bsnode_ptr->bvhlink);

			output_func("\tview_select = <%c>\n", bsnode_ptr->bvhlink->view_select);

			for (bvnode_ptr = bsnode_ptr->bvhlink->bvlink;
						bvnode_ptr != NULL;
								bvnode_ptr = bvnode_ptr->bvlink)
			{
				output_func("\t\tbvnode = 0x%x, vnode = 0x%x, ", bvnode_ptr, bvnode_ptr->vnode_ptr);
				output_func("view = %s\n", bvnode_ptr->vnode_ptr->view_name);
			}
		}

		if (bsnode_ptr->bghlink)
		{
			output_func("\tbghnode = 0x%x\n", bsnode_ptr->bghlink);

			output_func("\tgrant_select = <%c>\n", bsnode_ptr->bghlink->grant_select);

			for (bgnode_ptr = bsnode_ptr->bghlink->bglink;
						bgnode_ptr != NULL;
								bgnode_ptr = bgnode_ptr->bglink)
			{
				output_func("\t\tbgnode = 0x%x, gnode = 0x%x, ", bgnode_ptr, bgnode_ptr->gnode_ptr);
				output_func("\tgtor = %s", bgnode_ptr->gnode_ptr->original_gtor);
				output_func("\trel = %s\n", bgnode_ptr->gnode_ptr->rel_name);
			}
		}
	}
	output_func("RISuld_pri_batch_struct: end\n");
}

extern void RISuld_strip_newline(
	char *buffer)
{
	char *ptr;

	/*
	** Get a string and replace the newline character by null character
	*/
	if ((ptr = strchr(buffer,'\n')) != NULL)
	{
		*ptr = '\0';	
	}
}

extern void RISuld_display_error()
{
	exec sql begin declare section;
		char	*err_ptr;
	exec sql end declare section;
	
	exec sql report error into :err_ptr;
#if !defined(ULD_DLL)
	PUTS(err_ptr);
#endif
}


extern int * RISAPI RISXuld_get_RISuld_debug_addr()
{
	return &RISuld_debug;
}
