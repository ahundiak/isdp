/*
**	NAME:			upgtable.rc
**	AUTHORS:		Bhaskar R. Sayyaparaju
**	CREATION DATE:		3/94
**	ABSTRACT: 	
**		The functions that handle user-defined tables for the RIS upgrade 
**		utility.
**
**	REVISION HISTORY:
*/
 
/*
**	DEFINES
*/

/*
**	INCLUDES
*/
#ifdef UPGRADE_GLOBAL_DEFINE
#undef UPGRADE_GLOBAL_DEFINE
#endif

#ifdef MKMK_KLUDGE
#include "upgrade.h"
#endif

exec sql include "upgrade.h";
#ifdef WIN32
#include <windows.h>
#endif
#if defined(unix)
#include <sys/stat.h>
#endif
#include "ris_err.h"
#include "risupger.h"

/*
**	FUNCTION PROTOTYPES
*/
#define upgtable_rc
#include "sys.prt"
#if ! defined(sun) && ! defined(__hpux__)
# include "net_sys.prt"
#endif

#include "sysalloc.prt"
#include "comjmp.prt"
#include "comwrap.prt"
#include "comdebug.prt"
#include "comumsg.prt"
#include "ris.prt"
#include "upgmisc.prt"
#include "upgtable.prt"
#if defined (WIN32)
#include "cnvschfl.prt"
#endif
/*
**	VARIABLES
*/
int need_to_include = 0;

/*
**	FUNCTIONS
*/

/******************************************************************************/

extern void RISupg_extract_n_include_tables(
	char	*sch_name)
{
	objs_name_struct *objs_name_ptr = 0;
	int				 num_objs = 0;

	UPG_DBG(("RISupg_extract_n_include_tables: sch_name <%s>\n",sch_name));

	printf(MSG(RIS_I_UPG_EXTRACT_TABINFO1));
	num_objs = RISupg_get_objs_names(&objs_name_ptr,"ristables");

	risupg_cur_sch->tabunload=num_objs;
	if( objs_name_ptr )
		free(objs_name_ptr);
#if defined (WIN32)
        if (INTERRUPTED())
        {
                no_change_exit();
                CLEAR_INTERRUPT();
                LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
        }
#endif

	UPG_DBG(("1. RISupg_extract_n_include_tables: end # of tables %d\n",
					num_objs));
	return;
}

/******************************************************************************/

static int RISupg_get_objs_names(
	objs_name_struct	**objs_name_ptr,
	char				*ristab_name)
{
	objs_name_struct	*objs_list;
	int			objs_indx;

	exec sql begin declare section;
		int		num_objs;
		char	objs_name[RIS_MAX_ID_SIZE];
		char 	objs_type;
	exec sql end declare section;

	UPG_DBG(("RISupg_get_objs_names: objs_name_ptr 0x%x ristab_name <%s>\n",
			objs_name_ptr,ristab_name));

	/*
	**	user-defined objects (tables and views) are in ristables table 
	*/
	if( !strcmp(ristab_name,"ristables") )
	{
                /* had to change this non-cursored select to a cursored one
                   to get around a bug in which non-cursored select is not
                   freeing underlying cursor, making it so that this
                   table cannot be dropped in "drop schema" and causing
                   upgrade to fail.  Quick work-around to fix upgrade while
                   we continue to search out underlying problem for RDB *ddf*/


		exec sql declare cnt_cursor cursor for
			select 	count(distinct table_name)                      
			from	ristables
			where	table_name not like 'ris%%'
			and	table_type='T';

		exec sql open cnt_cursor;
		exec sql fetch cnt_cursor into :num_objs;
		exec sql close cnt_cursor;
		exec sql clear cursor cnt_cursor;

	}
	else
	{
        *objs_name_ptr = 0;
        UPG_DBG(("0. RISupg_get_objs_names: end\n"));
		return(0);
	}
	
    if( num_objs == 0 )
    {
        *objs_name_ptr = 0;
		/*
		**	Do not report error
		*/
		RISupg_write_objs_names(0,0);
        UPG_DBG(("1. RISupg_get_objs_names: end\n"));
        return(0);
    }

	if( (SQLCODE != RIS_SUCCESS) && (num_objs < 0) )
	{
        *objs_name_ptr = 0;
		RISupg_report_error(SQLCODE);
        UPG_DBG(("1. RISupg_get_objs_names: end\n"));
		LONGJMP(SQLCODE);
        return(0);
	}

	need_to_include = num_objs;
	objs_list = (objs_name_struct *) calloc (num_objs, sizeof(objs_name_struct));
	if( !objs_list )
	{
		fprintf(stderr,MSG(RIS_E_UPG_CANNOT_ALLOCATE_MEMORY));
		RISupg_report_error(RISupg_INTERNAL_ERROR);
        UPG_DBG(("3. RISupg_get_objs_names: end\n"));
		UPG_LONGJMP(RISupg_INTERNAL_ERROR);
		return(0);
	}

	exec sql whenever sqlerror goto :OBJS_error;

	if( !strcmp(ristab_name,"ristables") )
	{
		exec sql declare objs_cursor cursor for
			select 	distinct table_name,table_type
			from	ristables
			where	table_name not like 'ris%%'
			and 	table_type='T'
			order by table_name;
	}

	exec sql open objs_cursor;

	
	for (objs_indx = 0; objs_indx < num_objs; objs_indx++)
	{
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
		objs_name[0] = '\0';
		exec sql fetch objs_cursor into :objs_name,:objs_type;
		RISupg_to_lower_case(objs_name);
		strncpy(objs_list[objs_indx].objs_name, objs_name, strlen(objs_name));
		printf(MSG(RIS_I_UPG_EXTRACT_TABINFO),
				objs_list[objs_indx].objs_name);
		UPG_DBG(("TABLE : %s COUNT : %d\n",objs_list[objs_indx].objs_name,
					objs_indx));
		objs_list[objs_indx].tabtype = objs_type;
	}
	exec sql close objs_cursor;
	exec sql clear cursor objs_cursor;
	exec sql commit;

	*objs_name_ptr = objs_list;

	RISupg_write_objs_names(objs_list,num_objs);
	UPG_DBG(("4. RISupg_get_objs_names: end\n"));
	return(num_objs);

OBJS_error:
	exec sql whenever  sqlerror continue;
	RISupg_report_error(SQLCODE);
	exec sql close objs_cursor;
	exec sql clear cursor objs_cursor;
	exec sql commit;
	*objs_name_ptr = 0;
	UPG_DBG(("5. RISupg_get_objs_names: end with SQLCODE = 0x%x\n",SQLCODE));
#if defined (WIN32)
        if (INTERRUPTED())
        {
                no_change_exit();
                CLEAR_INTERRUPT();
                LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
        }
#endif
	LONGJMP(SQLCODE);
	return(0);
}

/******************************************************************************/

extern void RISupg_write_objs_names(
	objs_name_struct	*objs_list,
	int					num_objs)
{
	int objs_indx=0;
	int num_wrote=0;

	UPG_DBG(("RISupg_write_objs_names: objs_list <0x%x> num_objs<%d>\n",
				objs_list,num_objs));
	RISupg_fputs("BEGIN TABLE INFO\n",RISupg_table_fp);	
	for (objs_indx = 0; objs_indx < num_objs; objs_indx++)
	{
		UPG_DBG(("objs_list[%d] = %s\n", objs_indx,objs_list[objs_indx].objs_name));
		if(!objs_list[objs_indx].done)
		{
			fprintf(RISupg_table_fp,"%s\n",objs_list[objs_indx].objs_name);
			num_wrote++;
		}
	}
	RISupg_fputs("END TABLE INFO\n",RISupg_table_fp);
	if (!num_wrote)
		risupg_cur_sch->cre_tab = 1;
	UPG_DBG(("RISupg_write_objs_names: end objs_indx<%d>\n",
				objs_list,objs_indx));
	return;
}

/******************************************************************************/
static void RISupg_exec_include_table(
	char				*sch_name_pwd,
	char				*sch_name,
	objs_name_struct	*objs_name_curr)
{
    exec sql begin declare section;
		char	query[RIS_MAX_STMT_LEN];
    exec sql end declare section;

	UPG_DBG(("RISupg_exec_include_table(sch_name <%s> objs_name_curr 0x%x)\n", sch_name, objs_name_curr));

	if( objs_name_curr->tabtype == 'T' )
	{
		printf(MSG(RIS_I_UPG_INCLUDE_TABLE),objs_name_curr->objs_name);
		sprintf(query,
				"alter schema %s include table %s",
				sch_name_pwd,objs_name_curr->objs_name);
		UPG_DBG(("statement: %s\n",query));
	} 
	else if( objs_name_curr->tabtype == 'V' )
	{
		printf(MSG(RIS_I_UPG_INCLUDE_VIEW),objs_name_curr->objs_name);
		sprintf(query,
				"alter schema %s include view %s",
				sch_name_pwd,objs_name_curr->objs_name);
		UPG_DBG(("statement: %s\n",query));
	}
	else
	{
		return;
	}

	exec sql execute immediate :query;
	if( SQLCODE == RIS_E_OBJECT_INCLUDED )
	{
		if( objs_name_curr->tabtype == 'T' )
		{
			fprintf(stderr,MSG(RIS_I_UPG_WARN_TABLE_ALREADY_INCLUDED),
					objs_name_curr->objs_name);
/*
			if (risupg_cur_sch->tabunload > 0)
				risupg_cur_sch->tabunload--;
*/
			objs_name_curr->done = 1;
		}
		else
		{
			fprintf(stderr,MSG(RIS_I_UPG_WARN_VIEW_ALREADY_INCLUDED),
			objs_name_curr->objs_name);
		}
		UPG_DBG(("1. RISupg_exec_include_table: end\n"));
		return;
	}
	if( SQLCODE != RIS_SUCCESS )
	{
		if (RISupg_got_signal)
			LONGJMP(SQLCODE);
		RISupg_report_error(SQLCODE);
		if( objs_name_curr->tabtype == 'T' )
		{
			fprintf(stderr,MSG(RIS_E_UPG_WARN_TABLE_NOT_INCLUDED),
						objs_name_curr->objs_name);
		}
		else
		{
			fprintf(stderr,MSG(RIS_E_UPG_WARN_VIEW_NOT_INCLUDED),
			objs_name_curr->objs_name);
		}
		UPG_DBG(("2. RISupg_exec_include_table: end\n"));
		/*
		**	Ignore error and continue
		**	LONGJMP(SQLCODE);
		*/
		return;
	}
/*
	risupg_cur_sch->tabunload--;
*/
	objs_name_curr->done = 1;
/*
	risupg_cur_sch->cre_tab++;
*/
}

/******************************************************************************/

extern void RISupg_execute_table_info(
		char *sch_name_pwd,
		char *sch_name,
		char *tab_filename)
{
	objs_name_struct *objs_name_list=0;
	char buf[80];
	int num_objs;
	int count=0;
	int counter=0;
	int status=0;

	UPG_DBG(("RISupg_execute_table_info: schema name <%s>\n",sch_name));

			
	num_objs = risupg_cur_sch->tabunload;
	objs_name_list = calloc (num_objs, sizeof(objs_name_struct));
	printf(MSG(RIS_I_UPG_EXTRACT_TABINFO_FROM_DATAFIL));
	while (RIScom_fgets(buf,80,RISupg_table_fp) != NULL &&
			strncmp(buf,"BEGIN TABLE INFO",sizeof("BEGIN TABLE INFO")-1))
		UPG_DBG(("%s\n",buf));
	if (!strncmp(buf,"BEGIN TABLE INFO",sizeof("BEGIN TABLE INFO")-1))
	{
		while(1)
		{
#if defined (WIN32)
                	if (INTERRUPTED())
                	{
                        	no_change_exit();
                        	CLEAR_INTERRUPT();
                        	LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                	}
#endif
			if(RIScom_fgets(buf,80,RISupg_table_fp) == NULL)
			{
				printf(MSG(RIS_E_UPG_DATAFILE_CORRUPTED));
				LONGJMP(RISupg_DATAFILE_CORRUPTED);
			}
			UPG_DBG(("%s\n",buf));
			buf[strlen(buf)-1] = '\0';
			if (!strncmp(buf,"END TABLE INFO",sizeof("END TABLE INFO")-1))
				break;
			if (count > num_objs)
				printf(MSG(RIS_I_UPG_MORE_TABINFO));
			strcpy(objs_name_list[count].objs_name,buf);
			objs_name_list[count].tabtype = 'T';
			count++;
		}
	}
	else
	{
		printf(MSG(RIS_E_UPG_DATAFILE_CORRUPTED));
		LONGJMP(RISupg_DATAFILE_CORRUPTED);
	}
	status = SETJMP();
	if (status)
	{
		RIScom_fclose(RISupg_table_fp);
		RISupg_table_fp = RIScom_fopen(tab_filename,"w");
		if (!RISupg_table_fp)
			printf(MSG(RIS_E_UPG_OPEN_DUMPFILE_TO_WRITE));
		else
			RISupg_write_objs_names(objs_name_list,count);
		if( objs_name_list )
			free(objs_name_list);
		RESETJMP();
		LONGJMP(status);
	}
	for (counter=0;counter < count;counter++)
	{
#if defined (WIN32)
                if (INTERRUPTED())
                {
                        no_change_exit();
                        CLEAR_INTERRUPT();
                        LONGJMP(RIS_E_UPG_GOT_INTERRUPT);
                }
#endif
		RISupg_exec_include_table(sch_name_pwd,sch_name,objs_name_list+counter);
		UPG_DBG(("including table <%s>\n",objs_name_list[counter].objs_name));
	}
	RESETJMP();
	if (count == 0)
	{
		printf(MSG(RIS_I_UPG_TABLES_NOT_FOUND));
		risupg_cur_sch->cre_tab = 1;
	}
	else
	{
		RIScom_fclose(RISupg_table_fp);
		RISupg_table_fp = RIScom_fopen(tab_filename,"w");
		if (!RISupg_table_fp)
			printf(MSG(RIS_E_UPG_OPEN_DUMPFILE_TO_WRITE));
		else
			RISupg_write_objs_names(objs_name_list,count);
	}
	if( objs_name_list )
		free(objs_name_list);
	UPG_DBG(("RISupg_execute_table_info: end\n"));
}
	
/******************************************************************************/



/*
extern void RISupg_write_table_info(
		objs_name_struct *objs_name_ptr)
{
		int num_objs;

	UPG_DBG(("RISupg_write_table_info: begin\n"));
	RISupg_fputs("BEGIN TABLE INFO");	
	for(num_objs=0;num_objs < need_to_include;num_objs++)	
		fprintf(RISupg_schema_fp,"%s %c\n",objs_name_ptr[num_objs].objs_name,
				objs_name_ptr[num_objs].tabtype);
	RISupg_fputs("END TABLE INFO");	
	UPG_DBG(("RISupg_write_table_info: end\n"));
}
*/
