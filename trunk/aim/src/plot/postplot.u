/*
* postplot
*
* File:	/pma/postplot/postplot.u
*
* Description:
*
* Dependencies:
*
* Revision History:
*	$Log: postplot.u,v $
*	Revision 1.3  2002/04/08 18:38:28  tlstalli
*	Disabled Execute Button
*	
*	Revision 1.2  2001/10/29 19:46:43  tlstalli
*	Fixed TR 5523
*	
*	Revision 1.1.1.1  2001/06/01 20:06:28  tlstalli
*	Creating aim module
*	
*
* History:
*	MM/DD/YY	AUTHOR		DESCRIPTION
*
***************************************************************************/

#include "VDppl.h"
#include "VDobj.h"
#include "exdef.h"
#include "exfi.h"
#include "exmacros.h"
#include "refdef.h"
#include "refmacros.h"
#include "vadbgmacros.h"

/* Includes for the delete_local_file function */
#include "MEMerrordef.h"
#include "NFMerrordef.h"
#include "MEMstruct.h" 

#include "ACrg_collect.h"

#include "exdef.h"
#include "exmacros.h"
#include "EXproduct.h"

#include "DItypedef.h"
#include "DIdef.h"
#include "DIglob.h"
#include "DIprims.h"

/* Plot include files */
#include "plotmacros.h"
#include "pidef.h"
#include "plotcmd.h" 
#include "plotmsg.h"
#include "pltmessage.h"

#include "dpdef.h"
#include "dp.h"
#include "dpmacros.h"

#include "igetypedef.h"
#include "igrtypedef.h"
#include "igr.h"

#include "msdef.h"
#include "msmacros.h"

#include "lc.h"
#include "comiscmac.h"

#include "grgs.h"
#include "gr.h"
#include "grmacros.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "grgsmacros.h"
#include "grdpb.h"

#include "transerr.h"
#include "transdef.h"

#include "PDMStoolspro.h"
#include "PDUerror.h"
#include "PDUdesignpro.h"
#include "PDMmacros.h"

/* includes for form processing */
#include "FI.h"

/* include for Tree Manager Stuff */
#include "VDtypedef.h"
#include "VDobj.h"	 
#include "VDct1.h"
#include "VDct1Plot.h"
//#include "VDct1Cmd.h"

/* defines for PLTDrwData.frm forms gadgets */
#define PLTDrwDataEXECUTE 	13
#define	PLTDrwDataEXIT		12 
/*#define PLTDrwDataTOGGLE	14*/
#define PLTDrwDataTYPE		14
#define PLTDrwDataDRWNUM	22
#define PLTDrwDataREV		23
#define PLTDrwDataDRWTITLE	24
/*
#define PLTDrwDataABBNAME	25
*/
#define PLTDrwDataAUTHFOR	25
#define PLTDrwDataDRWDATE	26
#define PLTDrwDataNAVSEANUM	27
#define PLTDrwDataTEAM		28
#define PLTDrwDataPOSTEDDATE 31
#define PLTDrwDataCAGECODE	32
#define PLTDrwDataRUN		40
#define PLTDrwDataPDUCAT	41
#define PLTDrwDataPDUPRTNUM	42
#define PLTDrwDataPDUREV	43	 
#define PLTDrwDataMSGFLD	10

/* defines for PLTShtProc.frm form gadgets */
#define  PLTShtProcADDSHEET		50
#define  PLTShtProcSELECTALL	51
#define	 PLTShtProcPOST			52 
#define	 PLTShtProcEXIT			53
#define	 PLTShtProcMSGFLD		30

/* TABLE GADGETS */
#define PLTShtProc_TBL	55
#define PLTShtProc_C_SHTNUM	0
#define PLTShtProc_C_NAME	1
#define PLTShtProc_C_DESC	2
#define PLTShtProc_C_STATUS	3
#define PLTShtProc_C_DATE	4	 

/* defines for PLTAddSheet.frm form gadgets */
#define	 PLTAddSheetMSGFLD		54
#define	 PLTAddSheetEXIT		60	
#define	 PLTAddSheetEXECUTE		56
#define	 PLTAddSheetSHTNUM		57
#define	 PLTAddSheetSHTDESC		58
#define	 PLTAddSheetSHTNAME		59

/* added for Plot Revision -TLS */
/* defines for PLTRevQA.frm form gadgets */
#define PLTRevQAEXIT		65
#define PLTRevQAMESSAGET	61
#define PLTRevQAMESSAGEB	62
#define PLTRevQAYES			63
#define PLTRevQANO			64

								  
/* defines for form names */
#define		PLTDRAWDATAFRM		"PLTDrwData.frm"	/* Drawing Data form name */
#define		PLTSHEETDATAFRM		"PLTShtProc.frm"	/* Drawing Sheet form name */
#define		PLTADDSHEETFRM		"PLTAddSheet.frm"	/* Drawing Sheet form name */
/* added for Plot Revision -TLS */
#define		PLTREVQAFRM			"PLTRevQA.frm"		/* Drawing Revision QA form name */


#define		PLTDRAWDATAFRMLABEL		1232
#define		PLTSHEETDATAFRMLABEL	1233
#define		PLTADDSHEETFRMLABEL		1234

/* added for Plot Revision -TLS */
#define		PLTREVQAFRMLABEL		1235

#define		cmdtitle	"REVISION?"	   /* added for Plot Revision -TLS */


/* defines for Postman */
#define CLIX_CONNECT    -1
#define CLIX_DISCONNECT -2
#define SIZE 4096
#define SM_SIZE 128

#define PME     0
#define SIR     1

#define SIR_GLOBAL_DIR          ":IGENOD:SIRGlobal"
#define SIR_REQ_DATA            ":SRReqData"
/* #define SIR_MODCX_ID            "Model Context Id" */
#define SIR_CNTX_ID              "Context Id"

/* constants for AIM variable sizes */
#define OBID_SZ					24
#define ABB_NAME_SZ				5
#define DRAW_NUM_SZ				17
#define	AIM_REVSION				15	
#define DRAW_REV_SZ				15
#define DRAW_TITLE_SZ			80
#define DRAW_DATE_SZ			24
#define NAVSEA_DRAW_NUMBER_SZ	40
#define CAGECODE_SZ				10
#define TEAM_SZ					80
#define	POST_DATE_SZ			12
#define CI_SZ				60	


/* Posting command codes */
#define VDP_IS_CTX_CHECKED_OUT 30
#define VDP_IS_CTX_IN_VAULT 31
#define VDP_REG_PLOT_FILES 32
#define VDP_DOES_DRWDOC_EXIST 35
#define VDP_CHECK_OUT_IN_DATAITEM 36
#define VDP_GET_LATEST_DRAW_DOC_REV 37
#define VDP_REVISE_DRAW_DOC 38


/* External function for the PME process */
extern  int     POSTMAN_REQUEST_ON_CLIX();

/* Externals for the delete_local_file function ONLY */
extern  	MEMbuild_array();
extern		MEMclose();
extern		MEMwrite();
extern		MEMprint_buffer();

/* AIM/VDS functions */
extern  int	IsPmeEnabled();
extern	int	VDgetVdCollId();
extern  int	WhichAim();
extern 	int	VDgetDiagCtlPar();
extern 		VDPGetAimName();
extern 		VDPGetAimInfo();

/* TLS TR 5523 */
extern int	PDMReadHullApp();

/* GRNUC functions */
extern          GRget_properties();
extern  int     GRget_window_range();
extern  int 	GRdpb_get();
extern	int		COplot_get_window_range();
extern	int		COplot_get_fence_range();
extern	int		COget_fence_range();
extern	int		COcreate_plotfile();
extern   		GRgsget_fence();
extern          GRgsmgr_fun();

/*PDM/PDU funtions */
extern	void	PDUsetup_buffer();
extern	int		PDUget_buffer_col();
extern	int		PDUformat_buffer();
extern 	int		PDUadd_buffer_string();
extern			PDUfill_in_string();
extern			PDUdebug_on();
extern			PDUdebug_off();
extern  int		PDMi_find_cofilename();
extern	int		PDMGetPartInfoGivenFileName();


extern  int		SQLquery();

/* externals for the others functions */
extern	void	*realloc();
extern			printf();
extern			sprintf();
extern			snprintf();
extern  FILE	*fopen();
extern			fprintf();
extern  int		atoi();
extern	int		itoa();
extern  int 	strncmp();
extern  int		stat();
extern  int		system();
extern	char	*strcpy();
extern 	int 	change_mode;
extern	int		islower();
extern  int		_toupper();
extern  int		_strdup();

/* the posting commands */
extern	int		VDP_send_post_cmd();
extern	int		VDP_send_verify_cmd();
extern	int		VDP_send_ctx_verify_cmd();
extern	int		VDP_send_lpddoc_verify_cmd();
extern	int		VDP_copy_cmd();
extern	int		VDP_remove_cmd();
extern	int		VDP_connect_status();
extern	int		VDP_send_post_plot_cmd();
extern  int		VDP_send_file_check_out_in();
extern	int		VDP_get_latest_doc_rev_cmd();
extern  int		VDP_revise_doc_cmd();

extern	int		PDM_debug_on ;
extern  double  difftime ();
extern  long    *time (); 
extern			strftime (); 
extern char		*getlogin ();
extern			gethostname ();
extern struct	tm *localtime ();

//extern  int     EXR_getProdInfo();

/* externs for forms */
extern int		FI_append_symbol_path ();
extern int		FI_append_form_path ();
extern			FIf_new ();
extern FIf_set_cmd_oid_os ();
extern FIf_delete ();
extern FIf_display ();
extern FIf_erase ();
extern FIfld_set_text ();
extern FIfld_get_num_rows ();
extern FIfld_get_value ();
extern FIfld_set_value ();
extern FIfld_get_select ();
extern FIg_disable ();
extern FIg_enable ();
extern FIg_erase ();
extern FIfld_set_list_num_rows ();
extern FIg_reset ();
extern FIfld_get_list_text ();
extern FIfld_set_list_text ();
extern FIfld_get_text ();
extern FIg_get_value ();
extern FIg_get_text ();
extern FIfld_set_select ();
extern FIfld_get_active_row ();
extern FIg_get_state ();
extern FIg_set_text ();
extern FIfld_set_default_text ();
extern FIfld_get_list_num_rows ();
extern FIfld_get_list_select ();
extern FIg_display ();
extern FIfld_delete_rows();
extern FIfld_set_list_scroll();
extern ci_notification ();
extern FIfld_insert_blank_row();
extern FIfld_get_text_length();
extern FIg_set_state_off();

extern VDct1GetNodeRange();

extern EX_getpath();
extern EX_findmod();
extern EX_get_oid_nodname();
extern calloc();

extern struct EX_prod_def  *EX_product_list;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
extern GRclassid  OPP_GRgraphics_class_id;

extern            COcreate_plotfile();
extern            EX_filename1();
extern            GRgs_rp_action();
extern            GRbuild_prism_in_wnd();
extern            GRprism_locate();
extern            GRgs_fun();
extern char       *strrchr();
extern void       BSalloccv(), BSlininter();
extern IGRboolean BSfreecv ();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* definition for the structure of reference file */
struct PLT_reffile{
        IGRchar         ref_name[80];
        IGRulong        properties;
        int             display;
        GRspacenum      osnum;
        struct GRid     ctx_id;
        struct GRmd_env md_env;
};





/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                      Global Variables                              */
/*          (Needed by macro : plot$create_plotfile())                */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
char				*gPlotfile;
double				gRange[12];
struct	GRid		WIN_OBJ;
struct	GRmd_env	aimMOD_ENV;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                      Global Variables                              */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
char	*p_prism;
int		prism_type, right_prism;

struct	GRid		GS_ID, SV_ID;
struct	IGRcv_prism	*p_cvprism;
struct	IGRrt_prism	*p_rtprism;

struct	GRvg_construct	aimcst;
struct	IGRbsp_curve	*bsp_crv;
struct	IGRdisplay	aimdis;

struct	GRlc_classes	classinfo;
struct	OM_sd_classlist	locate_rtree_thing, locate_eligible_thing;

OMuword	rtree_classids[1];
OMuword	eligible_classids[1];

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/*
* Global variables in files.
*/

struct	LPD_s_DocInfo 
{

char		OBID[24];
char		FileType[12];
char		DrwNum[DRAW_NUM_SZ];
char		AimRev[AIM_REVSION];
char		PrevRev[AIM_REVSION];
char		DrwTitle[DRAW_TITLE_SZ];
char		AbbName[ABB_NAME_SZ];
char		AuthorizeFor[CI_SZ];
char		DrwDate[DRAW_DATE_SZ];
char		NavSeaDrwNum[NAVSEA_DRAW_NUMBER_SZ];
char		CageCode[CAGECODE_SZ];
char		Team[TEAM_SZ];
char		PostedDate[POST_DATE_SZ];


};
typedef struct  LPD_s_DocInfo   LPD_DocInfo;

LPD_DocInfo		LPD_Info;

struct	LPD_s_SheetInfo 
{

char		ShtNum[30];
char		ShtName[50];
char		ShtDesc[200];
char		Status[15];
char		Date[15];
char		ShtWindow[20];
GRrange		Range;
struct GRid window;
IGRdouble	range1[12];
struct		IGRcv_prism 	*cvprism;

};
typedef struct  LPD_s_SheetInfo   LPD_SheetInfo;

LPD_SheetInfo	LPD_ShtInfo[120];

int LPD_Sht_Index;

struct	EX_s_FileInfo 
{

char		filename[SM_SIZE];
char		plotfile[SM_SIZE];
char		server[30];
char		catalog[40];
char		partno[40];
char		revision[20];
char		ctxid[30];
int			filetype;
long		start_time;

};
typedef struct  EX_s_FileInfo   EX_FileInfo;

EX_FileInfo		E_FileInfo;
char			*errPDM ;
FILE			*ptr;
FILE			*plotptr;

/* global variables for forms */
IGRint		LPD_DOC_EXIST;

IGRint		form_PltDrawData_exists;
IGRint		form_PltDrawData_displayed;

IGRint		form_PltSheetProc_exists;
IGRint		form_PltSheetProc_displayed;

IGRint		form_PltAddSheet_exists;
IGRint		form_PltAddSheet_displayed;

/* added for Plot Revision -TLS */
IGRint		form_PltRevQA_exists;
IGRint		form_PltRevQA_displayed;

Form		gPltDrawDataFrmPtr ;
Form		gPltSheetProcFrmPtr ;
Form		gPltAddSheetFrmPtr ;
Form		gPltRevQAFrmPtr ; /* added for Plot Revision -TLS */

/* added for Plot Revision -TLS */
IGRint		gWhat_To_Do;
IGRchar		gMsg_Str[ 128 ];
IGRint		gYres, gNres;	/* keep track of yes and no responses */


struct		CIform_st form_st;
struct		GRid FORM_ID ;

struct {
  int response;
  int *data;
} e;

/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/* Generic Functions */
/**************************************************************************/

/*----------------------------------------------------------------------------*/
int PLT_getProdInfo(	run_name, logo, conf_path )
IGRchar     *run_name;
IGRchar     *logo;
IGRchar     *conf_path;
{

	struct EX_prod_def	*prodDef;
	IGRchar			config_path[512];
	IGRint			name_found;
	IGRint			prod_found;
	IGRint			i;
	IGRlong			sts;
	IGRchar			name[512];

	name_found = FALSE;
	prod_found = FALSE;
	sts = OM_S_SUCCESS ;

	fprintf(ptr,"\nPLT_getProdInfo: \n");

	if( ( run_name == NULL ) && ( logo == NULL ) ){
		__DBGpr_com(" Invalid Arguments" );
		return OM_E_INVARG ;
	}

	if( conf_path != NULL ){ *conf_path = '\0';  }
 
	prodDef    =  EX_product_list;

	if( run_name )	__DBGpr_str(" Run_Name ", run_name );
	if( logo     )	__DBGpr_str(" LOGO     ", logo );
													

	while( prodDef ){
	  __DBGpr_str("   RUN_NAME ",  prodDef->run_name);
	  __DBGpr_str("   LOGO_PTR ",  prodDef->logo);


	  if(strcmp(prodDef->run_name, run_name) == 0) 
	  {

	    name_found = TRUE;

	    strcpy( config_path , prodDef->config_path);
            break;

	  }
	  
	  prodDef = prodDef->next;

	}


	if ( !name_found ) return OM_E_NOTIMPL ;

	__DBGpr_str( "Checking path", config_path );

	i = 0;
	sts = OM_S_SUCCESS;
	while ( sts ){

	  sts = ex$get_path( index = i , path = name, len = sizeof(name) );

	  __DBGpr_int ( "Path no", i );
	  __DBGpr_str ( "Config path", name );

	  if( !strcmp( name, config_path )){

	    __DBGpr_com("FOUND PRODUCT");
	    prod_found = TRUE;
	    break;
	  }
	  i = i + 1; 
	}

	if( prod_found ){
	  if ( conf_path != NULL ){
		strcpy ( conf_path, config_path );
		__DBGpr_str(" CONFIG ", conf_path );
	  }
	  return OM_S_SUCCESS ;
	}
	else{
	  return OM_E_NOTIMPL ;
	}


}
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/* Forms functions */

/*****************************************************
* form_init:
*	- initializes the form
*
*****************************************************/

int form_init ( product_path )
IGRchar		*product_path;
{
IGRchar			form_path[256];
IGRint			pstatus;
IGRint			sts ;
int				status;

status        	= OM_S_SUCCESS;

  fprintf(ptr,"\nform_init: \n");
  
  if( form_PltDrawData_exists == TRUE ) return;

  

   /***  Tell I/Forms where to find our form path ************************/
  sprintf (form_path, "%s%s", product_path, "/config/english/forms"); 
  FI_append_form_path ( form_path );
  
  /*
   * the initialization of the form, which includes setting linking the form
   * to the command object; Get the form input and display the found
   * information in the form.
   */
 
  pstatus = FIf_new(	PLTDRAWDATAFRMLABEL,		
  						PLTDRAWDATAFRM,
  						ci_notification,
  						&gPltDrawDataFrmPtr ) ;
  			
  if ( (pstatus != FI_SUCCESS) || ( gPltDrawDataFrmPtr == NULL) )
  {
		UI_status("FATAL: Cannot initialize the form");
		fprintf(ptr,"\tFATAL: Cannot initialize the form.\n");
		status = OM_E_ERROR;
		goto quit;
  }

  form_PltDrawData_exists = TRUE;

  /****************************************************
   * MY_ID and OM_Gw_current_OS are symbolic constants 
   * that are defined in the "ciminimum.h" include file. 
   ****************************************************/

  pstatus = FIf_set_cmd_oid_os ( gPltDrawDataFrmPtr , MY_ID , OM_Gw_current_OS ) ;
  if (pstatus != FI_SUCCESS)
  {		
		UI_status("FATAL: Cannot link to the I/Forms system.");
		fprintf(ptr,"\tFATAL: Cannot link to the I/Forms system.\n");
        
		/****************************************************
		* The form has been loaded into memory at this point.  
		* we need to delete it from memory at this point.  
		*****************************************************/

		FIf_delete ( gPltDrawDataFrmPtr );
		form_PltDrawData_exists = FALSE;
		form_PltDrawData_displayed = FALSE;
		status = OM_E_ERROR;
		goto quit;
  }

  form_PltDrawData_exists = TRUE;
  
quit:  
  
  return status ;
}

/*****************************************************
* form_disp:
*	- displays the form
*
*****************************************************/

int form_disp ( )
{
IGRint		pstatus;
int			status ;

status		= OM_S_SUCCESS ;

  fprintf(ptr,"\nform_disp: \n");
  
  /*
   * display the form
   */

  if( form_PltDrawData_exists == TRUE )
  {
    
		pstatus = FIf_display ( gPltDrawDataFrmPtr ) ;
		if( pstatus != FI_SUCCESS )
		{

			UI_status("FATAL: Cannot display the form");
			fprintf(ptr,"\tFATAL: Cannot display the form.\n");
			
			FIf_delete ( gPltDrawDataFrmPtr ) ;
			form_PltDrawData_exists = FALSE;
			form_PltDrawData_displayed = FALSE;
			
			status = OM_E_ERROR;
			goto quit;
		}
		/*
		 * fill in some of the fields
		 */
   
		/* set information on the form */
		FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataPDUCAT, 0 , 0 , E_FileInfo.catalog, FALSE );
		FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataPDUPRTNUM, 0 , 0 , E_FileInfo.partno, FALSE );
		FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataPDUREV, 0 , 0 , E_FileInfo.revision, FALSE );
	

		/* disable some fields on the form */	
		/*FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataPDUCAT );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataPDUPRTNUM );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataPDUREV );*/

		/*FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataDRWTITLE );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataAUTHFOR );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataDRWDATE );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataNAVSEANUM );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataTEAM );
		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataPOSTEDDATE );*/

		FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );

		form_PltDrawData_displayed = TRUE;  
		status = OM_S_SUCCESS;
	
  } 
  else 
  {
		#ifdef DEBUG
		printf("form does not exist\n");
		#endif
    
		UI_status("FATAL: Form not found");
		fprintf(ptr,"\tFATAL: Form not found.\n");
		status = OM_E_ERROR;
  }
  
quit:  
  
  return status;
}

/************************************************************************
   Function get_input
	Initializes default values, calls up the form and retrieves 
	information from the form.
*************************************************************************/

get_input ( inprompt )
IGRchar	inprompt[50];
{
//IGRint	msg , j , numrows , sel , pos ;
//IGRdouble	dblId, value;
//struct GRid SelObj;

    //message( cmdtitle );
    prompt( inprompt );

    /* Process the form gadgets */

    while (1)   /* loop until user cancels the form. */
    {
      /*** suspend the command file and wait for the form.   ***/

      ci$get (prompt = prompt, response = &e);
    }
} 
/******* End of get_input ********/

/*****************************************************
* PLTsht_form_init:
*	- initializes the Sheet Processing form
*
*****************************************************/

long PLTsht_form_init()
{
int		fstatus;
int		status1;
long	pstatus;
int		status;

status  = OM_S_SUCCESS;

	__DBGpr_com ("PLTsht_form_init:");

	fprintf(ptr,"\nPLTsht_form_init: \n");

	/*
	 * the initialization of the form, which includes setting/linking the form
	 * to the command object; Get the form input and display the found
	 * information in the form.
	 */
 
	/*if( form_PltSheetProc_exists == TRUE ) return;*/

	__DBGpr_com ("PLTsht_form_init: creating the form.");
	fstatus = FIf_new (	PLTSHEETDATAFRMLABEL,
						PLTSHEETDATAFRM,
						ci_notification,
						&gPltSheetProcFrmPtr);

	if ( (fstatus != FI_SUCCESS) || (gPltSheetProcFrmPtr == NULL) )
	{
		UI_status("FATAL: Cannot initialize sheet form");
		fprintf(ptr,"\tFATAL: Cannot initialize sheet form.\n");
		status = OM_E_ERROR;
		goto quit;
	}

	
	form_PltSheetProc_exists = TRUE;

	/****************************************************
	 * MY_ID and OM_Gw_current_OS are symbolic constants 
	 * that are defined in the "ciminimum.h" include file. 
     ****************************************************/

	fstatus = FIf_set_cmd_oid_os (gPltSheetProcFrmPtr, MY_ID,
                                OM_Gw_current_OS);
	if (fstatus != FI_SUCCESS)
	{
		UI_status("FATAL: Cannot link to the I/Forms system.");
		fprintf(ptr,"\tFATAL: Cannot link to the I/Forms system.\n");
        
		/****************************************************
		* The form has been loaded into memory at this point.  
		* we need to delete it from memory at this point.  
		*****************************************************/

		form_PltSheetProc_exists = FALSE;
		FIf_delete (gPltSheetProcFrmPtr);
		form_PltSheetProc_displayed = FALSE;
		status = OM_E_ERROR;
		goto quit;
   }

   form_PltSheetProc_exists = TRUE;

 quit:  
  
  return status ;
}

/*****************************************************
* shtform_disp:
*	- displays the form
*
*****************************************************/

int shtform_disp ( )
{
IGRint		pstatus;
int			status ;
int			num_rows;
int			i;

TVDctBaseInfo	baseInfo;
TVDfld			fld;

IGRint			found, match;
IGRint			Sht_Index;

TGRid			mgrID;
TGRid			setID;
TGRid			treeID;
TGRid			sheetID;

GRrange			range;

IGRchar			sCage[5];
IGRchar			sLPDRev[20]; /* [12] */
IGRchar			sLPDNum[20]; /* [17] */

status			= OM_S_SUCCESS ;
found			= FALSE;
match			= FALSE;

mgrID.objid		= NULL_OBJID;
setID.objid		= NULL_OBJID;
treeID.objid	= NULL_OBJID;


num_rows		= 0;
Sht_Index		= 0;

	__DBGpr_com ("shtform_disp:");
	fprintf(ptr,"\nshtform_disp: \n");
  
	/*
	 * set the gadgets and display the sheet processing form
	 */

	if( form_PltSheetProc_exists == TRUE )
	{

		/*
		 * display the form
		 */

		pstatus = FIf_display ( gPltSheetProcFrmPtr ) ;
		if( pstatus != FI_SUCCESS )
		{

			UI_status("FATAL: Cannot display the sheet form");
			fprintf(ptr,"\tFATAL: Cannot display the sheet form.\n");
			
			FIf_delete ( gPltSheetProcFrmPtr ) ;
			form_PltSheetProc_exists = FALSE;
			form_PltSheetProc_displayed = FALSE;

			form_PltDrawData_displayed = FALSE;
			form_PltDrawData_exists = FALSE;
			FIf_delete (gPltDrawDataFrmPtr);

			__DBGpr_com ("reseting the stack.");
			ci$d_reset();
			ci$d_reset();

			status = OM_E_ERROR;
			goto quit;
		}

		/* clear the rows */
		FIfld_get_num_rows(gPltSheetProcFrmPtr, PLTShtProc_TBL, &num_rows);
		FIfld_delete_rows( gPltSheetProcFrmPtr, PLTShtProc_TBL, 0, num_rows-1);

		/* Set a messages in the message field on the sheet form */
		FIfld_set_text (gPltSheetProcFrmPtr, PLTShtProcMSGFLD, 0, 0, "", FALSE);
		FIfld_set_text (gPltSheetProcFrmPtr, PLTShtProcMSGFLD, 0, 0, "Select a sheet or sheets.", FALSE);


		/*
		 * get the sheets from the macro
		 */


		/* get the drawing object information from ISDP */
		// get the manager
		vdct1$GetManager(mgrID = &mgrID);

		// Do Nothing if no active manager
		if (mgrID.objid == NULL_OBJID) 
		{
			UI_status("No Tree Manager Available");
			fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
      		status = OM_E_ERROR;
			goto quit;

		}

		// Cycle through each set (GetMgrChild returns 0 when no more kids)
		for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
		{

			// Get the tree
			vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

			// Get the Plot Tree Info 
			vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
			if (strcmp(baseInfo.setType,"PlotTree") == 0)
			{
				found = TRUE;

				/* get the drawing number */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_DRAWING_NUMBER,
								fld   = &fld);
				/*sprintf(sLPDNum, "%s", fld.val.txt);*/
				strncpy(sLPDNum, fld.val.txt, strlen(fld.val.txt));
				__DBGpr_str("sLPDNum =  ", sLPDNum);

				/* get the drawing rev */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
								fld   = &fld);
				/*sprintf(sLPDRev, "%s", fld.val.txt);*/
				strncpy(sLPDRev, fld.val.txt, strlen(fld.val.txt));
				__DBGpr_str("sLPDRev =  ", sLPDRev);

				/* get the cage code */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_CAGE_CODE,
								fld   = &fld);
				/*sprintf(sCage, "%s", fld.val.txt);*/
				strncpy(sCage, fld.val.txt, 5);
				__DBGpr_str("sCage =  ", sCage);

			  
			    __DBGpr_str("sLPDNum =  ", sLPDNum);
				__DBGpr_str("sLPDRev =  ", sLPDRev);
				__DBGpr_str("sCage =  ", sCage);
				/* compare what we have to what the user wants */
				if( (strcmp( sLPDNum, LPD_Info.DrwNum) == 0) &&
					(strcmp( sLPDRev, LPD_Info.AimRev) == 0) &&
					(strcmp( fld.val.txt, LPD_Info.CageCode) == 0) )
				{
					/*	get the sheets and store them in the global structure
					 */

					__DBGpr_com("Got Drawing Object.");
					fprintf(ptr,"\n\tGot Drawing Object....................\n");
					// Cycle through and gett the sheet objects
					for(i = 0; vdct1$GetTree1Child(objID = &treeID, nth = i, outID = &sheetID); i = i + 1)
					{
						__DBGpr_com("Got Sheet Object.");
						
						/* add a new row for the sheet */
						FIfld_insert_blank_row(gPltSheetProcFrmPtr, PLTShtProc_TBL, 0);

						/***** get sheet number *****/
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_SHEET_NUMBER,
										fld   = &fld);
						__DBGpr_str("fld.val.txt =  ", fld.val.txt);
						sprintf( LPD_ShtInfo[Sht_Index].ShtNum, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].ShtNum =  ", LPD_ShtInfo[Sht_Index].ShtNum);

						/* add the field to the row */
						FIfld_set_text(		gPltSheetProcFrmPtr, 
											PLTShtProc_TBL,
											0, 
											PLTShtProc_C_SHTNUM, 
											LPD_ShtInfo[Sht_Index].ShtNum, 
											FALSE);

						/***** get sheet name *****/
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_SHEET_NAME,
										fld   = &fld);
						sprintf( LPD_ShtInfo[Sht_Index].ShtName, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].ShtName =  ", LPD_ShtInfo[Sht_Index].ShtName);
						
						FIfld_set_text(	gPltSheetProcFrmPtr, 
												PLTShtProc_TBL,
												0, 
												PLTShtProc_C_NAME, 
												LPD_ShtInfo[Sht_Index].ShtName, 
												FALSE);

						/***** get sheet desc *****/
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_SHEET_DESCRIPTION,
										fld   = &fld);
						sprintf( LPD_ShtInfo[Sht_Index].ShtDesc, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].ShtDesc =  ", LPD_ShtInfo[Sht_Index].ShtDesc);

						FIfld_set_text(	gPltSheetProcFrmPtr, 
												PLTShtProc_TBL,
												0, 
												PLTShtProc_C_DESC, 
												LPD_ShtInfo[Sht_Index].ShtDesc, 
												FALSE);

						/***** get sheet status *****/
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_STATUS,
										fld   = &fld);
						sprintf( LPD_ShtInfo[Sht_Index].Status, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].Status =  ", LPD_ShtInfo[Sht_Index].Status);

						FIfld_set_text(	gPltSheetProcFrmPtr, 
												PLTShtProc_TBL,
												0, 
												PLTShtProc_C_STATUS, 
												LPD_ShtInfo[Sht_Index].Status, 
												FALSE);

						/***** get sheet date *****/
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_DATE,
										fld   = &fld);
						sprintf( LPD_ShtInfo[Sht_Index].Date, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].Date =  ", LPD_ShtInfo[Sht_Index].Date);

						FIfld_set_text(	gPltSheetProcFrmPtr, 
												PLTShtProc_TBL,
												0, 
												PLTShtProc_C_DATE, 
												LPD_ShtInfo[Sht_Index].Date, 
												FALSE);

						/***** get sheet window  *****/
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_WINDOW,
										fld   = &fld);
						sprintf( LPD_ShtInfo[Sht_Index].ShtWindow, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].ShtWindow =  ", LPD_ShtInfo[Sht_Index].ShtWindow);
						__DBGpr_int("Sht_Index ", Sht_Index);

						/***** get sheet range *****/
						VDct1GetNodeRange(&sheetID, LPD_ShtInfo[Sht_Index].Range);
						//vdct1$GetNodeRange(nodeID   = &sheetID, 
						//		     objRange = LPD_ShtInfo[Sht_Index].Range);

						//printf(" Range %g, %g, %g\n", LPD_ShtInfo[Sht_Index].Range[0], LPD_ShtInfo[Sht_Index].Range[1], LPD_ShtInfo[Sht_Index].Range[2] );
    						//printf(" Range %g, %g, %g\n", LPD_ShtInfo[Sht_Index].Range[3], LPD_ShtInfo[Sht_Index].Range[4], LPD_ShtInfo[Sht_Index].Range[5] );
						

						/***** get sheet cvprism 
						vdcol$GetAttr(	objID = &sheetID,
										name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_DATE,
										fld   = &fld);
						sprintf( LPD_ShtInfo[Sht_Index].Date, "%s", fld.val.txt); 
						__DBGpr_str("LPD_ShtInfo[Sht_Index].Date =  ", LPD_ShtInfo[Sht_Index].Date);
						*****/

						Sht_Index = Sht_Index + 1;
						LPD_Sht_Index = LPD_Sht_Index + 1;

					}
					match = TRUE;
				}
				else
				{
					match = FALSE;
				}	
			}	
		}	
		
		if ( found == FALSE )
		{
			UI_status("No PlotTree Defined");
			fprintf(ptr,"\tNo PlotTree Defined.  Contact ISDP Administrator.\n");
	  		status = OM_E_ERROR;

			form_PltSheetProc_displayed = TRUE;
			form_PltSheetProc_exists = TRUE;

			/* Erase the main form */ 
			FIf_erase (gPltDrawDataFrmPtr);
			form_PltDrawData_displayed = FALSE;

			goto quit;
		}

		if ( match == FALSE )
		{
			UI_status("No Sheets Found For the Drawing Object.");
			fprintf(ptr,"\tNo Sheets Found For the Drawing Object.\n");
	  		
			FIg_set_text( gPltSheetProcFrmPtr, PLTShtProcMSGFLD, "No Sheets Found." );
			form_PltSheetProc_displayed = TRUE;
			form_PltSheetProc_exists = TRUE;

			/* Erase the main form */ 
			FIf_erase (gPltDrawDataFrmPtr);
			form_PltDrawData_displayed = FALSE;

			goto quit;
		}

		form_PltSheetProc_displayed = TRUE;
		form_PltSheetProc_exists = TRUE;

		/* Erase the main form */ 
		FIf_erase (gPltDrawDataFrmPtr);
		form_PltDrawData_displayed = FALSE;

		status = OM_S_SUCCESS;

  } 
  else 
  {
		#ifdef DEBUG
		printf("sheet form does not exist\n");
		#endif
    
		UI_status("FATAL: Sheet Form not found");
		fprintf(ptr,"\tFATAL: Sheet Form not found.\n");
		status = OM_E_ERROR;
  }
  
quit:  
  
  return status;


}

/*****************************************************
* PLTSheetProcessing_form:
*	- Process Sheet Processing form commands.
*
*****************************************************/

int PLTSheetProcessing_form( )
{

	long pstatus;
	int num_rows;
	int row;
	int status;
	int  response;

	/*
	 * this function is the main interface control for all activities with
	 * the command. It manages the initialization and the form_notification
	 * of the form.
	 * It also controls the output functionalities of the command object.
	 */
	__DBGpr_com ("PLTSheetProcessing_form:");
	fprintf(ptr,"\nPLTSheetProcessing_form: \n");

	
	pstatus = PLTsht_form_init ();
	__DBGpr_com ("after calling PLTSheetProcessing_form:");
	if (pstatus != OM_S_SUCCESS)
	{
		__DBGpr_com ("pstatus is bad:");
		return status;
	}

	if( form_PltSheetProc_exists != TRUE )
	{ 
  		#ifdef DEBUG
  		printf("sheet form not initialized, exiting\n");
  		#endif
  	
  		UI_status("FATAL: Sheet processing form not found");
		fprintf(ptr,"\tFATAL: Sheet processing form not found.\n");
		goto quit;
	}
	else 
	{
		__DBGpr_com ("calling shtforn_disp:");
		status = shtform_disp( );
	}

	__DBGpr_com ("after shtforn_disp:");

	/*********  Process the form gadgets **************************************/

	get_input( "Select options" );



quit: 

	return status; 
}
/**************************************/
/*****************************************************
* PLTaddsht_form_init:
*	- initializes the Add Sheet form
*
*****************************************************/

long PLTaddsht_form_init()
{
int		fstatus;
int		status1;
long	pstatus;
int		status;

status  = OM_S_SUCCESS;

	__DBGpr_com ("PLTaddsht_form_init:");

	fprintf(ptr,"\nPLTaddsht_form_init: \n");

	/*
	 * the initialization of the form, which includes setting/linking the form
	 * to the command object; Get the form input and aimdisplay the found
	 * information in the form.
	 */
 
	/*if( form_PltAddSheet_exists == TRUE ) return;*/

	__DBGpr_com ("PLTaddsht_form_init: creating the form.");
	fstatus = FIf_new (	PLTADDSHEETFRMLABEL,
						PLTADDSHEETFRM,
						ci_notification,
						&gPltAddSheetFrmPtr);

	if ( (fstatus != FI_SUCCESS) || (gPltAddSheetFrmPtr == NULL) )
	{
		UI_status("FATAL: Cannot initialize add sheet form");
		fprintf(ptr,"\tFATAL: Cannot initialize add sheet form.\n");
		status = OM_E_ERROR;
		goto quit;
	}

	
	form_PltAddSheet_exists = TRUE;

	/****************************************************
	 * MY_ID and OM_Gw_current_OS are symbolic constants 
	 * that are defined in the "ciminimum.h" include file. 
     ****************************************************/

	fstatus = FIf_set_cmd_oid_os (gPltAddSheetFrmPtr, MY_ID,
                                OM_Gw_current_OS);
	if (fstatus != FI_SUCCESS)
	{
		UI_status("FATAL: Cannot link to the I/Forms system.");
		fprintf(ptr,"\tFATAL: Cannot link to the I/Forms system.\n");
        
		/****************************************************
		* The form has been loaded into memory at this point.  
		* we need to delete it from memory at this point.  
		*****************************************************/

		form_PltAddSheet_exists = FALSE;
		FIf_delete (gPltAddSheetFrmPtr);
		form_PltAddSheet_displayed = FALSE;
		status = OM_E_ERROR;
		goto quit;
   }

   form_PltAddSheet_exists = TRUE;

 quit:  
  
  return status ;
}

/*****************************************************
* addshtform_disp:
*	- displays the add sheet form
*
*****************************************************/

int addshtform_disp ( )
{
IGRint		pstatus;
int			status ;

status		= OM_S_SUCCESS ;

	__DBGpr_com ("addshtform_disp:");
	fprintf(ptr,"\naddshtform_disp: \n");
  
	/*
	 * set the gadgets and display the sheet processing form
	 */

	if( form_PltAddSheet_exists == TRUE )
	{
		/*
		 * display the form
		 */

		pstatus = FIf_display ( gPltAddSheetFrmPtr ) ;
		if( pstatus != FI_SUCCESS )
		{

			UI_status("FATAL: Cannot display the addsheet form");
			fprintf(ptr,"\tFATAL: Cannot display the add sheet form.\n");
			
			FIf_delete ( gPltAddSheetFrmPtr ) ;
			form_PltAddSheet_exists = FALSE;
			form_PltAddSheet_displayed = FALSE;

			__DBGpr_com ("reseting the stack.");

			status = OM_E_ERROR;
			goto quit;
		}


		form_PltAddSheet_displayed = TRUE;
		form_PltAddSheet_exists = TRUE;

		/* Set a messages in the message field on the sheet form */
		FIfld_set_text (gPltAddSheetFrmPtr, PLTAddSheetMSGFLD, 0, 0, "", FALSE);
		FIfld_set_text (gPltAddSheetFrmPtr, PLTAddSheetMSGFLD, 0, 0, "Enter sheet information.", FALSE);

		status = OM_S_SUCCESS;

  } 
  else 
  {
		#ifdef DEBUG
		printf("add sheet form does not exist\n");
		#endif
    
		UI_status("FATAL: Add Sheet Form not found");
		fprintf(ptr,"\tFATAL: Add Sheet Form not found.\n");
		status = OM_E_ERROR;
  }
  
quit:  
  
  return status;


}


/*****************************************************
* PLTAddSheet_form:
*	- Add Sheet.
*
*****************************************************/

int PLTAddSheet_form( )
{

	long pstatus;
	int num_rows;
	int row;
	int status;
	int  response;

	/*
	 * this function is the main interface control for all activities with
	 * the command. It manages the initialization and the form_notification
	 * of the form.
	 * It also controls the output functionalities of the command object.
	 */
	__DBGpr_com ("PLTAddSheet_form:");
	fprintf(ptr,"\nPLTAddSheet_form: \n");

	
	pstatus = PLTaddsht_form_init ();
	__DBGpr_com ("after calling PLTAddSheet_form:");
	if (pstatus != OM_S_SUCCESS)
	{
		__DBGpr_com ("pstatus is bad:");
		return status;
	}

	if( form_PltAddSheet_exists != TRUE )
	{ 
  		#ifdef DEBUG
  		printf("add sheet form not initialized, exiting\n");
  		#endif
  	
  		UI_status("FATAL: Add Sheet processing form not found");
		fprintf(ptr,"\tFATAL: Add Sheet processing form not found.\n");
		goto quit;
	}
	else 
	{
		__DBGpr_com ("calling addshtforn_disp:");
		status = addshtform_disp( );
	}

	__DBGpr_com ("after addshtforn_disp:");

	/*********  Process the form gadgets **************************************/

	get_input( "Select options" );



quit: 

	return status; 
}




PLTsheetprocess_request()
{

int		status, i ;
int		retCode ;
int		num_rows;
int		row;
int		mcf_select;
int		length;
int		select;
int		pos;
int		index;
int		x;
int		col;
int		ierror1;

IGRint	found, match;

long  tp;

char	*sht_status;
char	*sht_number;
char	*sht_name;
char	*sht_desc;

char	plotfile[256];
char	plotfile_wo[256];
char	oldplotfile[256];
char	fmt_time[64];
char	plotfilename[256];
char	textfilename[256];

IGRchar			sCage[5];
IGRchar			sLPDRev[20];
IGRchar			sLPDNum[20];
IGRchar			sShtDrwRev[20];

TVDctBaseInfo	baseInfo;
TVDfld			fld;

TGRid			mgrID;
TGRid			setID;
TGRid			treeID;
TGRid			sheetID;

IGRdouble 			range[12];

struct IGRcv_prism 	*cvprism;
struct tm *tm_ptr;



status		= OM_S_SUCCESS ;
retCode 	= OM_S_SUCCESS;
num_rows	= 0;
row		= 0;
index		= 0;
x		= 0;
ierror1		= 0;
mcf_select	= FALSE;
sht_status	= NULL;
sht_number	= NULL;
sht_name	= NULL;
sht_desc	= NULL;
cvprism		= NULL;
mgrID.objid		= NULL_OBJID;
setID.objid		= NULL_OBJID;
treeID.objid	= NULL_OBJID;

	fprintf(ptr,"\nPLTsheetprocess_request: \n");

	/* Get the number of rows on the form */
	FIfld_get_num_rows(gPltSheetProcFrmPtr, PLTShtProc_TBL, &num_rows);
        __DBGpr_int("num_rows ", num_rows);


	/* for each row, 
	 * 1. check to see if it is selected, if so
	 *		a. check the status of the sheet
	 *		b. extract the sheet
	 *		c. ftp the extraction to AIM
	 *		d. execute the appropriate AIM command to process the plot extraction
	 *		e. update the sheet status area.
	 */

	for (row = 0; row < num_rows-1; row = row + 1)
	{
            __DBGpr_int("row = ", row);

		FIfld_get_select(	gPltSheetProcFrmPtr, 
							PLTShtProc_TBL, 
							row, 
							0, 
							&mcf_select);
	 
        	if (mcf_select)
		{
			__DBGpr_int("selected row ", row);
	
			FIfld_get_text_length(	gPltSheetProcFrmPtr, 
						PLTShtProc_TBL, 
						row, 
						PLTShtProc_C_STATUS, 
						&length);
			sht_status = (char *) malloc (sizeof (char) * length+1);
			memset(sht_status, NULL, sizeof (char) * length + 1);

			FIfld_get_text(	gPltSheetProcFrmPtr, 
					PLTShtProc_TBL, 
					row, 
					PLTShtProc_C_STATUS, 
					length,
					(unsigned char *)sht_status, 
							&select, 
							&pos);

			__DBGpr_str("sht_status ", sht_status);

			if ( (strcmp(sht_status, "") == 0) || (strcmp(sht_status, "NOT POSTED") == 0) ) 
			{
				length = 0;
				select = 0;
				pos = 0;

				FIfld_get_text_length(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										PLTShtProc_C_SHTNUM, 
										&length);

				sht_number = (char *) malloc (sizeof (char) * length+1);
				memset(sht_number, NULL, sizeof (char) * length + 1);

				
				FIfld_get_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								row, 
								PLTShtProc_C_SHTNUM, 
								length,
								(unsigned char *)sht_number, 
								&select, 
								&pos);

				__DBGpr_str("sht_number ", sht_number);

				length = 0;
				select = 0;
				pos = 0;

				FIfld_get_text_length(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										PLTShtProc_C_NAME, 
										&length);

				sht_name = (char *) malloc (sizeof (char) * length+1);
				memset(sht_name, NULL, sizeof (char) * length + 1);

				FIfld_get_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								row, 
								PLTShtProc_C_NAME, 
								length,
								(unsigned char *)sht_name, 
								&select, 
								&pos);

				__DBGpr_str("sht_name ", sht_name);

				FIfld_get_text_length(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										PLTShtProc_C_DESC, 
										&length);

				sht_desc = (char *) malloc (sizeof (char) * length+1);
				memset(sht_desc, NULL, sizeof (char) * length + 1);

				FIfld_get_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								row, 
								PLTShtProc_C_DESC, 
								length,
								(unsigned char *)sht_desc, 
								&select, 
								&pos);

				__DBGpr_str("sht_desc ", sht_desc);

				__DBGpr_int("LPD_Sht_Index ", LPD_Sht_Index);

				for ( x=0; x <= LPD_Sht_Index; x = x + 1)
				{
					__DBGpr_str("LPD_ShtInfo[x].ShtNum ", LPD_ShtInfo[x].ShtNum);
					__DBGpr_str("sht_number ", sht_number);

					if (strcmp(LPD_ShtInfo[x].ShtNum, sht_number) == 0)
					{
						index = x;
						__DBGpr_int("index ", index);
					} 
	
				}
				
				sprintf(plotfile, "\"%s %s Rev %s Sheet %s-%s.plt\"", LPD_Info.CageCode, 
										LPD_Info.DrwNum, 
										LPD_Info.AimRev ,
										sht_number,
										sht_name);
				__DBGpr_str("plotfile ", plotfile);

				sprintf(plotfile_wo, "%s %s Rev %s Sheet %s-%s.plt", LPD_Info.CageCode, 
										LPD_Info.DrwNum, 
										LPD_Info.AimRev ,
										sht_number,
										sht_name);
				__DBGpr_str("plotfile_wo ", plotfile_wo);

				sprintf(E_FileInfo.plotfile, "%s", plotfile_wo);

				status = extract_files( index ); 
				/*
				if (LPD_ShtInfo[index].cvprism)
					free(LPD_ShtInfo[index].cvprism);
				*/
				 
				if (status == OM_E_ERROR)
				{
					UI_status("Error extraction plot file...");
					fprintf(ptr,"\tError extraction plot file.\n"); 
					ierror1 = 1;
					goto error0;
				}

				status = ftp_files_to_aim_wl( E_FileInfo.plotfile );
				if ( status == OM_E_ERROR )
				{
					UI_status("Can not open ftp shell file for writing...");
					fprintf(ptr,"\tCan not open ftp shell file for writing.\n"); 
					ierror1 = 1;
					goto error0;
				}

				fprintf( "Removing Plot File.......\n" );
        			UI_status( "Removing Plot File......." );

        			// TLS 6-1-01: Fix for TR 5227
        			/*
         			 * Remove the Plot and Text file from the file system.
         			 */
         			status = remove_plt_file( &retCode );
				
				status == OM_S_SUCCESS;

				sprintf(oldplotfile, "%s","NONE");

				status = post_files( VDP_REG_PLOT_FILES, E_FileInfo.plotfile, oldplotfile, sht_desc );
				
				if (status == OM_E_ERROR)
				{
					UI_status("Error posting plot file...");
					fprintf(ptr,"\tError posting plot file.\n"); 
					ierror1 = 1;
					goto error0;
				}

				
error0:
            			__DBGpr_int("ierror1 = ", ierror1);
				/* clear the selected row */
					for (col = 0; col < 5; col = col + 1)
					{
						FIfld_set_select(	gPltSheetProcFrmPtr, 
									PLTShtProc_TBL, 
									row, 
									col, 
									FALSE);
					}

					/* now update the status area in the form for the posted sheet */
					if ( ierror1 == 1)
					{
						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								row, 
								PLTShtProc_C_STATUS, 
								"NOT POSTED", 
								FALSE);
					}
					else	
					{
						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								row, 
								PLTShtProc_C_STATUS, 
								"POSTED", 
								FALSE);
					}

					/* get the current date */
					fmt_time[0] = '\0';
					tm_ptr = NULL;

					time (&tp);
					tm_ptr = localtime (&tp);
					strftime (fmt_time, 64, "%m/%d/%y", tm_ptr);

					FIfld_set_text(	gPltSheetProcFrmPtr, 
							PLTShtProc_TBL,
							row, 
							PLTShtProc_C_DATE, 
							fmt_time, 
							FALSE);
										
				   /****** store the status in tree manager *******/

					/* get the drawing object information from ISDP */
					// get the manager
					vdct1$GetManager(mgrID = &mgrID);

					// Do Nothing if no active manager
					if (mgrID.objid == NULL_OBJID) 
					{
						UI_status("No Tree Manager Available");
						fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
      						status = OM_E_ERROR;
						goto cont;

					}

					// Cycle through each set (GetMgrChild returns 0 when no more kids)
					for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
					{

						// Get the tree
						vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

						// Get the Plot Tree Info 
						vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
						if (strcmp(baseInfo.setType,"PlotTree") == 0)
						{
							found = TRUE;

							/* get the drawing number */
							vdcol$GetAttr(	objID = &treeID,
									name  = VDCT1_PLOT_ATTR_NAME_DRAWING_NUMBER,
									fld   = &fld);
							/*sprintf(sLPDNum, "%s", fld.val.txt);*/
							strncpy(sLPDNum, fld.val.txt, strlen(fld.val.txt));
							__DBGpr_str("sLPDNum =  ", sLPDNum);

							/* get the drawing rev */
							vdcol$GetAttr(	objID = &treeID,
									name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
									fld   = &fld);
							/*sprintf(sLPDRev, "%s", fld.val.txt);*/
							strncpy(sLPDRev, fld.val.txt, strlen(fld.val.txt));
							__DBGpr_str("sLPDRev =  ", sLPDRev);

							/* get the cage code */
							vdcol$GetAttr(	objID = &treeID,
									name  = VDCT1_PLOT_ATTR_NAME_CAGE_CODE,
									fld   = &fld);
							/*sprintf(sCage, "%s", fld.val.txt);*/
							strncpy(sCage, fld.val.txt, 5);
							__DBGpr_str("sCage =  ", sCage);

						  
							__DBGpr_str("sLPDNum =  ", sLPDNum);
							__DBGpr_str("sLPDRev =  ", sLPDRev);
							__DBGpr_str("sCage =  ", sCage);
							/* compare what we have to what the user wants */
							if( (strcmp( sLPDNum, LPD_Info.DrwNum) == 0) &&
								(strcmp( sLPDRev, LPD_Info.AimRev) == 0) &&
								(strcmp( fld.val.txt, LPD_Info.CageCode) == 0) )
							{
							
								/* first update the posting_date attribute on the
								 * drawing object 
								 */

								/* get the posting date*/
								vdcol$GetAttr(	objID = &treeID,
										name  = VDCT1_PLOT_ATTR_NAME_POSTING_DATE,
										fld   = &fld);
								strcpy(fld.val.txt,fmt_time);
								vdcol$UpdAttrs(objID = &treeID, cnt = 1, fld = &fld);
								

								/*	get the sheets and store them in the global structure
								 */

								__DBGpr_com("Got Drawing Object.");
								fprintf(ptr,"\n\tGot Drawing Object....................\n");
								// Cycle through and gett the sheet objects
								for(i = 0; vdct1$GetTree1Child(objID = &treeID, nth = i, outID = &sheetID); i = i + 1)
								{
									__DBGpr_com("Got Sheet Object.");
									
									/***** get sheet number *****/
									vdcol$GetAttr(	objID = &sheetID,
											name  = VDCT1_PLOT_ATTR_NAME_SHEET_NUMBER,
											fld   = &fld);
									__DBGpr_str("fld.val.txt =  ", fld.val.txt);
									if(strcmp( fld.val.txt, sht_number) == 0) 
									{
										/* set the registation status */
										vdcol$GetAttr(	objID = &sheetID,
												name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_STATUS,
												fld   = &fld);
										if(ierror1 == 1 )
											strcpy(fld.val.txt,"NOT POSTED");
										else
											strcpy(fld.val.txt,"POSTED");
										vdcol$UpdAttrs(objID = &sheetID, cnt = 1, fld = &fld);

										/* set the registration date */
										vdcol$GetAttr(	objID = &sheetID,
												name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_DATE,
												fld   = &fld);
										strcpy(fld.val.txt,fmt_time);
										vdcol$UpdAttrs(objID = &sheetID, cnt = 1, fld = &fld);

										/* set the sheets drawing rev */
										vdcol$GetAttr(	objID = &sheetID,
												name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
												fld   = &fld);
										strcpy(fld.val.txt,sLPDRev);
										vdcol$UpdAttrs(objID = &sheetID, cnt = 1, fld = &fld);

									}
								}
							}
						}
					}
				
					ierror1 = 0;

					FIfld_set_text (	gPltSheetProcFrmPtr, 
								PLTShtProcMSGFLD, 
								0, 
								0, 
								"Post Process Complete ...", 
								FALSE);


					UI_status("Post Process Complete ...");
					fprintf(ptr,"\t\t\tPost Process Complete ...\n");

			}

/************************************************************************************/			

			if ( (strcmp(sht_status, "POSTED") == 0) || (strcmp(sht_status, "ERROR") == 0) )
			{
				/* get the selected sheet and generate the file name */
				length = 0;
				select = 0;
				pos = 0;

				FIfld_get_text_length(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										PLTShtProc_C_SHTNUM, 
										&length);

				sht_number = (char *) malloc (sizeof (char) * length+1);
				memset(sht_number, NULL, sizeof (char) * length + 1);

				
				FIfld_get_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								row, 
								PLTShtProc_C_SHTNUM, 
								length,
								(unsigned char *)sht_number, 
								&select, 
								&pos);

				__DBGpr_str("sht_number ", sht_number);

				length = 0;
				select = 0;
				pos = 0;

				FIfld_get_text_length(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										PLTShtProc_C_NAME, 
										&length);

				sht_name = (char *) malloc (sizeof (char) * length+1);
				memset(sht_name, NULL, sizeof (char) * length + 1);

				FIfld_get_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								row, 
								PLTShtProc_C_NAME, 
								length,
								(unsigned char *)sht_name, 
								&select, 
								&pos);

				__DBGpr_str("sht_name ", sht_name);

				FIfld_get_text_length(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										PLTShtProc_C_DESC, 
										&length);

				sht_desc = (char *) malloc (sizeof (char) * length+1);
				memset(sht_desc, NULL, sizeof (char) * length + 1);

				FIfld_get_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								row, 
								PLTShtProc_C_DESC, 
								length,
								(unsigned char *)sht_desc, 
								&select, 
								&pos);

				__DBGpr_str("sht_desc ", sht_desc);


				for ( x=0; x < LPD_Sht_Index; x = x + 1)
				{
					if (strcmp(LPD_ShtInfo[x].ShtNum, sht_number) == 0)
					{
						index = x;
						__DBGpr_int("index ", index);
					} 
	
				}
				
				sprintf(plotfile, "%s %s Rev %s Sheet %s-%s", LPD_Info.CageCode, 
															LPD_Info.DrwNum, 
															LPD_Info.AimRev ,
															sht_number,
															sht_name);
				__DBGpr_str("plotfile ", plotfile);

				sprintf(plotfile_wo, "%s %s Rev %s Sheet %s-%s.plt", LPD_Info.CageCode, 
															LPD_Info.DrwNum, 
															LPD_Info.AimRev ,
															sht_number,
															sht_name);
				__DBGpr_str("plotfile_wo ", plotfile_wo);

				sprintf(E_FileInfo.plotfile, "%s", plotfile_wo);
			  
				status = extract_files( index ); 
				 
				if (status == OM_E_ERROR)
				{
					UI_status("Error extraction plot file...");
					fprintf(ptr,"\tError extraction plot file.\n"); 
					ierror1 = 1;
					goto error1;
				}

			  
			    /***** NOW check to see if the drawing revision is new *****/
				/* get the drawing object and sheet information from Tree Manager */
				// get the manager
				vdct1$GetManager(mgrID = &mgrID);

				// Do Nothing if no active manager
				if (mgrID.objid == NULL_OBJID) 
				{	
					UI_status("No Tree Manager Available");
					fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
      				status = OM_E_ERROR;
					goto quit;
				}

				// Cycle through each set (GetMgrChild returns 0 when no more kids)
				for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
				{
  					// Get the tree
					vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

					// Get the Plot Tree Info 
					vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
					if (strcmp(baseInfo.setType,"PlotTree") == 0)
					{
						found = TRUE;
				
						/* get the drawing number */
						vdcol$GetAttr(	objID = &treeID,
										name  = VDCT1_PLOT_ATTR_NAME_DRAWING_NUMBER,
										fld   = &fld);
						/*sprintf(sLPDNum, "%s", fld.val.txt);*/
						strncpy(sLPDNum, fld.val.txt, strlen(fld.val.txt));
						__DBGpr_str("sLPDNum =  ", sLPDNum);

						/* get the drawing rev */
						vdcol$GetAttr(	objID = &treeID,
										name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
										fld   = &fld);
						/*sprintf(sLPDRev, "%s", fld.val.txt);*/
						strncpy(sLPDRev, fld.val.txt, strlen(fld.val.txt));
						__DBGpr_str("sLPDRev =  ", sLPDRev);

						/* get the cage code */
						vdcol$GetAttr(	objID = &treeID,
										name  = VDCT1_PLOT_ATTR_NAME_CAGE_CODE,
										fld   = &fld);
						/*sprintf(sCage, "%s", fld.val.txt);*/
						strncpy(sCage, fld.val.txt, 5);
						__DBGpr_str("sCage =  ", sCage);

							  
						__DBGpr_str("sLPDNum =  ", sLPDNum);
						__DBGpr_str("sLPDRev =  ", sLPDRev);
						__DBGpr_str("sCage =  ", sCage);
				
						/* compare what we have to what the user wants */
						if( (strcmp( sLPDNum, LPD_Info.DrwNum) == 0) &&
							(strcmp( sLPDRev, LPD_Info.AimRev) == 0) &&
							(strcmp( fld.val.txt, LPD_Info.CageCode) == 0) )
						{
							/*	get the sheets and store them in the global structure
							 */

							__DBGpr_com("Got Drawing Object.");
							fprintf(ptr,"\n\tGot Drawing Object....................\n");
							// Cycle through and gett the sheet objects
							for(i = 0; vdct1$GetTree1Child(objID = &treeID, nth = i, outID = &sheetID); i = i + 1)
							{
										__DBGpr_com("Got Sheet Object.");
										
										/***** get sheet number *****/
										vdcol$GetAttr(	objID = &sheetID,
														name  = VDCT1_PLOT_ATTR_NAME_SHEET_NUMBER,
														fld   = &fld);
										__DBGpr_str("fld.val.txt =  ", fld.val.txt);
										__DBGpr_str("sht_number =  ", sht_number);
										if(strcmp( fld.val.txt, sht_number) == 0) 
										{
											/* get the drawing revision */
											vdcol$GetAttr(	objID = &sheetID,
															name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
															fld   = &fld);
											strncpy(sShtDrwRev, fld.val.txt, strlen(fld.val.txt));

										}
							}
						}
					}
			   } //end for loop
			  
			  /* compare the revisions */
			  if (strcmp(sLPDRev, sShtDrwRev) == 0)
			  {
				/* the revison match, just do a check out/in process */

				sprintf(plotfilename, "%s.plt", plotfile );
				sprintf(textfilename, "%s.txt", plotfile );

				/* check out the data item*/ 
				status == OM_S_SUCCESS;
				status = check_out_in_doc(textfilename, "out", "EditText" );
				if ( status == OM_E_ERROR )
				{
					UI_status("FAIL TO CHECK OUT TEXT FILE...");
					UI_status("CONTACT AIM ADMINISTRATOR...");
					fprintf(ptr,"\tFAIL TO CHECK OUT TEXT FILE <%s>.  Skipping this file.\n", textfilename); 
					fprintf(ptr,"\tCONTACT AIM ADMINISTRATOR.\n"); 
					ierror1 = 1;
					goto error1;
				}

				status = check_out_in_doc(plotfilename, "out", "SrPlotFl" );
				if ( status == OM_E_ERROR )
				{
					UI_status("FAIL TO CHECK OUT PLOT FILE...");
					UI_status("CONTACT AIM ADMINISTRATOR...");
					fprintf(ptr,"\tFAIL TO CHECK OUT PLOT FILE <%s>.  Skipping this file.\n", plotfilename); 
					fprintf(ptr,"\tCONTACT AIM ADMINISTRATOR.\n"); 
					ierror1 = 1;
					goto error1;
				}
				
				
				/* ftp the plot file to aim*/ 
				status == OM_S_SUCCESS;
				status = ftp_files_to_aim_wl( E_FileInfo.plotfile );
				if ( status == OM_E_ERROR )
				{
					UI_status("FAIL TO TRANSFER PLOT FILE...");
					fprintf(ptr,"\tFAIL TO TRANSFER PLOT FILE.\n"); 
					ierror1 = 1;
					goto error1;
				}

				
				fprintf( "Removing Plot File.......\n" );
        			UI_status( "Removing Plot File......." );

        			// TLS 6-1-01: Fix for TR 5227
        			/*
         			 * Remove the Plot and Text file from the file system.
         			 */
         			status = remove_plt_file( &retCode );

				/* check in the data item */
				status == OM_S_SUCCESS;
				status = check_out_in_doc(textfilename, "in", "EditText" );
				if ( status == OM_E_ERROR )
				{
					UI_status("FAIL TO CHECK IN TEXT FILE...");
					UI_status("CONTACT AIM ADMINISTRATOR...");
					fprintf(ptr,"\tFAIL TO CHECK IN TEXT FILE <%s>.  Skipping this file.\n", textfilename); 
					fprintf(ptr,"\tCONTACT AIM ADMINISTRATOR.\n"); 
					ierror1 = 1;
					goto error1;
				}
				status = check_out_in_doc(plotfilename, "in", "SrPlotFl" );
				if ( status == OM_E_ERROR )
				{
					UI_status("FAIL TO CHECK IN PLOT FILE...");
					UI_status("CONTACT AIM ADMINISTRATOR...");
					fprintf(ptr,"\tFAIL TO CHECK IN PLOT FILE <%s>.  Skipping this file.\n", plotfilename); 
					fprintf(ptr,"\tCONTACT AIM ADMINISTRATOR.\n"); 
					ierror1 = 1;
					goto error1;
				}
			  }
			  else
			  {
				/* post the sheet to the latest revision */

				/* the AIM code will make sure to delete the relationship between the plot file
				 * and the drawing document if it has been revised 
				 */
				status = ftp_files_to_aim_wl( E_FileInfo.plotfile );
				if ( status == OM_E_ERROR )
				{
					UI_status("FAIL TO TRANSFER PLOT FILE...");
					fprintf(ptr,"\tFAIL TO TRANSFER PLOT FILE.\n"); 
					ierror1 = 1;
					goto error1;
				}
				
				fprintf( "Removing Plot File.......\n" );
        			UI_status( "Removing Plot File......." );

        			// TLS 6-1-01: Fix for TR 5227
        			/*
         			 * Remove the Plot and Text file from the file system.
         			 */
         			status = remove_plt_file( &retCode );

				status == OM_S_SUCCESS;
				/* create the plot file name of the using the previous drawing revision */
				sprintf(oldplotfile, "%s %s Rev %s Sheet %s-%s.plt", LPD_Info.CageCode, 
															LPD_Info.DrwNum, 
															LPD_Info.PrevRev ,
															sht_number,
															sht_name);
				__DBGpr_str("oldplotfile ", oldplotfile);

				status = post_files( VDP_REG_PLOT_FILES, E_FileInfo.plotfile, oldplotfile, sht_desc );
				if (status == OM_E_ERROR)
				{
					UI_status("Error posting plot file...");
					fprintf(ptr,"\tError posting plot file.\n"); 
					ierror1 = 1;
					goto error1;
				}

			  }

				
			  /******* update the status area on the form and in the tree manager for the sheet *******/
error1:
            		__DBGpr_int("ierror1 = ", ierror1);
			  /* get the current date */
				fmt_time[0] = '\0';
				tm_ptr = NULL;
				
				time (&tp);
				tm_ptr = localtime (&tp);
				strftime (fmt_time, 64, "%m/%d/%y", tm_ptr);
				
				FIfld_set_text(	gPltSheetProcFrmPtr, 
									PLTShtProc_TBL,
									row, 
									PLTShtProc_C_DATE, 
									fmt_time, 
									FALSE);

				/****** store the status in tree manager *******/
					mgrID.objid		= NULL_OBJID;
					setID.objid		= NULL_OBJID;
					treeID.objid	= NULL_OBJID;

					/* get the drawing object information from ISDP */
					// get the manager
					vdct1$GetManager(mgrID = &mgrID);

					// Do Nothing if no active manager
					if (mgrID.objid == NULL_OBJID) 
					{
						UI_status("No Tree Manager Available");
						fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
      					status = OM_E_ERROR;
						goto quit;

					}

					// Cycle through each set (GetMgrChild returns 0 when no more kids)
					for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
					{
						// Get the tree
						vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

						// Get the Plot Tree Info 
						vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
						if (strcmp(baseInfo.setType,"PlotTree") == 0)
						{
							found = TRUE;

							/* get the drawing number */
							vdcol$GetAttr(	objID = &treeID,
											name  = VDCT1_PLOT_ATTR_NAME_DRAWING_NUMBER,
											fld   = &fld);
							/*sprintf(sLPDNum, "%s", fld.val.txt);*/
							strncpy(sLPDNum, fld.val.txt, strlen(fld.val.txt));
							__DBGpr_str("sLPDNum =  ", sLPDNum);

							/* get the drawing rev */
							vdcol$GetAttr(	objID = &treeID,
											name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
											fld   = &fld);
							/*sprintf(sLPDRev, "%s", fld.val.txt);*/
							strncpy(sLPDRev, fld.val.txt, strlen(fld.val.txt));
							__DBGpr_str("sLPDRev =  ", sLPDRev);

							/* get the cage code */
							vdcol$GetAttr(	objID = &treeID,
											name  = VDCT1_PLOT_ATTR_NAME_CAGE_CODE,
											fld   = &fld);
							/*sprintf(sCage, "%s", fld.val.txt);*/
							strncpy(sCage, fld.val.txt, 5);
							__DBGpr_str("sCage =  ", sCage);

						  
							__DBGpr_str("sLPDNum =  ", sLPDNum);
							__DBGpr_str("sLPDRev =  ", sLPDRev);
							__DBGpr_str("sCage =  ", sCage);
							/* compare what we have to what the user wants */
							if( (strcmp( sLPDNum, LPD_Info.DrwNum) == 0) &&
								(strcmp( sLPDRev, LPD_Info.AimRev) == 0) &&
								(strcmp( fld.val.txt, LPD_Info.CageCode) == 0) )
							{
							
								/*	get the sheets and store them in the global structure
								 */

								__DBGpr_com("Got Drawing Object.");
								fprintf(ptr,"\n\tGot Drawing Object....................\n");
								// Cycle through and gett the sheet objects
								for(i = 0; vdct1$GetTree1Child(objID = &treeID, nth = i, outID = &sheetID); i = i + 1)
								{
									__DBGpr_com("Got Sheet Object.");
									
									/***** get sheet number *****/
									vdcol$GetAttr(	objID = &sheetID,
													name  = VDCT1_PLOT_ATTR_NAME_SHEET_NUMBER,
													fld   = &fld);
									__DBGpr_str("fld.val.txt =  ", fld.val.txt);
									__DBGpr_str("sht_number =  ", sht_number);
									if(strcmp( fld.val.txt, sht_number) == 0) 
									{
										/* set the registation status */
										vdcol$GetAttr(	objID = &sheetID,
												name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_STATUS,
												fld   = &fld);
										if (ierror1 == 1)
											strcpy(fld.val.txt,"ERROR");
										else
											strcpy(fld.val.txt,"POSTED");

										vdcol$UpdAttrs(objID = &sheetID, cnt = 1, fld = &fld);

										/* set the registration date */
										vdcol$GetAttr(	objID = &sheetID,
												name  = VDCT1_PLOT_ATTR_NAME_REGISTRATION_DATE,
												fld   = &fld);
										strcpy(fld.val.txt,fmt_time);
										vdcol$UpdAttrs(objID = &sheetID, cnt = 1, fld = &fld);

										/* set the sheets drawing rev */
										vdcol$GetAttr(	objID = &sheetID,
												name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
												fld   = &fld);
										strcpy(fld.val.txt,sLPDRev);
										vdcol$UpdAttrs(objID = &sheetID, cnt = 1, fld = &fld);

									}
								}
							}
						}
					} //end for loop
				
				
					ierror1 = 0;

					FIfld_set_text (	gPltSheetProcFrmPtr, 
								PLTShtProcMSGFLD, 
								0, 
								0, 
								"Post Process Complete ...", 
								FALSE);

				        fprintf( "Removing Plot File.......\n" );
        				UI_status( "Removing Plot File......." );

        				// TLS 6-1-01: Fix for TR 5227
        				/*
         				 * Remove the Plot and Text file from the file system.
         				 */
         				status = remove_plt_file( &retCode );

					UI_status("Post Process Complete ...");
					fprintf(ptr,"\t\t\tPost Process Complete ...\n");

				}
				/*else
				{
					status = OM_E_ERROR;
					goto quit;
				}
				*/
		} //end if statement
cont:
		continue;

	}//end of for loop

quit: 
	if ( sht_status ) { free ( (char *)sht_status ); sht_status = NULL; }
	if ( sht_number ) { free ( (char *)sht_number ); sht_number = NULL; }
	if ( sht_name ) { free ( (char *)sht_name ); sht_name = NULL; }
	if ( sht_desc ) { free ( (char *)sht_desc ); sht_desc = NULL; }
	return status;
}

/*************
*
*
**************/

int PLTAddSheet()
{

int			sts, status, msg;
struct GRmd_env 	module_info;
struct GRid 		window, fence;
IGRdouble 			range[12];
struct IGRcv_prism 	*cvprism; 
char 				result[64], color_table[128], seedfile[128];
char 				*plotfile;
int i;
struct GRid			temp;

status		= OM_S_SUCCESS ;
cvprism		= NULL;
plotfile	= NULL;
seedfile[0]	= NULL;
color_table[0]	= NULL;

	fprintf(ptr,"\nPLTAddSheet: \n");

	gr$gsget_fence (msg = &msg,fence_id = &temp);

	__DBGpr_int("msg for gsget_fence  =  ", msg);

	if ((msg == MSSUCC) ||(msg == OM_S_SUCCESS) )
	{
		UI_status("Retreived Fence Successfully ...");
		fprintf(ptr,"\t\t\tRetrieve Fence Successfully.\n");	

		ci$get_module_info(md_env = &module_info);

  		sts = plot$get_fence_range (	msg 	= &msg, 
					module 	= &module_info, 
					fence 	= &fence, 
					window 	= &window, 
					world 	= range, 
					view 	= &range[6],
					cvprism = &cvprism); 
	
   		__DBGpr_int("sts for get_fence_range  =  ", sts);

		if( ! ( sts & msg & 1 ) )
		{
  			UI_status("No Active Fence ...");
			fprintf(ptr,"\t\t\tNo Active Fence.\n");
       		status = OM_E_ERROR;
        	goto quit;
		}
		else
		{
			/* let the user enter in the sheet information */
			/* invoke the 3rd form */
			status = PLTAddSheet_form();


			/*FIfld_insert_blank_row( gPltSheetProcFrmPtr, PLTShtProc_TBL, 0);
			FIfld_pos_cursor( gPltSheetProcFrmPtr, PLTShtProc_TBL, 0, 0, 0, 0, 0, 0);*/


		}
	}
	else
	{
   		if ( msg == PI_F_NOWINDOW )
   		{
 			UI_status("No Window ...");
  			UI_status("No Active Fence ...");
			fprintf(ptr,"\t\t\tFENCE ERROR: No Window \n");	
			fprintf(ptr,"\tNo Active Fence.\n");
       			status = OM_E_ERROR;
        		goto quit;
   		}

   		if( msg == PI_F_BADWINDOW )
   		{
 			UI_status("Bad Window ...");
  			UI_status("No Active Fence ...");
			fprintf(ptr,"\t\t\tFENCE ERROR: Bad Window \n");	
			fprintf(ptr,"\tNo Active Fence.\n");
       			status = OM_E_ERROR;
        		goto quit;
   		}

  		UI_status("No Active Fence ...");
		fprintf(ptr,"\tNo Active Fence.\n");
       		status = OM_E_ERROR;
			goto quit;
	  }





quit:
	__DBGpr_com("quitting.");
	return status;
}

/*****************************************************
* PLTRevQA_form_init:
*	- initializes the Revision prompt form
*
*****************************************************/

long PLTRevQA_form_init()
{
int		fstatus;
int		status1;
long	pstatus;
int		status;

status  = OM_S_SUCCESS;

	__DBGpr_com ("PLTRevQA_form_init:");

	fprintf(ptr,"\nPLTRevQA_form_init: \n");

	/*
	 * the initialization of the form, which includes setting/linking the form
	 * to the command object; Get the form input and display the found
	 * information in the form.
	 */
 
	/*if( form_PltRevQA_exists == TRUE ) return;*/

	__DBGpr_com ("PLTRevQA_form_init: creating the form.");
	fstatus = FIf_new (	PLTREVQAFRMLABEL,
						PLTREVQAFRM,
						ci_notification,
						&gPltRevQAFrmPtr);

	if ( (fstatus != FI_SUCCESS) || (gPltRevQAFrmPtr == NULL) )
	{
		UI_status("FATAL: Cannot initialize add sheet form");
		fprintf(ptr,"\tFATAL: Cannot initialize add sheet form.\n");
		status = OM_E_ERROR;
		goto quit;
	}

	
	form_PltRevQA_exists = TRUE;

	/****************************************************
	 * MY_ID and OM_Gw_current_OS are symbolic constants 
	 * that are defined in the "ciminimum.h" include file. 
     ****************************************************/

	fstatus = FIf_set_cmd_oid_os (gPltRevQAFrmPtr, MY_ID,
                                OM_Gw_current_OS);
	if (fstatus != FI_SUCCESS)
	{
		UI_status("FATAL: Cannot link to the I/Forms system.");
		fprintf(ptr,"\tFATAL: Cannot link to the I/Forms system.\n");
        
		/****************************************************
		* The form has been loaded into memory at this point.  
		* we need to delete it from memory at this point.  
		*****************************************************/

		form_PltRevQA_exists = FALSE;
		FIf_delete (gPltRevQAFrmPtr);
		form_PltRevQA_displayed = FALSE;
		status = OM_E_ERROR;
		goto quit;
   }

   form_PltRevQA_exists = TRUE;

 quit:  
  
  return status ;
}

/*****************************************************
* PltRevQAform_disp:
*	- displays the revision prompt form
*
*****************************************************/

int PltRevQAform_disp ( )
{
IGRint		pstatus;
int			status ;

status		= OM_S_SUCCESS ;

	__DBGpr_com ("PltRevQAform_disp:");
	fprintf(ptr,"\nPltRevQAform_disp: \n");
  
	/*
	 * set the gadgets and display the sheet processing form
	 */

	if( form_PltRevQA_exists == TRUE )
	{
		/*
		 * display the form
		 */

		pstatus = FIf_display ( gPltRevQAFrmPtr ) ;
		if( pstatus != FI_SUCCESS )
		{

			UI_status("FATAL: Cannot display the revision prompt form");
			fprintf(ptr,"\tFATAL: Cannot display the revision prompt form.\n");
			
			FIf_delete ( gPltRevQAFrmPtr ) ;
			form_PltRevQA_exists = FALSE;
			form_PltRevQA_displayed = FALSE;

			__DBGpr_com ("reseting the stack.");

			status = OM_E_ERROR;
			goto quit;
		}


		form_PltRevQA_displayed = TRUE;
		form_PltRevQA_exists = TRUE;

		status = OM_S_SUCCESS;

  } 
  else 
  {
		#ifdef DEBUG
		printf("revision prompt form does not exist\n");
		#endif
    
		UI_status("FATAL: Revision Prompt Form not found");
		fprintf(ptr,"\tFATAL: Revision Prompt Form not found.\n");
		status = OM_E_ERROR;
  }
  
quit:  
  
  return status;


}

/*****************************************************
* prompt_to_revise:
*	- Process revision form.
*
*****************************************************/
prompt_to_revise()
{

int		status;

status		= OM_S_SUCCESS ;

	fprintf(ptr,"\nprompt_to_revise: \n");

	status = PLTRevQA_form_init ();
	__DBGpr_com ("after calling PLTRevQA_form_init:");
	if (status != OM_S_SUCCESS)
	{
		__DBGpr_com ("status is bad:");
		return status;
	}

	if( form_PltRevQA_exists != TRUE )
	{ 
  		#ifdef DEBUG
  		printf("revision prompt form not initialized, exiting\n");
  		#endif
  	
  		UI_status("FATAL: Revision prompting form not found");
		fprintf(ptr,"\tFATAL: Revision prompting form not found.\n");
		goto quit;
	}
	else 
	{
		__DBGpr_com ("calling PltRevQAform_disp:");
		status = PltRevQAform_disp( );
	}
											   
	__DBGpr_com ("after PltRevQAform_disp:");

	/*********  Process the form gadgets **************************************/

	get_input( "Select options" );


quit:
	__DBGpr_com("quitting.");
	return status;

}

/*******************************************************
* store_rev_in_tree_manager:
*	- store the latest drawing document revision in the 
*     previous revision attrribute in tree manager
*
*******************************************************/
store_rev_in_tree_manager(sDrwRev)
IGRchar		*sDrwRev;
{
int				status, i;
IGRint			found, match;

IGRchar			sCage[5];
IGRchar			sLPDRev[20];
IGRchar			sLPDNum[20];

TGRid			mgrID;
TGRid			setID;
TGRid			treeID;

TVDctBaseInfo	baseInfo;
TVDfld			fld;

status     		= OM_S_SUCCESS;
mgrID.objid		= NULL_OBJID;
setID.objid		= NULL_OBJID;
treeID.objid	= NULL_OBJID;

  fprintf(ptr,"\nstore_rev_in_tree_manager: \n");

  /****** store the status in tree manager *******/
  
	/* get the drawing object information from ISDP */
	vdct1$GetManager(mgrID = &mgrID);

	// Do Nothing if no active manager
	if (mgrID.objid == NULL_OBJID) 
	{
		UI_status("No Tree Manager Available");
		fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
    	status = OM_E_ERROR;
		goto quit;

	}

	// Cycle through each set (GetMgrChild returns 0 when no more kids)
	for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
	{

		// Get the tree
		vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

		// Get the Plot Tree Info 
		vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
		if (strcmp(baseInfo.setType,"PlotTree") == 0)
		{
			found = TRUE;
		
			/* get the drawing number */
			vdcol$GetAttr(	objID = &treeID,
							name  = VDCT1_PLOT_ATTR_NAME_DRAWING_NUMBER,
							fld   = &fld);
			/*sprintf(sLPDNum, "%s", fld.val.txt);*/
			strncpy(sLPDNum, fld.val.txt, strlen(fld.val.txt));
			__DBGpr_str("sLPDNum =  ", sLPDNum);

			/* get the drawing rev */
			vdcol$GetAttr(	objID = &treeID,
							name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
							fld   = &fld);
			/*sprintf(sLPDRev, "%s", fld.val.txt);*/
			strncpy(sLPDRev, fld.val.txt, strlen(fld.val.txt));
			__DBGpr_str("sLPDRev =  ", sLPDRev);

			/* get the cage code */
			vdcol$GetAttr(	objID = &treeID,
							name  = VDCT1_PLOT_ATTR_NAME_CAGE_CODE,
							fld   = &fld);
			/*sprintf(sCage, "%s", fld.val.txt);*/
			strncpy(sCage, fld.val.txt, 5);
			__DBGpr_str("sCage =  ", sCage);

						  
			__DBGpr_str("sLPDNum =  ", sLPDNum);
			__DBGpr_str("sLPDRev =  ", sLPDRev);
			__DBGpr_str("sCage =  ", sCage);
			
			/* compare what we have to what the user wants */
			if( (strcmp( sLPDNum, LPD_Info.DrwNum) == 0) &&
				(strcmp( sLPDRev, LPD_Info.AimRev) == 0) &&
				(strcmp( fld.val.txt, LPD_Info.CageCode) == 0) )
			{
				/* set or update the previous revision value */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_PREVIOUS_REV,
								fld   = &fld);
				__DBGpr_str("sDrwRev =  ", sDrwRev);
				strcpy(fld.val.txt,sDrwRev);
				vdcol$UpdAttrs(objID = &treeID, cnt = 1, fld = &fld);
							
			}
			else
			{
				UI_status("No Drawing Node Found");
				fprintf(ptr,"\tNo Drawing Node Found.  Contact ISDP Administrator.\n");
				status = OM_E_ERROR;
				goto quit;

			}
		}
		else
		{
			UI_status("No PlotTree Node Available");
			fprintf(ptr,"\tNo PlotTree Node Available.  Contact ISDP Administrator.\n");
			status = OM_E_ERROR;
			goto quit;
		}
	}

quit:
	return status;
}

/*******************************************************
* get_latest_doc_rev:
*	- Check AIM to get the latest drawing document revision
*
*******************************************************/
get_latest_doc_rev()
{
int     status ;
int		chkcode;
char	sDrwRev[DRAW_REV_SZ];

sDrwRev[0] = '\0';

fprintf(ptr,"\nget_latest_doc_rev: \n");

status = 0;
chkcode = VDP_GET_LATEST_DRAW_DOC_REV;

/*
 * Send Cmd to AIM through Postman to:
 *      1. get the latest drawing document revision. 
 */

UI_status("Getting latest Drawing Rev....................");
fprintf(ptr,"\tGetting the latest Drawing Document Revision....................\n");

__DBGpr_str("LPD_Info.DrwNum  =  ", LPD_Info.DrwNum);
__DBGpr_str("LPD_Info.CageCode  =  ", LPD_Info.CageCode);

status = VDP_get_latest_doc_rev_cmd(LPD_Info.DrwNum, LPD_Info.CageCode, sDrwRev, chkcode);

__DBGpr_int("status is  =  ", status);

if (status != 0) 
{
__DBGpr_int("status is bad.  status =  ", status);

	if(status == 43)
       	{
         	UI_status("There are no existing documents.");
         	fprintf(ptr,"\tThere are no existing drawing document objects in AIM with the particular cage code, drawing number and drawing revision.  Please Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
	else
       	{
		__DBGpr_int("status is bad.  status =  ", status);
         	UI_status("Error in getting the latest drawing document revision in AIM.\n");
         	fprintf(ptr,"\tError in getting the latest drawing document revision from the AIM server.  AIM returned a default error.  Please Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
}
else
{
	
	UI_status("Got the latest revision.");
    fprintf(ptr,"\tGot the Latest Drawing Revision.  It is %s\n", sDrwRev);

	/* now store the latest revision in the drawing object in tree manager */

	__DBGpr_str("sDrwRev  =  ", sDrwRev);
	sprintf(LPD_Info.PrevRev, "%s", sDrwRev);

	__DBGpr_str("LPD_Info.PrevRev  =  ", LPD_Info.PrevRev);
	status = store_rev_in_tree_manager(sDrwRev);
}
  


quit:

  return status ;
}

/*****************************************************
* revise_draw_doc:
*	- Send a command to AIM to revise the drawing document
*
*****************************************************/
revise_draw_doc()
{

int			status;
int			chkcode;

fprintf(ptr,"\nrevise_draw_doc: \n");

status     	= OM_S_SUCCESS;
chkcode		= VDP_REVISE_DRAW_DOC;

/*
 * Send Cmd to AIM through Postman to:
 *      1. revise the drawing document.
 */

UI_status("Revising Drawing Document in AIM....................");
fprintf(ptr,"\tRevising the Drawing Document in AIM....................\n");

status = VDP_revise_doc_cmd(LPD_Info.DrwNum, LPD_Info.AimRev, LPD_Info.PrevRev, LPD_Info.CageCode, chkcode);

__DBGpr_int("status is  =  ", status);

if (status != 0) 
{
__DBGpr_int("status is bad.  status =  ", status);

	if(status == 43)
    {
       	UI_status("There are no existing documents.");
       	fprintf(ptr,"\tThere are no existing drawing document objects in AIM with the particular cage code, drawing number and drawing revision.  Please Contact your AIM administrator.\n");
     	status = OM_E_ERROR;
      	goto quit;
    }
	
	if(status == 47)
    {
       	UI_status("The document is superceded.");
       	fprintf(ptr,"\tThe drawing document is superceded in AIM.  The document may be checked out.  Please Contact your AIM administrator.\n");
     	status = OM_E_ERROR;
      	goto quit;
    }

	if(status == 48)
    {
       	UI_status("More then 1 uniqe doucment found.");
       	fprintf(ptr,"\tThere were more then 1 document found with the same cage code, drawing number and drawing revision.  Please Contact your AIM administrator.\n");
     	status = OM_E_ERROR;
      	goto quit;
    }

	if(status == 49)
    {
       	UI_status("The document or related items are not baselined.");
       	fprintf(ptr,"\tThe document or related items are not baselined.  Please baseline the drawing document and it's related items in AIM and try again.\n");
     	status = OM_E_ERROR;
      	goto quit;
    }
	else
       	{
		__DBGpr_int("status is bad.  status =  ", status);
         	UI_status("Error in revising document in AIM.\n");
         	fprintf(ptr,"\tError in revising the drawing document in AIM.  AIM returned a default error.  Please Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
}
else
{
	
	UI_status("Drawing Document Revised...");
    fprintf(ptr,"\tDrawing Document Revised...\n");
	status = OM_S_SUCCESS;
}
  

quit:

  return status;
}

/*
* form_notification:
*	- Process form commands.
*
*****************************************************/

form_notification ()
{
	IGRchar lpd_drawing_number[50];
	IGRchar lpd_drawing_rev[40];
	IGRchar cage_code[10];
	IGRchar *p;
	IGRint	status;
	int num_rows;
	int row;
	int col;
	int state;
	int			sts, msg;
	struct GRmd_env 	module_info;
	struct GRid 		window, fence;
	char 				result[64], color_table[128], seedfile[128];
	int i;
	struct GRid			temp;

	seedfile[0]	= NULL;
	color_table[0]	= NULL;
	num_rows = 0;
	row = 0;
	col = 0;
	
    status = OM_S_SUCCESS;

    switch (form_st.gadget_label) 	 /* works for all forms */
    {
      
        
		case PLTDrwDataEXIT: 
             		
	  		__DBGpr_com ("form: EXIT ");
			if(ptr)
			{
        		  fclose(ptr);
        		  ptr = NULL;
			}
         	ci$put( response = TERMINATE );
         	break;
         	
        case PLTDrwDataEXECUTE:
			__DBGpr_com ("form: EXECUTE ");
			

			status = PLTSheetProcessing_form ();
			

			break;

        case PLTDrwDataRUN: 
             		
			__DBGpr_com ("form: run");

			fprintf(ptr, "\nform: RUN\n");

			/* reset the form */
			/*FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataDRWTITLE );
            FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataAUTHFOR );
            FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataDRWDATE );
            FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataNAVSEANUM );
            FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataTEAM );
			FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataPOSTEDDATE );*/

            FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );

		
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataTYPE, 0, 0, "");
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWTITLE, 0, 0, "");
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataTEAM, 0, 0, "");
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataAUTHFOR, 0, 0, "");
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataNAVSEANUM, 0, 0, "");
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWDATE, 0, 0, "");
			FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataPOSTEDDATE, 0, 0, "");

			/* now start the run processing */
			lpd_drawing_rev[0] = '\0';
			lpd_drawing_number[0] = '\0';
			cage_code[0] = '\0';
			LPD_Info.DrwNum[0] = '\0';
			LPD_Info.AimRev[0] = '\0';
			LPD_Info.CageCode[0] = '\0';
			LPD_Info.FileType[0] = '\0';

	 		FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataDRWNUM, lpd_drawing_number );
			FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataCAGECODE, cage_code );
			FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataREV, lpd_drawing_rev );

		    /* Make sure that the user entered a drawing number and revision */		
			if ( lpd_drawing_number[0] == '\0' )
			{
               		FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Drawing Number not defined" );
               		FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );
               		break;
           	}
			if ( cage_code[0] == '\0' )
			{
               		FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Cage Code not defined" );
               		FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );
               		break;
           	}

			if ( lpd_drawing_rev[0] == '\0' )
			{
               		FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Drawing Revision not defined" );
               		FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );
               		break;
           	}
			
			/*
			if (strcmp( lpd_drawing_rev, "-") == 0)
			{
				 lpd_drawing_rev[0] == '\0';
				 sprintf ( lpd_drawing_rev, "%s", "A");
			}
			*/

			
			fprintf(ptr,"\tDocument to Find............................\n");

			sprintf ( LPD_Info.DrwNum, "%s", lpd_drawing_number);
			__DBGpr_str("LPD_Info.DrwNum =  ", LPD_Info.DrwNum);
			fprintf(ptr,"\t\tLPD_Info.DrwNum = %s \n", LPD_Info.DrwNum );

			sprintf ( LPD_Info.AimRev, "%s", lpd_drawing_rev);
			__DBGpr_str("LPD_Info.AimRev =  ", LPD_Info.AimRev);
			fprintf(ptr,"\t\tLPD_Info.AimRev = %s \n", LPD_Info.AimRev);
			
			sprintf ( LPD_Info.CageCode, "%s", cage_code);
			__DBGpr_str("LPD_Info.CageCode =  ", LPD_Info.CageCode);
			fprintf(ptr,"\t\tLPD_Info.CageCode = %s\n", LPD_Info.CageCode);

			/*state = 0;
			FIg_get_state (gPltDrawDataFrmPtr, PLTDrwDataTOGGLE, &state); 
			if (state == 0)
				  sprintf ( LPD_Info.FileType, "%s", "Diagram");
			else
				  sprintf ( LPD_Info.FileType, "%s", "Arrangement");
			*/
			
			status = check_for_drawing_doc(lpd_drawing_number, lpd_drawing_rev, cage_code);
			
			if (LPD_DOC_EXIST == FALSE)
			{
				/* enable the fields for the user to input data */
				/*FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataDRWTITLE );
				FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataAUTHFOR );
				FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataDRWDATE );
				FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataNAVSEANUM );
				FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataTEAM );
				FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataPOSTEDDATE );	*/

				/*FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );*/
			
				
			}
			else
			{
				FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );
			}
			 		
			break;
         	         	
		case PLTShtProcADDSHEET: 
             		
	  		__DBGpr_com ("form: Toggle");

			status = PLTAddSheet();

        	break;

		case PLTShtProcPOST:

			__DBGpr_com ("PLTShtProc: POST ");

			FIfld_set_text (	gPltSheetProcFrmPtr, 
								PLTShtProcMSGFLD, 
								0, 
								0, 
								"Processing requests,  please wait ...", 
								FALSE);

			status = PLTsheetprocess_request (); 

			break;

			/**  Reset the form gadgets **/
         
			FIfld_set_text (	gPltSheetProcFrmPtr, 
								PLTShtProcMSGFLD, 
								0, 
								0, 
								"Successful Completion ...", 
								FALSE);
			break;
		
		case PLTShtProcSELECTALL:
			__DBGpr_com ("PLTShtProc: Select All");
			
			num_rows = 0;
			row = 0;
			col = 0;

			FIfld_get_num_rows(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL, 
								&num_rows);

			for (row = 0; row < num_rows; row = row + 1)
			{
				
				for (col = 0; col < 5; col = col + 1)
				{
					FIfld_set_select(	gPltSheetProcFrmPtr, 
										PLTShtProc_TBL, 
										row, 
										col, 
										TRUE);
				}
			}
					
			break;

		case PLTShtProcEXIT:	

			__DBGpr_com ("PLTShtProc: Exit");
			
			/* Erase and delete the displayed form */

			if(ptr)
			{
        		  fclose(ptr);
        		  ptr = NULL;
			}
			__DBGpr_com ("deleting the forms.");

			form_PltSheetProc_displayed = FALSE;
			form_PltSheetProc_exists = FALSE;
			FIf_delete (gPltSheetProcFrmPtr);

			form_PltDrawData_displayed = FALSE;
			form_PltDrawData_exists = FALSE;
			FIf_delete (gPltDrawDataFrmPtr);

			/*ci$put( response = TERMINATE );*/
			__DBGpr_com ("reseting the stack.");
			ci$d_reset();
			ci$d_reset();
			ci$d_reset();
							
			/* make sure we save the file now */
			ci$put(cmd_key = "EXSvFl");
			ci$put(string = "y");	
			ci$put(string = "n");

			break;

	   case PLTAddSheetEXECUTE:

			LPD_ShtInfo[LPD_Sht_Index].cvprism = NULL;

			__DBGpr_com ("PLTAddSheet: EXECUTE");

			gr$gsget_fence (msg = &msg,fence_id = &temp);
			__DBGpr_int("msg for gsget_fence  =  ", msg);

			if ((msg == MSSUCC) ||(msg == OM_S_SUCCESS) )
			{
				UI_status("Retreived Fence Successfully ...");
				fprintf(ptr,"\t\t\tRetrieve Fence Successfully.\n");	

				ci$get_module_info(md_env = &module_info);

				sts = plot$get_fence_range (	msg 	= &msg, 
												module 	= &module_info, 
												fence 	= &fence, 
												window 	= &LPD_ShtInfo[LPD_Sht_Index].window, 
												world 	= LPD_ShtInfo[LPD_Sht_Index].range1, 
												view 	= &LPD_ShtInfo[LPD_Sht_Index].range1[6],
												cvprism = &LPD_ShtInfo[LPD_Sht_Index].cvprism); 
				
   					__DBGpr_int("sts for get_fence_range  =  ", sts);

					if( ! ( sts & msg & 1 ) )
					{
  						UI_status("No Active Fence ...");
						fprintf(ptr,"\t\t\tNo Active Fence.\n");
       					status = OM_E_ERROR;
        				break;
					}
					else
					{
						/* get the sheet number and description from the form */
						LPD_ShtInfo[LPD_Sht_Index].ShtNum[0] = '\0';
						LPD_ShtInfo[LPD_Sht_Index].ShtName[0] = '\0';
						LPD_ShtInfo[LPD_Sht_Index].ShtDesc[0] = '\0';

	 					FIg_get_text( gPltAddSheetFrmPtr , PLTAddSheetSHTNUM, LPD_ShtInfo[LPD_Sht_Index].ShtNum );
						FIg_get_text( gPltAddSheetFrmPtr , PLTAddSheetSHTNAME, LPD_ShtInfo[LPD_Sht_Index].ShtName );
						FIg_get_text( gPltAddSheetFrmPtr , PLTAddSheetSHTDESC, LPD_ShtInfo[LPD_Sht_Index].ShtDesc );

						/* Make sure that the user entered a sheet number and revision */		
						if ( LPD_ShtInfo[LPD_Sht_Index].ShtNum[0] == '\0' )
						{
               						FIg_set_text( gPltAddSheetFrmPtr, PLTAddSheetMSGFLD, "Sheet Number not defined" );
               						FIg_set_state_off( gPltAddSheetFrmPtr, PLTAddSheetEXECUTE );
               						break;
           					}

						/* Make sure that the user entered a sheet name and revision */		
						if ( LPD_ShtInfo[LPD_Sht_Index].ShtName[0] == '\0' )
						{
               						FIg_set_text( gPltAddSheetFrmPtr, PLTAddSheetMSGFLD, "Sheet Name not defined" );
               						FIg_set_state_off( gPltAddSheetFrmPtr, PLTAddSheetEXECUTE );
							break;
           					}

						/* remove the form */
						form_PltAddSheet_displayed = FALSE;
						form_PltAddSheet_exists = FALSE;
						FIf_delete (gPltAddSheetFrmPtr);

						/* add a blank row to the top of the list */
						FIfld_insert_blank_row(gPltSheetProcFrmPtr, PLTShtProc_TBL, 0);


						/* add the row to the sheet */
						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								0, 
								PLTShtProc_C_SHTNUM, 
								LPD_ShtInfo[LPD_Sht_Index].ShtNum, 
								FALSE);

						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								0, 
								PLTShtProc_C_NAME, 
								LPD_ShtInfo[LPD_Sht_Index].ShtName, 
								FALSE);

						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								0, 
								PLTShtProc_C_DESC, 
								LPD_ShtInfo[LPD_Sht_Index].ShtDesc, 
								FALSE);


						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								0, 
								PLTShtProc_C_STATUS, 
								"NOT POSTED", 
								FALSE);

						FIfld_set_text(	gPltSheetProcFrmPtr, 
								PLTShtProc_TBL,
								0, 
								PLTShtProc_C_DATE, 
								"", 
								FALSE);

						/* increase global counter */
						LPD_Sht_Index = LPD_Sht_Index + 1;

						FIg_set_state_off( gPltSheetProcFrmPtr, PLTShtProcADDSHEET );


					}   


			}

			break;

	   case PLTAddSheetEXIT:	

			__DBGpr_com ("PLTAddSheet: Exit");
			
			/* Erase and delete the displayed form */

			__DBGpr_com ("deleting the add sheet form.");

			form_PltAddSheet_displayed = FALSE;
			form_PltAddSheet_exists = FALSE;
			FIf_delete (gPltAddSheetFrmPtr);

			break;

		case PLTRevQAEXIT:	

			__DBGpr_com ("PLTRevQA: Exit");
			
			/* Erase and delete the displayed form */

			__DBGpr_com ("deleting the revision prompt form.");

			form_PltRevQA_displayed = FALSE;
			form_PltRevQA_exists = FALSE;
			FIf_delete (gPltRevQAFrmPtr);

			/* reset the run button */
			FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );

			break;

		case PLTRevQAYES:	

			__DBGpr_com ("PLTRevQA: YES");
			
			/* the user wants to revise the document */

			__DBGpr_com ("the user wants to revise the document.");

			if( gYres == 0)
			{
				strcpy( gMsg_Str, "You Hit YES! are you sure?");
				gYres = 1;
			}
			else
			{
				strcpy( gMsg_Str, "OK I understand");
				gYres = 0;

				/* invoke the get latest revision command in aim */
				status = get_latest_doc_rev();

				if (status != OM_S_SUCCESS)
				{
					__DBGpr_com ("status is bad:");
					return status;
				}

				/* now invoke the revision command in aim to revise the doc */
				status = revise_draw_doc();

				if (status != OM_S_SUCCESS)
				{
					__DBGpr_com ("status is bad:");
					return status;
				}
				else
				{

					/* Erase and delete the displayed form */

					__DBGpr_com ("deleting the revision prompt form.");

					form_PltRevQA_displayed = FALSE;
					form_PltRevQA_exists = FALSE;
					FIf_delete (gPltRevQAFrmPtr);

					/* enable the execute button on the draw data form */
					FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );

				}


			}
			
			FIfld_set_text( gPltRevQAFrmPtr, PLTRevQAMESSAGET , 0, 0 , gMsg_Str, FALSE );
			message(gMsg_Str);
			//printf("%s\n", gMsg_Str );
			__DBGpr_str ("gMsg_Str", gMsg_Str);
			
			break;

		case PLTRevQANO:	

			__DBGpr_com ("PLTRevQA: NO");
			
			/* the user does not want to revise the document */

			__DBGpr_com ("the user does not want to revise the document.");

			if( gNres == 0)
			{
				strcpy( gMsg_Str, "You Hit NO! are you sure?");
				gNres = 1;
			}
			else
			{
				strcpy( gMsg_Str, "OK I understand");
				gNres = 0;

				/* Erase and delete the displayed form */

				__DBGpr_com ("deleting the revision prompt form.");

				form_PltRevQA_displayed = FALSE;
				form_PltRevQA_exists = FALSE;
				FIf_delete (gPltRevQAFrmPtr);

				/* reset the run button */
				FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );

			}
			FIfld_set_text( gPltRevQAFrmPtr, PLTRevQAMESSAGET , 0, 0 , gMsg_Str, FALSE );
			message(gMsg_Str);
			//printf("%s\n", gMsg_Str );
			__DBGpr_str ("gMsg_Str", gMsg_Str);
			
			break;


       }  /** switch **/
       
       #ifdef DEBUG
       printf("out of switch\n");
       #endif

}

/********************************************************/

/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/* Post Plot functions */

/*****************************************************
* verify_plot_tree:
*	- Verify a Plot Tree Exist for the current file.
*
*****************************************************/

verify_plot_tree( retCode )
int	*retCode;
{
int				i, status ;
TVDctBaseInfo	baseInfo;
IGRint			found;
TGRid			mgrID;
TGRid			setID;
TGRid			treeID;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;
found		= FALSE;

mgrID.objid  = NULL_OBJID;
setID.objid  = NULL_OBJID;
treeID.objid = NULL_OBJID;



	fprintf(ptr,"verify_plot_tree: \n");

	// get the manager
	vdct1$GetManager(mgrID = &mgrID);

	// Do Nothing if no active manager
	if (mgrID.objid == NULL_OBJID) 
	{
		UI_status("No Tree Manager Available");
		fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
      	status = OM_E_ERROR;
        goto quit;

	}

	vdobj$Print(objID = &mgrID);

	// Cycle through each set (GetMgrChild returns 0 when no more kids)
	for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
	{

		// Get the tree
		vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

		// Print it
		//printPlotTree(&treeID);
		
		// Make sure it s plot tree
		vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
		if (strcmp(baseInfo.setType,"PlotTree") == 0)
		{
			found = TRUE;
		}	
	}	
	
	if ( found == FALSE )
	{
		UI_status("No PlotTree Defined");
		fprintf(ptr,"\tNo PlotTree Defined.  Contact ISDP Administrator.\n");
	  	status = OM_E_ERROR;
		goto quit;
	}

	vdobj$Print(objID = &treeID);

    	
quit:
  return status ;
}


/*****************************************************
* verify_connect_postman:
*	- Verify the connection to AIM.
*
*****************************************************/

verify_connect_postman( retCode )
int	*retCode;
{
int		i, status ;

int		conn_status;
int		stat;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;

conn_status	= 0;
stat		= 0;

fprintf(ptr,"verify_connect_postman: \n");

if( IsPmeEnabled() == FALSE )
{
	UI_status("AIM server connection required");
	fprintf(ptr,"\tAIM server connection required.\n");
      	status = OM_E_ERROR;
        goto quit;
}

fprintf(ptr,"\tAIM server connection is established.\n");

quit:
  return status ;
}

/*****************************************************
* determine_AIM:
*	- Find out what AIM are we using.
*
*****************************************************/

determine_AIM( retCode )
int	*retCode;
{
int			status ;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;

fprintf(ptr,"\ndetermine_AIM: \n");

if( WhichAim() == PME)
{
	UI_status("This process does not support PME.");
	fprintf(ptr,"\tThis process does not support PME.\n");
      	status = OM_E_ERROR;
        goto quit;
}

if( WhichAim() == SIR)
{
	UI_status("AIM server is SIR");
	fprintf(ptr,"\tAIM server is SIR\n");
      	status = OM_S_SUCCESS;
        goto quit;
}


quit:

  return status ;
}

/*****************************************************
* get_ctx_id:
*	- get the context id from the file collector.
*
*****************************************************/

/***
get_ctx_id( retCode )
int	*retCode;
{
int			status ;
OMuword         	curOs;
IGRchar         	DirName[DI_PATH_MAX];
IGRchar         	CollName[DI_PATH_MAX];
struct GRid     	CollId;
struct ACrg_coll	coll;
IGRlong         	*msg;

*retCode	= OM_S_SUCCESS  ;
status		= OM_S_SUCCESS ;


fprintf(ptr,"\nget_ctx_id: \n");

ex$get_cur_mod( osnum = &curOs );

status = di$give_pathname(	osnum           = curOs,
                                pathname        = DirName );

sprintf( CollName,"%s%s%s", DirName, SIR_GLOBAL_DIR, SIR_REQ_DATA );

CollId.objid = NULL_OBJID;

status = VDgetVdCollId ( &msg, CollName, TRUE, FALSE, &CollId );

if (CollId.objid == NULL_OBJID )
{
	UI_status("AIM Required Data not set...");
	fprintf(ptr,"\tSIR Required Data not set. \n");
      	status = OM_E_ERROR;
   	return status;
}

strcpy( coll.name, SIR_CNTX_ID  );

ci$send ( msg = message ACrg_collect.ACget_named_attribute(
		 msg,
		 &coll ),
		 targetid = CollId.objid,
		 targetos = CollId.osnum);

strcpy( E_FileInfo.ctxid, coll.desc.value.att_txt );
fprintf(ptr,"\tContext ID: %s \n", E_FileInfo.ctxid);
UI_status("AIM Data is Set.");

quit:

  return status ;
}
***/

/*******************************************************
* is_ctx_checked_out_in_AIM:
*	- Check AIM to see if the context from the Default Data
*	  information has a version that is checked out.  If so,
*	  display an error message to the user and terminate the
*	  execution of the ppl.
*
*     i.e. the context must be checked in on the AIM server
*          before the extraction process will continue.
*
*******************************************************/

/*
is_ctx_checked_out_in_AIM( retCode )
int	*retCode ;
{
int     status ;
int	chkcode;

fprintf(ptr,"\nis_ctx_checked_out_in_AIM: \n");

status = 0;
chkcode = VDP_IS_CTX_CHECKED_OUT;

//
// Send Cmd to AIM through Postman to:
//       1. see if the context is checked in on the AIM server. 
//

UI_status("Verifying context is checked in on AIM server....................");
fprintf(ptr,"\tVerifying context is checked in on AIM server....................\n");

status = VDP_send_ctx_verify_cmd(E_FileInfo.ctxid , chkcode);

__DBGpr_int("status is  =  ", status);

if (status != 0) 
{
__DBGpr_int("status is bad.  status =  ", status);

	if(status == 40)
       	{
         	UI_status("The context is not checked in.");
         	fprintf(ptr,"\tThe context that is associated with the current model file MDC in AIM is not checked in on the AIM server.  Please check the context in before processing an automated extraction.  (i.e The context is the System, SubSystem, Zone, or Zone System that is associated with this MDC.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
	else
       	{
		__DBGpr_int("status is bad.  status =  ", status);
         	UI_status("Error in verifying context checked in, in AIM.\n");
         	fprintf(ptr,"\tError in verifying that the context is checked in on the AIM server.  AIM returned a default error.  Please Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
}
else
{
	UI_status("The context is checked in.");
        fprintf(ptr,"\tThe context is checked in on the AIM server.\n");
	status = OM_S_SUCCESS;
}
  


quit:

  return status ;
}
*/

/*******************************************************
* is_ctx_in_vault_in_AIM:
*	 - Check AIM to see if the context from the Default Data
*	   information is in a vault.  If not, 
*	   display an error message to the user and terminate the
*	   execution of the ppl.
*	
*	   i.e. the context must be in a vault in AIM before the
*	        extraction process will continue.
*
*******************************************************/
/*
is_ctx_in_vault_in_AIM( retCode )
int	*retCode ;
{
int     status ;
int	chkcode;

chkcode = VDP_IS_CTX_IN_VAULT;

fprintf(ptr,"\nis_ctx_in_vault_in_AIM: \n");

//*
// * Send Cmd to AIM through Postman to:
// *      1. post the files into AIM. 
// 

UI_status("Verifying context is in a vault.....................");
fprintf(ptr,"\tVerifying context is in a vault on the AIM server....................\n");

status = VDP_send_ctx_verify_cmd(E_FileInfo.ctxid, chkcode);

__DBGpr_int("status is  =  ", status);

if (status != 0) 
{
__DBGpr_int("status is bad.  status =  ", status);

	if(status == 41)
       	{
         	UI_status("The context is not in an AIM vault");
         	fprintf(ptr,"\tThe context that is associated with the current model file MDC is not in an AIM vault.  Please transfer the context to an AIM vault before processing an automated extraction.  (i.e The context is the System, SubSystem, Zone, or Zone System that is associated with this MDC.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
	else
       	{
         	UI_status("Error in verifying context in AIM vault.\n");
         	fprintf(ptr,"\tError in verifying that the context is in an AIM. vault.   AIM returned a default error.  Please Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
}
else
{
	UI_status("The context is in a vault.");
        fprintf(ptr,"\tThe context is in a vault on the AIM server.\n");
	status = OM_S_SUCCESS;
}

quit:

  return status ;

}
*/

/*******************************************************
* check_for_drawing_doc:
*	 - Check AIM to see if the LPD Document in AIM already exist, if so
*	   it's document information is returned.
*
*******************************************************/

check_for_drawing_doc( lpd_drawing_number, lpd_drawing_rev, cage_code )
IGRchar *lpd_drawing_number;
IGRchar *lpd_drawing_rev;
IGRchar	*cage_code;
{
int		status, i, code;

/*TLS 10-16-01 TR 5523 */
int 		j, k, number;
char 		LpdDesc[50];
char 		LpdtempDesc[2];
char 		LpdValue[1];
char 		*lpdvalue[12];

TVDctBaseInfo	baseInfo;
TVDfld		fld;

IGRint		found, match;

TGRid		mgrID;
TGRid		setID;
TGRid		treeID;

IGRchar		sCage[5];
IGRchar		sLPDRev[20];
IGRchar		sLPDNum[20];

status		= OM_S_SUCCESS ;
found		= FALSE;
match		= FALSE;

mgrID.objid	= NULL_OBJID;
setID.objid	= NULL_OBJID;
treeID.objid	= NULL_OBJID;


fprintf(ptr,"\ncheck_for_drawing_doc: \n");

UI_status("Verifying Drawing Document exist.....................");
fprintf(ptr,"\tVerifying Drawing Document exist....................\n");

__DBGpr_str("lpd_drawing_number =  ", lpd_drawing_number);
__DBGpr_str("lpd_drawing_rev =  ", lpd_drawing_rev);
__DBGpr_str("cage_code =  ", cage_code);

LPD_Info.OBID[0] = '\0';
LPD_Info.DrwTitle[0] = '\0';
LPD_Info.AbbName[0] = '\0';
LPD_Info.DrwDate[0] = '\0';
LPD_Info.NavSeaDrwNum[0] = '\0';

/*TLS 10-16-01 TR 5523 */
j	= 0;
k	= 0;
number 	= 0;

/* clear the status field */
FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "" );

/* get the drawing object information from ISDP */
	// get the manager
	vdct1$GetManager(mgrID = &mgrID);

	// Do Nothing if no active manager
	if (mgrID.objid == NULL_OBJID) 
	{
		UI_status("No Tree Manager Available");
		fprintf(ptr,"\tNo Tree Manager Available.  Contact ISDP Administrator.\n");
      	status = OM_E_ERROR;
        goto quit;

	}

	// Cycle through each set (GetMgrChild returns 0 when no more kids)
	for(i = 0; vdct$GetMgrChild(objID = &mgrID, nth = i, outID = &setID); i = i + 1) 
	{

		// Get the tree
		vdct1$GetSetTree(setID = &setID, treeID = &treeID);	/* treeID is the drawing id */

		// Get the Plot Tree Info and break 
		vdct1$GetBaseInfo(objID = &treeID, baseInfo = &baseInfo);
		if (strcmp(baseInfo.setType,"PlotTree") == 0)
		{
			found = TRUE;

			/* get the drawing number */
			vdcol$GetAttr(	objID = &treeID,
							name  = VDCT1_PLOT_ATTR_NAME_DRAWING_NUMBER,
							fld   = &fld);
			/*sprintf(sLPDNum, "%s", fld.val.txt);*/
			strncpy(	sLPDNum, fld.val.txt, strlen(fld.val.txt)); 
			/*sLPDNum[strlen(sLPDNum)] = '\0';*/
			__DBGpr_str("sLPDNum =  ", sLPDNum);

			/* get the drawing rev */
			vdcol$GetAttr(	objID = &treeID,
							name  = VDCT1_PLOT_ATTR_NAME_DRAWING_REV,
							fld   = &fld);
			/*sprintf(sLPDRev, "%s", fld.val.txt);*/
			strncpy(sLPDRev, fld.val.txt, strlen(fld.val.txt));
			/*sLPDRev[strlen(sLPDRev)] = '\0';*/
			__DBGpr_str("sLPDRev =  ", sLPDRev);

			/* get the cage code */
			vdcol$GetAttr(	objID = &treeID,
							name  = VDCT1_PLOT_ATTR_NAME_CAGE_CODE,
							fld   = &fld);
			/*sprintf(sCage, "%s", fld.val.txt);*/
			__DBGpr_str("fld.val.txt =  ", fld.val.txt);
			strncpy(sCage, fld.val.txt, 5);
			/*sCage[strlen(sCage)] = '\0';*/
			__DBGpr_str("sCage =  ", sCage);

			__DBGpr_com("********************");
			__DBGpr_str("sCage =  ", sCage);
			__DBGpr_str("sLPDNum =  ", sLPDNum);
			__DBGpr_str("sLPDRev =  ", sLPDRev);
			__DBGpr_str("lpd_drawing_rev =  ", lpd_drawing_rev);
			   
			/* compare what we have to what the user wants */
			if( (strcmp( sLPDNum, lpd_drawing_number) == 0)  &&
				(strcmp( sLPDRev, lpd_drawing_rev) == 0) &&
				(strcmp( fld.val.txt, cage_code) == 0) )			 
			{
				/*	get the rest of the attributes from the manager and store
				 *	them in the global structure. 
				 */

				__DBGpr_com("Drawing Document Found.");
				fprintf(ptr,"\n\tDrawing Document Found....................\n");
				
				/* get the drawing type */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_DRAWING_TYPE,
								fld   = &fld);
				sprintf(LPD_Info.FileType, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.FileType =  ", LPD_Info.FileType);
				fprintf(ptr,"\t\tLPD_Info.FileType: %s\n", LPD_Info.FileType);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataTYPE, 0 , 0 , LPD_Info.FileType, FALSE );
				
				/* get the drawing title */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_DRAWING_TITLE,
								fld   = &fld);
				sprintf(LPD_Info.DrwTitle, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.DrwTitle =  ", LPD_Info.DrwTitle);
				fprintf(ptr,"\t\tLPD_Info.DrwTitle: %s\n", LPD_Info.DrwTitle);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWTITLE, 0 , 0 , LPD_Info.DrwTitle, FALSE );
				
				/* get the drawing title */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_TEAM,
								fld   = &fld);
				sprintf(LPD_Info.Team, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.Team =  ", LPD_Info.Team);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataTEAM, 0 , 0 , LPD_Info.Team, FALSE );
				fprintf(ptr,"\t\tLPD_Info.Team: %s\n", LPD_Info.Team);

				/* get the abb. name 
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_ABBNAME,
								fld   = &fld);
				sprintf(LPD_Info.AbbName, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.AbbName =  ", LPD_Info.AbbName);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataABBNAME, 0 , 0 , LPD_Info.AbbName, FALSE );
				fprintf(ptr,"\t\tLPD_Info.AbbName: %s\n", LPD_Info.AbbName);
				*/

				/******************************************
				 * TLS 10-16-01 Fix for Shuttle II, Tr 5523.
				 * Added code to retireve the HAP value from the file instead of tree manager.
				 ******************************************
				 */

				/********** TLS Commented out and replaced with TR 5523 fix
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_AUTHORIZE_FOR,
								fld   = &fld);
				sprintf(LPD_Info.AuthorizeFor, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.AuthorizeFor =  ", LPD_Info.AuthorizeFor);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataAUTHFOR, 0 , 0 , LPD_Info.AuthorizeFor, FALSE );
				fprintf(ptr,"\t\tLPD_Info.AuthorizeFor: %s\n", LPD_Info.AuthorizeFor);
				*************/

				//TLS TR 5523
				//get the HAP value from the file.

			        LpdDesc[0] = '\0';

        			status = PDMReadHullApp(E_FileInfo.catalog, E_FileInfo.partno,
                                        		E_FileInfo.revision, lpdvalue);
        			for(j = 0; j <= 11; j = j + 1)
        			{
                			LpdValue[0] = '\0';
                			strncpy(LpdValue, lpdvalue[j], 1);

          				if(!strcmp(LpdValue,"Y"))
          				{

           					number  = number + 1;
            					sprintf(LpdtempDesc,"%d",k+17);

                   				if(number>1)
             					{
                   					strcat(LpdDesc, ",");
             					}
                  				strcat(LpdDesc, LpdtempDesc);
                   				if(!strcmp(LpdtempDesc, "28"))
                    					strcat(LpdDesc, "AF");

                  			}

          				k = k + 1;
    				}

				/* now store the HAP value in the global constant so it can be sent to AIM. */
				sprintf(LPD_Info.AuthorizeFor, "%s", LpdDesc);
                                __DBGpr_str("LPD_Info.AuthorizeFor =  ", LPD_Info.AuthorizeFor);
                                FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataAUTHFOR, 0 , 0 , LPD_Info.AuthorizeFor, FALSE );
                                fprintf(ptr,"\t\tLPD_Info.AuthorizeFor: %s\n", LPD_Info.AuthorizeFor);

				/********* TLS - Done with TR 5523 ***************/

				/* get the navsea drawing number*/
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_NAVSEA_DRAWING_NUMBER,
								fld   = &fld);
				sprintf(LPD_Info.NavSeaDrwNum, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.NavSeaDrwNum =  ", LPD_Info.NavSeaDrwNum);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataNAVSEANUM, 0 , 0 , LPD_Info.NavSeaDrwNum, FALSE );
				fprintf(ptr,"\t\tLPD_Info.NavSeaDrwNum: %s\n", LPD_Info.NavSeaDrwNum);


				/* get the drawing date */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_DRAWING_DATE,
								fld   = &fld);
				sprintf(LPD_Info.DrwDate, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.DrwDate =  ", LPD_Info.DrwDate);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWDATE, 0 , 0 , LPD_Info.DrwDate, FALSE );
				fprintf(ptr,"\t\tLPD_Info.DrwDate: %s\n", LPD_Info.DrwDate);


				/* get the posted date */
				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_POSTING_DATE,
								fld   = &fld);
				sprintf(LPD_Info.PostedDate, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.PostedDate =  ", LPD_Info.PostedDate);
				FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataPOSTEDDATE, 0 , 0 , LPD_Info.PostedDate, FALSE );
				fprintf(ptr,"\t\tLPD_Info.PostedDate: %s\n", LPD_Info.PostedDate);
				

				vdcol$GetAttr(	objID = &treeID,
								name  = VDCT1_PLOT_ATTR_NAME_PREVIOUS_REV,
								fld   = &fld);
				sprintf(LPD_Info.PrevRev, "%s", fld.val.txt);
				__DBGpr_str("LPD_Info.PrevRev =  ", LPD_Info.PrevRev);
				fprintf(ptr,"\t\tLPD_Info.PrevRev: %s\n", LPD_Info.PrevRev);


				match = TRUE;
			}
			else
			{
				match = FALSE;
			}	
		}	
	}	
	
	if ( found == FALSE )
	{
		UI_status("No PlotTree Defined");
		fprintf(ptr,"\tNo PlotTree Defined.  Contact ISDP Administrator.\n");
	  	status = OM_E_ERROR;
		goto quit;
	}

	if ( match == FALSE )
	{
		UI_status("No Drawing Object Found With Given ID.");
		fprintf(ptr,"\tNo Drawing Object Found With Given ID.\n");
	  	FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Drawing Object Not Found...Try Again" );
		FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );
		FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWNUM, 0 , 0 , "", FALSE );
		goto quit;
	}
	else
	{
		
		status = OM_S_SUCCESS;
		code = 0;
		code = VDP_DOES_DRWDOC_EXIST; 

		__DBGpr_com("verifying in AIM.");
		//printf("verifying in AIM.");
		
		status = VDP_send_lpddoc_verify_cmd(lpd_drawing_number, lpd_drawing_rev, cage_code, code );

		if (status != 0) 
		{
			__DBGpr_int("status is bad.  status =  ", status);
			//printf("status is bad.  status = %d\n", status);

			if(status == 42)
       			{
         			UI_status("Unique Object Exist.");
         			fprintf(ptr,"Unique Object Exist.\n");
       	 			status = OM_S_SUCCESS;
       			}

			if(status == 43)
       			{
         			UI_status("No Document Exist.");
         			fprintf(ptr,"No Document Exist.\n");
       	 			status = OM_S_SUCCESS;
       			}

			if(status == 45)
			{
				/*
         			UI_status("Revise Attempt.  Not Suported.");
         			fprintf(ptr,"Revise Attempt.  Not Suported.\n");
         			status = OM_E_ERROR;
				*/

         			UI_status("Drawing Document Needs Revising.");
         			fprintf(ptr,"Drawing Document Needs Revising.\n");
				status = prompt_to_revise();
			}

			if(status == 46)
			{
				UI_status("Drawing Document is Frozen.");
         			fprintf(ptr,"Drawing Document is Frozen.\n");
       	 			status = OM_S_SUCCESS;
				//disable the execute button
				FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Drawing Document is Frozen." );
				FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );
				goto quit;
			}
			
			if(status == 47)
			{
				UI_status("Drawing Document is Superceded.");
         			fprintf(ptr,"Drawing Document is Superceded.\n");
       	 			status = OM_S_SUCCESS;
				//disable the execute button
				FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Drawing Document is Superceded." );
				FIg_disable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );
				goto quit;
			}
		}
		else 
		{
			status = OM_S_SUCCESS;
       			UI_status("Verification was Successful.....................\n");
       			fprintf(ptr,"Verification was Successful.....................\n");
		}              

		if( status != OM_S_SUCCESS )
		{
			//printf("status is bad....  status = %d\n", status);
			__DBGpr_int("status is bad... status = ", status);

			/* disable the run button and show error message */
			FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "Drawing Document Revision NOT Supported." );
			FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );
			UI_status("Drawing Document Revision NOT Supported.");
			fprintf(ptr,"\tDrawing Document Revision NOT Supported.  Modify the drawing object revision attribute for the file in Tree Manager and restart the command.\n"); 
			status = OM_E_ERROR;
			goto quit;
		}
	}

/* TLS - hard coded for now 
FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataTYPE, 0 , 0 , "Diagram", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataTYPE, LPD_Info.FileType );
__DBGpr_str("LPD_Info.FileType =  ", LPD_Info.FileType);
fprintf(ptr,"\t\tLPD_Info.FileType: %s\n", LPD_Info.FileType);

FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWTITLE, 0 , 0 , "Tawana's Document", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataDRWTITLE, LPD_Info.DrwTitle );
__DBGpr_str("LPD_Info.DrwTitle =  ", LPD_Info.DrwTitle);
fprintf(ptr,"\t\tLPD_Info.DrwTitle: %s\n", LPD_Info.DrwTitle);

FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataTEAM, 0 , 0 , "TEAM 17", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataTEAM, LPD_Info.Team );
__DBGpr_str("LPD_Info.Team =  ", LPD_Info.Team);
fprintf(ptr,"\t\tLPD_Info.Team: %s\n", LPD_Info.Team);

FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataABBNAME, 0 , 0 , "TLS Doc", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataABBNAME, LPD_Info.AbbName );
__DBGpr_str("LPD_Info.AbbName =  ", LPD_Info.AbbName);
fprintf(ptr,"\t\tLPD_Info.AbbName: %s\n", LPD_Info.AbbName);


FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataNAVSEANUM, 0 , 0 , "1128", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataNAVSEANUM, LPD_Info.NavSeaDrwNum );
__DBGpr_str("LPD_Info.NavSeaDrwNum =  ", LPD_Info.NavSeaDrwNum);
fprintf(ptr,"\t\tLPD_Info.NavSeaDrwNum: %s\n", LPD_Info.NavSeaDrwNum);


FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataDRWDATE, 0 , 0 , "07-12-2000", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataDRWDATE, LPD_Info.DrwDate );
__DBGpr_str("LPD_Info.DrwDate =  ", LPD_Info.DrwDate);
fprintf(ptr,"\t\tLPD_Info.DrwDate: %s\n", LPD_Info.DrwDate);


FIfld_set_text ( gPltDrawDataFrmPtr, PLTDrwDataPOSTEDDATE, 0 , 0 , "", FALSE );
FIg_get_text( gPltDrawDataFrmPtr , PLTDrwDataPOSTEDDATE, LPD_Info.PostedDate );
__DBGpr_str("LPD_Info.PostedDate =  ", LPD_Info.PostedDate);
fprintf(ptr,"\t\tLPD_Info.PostedDate: %s\n", LPD_Info.PostedDate);
*/


__DBGpr_str("LPD_Info.Team =  ", LPD_Info.Team);
__DBGpr_str("LPD_Info.FileType =  ", LPD_Info.FileType);
__DBGpr_str("LPD_Info.DrwNum =  ", LPD_Info.DrwNum);
__DBGpr_str("LPD_Info.AimRev =  ", LPD_Info.AimRev);
__DBGpr_str("LPD_Info.CageCode =  ", LPD_Info.CageCode);

/* If any of the requird fields are empty, then disable the execute button and show error message */
if (	( LPD_Info.Team[0] == '\0') ||
		( LPD_Info.FileType[0] == '\0') ||
		( LPD_Info.DrwNum[0] == '\0') ||
		( LPD_Info.AimRev[0] == '\0') ||
		( LPD_Info.CageCode[0] == '\0') )
{

	FIg_set_text( gPltDrawDataFrmPtr, PLTDrwDataMSGFLD, "All Required Fields Not Set for Drawing." );
    FIg_set_state_off( gPltDrawDataFrmPtr, PLTDrwDataRUN );
	UI_status("All Required Fields Not Set for Drawing Object.");
	fprintf(ptr,"\tAll Required Fields Not Set in Drawing Object.  Modify the drawing object for the file in Tree Manager and restart the command.\n"); 
	status = OM_E_ERROR;
	goto quit;

}
else
{
	FIg_enable( gPltDrawDataFrmPtr, PLTDrwDataEXECUTE );
}


quit:

  return status ;

}


/*******************************************************
* check_out_in_doc:
*	- Check In/Out the plot file 
*******************************************************/

check_out_in_doc( plotfilename, preference, classname1 )	
char *plotfilename;
char *preference;
char *classname1;
{
int status ;
int	chkcode;
char pref[10];

fprintf(ptr,"\ncheck_out_in_doc: \n");

status = 0;

chkcode = VDP_CHECK_OUT_IN_DATAITEM;

UI_status("Checking out/in plotfile on AIM server....................");
fprintf(ptr,"\tChecking out/in plotfile on AIM server....................\n");

status = VDP_send_file_check_out_in(plotfilename, classname1, preference, chkcode);

__DBGpr_int("status is  =  ", status);

if (status != 0) 
{
	__DBGpr_int("status is bad.  status =  ", status);

	if(status == 40)
       	{
         	UI_status("The dataitem is not checked in.");
         	fprintf(ptr,"\tThe dataitem is not checked in or is not found on the AIM server.  Please Contact your AIM Administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
	else
       	{
			__DBGpr_int("status is bad.  status =  ", status);
         	UI_status("Error in checking out/in dataitem in AIM.\n");
         	fprintf(ptr,"\tError in checking out/in dataitem in AIM.  Please Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
        	goto quit;
       	}
}
else
{
	UI_status("DataItem is Checked Out/In.");
    fprintf(ptr,"\tDataItem is Checked Out/In.\n");
	status = OM_S_SUCCESS;
}
  


quit:

  return status ;
}



/*******************************************************
* get_file_info:
*	- Get the filename, catalog, part number, and revision information 
*	  about the file. 
*
*******************************************************/

get_file_info( retCode )
int	*retCode ;
{
int           	i, status, ch ;
char		*temp,*tmpfile, temp1[128]; 
char            cur_filedescr[OM_K_MAXOSNAME_LEN];


*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;
temp		= NULL;
tmpfile         = NULL;
ch              = '/';


fprintf(ptr,"\nget_file_info: \n");

/* Get current filename */
ex$filename( name=cur_filedescr, len=OM_K_MAXOSNAME_LEN );
fprintf(ptr, "\tlocal file: %s\n", cur_filedescr);

temp = strrchr(cur_filedescr, ch);
sprintf(temp1,"%s", temp);
tmpfile = strtok(temp1, "/");
sprintf(cur_filedescr,"%s", tmpfile);


sprintf(E_FileInfo.filename, "%s", cur_filedescr);


/* get the pdm catalog, part number and revision */
status = PDMGetPartInfoGivenFileName(	E_FileInfo.filename, 
					E_FileInfo.catalog, 
					E_FileInfo.partno, 
					E_FileInfo.revision);
 
fprintf(ptr,"\tPDM filename: %s \n", E_FileInfo.filename);
fprintf(ptr,"\tPDM catalog: %s \n", E_FileInfo.catalog);
fprintf(ptr,"\tPDM partno: %s \n", E_FileInfo.partno);
fprintf(ptr,"\tPDM revision: %s \n", E_FileInfo.revision);

/* 
   TLS 10-16-01 TR 5523 
   This must be a valid PDU part now that we are getting the HAP value from the file. 
*/
if( 	( E_FileInfo.filename[0] == '\0' ) || 
	( E_FileInfo.catalog[0] == '\0' )  || 
	( E_FileInfo.partno[0] == '\0' )   || 
	( E_FileInfo.revision[0] == '\0')   )
{
	UI_status("Part Is Not A Valid PDU Part...View Log File.");
	fprintf(ptr,"PDU Data Is Invalid.  Please make sure that the part is a valid PDU part.\n");
	fprintf(ptr,"Please make sure that the part is checked into the PDU database.\n");
      	status = OM_E_ERROR;
        goto quit;
}


UI_status("Got the PDM File Info.");

quit:

  return status ;
}

/*******************************************************
* get_server_name:
*	- Get the AIM server name that we are connected to.
*
*******************************************************/

get_server_name( retCode )
int	*retCode ;
{
int           	i, status, ch ;
char            aim_user[50], aim_server[25], aim_env[15];

*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;

fprintf(ptr, "\nget_server_name:\n");

VDPGetAimInfo(aim_user, aim_server, aim_env);

fprintf(ptr,"\tAIM Server: %s\n", aim_server);
sprintf(E_FileInfo.server, "%s", aim_server);

fprintf(ptr,"\tAIM Server: %s\n", E_FileInfo.server);

UI_status("Got the AIM Server File Info.");

quit:

  return status ;
}

/*******************************************************
* get_ref_info1
*	- Get the reference file informaton.
*
*******************************************************/
int  get_ref_info1( mod_env, refcount, reftab )
struct GRmd_env         *mod_env;
IGRlong                 *refcount;
struct PLT_reffile      **reftab;
{
long            sts, status;
int		sts1;	
OM_S_OBJID      Super_id;
IGRshort        count_nested;
GRobjid         *objlist;
GRspacenum      *oslist;
int             on_off;
IGRint          i,j;
IGRint          msg;
IGRlong         count;
IGRulong        prop_mask, props;
unsigned short  properties;
struct GRobj_info       refinfo;
struct PLT_reffile      *curref, *ref;
struct GRid     ref_object;
IGRushort       PLTproperties;

  objlist = (GRobjid *)(NULL);
  oslist  = (GRspacenum *)(NULL);
  *refcount = 0;
  count = 0;

  status = ex$get_objid_from_NOD(
                        NODname         = "IGENOD",
                        objname         = "Ref Mgr",
                        pobjid          = &Super_id,
                        modid           = mod_env->md_id.objid,
                        mod_osnum       = mod_env->md_id.osnum);
  if(!(status&1)) goto quit ;

  prop_mask = 0;
  count_nested = 0;
  status = ci$send(msg     = message Super_rfmgr.GRget_channel_count
                                   (&sts, &prop_mask, &count_nested, &count),
          targetid = Super_id,
          targetos = mod_env->md_id.osnum );

  if(!(status&1)) goto quit ;

  __DBGpr_int("channel count =", count);

  i = (int)count;
  objlist = om$calloc( num = i, structure = GRobjid );
  oslist  = om$calloc( num = i, structure = GRspacenum );

  prop_mask = 0; count_nested = 0;
  status =
  ci$send(msg      = message Super_rfmgr.GRget_channel_objects
                                     (&sts, &prop_mask, &count_nested, &count,
                                      objlist, oslist, &count),
          targetid = Super_id,
          targetos = mod_env->md_id.osnum );
  if(!(status&1)) goto quit ;

  i = (int) count;
  *reftab = om$calloc( num = i, structure = struct PLT_reffile );

  __DBGpr_int(" Channel objects retrieved ", count);

  curref = *reftab;
  *refcount = count;
  j = 0;
  for( i=0; i<count ; i = i + 1 ) 
  {
    status =
    ci$send(msg      = message GRreffile.GRgetobjinfo( &sts, &refinfo ),
            targetid = objlist[i],
            targetos = oslist[i] );
    if(!(status&1)) continue;

    status =
    ci$send(msg      = message GRreffile.GRgetenvironment
                                          ( &sts, mod_env, &(curref->md_env) ),
            targetid = objlist[i],
            targetos = oslist[i] );
    if(!(status&sts&1)) continue;

    curref->osnum = curref->md_env.md_id.osnum;

    j = strlen (refinfo.type);
    for ( i=j; i>0; i = i - 1 )
    {
    	if( refinfo.type[i] == ',' )
        {
            refinfo.type[i] = '\0';
            break;
        }
    }

    strcpy( curref->ref_name, refinfo.type );
    curref->ctx_id.objid = objlist[i];
    curref->ctx_id.osnum = oslist[i];

    __DBGpr_str(" refinfo.type ", refinfo.type );
    __DBGpr_obj(" Cur Refernce ", curref->md_env.md_id );

    on_off = 0 ;

    status =
    ci$send(msg = message GRreffile.GRgetrfprops
                                          ( &sts, &props ),
            targetid = objlist[i],
            targetos = oslist[i] );


    ref_object.objid = objlist[i];
    ref_object.osnum = oslist[i];
    sts1 = OM_S_SUCCESS ;
    sts1 = gr$get_properties( object_id = &ref_object,
                       properties_mask = &PLTproperties);

    curref->properties = props;


    if ( PLTproperties & GRIS_DISPLAYABLE )
         on_off = 1;

    __DBGpr_int("on_off ", on_off);

    curref->display = on_off;

    j = j + 1;
    curref = curref + 1;

  } 

  if (j <= 0)
   {
      *refcount = 0;
      goto quit;
   }

  if( j < count )
   {
      i = j;
      *refcount = j;
      i = i * sizeof(struct PLT_reffile);
      *reftab = (struct PLT_reffile *)om$realloc( ptr  = (char *)*reftab,
                                                  size = i );
   }
   __DBGpr_int("refcount ", *refcount);

  if( objlist ) om$dealloc( ptr = objlist );
  if( oslist )  om$dealloc( ptr = oslist );

  return status ;

UI_status("Got the Ref. File Info.");

quit:
  if( objlist ) om$dealloc( ptr = objlist );
  if( oslist )  om$dealloc( ptr = oslist );
  if( *reftab ) om$dealloc( ptr = *reftab );
  *refcount = 0;
  return status ;
}

/*********************************************************
* get_reference_info:
*	- extract the dummy file with the local files attached. 
*********************************************************/

get_reference_info(mod_env, retCode )
struct GRmd_env mod_env;
int	* retCode ;
{
int           	i, status;

int seconds, minutes;
long finish_time;
double diff_time;

IGRint                refcount;
struct PLT_reffile    *reftab;
char                  ref_name[50];
char                  *tmpfile, *temp;
char                  catalog[40], part[40], rev[10];
int                   ch, pdm_stat, check;
char                  *errPDM, cidate[40], ciuser[40];
char                  *output_buffer;
int                   itemno, rows, ris_err_code;
char                  sql_str[512];
MEMptr                bufr;
char                  **data;
int                   y;
char		      *plotfile;
char		      *filename;
/*struct GRmd_env       mod_env;*/

tmpfile               = NULL;
temp                  = NULL;
ch                    = '/';
pdm_stat              = OM_S_SUCCESS;
check                 = 0;
bufr                  = NULL;
plotfile	      = NULL;
filename	      = NULL;

status        	= OM_S_SUCCESS ;


fprintf(ptr, "\nget_reference_info:\n");



  time (&finish_time);

  diff_time = difftime (finish_time, E_FileInfo.start_time);
  seconds = (int) diff_time;

/*  
  plotfile = strtok(E_FileInfo.filename, ".");

  strcpy(plotfile, E_FileInfo.filename);
*/

  fprintf (plotptr,"\n\n------------------------------------------------------------------------\n");
  fprintf (plotptr,"------------------------------------------------------------------------\n");
  fprintf (plotptr, "\n\n%s", "               Output Filename\n\n");
  fprintf (plotptr, "ISDP Filename :   %s\n", E_FileInfo.filename);

  fprintf (plotptr, "\n\n\n%s", "               Reference Filenames\n\n");

  refcount = 0;
  reftab = NULL;
  /*ci$get_module_info (md_env = &mod_env);*/

  get_ref_info1 (&mod_env, &refcount, &reftab);

  if(refcount <= 0)
  {
    fprintf (plotptr, "No reference file(s) attached to  :   %s\n\n", E_FileInfo.filename);
    fprintf (ptr, "\tNo reference file(s) attached to  :   %s\n\n", E_FileInfo.filename);
  }
  else

  {
     fprintf(plotptr, " No. of Reference files :      %d\n\n", refcount);
	 for (i = 0; i < refcount; i = i + 1)
     {
             strncpy(ref_name,  reftab[i].ref_name, 39);
             fprintf (plotptr, "VDS Reference File  : %s\n", ref_name);

             pdm_stat = PDMGetPartInfoGivenFileName(ref_name, catalog, part, rev);

                fprintf (plotptr, "Catalog             : %s\n", catalog);
				fprintf (plotptr, "Part No             : %s\n", part);
                fprintf (plotptr, "Revision            : %s\n", rev);

                pdm_stat = PDMquery_partno(catalog, part, rev, &itemno);
                y=0;
                sprintf(sql_str, "%s f_%s %s %d %s %d","SELECT n_cidate, n_ciuser FROM ", catalog,"WHERE n_itemnum = ", itemno,"AND n_fileversion > ", y);
                pdm_stat = SQLquery(sql_str, &bufr, 512);
   		__DBGpr_int("pdm_stat ", pdm_stat);
    		__DBGpr_str(" sql_str ", sql_str );
                if (pdm_stat != SQL_S_SUCCESS)
                        MEMclose(&bufr);
                else
                        pdm_stat = MEMbuild_array(bufr);
                if (pdm_stat != MEM_S_SUCCESS)
                        MEMclose(&bufr);
                else
                {
                	data = (char **) bufr->data_ptr;
                        strcpy(cidate, data[0]);
                        strcpy(ciuser, data[1]);
                        if (strcmp (cidate, "") == 0)
                        	fprintf(plotptr, "Error in retrieving Checked in Date\n");
                        else
                                fprintf(plotptr, "Checked in Date     : %s\n", cidate);

                        if (strcmp (ciuser, "") == 0)
                                fprintf(plotptr, "Error in retrieving Checked in User\n");
                        else
                                fprintf(plotptr, "Checked in User     : %s\n", ciuser);
                        fprintf(plotptr, "\n");
                 }
        	 catalog[0] = '\0';
        	 part[0] = '\0';
        	 rev[0] = '\0';
        	 cidate[0] = '\0';
        	 ciuser[0] = '\0';
			 get_reference_info(reftab[i].md_env, retCode);
         } 
  }


status = close_log_file( retCode ); 

quit:
  return status ;
}


/*********************************************************
* create_log_file:
*	- creates and opens a log file for the ppl process.
*
*********************************************************/

create_log_file(  retCode )
int	* retCode ;
{
int	status;
char	*plotfile;
char	*filename;

char	log[40];

plotfile	= NULL;
filename	= NULL;

status		= OM_S_SUCCESS ;


/**** Get the local filename - remove the ext on the filename */
fprintf(ptr,"\tISDP Filename: %s \n", E_FileInfo.filename);

fprintf(ptr,"\tPlot Filename: %s \n", E_FileInfo.plotfile);

plotfile = strtok(E_FileInfo.plotfile, ".");

/* open the plot text file to print out reference information */
sprintf(log, "%s.txt",plotfile);
plotptr = fopen(log, "w+");
if(plotptr == NULL)
  UI_status("Can not open the plot reference text file for writing...");

quit:
  return status ;
}


/*********************************************************
* close_log_file:
*	- closes the log file for the ppl process.
*
*********************************************************/

close_log_file(  retCode )
int     * retCode ;
{
int	status;

status		= OM_S_SUCCESS ;


fclose(plotptr);

quit:
  return status ;
}


/*********************************************************
* print_log_file_heading:
*	- prints a heading in the log file.
*
*********************************************************/

int print_log_file_heading( retCode )
int	* retCode ;
{
int	status;

/*
struct tm
  {                           
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };
*/


struct tm *tm_ptr;
long  tp;
char  fmt_time[64], *user_name, node_name[32];

fmt_time[0] = '\0';
node_name[0] = '\0';
tm_ptr = NULL;
user_name = NULL;
status		= OM_S_SUCCESS ;

time (&tp);
E_FileInfo.start_time = tp;
tm_ptr = localtime (&tp);
strftime (fmt_time, 64, "Date: %m/%d/%y %H:%M", tm_ptr);
gethostname (node_name, 32);
user_name = getlogin ();

time (&tp);
E_FileInfo.start_time = tp;

fprintf(ptr, "\nprint_log_file_heading:\n\n");

fprintf (ptr, "%s\n", "\tPlot File Extraction\n");

/* create log file */
status = create_log_file( retCode );

/*
__CheckRC( retCode, status, "create_log_file", quit );
*/

fprintf (plotptr, "%s\n", "Plot File Extraction\n\n");
fprintf (plotptr, "%s\n\n", fmt_time);
fprintf (ptr, "\t%s\n", fmt_time);
if (user_name)
{
   fprintf (plotptr, "Username: %s\n\n", user_name);
   fprintf (ptr, "\tUsername: %s\n", user_name);
}
else
{
   fprintf (plotptr, "Username: %s\n\n", "NO USERNAME");
   fprintf (ptr, "\tUsername: %s\n", "NO USERNAME");
}
fprintf (plotptr, "Nodename: %s\n\n", node_name);
fprintf (ptr, "\tNodename: %s\n", node_name);

/*
status = get_reference_info( retCode ); 
status = close_log_file( retCode );
*/

quit:
  return status;


}


/*********************************************************
* extract_files:
*	- extract the dummy file with the local files attached. 
*
*********************************************************/

extract_files(  index )
int index;
{

int				sts, status, msg, i; 
int				retCode ;       
struct GRmd_env module_info;
struct GRid 	window, fence;
char 			result[64], color_table[128], seedfile[128];
struct GRid		temp;
struct GRid		GR_OBJ, win_id;
char			windowname[50];

status			= OM_S_SUCCESS ;
seedfile[0]		= NULL;
color_table[0]	= NULL;
retCode			= OM_S_SUCCESS;
gPlotfile		= NULL;


__DBGpr_com("extract_files.....");
fprintf(ptr, "\nextract_files:\n");


  /* print the log file heading before generating plot file */
  status = print_log_file_heading( &retCode );


  UI_status("Processing Plot File ...");
  fprintf(ptr,"\n\t\tProcessing Plot Drawning Extraction.\n");

  /**** Get the local filename - remove the ext on the filename */
  gPlotfile = strtok(E_FileInfo.plotfile, ".");	
  strcat(gPlotfile,".plt");

  fprintf(ptr,"\t\t\tPlot Filename: %s \n", gPlotfile);


	/* given the range from the LPD_ShtInfo structure for the index, place a fence */
	//LPD_ShtInfo[index].range
	
	gRange[0] = LPD_ShtInfo[index].Range[0];
	gRange[1] = LPD_ShtInfo[index].Range[1];
	gRange[2] = LPD_ShtInfo[index].Range[2];

	gRange[3] = LPD_ShtInfo[index].Range[3];
	gRange[4] = LPD_ShtInfo[index].Range[4];
	gRange[5] = LPD_ShtInfo[index].Range[5];
	
	
		
	// Copy gRange to &gRange[6] ...
	memcpy ( &gRange[6], &gRange[0], 6 * sizeof(double));

	// Get the object_ID of the window from its name...
	//sts = get_window_id ( "plan", &win_id );

	sprintf(windowname, "%s", LPD_ShtInfo[index].ShtWindow);
	__DBGpr_str(" windowname ", windowname );
	__DBGpr_int("index ", index);

	sts = get_window_id ( windowname , &win_id );
	if ( ! sts )
	{
		fprintf(stderr,"get_window_id error\n");
		goto quit;
	}

	WIN_OBJ  = win_id;

	// Construct a temporary closed linestring from a range...
	sts = construct_linestr ( gRange, &GR_OBJ );
	if ( ! sts )
	{
		fprintf(stderr,"construct_linestr error\n");
		goto quit;
	}

	// Construct and process a rectangular fence...
	sts = construct_fence( GR_OBJ );
	if ( ! sts )
	{
		fprintf(stderr,"construct_fence error\n");
		goto quit;
	}

	// Delete the temporary closed linestring...
	sts =	ci$send (	msg = message GRgraphics.GRdelete (&msg, &aimMOD_ENV),
						targetid = GR_OBJ.objid,
						targetos = GR_OBJ.osnum);


	/************************************************
	ci$get_module_info(md_env = &module_info);
	   
  	fprintf(ptr,"\t\t\tCalling create_plotfile:\n");
  	sts = plot$create_plotfile(	msg 		= &msg,
                       			filetype 	= PI_IGDS_FILE,
                       			module 		= &module_info,
                       			dbtype 		= "3d",
                       			range 		= LPD_ShtInfo[index].range,
                       			window 		= &LPD_ShtInfo[index].window,
                       			cvprism 	= LPD_ShtInfo[index].cvprism,
                       			plotfile 	= gPlotfile,
                       			seedfile 	= seedfile,
                       			color_table 	= color_table,
                       			flood_index 	= -1,
                       			filter_function = NULL,
                       			filter_data 	= NULL,
		       			status 			= result);
		
		__DBGpr_str("result  =  ", result);
		__DBGpr_int("msg   =  ", msg);

		if (msg == MSSUCC)
			__DBGpr_com("it's MSSUCC");	

		if (msg == MSINARG)
			__DBGpr_com("it's MSINARG");
		if (msg == GUREAD_ERROR)
			__DBGpr_com("it's GUREAD_ERROR");
		if (msg == GUNOFILE)
			__DBGpr_com("it's GUNOFILE");
		if (msg == GUNOSEEDFILE)
			__DBGpr_com("it's GUNOSEEDFILE");
		if (msg == GUWRITE_ERROR)
			__DBGpr_com("it's GUWRITE_ERROR");
		if (msg == GUELEMENT_OVERFLOW)
			__DBGpr_com("it's MSSGUELEMENT_OVERFLOWUCC");

		if (msg == GUVIEW_OVERFLOW)
			__DBGpr_com("it's GUVIEW_OVERFLOW");


		status = result;
   		__DBGpr_int("sts  =  ", sts);
		if ( sts == 1)
		{
  			UI_status("Plot File Created ...");
			fprintf(ptr,"\t\t\tPlot File Created.\n");
		}
		else
		{
  			UI_status("Plot File Creation Failed ...");
			fprintf(ptr,"\t\t\tPlot File Creation Failed.\n");
       			status = OM_E_ERROR;
        		goto quit;
		}
	*************************************************/

ci$get_module_info(md_env = &module_info);

/* status = get_reference_info( aimMOD_ENV, &retCode ); */
status = get_reference_info( module_info, &retCode );


quit:
  return status;

}











/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

cst_settings ()
{
    ci$get_module_info( md_env = &aimMOD_ENV);

    aimdis.color		= cnst_list.color;
    aimdis.weight		= cnst_list.weight;
    aimdis.style		= cnst_list.style;

    aimcst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
    aimcst.display		= &aimdis;
    aimcst.env_info	= &aimMOD_ENV;
    aimcst.newflag		= 0;
    aimcst.level		= cnst_list.level;
    aimcst.geometry	= NULL;
    aimcst.class_attr	= 0;
    aimcst.name		= 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

get_window_id ( name, win_id )

  char        *name;		// I
  struct GRid *win_id;		// O

{
  char *filnam, filename[OM_K_MAXOSNAME_LEN], wndwname[PATH_MAX];
  int  sts;
  OM_S_OBJID winobj;
  OMuword    winosn;

  fprintf(ptr, "\nget_window_id:\n");
  __DBGpr_com("get_window_id");

  
  sts = ex$filename ( name = filename, len = OM_K_MAXOSNAME_LEN );
  if ( ! (sts & 1) )
  {
    fprintf(stderr,"ex$filename error = %d\n", sts);
    sts = 0;
    goto wrapup;
  }

  filnam = strrchr ( filename, '/' ) + 1;
  sprintf(wndwname, ":%s:views:regviews:GRviews:%s", filnam, name);

  sts =
    di$translate ( objname =  wndwname,
                   p_osnum = &winosn,
                   p_objid = &winobj );
  if ( ! (sts & 1) )
  {
    fprintf(stderr,"di$translate error = %d\n", sts);
    sts = 0;
    goto wrapup;
  }
  win_id->objid = winobj;
  win_id->osnum = winosn;
  //DEBUG2 ("win_id = [%d,%d]\n", win_id->osnum, win_id->objid);

wrapup:

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

construct_linestr ( range, GR_OBJ )

  double	*range;		// I
  struct GRid	*GR_OBJ;	// O
{
  int		i, msg, sts, npts;
  double	points[15], *pnt0, *pnt1, nvec[3];

  fprintf(ptr, "\nconstruct_linestr:\n");
  __DBGpr_com("construct_linestr");

  cst_settings ();

  sts  = 1;
  npts = 5;
  pnt0 = range;
  pnt1 = &range[3];

  // For the time being, we suppose to be working in a TOP-view: pnt0[2] == pnt1[2]
  // Define a closed rectangular linestring from the range:
  points[0]  = pnt0[0];
  points[1]  = pnt0[1];
  points[2]  = pnt0[2];

  points[3]  = pnt1[0];
  points[4]  = pnt0[1];
  points[5]  = pnt0[2];

  points[6]  = pnt1[0];
  points[7]  = pnt1[1];
  points[8]  = pnt0[2];

  points[9]  = pnt0[0];
  points[10] = pnt1[1];
  points[11] = pnt0[2];

  points[12] = pnt0[0];
  points[13] = pnt0[1];
  points[14] = pnt0[2];

  for ( i=0 ; i< 12 ; i=i+3 )
    //DEBUG3 ("%14.6f %14.6f %14.6f\n", points[i], points[i+1], points[i+2]);

  BSalloccv ( (IGRshort)2, (IGRlong)5, (IGRboolean)0, (IGRshort)0, &bsp_crv, &msg);
  if ( msg )
  {
    fprintf(stderr,"BSalloccv error = %d\n", msg);
    sts = 0;
    return (sts);
  }

  BSlininter(&msg, &npts, points, bsp_crv, nvec );
  if ( msg )
  {
    fprintf(stderr,"BSlininter error = %d\n", msg);
    sts = 0;
    goto wrapup;
  }

  aimcst.geometry  = (char *)bsp_crv;
  aimcst.msg       = &msg;

  GR_OBJ->objid = NULL_OBJID;
  GR_OBJ->osnum = aimMOD_ENV.md_id.osnum;

//  if ( ! ci$send ( msg      = message GR3dlinestr.GRconstruct(&aimcst),
  if ( ! ci$send ( msg      = message GR3dorthpoly.GRconstruct(&aimcst),
                   targetid = GR_OBJ->objid,
                   targetos = GR_OBJ->osnum,
                   construct= TRUE) )
  {
    GR_OBJ->objid = NULL_OBJID;
    fprintf(stderr,"GR3dlinestr.GRconstruct error\n");
    sts = 0;
    goto wrapup;
  }
  //DEBUG2 ("After GR3dlinestr.GRconstruct GR_OBJ = [%d,%d]\n", GR_OBJ->osnum, GR_OBJ->objid);

wrapup:

  BSfreecv ( &msg, bsp_crv );

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

construct_fence( OBJET )

struct	GRid	OBJET;
{
  int	msg, sts;

  p_cvprism       = NULL;
  p_rtprism       = NULL;

  get_symb();

  build_locate_criteria();

  //DEBUG2 ("OBJET = [%d,%d]\n",OBJET.osnum,OBJET.objid);

  if ( ! is_closed_obj		( OBJET ))	return (0);
  if ( ! build_cv_prism		( OBJET ))	return (0);
  if ( ! construct_fence_set	( OBJET ))	return (0);
  if ( ! start_transition_set	( OBJET ))	return (0);
  if ( ! get_prism_data		( OBJET ))	return (0);
  if ( ! end_transition_set() )			return (0);

  sts =
    ci$send ( msg      = message GRfcset.GSdissolve(&msg),
              targetid = GS_ID.objid,
              targetos = GS_ID.osnum);

  if (!(sts & msg & 1))
  {
    fprintf(stderr,"GRgrset.GSdissolve error ; sts = %d , msg = %d\n",sts,msg );
    om$report_error (sts = sts);
    sts = 0;
  }

  if ( p_cvprism ) free ( (char *)p_cvprism );
  if ( p_rtprism ) free ( (char *)p_rtprism );

  p_cvprism = NULL;
  p_rtprism = NULL;

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

build_locate_criteria()
{
  OMuword	GRgraphics_classid;

  // Set up the locate criteria...
  GRgraphics_classid                 = OPP_GRgraphics_class_id;

  locate_rtree_thing.p_classes       = &rtree_classids[0];
  locate_eligible_thing.p_classes    = &eligible_classids[0];

  locate_rtree_thing.w_count         = 1;
  locate_rtree_thing.w_flags         = OM_CLST_subclass;
  locate_rtree_thing.p_classes[0]    = GRgraphics_classid;

  locate_eligible_thing.w_count      = 1;
  locate_eligible_thing.w_flags      = OM_CLST_subclass;
  locate_eligible_thing.p_classes[0] = GRgraphics_classid;

  classinfo.rtree_classes            = &locate_rtree_thing;
  classinfo.eligible_classes         = &locate_eligible_thing;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

is_closed_obj ( OBJET )

struct	GRid	OBJET;
{
  int		msg, sts;
  int		is_clsd;
  struct	GRprops	props;

  sts =
    ci$send ( msg      = message GRvg.GRgeomprops( &msg,
                                                   &aimMOD_ENV.md_env.matrix_type,
                                                    aimMOD_ENV.md_env.matrix,
                                                   &props),
              targetid = OBJET.objid,
              targetos = OBJET.osnum );

  if (!(sts & msg & 1))
  {
    fprintf(stderr,"GRvg.GRgeomprops error ; sts = %#x, msg = %#x\n",sts,msg );
    om$report_error (sts = sts);
    goto wrapup;
  }

  is_clsd = props.phy_closed;

wrapup:

  return (is_clsd);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

build_cv_prism (OBJET)

struct GRid OBJET;
{
  char	*ptr;
  int		i, size, num_pnt;
  int		msg, sts;
  double	*pnt_ptr;

  sts =
    ci$send ( msg      = message GRvg.GRgenabsg( &msg,
                                                 &aimMOD_ENV.md_env.matrix_type,
                                                  aimMOD_ENV.md_env.matrix,
                                                 &bsp_crv),
              targetid = OBJET.objid,
              targetos = OBJET.osnum);

  if (!(sts & msg & 1))
  {
    fprintf(stderr,"GRvg.GRgenabsg error ; sts = %#x, msg = %#x\n",sts,msg );
    om$report_error (sts = sts);
    goto wrapup;
  }

  //DEBUG1 ("bsp_crv->num_poles = %d\n",bsp_crv->num_poles );

  for ( i=0 ; i< 3 * bsp_crv->num_poles ; i=i+3 )
    //DEBUG3 ("%14.6f %14.6f %14.6f\n",bsp_crv->poles[i],bsp_crv->poles[i+1],bsp_crv->poles[i+2]);

  // get the size of the bspline curve

  sts =
    ci$send ( msg      = message GRvg.GRgetsize( &msg,
                                                 &aimMOD_ENV.md_env.matrix_type,
                                                  aimMOD_ENV.md_env.matrix,
                                                 &size),
              targetid = OBJET.objid,
              targetos = OBJET.osnum );

  if (!(sts & msg & 1))
  {
    fprintf(stderr,"GRvg.GRgetsize error ; sts = %#x, msg = %#x\n",sts,msg );
    om$report_error (sts = sts);
    goto wrapup;
  }

  // allocate and format a prism

  if ((bsp_crv->order == 2) && (!bsp_crv->rational))
  {
    // generate a right prism

    //DEBUG0 ("Creating a right prism\n");

    prism_type = GR_RIGHT_PRISM;
    right_prism= TRUE;

    size = sizeof (struct IGRrt_prism) + sizeof (IGRdouble) * 3 * bsp_crv->num_poles;

    p_rtprism = (struct IGRrt_prism *) calloc (1, size);

    //DEBUG2 ("size rtprism = %d , p_rtprism = %#x <<<<<<<<<<<<<<\n", size, p_rtprism);

    if (p_rtprism == NULL)
    {
      fprintf(stderr,"build_cv_prism() : calloc (size = %d) failed\n", size);
      goto wrapup;
    }

    ptr = (char *) p_rtprism + sizeof (struct IGRrt_prism);

    p_rtprism->polygon.points	= (IGRdouble *) ptr;

    num_pnt = bsp_crv->num_poles;
    pnt_ptr = (IGRdouble *) ptr;

    p_prism = (char *) p_rtprism;
  }
  else
  {
    // generate a curve prism

    //DEBUG0 ("Creating a curve prism\n");

    prism_type  = GR_CURVE_PRISM;
    right_prism = FALSE;

    size = size + sizeof (struct IGRcv_prism) - sizeof(struct IGRbsp_curve);

    p_cvprism = (struct IGRcv_prism *) calloc (1, size);

    //DEBUG2 ("size cvprism = %d , p_cvprism = %#x <<<<<<<<<<<<<<\n", size,p_cvprism);

    if (p_cvprism == NULL)
    {
      fprintf(stderr,"build_cv_prism() : calloc (size = %d) failed\n", size);
      goto wrapup;
    }

    ptr = (char *) p_cvprism + sizeof (struct IGRcv_prism);

    p_cvprism->curve.poles = (IGRdouble *) ptr;

    num_pnt = bsp_crv->num_poles;
    pnt_ptr = (IGRdouble *) ptr;

    ptr = ptr + sizeof (IGRdouble) * 3 * bsp_crv->num_poles;

    if (bsp_crv->rational)
    {
      p_cvprism->curve.weights = (IGRdouble *) ptr;
      ptr = ptr + sizeof (IGRdouble) * bsp_crv->num_poles;
    }

    if (bsp_crv->num_knots)
    {
      p_cvprism->curve.knots = (IGRdouble *) ptr;
      ptr = ptr + sizeof (IGRdouble) * bsp_crv->num_knots;
    }

    if (bsp_crv->num_boundaries)
    {
      p_cvprism->curve.bdrys = (IGRdouble *) ptr;
    }
    p_prism = (char *) p_cvprism;
  }
  //DEBUG2 ("Enter GRbuild_prism_in_wnd ; WIN_OBJ = [%d,%d]\n", WIN_OBJ.osnum, WIN_OBJ.objid);

  // call a function that will build the prism
  sts = GRbuild_prism_in_wnd (&msg, &WIN_OBJ, bsp_crv, (char *)p_prism);

  //DEBUG4 ("After GRbuild_prism_in_wnd ; WIN_OBJ = [%d,%d], sts = %d, msg = %d\n", WIN_OBJ.osnum, WIN_OBJ.objid, sts, msg);

  if (!(sts & msg & 1))
  {
    fprintf(stderr,"GRbuild_prism_in_wnd() ; sts = %#x, msg = %#x\n",sts,msg );
    om$report_error (sts = sts);
    goto wrapup;
  }

  if ( right_prism )
  {
    //DEBUG1 ("p_rtprism->height = %14.6f\n",p_rtprism->height );

    //for ( i=0 ; i<15 ; i=i+4 )
      //DEBUG4 ("%14.6f %14.6f %14.6f %14.6f\n",p_rtprism->matrix[i],p_rtprism->matrix[i+1],p_rtprism->matrix[i+2],p_rtprism->matrix[i+3]);
  }
  else
  {
    //DEBUG1 ("p_cvprism->height = %14.6f\n",p_cvprism->height );

    //for ( i=0 ; i<15 ; i=i+4 )
      //DEBUG4 ("%14.6f %14.6f %14.6f %14.6f\n",p_cvprism->matrix[i],p_cvprism->matrix[i+1],p_cvprism->matrix[i+2],p_cvprism->matrix[i+3]);
  }
  //DEBUG1 ("prism num_poles = %d\n",num_pnt );

  //for ( i=0 ; i< 3 * num_pnt ; i=i+3 )
    //DEBUG3 ("%14.6f %14.6f %14.6f\n",pnt_ptr[i],pnt_ptr[i+1],pnt_ptr[i+2]);

wrapup:

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

construct_fence_set( OBJET )

struct	GRid	OBJET;
{
  char classname2[1024];
  int  msg, sts, properties;

  properties = GRIS_POST_PROCESSING_INSIDE | GRIS_BACKGROUND_DISPLAY;

  // Construct & Initialize the fence set.

  GS_ID.osnum = OBJET.osnum;

  sts =
    ci$send ( msg       = message GRgrset.GSinit( &msg,
                                                  &properties,
                                                   NULL,
                                                   NULL),
              construct = TRUE,
              targetid  = GS_ID.objid,
              targetos  = GS_ID.osnum);

  if ( ! ( sts & msg & 1) )
  {
    fprintf(stderr,"GRgrset.GSinit error ; sts = %d , msg = %d\n",sts,msg );
    om$report_error ( sts = sts );
    goto wrapup;
  }

  om$get_classname ( objid     = GS_ID.objid,
                     osnum     = GS_ID.osnum,
                     classname = classname2  );


wrapup:

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

start_transition_set( OBJET )

struct	GRid	OBJET;
{
  int		msg, sts;
  int		properties;

  // Start a transition for the graphics set.

  properties = 0;

  SV_ID.osnum = OBJET.osnum;

  sts =
    ci$send ( msg      = message GRgrset.GSstart_transition( &msg,
                                                             &aimMOD_ENV,
                                                             &properties,
                                                              NULL,
                                                             &SV_ID),
              targetid = GS_ID.objid,
              targetos = GS_ID.osnum);

  //DEBUG2 ("start_transition_set() SV_ID = [%d,%d]\n", SV_ID.osnum, SV_ID.objid);

  if ( ! ( sts & msg & 1) )
  {
    fprintf(stderr,"GRgrset.GSstart_transition error ; sts = %d , msg = %d\n",sts,msg );
    om$report_error ( sts = sts );
    goto wrapup;
  }

wrapup:

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

end_transition_set()
{
  int		msg, sts;

  sts = ci$send ( msg      = message GRgrset.GSend_transition (&msg, NULL),
                  targetid = GS_ID.objid,
                  targetos = GS_ID.osnum);

  //DEBUG0 ("end_transition_set() ; exit GRgrset.GSend_transition\n" );

  if ( ! ( sts & msg & 1) )
  {
    fprintf(stderr,"GRgrset.GSend_transition error ; sts = %d , msg = %d\n",sts,msg );
    om$report_error ( sts = sts );
    goto wrapup;
  }

wrapup:

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

get_prism_data( OBJET )

struct	GRid	OBJET;
{
  int				rc, sts;
  struct GRlc_locate		attributes;
  struct GRrp_action_args	rp_action_args;

  rp_action_args.gs_id       = GS_ID;
  rp_action_args.sv_id       = SV_ID;
  rp_action_args.clip_flag   = TRUE;
  rp_action_args.rp_relation = GO_INSIDE | GO_OVERLAP;

  strcpy (attributes.classes,"GRgraphics");

  attributes.properties      = LC_LC_ONLY | LC_RW | LC_DP_ONLY | IGN_MOD_BIT | IGN_PLANAR_BIT;
  attributes.owner_action    = LC_FLEX_COMP  | LC_FLEX_OWNER ;

  sts = gr$gsprism_locate ( msg            = &rc,
                            mod_env        = &aimMOD_ENV,
                            window_id      = &WIN_OBJ,
                            attributes     = &attributes,
                            classinfo      = &classinfo,
                            prism_type     = prism_type,
                            prism          = p_prism,
                            prism_attr     = TRUE_REL,
                            inside_outside = 1,
                            layers         = NULL,
                            action_handler = GRgs_rp_action,
                            action_args    = &rp_action_args );

  //DEBUG2 ("gr$gsprism_locate: sts = %d , rc = %d\n", sts, rc );

  if ( ! ( sts & rc & 1) )
  {
    fprintf(stderr,"gr$gsprism_locate error ; sts = %d , rc = %d\n",sts,rc );
    om$report_error ( sts = sts );
    goto wrapup;
  }

  if ( ! get_chan_objs( OBJET ) ) goto wrapup;

wrapup:

  return (sts);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

get_chan_objs( OBJET )
struct	GRid	OBJET;
{
  char	*channame; 
  char  result[80];
  short	 cl_id;
  int    i0, count, size, msg, sts;
  //char  classname3[200];
  
  OMuword	*l_osn;
  GRobj		*l_obj;

  //TLS
  int	status;
  IGRdouble               range[12];
  struct GRmd_env         module_info;
  struct GRid             window, fence;
  struct IGRcv_prism      *cvprism;
  char                    color_table[128], seedfile[128];
  int i;
  struct GRid temp;
  struct GRid          fence_id;

  status          = OM_S_SUCCESS ;
  seedfile[0]     = NULL;
  color_table[0]  = NULL;
  cvprism         = NULL;


  channame = "GRcmpowner.to_components";

  count = 0;
  l_osn = NULL;
  l_obj = NULL;

  sts =
    gr$gsinqcount ( msg       = &msg,
                    count     = &count,
                    senderid  = GS_ID.objid,
                    senderos  = GS_ID.osnum,
                    object_id = &SV_ID);

  //DEBUG1 ("get_chan_objs() ; exit gr$gsinqcount : count = %d\n", count);

  if ( ! ( sts & msg & 1) )
  {
    fprintf(stderr,"get_chan_objs() : gr$gsinqcount error ; sts = %d , msg = %d\n",sts,msg );
    om$report_error ( sts = sts );
    goto wrapup;
  }

  if ( count > 0 )
  {
    size  = sizeof (OMuword) * count;
    l_osn = (OMuword *) om$malloc (size = size);
    if (l_osn == NULL)
    {
      fprintf(stderr,"get_chan_objs() : om$malloc (size = %d) failed\n", size);
      goto wrapup;
    }

    size  = sizeof (GRobj) * count;
    l_obj = (GRobj *) om$malloc (size = size);
    if (l_obj == NULL)
    {
      fprintf(stderr,"get_chan_objs() : om$malloc (size = %d) failed\n", size);
      goto wrapup;
    }
  }

  sts =
    ci$get_channel_objects( osnum     = (int)SV_ID.osnum,
                            objid     = SV_ID.objid,
                            channname = channame,
                            obj_list  = l_obj,
                            osn_list  = l_osn,
                            count     = &count );

  //DEBUG1 ("get_chan_objs() ; exit ci$get_channel_objects : count = %d\n",count );

  if ( sts != 1 )
  {
    fprintf(stderr,"get_chan_objs() : ci$get_channel_objects error ; sts = %d , count = %d\n",sts,count );
    om$report_error ( sts = sts );
    goto wrapup;
  }

  for ( i0=0 ; i0< count ; i0=i0+1 )
  {
    sts =
      om$get_classid (	objid     = l_obj[i0],
                        osnum     = l_osn[i0],
                        p_classid = &cl_id );
    //sts = om$get_classname ( classid   = cl_id, classname = classname3  );

    if ( sts != 1 )
    {
      fprintf(stderr,"get_chan_objs() : om$get_classid() ; sts = %#x\n",sts );
      om$report_error (sts = sts);
      goto wrapup;
    }

    //__DBGpr_str("classname3  =  ", classname3);

    /*
    printf(" l_obj[i0] <%d> \n", l_obj[i0]);
    printf(" OBJET.objid <%d> \n", OBJET.objid);
    printf("\n");
    printf(" l_osn[i0] <%d> \n", l_osn[i0]);
    printf(" OBJET.osnum <%d> \n", OBJET.osnum);
    printf("\n");
    */

    if ( l_obj[i0] == OBJET.objid && l_osn[i0] == OBJET.osnum )
    {
      //DEBUG0 ("  equal to located OBJECT\n");
      
      __DBGpr_com("located object");
      fence_id.osnum = l_osn[i0];
      fence_id.objid = l_obj[i0]; 
    }
    else
    {
      //DEBUG0 ("\n");
    }
  }

  // Create a plotfile...

  //printf("gRange %f %f %f %f %f %f\n", gRange[0],gRange[1],gRange[2],gRange[3],gRange[4],gRange[5]);
  //printf("WIN_OBJ %d %d \n", WIN_OBJ.objid, WIN_OBJ.osnum);

  //TLS111


  //if ((msg == MSSUCC) ||(msg == OM_S_SUCCESS) )
   //{
/*

        __DBGpr_com("calling ci$get_module_info.....");
   	//ci$get_module_info(md_env = &module_info);
*/

        status = gr$gsput_fence (	msg = &msg, 
					mod_env = &aimMOD_ENV,
         				fence_id = &fence_id, 
					window_id = &WIN_OBJ);
  
        gr$gsget_fence (msg = &msg,fence_id = &temp);

        __DBGpr_int("msg for gsget_fence  =  ", msg);

        __DBGpr_com("calling plot$get_fence_range.....");
        sts = plot$get_fence_range (    msg     = &msg,
                                        module  = &aimMOD_ENV,
                                        fence   = &fence,
                                        window  = &window,
                                        world   = range,
                                        view    = &range[6],
                                        cvprism = &cvprism);

	__DBGpr_int("sts for get_fence_range  =  ", sts);
        if( ! ( sts & msg & 1 ) )
        {
                UI_status("No Active Fence ...");
                fprintf(ptr,"\t\t\tNo Active Fence.\n");
                status = OM_E_ERROR;
                goto wrapup;
        }
        else
        {

        	UI_status("Retreived Fence Successfully ...");
        	fprintf(ptr,"\t\t\tRetrieve Fence Successfully.\n");
  		//printf("range %f %f %f %f %f %f\n", range[0],range[1],range[2],range[3],range[4],range[5]);
  		//printf("window %d %d \n", window.objid, window.osnum);

  		fprintf(ptr,"\t\t\tCalling create_plotfile:\n");

        	__DBGpr_com("calling plot$create_plotfile.....");
  		sts = plot$create_plotfile(	msg             = &msg,
  						filetype        = PI_IGDS_FILE,
       	       		                        module          = &aimMOD_ENV,
               		                       	dbtype          = "3d",
               	                         	range           = range,
               	                         	window          = &window,
                                       	 	cvprism         = cvprism,
                                        	plotfile        = gPlotfile,
                                        	seedfile        = seedfile,
                                        	color_table     = color_table,
                                        	flood_index     = -1,
                                        	filter_function = NULL,
                                        	filter_data     = NULL,
                                        	status          = result);

		free(cvprism);

                __DBGpr_int("sts  =  ", sts);
                if ( sts == 1)
                {
                        UI_status("Plot File Created ...");
                        fprintf(ptr,"\t\t\tPlot File Created.\n");
                }
                else
                {
                        UI_status("Plot File Creation Failed ...");
                        fprintf(ptr,"\t\t\tPlot File Creation Failed.\n");
                        status = OM_E_ERROR;
                        goto wrapup;
                }

        }
  //}

/*
  sts =
  plot$create_plotfile ( msg      = &msg,
                         module   = &aimMOD_ENV,
                         dbtype   = "3d",
                         range    = gRange,
                         window   = &WIN_OBJ,
                         plotfile = gPlotfile,
                         status   = result);

  if ( ! (sts & 1 & msg) )
  {
    fprintf(stderr,"plot$create_plotfile() error: sts = %d, msg = %d\n", sts, msg);
    sts = 0;
    goto wrapup;
  }
  else
  {
    fprintf(stderr,"%s = <%s>\n", result, gPlotfile);
  }
*/

  if ( l_osn ) { free ( (char *)l_osn ); l_osn = NULL; }
  if ( l_obj ) { free ( (char *)l_obj ); l_obj = NULL; }

wrapup:

  return (sts);
}














/*******************************************************
* ftp_files_to_aim_wl:
*	- ftp the extracted files to the exported work location.
*
*******************************************************/

ftp_files_to_aim_wl( plotfile )
char	*plotfile ;
{
int           	status;
FILE		*ftpptr;
char		*temp;

status        	= OM_S_SUCCESS ;             
ftpptr		= NULL ;
temp		= NULL ;
  
fprintf(ptr,"\nftp_files_to_aim_wl:\n");

ftpptr = fopen("PLOTftp.sh", "w+");
if(ftpptr == NULL)
{
	UI_status("Can not open ftp shell file for writing...");
	fprintf(ptr,"\tCan not open ftp shell file for writing.\n"); 
      	status = OM_E_ERROR;
        goto quit;
}

UI_status("Transfering Plot Files to AIM...");
fprintf(ptr,"\tTransfering Plot Files to AIM.\n");

/* remove the ext on the filename */
temp = strtok(plotfile, ".");

  fprintf( ftpptr, "if ( \techo user anonymous blank\n");
  fprintf(ftpptr, "\techo bin\n");
  fprintf(ftpptr, "\techo send \\\"%s.plt\\\"\n", temp);
  fprintf(ftpptr, "\techo ascii\n");
  fprintf(ftpptr, "\techo send \\\"%s.txt\\\"\n",temp);
  fprintf(ftpptr, "\techo quit\n");
  fprintf(ftpptr, " ) | ftp -ni %s ; then\n", E_FileInfo.server);
  fprintf(ftpptr, "\techo ftp to AIM work location was SUCCESSFUL.\n");
  fprintf(ftpptr, "else\n");
  fprintf(ftpptr, "\techo Ftp to AIM work location FAILED.\n");
  fprintf(ftpptr, "fi\n");
  fclose(ftpptr);
  status =  system ("chmod 777 PLOTftp.sh");
  status =  system ("PLOTftp.sh");
  if( status != 0 )
  {
	UI_status("Can not execute ftp shell file for Posting Plot Files...");
	fprintf(ptr,"\tCan not execute ftp shell file for Posting Plot Files.\n"); 
      	status = OM_E_ERROR;
        goto quit;
  }
  else
  {
	UI_status("Transfer Complete...");
	fprintf(ptr,"\tTransfer Complete.\n");
	status = OM_S_SUCCESS;
  }

quit:

  return status ;

}   

/*******************************************************
* post_files:
*	 - sends a command to AIM through postman to post the 
*	   extracted files to AIM.  The command that this function
*	   calls is in VDPostCmd.c
*
*******************************************************/

int post_files( cmdcode, plotfile, oldplotfile, plotdesc)
int		cmdcode;
char	*plotfile;
char	*oldplotfile;
char	*plotdesc;
{
int     i;
int     status;
int     code;

status     	= OM_S_SUCCESS ;
code		= 0; 		

/*
 * Send Cmd to AIM through Postman to:
 *      1. post the files into AIM. 
 */

UI_status("Sending post command to AIM....................");
fprintf(ptr,"Sending post command to AIM....................\n");

/* set the AIM command code */
/* VDP_REG_PLOT_FILES is the command code for VDP_REG_PLOT_FILES */
code = cmdcode;

status = VDP_send_post_plot_cmd(	E_FileInfo.server,
									plotfile,
									oldplotfile,
									plotdesc, 
									E_FileInfo.catalog, 
									E_FileInfo.partno, 
									E_FileInfo.revision,
									E_FileInfo.ctxid,
									LPD_Info.FileType,
									LPD_Info.DrwNum, 
									LPD_Info.AimRev,
									LPD_Info.DrwTitle,
									LPD_Info.AuthorizeFor,
									LPD_Info.NavSeaDrwNum,
									LPD_Info.Team,
									LPD_Info.CageCode,
									code); 

if (status != 0) 
{
	__DBGpr_int("status is bad.  status =  ", status);

	if(status == 1)
       	{
         	UI_status("There was an AIM connection problem.");
         	fprintf(ptr,"There wan an AIM socket connection problem.\n");
       	 	status = OM_E_ERROR;
       	}

	if(status == 30)
       	{
         	UI_status("The AIM work location could not be found.");
         	fprintf(ptr,"The AIM work location could not be found.  Verify that the work location exist.  If it does, contact your administrator.\n");
       	 	status = OM_E_ERROR;
       	}

       if(status == 31)
       {
         	UI_status("Error in retrieving the server host name in AIM.");
         	fprintf(ptr,"Error in retrieving the server host name in AIM.  Contact Administrator.\n");
         	status = OM_E_ERROR;
       }

       if(status == 32)
       {
         	UI_status("An Error has occured in AIM.");
         	fprintf(ptr,"An Error has occured in AIM.  Contact the Administrator.\n");
         	status = OM_E_ERROR;
       }

       if(status == 33)
       {
         	UI_status("The extracted files are not in the work locations.");
         	fprintf(ptr,"The extracted files are not in the work locations.\n");
         	status = OM_E_ERROR;
       }
       if(status == 34)
       {
         	UI_status("The AIM vault could not be found.");
         	fprintf(ptr,"The AIM vault could not be found.  Verify that the vault exist.  If it does, contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
       if(status == 35)
       {
         	UI_status("The AIM vault location could not be found.");
         	fprintf(ptr,"The AIM vault location could not be found.  Verify that the vault location exist.  If it does, contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
       if(status == 36)
       {
         	UI_status("An ERROR Occurred In AIM .");
         	fprintf(ptr,"The unregisted AIM object could not be located in the work location.  Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }

       if(status == 37)
       {
         	UI_status("The AIM work location is not set in the config file.");
         	fprintf(ptr,"The AIM work location is not set in the config file.  Locate the config parameter in the AIM config.cfg file and set it to the work location name.  If it id set then conatact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }

	   if(status == 45)
       {
         	UI_status("DOCUMENT REVISION NOT SUPPORTED IN THIS BUILD.");
         	fprintf(ptr,"The Drawing Document being used needs to be revised.  DRAWING DOCUMENT REVISION IS NOT SUPPORTED IN THIS PST BUILD. Set the Drawing Revision is Tree Manager to a Revision that already exist in AIM.\n");
       	 	status = OM_E_ERROR;
       }

	   if(status == 50)
       {
         	UI_status("Plot File Not Found.");
         	fprintf(ptr,"The plot file was not found in AIM.\n");
       	 	status = OM_E_ERROR;
       }
       else
       {
         	UI_status("Error in sending post command to AIM.\n");
         	fprintf(ptr,"Error in sending post command to AIM. Contact your AIM administrator.\n");
       	 	status = OM_E_ERROR;
       }
}
else 
{
	status = OM_S_SUCCESS;
       	UI_status("Posting to AIM  was Successful.....................\n");
       	fprintf(ptr,"Posting to AIM  was Successful.....................\n");
}              

quit:

  return status ;

}
/********************************************************
* remove_plt_file:
*	- Remove the .dri file from the work location directory.  
*     The transfer process does not remove the file because
*     there is an sysmbolic link between the .dri and DesignReview.
*     Instead it makes a local copy of the file in to the vault
*     location and leaves a local copy in the exported dir.
*
**********************************************************/

remove_plt_file( retCode )
int     *retCode ;
{
int	status;
char  	temp[256], *rmPlotfile;

*retCode      	= OM_S_SUCCESS  ;
status        	= OM_S_SUCCESS ;
rmPlotfile 	= NULL;

fprintf(ptr,"\nremove_plt_file: \n");
__DBGpr_com ("remove_plt_file:");

//status = VDP_remove_plt(E_FileInfo.exportDir, E_FileInfo.filename);

rmPlotfile = strtok(E_FileInfo.plotfile, ".");

fprintf(ptr,"\t\t\tRemoving Plot Filename: %s \n", rmPlotfile);

sprintf(temp, "rm \"%s.plt\"",rmPlotfile);
status = system(temp);

temp[0] = '\0';

sprintf(temp, "rm \"%s.txt\"",rmPlotfile);
status = system(temp);

temp[0] = '\0';

sprintf(temp, "rm 1CC97*.tbl");
status = system(temp);

status = OM_S_SUCCESS;

quit:

  return status ;

}

/***************************************************************************
   Function wakeup
      Used in form control.  Is called automically by system form routines.
****************************************************************************/
wakeup ()
{
#ifdef DEBUG
  printf("in command wakeup, done=%d\n", done );
#endif
  //message( cmdtitle );

  //if (  rerun == TRUE )
 // {
  	//FIg_reset ( gPltDrawDataFrmPtr, LIST);
  	//FIg_reset ( gPltDrawDataFrmPtr, OBJLIST);
	//rerun = FALSE;
	//go();
//  }
}
/******* End of wakeup ********/

/***************************************************************************
   Function sleep
      Used in form control.  Is called automically by system form routines.
****************************************************************************/
sleep ()
{
}
/******* End of sleep ********/

/***************************************************************************
   Function delete
      Used in form control.  Is called automically by system form routines.
****************************************************************************/
delete ()
{
#ifdef DEBUG
printf("in command delete, done=%d\n", done );
#endif

   if( form_PltDrawData_exists == TRUE )
   {
      FIf_delete ( gPltDrawDataFrmPtr );
      form_PltDrawData_exists = FALSE;
      form_PltDrawData_displayed = FALSE;
   }
}



/****************************************************************
* main:
*	- This is the start of the ppl program.
*
*****************************************************************/
main()
{
int	status ;
int	retCode ;
int	savDebugFlag ;
char 	log[30];
IGRchar	product_path[256];

LPD_Sht_Index = 0;

status 	= OM_S_SUCCESS;
retCode = OM_S_SUCCESS;
ptr	= NULL;

        /* open the log file to print out posting information */
	sprintf(log, "%s","PLOTpost.log");
        ptr = fopen(log, "w+");
        if(ptr == NULL)
          UI_status("Can not open log file for writing...");


        UI_status("Processing..........................");
	
	/* make sure that we have a Plot Tree */
	status = verify_plot_tree( &retCode );
	__CheckRC( retCode, status, "verify_plot_tree", leave );
	
	/*
	 * Make sure that we are connected to the server through postman
	 * before processing the extraction. 
	 */
	status = verify_connect_postman( &retCode );
	__CheckRC( retCode, status, "verify_connect_postman", leave );

	/*
	 * Determine which aim server we are connected to.
	 * It must be SIR for now.
	 */
	status = determine_AIM( &retCode );
	__CheckRC( retCode, status, "determin_AIM", quit );


	/*
	 * Verify that the Default Aim Data is set on the file.
	 * If it is set, then get the context id from the collector.
	 
	status = get_ctx_id( &retCode );
	__CheckRC( retCode, status, "get_ctx_id", leave );
	*/
	/*
	 * Verify that the context is checked in on the AIM server.
	 
	status = is_ctx_checked_out_in_AIM( &retCode );
	__CheckRC( retCode, status, "is_ctx_checked_out_in_AIM", leave );
	*/
	/*
	 * Verify that the context is in a vault on the AIM server.
	 
	status = is_ctx_in_vault_in_AIM( &retCode );
	__CheckRC( retCode, status, "is_ctx_in_vault_in_AIM", leave );
	*/
	
	
	/*
	 * Get the PDU file information from the file.
	 */
	status = get_file_info( &retCode );
	__CheckRC( retCode, status, "get_file_info", quit );

	/*
	 * Get the name of the server that postman is connected to.
	 */
	status = get_server_name( &retCode );
	__CheckRC( retCode, status, "get_server_name", quit );

	/*********************************************************
	 * TLS: NEW Enhancements 06/30/00
	 *	-	Added an interface to retrieve information from the user
	 *		in order to process the sheet based on their wishes.
	 *
	 *********************************************************/
	 
		/* make sure that the Drawing object exist in the file before processing a plot extration */
		
		/*status = v$getDrawObj(&gDrwObj);*/

		status = OM_S_SUCCESS;

		if (status == OM_S_SUCCESS)
		{

			/* Get the product path for VDS */
			status = PLT_getProdInfo( "I_VDS", NULL, product_path );
  		   
			status = form_init ( product_path );
			if( form_PltDrawData_exists != TRUE )
			{ 
  				#ifdef DEBUG
  				printf("form not initialized, exiting\n");
  				#endif
  			
  				UI_status("FATAL: Form not found");
				fprintf(ptr,"\tFATAL: Form not found.\n");
				goto quit;
			}
			else 
			{
				status = form_disp( );
			}
			 
			get_input( "Select options" );
		
			goto quit;
			
		}
		else
		{
			fprintf(ptr, "Drawing Object Does Not Exist In The Current File.....\n");
			UI_status( "Drawing Object Not Found.....");
			status = OM_S_SUCCESS;
			goto quit;
		} 

quit:
	if(status != OM_S_SUCCESS)
        {
          fprintf(ptr, "Process Terminated.....\n");
          UI_status( "Process Terminated.....");
        }
        else
        {
	  fprintf( "Process Complete.......\n" );
	  UI_status( "Process Complete......." );
        }

leave:

        fclose(ptr);
        ptr = NULL;

}

