/*
**  NAME:                           cnvschfl.rc
**  AUTHORS:                        Sunil Murthy
**  CREATION DATE:                  01/19/93
**  ABSTRACT:
**      Utility for fixing the schema file.
**
**  REVISION HISTORY:
*/

/*
**  INCLUDES
*/
#include <stdio.h>
#include <ctype.h>
#include <termio.h>
#include <signal.h>
#include "rislimit.h"
#include "risver.h"
#include "riscom.h"
#include "risprods.h"
#include "risstjmp.h"
#include "file.h"
#include "schfile.h"
#include "ris.h"

/*
**  FUNCTION PROTOTYPES
*/
#define cnvschfl_rc
#include "sys.prt"
#include "sysalloc.prt"
#include "wrap.prt"
#include "ris.prt"
#include "cnvschfl.prt"
#include "comjmp.prt"
#include "compd.prt"
#include "comprtcl.prt"
#include "netgnerc.prt"

/*
** DEFINES
*/
#define OSCOUNT 3
#define ID_BUFFER_SIZE  256

#if defined(__Sol2__)
# define _NSIG _sys_nsig
#elif defined(Soli)
# define _NSIG 34
#elif defined (sun)
# define _NSIG NSIG
#endif

/*
** VARIABLES
*/
char * ostypes[] =
	{
		"UNIX",
		"VAX/VMS",
		"WINDOWS NT",
	};
char ostype_letter[OSCOUNT] = "UVN";


char yesno[2] = "YN";
char id[ID_BUFFER_SIZE];
char id_name[ID_BUFFER_SIZE];
char filename[L_tmpnam];
char tmp_name[L_tmpnam];
char tmp_id_name[L_tmpnam];

	
schema_file_parms *file_parms;

/*
**  FUNCTIONS
*/

/******************************************************************************/

static void warn_1()
{
	printf("                    ************  WARNING:  ************ \n");
	printf("Notice that  the program  doesn't verify  the values specified in the SERVER_VERSION\n");
	printf("entry. If  these entries  are not\n");
	printf("correctly specified,  run this program again to set them to correct ones.\n");
	printf("                    ************************************ \n");
}

/******************************************************************************/

static void head()
{
	printf("================================================================================\n");
	printf("This program makes it possible for users to modify the RIS schema file by adding\n");
	printf("the SERVER_VERSION field  to the schema section of every schema in the schema file.\n");
	printf("Before making modifications,  you must understand the meaning of the field by\n");
	printf("consulting the README file for this product and the RIS SQL Reference Manual.\n");
	printf("\n\n");
	warn_1();
	printf("\n");
	printf("If you experience  problems,  please call our support hotline at  1-800-633-7248\n");
	printf("and log a problem.\n");
	printf("================================================================================\n");
}

/******************************************************************************/

static int read_id_file(
	char	*buffer,
	int		size)
{
	char	*ptr;
	char	temp_name[L_tmpnam];
	FILE	*filep;

	/*
	**	NOTE:	If the id file doesn't exist, this routine will put a 
	**			null string in buffer and return RIS_SUCCESS
	*/

	*buffer = 0;
  	tmpnam(temp_name);

	if (!NET_get_file(&RIS_file_net,&RIS_file_connect,RIS_id_file,
		temp_name))
	{
		if ((filep = fopen(temp_name, "r")) == NULL)
		{
			unlink(temp_name);
			return -1;
		}

		fgets(buffer, size, filep);
		if ((ptr = strchr(buffer, '\n')) == NULL) /*itbokic 3/30 */
			ptr = buffer + (size - 1);
		*ptr = 0;

		unlink(temp_name);
		return 1;
	}
	else
	{
		unlink(temp_name);
		return -1;
	}
}

/******************************************************************************/

static void no_change_exit()
{
	read_id_file(id, ID_BUFFER_SIZE);
	if (!strcmp(id, id_name))
	{
		NET_remove_file(&RIS_file_net,&RIS_file_connect, RIS_id_file);
	}
	NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
	unlink(filename);
	unlink(tmp_name);
	unlink(tmp_id_name);
	printf("\nNo modifications have been made. Bye!\n\n");
	exit(1);
}

/******************************************************************************/

static void sig_handler(int sig)
{
	printf("\nInterrupt ... by sig == %d\n", sig);
	no_change_exit();
}

/******************************************************************************/

extern void init_signal()
{
	int sig;

	for (sig=1;sig < _NSIG;sig++)
	{
		switch(sig)
		{

/* handle these signals */

			case SIGHUP:
			case SIGINT:
			case SIGQUIT:
			case SIGILL:
			case SIGABRT:
			case SIGEMT:
			case SIGFPE:
			case SIGBUS:
			case SIGSEGV:
			case SIGSYS:
			case SIGPIPE:
			case SIGTERM:
#if !defined (sun)
			case SIGPWR:
#endif
				if (sigset(sig, &sig_handler) == SIG_ERR)
				{
					printf("\nError: sigset for sig == %d failed\n", sig);
					no_change_exit();
				}
			break;

			default:
			break;
		}
	}
}

/******************************************************************************/

static void init_net_parms_addr(
	schema_file_parms *sf,
	char	**ptr)
{
	
	/*
	** initialize protocol address
	*/
	RIScom_init_protocols(
		RIS_local_xns_addr, sizeof(RIS_local_xns_addr),
		RIS_local_tcp_addr, sizeof(RIS_local_tcp_addr),
		RIS_local_lu62_addr, sizeof(RIS_local_lu62_addr),
		RIS_local_dnp_addr, sizeof(RIS_local_dnp_addr));

	/*
	** initialize network parameters
	*/
	switch(sf->protocol)
	{
		case 'M':
			RIS_file_net.protocol = SHMEM;

			break;

		case 'T':
			RIS_file_net.protocol = TCP;
			strcpy(RIS_file_connect.tcp.address, sf->address);
			strcpy(RIS_file_connect.tcp.username, sf->username);
			RIScom_depd(sf->password, RIS_file_connect.tcp.password);
			*ptr = RIS_local_tcp_addr;

			break;

		case 'X':
			RIS_file_net.protocol = XNS;
			strcpy(RIS_file_connect.xns.address, sf->address);
			strcpy(RIS_file_connect.xns.username, sf->username);
			RIScom_depd(sf->password, RIS_file_connect.xns.password);
			*ptr = RIS_local_xns_addr;

			break;

		case 'D':
			RIS_file_net.protocol = DNP;
			strcpy(RIS_file_connect.dnp.node_name, sf->address);
			strcpy(RIS_file_connect.dnp.userid, sf->username);
			RIScom_depd(sf->password, RIS_file_connect.dnp.password);
			*ptr = RIS_local_dnp_addr;

			break;

		default:

			break;
	}
}

/******************************************************************************/

static char get_answer(
	char *prompt,
	int answer_count,
	char answers[],
	char def)
{
	char *ptr;
	int i;
	char buf[80];

	buf[0] = '\0';

	while(1)
	{
		printf("%s",prompt);
		fflush(stdout);
		if (!gets(buf))
		{
			continue;
		}
		ptr = buf;
		while (*ptr && isspace(*ptr)) /*itbokic 3/30 */
		{
			++ptr;
		}
		if (islower(*ptr)) /*itbokic 3/30 */
		{
			*ptr = _toupper(*ptr);
		}
		if ((*ptr == '\0') && (!strcmp(answers, yesno)))
		{
			*ptr = def;
		}
		for (i=0; i < answer_count; ++i)
		{
			if (*ptr == answers[i])
			{
				return *ptr;
			}
		}
		printf("<%c> is not a valid answer.\n", *ptr);
	}
}

/******************************************************************************/

static char get_ostype()
{
	int i=0;
	char answer;

	printf("\n\tSelection List For OSTYPE\n");
	for (i=0; i < OSCOUNT; i++)
	{
		printf("\t %c:  %s\n", ostype_letter[i], ostypes[i]);
	}
	answer = get_answer(
				"\tEnter your selection:", 
				OSCOUNT, ostype_letter, '\0');

	return answer;
}

/******************************************************************************/

static void get_osuser(
	char *prompt,
	char *str)
{
    char *ptr;
    char buf[80];
    buf[0] = '\0';

    while(1)
    {
        printf("%s",prompt);
        fflush(stdout);
        if (!gets(buf))
        {
            continue;
        }
        ptr = buf;
        while (*ptr && isspace(*ptr)) /*itbokic 3/30 */
        {
            ++ptr;
        }
		if (*ptr != '\0')
		{
			break;
		}
		printf("\nOSUSER currently is not set.");
		printf("You must set it now.\n");
    }
	strcpy(str, ptr);
}

/******************************************************************************/

static void get_passwd(
	char *prompt,
	char *str)
{
	struct termio termdata;
    char *ptr;
    char buf[80];
    buf[0] = '\0';

    while(1)
    {
        printf("%s",prompt);
        fflush(stdout);

		/* set io to no echo, no buffer */
		ioctl(0, TCGETA, &termdata);
		termdata.c_lflag &= ~ICANON & ~ECHO;
		termdata.c_cc[4] = 1;
		ioctl(0, TCSETA, &termdata);

        if (!gets(buf))
        {
            continue;
        }

		/* set io to echo, buffer */
		ioctl(0, TCGETA, &termdata);
		termdata.c_lflag |= ICANON | ECHO;
		termdata.c_cc[4] = 4;
		ioctl(0, TCSETA, &termdata);

        ptr = buf;
        while (*ptr && isspace(*ptr)) /*itbokic 3/30 */
        {
            ++ptr;
        }
		break;
    }
	strcpy(str, ptr);
    printf("\n");
    fflush(stdout);
}

/******************************************************************************/

static int db_display(
	FILE *in)
{
	char buffer[LINE_BUFFER_SIZE];
	char dtype=0;
	int db_show=0;
	int shown=0;

	for(;;)
	{
		memset (buffer,0, LINE_BUFFER_SIZE);
		if (fgets(buffer, LINE_BUFFER_SIZE, in) == NULL)
		{
			shown = 0;
			break;
		}
		if (buffer[LINE_BUFFER_SIZE - 2] && 
			buffer[LINE_BUFFER_SIZE - 2] != '\n')
		{
			printf("\nFound a line that's too long in the RIS schema file.\n");
			no_change_exit();
		}

		if (!strncmp(buffer, DTYPE, DTYPE_SIZE)) /*itbokic 3/30 */
		{
			db_show = 1;
			dtype = *(buffer + DTYPE_SIZE);
			printf("\n");
			printf(
			"--------------------------------------------------------------------------------\n");
			switch(dtype)
			{
				case 'X':
					printf("DTYPE=INFORMIX\n");
					break;
				case 'O':
					printf("DTYPE=ORACLE\n");
					break;
				case 'I':
					printf("DTYPE=INGRES\n");
					break;
				case 'D':
					printf("DTYPE=DB2\n");
					break;
				case 'R':
					printf("DTYPE=RDB\n");
					break;
				case 'Y':
					printf("DTYPE=SYBASE\n");
					break;
				case 'M':
					printf("DTYPE=MSSQL\n");
					break;
				default:
					printf("DTYPE=UNKNOWN\n");
					break;
			}
		}
		else if (!strncmp(buffer,  "--------------------------------------------------------------", 42)) /*itbokic */
		{
			if (db_show == 1)
			{
				printf("%s", buffer);
				shown = 1;
				db_show = 0;
				break;
			}
		}
		else
		{
			if (db_show == 1)
			{
				printf("%s", buffer);
			}
		}
	}
	return shown;
}

/******************************************************************************/

static int read_write_file(
	FILE *in_0,
	FILE *in,
	FILE *out)
{
	char buffer[LINE_BUFFER_SIZE];
	int len;
	char dbname[RIS_MAX_ID_SIZE];
	char ostypebuf[OSTYPE_SIZE+2];
	char osuserbuf[OSUSER_SIZE + RIS_MAX_ID_SIZE];
	char osuser[RIS_MAX_ID_SIZE];
	char old_osuser[RIS_MAX_ID_SIZE];
	char ospasswdbuf[OSPASS_SIZE + RIS_MAX_PASSWD_SIZE];
	char ospasswd[RIS_MAX_PASSWD_SIZE];
	char old_ospasswd[RIS_MAX_PASSWD_SIZE];
	char ospasswd1[RIS_MAX_PASSWD_SIZE];
	char envbuf[ENV_SIZE + RIS_MAX_ID_SIZE];
	char encpt[RIS_MAX_PASSWD_SIZE];
	char depd[RIS_MAX_PASSWD_SIZE];
	char nodeportbuf[20];
	char os;
	char old_os;
	char confirm;
	char *osuserptr;
	char *ospassptr;
	char dtype=0;
	int protocol_count=0;
	int netaddr_count=0;
	int linenum=0;
	int dbname_linenum=0;
	int osuser_linenum=0;
	int ospass_linenum=0;
	int os_linenum=0;
	int group_linenum=0;
	int lastnet_linenum=0;
	int cflag=0;
	int empty=1;
	int swap_env_protocol=0;

	for(;;)
	{
		memset (buffer,0, LINE_BUFFER_SIZE);
		if (fgets(buffer, LINE_BUFFER_SIZE, in) == NULL)
		{
			break;
		}
		linenum++;

		if (buffer[LINE_BUFFER_SIZE - 2] && 
			buffer[LINE_BUFFER_SIZE - 2] != '\n')
		{
			printf("\nFound a line that's too long in the RIS schema file %d\n",linenum);
			no_change_exit();
		}

		if (!strncmp(buffer, DBNAME, DBNAME_SIZE)) /*itbokic 3/30 */
		{
			dbname_linenum = linenum;

			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, DTYPE, DTYPE_SIZE)) /*itbokic 3/30 */
		{
			db_display(in_0);
			empty = 0;
			dtype = *(buffer + DTYPE_SIZE);

			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, NETADDR, NETADDR_SIZE)) /*itbokic 3/30 */
		{
			netaddr_count++;
			if (netaddr_count == RIS_MAX_PROTOCOLS)
			{
				lastnet_linenum = linenum;
				netaddr_count=0;
			}
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, PROTOCOL, PROTOCOL_SIZE) && !protocol_count) /*itbokic 3/30 */
		{
			if (linenum == (dbname_linenum + 1))
			{
				printf("\nThe OSTYPE entry currently does not exist. ");
				printf("You must specify it now.\n");
				os = get_ostype();
				memset (ostypebuf, 0, OSTYPE_SIZE+2);
				sprintf(ostypebuf, "OSTYPE=%c\n", os);
				cflag = 1;
	
				if (fputs(ostypebuf, out) == EOF)
				{
					printf("Error writing to file: linenum:%d\n", linenum);
					break;
				}
				fflush(out);
			}
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, OSTYPE, OSTYPE_SIZE)) /*itbokic 3/30 */
		{
			old_os = *(buffer + OSTYPE_SIZE);
			if (isalpha((int)old_os)) /*itbokic 3/30 */
			{
				printf("\nOSTYPE currently is set to <%c>. \n", old_os);
				confirm = get_answer("\tDo you wish to change it (Y/N)? [N]:", 
					2, yesno, 'N');
			}
			else
			{
				printf("\nOSTYPE currently is not set. You must set it now.\n");
				confirm = 'Y';
			}
			if (confirm == 'Y')
			{
				os = get_ostype();
				memset (ostypebuf, 0, OSTYPE_SIZE+2);
				sprintf(ostypebuf, "OSTYPE=%c\n", os);
				if (old_os != os)
				{
					cflag = 1;
				}

				if (fputs(ostypebuf, out) == EOF)
				{
					printf("\nError writing to file: linenum:%d\n", linenum);
					break;
				}
				fflush(out);
			}
			else
			{
				if (fputs(buffer, out) == EOF)
				{
					printf("\nError writing to file: linenum:%d\n", linenum);
					break;
				}
				fflush(out);
			}
		}
		else if (!strncmp(buffer, SCHFILE_DIR, DIR_SIZE) || /*itbokic 3/30 */
				 !strncmp(buffer, ARCH, ARCH_SIZE)) /*itbokic 3/30 */
		{
			if ((lastnet_linenum == linenum - 1 || 
				 osuser_linenum == linenum - 1) &&
				(dtype == 'O' || dtype == 'D' || dtype == 'Y' || dtype == 'M'))
			{
				if (lastnet_linenum == linenum - 1)
				{
					printf("\nThe OSUSER entry currently does not exist. ");
					printf("You must specify it now.\n");
					get_osuser("\tEnter an operating system username:", osuser);
					sprintf(osuserbuf, "OSUSER=%s\n", osuser);
					cflag = 1;
					if (fputs(osuserbuf, out) == EOF)
					{
						printf("\nError writing to file: linenum:%d\n", linenum);
						break;
					}
					fflush(out);
				}
				printf("\nThe OSPASS entry currently does not exist. ");
				printf("You must specify it now.\n");
ospass_lp_1:
				get_passwd("\tEnter new password:", ospasswd);
				get_passwd("\tRe-enter new password:", ospasswd1);
				if (ospasswd && ospasswd1)
				{
					if (strcmp(ospasswd, ospasswd1))
					{
						printf("They don't match; try again.\n");
						printf("\nOSPASS currently is not set.\n");
						confirm = get_answer(
							"\tDo you wish to change it (Y/N)? [N]:", 
							2, yesno, 'N');
						if (confirm == 'N')
						{
							sprintf(ospasswdbuf, "OSPASS=\n");
						}
						else
						{
							goto ospass_lp_1;
						}
					}
					else
					{
						RIScom_pd(ospasswd, encpt);
						sprintf(ospasswdbuf, "OSPASS=%s\n", encpt);
					}
				}
				else
				{
					sprintf(ospasswdbuf, "OSPASS=\n");
				}
				cflag = 1;
				if (fputs(ospasswdbuf, out) == EOF)
				{
					printf("\nError writing to file: linenum:%d\n", linenum);
					break;
				}
				fflush(out);
			}
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, OSUSER, OSUSER_SIZE)) /*itbokic 3/30 */
		{
			osuser_linenum = linenum;
			if (dtype == 'O' || dtype == 'D' || dtype == 'Y' || dtype == 'M')
			{
				osuserptr = buffer + OSUSER_SIZE;
				if ((len = strlen(osuserptr) -1) == 0)
				{
					memset(osuser, 0, RIS_MAX_ID_SIZE);
					printf("\nOSUSER currently is not set. ");
					printf("You must set it now.\n");
					get_osuser("\tEnter an operating system username:", osuser);
					cflag = 1;
					sprintf(osuserbuf, "OSUSER=%s\n", osuser);
					if (fputs(osuserbuf, out) == EOF)
					{
						printf("\nError writing to file: linenum:%d\n", linenum);
						break;
					}
					fflush(out);
				}
				else
				{
					memset (old_osuser, 0, RIS_MAX_ID_SIZE);
					memcpy (old_osuser, osuserptr, len);
					printf("\nOSUSER currently is set to <%s>. \n", old_osuser);
					confirm = get_answer(
						"\tDo you wish to change it (Y/N)? [N]:", 
						2, yesno, 'N');
					if (confirm == 'Y')
					{
						memset(osuser, 0, RIS_MAX_ID_SIZE);
						get_osuser("\tEnter an operating system username:",
							osuser);
						sprintf(osuserbuf, "OSUSER=%s\n", osuser);
						if (strcmp(old_osuser, osuser))
						{
							cflag = 1;
						}
						if (fputs(osuserbuf, out) == EOF)
						{
							printf("\nError writing to file: linenum:%d\n",
								linenum);
							break;
						}
						fflush(out);
					}
					else
					{
						if (fputs(buffer, out) == EOF)
						{
							printf("\nError writing to file: linenum:%d\n",
								linenum);
							break;
						}
						fflush(out);
					}
				}
			}
			else
			{
				printf("\nOSUSER field invalid for <%s>\n", dbname);
			}
		}
		else if (!strncmp(buffer, OSPASS, OSPASS_SIZE)) /*itbokic 3/30 */
		{
			ospass_linenum = linenum;
			if (dtype == 'O' || dtype == 'D' || dtype == 'Y' || dtype == 'M')
			{
				if (lastnet_linenum == linenum - 1)
				{
					printf("\nThe OSUSER entry currently does not exist. ");
					printf("You must specify it now.\n");
					get_osuser("\tEnter an operating system username:", osuser);
					sprintf(osuserbuf, "OSUSER=%s\n", osuser);
					cflag = 1;
					if (fputs(osuserbuf, out) == EOF)
					{
						printf("\nError writing to file: linenum:%d\n", linenum);
						break;
					}
					fflush(out);
				}
				ospassptr = buffer + OSPASS_SIZE;
				memset (old_ospasswd, 0, RIS_MAX_PASSWD_SIZE);
				memcpy (old_ospasswd, ospassptr, strlen(ospassptr)-1);
				RIScom_depd (old_ospasswd, depd);
				
ospass_lp_2:
				if ((len = strlen(ospassptr) -1) == 0)
				{
					printf("\nOSPASS currently is not set. \n");
				}
				else
				{
					printf("\nOSPASS currently is set. \n");
				}
				confirm = get_answer(
					"\tDo you wish to change it (Y/N)? [N]:", 
					2, yesno, 'N');

				if (confirm == 'Y')
				{
					memset(ospasswd, 0, RIS_MAX_PASSWD_SIZE);
					get_passwd("\tEnter new password:", ospasswd);
					get_passwd("\tRe-enter new password:", ospasswd1);
					if (ospasswd && ospasswd1)
					{
						if (!strcmp(ospasswd, ospasswd1))
						{
							RIScom_pd(ospasswd, encpt);
							sprintf(ospasswdbuf, "OSPASS=%s\n", encpt);
						}
						else
						{
							printf(
							"They don't match; no change for the password.\n");
							goto ospass_lp_2;
						}
					}
					else
					{
						sprintf(ospasswdbuf, "OSPASS=\n");
					}
					if (strcmp(depd, ospasswd))
					{
						cflag = 1;
					}
					if (fputs(ospasswdbuf, out) == EOF)
					{
						printf("\nError writing to file: linenum:%d\n", linenum);
						break;
					}
					fflush(out);
				}
				else
				{
					if (fputs(buffer, out) == EOF)
					{
						printf("\nError writing to file: linenum:%d\n", linenum);
						break;
					}
					fflush(out);
				}
			}
			else
			{
				printf("\nOSPASSWD field invalid for <%s>\n", dbname);
			}
		}
		else if (!strncmp(buffer, OS, OS_SIZE)) /*itbokic 3/30 */
		{
			os_linenum = linenum;
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, ENV, ENV_SIZE)) /*itbokic 3/30 */
		{
			if (os_linenum == linenum - 1)
			{
				memset(envbuf, 0, ENV_SIZE + RIS_MAX_ID_SIZE);
				strcpy(envbuf, buffer);	
				swap_env_protocol = 1;
			}
			else
			{
				if (fputs(buffer, out) == EOF)
				{
					printf("\nError writing to file: linenum:%d\n", linenum);
					break;
				}
				fflush(out);
			}
		}
		else if (!strncmp(buffer, NET_PROTOCOL, NET_PROTOCOL_SIZE)) /*itbokic 3/30 */
		{
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
			if (swap_env_protocol)
			{
				swap_env_protocol = 0;
				if (fputs(envbuf, out) == EOF)
				{
					printf("\nError writing to file: linenum:%d\n", linenum);
					break;
				}
				fflush(out);
			}
		}
		else if (!strncmp(buffer, GROUP, GROUP_SIZE)) /*itbokic 3/30 */
		{
			group_linenum = linenum;
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, NODE, NODE_SIZE)) /*itbokic 3/30 */
		{
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else if (!strncmp(buffer, PORT, PORT_SIZE)) /*itbokic 3/30 */
		{
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
		else
		{
			if (dtype == 'D' && group_linenum && group_linenum == linenum - 1)
			{
				group_linenum = 0;
				memset (nodeportbuf, 0, 20);
				sprintf(nodeportbuf, "NODE=\nPORT=\n");
				if (fputs(nodeportbuf, out) == EOF)
				{
					printf("\nError writing to file: linenum:%d\n",linenum);
					break;
				}
				fflush(out);
				cflag = 1;
			}
			if (fputs(buffer, out) == EOF)
			{
				printf("\nError writing to file: linenum:%d\n", linenum);
				break;
			}
			fflush(out);
		}
	}
	if (empty)
	{
		printf("\nThe schema file is empty (no database entry specified).\n");
	}
	return cflag;
}

/******************************************************************************/

main(
	int argc,
	char *argv[])
{
	FILE *in_file_0;
	FILE *in_file;
	FILE *out_file_0;
	FILE *out_file;
	FILE *filep;
	char confirm;
	char confirm_rnm = 'N';
	char *schema_filename;
	char *net_addr_ptr;
	char *cptr;
	int	status;
	int	cflag, ch;

    if (argc > 1 || (argv[1] && !strcmp(argv[1], "-?")))
	{
		fprintf(stderr,"Usage: %s [-?]\n", argv[0]);
		exit(1);
	}
		
	status = SETJMP();
	if (status)
	{
		printf("\nGet a error from RIS function. Aborting..\n");
		RESETJMP();
		no_change_exit();
	}

	init_signal();
	
	printf("\n\n");
	head();
	
	file_parms = (schema_file_parms *)malloc(sizeof(schema_file_parms));
	RISget_schema_file_location(file_parms);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf("\nCan not get the location of RIS schema file from the parms file. Aborting..\n");
		RISterminate();
		exit(1);
	}
	
	printf("\nThe schema file to be fixed is: <%s> ", file_parms->filename);
	if (file_parms->protocol != 'M')
	{
		printf("at REMOTE node <%s>.\n\n", file_parms->address);
	}
	else
	{
		printf("at LOCAL node.\n\n");
	}
	printf("If this is not  the file you want to fix, you may use the command \"locate schema\n");
	printf("file\" in RIS interactive utility to set it to correct one.\n");
	confirm = get_answer(
		"\nDo you wish to fix this schema file now (Y/N)? [Y]:", 2, yesno, 'Y');
	
	printf(
	"================================================================================\n");

	if (confirm == 'N')
	{
		no_change_exit();
	}

	printf("Running 'get schema file' ...\n");
	RIS_upgrade_flag = 1;
	RISget_schema_file(&schema_filename, 0, 0, 0);
	if (SQLCODE != RIS_SUCCESS)
	{
		printf("\nCan not get the schema file (it may be missing or corrupted). Aborting..\n");
		exit(1);
	}
	printf("machine       :");
	if (file_parms->protocol != 'M')
	{
		printf("   <%s>\n", file_parms->address);
	}
	else
	{
		printf("   LOCAL\n");
	}
	printf("schema file   :   <%s>\n", schema_filename);

	strcpy(RIS_file, schema_filename);
	strcpy(RIS_lock_file, schema_filename);
	strcat(RIS_lock_file, ".LCK");
	strcpy(RIS_id_file, schema_filename);
	strcat(RIS_id_file, ".ID");
	net_addr_ptr = "";
	init_net_parms_addr(file_parms, &net_addr_ptr);
	/*
	**	lock schema file
	*/
	if (NET_get_lock_file(&RIS_file_net,&RIS_file_connect, RIS_lock_file))
	{
		printf("\nThe RIS schema file may be in use by other user (otherwise, the schema lock file\n");
		printf("is abnormally missing), try later.\n");
		exit(1);
	}

	tmpnam(tmp_name);
	tmpnam(tmp_id_name);
	tmpnam(filename);
	
	/*
	** write schema id file
	*/
	if ((filep = fopen(tmp_id_name, "w")) == NULL)
	{
		printf("\n");
		fprintf(stderr,"%s: error opening tmp_id_name \"%s\"\n",
			argv[0], tmp_id_name);
		no_change_exit();
	}
	
	sprintf(id_name, "%s:%d", net_addr_ptr, getpid());

	if (fputs(id_name, filep) < 0)
	{
		fclose(filep);
		printf("\nCan not write tmp_id_name. Aborting..\n");
		no_change_exit();
	}

	fclose(filep);

	if (NET_put_file(&RIS_file_net, &RIS_file_connect, 
		tmp_id_name, RIS_id_file))
	{
		printf("\nCan not write RIS schema id file. Aborting..\n");
		no_change_exit();
	}

	/*
	**	make a copy of the schema file
	*/
	if (NET_get_file(&RIS_file_net, &RIS_file_connect,
		RIS_file, filename))
	{
		printf("\nCan not get RIS schema file. Aborting..\n");
		no_change_exit();
	}

	if ((in_file_0 = fopen(filename,"r")) == NULL)
	{
		printf("\n");
		fprintf(stderr,"%s: error opening schema file \"%s\"\n",
			argv[0], filename);
		printf("Check location of schema and rerun %s\n", argv[0]);
		no_change_exit();
	}
	if ((in_file = fopen(filename,"r")) == NULL)
	{
		printf("\n");
		fprintf(stderr,"%s: error opening schema file \"%s\"\n",
			argv[0], filename);
		printf("Check location of schema and rerun %s\n", argv[0]);
		no_change_exit();
	}
	if ((out_file = fopen(tmp_name, "w")) == NULL)
	{
		printf("\n");
		fprintf(stderr,"%s: error opening temp. file \"%s\"\n",
			argv[0], tmp_name);
	}
	if ((out_file_0 = fopen(tmp_name, "r")) == NULL)
	{
		printf("\n");
		fprintf(stderr,"%s: error opening temp. file \"%s\"\n",
			argv[0], tmp_name);
	}

	printf("\n================================================================================\n");
	if (!strcmp(file_parms->filename, "risschema"))
	{
		printf("\nThe name of schema file is an old default name: 'risschema'.\n");
		confirm_rnm = get_answer("Do you wish to rename it to new default name: 'schemas' (Y/N)? [Y]:", 2, yesno, 'Y');
	}
	
	cflag = read_write_file(in_file_0, in_file, out_file);

	if (!cflag && confirm_rnm != 'Y')
	{
		no_change_exit();
	}

	printf("\n================================================================================\n");
	if (!cflag)
	{
			printf("\nNo modifications have been made for the contents of the schema file.\n");
			printf("\nBut, the name of default schema file will be changed to 'schemas'.\n");
	}
	else
	{
		printf("\nBefore all the changes you have made above are written back the RIS schema file,\n");
		printf("please review the new contents of the schema file as following.\n");
		while (db_display(out_file_0))
		{
			printf("\nType RETURN key to continue:");
			while ((ch = getchar()) != '\n')
			{
			}
		}
		printf("\n--------------------------------------------------------------------------------\n");
		if (confirm_rnm == 'Y')
		{
			printf("\nThe name of default schema file will be changed to 'schemas'.\n");
		}
	}
	printf("\n================================================================================\n");
	confirm = get_answer(
		"\nDo you wish to accept all above changes (Y/N)? [Y]:", 2, yesno, 'Y');
	if (confirm == 'Y')
	{
		read_id_file(id, ID_BUFFER_SIZE);
		if (strcmp(id, id_name))
		{
			printf("\nOther users may have changed the oringial RIS schema file, while you are running\n");
			printf("the covertschfile utility. In order to make sure that your changes are performed\n");
			printf("on the current schema file, try later.\n");
			no_change_exit();
		}
		if (confirm_rnm == 'Y')
		{
			strcpy(file_parms->filename, "schemas");
#ifndef OLD
			RIScom_depd(file_parms->password, file_parms->password);
#endif
			RISlocate_schema_file(file_parms);
			if (SQLCODE != RIS_SUCCESS)
			{
				printf("\nCan not store the location of RIS schema file to the parms file. Aborting..\n");
				RISterminate();
				exit(1);
			}
			cptr = strrchr(RIS_file, '/'); /*itbokic 3/30 */
			*cptr = '\0';
			strcat(RIS_file, "/schemas");
			cptr = strrchr(RIS_lock_file, '/'); /*itbokic 3/30/95 */
			*cptr = '\0';
			strcat(RIS_lock_file, "/schemas.LCK");
		}
	   	if (NET_put_file(&RIS_file_net, &RIS_file_connect, tmp_name,
		   	RIS_file))
	   	{
			printf("\nFail to write new RIS schema file back. Aborting..\n");
			no_change_exit();
	   	}
		NET_remove_file(&RIS_file_net,&RIS_file_connect, RIS_id_file);
	   	NET_put_lock_file(&RIS_file_net, &RIS_file_connect, RIS_lock_file);
		if (confirm_rnm == 'Y')
		{
			NET_remove_file(&RIS_file_net,&RIS_file_connect, schema_filename);
		}
		unlink(filename);
		printf("\nRunning 'checksum schema file' ...\n");
		RISrestore_schema_file_checksum();
		if (SQLCODE != RIS_SUCCESS)
		{
			printf("\nRIS schema file is corrupted. Aborting..\n");
			no_change_exit();
		}
		unlink(tmp_name);
		unlink(tmp_id_name);
		unlink(filename);
		printf("\n");
		warn_1();
		printf("\nProgram complete. Bye!\n\n");
		RISterminate();
		exit(0);
	}
	else
	{
		no_change_exit();
	}
}

/******************************************************************************/
