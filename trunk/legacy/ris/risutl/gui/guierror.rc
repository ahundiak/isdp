/* Do not alter this SPC information: $Revision: 1.3.27.1 $ */
/*
**	NAME:									guierror.c
**	AUTHORS:								Terry McIntyre
**	CREATION DATE:							11/90
**	ABSTRACT:
**		The code to process ris errors for the schema manager.
**	
**	REVISION HISTORY:
**
**	11/94:	Added support for INTERNATIONALIZATION.  Rick Kramer
*/
 
/*
**	INCLUDES
*/
#include "gui.h"
#include "rislimit.h"
#if defined(WIN32)
#include <windows.h>
#include <wchar.h>
#endif
#include "ucommon.h"

/*
**	FUNCTION PROTOTYPES
*/
#define guierror_c
#include "comdebug.prt"
#include "fi.prt"
#include "guierror.prt"
#include "comumsg.prt"
#include "ucoerrbx.prt"
#include "ris.prt"
#if defined(WIN32)
#include "comuni.prt"
#endif


/*
**	DEFINES
*/

/*
**	VARIABLES
*/
static struct fi_error_s
{
    int error;
    int name;
    int msg;
} fi_error[] =
{
	{
		FI_SUCCESS,
		(int)RISUTL_I_FI_SUCCESS,
		(int)RISUTL_I_FI_SUCCESS_MSG
	},
	{
		FI_FORM_FILE_NOT_FOUND,
		(int)RISUTL_I_FI_FORM_FILE_NOT_FOUND,
		(int)RISUTL_I_FI_FORM_FILE_NOT_FOUND_MSG
	},
	{
		FI_FORM_FILE_READ_ERROR,
		(int)RISUTL_I_FI_FORM_FILE_READ_ERROR,
		(int)RISUTL_I_FI_FORM_FILE_READ_ERROR_MSG
	},
	{
		FI_FORM_NOT_DISPLAYED,
		(int)RISUTL_I_FI_FORM_NOT_DISPLAYED,
		(int)RISUTL_I_FI_FORM_NOT_DISPLAYED_MSG
	},
	{
		FI_FORM_DISPLAYED,
		(int)RISUTL_I_FI_FORM_DISPLAYED,
		(int)RISUTL_I_FI_FORM_DISPLAYED_MSG
	},
	{
		FI_QUIET_MODE_ON,
		(int)RISUTL_I_FI_QUIET_MODE_ON,
		(int)RISUTL_I_FI_QUIET_MODE_ON_MSG
	},
	{
		FI_NO_WINDOWS_AVAIL,
		(int)RISUTL_I_FI_NO_WINDOWS_AVAIL,
		(int)RISUTL_I_FI_NO_WINDOWS_AVAIL_MSG
	},
	{
		FI_NO_SUCH_FORM,
		(int)RISUTL_I_FI_NO_SUCH_FORM,
		(int)RISUTL_I_FI_NO_SUCH_FORM_MSG
	},
	{
		FI_LABEL_IN_USE,
		(int)RISUTL_I_FI_LABEL_IN_USE,
		(int)RISUTL_I_FI_LABEL_IN_USE_MSG
	},
	{
		FI_NO_SUCH_GADGET,
		(int)RISUTL_I_FI_NO_SUCH_GADGET,
		(int)RISUTL_I_FI_NO_SUCH_GADGET_MSG
	},
	{
		FI_NO_MEMORY,
		(int)RISUTL_I_FI_NO_MEMORY,
		(int)RISUTL_I_FI_NO_MEMORY_MSG
	},
	{
		FI_NO_SUCH_GROUP,
		(int)RISUTL_I_FI_NO_SUCH_GROUP,
		(int)RISUTL_I_FI_NO_SUCH_GROUP_MSG
	},
	{
		FI_NO_PASS_ON,
		(int)RISUTL_I_FI_NO_PASS_ON,
		(int)RISUTL_I_FI_NO_PASS_ON_MSG
	},
	{
		FI_NO_SUCH_VS,
		(int)RISUTL_I_FI_NO_SUCH_VS,
		(int)RISUTL_I_FI_NO_SUCH_VS_MSG
	},
	{
		FI_INVALID_GADGET_TYPE,
		(int)RISUTL_I_FI_INVALID_GADGET_TYPE,
		(int)RISUTL_I_FI_INVALID_GADGET_TYPE_MSG
	},
	{
		FI_INVALID_FORMAT,
		(int)RISUTL_I_FI_INVALID_FORMAT,
		(int)RISUTL_I_FI_INVALID_FORMAT_MSG
	},
	{
		FI_INVALID_VERSION,
		(int)RISUTL_I_FI_INVALID_VERSION,
		(int)RISUTL_I_FI_INVALID_VERSION_MSG
	},
	{
		FI_ILLEGAL_VALUES,
		(int)RISUTL_I_FI_ILLEGAL_VALUES,
		(int)RISUTL_I_FI_ILLEGAL_VALUES_MSG
	},
	{
		FI_FORM_FILE_OPEN_DENIED,
		(int)RISUTL_I_FI_FORM_FILE_OPEN_DENIED,
		(int)RISUTL_I_FI_FORM_FILE_OPEN_DENIED_MSG
	},
	{
		FI_INVALID_BUFFER,
		(int)RISUTL_I_FI_INVALID_BUFFER,
		(int)RISUTL_I_FI_INVALID_BUFFER_MSG
	},
	{
		FI_LOAD_FONT_ERROR,
		(int)RISUTL_I_FI_LOAD_FONT_ERROR,
		(int)RISUTL_I_FI_LOAD_FONT_ERROR_MSG
	},
	{
		FI_NO_SUCH_ENV_FUNCTION,
		(int)RISUTL_I_FI_NO_SUCH_ENV_FUNCTION,
		(int)RISUTL_I_FI_NO_SUCH_ENV_FUNCTION_MSG
	},
	{
		FI_INVALID_ROW,
		(int)RISUTL_I_FI_INVALID_ROW,
		(int)RISUTL_I_FI_INVALID_ROW_MSG
	},
	{
		FI_INVALID_COL,
		(int)RISUTL_I_FI_INVALID_COL,
		(int)RISUTL_I_FI_INVALID_COL_MSG
	},
	{
		FI_NO_CONNECTION,
		(int)RISUTL_I_FI_NO_CONNECTION,
		(int)RISUTL_I_FI_NO_CONNECTION_MSG
	},
	{
		FI_UNABLE_TO_SAVE_FORM,
		(int)RISUTL_I_FI_UNABLE_TO_SAVE_FORM,
		(int)RISUTL_I_FI_UNABLE_TO_SAVE_FORM_MSG
	},
	{
		FI_FORM_FILE_SAVE_ERROR,
		(int)RISUTL_I_FI_FORM_FILE_SAVE_ERROR,
		(int)RISUTL_I_FI_FORM_FILE_SAVE_ERROR_MSG
	},
	{
		FI_INVALID_NEWER_FORM_VERSION,
		(int)RISUTL_I_FI_INV_NEWER_FORM_VERSION,
		(int)RISUTL_I_FI_INV_NEWER_FORM_VERSION_MSG
	}
};

static int fi_error_count = sizeof(fi_error)/sizeof(struct fi_error_s);

/*
**	FUNCTIONS
*/

/******************************************************************************/

static int get_FI_error_name_key(
	int error)
{
    int	i;

    for (i = 0; i < fi_error_count; i++)
	{
        if (error == fi_error[i].error)
		{
			return fi_error[i].name;
		}
	}

	return RISUTL_I_UNKNOWN_FI_NAME; 
}

/******************************************************************************/

static int get_FI_error_message_key(
	int error)
{
    int	i;

    for (i = 0; i < fi_error_count; i++)
	{
        if (error == fi_error[i].error)
		{
			return fi_error[i].msg;
		}
	}

	return RISUTL_I_UNKNOWN_FI_MSG; 
}

/******************************************************************************/

extern void RISgui_note_box(
	char *ptr)
{
	GUI_DBG(("RISgui_error_box()\n%s", ptr));

	FI_message_box(FI_CURRENT_SCREEN, -1, -1,
		"NOTE", FI_BLUE, "dutch801b", 30.0,
		ptr, FI_BLACK, "mono821b", 15.0, FI_LEFT_JUSTIFIED, 81);
	GUI_DBG(("RISgui_note_box():complete\n"));
}

/******************************************************************************/

extern void RISgui_warning_box(
	char *ptr)
{
	GUI_DBG(("RISgui_warning_box()\n%s", ptr));
	FI_message_box(FI_CURRENT_SCREEN, -1, -1,
		"WARNING", FI_YELLOW, "dutch801b", 30.0,
		ptr, FI_BLACK, "mono821b", 15.0, FI_LEFT_JUSTIFIED, 81);
	GUI_DBG(("RISgui_warning_box():complete\n"));
}

/******************************************************************************/

extern void RISgui_error_box(
	char *ptr)
{
	GUI_DBG(("RISgui_error_box()\n%s", ptr));
	FI_message_box(FI_CURRENT_SCREEN, -1, -1,
		"ERROR", FI_RED, "dutch801b", 30.0,
		ptr, FI_BLACK, "mono821b", 15.0, FI_LEFT_JUSTIFIED, 81);
	GUI_DBG(("RISgui_error_box():complete\n"));
}

/******************************************************************************/

static void strncpy_null_terminate(
	char *s1,
	char *s2,
	int n)
{
	int i = 0;
#if defined(WIN32)
	wchar_t *in_data;
	wchar_t *out_data;
	out_data = (wchar_t *)s1;
#else
	char *in_data;
	char *out_data;
	in_data = s2;
	out_data = s1;
#endif
	/*
	**	Will copy up to n-1 bytes from s2 to s1, and then null terminate
	**	If s2 is shorter than n, s1 will be padded with nulls.
	**	If s2 is NULL, s1 will be filled with nulls.
	*/
#if defined(WIN32)
	RIScom_multiwide(&RISwide_ptr,&s2,&RISwide_size,MULTITOWIDE,n);
	in_data = RISwide_ptr;
#endif

	if (in_data)
	{
		for (; i < n-1 && *in_data; i++)
		{
			*out_data++ = *in_data++;
		}
	}

	for (; i < n; i++)
	{
		*out_data++ = WIDECHAR('\0'); 
	}
#if defined(WIN32)
	RIScom_wcstombs(s1,out_data,n);
#endif
}

/******************************************************************************/

extern void RISgui_errhandle(
	int error,
	int FI_error)
{
	GUI_DBG(("RISgui_errhandle(error:%d FI_error:%d)\n", error, FI_error));

	RIS_gui_error.error = error;
	strncpy_null_terminate(RIS_gui_error.error_name, RIScom_error_code(error),
			sizeof(RIS_gui_error.error_name));
	strncpy_null_terminate(RIS_gui_error.error_message,RIScom_umsg(error),
			sizeof(RIS_gui_error.error_message));

	RIS_gui_error.FI_error = FI_error;
	strncpy_null_terminate(RIS_gui_error.FI_error_name,
		RIScom_umsg(get_FI_error_name_key(FI_error)),
		sizeof(RIS_gui_error.FI_error_name));
	strncpy_null_terminate(RIS_gui_error.FI_error_message,
		RIScom_umsg(get_FI_error_message_key(FI_error)),
		sizeof(RIS_gui_error.FI_error_message));
}

/******************************************************************************/

extern char *RISgui_generate_error_box()
{
	char *ptr;
	static char buffer[1072];

	if (RIS_gui_error.FI_error)
	{
		ptr = RISuco_char_error_box(buffer, RISUTL_I_FORMS_ERROR,
			0, RIS_gui_error.error, NULL, 0, 0);

		RISuco_char_error_box(ptr, RISUTL_I_FI_ERROR,
			get_FI_error_name_key(RIS_gui_error.FI_error),
			RIS_gui_error.FI_error, NULL,
			get_FI_error_message_key(RIS_gui_error.FI_error), 1);

	}
	else
	{
		RISuco_char_error_box(buffer, RISUTL_I_FORMS_ERROR,
			0, RIS_gui_error.error, NULL, 0, 1);
	}

	return buffer;
}

/******************************************************************************/

extern int RISgui_report_error()
{
#if 0
	int code;
#endif

	exec sql begin declare section;
	char	*ptr;
	exec sql end declare section;

	if (RIS_gui_error.error == RISUTL_E_RIS_ERROR)
	{
#if 0
		code = risca->sqlcode;
#endif
		exec sql report error into :ptr;
	}
	else
	{
#if 0
		code = RIS_gui_error.error;
#endif
		ptr = RISgui_generate_error_box();
	}

#if 0
	if (RISgui_user_error_handler &&
		RISgui_user_error_handler(code, ptr) == 0) return 0;
#endif
	
	RISgui_error_box(ptr);

	return 1;
}

/******************************************************************************/
