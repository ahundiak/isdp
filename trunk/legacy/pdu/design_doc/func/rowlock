Purpose of Locking
  The purpose of locking the CITs are
  1. To assure that no one gets a structure, while it's getting modified.
  2. To assure that two different users get the same n_citnos, while making
     the entry in to CITS. {Query is made on Max n_citno and incremented till
     the whole structure is defined}.
  3. To assure that two different users get the same p_pdcnos, while making
     the entry in to CITS and the dynamic table. {Query is made on
     Max p_pdcnos and incremented till the whole dynamic information is
     defined}.

Suggested equivalent to row level locking without locking the table

  1. While a assembly is getting modified, use NFMINDEXES or some other
     field  to flag that it's getting modified. This is just for that
     assembly [row], and not for all assemblies in the CIT. While querying
     for the structure of an assembly, a check has to be made for this
     assembly alone [Not for any assembly in the CIT, like what we do now]
     and for any sub-assemblies in the path for the update. This table should
     be locked to avoid any concurrency problems. But this locking is
     not costly becuase, this time for query or insert or update in this
     table is far much less than for the both the CITS. This is equivalent
     to row-level locking, except that it's implemented by us, instead
     of the DBMS.

  2. Store the next available n_citnos in NFMINDEXES. This aviods us to
     query max (n_citno) [Costly, especially when the CIT grows in size].
     This table should be locked to aviod concurreny problems in
     querying the next available n_citno, Update of the next available
     n_citnos.

  3. Store the next available p_pdcnos in NFMINDEXES. This aviods us to
     query max (n_citno) [Costly, especially when the CIT grows in size].
     This table should be locked to aviod concurreny problems in
     querying the next available n_citno, Update of the next available
     n_citnos.


Problems in current design {locking the CITs}

1. CIT is locked for a longer time.
2. Locking a bigger table is costlier than locking a smaller table.
3. When one structure is getting modified, we don't allow the
   users to do any operation {checkin, checkout, etc.} even on
   assemblies which are totally independent of that structure.
4. We loop for only two minutes.

