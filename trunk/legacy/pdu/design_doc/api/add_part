
  Author:    Mychelle Greene
  Title:     API Design Document pdmoAddPart
  Date:      8/18/93
  Revision:  6

  Abstract:  
 
  This API adds a part to the database.

  Keywords:

  Add Part

  Function Protocol:

  pdmoAddPart(	cpr_catalog,
		cpr_partnum, 
		cpr_revision, 
		cpr_parttype, 
		cpr_description,
		cpr_acl_name, 
		cpr_stg_name, 
		spr_attrs, 
		spr_files);

  Input:

	char	*cpr_catalog
	char	*cpr_partnum
	char	*cpr_revision
	char	*cpr_parttype
	char	*cpr_description
	char	*cpr_acl_name
	char	*cpr_stg_name
	struct   attribute_info *spr_attrs
	struct   file_info      *spr_files

  Output:

	None

  Sample Invocation:
 
    status = pdmoAddPart(	"api_catalog", 
                                "api_part1",
                                "a",
				"G",
				"part added through API",
                                "PDM_PART_ACL",
                                "NFMFILES,
				attr_list,
                                add_file_list);

  Input Limitations:

	cpr_catalog:	required 
			16 characters or less
			must already exist

	cpr_partnum:	required
			! * ? , : invalid characters
			must not exceed the number of characters specified 
			  at catalog creation time

	cpr_revision:	required
			! * ? , : invalid characters
			must not exceed the number of characters specified 
			  at catalog creation time

	cpr_parttype:	required
			must be "M" "m" "D" "d" "G" "g" "N" or "n"

	cpr_description:	optional
			must not exceed the number of characters specified 
			  at catalog creation time

	cpr_acl_name:	required
			default is PDM_PART_ACL

	cpr_stg_name:	required
			default is NFMFILES

	spr_files:	optional
			necessary for adding a part with file information
			
	spr_attrs:	optional
			necessary for changing the value of system or user-
			  defined attributes

  Structures:

  struct file_info
  {
  char                 cpr_file_desc[IK_FILEDESC_MAX];
  char                 cpr_local_fn[IK_FILENAME_MAX];
  char                 cpr_storage_fn[IK_FILENAME_MAX];
  char                 cpr_file_type[IK_FILETYPE_MAX];
  int                  ir_mode;
  struct file_info  *spm_next;
  };

	cpr_file_desc:	optional
			must not exceed 40 characters

	cpr_local_fn:	optional
			must be unique to for the part being added
			must not exceed 14 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters

	cpr_storage_fn:	optional
			must be unique to for the part being added
			must not exceed 14 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters
			filename must not already exist in check in storage
			  area

	cpr_file_type:	optional
			may not be "M" or "m"
			must not exceed 5 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters

  struct attribute_info
  {
  char                 cpr_attr_name[IK_ATTR_MAX];
  char                 cpr_datatype[IK_DATATYPE_MAX];
  char                 cpr_synonym[IK_SYNONYM_MAX];
  char                 cpr_value[IK_VALUE_MAX];
  struct attribute_info *spm_next;
  };

	cpr_attr_name:	required
			must not exceed 20 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters
			must not be a database reserved word

	cpr_datatype:	required
			must be a valid datatype: real, integer, char(xx),
			  decimal, smallint

	cpr_synonym:	required
			must not exceed 40 characters

	cpr_value:	optional
			must be compatible with the specified datatype

  Return Status:

	PDM_S_SUCCESS
	PDM_E_CAT_FIELD_BLANK
	PDM_E_PART_FIELD_BLANK
	PDM_E_REV_FIELD_BLANK
	PDM_E_CAT_FIELD_TOO_LONG
	PDM_E_PART_FIELD_TOO_LONG
	PDM_E_LOC_FN_TOO_LONG
	PDM_E_FILE_DESC_TOO_LONG
	PDM_E_FILETYPE_TOO_LONG
	PDM_E_STG_FN_TOO_LONG 
	PDM_E_CAT_NOT_FOUND
	PDM_E_INVALID_CHAR_IN_PART
	PDM_E_INVALID_CHAR_IN_REV
	PDM_E_INVALID_CHAR_IN_LOCFN
	PDM_E_INVALID_CHAR_IN_STGFN
	PDM_E_INVALID_CHAR_IN_FILETYPE
	PDM_E_IDENTIFIER_TOO_LONG
	PDM_E_REVISION_EXISTS
	PDM_E_CI_FILENAME_EXISTS
	PDM_E_STG_FN_NOT_UNIQUE
	PDM_E_ACLNAME_NOT_FOUND
	PDM_E_STGNAME_NOT_FOUND
	PDM_E_INVALID_PART_TYPE
	PDM_I_TABLE_LOCKED 
	NFM_E_ITEM_ACL_NOT_IN_PROJ_MAP
	NFM_E_NO_SO_FOUND_FOR_ITEM
	NFM_E_NO_SO_USERS_FOUND_IN_ACL
	NFM_W_INVALID_VERSION_LIMIT
	NFM_E_INV_ACL_FOR_OWNED_MEMBER
	NFM_E_INV_ACL_FOR_MAPPED_CAT

	PDM_E_USER_NOT_LOGGED_IN

  External Functions:

  PDMvalidate_user_access()
  PDUcheck_catalog_syntax()
  PDMrverify_catalog()
  PDUcheck_part_syntax()
  PDUcheck_part_datatype()
  PDUcheck_rev_syntax()
  PDUcheck_rev_datatype()
  PDMcheck_partnum()
  PDUcheck_desc_datatype()
  PDUvalidate_parttype()
  PDUverify_aclname()
  PDUverify_storage_name()
  PDUverify_file_desc()
  PDUverify_addpart_filename()
  PDUcheck_dup_sa_fname()
  PDUverify_filetype()
  PDUfind_attr_in_bufr()
  PDUvalid_attr()
  PDUcheck_for_reserved_words()
  PDUformat_buffer()
  PDMadd_part()
  
  Assumptions:

  If the user is adding files with the new part, pdmoLoadFileStructure must
  be called before pdmoAddPart.

  If the user is assigning attribute values, pdmoLoadAttrStructure must be
  called before pdmoAddPart.

  The user must call the appropriate APIs to free the file and attribute 
  structures.

  The PDMexec userid has been loaded during login.

  Impacts:
 
  None

  Future:
 
  None

  Test Cases:

    Success

  Add a graphic part with one file.
  Add a graphic part with multiple files.
  Add a graphic part without files.
  Add a nongraphic part.
  Add a macro part.
  Add a part with a storage area filename.
  Add a part with values for attributes and user-defined attributes.

    Failure

  Add a part with an invalid part type.
  Add a part that already exists.
  Add a part with an invalid local/storage filename.
  Add a part with a duplicate local/storage filename.
  Add a part to an invalid ACL.
  Add a part with an invalid storage area name.

  Algorithm:

- verify login - call PDUcheck_if_logged_in
	- if status != SUCCESS, return status

- verify that all required input has been entered
	- catalog - call PDUvalidate_catalog
		- set bufr_flag = TRUE
		- set PDU_main_form_cat = FALSE
		- call PDMrverify_catalog
		- if status != SUCCESS, return status
		- split the return buffer into the attr_bufr and data_bufr

	- partnum - call PDUcheck_part_syntax
		- if status != SUCCESS, return status
		- get the part datatype from the attr_bufr
		- call PDUcheck_part_datatype
		- if status != SUCCESS, return status

	- revision - call PDUcheck_rev_syntax
		- if status != SUCCESS, return status
		- get the revision datatype from the attr_bufr
		- call PDUcheck_rev_datatype
		- if status != SUCCESS, return status

	- check to see if the part already exists - call PDMcheck_partnum
		- if status = SUCCESS
			- status = PDM_E_PART_EXISTS
			- return status
		- else if status == PDM_E_PARTREV_NOT_FOUND
			- status = PDM_S_SUCCESS
			- return status
		- else return status

- call PDMvalidate_user_access
	- if status != SUCCESS, return status

	- description - call PDUcheck_desc_datatype
		- if status != SUCCESS, return status

	- parttype - call PDUvalidate_parttype
		- if status != SUCCESS, return status
		- if parttype = N, verify that file list is NULL
			- if file list is not NULL, PDM_E_NONGRAPH_FILES

	- acl_name - call PDUverify_aclname
		- if status != SUCCESS, return status
	- verify that a valid acl_no was returned
	- write the acl_no to the data_bufr

	- stg_name - call PDUverify_storage_name
		- if status != SUCCESS, return status
	- verify that a valid storage_no was returned
	- write the storage_no to the data_bufr

- write part information to the data_bufr
	- partnum
	- revision
	- parttype
	- description

- if file_list, for each entry verify data in file_list
	- if !local_fn && !storage_fn
		- return PDM_E_NO_DATA_IN_FILE_LIST
	- filedesc - if filedesc, call PDUverify_file_desc
		- if status != SUCCESS, return status
	- if local_fn - call PDUverify_addpart_filename
		- if status != SUCCESS, return status
	- if storage_fn - call PDUverify_addpart_filename
		- if status != SUCCESS, return status
		- call PDMcheck_dup_sa_fname
		- if status != SUCCESS, return status
	- if filetype - call PDUverify_filetype
		- if status != SUCCESS, return status
	- if mode != ADD
		- return PDM_E_INVALID_MODE

- for each attribute in the list
	- if both attr_name and attr_synonym are empty, return error message

	- else if attr_name is not empty
		- call PDUfind_attr_in_buffer
		- if return status = -1, return PDM_I_ATTR_NOT_FOUND
		- call PDUvalid_attr
		- if return status != SUCCESS, return PDM_E_INVALID_ATTR
		- call PDUcheck_for_reserved_words
		- if return status != SUCCESS, return PDM_E_RESERVED_DATA

	- else if attr_synonym is not empty
		- call PDUfind_attr_in_buffer
		- if return status = -1, return PDM_I_ATTR_NOT_FOUND

	- else return error message

	- test for write permission
	- if n_write = N, return PDM_E_NOT_WRITABLE
	- write the attribute to the data_bufr


- if file_list
	- call PDUformat_buffer
	- write a blank first row to the buffer
	- call PDUget_buffer_col for n_cofilename
	- call PDUget_buffer_col for n_cifilename
	- call PDUget_buffer_col for n_filetype
	- call PDUget_buffer_col for p_filedesc
	- call PDUget_buffer_col for n_cisaname
	- for each set of file information
		- write the file information to the file_bufr
		- write the storage area name to the file_bufr

- call PDMadd_part function
- set part state with return status
- close all buffers
- return
