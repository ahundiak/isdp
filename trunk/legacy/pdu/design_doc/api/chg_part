
  Author:    Mychelle Greene
  Title:     API Design Document pdmoChangePart
  Date:      10/22/93
  Revision:  10

  Abstract:  

  This API changes the definition of an existing part in the database.

  Keywords:

  Change Part

  Function Protocol:

  pdmoChangePart(	cpr_catalog,
			cpr_partnum, 
			cpr_revision, 
			cpr_parttype, 
			cpr_description,
			cpr_acl_name, 
			cpr_stg_name, 
			spr_attrs, 
			spr_add_files,
			spr_chg_files)

  Input:

	char	*cpr_catalog
	char	*cpr_partnum
	char	*cpr_revision
	char	*cpr_parttype
	char	*cpr_description
	char	*cpr_acl_name
	char	*cpr_stg_name
	struct   attribute_info *spr_attrs
	struct   file_info      *spr_add_files
	struct   chg_file_info  *spr_chg_files

  Output:

	None

  Sample Invocation:
 
    status = pdmoChangePart(    "api_catalog",
                                "api_part1",
                                "a",
                                "G",
                                "part added through API",
                                "NFMFILES,
                                attr_list,
                                add_file_list,
				chg_file_list);

  Input Limitations:

	cpr_catalog:	required 
			16 characters or less
			must already exist

	cpr_partnum:	required
			! * ? , : invalid characters
			must not exceed the number of characters specified 
			  at catalog creation time

	cpr_revision:	required
			! * ? , : invalid characters
			must not exceed the number of characters specified 
			  at catalog creation time

	cpr_parttype:	optional
			will remain unchanged if NULL

	cpr_description:	optional
			must not exceed the number of characters specified 
			  at catalog creation time

			Note:  If cpr_description = NULL or "" (NULL_STRING)
			       the current value will remain unchanged.

			       If cpr_description = " ", the current value be 
				cleared out.

	cpr_acl_name:	optional
			will remain unchanged if NULL

	cpr_stg_name:	optional
			will remain unchanged if NULL

	spr_add_files:	optional
			necessary for adding file information
			
	spr_chg_files:	optional
			necessary for changing file information
			
	spr_attrs:		required
			must contain a list of default attributes and values
			  that are present in all catalog
			may contain an appended list of user-defined 
			  attributes and values

  Structures:

  struct file_info
  {
  char                 cpr_file_desc[IK_FILEDESC_MAX];
  char                 cpr_local_fn[IK_FILENAME_MAX];
  char                 cpr_storage_fn[IK_FILENAME_MAX];
  char                 cpr_file_type[IK_FILETYPE_MAX];
  int                  ir_mode;
  struct file_info  *spm_next;
  };
 
  struct chg_file_info
  {
  char                 cpr_file_desc[IK_FILEDESC_MAX];
  char                 cpr_chg_file_desc[IK_FILEDESC_MAX];
  char                 cpr_local_fn[IK_FILENAME_MAX];
  char                 cpr_chg_local_fn[IK_FILENAME_MAX];
  char                 cpr_storage_fn[IK_FILENAME_MAX];
  char                 cpr_chg_storage_fn[IK_FILENAME_MAX];
  char                 cpr_file_type[IK_FILETYPE_MAX];
  char                 cpr_chg_file_type[IK_FILETYPE_MAX];
  int                  ir_mode;
  struct chg_file_info  *spm_next;
  };

	cpr_file_desc:	optional
			must not exceed 40 characters

	cpr_local_fn:	optional
			must be unique to for the part being added
			must not exceed 14 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters

	cpr_storage_fn:	optional
			must be unique to for the part being added
			must not exceed 14 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters
			filename must not already exist in check in storage
			  area

	cpr_file_type:	optional
			may not be "M" or "m"
			must not exceed 5 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters

	ir_mode:	reguired
			specifies whether user is adding, changing or
			  deleting file information
			ADD = 1, CHANGE = 2, DELETE = 3

  struct attribute_info
  {
  char                 cpr_attr_name[IK_ATTR_MAX];
  char                 cpr_datatype[IK_DATATYPE_MAX];
  char                 cpr_synonym[IK_SYNONYM_MAX];
  char                 cpr_value[IK_VALUE_MAX];
  struct attribute_info *spm_next;
  };

	cpr_attr_name:	required
			must not exceed 20 characters
			/ # = ! * \\ ( ) { } [ ] < > & ? $ @ + - : | invalid
			  characters
			must not be a database reserved word

	cpr_datatype:	required
			must be a valid datatype: real, integer, char(xx),
			  decimal, smallint

	cpr_synonym:	required
			must not exceed 40 characters

	cpr_value:	optional
			must be compatible with the specified datatype

  Return Status:

	PDM_S_SUCCESS
	PDM_E_CAT_FIELD_BLANK
	PDM_E_PART_FIELD_BLANK
	PDM_E_REV_FIELD_BLANK
	PDM_E_LOC_FN_TOO_LONG
	PDM_E_FILE_DESC_TOO_LONG
	PDM_E_FILETYPE_TOO_LONG
	PDM_E_STG_FN_TOO_LONG 
	PDM_E_CAT_NOT_FOUND
	PDM_E_INVALID_CHAR_IN_LOCFN
	PDM_E_INVALID_CHAR_IN_STGFN
	PDM_E_INVALID_CHAR_IN_FILETYPE
	PDM_E_IDENTIFIER_TOO_LONG
	PDM_E_CI_FILENAME_EXISTS
	PDM_E_STG_FN_NOT_UNIQUE
	PDM_E_ACLNAME_NOT_FOUND
	PDM_E_STGNAME_NOT_FOUND
	PDM_E_INVALID_PART_TYPE
	PDM_I_TABLE_LOCKED 
	NFM_E_ITEM_ACL_NOT_IN_PROJ_MAP
	NFM_E_NO_SO_FOUND_FOR_ITEM
	NFM_E_NO_SO_USERS_FOUND_IN_ACL
	NFM_W_INVALID_VERSION_LIMIT
	NFM_E_INV_ACL_FOR_OWNED_MEMBER
	NFM_E_INV_ACL_FOR_MAPPED_CAT

	PDM_E_NOT_USER_LOGGED_IN


  External Functions:
 
  PDUcheck_if_logged_in()
  PDMvalidate_user_access()
  PDUvalidate_catalog()
  PDMcheck_partnum()
  PDMget_existing_data()
  PDUcheck_desc_datatype()
  PDUvalidate_parttype()
  PDUverify_storage_name()
  PDUverify_file_desc()
  PDUverify_addpart_filename()
  PDUcheck_dup_sa_fname()
  PDUverify_filetype()
  PDUfind_attr_in_bufr()
  PDUvalid_attr()
  PDUcheck_for_reserved_words()
  PDUformat_buffer()
  PDUdelete_files_from_buffer()
  PDUadd_files_to_buffer()
  PDUchange_files_in_buffer()
  PDMmodify_part()
  PDMcancel_modify_part()
 
  Assumptions:
 
  If the user is adding file information, pdmoLoadFileStructure must be 
  called before calling pdmoChangePart.
 
  If the user is changing file information, pdmoLoadChangeStructure must be
  called before calling pdmoChangePart.
 
  If the user is changing attribute values, pdmoLoadAttrStructure must be
  called before pdmoChangePart.
 
  The user must call the appropriate APIs to free the file and attribute 
  structures.

  The PDMexec userid has been loaded during login.
 
  Impacts:

  None
 
  Future:

  Additional APIs will be written to add and change files without calling
  pdmoChangePart.  This will eliminate the time that is used to retrieve
  attribute information.

  Test Cases:

    Success
 
  Change the local filename of a part.
  Change the storage area filename of a part.
  Change the part type of a part.
  Change the description of a part.
  Change the values for attributes and user-defined attributes.
  Add files to a part.
  Delete files from a part.
 
    Failure
 
  Change the part type to an invalid part type.
  Change the local filename to an invalid filename.
  Change the storage filename to an invalid filename.
  Change the local filename to a duplicate local filename.
  Change the storage area filename to a duplicate storage area filename.
  Change the description to an invalid description.
 
  Algorithm:

- verify login - call pdmcheck_log_in
        - if status != SUCCESS, return status
 
- verify that all required input has been entered
	- catalog - call PDUvalidate_catalog
                - if status != SUCCESS, return status

	- partnum - check for NULL and NULLSTRING

	- revision - check for NULL and NULLSTRING

	- make sure the part already exists - call PDMcheck_partnum
                - if status != SUCCESS
                        - return status

- call PDMvalidate_user_access
        - if status != SUCCESS, return status

	- call function to get existing part data - PDMget_existing_data
                - if status != SUCCESS
                        - return status
	- split return buffer into attr_bufr and data_bufr

	- description - call PDUcheck_desc_datatype
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
 
	- if parttype != NULL
        	- parttype - call PDUvalidate_parttype
                	- if status != SUCCESS, 
				- call PDMcancel_modify_part
				- return status
                	- if parttype = N, verify that chg_file list is NULL
                        	- if chg_file list is not NULL, 
					- call PDMcancel_modify_part
					- return PDM_E_NONGRAPH_FILES

	- if acl_name != NULL
        	- acl_name - call PDUverify_aclname
                	- if status != SUCCESS, 
				- call PDMcancel_modify_part
				- return status
        	- verify that a valid acl_no was returned
        	- write the acl_no to the data_bufr
 
	- if stg_name != NULL
        	- stg_name - call PDUverify_storage_name
                	- if status != SUCCESS, 
				- call PDMcancel_modify_part
				- return status
        	- verify that a valid storage_no was returned
        	- write the storage_no to the data_bufr
 
- write part information to the data_bufr
        - parttype
        - description

- for each attribute in the list
	- if both attr_name and attr_synonym are empty, return error message
 
        - else if attr_name is not empty
                - call PDUfind_attr_in_buffer
                - if return status = -1, 
			- call PDMcancel_modify_part
			- return PDM_I_ATTR_NOT_FOUND
		- call PDUvalidate_data_value
		- if status != PDM_S_SUCCESS
			- return status
                - test for write permission
 
        - else if attr_synonym is not empty
                - call PDUfind_attr_in_buffer
                - if return status = -1, 
			- call PDMcancel_modify_part
			- return PDM_I_ATTR_NOT_FOUND
		- call PDUvalidate_data_value
		- if status != PDM_S_SUCCESS
			- return status
                - test for write permission
 
        - else return error message

        - if n_write = N, 
		- call PDMcancel_modify_part
		- return PDM_E_NOT_WRITABLE
        - if n_update = N, 
		- call PDMcancel_modify_part
		- return PDM_E_NOT_UPDATABLE
        - write the attribute to the data_bufr

- if delete_file_list
	- check the status of part (in/out)
	- if part is not checked in
		- call PDMcancel_modify_part
		- return PDM_E_CANNOT_DELETE_FILES

- if add_file_list
	- check the status of part (in/out)
	- if part is not checked out
		- call PDMcancel_modify_part
		- return PDM_E_CANNOT_ADD_FILES

- if chg_file_list
	- check the status of part (in/out)
	- if part is not checked in
		- call PDMcancel_modify_part
		- return PDM_E_CANNOT_CHANGE_FILES

- if delete_file_list, for each entry verify data in file_list
        - if !filedesc && !local_fn && !storage_fn && !filetype
		- call PDMcancel_modify_part
                - return PDM_E_NO_DATA_IN_FILE_LIST
	- for each node in the list
		- if mode != 3
			- call PDMcancel_modify_part
			- return PDM_E_INVALID_MODE
	- call PDUdelete_files_from_buffer
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status

- if add_file_list, for each entry verify data in file_list
        - if !filedesc && !local_fn && !storage_fn && !filetype
		- call PDMcancel_modify_part
                - return PDM_E_NO_DATA_IN_FILE_LIST
        - if file_desc call PDUverify_file_desc
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
        - if local_fn call PDUverify_addpart_filename
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
        - if storage_fn call PDUverify_addpart_filename
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
                - call PDMcheck_dup_sa_fname
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
        - if filetype call PDUverify_filetype
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
	- for each node in the list
		- if mode != 1
			- call PDMcancel_modify_part
			- return PDM_E_INVALID_MODE
	- call PDUadd_files_to_buffer
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status

- if chg_file_list, for each entry verify data in file_list
        - if !chg_filedesc && !chg_local_fn && !chg_storage_fn && !chg_filetype
		- call PDMcancel_modify_part
                - return PDM_E_NO_DATA_IN_FILE_LIST
        - if chg_file_desc call PDUverify_file_desc
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
        - if chg_local_fn call PDUverify_addpart_filename
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
        - if chg_storage_fn call PDUverify_addpart_filename
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
                - call PDMcheck_dup_sa_fname
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
        - if chg_filetype call PDUverify_filetype
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status
	- for each node in the list
		- if mode != 2
			- call PDMcancel_modify_part
			- return PDM_E_INVALID_MODE
	- call PDUchange_files_in_buffer
                - if status != SUCCESS, 
			- call PDMcancel_modify_part
			- return status

- call PDMmodify_part function
- set part state
- if status != PDM_S_SUCCESS
	- call PDMcancel_modify_part
- return
