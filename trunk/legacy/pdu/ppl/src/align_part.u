/*
 * Author: Jamal Shakra
 * Date: 12-14-91
 * This command graphically aligns a part to a given coordinate system.
 */


#include 	"ciminimum.h"
#if ! defined(__sgi)
#include 	"unistd.h"
#endif
#include 	"cimacros.h"
#include 	"PDUstr.h"
#include        "ex.h"
#include        "igrdp.h"
#include 	"partmacros.h"
#include	"cieveryone.h"
#include	"cimacros.h"
#include	"acdef.h"
#include	"acmacros.h"
#include	"ACdb_info.h"
#include	"macro.h"
#include	"grdpbdef.h"
#include	"grdpb.h"
#include	"grdpbmacros.h"
#include	"growner.h"
#include	"igrdp.h"
#include	"madef.h"
#include	"exdef.h"
#include	"exmacros.h"
#include	"dp.h"
#include	"dpdef.h"
#include	"grcoordsys.h"
#include	"csdef.h"
#include        "DItypedef.h"
#include        "DIdef.h"
#include        "DIglob.h"
#include        "DIprims.h"
#include	"msdef.h"
#include	"PDUint.h"
#include	"PDUintdef.h"
#include	"string.h"
#include	"grsymdef.h"
#include	"grsym.h"
#include	"grownerdef.h"
#include 	"dpmacros.h"
#include 	"comiscmac.h"
#include 	"coplcmac.h"
#include 	"cotxmacros.h"
#include 	"partdef.h"
#include        "csmacros.h"
#include        "PDUinform.h"


/* External function definition */
extern          _pdm_status();
extern          _pdm_debug();
extern		GRdpb_get();
extern		COpart_attr_func();
extern          PDUfill_in_string();
extern          PDUdisplay_GRpart();
extern          PDUalign_GRpart();
extern          PDUdisplay_design_form();
extern          DImain();
extern          GRcsget_mgr();
extern          DPdisbyoid();
extern          malloc();
extern          free();

/* External variable definition */
extern          IGRint     PDU_message_type;
extern          IGRint     PDU_command;
extern          IGRint     PDU_prompt_type;
extern          IGRdouble  PDU_point[3];
extern          IGRshort   PDU_store_point;
extern          IGRchar    PDU_align_part_by;
extern          IGRshort   PDU_loop_cmd;
extern   struct GRid       *PDU_part_id;

main()
{

 struct GRmd_env  mod_env;
 struct GRid      part_id;		
 IGRchar          value[MAX_VALUE];
 IGRint           type;
 IGRlong          msg, sts;
 IGRlong          status;
 IGRdouble        origin[3];
 IGRdouble        point1[3];
 IGRdouble        point2[3];
 struct GRevent   my_event;
 struct GRid      src_coorid;
 struct GRid      dst_coorid;
 struct GRid      act_coorid;
 IGRmatrix        src_matrix;
 IGRmatrix        dst_matrix;
 IGRchar          coord_dir[DI_PATH_MAX];
 IGRshort         cstype;
 GRobjid          csmgr_id;   
 IGRlong	  NumberOfBytes, BytesReceived;

 
 align_again:

 /* Get active module information */
 NumberOfBytes = sizeof(mod_env);
 status = gr$get_module_env( 
                           msg = &msg,
			   sizbuf = &NumberOfBytes,
			   buffer = &mod_env,
			   nret = &BytesReceived
                          );

 /* Locate GRpart */
 identify_GRpart:

 message("Align Part");

 begincmd("locate part pointer");
 endcmd();

 if (PDU_part_id == NULL)
    {
     exit;
    }

 /* Validate part pointer identity */
 part_id.osnum = PDU_part_id->osnum;
 part_id.objid = PDU_part_id->objid;

 status = co$part_get_attr (
                             msg = &msg,
                             mod_env = &mod_env,
                             part = &part_id,
                             attr = "attach_flag",
                             value = value,
                             type = &type 
                           ); 

 if ( (msg != MSSUCC) || (strcmp(value, "") == 0) )
    {
     message("Invalid part pointer");
     delay();
     
     /* Deallocate and initialize PDU_part_id */
     free(PDU_part_id);
     PDU_part_id = NULL;

     goto identify_GRpart;
    }

 else 
  if (strcmp(value, "-1.000000") == 0)
     {
      message("Part can not be aligned if not attached");
      delay();
      delay();

     /* Deallocate and initialize PDU_part_id */
     if (PDU_part_id)
        {
         free(PDU_part_id);
         PDU_part_id = NULL;
        }

      goto identify_GRpart;
     }

  else
    {
     /* Extract serial number from GRpart */
     co$part_get_attr (
                       msg = &msg,
                       mod_env = &mod_env,
                       part = &part_id,
                       attr = "serial",
                       value = value,
                       type = &type
                      );

    /* The serial number is nothing else but the obj id of the coord. sys */
    sscanf(value, "%d", &src_coorid.objid);
    src_coorid.osnum = mod_env.md_id.osnum;

    /* Get part pointer transition matrix */
     status = ci$send(
                      msg = message GRgencs.GRgetmatrix(
                                                         &sts,
                                                         src_matrix
                                                       ),
                      targetid = src_coorid.objid,
                      targetos = src_coorid.osnum 
                     );

    /* If align by coord sys */
    if (PDU_align_part_by == 'C')
       {
        while (!ci$locate
                         (
                          obj = &dst_coorid.objid,
                          prompt = "Identify coordinate system",
                          acc_prompt = "Enter data point to accept"
                         )
              )
        message("Invalid coordinate system");

        /* Make sure part is not aligned to it's original
           part pointer */
        if (dst_coorid.objid == src_coorid.objid)
           {
            message("Part is already aligned");
            PDUdisplay_GRpart(
                              part_id,
                              1
                             );
            delay();
            PDUdisplay_design_form();
            exit;
           }

        /* Extract trans matrix of located coor system */
        dst_coorid.osnum = mod_env.md_id.osnum;
        status = ci$send(
                         msg = message GRgencs.GRgetmatrix
                                              (
                                               &sts,
                                               dst_matrix
                                              ),
                         targetid = dst_coorid.objid,
                         targetos = dst_coorid.osnum
                        );
        if (1&status)
           {
           /* Align part to located coor system */
           status = PDUalign_GRpart(
                                    src_matrix,
                                    dst_matrix,
                                    part_id,
                                    mod_env
                                   );

           if (status == PDM_S_SUCCESS)
              {
               /* Update display of part */
               dp$display(
                          msg = &sts,
                          oids = &part_id,
                          mode = GRbd
                         );

                goto align_again;
              }

           else
              {
               message("SEVERE error: Part alignment failed");
               delay();

               /* Deallocate and initialize PDU_part_id */
               if (PDU_part_id)
                  {
                   free(PDU_part_id);
                   PDU_part_id = NULL;
                  }

               PDUdisplay_design_form();
               exit;
              }
           }

        else
          {
           _pdm_debug("GRgencs.GRgetmatrix failed(1)", 0);

           /* Deallocate and initialize PDU_part_id */
           if (PDU_part_id)
              {
               free(PDU_part_id);
               PDU_part_id = NULL;
              }

           PDUdisplay_design_form();
           exit;
          }

       } /* end align by coord sys */

    else
     /* Align by 3-points */
     if (PDU_align_part_by == 'P')
        {
        /* Need to save the active coordinate system */
        status =  cs$get_mgr (
                              msg = &msg,
                              osnum = mod_env.md_id.osnum,
                              module = mod_env.md_id.objid,
                              csmgr = &csmgr_id
                             );


        /* Get the obj id of the most recently defined coor sys */
        status = ci$send(
                         msg = message GRcsmgr.GRget_acs_info
                                              (
                                               &msg,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &cstype,
                                               &act_coorid
                                              ),
                         targetid = csmgr_id,
                         targetos = mod_env.md_id.osnum
                        );

        PDU_message_type = PDM_I_ALIGN_PART_MSG;

        PDU_prompt_type = PDM_I_POINT_ONE;
        begincmd("enter data point");
        endcmd();

        if (!PDU_store_point)
           {
            /* No data point entered */

            /* Deallocate and initialize PDU_part_id */
            if (PDU_part_id)
               {
                free(PDU_part_id);
                PDU_part_id = NULL;
               }

            exit;
           }

        origin[0] = PDU_point[0];
        origin[1] = PDU_point[1];
        origin[2] = PDU_point[2];

        PDU_store_point = FALSE;

        PDU_prompt_type = PDM_I_POINT_TWO;
        begincmd("enter data point");
        endcmd();

        if (!PDU_store_point)
           {
            /* No data point entered */

            /* Deallocate and initialize PDU_part_id */
            if (PDU_part_id)
               {
                free(PDU_part_id);
                PDU_part_id = NULL;
               }

            exit;
           }

        PDU_store_point = FALSE;

        point1[0] = PDU_point[0];
        point1[1] = PDU_point[1];
        point1[2] = PDU_point[2];

        PDU_prompt_type = PDM_I_POINT_THREE;
        begincmd("enter data point");
        endcmd();

        if (!PDU_store_point)
           {
            /* No data point entered */

            /* Deallocate and initialize PDU_part_id */
            if (PDU_part_id)
               {
                free(PDU_part_id);
                PDU_part_id = NULL;
               }

            exit;
           }

        PDU_store_point = FALSE;

        point2[0] = PDU_point[0];
        point2[1] = PDU_point[1];
        point2[2] = PDU_point[2];

        begincmd ("define coordinate system from 3 points");
                   ci$put(response = TERMINATE, pos = FRONT);
                   ci$put(string = "", pos = FRONT);
                   ci$put(point = point2, pos = FRONT);
                   ci$put(point = point1, pos = FRONT);
                   ci$put(point = origin, pos = FRONT);
        endcmd();

        /* Get the obj id of the most recently defined coor sys */
        status = ci$send(
                          msg = message GRcsmgr.GRget_acs_info
                                               (
                                                &msg,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &cstype,
                                                &dst_coorid
                                               ),
                          targetid = csmgr_id,
                          targetos = mod_env.md_id.osnum
                        );

        /* Make sure part is not aligned to it's original part
           pointer */
        if (dst_coorid.objid == src_coorid.objid)
           {
            message("Part is already aligned");
            delay();

            /* Restore active coordinate system */
            status = ci$send(
                      msg = message GRcsmgr.GRset_active_cs
                                           (
                                            &msg,
                                            &mod_env,
                                            act_coorid.objid
                                           ),
                      targetid = csmgr_id,
                      targetos = mod_env.md_id.osnum
                     );

            /* Deallocate and initialize PDU_part_id */
            if (PDU_part_id)
               {
                free(PDU_part_id);
                PDU_part_id = NULL;
               }

            PDUdisplay_design_form();
            exit;
           }

        /* Get the transition matrix of the active coor system */
           status = ci$send(
                            msg = message GRgencs.GRgetmatrix(
                                                              &sts,
                                                              dst_matrix
                                                             ),
                            targetid = dst_coorid.objid,
                            targetos = dst_coorid.osnum
                           );

        /* Align part to most recently created coor system */
        status = PDUalign_GRpart(
                                 src_matrix,
                                 dst_matrix,
                                 part_id,
                                 mod_env
                                );

        if (status != PDM_S_SUCCESS)
           {
            message("SEVERE error: Part alignment failed");
            delay();
            
            /* Restore active coordinate system */
            status = ci$send(
                      msg = message GRcsmgr.GRset_active_cs
                                           (
                                            &msg,
                                            &mod_env,
                                            act_coorid.objid
                                           ),
                      targetid = csmgr_id,
                      targetos = mod_env.md_id.osnum
                     );

            /* Deallocate and initialize PDU_part_id */
            if (PDU_part_id)
               {
                free(PDU_part_id);
                PDU_part_id = NULL;
               }

            PDUdisplay_design_form();
            exit;
           }

        else
          {
           /* Erase 3-point coord. sys. */
           dp$display(
                      msg = &sts,
                      oids = &dst_coorid,
                      mode = GRbe
                     );

           /* Erase 3-point coord. sys. again */
           dp$display(
                      msg = &sts,
                      oids = &dst_coorid,
                      mode = GRbe
                     );

           /* Update display of part */
           dp$display(
                      msg = &sts,
                      oids = &part_id,
                      mode = GRbd
                     );

           /* Delete 3-point coord. sys. */
           ci$send(
                   msg = message GRgraphics.GRdelete
                                              (
                                               &sts,
                                               &mod_env
                                              ),
                   targetid = dst_coorid.objid,
                   targetos = dst_coorid.osnum
                  );

           /* Restore active coordinate system */
           status = ci$send(
                             msg = message GRcsmgr.GRset_active_cs
                                                  (
                                                   &msg,
                                                   &mod_env,
                                                   act_coorid.objid
                                                  ),
                             targetid = csmgr_id,
                             targetos = mod_env.md_id.osnum
                           );
          }

       } /* end align by 3-points */
     
     /* Loop command, if necessary */
     if (PDU_loop_cmd == TRUE)
        {
         /* Deallocate and initialize PDU_part_id */
         if (PDU_part_id)
            {
             free(PDU_part_id);
             PDU_part_id = NULL;
            }

         goto align_again;
        }
    }
}

int  delay()
 {
  int  i;

  for (i = 0; i < 20000; i = i + 1);
 }
