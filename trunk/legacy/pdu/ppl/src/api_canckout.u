#if ! defined(__sgi)
#include        "unistd.h"
#endif
#include 	"ciminimum.h"
#include 	"PDUstr.h"
#include        "PDUpart.h"
#include        "igrdp.h"
#include 	"partmacros.h"
#include 	"part.h"
#include	"cieveryone.h"
#include	"acdef.h"
#include	"acmacros.h"
#include	"ACdb_info.h"
#include	"macro.h"
#include	"grdpbdef.h"
#include	"grdpb.h"
#include	"grdpbmacros.h"
#include	"growner.h"
#include	"igrdp.h"
#include	"madef.h"
#include	"expriv.h"
#include	"exmacros.h"
#include	"dp.h"
#include	"dpdef.h"
#include	"grcoordsys.h"
#include	"csdef.h"
#include	"msdef.h"
#include	"PDUint.h"
#include	"PDUintdef.h"
#include	"grsymdef.h"
#include	"grsym.h"
#include	"grownerdef.h"
#include 	"dpmacros.h"
#include 	"comiscmac.h"
#include 	"coplcmac.h"
#include 	"cotxmacros.h"
#include 	"partdef.h"
#include        "DItypedef.h"
#include        "DIdef.h"
#include        "DIglob.h"
#include        "DIprims.h"
#include        "expmacros.h"
#include        "csmacros.h"
#include        "MEMstruct.h"
#include        "MEMerrordef.h"
#include        "PDUfile_def.h"
#include        "PDUinform.h"
#include        "PDUassy.h"
#include        "PDUforms.h"



/* External functions declaration section */
extern          _pdm_status();
extern          _pdm_debug();
extern          GRdpb_get();
extern          MEMbuild_array();
extern          PDUsetup_buffer();
extern          PDUget_buffer_col();
extern          PDUfill_in_string();
extern          PDUverify_file();
extern          EX_retrieve_os();
extern          EX_get_invis_info_by_index();
extern          PDUload_delete_buffer();
extern          Close_OS();
extern          free();
extern          MEMclose();
extern          PDMfile_to_tmp_bufr();
extern          PDMbuffer_to_file();

/* External variables declaration section */

/* Global variable declaration */
#define         CANCOFILE_BUFR      2013
#define         CANCOASSY_BUFR      2014

main()
{

 struct           GRmd_env  mod_env;		
 long             NumberOfBytes, BytesReceived;
 long             stat,msg;
 int              status;
 int              row;
 int              file_col;
 int              file_type;
 int              index;
 int              count;
 short            major;
 short            minor;
 short            file_found;
 char             mach_type;
 char             mount_name[40];
 char             caw_formatfile[14];
 char             caw_datafile[14];
 char             stamp_path[DI_PATH_MAX];
 char             *file;
 char             **data_row;
 MEMptr           file_bufr;
 MEMptr           attach_bufr;
 OMuword          osnum;
 GRobjid          objid;
 GRobjid          osid;

 _pdm_debug("In api_canckout.u", 0);

 data_row = NULL;
 file = NULL;
 attach_bufr = NULL;
 index = 0;
 count = 0;
 osid = NULL_OBJID;
 file_found = FALSE;

 /* Get current module environment information */
 NumberOfBytes = sizeof(mod_env);
 stat = gr$get_module_env(
                          msg = &msg,
                          sizbuf = &NumberOfBytes,
                          buffer = &mod_env,
                          nret = &BytesReceived
                         );

  caw_formatfile[0] = '\0';
  caw_datafile[0] = '\0';

  sprintf(caw_formatfile, "/usr/tmp/%d.for", CANCOFILE_BUFR);
  sprintf(caw_datafile, "/usr/tmp/%d.dat", CANCOFILE_BUFR);

  status = PDMfile_to_tmp_bufr (&file_bufr, caw_formatfile, caw_datafile);
  _pdm_status("PDMfile_to_tmp_bufr", status);
  if (status != PDM_S_SUCCESS) 
    exit;

 if (file_bufr == NULL)
    {
    _pdm_debug("No files found", 0);
    exit;
    }
 else if (file_bufr->rows == 0)
    {
    _pdm_debug("No files found", 0);
    exit;
    }

 status = MEMbuild_array(file_bufr);
 _pdm_status("MEMbuild_array", status);

 if (status != MEM_S_SUCCESS)
    {
     _pdm_debug("MEMbuild_array failed", 0);
     exit;
    }

 PDUsetup_buffer(file_bufr, ROW, &data_row);
 PDUget_buffer_col(file_bufr, "n_cofilename", &file_col);

 for (row = 0; row < file_bufr->rows; row = row + 1)
     {
     PDUfill_in_string(
                       &file,
                       data_row[(file_bufr->columns * row) + file_col]
                      );

     _pdm_debug("filename = <%s>", file);

     /* verify filename for part */
     status = PDUverify_file(file);
     _pdm_status("PDUverify_file", status);

     if (status == PDM_E_FILE_NOT_FOUND)
       {
       status = PDM_E_FILE_NOT_LOCAL;
       _pdm_debug("SEVERE error: checkout file <%s> does not exist locally",
                  file);
       exit;
       }

     else
         {
          /* Check to see if file is an OM file */
          status = ex$is_om_file(
                                 filename = file,
                                 p_major = &major,
                                 p_minor = &minor,
                                 p_mach_type = &mach_type,
                                 p_file_type = &file_type
                                );
          _pdm_status("ex$is_om_file", status);

          if (status)
             {
              _pdm_debug("file <%s> is an OM file", file);

              /* Construct file mount name */
              strcpy(mount_name, ":");
              strcat(mount_name, file);

              /* Get osnum of invis space */
              status = ex$retrieve_module (
                                           filename = file,
                                           file_no = &index,
                                           ftype = EX_invisible,
                                           flag = EX_overwrite,
                                           fstat = EX_default,
                                           type = EX_ACTINV,
                                           mount_name = mount_name,
                                           msg = &msg
                                          );
              _pdm_status ("ex$retrieve_module", status);

              if (!status)
                 {
                  _pdm_debug("ex$retrieve_module failed on <%s>",
                             file);
                  exit;
                 }

              /* Open object space */
              status = ex$get_invis_info_by_index (
                                                   index = index,
                                                   mod_osnum = &osnum,
                                                   mod_id = &objid,
                                                   filed_id = &osid
                                                  );
              _pdm_status ("ex$get_invis_info_by_index", status);

              if (!status)
                 {
                  _pdm_debug("ex$get_invis_info_by_index failed on <%s>",
                             file);
                  exit;
                 }

              mod_env.md_id.osnum = osnum;
              mod_env.md_id.objid = objid;

              /* Construct path to <filename>:PDU_DESIGN_FILE directory */
              di$give_pathname(
                               osnum = osnum,
                               pathname = stamp_path
                              );

              strcat(stamp_path, ":PDU_DESIGN_FILE");

              /* Check to see if file is a PDU design file */
              status = di$ls(regexp = stamp_path, ptr = &count);
              _pdm_status("di$ls", status);

              if ( (status == DIR_S_SUCCESS) && (count > 0) )
                 {
                  _pdm_debug("<%s> is a PDU design file", file);

                  /* Load delete local files buffer */
                  status = PDUload_delete_buffer(
                                                 &mod_env,
                                                 -1,
                                                 &attach_bufr
                                                );
                  _pdm_status("PDUload_delete_buffer", status);

                  if (status != PDM_S_SUCCESS)
                     {
                      _pdm_debug("PDUload_delete_buffer failed", 0);

                      /* Need to close obj space */
                      status = ex$close_module (
                                                index = index,
                                                flag = 0 | EX_ACTINV,
                                                ftype = EX_invisible
                                               );
                      _pdm_status ("ex$close_module", status);
                      exit;
                     }

                  file_found = TRUE;
                 }

              /* Close and save object space */
              status = ex$close_module (
                                        index = index,
                                        flag = 0 | EX_ACTINV,
                                        ftype = EX_invisible
                                       );
              _pdm_status ("ex$close_module", status);

              if (file_found)
                 {
                  status = PDM_S_SUCCESS;
                  break;
                 }

              else
                  {
                   _pdm_debug("<%s> is not a PDU design file", file);
                   status = PDM_S_SUCCESS;
                  }
             }

          else
              {
               _pdm_debug("file <%s> is not an OM file", file);
               status = PDM_S_SUCCESS;
              }
         }

     } /* end for loop */

  caw_formatfile[0] = '\0';
  caw_datafile[0] = '\0';

  sprintf(caw_formatfile, "/usr/tmp/%d.for", CANCOFILE_BUFR);
  sprintf(caw_datafile, "/usr/tmp/%d.dat", CANCOFILE_BUFR);

  status = PDMbuffer_to_file(attach_bufr, caw_formatfile, caw_datafile);
  _pdm_status("PDMbuffer_to_file", status);
  if (status != PDM_S_SUCCESS)
    exit;

  /* Free variables */
  if (file)
     free(file);

  if (file_bufr)
     MEMclose(&file_bufr);

exit;
}
