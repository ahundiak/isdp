:Using I/PDM External Functions:

This  describes the set of functions that exist to access I/PDM
and I/PDU from a program. These functions can be used in PPL
programs or in regular C programs executed outside the
product.  This topic provides the syntax and examples for
each function.

Macro                        Description

pdmoAddFiles                Adds files to an existing part.
pdmoAddPartToAssembly       Adds a part non-graphically to an assembly.
pdmoCancelCheckoutPart      Cancels a part checkout.
pdmoChangeFiles             Changes file for an existing part.
pdmoChangePart              Changes the definition for an existing part.
pdmocheckin                 Checks in a single part or list of parts.
pdmoCheckOutPart            Checks out a part or list of parts.
pdmOChkPartExistance        Checks to see if part exists in a given catalog.
pdmoDebugOn                 Turns debug on.
pdmoDefineAssembly          Adds a part non-graphically to an assemly.
pdmoDeleteFiles             Deletes files from an existing part.
pdmoDeletePart              Deletes part definition from database.
pdmoDeletePartOccurrence    Deletes a graphic part, non-graphic part, and any
                            parametric part, but does not delete the part
                            definition from the database.
pdmoFreeStructure           Frees an attribute structure that has been
                            used to add or change the attribute values
                            associated with a part.
pdmoFreeChangeStructure     Frees a file structure that has been used to
                            change the file information associated with a part.
pdmoFreeFileStructure       Frees a file structure that has been used to add or
                            change the file information associated with a part.
pdmoFreeStorageArea         Frees the memory allocated for the pdmStorageArea
                            structure.
pdmoFreeTransStructure      Frees the transition structure that contains a
                            list of possible transitions for a part.
pdmoGetObjidGivenUsageId    Returns the part's objid given the usageid for the
                            part.
pdmOGetPartOccurance        Gets instances of a part in the database.
pdmoLoadAttrStructure       Loads attribute values into a structure and
                            adds the structure as an entry in a link
                            list of structures.  The link list is then
                            passed to the pdmoAddPart function.
pdmoLoadChangeStructure     Loads file data into a structure and places the
                            structure as an entry in a link list of structures.
                            The link list is then passed to the pdmoChangePart 
                            function.
pdmoLoadFileStructure       Loads file data into a structure and places the
                            structure as an entry in a link list of structures.
                            The link list is then passed to the pdmoAddPart
                            or pdmoChangePart function.
pdmoLoadStorageArea         Loads the storage area structure pdmStorageArea.
                            Allocates memory for the structure and load the
                            structure with the input data.
pdmOLogout                  Logs a user out of an NFM environment and
                            disconnects the user from the underlying database.
pdmoModifyAssembly          Modifies the assembly structure of a part.
pdmoMoveToNextState         Moves a part to the next or previous state in the
                            user's workflow.
pdmoPlacePart               Places a graphic, non-graphic part, and any
                            parametric part.
pdmOReportAssembly          Creates an Exploded Summary BOM report.
pdmoRisQuery                Lets you query the database.
pdmoRisStmt                 Lets you manipulate the underlying relational
                            database by inserting, updating, or deleting data.

:pdmoAddFiles:

This API add files to an existing part.


pdmoAddFiles (cpr_catalog,               
              cpr_partnum,
              cpr_revision,
              cpr_acl_name,
              cpr_stg_name,
              spr_add_files); 

Argument        Data Type          I/O    Description

*cpr_catalog    char                I     Catalog Number.
*cpr_partnum    char                I     Part Number.
*cpr_revision   char                I     Part Revision.
*cpr_acl_name   char                I     ACL Name.
*cpr_stg_name   char                I     Storage Area Name.
*spr_add_files  struct file_info    I
    

Input Restrictions


[]   cpr_catalog


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_partnum


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_revision


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_acl_name


     -  Attribute is required.


     -  Default is PDM_PART_ACL.



[]   cpr_stg_name


     -  Attribute is required.


     -  Default is NFMFILES.



[]   spr_add_files


     -  Attribute is optional.


     -  Necessary for adding file information.

             Structures

struct file_info
  {
  char   cpr_file_desc[IK_FILEDESC_MAX];
  char   cpr_local_fn[IK_FILENAME_MAX];
  char   cpr_storage_fn[IK_FILENAME_MAX];
  char   cpr_file_type[IK_FILETYPE_MAX];
  int    ir_mode;
  struct file_info  *spm_next;
  };
Input Restrictions


[]   cpr_file_desc


     -  Attribute is optional.


     -  Must not exceed 40 characters.



[]   cpr_local_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   cpr_storage_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Filename must not already exist in check in storage area.



[]   cpr_file_type


     -  Attribute is optional.


     -  May not be "M" or "m".


     -  Must not exceed 5 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   ir_mode


     -  Attribute is reguired.


     -  Specifies whether user is adding, changing or deleting
        file information; ADD = 1, CHANGE = 2, DELETE = 3.


Status Return

PDM_S_SUCCESS                      Successful Completion.
PDM_E_CAT_FIELD_BLANK
PDM_E_PART_FIELD_BLANK
PDM_E_REV_FIELD_BLANK
PDM_E_LOC_FN_TOO_LONG
PDM_E_FILE_DESC_TOO_LONG
PDM_E_FILETYPE_TOO_LONG
PDM_E_STG_FN_TOO_LONG
PDM_E_CAT_NOT_FOUND
PDM_E_INVALID_CHAR_IN_LOCFN
PDM_E_INVALID_CHAR_IN_STGFN
PDM_E_INVALID_CHAR_IN_FILETYPE
PDM_E_IDENTIFIER_TOO_LONG
PDM_E_CI_FILENAME_EXISTS
PDM_E_STG_FN_NOT_UNIQUE
PDM_E_ACLNAME_NOT_FOUND
PDM_E_STGNAME_NOT_FOUND
PDM_I_TABLE_LOCKED
PDM_E_NOT_USER_LOGGED_IN

External Functions

PDUcheck_if_logged_in()
PDMvalidate_user_access()
PDUvalidate_catalog()
PDMcheck_partnum()
PDMget_existing_data()
PDUvalidate_parttype()
PDUverify_aclname()
PDUverify_file_desc()
PDUvefify_addpart_filename()
PDUcheck_dup_sa_fname()
PDUverify_filetype()
PDUformat_buffer()
PDUadd_files_to_buffer()
PDMmodify_part()
PDMcancel_modify_part()

Assumptions



1.   The pdmoLoadFileStructure must be called before calling
     pdmoAddFiles.


2.   The user must call pdmoFreeFileStructure to free the file
     structure.


3.   The PDMexec userid has been loaded during login.

:pdmoAddPartToAssembly:

This function adds a part non-graphically to the given
assembly. It validates the entries in child_list.  The structure
can be defined only if the part status is Checked In or Never
Checked In.

pdmoAddPartToAssembly
  (
    char *cpr_catalog,
    char *cpr_partnum,
    char *cpr_revsion,
    PDMchildren *spr_PDMstructure
  )

Argument          Data Type      I/O   Description

*cpr_catalog       char            I    Catalog Name to be defined.
*cpr_partnum       char            I    Part Number of the part to be defined.
*cpr_revision      char            I    Revision of the part to be defined.
*spr_PDMstructure  struct          I    Children info which make up the
                    PDMchildren         assembly.

   {
    int     im_n_citno;      /* System defined - Leave it  - N */
    int     im_n_pcatalogno; /* System defined - Leave it  - N */
    int     im_n_pitemno;    /* System defined - Leave it  - N*/
    int     im_n_ccatalogno; /* System defined - Leave it  - N*/
    int     im_n_citemno;    /* System defined - Leave it  - N*/
    int     ir_p_level;/* Level no of the assembly-Default 1 - OPTIONAL*/
    cha     caw_n_setindicator[2]; /* System defined -Leave it -N*/
    cha     caw_n_status[3];  /* System defined - Leave it  - N*/
    int     im_p_pchildno;    /* System defined - Leave it  - N*/
    int     ir_p_childno;    /* Child no of the like parts in the same
                                level, if multiple parts are defined without
                                this input system will assign it - OPTIONAL*/
    char    car_n_catalogname[21]; /*Catalogname of the child - INPUT */
    char    *cpr_n_itemname;      /*Partnumber of the child   - INPUT */
    char    *cpr_n_itemrev;       /*Revision   of the child   - INPUT */
    char    *cpr_n_itemdesc;      /*Description of the child  - INPUT */
    char    car_p_attached[2];/*Display flag of the child - Leave it -N */
    double  dr_p_quantity;   /* Quantity of the child - Default 1 OPTIONAL*/
    char    car_p_usgaeid[25]; /* Usage ID - OPTIONAL */
    char    car_n_cofilename[14]; /*Filename of the part - OPTIONAL */
    int     ir_p_tagno;  /* Tagno - OPTIONAL - Default system generates */
    char    car_p_alttagno;/* ALttagno -OPTIONAL-Default system generates*/
    spr_children      *next;/* NEXT child pointer of linked list or NULL*/
   }* spr_PDMchildren;

 pdmoLoadChildStructure can be called to load this structure.

Input Restrictions


[]   cpr_n_catalogname


     -  Attribute Required.



[]   cpr_n_itemname


     -  Attribute Required.



[]   cpr_n_itemrev


     -  Attribute Required.



[]   ir_p_tagno


     -  Attribute cannot be zero or negative.



[]   ir_p_quantity


     -  Attribute cannot be zero or negative.

Example

#include  <stdio.h>
#include  "PDUerror.h"
#include  "MEMstruct.h"
#include  "MEMerrordef.h"
#include  "NFMerrordef.h"
#include  "SQLerrordef.h"
#include  "PDUris_incl.h"
#include  "PDMproto.h"
#include  "PDUpdmrpro.h"

static  long  status; static  char  s[1024]; extern  int   PDMdebug_on; extern  char
PDM_DEBUG_FILE[]; extern  PDMexec_ptr   PDMexec;

status = pdmoAddPartToAssembly (
                                cpr_catalog,
                                cpr_partnum,
                                cpr_revsion,
                                spr_PDMstructure
                               ); 

Status Return

PDM_S_SUCCESS                 Succesful Completion.
PDM_E_CATALOG_NOT_FOUND       Catalog Not Found.
PDM_E_PART_NOT_FOUND          Part Number Not Found.
PDM_E_CAT_FIELD_BLANK         Catalog Field Blank.
PDM_E_PART_FIELD_BLANK        Part Number Field Blank.
PDM_E_REV_FIELD_BLANK         Revison Field Blank.
PDM_E_INVALID_PART_TYPE       Invalid Part Type.
PDM_I_TABLE_LOCKED            Concurrent Access, the Table is Locked.
PDM_E_LOCK_CIT                CIT is locked, Please try later.
PDM_E_SQL_STMT                Invalid data.

Assumptions



1.   The part status is Checked In or Never Checked In.


2.   Parts are known to the database, except the view parts.


3.   Parts are yet to be positioned.


4.   Parts are not cyclic, except for the background
     attachement.


5.   The user has the access the change the defintion of the
     part.


6.   The part is not flagged for delete, restore, backup, archive.


7.   The part is backuped, or archived.


8.   You can't change parametric assemblies.


9.   You can't change nth level structure.


10.  The user is logged into the database.

Functions Called

PDMquery_catalog_partnos
MEM functions
PDMquery_assembly_ind
PDMload_partnos
PDMload_parentnos
PDMcheck_cycles
PDMstop_transaction
SQLstmt
PDMset_n_setindicator
PDMstart_transaction

Reused Functions

PDMquery_catalog_partnos  - used everywhere
MEM functions             - used everywhere
PDMquery_assembly_ind     - used everywhere
PDMload_partnos           - List local files
PDMstop_transaction       - used everywhere
SQLstmt                   - used everywhere
PDMset_n_setindicator    - Checkin
PDMstart_transaction     - used everywhere

:pdmCancelCheckoutPart:

This macro cancel part checkout.

int pdmoCancelCheckoutPart ( char *cpr_Catalog,
                             char *cpr_Partnum,
                             char *cpr_Revision)

Argument       Data Type       I/O    Description
             
*cpr_Catalog    char            I     Catalog name.
*cpr_Partnum    char            I     Part number.
*cpr_Revision   char            I     Part revision.

Attribute Restrictions


[]   cpr_catalog


     -  Attribute is required.


     -  Must contain 16 characters or less.


     -  Must already exist.



[]   cpr_partnum


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Part number must not exceed the number of characters
        specified at catalog creation time.



[]   cpr_revision


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Part revision must not exceed the number of characters
        specified at catalog creation time.

Assumptions


[]   The storage structure should have the current working
     area information.


[]   Global structure information required for validate access.

Status Returns

PDM_S_SUCCESS                  Successful Completion
PDM_E_APPEND_BUFFER
PDM_E_BUFFER_FORMAT
PDM_E_BUILD_ARRAY
PDM_E_COULD_NOT_LOAD_PART_INFO
PDM_E_COULD_NOT_MALLOC
PDM_E_CO_SAME_USER_DIFF_SA
PDM_E_ITEM_LOCKED
PDM_E_NOTCHECK_IN
PDM_E_NOTCHECK_OUT
PDM_E_NOT_CO_USER
PDM_E_PART_CHECKED_OUT
PDM_E_PART_FLAGGED_FOR_ARCHIVE
PDM_E_PART_FLAGGED_FOR_BACKUP
PDM_E_PART_FLAGGED_FOR_DELETE
PDM_E_PART_FLAGGED_FOR_RESTORE
PDM_E_PART_NONGRAPHIC
PDM_E_TEMP_IN
PDM_E_TEMP_OUT
PDM_E_WRITE_ROW
PDM_I_CHECKED_OUT_BY_ANOTHER_USER
PDM_E_ASSY_NOT_CHECKEDIN
PDM_E_ITEM_FLAG_ARCHIVE
PDM_E_ITEM_FLAG_BACKUP
PDM_E_ITEM_FLAG_DELETE
PDM_E_NO_PART_FILE
PDM_E_SET_FLAG_ARCHIVE
PDM_E_SET_FLAG_BACKUP
PDM_I_TABLE_LOCKED

:pdmoChangeFiles:

This API change files for an existing part.

pdmoChangeFiles  (cpr_catalog,
                  cpr_partnum,
                  cpr_revision,
                  cpr_acl_name,
                  cpr_stg_name,
                  spr_add_files);

Argument             Data Type              I/O    Description

*cpr_catalog         char                    I     Catalog Name.
*cpr_partnum         char                    I     Part Number.
*cpr_revision        char                    I     Part Revision.
*cpr_acl_name        char                    I     Access Control List Name.
*cpr_stg_name        char                    I     Storage Area Name.
*spr_change_files    struct file_info        I     New file name.
                    

Input Restrictions


[]   cpr_catalog


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_partnum


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_revision


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_acl_name


     -  Attribute is required.


     -  Default is PDM_PART_ACL.



[]   cpr_stg_name


     -  Attribute is required.


     -  Default is NFMFILES.



[]   spr_add_files


     -  Attribute is optional.


     -  Necessary for adding file information.

Example

status = pdmoChangeFiles(
                          "api_catalog",
                          "api_part1",
                          "a",
                          "PDM_PART_ACL",
                          "NFMFILES",
                          chg_file_list
                         );

Structures

struct file_info
     {
        char    cpr_file_desc[IK_FILEDESC_MAX];
        char    cpr_local_fn[IK_FILENAME_MAX];
        char    cpr_storage_fn[IK_FILENAME_MAX];
        char    cpr_file_type[IK_FILETYPE_MAX];
        int     ir_mode;
        struct  file_info  *spm_next;
     };

Input Restrictions


[]   cpr_file_desc


     -  Attribute is optional.


     -  Must not exceed 40 characters.



[]   cpr_local_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   cpr_storage_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters filename must not already exist in check in
        storage area.



[]   cpr_file_type


     -  Attribute is optional.


     -  May not be "M" or "m".


     -  Must not exceed 5 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   ir_mode


     -  Attribute is reguired.


     -  Specifies whether user is adding, changing, or deleting
        file information; ADD = 1, CHANGE = 2, DELETE = 3.

Status Return

PDM_S_SUCCESS                   Successful Completion.
PDM_E_CAT_FIELD_BLANK           Catalog Field Blank.
PDM_E_PART_FIELD_BLANK          Part Field Blank.
PDM_E_REV_FIELD_BLANK           Revision Field Blank.
PDM_E_LOC_FN_TOO_LONG           Location Field Too Long.
PDM_E_FILE_DESC_TOO_LONG        File Description Too Long.
PDM_E_FILETYPE_TOO_LONG         File Name Too Long.
PDM_E_STG_FN_TOO_LONG           STG_FN Too Long.
PDM_E_CAT_NOT_FOUND             Catalog Not Found.
PDM_E_INVALID_CHAR_IN_LOCFN     Invalid Character in LOCFN.
PDM_E_INVALID_CHAR_IN_STGFN     Invalid Character in STGFN.
PDM_E_INVALID_CHAR_IN_FILETYPE  Invalid Character in File Type.
PDM_E_IDENTIFIER_TOO_LONG       Identifier Too Long.
PDM_E_CI_FILENAME_EXISTS        CI File Name.
PDM_E_STG_FN_NOT_UNIQUE         STGFN Not Unique.
PDM_E_ACLNAME_NOT_FOUND         Access Control Name Not Found.
PDM_E_STGNAME_NOT_FOUND         STG Name Not Found.
PDM_I_TABLE_LOCKED              Table Locked.
PDM_E_NOT_USER_LOGGED_IN        User Not Logged In.

External Functions

PDUcheck_if_logged_in()
PDMvalidate_user_access()
PDUvalidate_catalog()
PDMcheck_partnum()
PDMget_existing_data()
PDUvalidate_parttype()
PDUverify_aclname()
PDUverify_storage_name()
PDUverify_file_desc()
PDUverify_addpart_filename()
PDUcheck_dup_sa_fname()
PDUverify_filetype()
PDUformat_buffer()
PDUadd_files_to_buffer()
PDMmodify_part()
PDMcancel_modify_part()

Assumptions



1.   The pdmoLoadChangeStructure must be called before
     calling pdmoChangeFiles.


2.   The user must call pdmoFreeChangeStructure to free the
     file structure.


3.   The PDMexec userid has been loaded during login.

:pdmoChangePart:

This API changes the definition of an existing part in the
database.

pdmoChangePart (
                cpr_catalog,
                cpr_partnum,
                cpr_revision,
                cpr_parttype,
                cpr_description,
                cpr_acl_name,
                cpr_stg_name,
                spr_attrs,
                spr_add_files,
                spr_chg_files,
                spr_delete_files
               );

Argument            Data Type                I/O    Description

*cpr_catalog        char                      I     Catalog Number.
*cpr_partnum        char                      I     Part Number.
*cpr_revision       char                      I     Part Revision.
*cpr_parttype       char                      I     Part Type.
*cpr_description    char                      I     Description.
*cpr_acl_name       char                      I     Access Control Name.
*cpr_stg_name       char                      I     Storage Area Name.
*spr_attrs          struct attribute_info     I     Attribute.
*spr_add_files      struct file_info          I     Add Files.
*spr_chg_files      struct chg_file_info      I     Change Files.
*spr_delete_files   struct file_info          I     Delete File.


Input Restrictions


[]   cpr_catalog


     -  Attribute is required.



[]   cpr_partnum


     -  Attribute is required.



[]   cpr_revision


     -  Attribute is required.



[]   cpr_parttype


     -  Attribute is required.



[]   cpr_description


     -  Attribute Optional.



[]   cpr_acl_name


     -  Attribute is required.



[]   cpr_stg_name


     -  Attribute is required.



[]   spr_add_files


     -  Attribute Optional.



[]   spr_chg_files


     -  Attribute Optional.



[]   spr_delete_files


     -  Attribute is optional.



[]   spr_attrs


     -  Attribute is required.

Example

status = pdmoChangePart(
                        "api_catalog",
                        "api_part1",
                        "a",
                        "G",
                        "part added through API",
                        "PDM_PART_ACL",
                        "NFMFILES",
                        attr_list,
                        add_file_list,
                        chg_file_list
                       );

Structures

struct file_info
      {
        char    cpr_file_desc[IK_FILEDESC_MAX];
        char    cpr_local_fn[IK_FILENAME_MAX];
        char    cpr_storage_fn[IK_FILENAME_MAX];
        char    cpr_file_type[IK_FILETYPE_MAX];
        int     ir_mode;
        struct  file_info  *spm_next;
      };
struct chg_file_info
      {
        char    cpr_file_desc[IK_FILEDESC_MAX];
        char    cpr_chg_file_desc[IK_FILEDESC_MAX];
        char    cpr_local_fn[IK_FILENAME_MAX];
        char    cpr_chg_local_fn[IK_FILENAME_MAX];
        char    cpr_storage_fn[IK_FILENAME_MAX];
        char    cpr_chg_storage_fn[IK_FILENAME_MAX];
        char    cpr_file_type[IK_FILETYPE_MAX];
        char    cpr_chg_file_type[IK_FILETYPE_MAX];
        int     ir_mode;
        struct  chg_file_info  *spm_next;
    };

Restrictions


[]   cpr_file_desc


     -  Attribute is optional.


     -  Must not exceed 40 characters.



[]   cpr_local_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   cpr_storage_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Filename must not already exist in check in storage area.



[]   cpr_file_type


     -  Attribute is optional.


     -  May not be M or m.


     -  Must not exceed 5 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   ir_mode


     -  Attribute is required.


     -  Specifies whether user is adding, changing, or deleting
        file information: ADD = 1, CHANGE = 2, DELETE = 3.

struct attribute_info
    {
       char   cpr_attr_name[IK_ATTR_MAX];
       char   cpr_datatype[IK_DATATYPE_MAX];
       char   cpr_synonym[IK_SYNONYM_MAX];
       char   cpr_value[IK_VALUE_MAX];
       struct attribute_info *spm_next;
    };

Restrictions


[]   cpr_attr_name


     -  Attribute is required.


     -  Must not exceed 20 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Must not be a database reserved word.



[]   cpr_datatype


     -  Attribute is required.


     -  Must be a valid datatype: real, integer, char(xx), decimal,
        smallint.



[]   cpr_synonym


     -  Attribute is required.


     -  Must not exceed 40 characters.



[]   cpr_value


     -  Attribute is optional.


     -  Must be compatible with the specified datatype.

Status Return

PDM_S_SUCCESS                     Successful Completion.
PDM_E_CAT_FIELD_BLANK             Catalog Field Blank.
PDM_E_PART_FIELD_BLANK            Part Field Blank.
PDM_E_REV_FIELD_BLANK             Revision Field Blank.
PDM_E_LOC_FN_TOO_LONG             Location Field Too Long.
PDM_E_FILE_DESC_TOO_LONG          File Description Too Long.
PDM_E_FILETYPE_TOO_LONG           File Type Too Long.
PDM_E_STG_FN_TOO_LONG             Storage Area Too Long.
PDM_E_CAT_NOT_FOUND               Catalog Not Found.
PDM_E_INVALID_CHAR_IN_LOCFN       Invalid Character in LOCFN.
PDM_E_INVALID_CHAR_IN_STGFN       Invalid Character in StorageFN.
PDM_E_INVALID_CHAR_IN_FILETYPE    Invalid Character in File Type.
PDM_E_IDENTIFIER_TOO_LONG         Identifier Too Long.
PDM_E_CI_FILENAME_EXISTS          File Name Exists.
PDM_E_STG_FN_NOT_UNIQUE           StorageFN Is Not Unique.
PDM_E_ACLNAME_NOT_FOUND           Access Control List Not Found.
PDM_E_STGNAME_NOT_FOUND           Storage Name Not Found.
PDM_E_INVALID_PART_TYPE           Invalid Part Type.
PDM_I_TABLE_LOCKED                Table Locked.
NFM_E_ITEM_ACL_NOT_IN_PROJ_MAP    Access Control List Not In ??.
NFM_E_NO_SO_FOUND_FOR_ITEM        ????.
NFM_E_NO_SO_USERS_FOUND_IN_ACL    ????.
NFM_W_INVALID_VERSION_LIMIT       Invalid Version Limit.
NFM_E_INV_ACL_FOR_OWNED_MEMBER    Invalid Access Control List For Owned Member.
NFM_E_INV_ACL_FOR_MAPPED_CAT      Invalid Access Control List For Mapped
                                  Catalog.
PDM_E_NOT_USER_LOGGED_IN          No User Logged In.

External Functions

PDUcheck_if_logged_in()
PDMvalidate_user_access()
PDUvalidate_catalog()
PDMcheck_partnum()
PDMget_existing_data()
PDUcheck_desc_datatype()
PDUvalidate_parttype()
PDUverify_aclname()
PDUverify_storage_name()
PDUverify_file_desc()
PDUverify_addpart_filename()
PDUcheck_dup_sa_fname()
PDUverify_filetype()
PDUfind_attr_in_bufr()
PDUvalid_attr()
PDUcheck_for_reserved_words()
PDUformat_buffer()
PDUdelete_files_from_buffer()
PDUadd_files_to_buffer()
PDUchange_files_in_buffer()
PDMmodify_part()
PDMcancel_modify_part()

Assumptions



1.   If the user is adding or deleting file information,
     pdmoLoadFileStructure must be called before calling
     pdmoChangePart.


2.   If the user is changing file information,
     pdmoLoadChangeStructure must be called before calling
     pdmoChangePart.


3.   If the user is changing attribute values,
     pdmoLoadAttrStructure must be called before
     pdmoChangePart.


4.   The user must call the appropriate APIs to free the file and
     attribute structures.


5.   The PDMexec userid has been loaded during log-in.

pdmocheckin

This macro checks in a list of parts. The files of the parts are
moved and the database is updated.

long pdmoAddPartToAssembly
(
PDMparts *spr_parts;
)
{
 *cpr_n_catalogname,
 *cpr_n_itemname,
 *cpr_n_itemrev,
 *cpr_filename,
 car_st_update_flag[2],
 iw_status,
 *spr_next
{

Argument                 Data Type        I/O    Description
                   
*spr_parts               PDMparts          I     Linked list of parts to be
                                                 checked in.
*cpr_n_catalogname       char              I     Catalog of the part to be
                                                 checked in.
*cpr_n_itemname          char              I     Part number of the part to be
                                                 checked in.
*cpr_n_itemrev           char              I     Revision of the part to be
                                                 checked in.
*cpr_filename            char              I     Local filename of the part 
                                                 from which the assembly
                                                 structure is to be read, if 
                                                 the part is and assembly and 
                                                 has multiple files.  If this 
                                                 input is null, the only
                                                 or the first file will be
                                                 taken for checkin.
car_st_update_flag[2]    char              I     Flag to indicate
                                                 whether to update the product
                                                 structure or not.  Setting
                                                 this flag to "N", 'n',
                                                 disables product structure
                                                 update, and only file 
                                                 management will be done. By
                                                 setting this flag to 'N', you
                                                 don't need have loaded in the
                                                 workstation for checkin.
iw_status                long              O     Status of the checkin
                                                 operation of this part.
*spr_next                PDMparts          O     Pointer to the next node in 
                                                 the linked list or NULL.

Notes

pdmoLoadPartsForCheckin can be called to load this structure.

Attribute Restrictions


[]   cpr_n_catalogname


     -  Attribute is required.


     -  Must contain 16 characters or less.


     -  Must already exist.



[]   cpr_n_itemname


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_n_itemrev


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_filename


     -  Attribute is optional.



[]   car_st_update_flag


     -  Attribute is optional.


     -  Y,y,N,n, and NULL STRING are valid values.

Assumptions



1.   The part is checked out/Never checked in.


2.   Parts are known to the database, except the view parts.


3.   The user has the access to checkin the part.


4.   The part is not flagged for delete, restore, backup, archive.


5.   The part is backuped, or archived.


6.   The part is not non-graphic or parametric.


7.   The files of the part are all local.


8.   The user is logged into the database.

Functions Called

PDUint_checkin
PDUext_checkin
PDMvalidate_user_access
PDMload_part_info
PDMcheckin
PDMupdate_set_members
PDMinsert_cit_info
NFMcheckin_item.
PDMupdate_local_filemgr
PDMdelete_macro_libraries
PDMdefine_parametric_assembly
PDMquery_catalog_partnos
MEM functions
PDMget_filenames
gr$get_module_env
ex$is_om_file
ex$retrieve_module
ex$get_invis_info_by_index
PDUis_PDU_file
PDUremove_PDU_design_file_stamp
ex$close_module.
PDUprepare_param_cats_list
PALcheckin
PDUload_child_buffer
di$find.
di$dump.
co$part_get_attr.
PDUload_attach_buffer
PDUevalute_exp
PDUload_dynamic_attrs
PDUget_all_GRpart_ids.
PDUprocess_part_dyn_attrs
di$give_pathname
PDUload_view_info
PDMcheck_cycles
PDMstop_transaction
SQLstmt
PDMset_n_setindicator
PDMstart_transaction

Status Returns

PDM_S_SUCCESS               Succesful Completion
PDM_E_CATALOG_NOT_FOUND     Catalog does not exist.
PDM_E_PART_NOT_FOUND        Part does not exist.
PDM_E_CAT_FIELD_BLANK       User must enter catalog.
PDM_E_PART_FIELD_BLANK      User must enter part number.
PDM_E_REV_FIELD_BLANK       Part revison field empty.
PDM_E_INVALID_PART_TYPE     Invalid part type.
PDM_I_TABLE_LOCKED          Concurrent access, the table is locked.
PDM_E_SQL_STMT              Invalid data.

Example

#include  <stdio.h>
#include  "PDUerror.h"
#include  "MEMstruct.h"
#include  "MEMerrordef.h"
#include  "NFMerrordef.h"
#include  "SQLerrordef.h"
#include  "PDUris_incl.h"
#include  "PDMproto.h"
#include  "PDUpdmrpro.h"

static  long  status;
static  char  s[1024]; 
extern  int   PDMdebug_on; 
extern  char  PDM_DEBUG_FILE[]; 
extern  PDMexec_ptr     PDMexec;

 status = pdmoCheckin ( PDMparts spr_parts); 

:pdmoCheckOutPart:

This macro checks out a part.

int pdmoCheckOutPart (
                      PDMparts *spm_parts,
                      long *ipw_status
                     )

Argument     Data Type       I/O    Description
             

*spm_parts   PDMparts         I     Structure containing the part information.
*ipw_status  long             I     Overall status of the command.

Structure definition

  PDMparts *spr_part {

    char *cpr_catalog      : Catalog name of the part to be checked out
                             Required
    char *cpr_itemname     : Item name of the part to be checked out
                             Required
    char *cpr_itemrev      : Item Rev of the part to be checked out
                             Required
    char *cpr_Filename     : Checkout Filename name of the part to be
                             checked out
                             Optional /*
    char car_st_update[2]  : Flag to indicate whether display management is
             Not Required    required for this part. Possible values are
                             "Y" &  "N". Default will be "N".  */
    long *ipw_PStatus      : Status of checkout operation of this part

    PDMparts *spm_next     : Pointer to the next node in the linked list
                             or NULL
         } 

Assumptions



1.   The catalog and part exists for each entry and the part is
     an assembly.


2.   The storage structure should have the current working
     area information.


3.   Global structure information required for validate access.

Return Status

PDM_S_SUCCESS                       Successful Completion.
PDM_E_APPEND_BUFFER
PDM_E_BUFFER_FORMAT
PDM_E_BUILD_ARRAY
PDM_E_COULD_NOT_LOAD_PART_INFO
PDM_E_COULD_NOT_MALLOC
PDM_E_CO_SAME_USER_DIFF_SA
PDM_E_ITEM_LOCKED
PDM_E_NOTCHECK_IN
PDM_E_NOTCHECK_OUT
PDM_E_NOT_CO_USER
PDM_E_PART_CHECKED_OUT
PDM_E_PART_FLAGGED_FOR_ARCHIVE
PDM_E_PART_FLAGGED_FOR_BACKUP
PDM_E_PART_FLAGGED_FOR_DELETE
PDM_E_PART_FLAGGED_FOR_RESTORE
PDM_E_PART_NONGRAPHIC
PDM_E_TEMP_IN
PDM_E_TEMP_OUT
PDM_E_WRITE_ROW
PDM_I_CHECKED_OUT_BY_ANOTHER_USER
PDM_E_ASSY_NOT_CHECKEDIN
PDM_E_ITEM_FLAG_ARCHIVE
PDM_E_ITEM_FLAG_BACKUP
PDM_E_ITEM_FLAG_DELETE
PDM_E_NO_PART_FILE
PDM_E_SET_FLAG_ARCHIVE
PDM_E_SET_FLAG_BACKUP
PDM_I_TABLE_LOCKED
PDM_I_COULD_NOT_CO_SOME_PARTS
PDM_E_COULD_NOT_CHECKOUT_PARTS

:pdmOChkPartExistance:

This function checks to see whether given part exists in the
given catalog with given revision.

pdmOChkPartExistance ( *cpr_Catalog,
                       *cpr_Partnum,
                       *cpr_Revision);

Argument          Data Type       I/O    Description


*cpr_catalog       char            I     Catalog name.
*cpr_partnum       char            I     Part number.
*cpr_revision      char            I     Part revision.
*ipw_status        int             O     Status returned by the function

Input Restrictions


[]   *cpr_catalog


     -  Attribute is required.



[]   *cpr_partnum


     -  Attribute is required.



[]   cpr_revision


     -  Attribute is required.

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_PART_NOT_FOUND          Part Does Not Exist.
PDM_E_CATALOG_NOT_FOUND       Catalog Does Not Exist.
PDM_E_NO_SUCH_TABLE           Table Does Not Exist.
PDM_E_NO_SUCH_ATTRIBUTE       Attribute Does Not Exist.
PDM_E_REQ_COLUMN_NOT_FOUND    Column Does Not Exist.

Assumptions

Catalog exists in the database.
:pdmoDebugOn:

The global variables are PDM_debug_on, and PDMdebug_on
to 1.  The path variables are PDU_DEBUG_FILE, and
PDM_DEBUG_FILE are loaded.  NFM variables toggles and files
are set.

int pdmoDebugOn (
                  int iar_toggles[8],
                  char car_paths[8]
                 )

Input:
        toggles [0] =   1 or 0;    /*PDU deb on or debug off*/
        toggles [1] =   1 or 0;    /*PDM deb on or debug off*/
        toggles [2] =   1 or 0;    /*NFM deb on or debug off*/
        toggles [3] =   1 or 0;    /*SQL deb on or debug off*/
        toggles [4] =   1  or 0;     /*MEMS deb on or debug off*/
        toggles [5] =   1  or 0;     /*ERRS deb on or debug off*/
        toggles [6] =   1 or 0;    /*NET-CLIENT deb on or debug off*/
        toggles [7] =   1 or 0;    /*NET-SERVER deb on or debug off*/

   The path variables for NFM are

        files [0] =   "/usr2/tmp/pdu.dbg"; /*PDU debug file*/
        files [1] =   "/usr2/tmp/pdm.dbg";  /*PDM debug file*/
        files [2] =   "/usr2/tmp/nfm.dbg"; /*NFM debug file*/
        files [3] =   "/usr2/tmp/sql.dbg";  /*SQL debug file*/
        files [4] =   "/usr2/tmp/mem.dbg";  /*MEM debug file*/
        files [5] =   "/usr2/tmp/err.dbg";  /*ERRS debug file*/
        files [6] =   "/usr2/tmp/netc.dbg";  /*NETC debug file*/
        files [7] =   "/usr2/tmp/nets.dbg";  /*NETS debug file*/ 

Functions

NFMdebug_all

Status Returns

PDM_S_SUCCESS                 Successful Completion.
PDM_E_OPEN_FILE               Couldn't open the debug files.
PDM_E_FAILURE                 Couldn't generate the debugs.

Include Files
#include <DEBUG.h>

Main Function

int pdmoDebugOn ( )

{ }

Name
   pdmoDebugOff

Abstract
   Turns the debug option "OFF" of PDU,PDM,and NFM subsystems.

Synopsis
  int pdmoDebugOff ()

Description
   The global variables are PDM_debug_on, and PDMdebug_on to "OFF".
   The path variables are PDU_DEBUG_FILE, and PDM_DEBUG_FILE to "OFF".
    NFM variables of toggle and files for set.

   Algorithm:
       1. Sets the global variables PDM_debug_on for PDU debug to zero.
          Nullifies the path of PDU_DEBUG_FILE variable, proceeds further
       2. Sets the global variables PDMdebug_on for PDM debug to zero.
          Nullifies the path of PDM_DEBUG_FILE variable, proceeds further
       3. Sets the variable NFMtoggle[8] =0 for NFM subsystem debug.
          Nullifies the path to NFMfiles[8] variable, proceeds further
       4. Sets the variable NFMtoggle[9] =0 for SQL sub system debug
          Nullifies the path to NFMfiles[9] variable, proceeds further
       5. Sets the variable NFMtoggle[11] =0 for MEM subsytem debug
          Nullifies  the path to NFMfiles[11] variable, proceeds further
       6. Sets the variable NFMtoggle[14] =0 for Error sub sytem debug
          Nullifies the path to NFMfiles[14] variable, proceeds further
       7. Sets the variable NFMtoggle[6] =0 for Error sub sytem debug
          Nullifies the path to NFMfiles[6] variable, proceeds further
       8. Sets the variable NFMtoggle[3] =0 for Error sub sytem debug
          Nullifies the path to NFMfiles[3] variable, proceeds further

then call NFMall_debug() function ; return success; 

Assumption



1.   The user has logged into the database.

Function

NFMdebug_all

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_FAILURE                 Couldn't turn the debug off.

Include Files
#include <DEBUG.h>

Main Function

int pdmoDebugOff ( )

{ } 

:pdmoDefineAssembly:

To define a non-graphic assembly, a list of 1-level children are
given.  This function adds a part non-graphically to the given
assembly. It validates the entries in child_list [It adds to the
database, if the parts doesn't exist in the case of VIEW
catalogs]. The structure can be defined on if part is checked
in/Never checked in. If it's already exits as an assembly,
knock off the old defintion, redefine the structure.


long pdmoDefineAssembly (
                           char *cpr_catalog,
                           char *cpr_partnum,
                           char *cpr_revsion,
                           PDMchildren *spr_PDMstructure
                         )


Argument            Data Type       I/O    Description

*cpr_catalog        char              I     Catalog of the part to be defined.
*cpr_partnum        char              I     Partnum of the part to be defined.
*cpr_revision       char              I     Revision of the part to be defined.
*spr_PDMstructure   struct            I     Children info which make up the
                    PDMchildren             assembly.

        {
        int     im_n_citno;      /* System defined - Leave it  - N */
        int     im_n_pcatalogno; /* System defined - Leave it  - N */
        int     im_n_pitemno;    /* System defined - Leave it  - N*/
        int     im_n_ccatalogno; /* System defined - Leave it  - N*/
        int     im_n_citemno;    /* System defined - Leave it  - N*/
        int     ir_p_level;/* Level no of the assembly-Default 1 - OPTIONAL*/
        cha     caw_n_setindicator[2]; /* System defined -Leave it -N*/
        cha     caw_n_status[3];  /* System defined - Leave it  - N*/
        int     im_p_pchildno;    /* System defined - Leave it  - N*/
        int     ir_p_childno;    /* Child no of the like parts in the
                                    same level, if multiple parts
                                    are defined without this input
                                   system will assign it - OPTIONAL*/
        char    car_n_catalogname[21]; /*Catalogname of the child -
INPUT */
        char    *cpr_n_itemname;      /*Partnumber of the child   -
INPUT */
        char    *cpr_n_itemrev;       /*Revision   of the child   -
INPUT */
        char    *cpr_n_itemdesc;      /*Description of the child  -
INPUT */
        char    car_p_attached[2];/*Display flag of the child - Leave it
-N */
        double  dr_p_quantity;   /* Quantity of the child - Default 1 -
                                    OPTIONAL*/
        char    car_p_usgaeid[25]; /* Usage ID - OPTIONAL */
        char    car_n_cofilename[14]; /*Filename of the part - OPTIONAL */
        int     ir_p_tagno;  /* Tagno - OPTIONAL - Default system
generates */
        char    car_p_alttagno;/* ALttagno -OPTIONAL-Default system generates*/
        spr_children      *next;/* NEXT child pointer of linked list or NULL*/
        }* spr_PDMchildren;

Notes

pdmoLOadChildStructure can be used to load this structure.

Input Restrictions


[]   cpr_n_catalogname


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_n_itemname


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_n_itemrev


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   ir_p_tagno


     -  Cannot be zero or negative.



[]   ir_p_quantity


     -  Cannot be zero or negative.

Example

#include                <stdio.h>
#include                "PDUerror.h"
#include                "MEMstruct.h"
#include                "MEMerrordef.h"
#include                "NFMerrordef.h"
#include                "SQLerrordef.h"
#include                "PDUris_incl.h"
#include                "PDMproto.h"
#include                "PDUpdmrpro.h"

static  long status; 
static  char s[1024]; 
extern  int PDMdebug_on; 
extern  char PDM_DEBUG_FILE[]; 
extern  PDMexec_ptr PDMexec;

Main Function 

Status Return

PDM_S_SUCCESS                 Succesful Completion.
PDM_E_CATALOG_NOT_FOUND       A given catalog is not there in the DB.
PDM_E_PART_NOT_FOUND          A given part/rev is not there in the DB.
PDM_E_CAT_FIELD_BLANK         Catalog field empty.
PDM_E_PART_FIELD_BLANK        Partnum field empty.
PDM_E_REV_FIELD_BLANK         Revison field empty.
PDM_E_INVALID_PART_TYPE       Invalid part type.
PDM_I_TABLE_LOCKED            Concurrent access, the table is locked.
PDM_E_LOCK_CIT                CIT is locked, Please try later.
PDM_E_SQL_STMT                Invalid data.

Assumptions



1.   The part is checked in/Never checked in.


2.   Parts are know to the database, except the view parts.


3.   Parts are yet to be positioned.


4.   Parts are not cyclic, except for the background
     attachement.


5.   The user has the access the change the defintion of the
     part.


6.   The part is not flagged for delete, restore, backup, archive.


7.   The part is backuped, or archived.


8.   You can't change parametric assemblies.


9.   You can't change nth level structure.


10.  The user is logged into the database.

Functions

PDMsdefine_assembly_structure
PDMquery_catalog_partnos
MEM functions
PDMexpand_copy_buffer
PDMquery_assembly_ind
PDMload_partnos
PDMload_parentnos
PDMcheck_cycles
PDMstop_transaction
SQLstmt
PDMdron_setindicator
PDMload_set_members
PDMset_n_setindicator
PDMstart_transaction

Reused Functions

PDMquery_catalog_partnos  - used everywhere
MEM functions             - used everywhere
PDMexpand_copy_buffer     - Data defintion functionality
PDMquery_assembly_ind     - used everywhere
PDMload_partnos           - List local files
PDMstop_transaction       - used everywhere
SQLstmt                   - used everywhere
PDMdron_setindicator      - Checkin
PDMload_set_members       - Checkin
PDMset_n_setindicator    - Checkin
PDMstart_transaction     - used everywhere

:pdmoDeleteFiles:

This API deleted files from an existing part.

pdmoDeleteFiles(
                cpr_catalog,
                cpr_partnum,
                cpr_revision,
                cpr_acl_name,
                cpr_stg_name,
                spr_add_files
               );

Argument           Data Type         I/O   Description

*cpr_catalog       char               I    Catalog Number.
*cpr_partnum       char               I    Part Number.
*cpr_revision      char               I    Revision.
*cpr_acl_name      char               I    Access Control List.
*cpr_stg_name      char               I    Storage Name.
*spr_delete_files  struct file_info   I    Delete Files.
                    

Input Restrictions


[]   cpr_catalog


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_partnum


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_revision


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_acl_name


     -  Attribute is required.


     -  Default is PDM_PART_ACL.



[]   cpr_stg_name


     -  Attribute is required.


     -  Default is NFMFILES.



[]   spr_delete


     -  Attribute is optional.


     -  Necessary for deleting file information.

Example

status = pdmoDeleteFiles(
                         "api_catalog",
                         "api_part1",
                         "a",
                         delete_file_list
                        );

Structures

struct file_info
    {
       char   cpr_file_desc[IK_FILEDESC_MAX];
       char   cpr_local_fn[IK_FILENAME_MAX];
       char   cpr_storage_fn[IK_FILENAME_MAX];
       char   cpr_file_type[IK_FILETYPE_MAX];
       int    ir_mode;
       struct file_info  *spm_next;
    };

Restrictions


[]   cpr_file_desc


     -  Attribute is optional.


     -  Must not exceed 40 characters.



[]   cpr_local_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   cpr_storage_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Filename must not already exist in check in storage area.



[]   cpr_file_type


     -  Attribute is optional.


     -  May not be M or m.


     -  Must not exceed 5 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   ir_mode


     -  Attribute is required.


     -  Specifies whether user is adding, changing, or deleting
        file information: ADD = 1, CHANGE = 2, DELETE = 3.

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_CAT_FIELD_BLANK         Catalog Field Blank.
PDM_E_PART_FIELD_BLANK        Part Field Blank.
PDM_E_REV_FIELD_BLANK         Revision Field Blank.
PDM_E_CAT_NOT_FOUND           Catalog Not Found.
PDM_E_ACLNAME_NOT_FOUND       Access Control List Not Found.
PDM_E_STGNAME_NOT_FOUND       Storage Area Not Found.
PDM_I_TABLE_LOCKED            Table Locked.
PDM_E_NOT_USER_LOGGED_IN      User Not Logged In.

External Functions

PDUcheck_if_logged_in()
PDMvalidate_user_access()
PDUvalidate_catalog()
PDMcheck_partnum()
PDMget_existing_data()
PDUverify_aclname()
PDUverify_storage_name()
PDUformat_buffer()
PDUdelete_files_from_buffer()
PDMmodify_part()
PDMcancel_modify_part()

Assumptions



1.   The pdmoLoadFileStructure must be called before calling
     pdmoDeleteFiles.


2.   The user must call pdmoFreeFileStructure to free the file
     structure.


3.   The PDMexec userid has been loaded during log-in.

:pdmoDeletePart:

This API deletes a part definition in the database.

pdmoDeletePart(
               cpr_catalog,
               cpr_partnum,
               cpr_revision
              )

Argument       Data Type    I/O   Description

*cpr_catalog   char          I    Catalog name.
*cpr_partnum   char          I    Part number.
*cpr_revision  char          I    Revision.

Input Restrictions


[]   cpr_catalog


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_partnum


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_revision


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.

Example

status = pdmoDeletePart(
                        "api_catalog",
                        "api_part1",
                        "a"
                       );

Status Return

PDM_S_SUCCESS                   Successful Completion.
PDM_E_PART_OCCURS_IN_ASSEMBLY   Part Occurs In Assembly.
PDM_E_CAT_FIELD_BLANK           Catalog Field Blank.
PDM_E_PART_FIELD_BLANK          Part Field Blank.
PDM_E_REV_FIELD_BLANK           Revision Field Blank.
PDM_E_CAT_NOT_FOUND             Catalog Not Found.
PDM_I_TABLE_LOCKED              Table Locked.
PDM_E_USER_NOT_LOGGED_IN        User Not Logged In.

External Functions

PDUcheck_if_logged_in()
PDUmessage_trans()
PDUvalidate_catalog()
PDMcheck_partnum()
PDMrdelete_part()
PDMset_to_state()

Assumptions

The PDMexec userid has been loaded during login.
:pdmoDeletePartOccurrence:

This macro deletes a graphic part, non-graphic part, and any
parametric part. It does not delete the part definition from the
database.

long pdmoDeletePartOccurrence (
                               spr_mod_env,
                               spr_part
                              )

Argument              Data Type       I/O    Description


*struct GRmd_env      spr_mod_env      I     Module environment to delete part
                                             occurrence.
*struct GRid          spr_part         I     Object ID of part occurrence
                                             to be deleted.

Status Returns

PDM_E_BAD_OBJID                 Bad Object Id.
PDM_E_NULL_OBJID                Null Object Id.
PDM_E_DELETE_PARAMETRIC_PART    Delete Parametric Part.
PDM_E_DETACH_MACRO_LIB          Detach Macro Library.
PDM_E_DELETE_GRPART             Delete GRPart.
PDM_E_DETACH_PART               Detach Part.
PDM_E_INVALID_PART_POINTER      Invalid Part Pointer.

External Functions

PDUis_parametric_part()
co$part_get_attr()
di$give_pathname()
PDUget_GRpart_ids()
PDMdetach_part()
PDUremove_assembly()
delete_prpart()
PDMdetach_macro_library()
delete_maclib_entry()
dp$display()

Assumptions



1.   The user must be logged into PDM.


2.   EMS must be running and if the delete part occurrence is
     suppose to be invisible, the file must be opened invisibly
     prior to calling pdmoDeletePartOccurrence.

:pdmoFreeAttrStructure:

This API frees an attribute structure that has been used to add
or change the attribute values associated with a part.

pdmoFreeAttrStructure(spm_attrs)

Argument     Data Type         I/O   Description

*spm_attrs   struct             I    ????.
             attrs_info

Input Restrictions


[]   spm_attrs


     -  Attribute is required.


     -  pdmoLoadAttrStructure must be called before calling
        pdmoFreeAttrStructure.

Example

status = pdmoFreeAttrStructure(&attr_list)

Structures

struct attribute_info
    {
        char   cpr_attr_name[IK_ATTR_MAX];
        char   cpr_datatype[IK_DATATYPE_MAX];
        char   cpr_synonym[IK_SYNONYM_MAX];
        char   cpr_value[IK_VALUE_MAX];
        struct attribute_info *spm_next;
    };


Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_NULL_LIST               ????.
PDM_E_USER_NOT_LOGGED_IN      PDM User Not Logged In.

Assumptions

The pdmoLoadAttrStructure macro must be called to allocate
the attribute_info structure before pdmoFreeAttrStructure is
called.
:pdmoFreeChangeStructure:

This API frees a file structure that has been used to change
the file information associated with a part.

pdmoFreeChangeStructure(spm_file_list)

Argument          Data Type         I/O   Description

**spm_file_list   struct             I    Linked list of
                  chg_file_info           structures.

Input Restrictions


[]   spm_file_list


     -  Attribute is required.


     -  pdmoLoadFileStructure must be called before calling
        pdmlFreeFileStructure.

Example

status = pdmoFreeChangeStructure(&chg_file_list);

Structures

struct chg_file_info
    {
      char    cpr_file_desc[IK_FILEDESC_MAX];
      char    cpr_chg_file_desc[IK_FILEDESC_MAX];
      char    cpr_local_fn[IK_FILENAME_MAX];
      char    cpr_chg_local_fn[IK_FILENAME_MAX];
      char    cpr_storage_fn[IK_FILENAME_MAX];
      char    cpr_chg_storage_fn[IK_FILENAME_MAX];
      char    cpr_file_type[IK_FILETYPE_MAX];
      char    cpr_chg_file_type[IK_FILETYPE_MAX];
      int     ir_mode;
      struct  chg_file_info  *spm_next;
    };

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_USER_LOGGED_IN          PDM User Not Logged In.
PDM_E_NULL_LIST               Null List.

Assumptions

The pdmoLoadChangeStructure macro must be called to
allocate the chg_file_info structure before
pdmoFreeChangeStructure is called.
:pdmoFreeFileStructure:

This API frees a file structure that has been used to add or
change the file information associated with a part.

pdmoFreeFileStructure(spm_file_list)

Argument          Data Type    I/O   Description

**spm_file_list   struct        I    Linked list of
                  file_info          structures.

Input Restrictions


[]   spm_file_list Attribute is required.


     -  pdmoLoadFileStructure must be called before calling
        pdmoFreeFileStructure.

Example

status = pdmoFreeFileStructure(&file_list);

Structures

struct file_info
     {
       char    cpr_file_desc[IK_FILEDESC_MAX];
       char    cpr_local_fn[IK_FILENAME_MAX];
       char    cpr_storage_fn[IK_FILENAME_MAX];
       char    cpr_file_type[IK_FILETYPE_MAX];
       int     ir_mode;
       struct  file_info  *spm_next;
     };

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_USER_LOGGED_IN          PDM User Not Logged In.
PDM_E_NULL_LIST               ???????.

Assumptions

The pdmoLoadFileStructure macro must be called to allocate
the file_info structure before pdmoFreeFileStructure is called.
:pdmoFreeStorageArea:

This macro frees the memory allocated for the
pdmStorageArea Structure.  The integer variables in the
structure are set to 0 and char variables in the structure are
set to null.

pdmoFreeStorageArea(spm_userinfo)
struct pdmStorageArea **spm_userinfo

Argument       Data Type            I/O    Description

spm_userinfo   struct                I     Address of
               pdmStorageArea              pointer to pdmStorageArea
                                           structure.

Status Returns

PDM_S_SUCCESS     Successful Completion.

:pdmoFreeTransStructure:

This API frees the transisition structure that contains a list of
possible transitions for a part.

pdmoFreeTransStructure(spm_trans)

Argument     Data Type          I/O    Description

*spm_trans   struct              I     Linked list of
             part_transition           structures.

Input Restrictions


[]   spm_trans


     -  Attribute is required.


     -  pdmoGetTransitions must be called before calling
        pdmoFreeTransStructure.

Example

status = pdmoFreeTransStructure(&trans_list);

Structure

struct part_transition
       {
          char   cpr_statename[IK_STATENAME_MAX];
          char   cpr_transition[IK_TRANSNAME_MAX];
          int    ir_stateno;
          struct part_transition *spm_next;
        };

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_NULL_LIST               ?????.
PDM_E_USER_NOT_LOGGED_IN      PDM User Not Logged In.

Assumptions

The pdmoGetTransitions macro must be called to allocate the
part_transition structure before pdmoFreeTransStructure is
called.
:pdmoGetObjidGivenUsageid:

The delete part occurrence macro requires the objid as a
parameter.  This macro will return the part's objid given the
usageid of the part.

long pdmoGetObjidGivenUsageid(
                              spr_mod_env,
                              cpr_usageid,
                              spw_part
                             )

Argument     Data Type             I/O    Description
             

spr_mod_env   *struct GRmd_env      I     Module environment to delete part
                                          occurrence.
cpr_usageid   *char                 I     Usageid of part.
spw_part      *struct GRid          O     Object ID of part to be deleted.

Status Returns

PDM_E_NULL_USAGEID
PDM_E_USAGEID_NOT_FOUND
PDM_S_SUCCESS               Successful Completion.

External Functions

PDUget_all_GRpart_ids()
PDUget_all_parametric_ids()

Assumptions

EMS must be running and if the usageid of the part is in an
invisible object space, the file must be opened invisibly prior
to calling pdmoGetObjidGivenUsageid.
:pdmOGetPartOccurance:

This function gets instances of this part in the database.

pdmOGetPartOccurance ( *cpr_Partnum,
                       *spw_catalog_struct,
                       *ipw_status);

Argument       Data Type       I/O    Description
             
*cpr_partnum   char             I     Part Number.
*ipw_status    char             O     Status Return.

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_PART_NOT_FOUND          Part Number Not Found.
PDM_E_CATALOG_NOT_FOUND       Catalog Not Found.
PDM_E_NO_SUCH_TABLE           No Such Table.
PDM_E_NO_SUCH_ATTRIBUTE       No Such Attribute.
PDM_E_REQ_COLUMN_NOT_FOUND    Column Not Found.

Assumptions

Catalog exists in the database.
:pdmoLoadAttrStructure:

This macro loads attribute values into a structure and adds
the structure as an entry in a link list of structures.  The link
list is then passed to the pdmoAddPart function.

pdmoLoadAttrStructure(
                      cpr_attr_name,
                      cpr_datatype,
                      cpr_synonym,
                      cpr_value,
                      spm_attrs
                     )

Argument          Data Type         I/O    Description
             
*cpr_attr_name    char               I     Attribute name.
*cpr_datatype     char               I     Attribute datatype.
*cpr_synonym      char               I     Attribute synonym.
*cpr_value        char               I     Attribute value.
**spm_attrs       struct attrs_info  I

Input Restrictions


[]   cpr_attr_name


     -  Attribute is required.


     -  Must not exceed 20 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Must not be a database reserved word.



[]   cpr_datatype


     -  Attribute is required.


     -  Must be a valid datatype: real, integer, char(xx), decimal,
        smallint.



[]   cpr_synonym


     -  Attribute is required.


     -  Must not exceed 40 characters.



[]   cpr_value


     -  Attribute is required.


     -  Must be compatible with the specified datatype.

Example

status = pdmLoadAttrStructure(
                              "diameter",
                              "integer"
                              "Diameter",
                              "2",
                              &attr_list
                             );

Structures

struct attribute_info
  {
   char cpr_attr_name[IK_ATTR_MAX];
   char cpr_datatype[IK_DATATYPE_MAX];
   char cpr_synonym[IK_SYNONYM_MAX];
   char cpr_value[IK_VALUE_MAX];
   struct attribute_info *spm_next;
  };

Status Returns

PDM_S_SUCCESS               Successful Completion.
PDM_E_USER_LOGGED_IN
PDM_E_INVALID_DATATYPE      Attribute datatype is invalid.
PDM_E_INVALID_ATTR          Attribute is invalid.
PDM_E_RESERVED_ATTR         Attribute is reserved word.
PDM_E_NOT_WRITABLE
PDM_I_ATTR_NOT_FOUND        Attribute does not exist.
PDM_E_NO_DATA

External Functions

  PDUload_attr_structure()

Assumptions



1.   The return structure, spm_attrs, should be initialized to
     NULL the first time pdmoLoadAttrStructure is called.


2.   The pdmoFreeAttrStructure API should be called to free up
     this structure when the user is through with it.

:pdmoLoadChangeStructure:

This macro loads file data into a structure and places the
structure as an entry in a link list of structures.  The link list is
then passed to the pdmoChangePart function.

pdmoLoadChangeStructure(
                        cpr_file_desc,
                        cpr_chg_file_desc,
                        cpr_local_fn,
                        cpr_chg_local_fn,
                        cpr_storage_fn,
                        cpr_chg_storage_fn,
                        cpr_file_type,
                        cpr_chg_file_type,
                        ir_mode,
                        spm_file_list
                       )

Argument              Data Type       I/O    Description

*cpr_file_desc        char             I     Existing file description.
*cpr_chg_file_desc    char             I     New file description.
*cpr_local_fn         char             I     Existing file name.
*cpr_chg_local_fn     char             I     New file name.
*cpr_storage_fn       char             I     Existing storage file name.
*cpr_chg_storage_fn   char             I     New storage file name.
*cpr_file_type        char             I     Existing filetype.
*cpr_chg_file_type    char             I     New filetype.
ir_mode               int              I
**spm_file_list       struct           I
                      chg_file_info

Input Restrictions


[]   cpr_file_desc


     -  Attribute is optional.


     -  Must not exceed 40 characters.



[]   cpr_local_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   cpr_storage_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Filename must not already exist in check in storage area.



[]   cpr_file_type


     -  Attribute is optional.


     -  May not be M or m.


     -  Must not exceed 5 characters


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   ir_mode


     -  Attribute is required.


     -  ADD = 1, DELETE = 3.

Example

status = pdmoLoadChangeStructure(
                                 "old_filedesc",
                                 "new_filedesc",
                                 "old_local_fn",
                                 "new_local_fn",
                                 "old_storage_fn",
                                 "new_storage_fn",
                                 "old_filetype",
                                 "new_filetype",
                                 CHANGE,
                                 &change_file_list
                                );

Structures

struct chg_file_info
  {
  char cpr_file_desc[IK_FILEDESC_MAX];
  char cpr_chg_file_desc[IK_FILEDESC_MAX];
  char cpr_local_fn[IK_FILENAME_MAX];
  char cpr_chg_local_fn[IK_FILENAME_MAX];
  char cpr_storage_fn[IK_FILENAME_MAX];
  char cpr_chg_storage_fn[IK_FILENAME_MAX];
  char cpr_file_type[IK_FILETYPE_MAX];
  char cpr_chg_file_type[IK_FILETYPE_MAX];
  int  ir_mode;
  struct chg_file_info  *spm_next;
  };

Status Returns

PDM_S_SUCCESS                   Successful Completion.
PDM_E_FILE_DESC_TOO_LONG        File description is too long.
PDM_E_FILETYPE_TOO_LONG         File type is too long.
PDM_E_STG_FN_TOO_LONG           Storage filename is too long.
PDM_E_INVALID_CHAR_IN_LOCFN     Local filename contains invalid character.
PDM_E_INVALID_CHAR_IN_STGFN     Storage filename contains invalid characters.
PDM_E_INVALID_CHAR_IN_FILETYPE  Filetype contains invalid characters.
PDM_E_IDENTIFIER_TOO_LONG       Identifier is too long.
PDM_E_CI_FILENAME_EXISTS        Checkin filename already exists.
PDM_E_STG_FN_NOT_UNIQUE         Storage filename already exists.
PDM_E_USER_NOT_LOGGED_IN        User must log in.
PDM_E_NO_DATA
PDM_E_REQUIRED_DATA

External Functions

  PDUload_change_structure()

Assumptions



1.   The return structure, spm_file_list, should be initialized to
     NULL the first time pdmoLoadChangeStructure is called.


2.   Although all of the fields are optional, at least one field
     must have data, or the program will be exited.


3.   The pdmoFreeChangeStructure macro should be called to
     free up this structure when the user is through with it.

:pdmoLoadFileStructure:

This macro loads file data into a structure and places the
structure as an entry in a link list of structures.  The link list is
then passed to the pdmoAddPart or pdmoChangePart macro.

pdmoLoadFileStructure(
                      cpr_file_desc,
                      cpr_local_fn,
                      cpr_storage_fn,
                      cpr_file_type,
                      ir_mode,
                      spm_file_list
                     )

Argument           Data Type        I/O    Description

*cpr_file_desc     char              I     File description.
*cpr_local_fn      char              I     Local filename.
*cpr_storage_fn    char              I     Storage filename.
*cpr_file_type     char              I     File type.
ir_mode            int               I
**spdm_file_list   struct            I
                   file_info

Input Restrictions


[]   cpr_file_desc


     -  Attribute is optional.


     -  Must not exceed 40 characters.



[]   cpr_local_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   cpr_storage_fn


     -  Attribute is optional.


     -  Must be unique to for the part being added.


     -  Must not exceed 14 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.


     -  Filename must not already exist in check in storage area.



[]   cpr_file_type


     -  Attribute is optional.


     -  May not be "M" or "m".


     -  Must not exceed 5 characters.


     -  / # = ! * \ ( ) { } [ ] <  > & ? $ @ + - : | are invalid
        characters.



[]   ir_mode


     -  Attribute is required.


     -  ADD = 1, DELETE = 3

Example

status = pdmoLoadFileStructure(
                               "filedesc",
                               "local_fn",
                               "storage_fn",
                               "filetype",
                               DELETE,
                               &delete_list
                              );

Structures

struct file_info
  {
  char cpr_file_desc[IK_FILEDESC_MAX];
  char cpr_local_fn[IK_FILENAME_MAX];
  char cpr_storage_fn[IK_FILENAME_MAX];
  char cpr_file_type[IK_FILETYPE_MAX];
  int  ir_mode;
  struct file_info  *spm_next;
  };

Status Returns

PDM_S_SUCCESS                    Successful Completion.
PDM_E_FILE_DESC_TOO_LONG         File description is too long.
PDM_E_FILETYPE_TOO_LONG          File type is too long.
PDM_E_STG_FN_TOO_LONG            Storage filename is too long.
PDM_E_INVALID_CHAR_IN_LOCFN      Local filename contains invalid character.
PDM_E_INVALID_CHAR_IN_STGFN      Storage filename contains invalid character.
PDM_E_INVALID_CHAR_IN_FILETYPE   Filetype contains invalid character.
PDM_E_IDENTIFIER_TOO_LONG        Identifier is too long.
PDM_E_CI_FILENAME_EXISTS         Checkin filename already exists.
PDM_E_STG_FN_NOT_UNIQUE          Storage filename already exists.
PDM_E_USER_NOT_LOGGED_IN         User must log in.
PDM_E_NO_DATA
PDM_E_REQUIRED_DATA

External Functions

PDUload_file_structure()

Assumptions



1.   The return structure, spm_file_list, should be initialized to
     NULL the first time pdmoLoadFileStructure is called.


2.   Although all of the fields are optional, at least one field
     must have data, or the program will be exited.


3.   The pdmoFreeFileStructure macro should be called to free
     up this structure when the user is through with it.

:pdmoLoadStorageArea:

This macro loads the Storage Area Struct pdmStorageArea.
This function allocates memory for the structure and load the
structure with the input data. The outputs from the structure
will be initialized.

pdmoLoadStorageArea(
                    cpr_storage_node,
                    cpr_storage_user,
                    cpr_storage_passwd,
                    cpr_storage_path,
                    **spm_userinfo
                   )

Argument               Data Type       I/O    Description

*cpr_storage_node      char             I     Storage area node name.
*cpr_storage_user      char             I     Storage area user name.
*cpr_storage_passwd    char             I     Storage area password.
*cpr_storage_path      char             I     Storage area path.
**spm_userinfo         struct          I/O    Structure that will be loaded
                       pdmStorageArea         with the input data and the
                                              output fields will be
                                              initialized.

Input Restrictions


[]   cpr_storage_node


     -  Attribute is required.


     -  Must not exceed 30 characters.



[]   cpr_storage_user


     -  Attribute is required.


     -  Must not exceed 14 characters.



[]   cpr_storage_passwd


     -  Attribute is optional.


     -  Must not exceed 14 characters



[]   cpr_storage_path


     -  Attribute is required.


     -  Must not exceed 80 characters.

Structures

struct pdmStorageArea
{
 char node_name[IK_NODE_MAX]
 char user_name[IK_USER_MAX]
 char user_passwd[IK_PASSWD_MAX]
 char path[IK_PATH_MAX]
 char saname[IK_SANAME_MAX]
 int  sanum
 int  userid
}

Argument                   Data Type        I/O    Description
                         

node_name[IK_NODE_MAX]     char              O     Workstation node name
                                                   for storage area.
user_name[IK_USER_MAX]     char              O     Workstation user name
                                                   for storage area.
user_passwd[IK_PASSWD_MAX] char              O     Workstation password.
path[IK_PATH_MAX]          char              O     Storage area path on
                                                   workstation.
saname[IK_SANAME_MAX]      char              O     Storage area name given
                                                   by the database.
sanum                      int               O     Storage area number.
userid                     int               O     User id assigned by
                                                   database.

Output Restrictions


[]   node_name


     -  Attribute is required.


     -  Must not exceed 30 characters



[]   user_name


     -  Attribute is required.


     -  Must not exceed 14 characters



[]   user_passwd


     -  Attribute is required.


     -  Must not exceed 14 characters



[]   path


     -  Attribute is required.


     -  Must not exceed 80 characters



[]   saname


     -  Must not exceed 14 characters

Status Returns

PDM_S_SUCCESS
PDM_E_COULD_NOT_MALLOC

:pdmoLogin:

This macro lets a user log in to an NFM environment for
database manipulation.

long pdmoLogin(
               cpr_env,
               cpr_pdmuser,
               cpr_pdmpasswd,
               cpr_msgpath,
               spm_userinfo
              )

Argument         Data Type         I/O    Description

*cpr_env         char               I     Environment name.
*cpr_pdmuser     char               I     I/PDM user name.
*cpr_pdmpasswd   char               I     User name password.
*cpr_msgpath     char               I     Device or file name for message
                                          output.
**spm_userinfo   struct            I/O    Address of pointer to 
                 pdmWorkingArea           pdmWorkingArea structure.

Input Restrictions


[]   cpr_env


     -  Attribute is required.


     -  Must not exceed 9 characters.



[]   cpr_pdmuser


     -  Attribute is required.


     -  Must not exceed 14 characters.



[]   cpr_pdmpasswd


     -  Attribute is required.


     -  Must not exceed 14 characters.



[]   cpr_msgpath


     -  Attribute is optional.

Structures

  struct pdmWorkingArea
  {
   char node_name[IK_NODE_MAX]
   char user_name[IK_USER_MAX]
   char user_passwd[IK_PASSWD_MAX]
   char path[IK_PATH_MAX]
   char saname[IK_SANAME_MAX]
   int  sanum
   int  userid
  }

Argument                    Data Type       I/O    Description
                         
node_name[IK_NODE_MAX]      char             I     Workstation node name
                                                   for storage area.
user_name[IK_USER_MAX]      char             I     Workstation user name.
user_passwd[IK_PASSWD_MAX]  char             I     Workstation password.
path[IK_PATH_MAX]           char             I     Storage area path on
                                                   workstation.
saname[IK_SANAME_MAX]       char             O     Storage area name.
sanum                       int              O     Storage area number.
userid                      int              O     User id assigned by
                                                   database.

Restrictions


[]   node_name


     -  Attribute is required.


     -  Must not exceed 30 characters



[]   user_name


     -  Attribute is required.


     -  Must not exceed 14 characters



[]   user_passwd


     -  Attribute is optional.


     -  Must not exceed 14 characters



[]   path


     -  Attribute is required.


     -  Must not exceed 80 characters



[]   saname


     -  Must not exceed 14 characters

Status Returns

PDM_S_SUCCESS               Successful Completion.
PDM_E_INITIALIZED
PDM_E_BAD_PROTOCOL
PDM_E_BAD_USERNAME
PDM_E_BAD_ENV
PDM_E_CLH
PDM_E_USER_PASSWD
PDM_E_LOCATE_SCHEMA_FILE
PDM_E_INVALID_ENV
PDM_E_LIST_ENVS
PDM_E_WRKST_NODE

External Functions

NFMls_nodes()
PDUget_envs()
PDUload_exec_structure()
PDMlogin()
PDMverify_init()
PDUfill_in_string()
PDUuser_init()
PDUstorage_init()
PDUpdm_exec_init()
PDUget_sun_nodename()

Assumptions

Only one schema can be active at a time. If the user has
already activated a schema then pdmoLogin will deactivate
the existing schema to allow connection to the new schema
or error if trying to connect to the same schema. The user is
responsible for freeing the pointer to the pdmWorkingArea
structure. The local working area will be the location of the
check out storage area.
:pdmOLogout:

This macro logs a user out of an NFM environment and
diconnects the user from the underlying database.

pdmOLogout()

Status Returns

PDM_S_SUCCESS               Successful Completion.

External Functions

PDUload_exec_structure()
PDMterminate()

Assumptions

Logout is called only after a successfull login has occurred.

:pdmoModifyAssembly:

This macro modifies the assembly stucture of a part.

long pdmoModifyAssembly (
                        char *cpr_catalog,
                        char *cpr_partnum,
                        char *cpr_revsion,
                        PDMchildren *spr_PDMadd_to_structure,
                        PDMchildren *spr_PDMdelete_from_structure
                         )

Argument        Data Type       I/O    Description

*cpr_catalog    char             I     Catalog name.
*cpr_partnum    char             I     Part number.
*cpr_revision   char             I     Part revision.
*spr_PDMadd_    PDMchildren      I     Children information that needs
to_structure                           to be added to the assembly.

{
int     im_n_citno;      /* System defined - Leave it  - N */
int     im_n_pcatalogno; /* System defined - Leave it  - N */
int     im_n_pitemno;    /* System defined - Leave it  - N*/
int     im_n_ccatalogno; /* System defined - Leave it  - N*/
int     im_n_citemno;    /* System defined - Leave it  - N*/
int     ir_p_level;/* Level no of the assembly-Default 1 - OPTIONAL*/
cha     caw_n_setindicator[2]; /* System defined -Leave it -N*/
cha     caw_n_status[3];  /* System defined - Leave it  - N*/
int     im_p_pchildno;    /* System defined - Leave it  - N*/
int     ir_p_childno;    /* Child no of the like parts in the
                                    same level, if multiple parts
                                    are defined without this input
                                   system will assign it - OPTIONAL*/
char    car_n_catalogname[21]; /*Catalogname of the child - INPUT */
char    *cpr_n_itemname;      /*Partnumber of the child   - INPUT */
char    *cpr_n_itemrev;       /*Revision   of the child   - INPUT */
char    *cpr_n_itemdesc;      /*Description of the child  - INPUT */
char    car_p_attached[2];/*Display flag of the child - Leave it -N */
double  dr_p_quantity;   /* Quantity of the child - Default 1
OPTIONAL*/
char    car_p_usgaeid[25]; /* Usage ID - OPTIONAL */
char    car_n_cofilename[14]; /*Filename of the part - OPTIONAL */
int     ir_p_tagno;  /* Tagno - OPTIONAL - Default system generates */
char    car_p_alttagno;/* ALttagno -OPTIONAL-Default system generates
*/
spr_children      *next;/* NEXT child pointer of linked list or NULL
*/
        }* spr_PDMchildren;

pdmoLoadChildStructure can be used to load the structure.
PDMchildren *spr_PDMdelete_from_structure - children info which needs to be deleted from
the assembly.

        {
        int     im_n_citno;      /* System defined - Leave it  - N */
        int     im_n_pcatalogno; /* System defined - Leave it  - N */
        int     im_n_pitemno;    /* System defined - Leave it  - N*/
        int     im_n_ccatalogno; /* System defined - Leave it  - N*/
        int     im_n_citemno;    /* System defined - Leave it  - N*/
        int     ir_p_level;/* Level no of the assembly-Default 1 - OPTIONAL*/
        cha     caw_n_setindicator[2]; /* System defined -Leave it -N*/
        cha     caw_n_status[3];  /* System defined - Leave it  - N*/
        int     im_p_pchildno;    /* System defined - Leave it  - N*/
        int     ir_p_childno;    /* Child no of the like parts in the
                                    same level, if multiple parts
                                    are defined without this input
                                   system will assign it - OPTIONAL*/
        char    car_n_catalogname[21]; /*Catalogname of the child - INPUT */
        char    *cpr_n_itemname;      /*Partnumber of the child   - INPUT */
        char    *cpr_n_itemrev;       /*Revision   of the child   - INPUT */
        char    *cpr_n_itemdesc;      /*Description of the child  - INPUT */
        char    car_p_attached[2];/*Display flag of the child - Leave it -N */
        double  dr_p_quantity;   /* Quantity of the child - Default 1 OPTIONAL*/
        char    car_p_usgaeid[25]; /* Usage ID - OPTIONAL */
        char    car_n_cofilename[14]; /*Filename of the part - OPTIONAL */
        int     ir_p_tagno;  /* Tagno - OPTIONAL - Default system generates */
        char    car_p_alttagno;/* ALttagno -OPTIONAL-Default system generates */
        spr_children      *next;/* NEXT child pointer of linked list or NULL */
        }* spr_PDMchildren;

pdmoLoadChildStructure can be used to load the structure.  

Input Restrictions


[]   cpr_n_catalogname


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_n_itemname


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_n_itemrev


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   ir_p_tagno


     -  Cannot be zero or negative.



[]   ir_p_quantity


     -  Cannot be zero or negative.

Example

#include                <stdio.h>
#include                "PDUerror.h"
#include                "MEMstruct.h"
#include                "MEMerrordef.h"
#include                "NFMerrordef.h"
#include                "SQLerrordef.h"
#include                "PDUris_incl.h"
#include                "PDMproto.h"
#include                "PDUpdmrpro.h"

static  long status; 
static  char s[1024]; 
extern  int PDMdebug_on; 
extern  char PDM_DEBUG_FILE[]; 
extern  PDMexec_ptr     PDMexec;

Main Function 

Status Returns

PDM_S_SUCCESS                  Succesful Completion.
PDM_E_CATALOG_NOT_FOUND        A given catalog is not there in the database.
PDM_E_PART_NOT_FOUND           A given part/rev is not there in the database.
PDM_E_CAT_FIELD_BLANK          Catalog field empty.
PDM_E_PART_FIELD_BLANK         Part number field empty.
PDM_E_REV_FIELD_BLANK          Revison field empty.
PDM_E_INVALID_PART_TYPE        Invalid part type.
PDM_I_TABLE_LOCKED             Concurrent access, the table is locked.
PDM_E_LOCK_CIT                 CIT is locked, Please try later.
PDM_E_SQL_STMT                 Invalid data.

Assumptions



1.   The part is checked in/Never checked in.


2.   Parts are know to the database, except the view parts.


3.   Parts are yet to be positioned.


4.   Parts are not cyclic, except for the background
     attachement.


5.   The user has the access the change the defintion of the
     part.


6.   The part is not flagged for delete, restore, backup, archive.


7.   The part is backuped, or archived.


8.   You can't change parametric assemblies.


9.   You can't change nth level structure.


10.  The user must be logged into PDM database.

Functions

PDMsdefine_assembly_structure
PDMquery_catalog_partnos
MEM functions
PDMexpand_copy_buffer
PDMquery_assembly_ind
PDMload_partnos
PDMload_parentnos
PDMcheck_cycles
PDMstop_transaction
SQLstmt
PDMdron_setindicator
PDMload_set_members
PDMset_n_setindicator
PDMstart_transaction

Reused functions

PDMquery_catalog_partnos  - used everywhere
MEM functions             - used everywhere
PDMexpand_copy_buffer     - Data defintion functionality
PDMquery_assembly_ind     - used everywhere
PDMload_partnos           - List local files
PDMstop_transaction       - used everywhere
SQLstmt                   - used everywhere
PDMdron_setindicator      - Checkin
PDMload_set_members       - Checkin
PDMset_n_setindicator    - Checkin
PDMstart_transaction     - used everywhere

:pdmoMoveToNextState:

This API moves a part to the next or previous state in the
user's workflow.

pdmoMoveToNextState(cpr_catalog,
                    cpr_partnum,
                    cpr_revision,
                    ir_statenum,
                    cpr_statename
                   )

Argument        Data Type       I/O    Description
               
*cpr_catalog     char            I     Catalog name.
*cpr_partnum     char            I     Part number.
*cpr_revision    char            I     Part revision.
ir_statenum      int             I     State number.
*cpr_statename   char            I     State name.

Input Restrictions


[]   cpr_catalog


     -  Attribute is required.


     -  Must be 16 characters or less.


     -  Must already exist.



[]   cpr_partnum


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   cpr_revision


     -  Attribute is required.


     -  ! * ? , : are invalid characters.


     -  Must not exceed the number of characters specified at
        catalog creation time.



[]   ir_statenum


     -  Attribute is required.


     -  Must be the number that represents the workflow state
        to which the part is being moved.



[]   cpr_statename


     -  Attribute is required.


     -  Must be a valid workflow state.

Example

status = pdmoMoveToNextState(
                             "api_catalog",
                             "api_partnum",
                             "api_revision",
                             14,
                             "design complete"
                            );

Status Returns

PDM_S_SUCCESS               Successful Completion.
PDM_E_CAT_FIELD_BLANK       User must enter catalog name.
PDM_E_PART_FIELD_BLANK      User must enter part number.
PDM_E_REV_FIELD_BLANK       User must enter part revision.
PDM_E_CAT_NOT_FOUND         Catalog does not exist.
PDM_I_TABLE_LOCKED
PDM_E_USER_NOT_LOGGED_IN    User must log in.
PDM_E_INVALID_STATE

External Functions

PDUcheck_if_logged_in()
PDUmessage_trans()
PDUvalidate_catalog()
PDMcheck_partnum()
PDMget_trans()
PDUmark_trans_in_buffer()
PDMrmake_transition()

Assumptions



1.   The user supplies the state that the part should be moved
     to.  If the user does not know the possible states of
     transition, the pdmoGetTransitions API can be called to
     retrieve a list of transitions.


2.   The PDMexec userid has been loaded during log-in.

:pdmoPlacePart:

This macro places a graphic part, non-graphic part, and any
parametric part.  The macro can also "place but not position"
any PDM part.

pdmoPlacePart(
               spr_mod_env,
               spw_part,
               cpr_catalogname,
               cpr_itemname,
               cpr_itemrev
               cpr_cofilename,
               cpr_usageid,
               cpr_viewname,
               cpr_quantity,
               cpr_explode,
               cpr_attach,
               cpr_alttagno,
               cpr_incstr,
               cpr_incbom,
               ir_dyn_count,
               cpr_dyn_names,
               cpr_dyn_values,
               ir_dynloc_count,
               cpr_dynloc_names,
               spr_dynloc_id,
               dar_origin,
               dar_x_point,
               dar_y_point,
               spr_position_cs
              )

Argument            Data Type           I/O    Description
                   

spr_mod_env        *struct GRmd_env      I     Module enviroment to
                                               place part occurrence.
spw_part           *struct GRid          O     Object ID of GRid placed part.
cpr_catalogname    *char                 I     Catalog name.
cpr_itemname       *char                 I     Part number.
cpr_itemrev        *char                 I     Part revision.
cpr_cofilename     *char                 I     File name.
cpr_usageid        *char                 I     Part usage id.
cpr_viewname       *char                 I     Graphic view name.
cpr_quantity       double                I     Part quantity.
cpr_explode        *char                 I     Explode in BOM (Y or N).
cpr_attach         *char                 I     Attach file (Y or N).
cpr_alttagno       *char                 I     Unique alternate tag number.
cpr_incstr         *char                 I     Background part (Y or N).
cpr_incbom         *char                 I     Include in BOM (Y or N).
ir_dyn_count       int                   I     Dynamic attribute count.
cpr_dyn_names      **char                I     Dynamic attribute name array.
cpr_dyn_values     **char                I     Dynamic attribute value array.
ir_dynloc_count    int                   I     Dynamic locate input count.
cpr_dynloc_names   **char                I     Dynamic locate input names.
spr_dynloc_id      *struct GRid          I     Dynamic locate input object ID.
dar_origin         double[3]             I     Position by three point origin 
                                               point.
dar_x_point        double[3]             I     Position by three point x-axis 
                                               point.
dar_y_point        double[3]             I     Position by three point y-axis 
                                               point.
spr_position_cs    *struct GRid          I     Position by coordinate system.

Status Returns

PDM_E_CAT_NOT_FOUND         Catalog does not exist.
PDM_E_PART_NOT_FOUND        Part does not exist.
PDM_E_PARTREV_NOT_FOUND     Part revision does not exist.
PDM_E_BAD_DYNLOC
PDM_E_BAD_DYNATTR
PDM_S_SUCCESS               Successful Completion
PDM_E_DYN_TRIP
PDM_E_DYN_LOC_TRIP
PDM_E_BAD_DYN_LOC_ERROR
PDM_E_DUPLICATE_USAGEID
PDM_E_LENGTH_USAGEID
PDM_E_VIEWNAME_NOT_EXIST
PDM_E_INVALID VALUE
PDM_E_BAD_POSITION
PDM_E_DUP_ALTTAGNO

External Functions

PDUvalid_catalog()
PDUcheck_partnum()
PDUget_default_usageid()
PDUvalidate_quantity()
PDUis_alt_tag_unique()
PDUget_parttype()
PDUis_cyclic_placement()
PDUvalid_filename()
PDUcreate_GRpart()
PDUadd_assy_struct_from_buffer()
PDUgenerate_coord_orientation()
PDUcreate_part_pointer()
co$part_put_attr()
PDMget_part_attach_info()
co$part_get_attr()
PDUget_all_ref_file_names()
PDUload_local_file_buffer()
PDMcopy_attach()
PDUverify_file()
PDUattach_ref_to_GRpart()
PDUmodify_exp()
PDMquery_dynamic_attributes()
SetDynAttrs()
InstanceMacro()

Assumptions



1.   The user must be logged into PDM.


2.   EMS must be running and if the place part is suppose to be
     invisible, the file must be opened invisibly prior to calling
     pdmoPlacePart.

:pdmOReportAssembly:

This function creates exploded summary bom report.

pdmOReportAssembly ( *cpr_Catalog,
                     *cpr_Partnum,
                     *cpr_Revision,
                     *cpr_SaName,
                     ir_MaxLevel,
                     *cpr_FileName,
                     *cpr_TemplName,
                     *cpr_RisTmplName,
                     *cpw_ReportFileName)

Argument            Data Type        I/O     Description
                  

*cpr_catalog          char         I      Catalog Name.
*cpr_partnum          char         I      Part Number.
*cpr_revision         char         I      Part Revision.
*cpr_SaName           char         I      Storage Area Name.
ir_MaxLevel           char         I      Maximum Level.
*cpr_FileName         char         I      Filename.
*cpr_TemplName        char         I      Template Name.
*cpr_RisTmplName      char         I      RIS Template Name.
*cpw_ReportFileName   char        I/O     Report Filename.

Status Return

PDM_S_SUCCESS                 Successful Completion.
PDM_E_DROP_BOM_TABLE          Drop BOM Table.
PDM_E_CATALOG_NOT_FOUND       Catalog Not Found.
PDM_I_ATOMIC_PART
PDM_E_PART_NOT_ASSEMBLY       Part Is Not An Assembly.
PDM_E_PART_NOT_FOUND          Part Not Found.
PDM_E_EXPLODE_NOT_SET         Explode Not Set.
PDM_I_NO_ROWS_FOUND           No Rows Found.
PDM_E_GEN_BOM_TABLE_NAME
PDM_E_QUERY_SET_MEMBERS
PDM_E_QUERY_TEMPLATE_DEF
PDM_E_REQ_COLUMN_NOT_FOUND    Required Columns Not Found.
PDM_E_BOMREQATTR_NOT_FOUND    BOM Required Attribute Not Found.
PDM_E_ADDTO_RPS_TAB
PDM_E_COULD_NOT_MALLOC
PDM_E_BUFFER_FORMAT
PDM_E_BUILD_ARRAY
PDM_E_BUILD_BUFFER_ARRAY
PDM_E_COPY_BUFFER
PDM_E_OPEN_BUFFER
PDM_E_SQL_QUERY
PDM_E_SQL_STMT
PDM_E_WRITE_BUFFER
PDM_E_WRITE_COLUMN
PDM_E_WRITE_FORMAT
PDM_E_WRITE_ROW

Assumptions



1.   Catalog, partnum, rev and template exists in the database.


2.   Part is an assembly.

:pdmoRisQuery:

This function gives the user the ability to query the database.

pdmoRisQuery(cpr_sql_str,spm_query_info,spw_err_code)
char *cpr_sql_str
struct pdmRisQuery **spm_query_info
struct pdmRisError **spw_err_code

Argument          Data Type             I/O    Description

cpr_sql_str       char                   I
spm_query_info   struct pdmRisQuery     I/O
spw_err_code     struct pdmRusError     I/O
               

Return Status

SQL_S_SUCCESS                 Successful Completion.
SQL_E_NOT_QUERY
SQL_I_NO_ROWS_FOUND           No Rows Found.
SQL_E_DATA_TYPE               Data Type.
SQL_E_MESSAGE
SQL_E_MALLOC
SQL_E_NOT_QUERY
SQL_E_PREPARE
PDM_E_LOGIN

Assumptions



1.   The user must be logged in to an environment by using the
     pdmoLogin function.


2.   The input string sql_str is a valid sql query statement that
     is null terminated.


3.   The user is responsible for freeing the pdmRisError
     structure pointer and the pdmRisQuery structure pointer.


4.   The members of the structure are static allocation.

:pdmoRisStmt:

This function gives the user the ability to manipulate the
underlying relational database by inserting, updating or
deleting data.

pdmoRisStmt    (cpr_sql_str,spw_err_code)
*cpr_sql_str

pdmRisError **spw_err_code 

Argument        Data Type       I/O    Description
             
cpr_sql_str     char             I
spw_err_code    char             O

Structure

Struct pdmRisError { long ris_error_code char
 ris_error_string[IK_RIS_ERROR_MAX] long db_error_code char
 db_type }

ris_error_code - negative error code returned by ris
ris_error_string - sql error message corresponding to
ris_error_code db_error_code - vendor database error code
db_type - vendor database type - X informix, O oracle, I ingres

Status Return

PDM_E_SQL_STMT
PDM_E_TABLE_NOT_FOUND         Table Not Found.
PDM_S_SUCCESS                 Successful Completion.
SQL_E_MALLOC

Assumptions



1.   The user must be logged in to an environment by using the
     pdmoLogin function.


2.   The input string sql_str is a valid sql statement that is null
     terminated.


3.   The user will handle all transactions. The user is
     responsible for freeing the pointer to pdmRisError.



