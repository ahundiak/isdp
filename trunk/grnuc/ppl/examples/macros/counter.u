/************************************************************************/
/*                                                                      */
/*  Program: counter.u              Macro: ems$place_counterpart	*/
/*                                                                      */
/*  Defined in: EMSascmacros.h                                          */
/*                                                                      */
/*  Comments  : To place a hole and either counterbore or countersink	*/
/*	on end of it.  The hole must not already exist.			*/
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "ci_easy.h"
#include "go.h"
#include "griodef.h"
#include "grdpbmacros.h"
#include "dpmacros.h"
#include "lcdef.h"

#include "EMSascmacros.h"
#include "EMSasnuc.h"
#include "EMSasopts.h"

#define TYPE		0
#define SURFACE 	1
#define HOLE_DIA	2
#define HOLE_DEPTH	3
#define COUNTER_DIA	4
#define COUNTER_DEPTH	5
#define PROCESS		6
#define HOLE_ANGLE	7
#define COUNTER_ANGLE	8
#define CENTER_PT	9
#define THRU_HOLE	10

#define COUNTER_SINK	0
#define COUNTER_BORE	1

extern GRclassid OPP_GRcurve_class_id;
extern GRclassid OPP_EMSsubbs_class_id;
extern GRclassid OPP_EMSsurface_class_id;

extern	int	GRdpb_get();

main ()
{
     /* Declare variables here : */
     struct GRvg_construct    const_list;
     struct GRlc_info         surface_info;
     struct IGRdisplay        disp_buffer;
     struct GRid              res_obj;
     IGRshort                 disp_level;
     IGRboolean               assoc_placement;
     IGRushort                options;

     IGRint		      type;
     IGRint		      num_parts;
     IGRboolean		      axis_normal;
     IGRboolean		      thru_hole;

     struct GRevent	      center_pt_event;     
     struct GRevent	      bottom_angle_event;
     struct GRevent	      counter_depth_event;
     struct GRevent	      counter_dia_event;
     struct GRevent	      hole_dia_event;
     struct GRevent	      hole_depth_event;

     IGRint                   sts, num_bytes;
     IGRint		      res,state;
     IGRlong                  msg_loc, nbytes_ret;
     OM_S_CLASSLIST           elig_classes;
     GRclassid                eli_classes[3];
     IGRint		      surf_cnt;
     IGRchar		      prompt[50];
     IGRdouble		      tmp;


  /* End of variable declarations */

  message ("Place Counterpart (Bore/Sink)") ;
  state = TYPE;
  num_parts=0;
     
  while( 1 )
  {

    if ( state == TYPE )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Counter type ?(Sink=0, Bore=1)"
  	     );
      if ( tmp < 2 )
      {
        type = tmp;
        state = HOLE_DIA;
      }
      else
        state = TYPE;
    }
    if ( state == HOLE_DIA )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Hole diameter ?"
  	     );
      hole_dia_event.subtype = GRst_v_REGULAR;
      hole_dia_event.event.value = tmp; 
      state = THRU_HOLE;
    }
    if ( state == HOLE_ANGLE )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Hole bottom angle ?"
  	     );
      bottom_angle_event.subtype = GRst_v_REGULAR;
      bottom_angle_event.event.value = tmp; 
      state = COUNTER_DIA;
    }
    if ( state == HOLE_DEPTH )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Hole Depth ?"
  	     );
      hole_depth_event.subtype = GRst_v_REGULAR;
      hole_depth_event.event.value = tmp; 
      state = HOLE_ANGLE;
    }
    if ( state == THRU_HOLE )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Hole is ? (thru=0 or blind=1)"
  	     );
      if ( tmp == 0 )
      {
        thru_hole = TRUE;
        state = COUNTER_DIA;
      }else
      if ( tmp == 1 )
      {
        thru_hole = FALSE;
        state = HOLE_DEPTH;
      }
    }
    if ( state == COUNTER_DIA )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Counterpart diameter ?"
  	     );
      if ( tmp > hole_dia_event.event.value )
      {
        counter_dia_event.subtype = GRst_v_REGULAR;
        counter_dia_event.event.value = tmp; 
	if ( type == COUNTER_BORE )
          state = COUNTER_DEPTH;
	else
	  state = COUNTER_ANGLE;
        status("");
      }
      else
      {
        status ( "counterpart dia > hole dia" );
        state = COUNTER_DIA;
      }
    }
    if ( state == COUNTER_DEPTH )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Counterpart depth ?"
  	     );
      if ( thru_hole == TRUE )
      {
        counter_depth_event.subtype = GRst_v_REGULAR;
        counter_depth_event.event.value = tmp; 
        state = SURFACE;
      }else
      if ( tmp < hole_depth_event.event.value )
      {
        counter_depth_event.subtype = GRst_v_REGULAR;
        counter_depth_event.event.value = tmp; 
        state = SURFACE;
        status("");
      }
      else
      {
        status ( "counterpart depth < hole depth" );
        state = COUNTER_DEPTH;
      }
    }
    if ( state == COUNTER_ANGLE )
    {
      tmp=0;  
      ci$get( value = tmp,
	     prompt = "Counterpart Angle ?"
  	     );
      counter_depth_event.subtype = GRst_v_REGULAR;
      counter_depth_event.event.value = tmp; 
      state = SURFACE;
    }
    if ( state == CENTER_PT )
    {
      tmp=0;  
      ci$getevent( response = &res,
                   event = &center_pt_event,
                   mask = GRm_DATA,
	           prompt = "Center point of counterpart"
  		 );
      if ( res == EX_DATA )
      {
        state = PROCESS;
        num_parts=1;
      }
      else if ( res == EX_BACK_UP )
        state = SURFACE;
    }

    if ( state == SURFACE ) 
    {
      /*Get the first object */
      elig_classes.w_count = 1;
      eli_classes[0] = OPP_EMSsubbs_class_id;
      elig_classes.w_flags = OM_CLST_subclass;
      elig_classes.p_classes = eli_classes;
    
      ci$locate ( obj=&surface_info.located_obj.objid,
                lc_info=&surface_info,
	        prompt="Identify Surface",
	        acc_prompt="Accept/Reject",
                response=&res,
	        relocate_prompt="Surface not Found",
		owner_action = LC_RIGID_COMP | LC_FLEX_COMP,
                eligible_classes = &elig_classes
	      );
      if ( res == EX_DATA )
      {
        state = CENTER_PT;
        surf_cnt = 0;
      }
      else if (res == EX_BACK_UP)
        state = SURFACE;
    }

    if ( state == PROCESS )
    {
      num_bytes = sizeof(struct IGRdisplay);
      gr$get_active_display ( msg = &msg_loc, sizbuf = &num_bytes,
			    nret= &nbytes_ret, buffer = &disp_buffer );
      gr$get_active_level   ( buffer = &disp_level );
    
      const_list.msg        = &msg_loc;
      const_list.env_info   = &surface_info.module_info;
      const_list.display    = &disp_buffer;
      const_list.properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
      const_list.newflag    = FALSE;
      const_list.level      = disp_level;
      const_list.class_attr = NULL;
      const_list.name       = NULL;
      const_list.geometry   = NULL;

      gr$get_associative_flag ( buffer = &assoc_placement );
    
      if ( ! assoc_placement )
           options = EMSasconst_notassociative;
      else
           options = NULL;

      res_obj.osnum = surface_info.located_obj.osnum;
      status( "Processing ..");

      sts = ems$place_counterpart( msg = &msg_loc,
                            surface = &surface_info,
                            type = type,
                            axis_normal = TRUE,
                            thru_hole = thru_hole,
                            center_pt_event = &center_pt_event,
                            num_parts = num_parts,
                            part_info = NULL,
                            counter_depth_event = &counter_depth_event,
                            counter_dia_event = &counter_dia_event,
                            hole_dia_event = &hole_dia_event,
                            hole_depth_event = &hole_depth_event,
                            bottom_angle_event = &bottom_angle_event,
                            gen_opts = options,
                            construction_list = &const_list,
                            resultant_id = &res_obj);

      if (!(sts & msg_loc & 1)) goto wrapup;

      state = TYPE;
      status( "Successfully created"); 
    }
  }  
  exit;
wrapup:
  status("place counterpart failed");
  exit;
}
