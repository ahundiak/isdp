/************************************************************************/
/*									*/
/*  Program: intersect.u	    Macro: ems$intersect_two_elements	*/
/*									*/
/*  Defined in: EMSascmacros.h						*/
/*									*/
/*  Comments  : 							*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "ciminimum.h"
#include "cimacros.h"
#include "ci_easy.h"
#include "go.h"
#include "grdpbmacros.h"
#include "dpmacros.h"
#include "lcdef.h"

#include "EMSascmacros.h"
#include "EMSasnuc.h"
#include "EMSasopts.h"

#define FIRST_ELE	1
#define SECOND_ELE	2
#define TRIM_OPT	3

extern GRclassid OPP_GRcurve_class_id;
extern GRclassid OPP_EMSsubbs_class_id;
extern GRclassid OPP_EMSsurface_class_id;

extern	int	GRdpb_get();
extern	int	DPmacupdate();

main ()
{
     /* Declare variables here : */
     struct GRvg_construct    const_list;
     struct GRlc_info         elem1_info;
     struct GRlc_info         elem2_info;

     struct IGRdisplay        disp_buffer;
     IGRboolean               trimming_required;
     IGRshort                 disp_level;
     IGRboolean               assoc_placement;
     IGRushort                options;
     GRobjid                  res_obj;
     IGRint                   tmp,sts, num_bytes;
     IGRint		      res,state;
     IGRlong                  msg_loc, nbytes_ret;
     OM_S_CLASSLIST           elig_classes;
     GRclassid                eli_classes[3];


  /* End of variable declarations */

  message ("Intersection of curves/surfaces/solids") ;

  /*Get the first object */
  elig_classes.w_count = 3;
  eli_classes[0] = OPP_GRcurve_class_id;
  eli_classes[1] = OPP_EMSsubbs_class_id;
  eli_classes[2] = OPP_EMSsurface_class_id;
  elig_classes.w_flags = OM_CLST_subclass;
  elig_classes.p_classes = eli_classes;
  state = FIRST_ELE;
   
  while( 1 )
  {
    if ( state == FIRST_ELE ) 
    {
      ci$locate ( obj=&elem1_info.located_obj.objid,
                lc_info=&elem1_info,
	        prompt="Identify First curve/surface/solid",
	        acc_prompt="Accept/Reject ",
                response=&res,
	        relocate_prompt="Element not Found",
		owner_action = LC_ASSOCIATIVE | LC_EXTERN_CONSTRAINED |
				LC_REF_OBJECTS,
                eligible_classes = &elig_classes
	      );
      if ( res == EX_DATA )
        state = SECOND_ELE;
      else if (res == EX_RJT_MOVEON)
        break;
    }
    if ( state == SECOND_ELE )
    {
      ci$locate ( obj=&elem2_info.located_obj.objid,
                lc_info=&elem2_info,
	        prompt="Identify Second curve/surface/solid",
	        acc_prompt="Accept/Reject ",
                response=&res,
	        relocate_prompt="Element not Found",
		owner_action = LC_RIGID_COMP | LC_FLEX_COMP,
                eligible_classes = &elig_classes
	      );
      if ( res == EX_DATA )
        state = TRIM_OPT;
      else if ( res == EX_RJT_MOVEON )
        state = SECOND_ELE;
      else if ( res == EX_BACK_UP )
        state = FIRST_ELE;
    }
    if ( state == TRIM_OPT )
    {
      ci$get( value = tmp,
	     prompt = "Is trimming required ? Yes = 1; No = 0"
  	     );
      trimming_required = tmp;

      num_bytes = sizeof(struct IGRdisplay);
      gr$get_active_display ( msg = &msg_loc, sizbuf = &num_bytes,
			    nret= &nbytes_ret, buffer = &disp_buffer );
      gr$get_active_level   ( buffer = &disp_level );
    
      const_list.msg        = &msg_loc;
      const_list.env_info   = &elem1_info.module_info;
      const_list.display    = &disp_buffer;
      const_list.properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
      const_list.newflag    = FALSE;
      const_list.level      = disp_level;
      const_list.class_attr = NULL;
      const_list.name       = NULL;
      const_list.geometry   = NULL;

      gr$get_associative_flag ( buffer = &assoc_placement );
    
      if ( ! assoc_placement )
           options = EMSasconst_notassociative;
      else
           options = NULL;

      status( "Processing ..");

      sts = ems$assoc_intersect_elements( msg = &msg_loc,
                                    elem1_info = &elem1_info,
                                    elem2_info = &elem2_info,
                                    trimming_required = trimming_required ,
                                    options = options,
                                    construction_list = &const_list,
                                    resultant_obj = &res_obj);

      if (!(sts & msg_loc & 1)) goto wrapup;

      dp$update ( msg   = &msg_loc );
      state = FIRST_ELE;
      status( "Successfully created"); 
    }
  }  
  exit;
wrapup:
      status("Intersection failed");
  exit;
}
