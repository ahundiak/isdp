/*
#define  DEBUG	1
#define  vsDEBUG	1
*/
#include "FI.h"
#include "ndmacros.h"
#include "VDppl.h"
#include "VDmem_ppl.h"
#include "VDobj.h"
#include "vlplatejig.h"
#include "vldbgmacros.h"

#define vsDEBUG 	1
#define vdserrDEBUG	1

/************************************************************
  Define Constants.
 ************************************************************/
/*
 * Define constants for form 
 */
#define FORM_LABEL	100		// Arbitrary Number for Form
#define FORM_NAME	"VLplateJig"	// Form File
#define TITLE_STRING	"Modify Plate Jig Manager"

/************************************************************
  External functions.
 ************************************************************/
extern	ci_notification();	/* The forms system automatically calls    */
				/* this function, which in turn calls your */
				/* form_notification function              */

extern	FIf_set_cmd_oid_os();	/* This function tells the forms system */
				/* to notify this command file when the */
				/* user manipulates the form */

extern	FIf_reset() ;
extern	FIf_new();		/* Creates the form              */
extern	FIf_display();		/* Draws the form                */
extern	FIf_erase();		/* Erases the form               */
extern	FIf_delete();		/* Removes the form              */
extern	FIg_get_value();	/* Retrieves values from gadgets */
extern	FIg_set_value();	/* Retrieves values from gadgets */
extern	FIg_reset() ;
extern	FIg_unhilite() ;
extern	FIfld_set_select() ;

extern IGRlong VLgetPlateJigMgrAttr(), VLsetPlateJigMgrAttr();
extern GRdisplay_object(), NDwait_batch(), NDget_mod_batch(),
       NDexec_batch();

/************************************************************
  Global variables.
 ************************************************************/
int	test_wakeup;	// The wakeup function uses this flag to
			// test if the main function has started yet.

int	form_exists,	// The delete function uses this flag
			// to test if the form exists 
	form_displayed,	// The sleep function uses this flag
			// to test if the form is displayed
	not_done;		// This value is set to 0 when the user
			// selects the cancel or exit & save buttons

Form	form;		// Use this variable for the forms functions. 

struct	CIform_st form_st;	// This structure contains information on
				// which form and gadget was manipulated. 

enum GRdpmode   dpBvlMode ;
enum GRdpmode   hilitMode ;
TGRid           hilitObj ;
IGRint          hilitGadget ;

TGRobj_env      oldbox, jigMacOE;
IGRdouble       oldval[NUM_PM_ATTR];

IGRint          fontSize ;
IGRchar         fontStr[80] ;

IGRchar		msgStr[128];
enum GRdpmode	dpMode ;

void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  __DBGpr_com("return_error");
  status("");		/* Clear the status field  */
  message("");		/* Clear the message field */
  exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  int error;
  
  SetProc(COplateJigMod - form_init); Begin
 /*************************
   Create (load) the form.
  *************************/
  __DBGpr_str("Form name",FORM_NAME);
  error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &form );
  if ( form == NULL ) 
    {
      write( "Could not create the form.\n",
             "Error code = ",  error,  "\n"  );
      return_error();
    }

  form_exists = TRUE;  /* Flag for delete function */

 /**********************************************
   Tell the Forms System to notify this command
   file when the user manipulates the form.
  **********************************************/
  error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
  if ( error )
    {
      write( "Could not link to the Forms System.\n",
             "Error code = ",    error,         "\n"  );
      form_exists = FALSE;
      return_error();
    }

 /*******************
   Display the form.
  *******************/
  
  error = FIf_display( form );
  if ( error ) {
      write( "Could not display the form.\n",
             "Error code = ",  error,   "\n"  );
      return_error();
  }

  form_displayed = TRUE;  /* Flag for sleep function */

  End
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  char outString[80];
  SetProc(COplateJigMod - form_notification); Begin
  
  ci$put( response = MOVE_ON );  /* Give control to the main function */
  End
}


wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  SetProc( COplateJigMod - wakeup); Begin
  /* Display the form unless the command file is just starting */
  __DBGpr_int("COplateJigMod waking up, test_wakeup",test_wakeup);
  __DBGpr_int("COplateJigMod waking up, not_done", not_done);
  if ( test_wakeup == 1 && not_done ) {
      if( form ) 
      {
	FIf_display ( form );  /* Redisplay the form */
      	form_displayed = TRUE; /* Set flag for sleep function */
      }
  }
  End
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  SetProc(COplateJigMod - sleep ); Begin

  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
  {
    FIf_erase ( form );
    form_displayed = FALSE;
  }
  End
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
   SetProc(COplateJigMod - delete); Begin
	__DBGpr_int("form_displayed", form_displayed);
	__DBGpr_int("form_exists", form_exists);
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE ) {
      FIf_erase ( form );
      form_displayed = FALSE;
  }

  /* Delete the form if it exists */
  if ( form_exists ) {
      if( form ) {
	FIf_delete( form );
 	form = NULL ;
      }
  }

  End
}


/**********************************************************/
IGRstat LocateOE( inType, inPrompt, selOE, objName, check)
IGRchar		*inType;
IGRchar		*inPrompt;
TGRobj_env	*selOE;
IGRchar		*objName;
IGRint		check;
{
	IGRint	response ;

	if( selOE->obj_id.objid != NULL_OBJID ) {
		gr$display_object (     object_id = &selOE->obj_id ,
					md_env    = &selOE->mod_env ,
					mode      = GRhd ) ;
	}

 	ci$locate(
		obj		= &selOE->obj_id.objid,
     		osnum		= &selOE->obj_id.osnum,
		md_env		= &selOE->mod_env,
		response	= &response,
		classes		= inType,
		prompt		= inPrompt, 
		stackable	= TRUE ,
		properties	= LC_LC_ONLY | LC_DP_ONLY | LC_RW,
		owner_action	= LC_RIGID_COMP  | LC_RIGID_OWNER | 
				  LC_FLEX_COMP   | LC_FLEX_OWNER  | 
				  LC_REF_OBJECTS );
            
wrapup:
   return TRUE;
}

/*****************************************************************/
IGRstat ModifyMacro() 
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRint		toggle_val;
	IGRdouble	value;
	IGRint		modif, cn_type, b_mod;	
	struct GRid	newbox;

 	SetProc( COplateJigMod - ModifyMacro); Begin

	retFlag = 0 ;
	modif   = 0;

        FIg_get_value( form, JF_MS, &value );
	if( oldval[IDX_PM_MID] != value )
	{
	  __DBGpr_dbl("New Mid Ship Value", value );
	  oldval[IDX_PM_MID] = value;
	  modif = 1;
	}

        FIg_get_value( form, JF_EX, &value );
        if( oldval[IDX_PM_EXT1] != value )
        {
          __DBGpr_dbl("New Extension Value", value );
          oldval[IDX_PM_EXT1] = value;
          modif = 1;
        }

        FIg_get_value( form, JF_HR, &value );
        if( oldval[IDX_PM_HOLE] != value )
        {
          __DBGpr_dbl("Scallop Radius Value", value );
          oldval[IDX_PM_HOLE] = value;
          modif = 1;
        }

        FIg_get_value( form, JF_GG, &value );
        if( oldval[IDX_PM_GRD] != value )
        {
          __DBGpr_dbl("Ground Gap Value", value );
          oldval[IDX_PM_GRD] = value;
          modif = 1;
        }

        FIg_get_value( form, JF_OS, &value );
        if( oldval[IDX_PM_OSET] != value )
        {
          __DBGpr_dbl("Offset Value", value );
          oldval[IDX_PM_OSET] = value;
          modif = 1;
        }

        FIg_get_value( form, JF_SP, &value );
        if( oldval[IDX_PM_SPAC] != value )
        {
          __DBGpr_dbl("Spacing Value", value );
          oldval[IDX_PM_SPAC] = value;
          modif = 1;
        }

        FIg_get_value( form, JF_SW, &value );
        if( oldval[IDX_PM_STWI] != value )
        {
          __DBGpr_dbl("Strip Width Value", value );
          oldval[IDX_PM_STWI] = value;
          modif = 1;
        }

        FIg_get_state(form, JF_GO, &toggle_val );
        if( (int)oldval[IDX_PM_GROP] != toggle_val )   
        {      
          __DBGpr_com("Grid Option Toggle is changed");    
          oldval[IDX_PM_GROP] = (IGRdouble)toggle_val ; 
          modif = 1;   
        }

	FIg_get_state(form, JF_DR, &toggle_val );
	if( (int)oldval[IDX_PM_DIR] != toggle_val )
        {
          __DBGpr_com("Jig Direction Toggle is changed");
          oldval[IDX_PM_DIR] = (IGRdouble)toggle_val ;
          modif = 1;
        }	

	if( modif )
	{
	   ci$get_module_info( md_env = &MOD_ENV );
	   newbox.osnum = MOD_ENV.md_id.osnum;
	   sts = VLsetPlateJigMgrAttr( &retFlag, oldval, &newbox );
	   __CheckRC( sts, retFlag, "VLsetPlateJigMgrAttr", wrapup );

	   __DBGpr_obj("Old Box ", oldbox.obj_id );
	   __DBGpr_obj("New Attribute Box created ", newbox );

           sts = ci$send ( msg = message NDnode.NDchange_connect(
				1, &oldbox.obj_id, &newbox),
                targetid = jigMacOE.obj_id.objid,
                targetos = jigMacOE.obj_id.osnum);

	   cn_type    = ND_COMP; /* recompute the object */
	   sts = nd$wait_batch(	type        = GR_GEOM_POSTED,
				nb_obj      = 1,
				l_object    = &jigMacOE.obj_id,
				l_obj_info  = &cn_type );

	   nd$mod_batch(request = ND_INQ,
                   p_ret_mode   = &b_mod );	

           if( b_mod != ND_DEFER ) nd$exec_batch();
	}

	retFlag = 1 ;
wrapup:
	End
	return retFlag ;
}

/************************************************************************/
FillInForm() 
{
	IGRstat		retFlag ;
	IGRstat		sts ;
	IGRint		i ;

	SetProc(COplateJigMod - FillInForm); Begin

	retFlag = 1 ;
	vdobj$GetTemplate(  objOE = &jigMacOE,
			    nth   = IDX_PM_ATTR,
			    templateOE = &oldbox );
	__DBGpr_obj("Old Attribute Box ", oldbox.obj_id );

	VLgetPlateJigMgrAttr ( &retFlag, oldval, &oldbox );

        /* Fill the form */
	FIg_set_value ( form, JF_MS, oldval[IDX_PM_MID] );
	__DBGpr_dbl("Mid Ship Value ", oldval[IDX_PM_MID] );

	FIg_set_value ( form, JF_EX, oldval[IDX_PM_EXT1] );
	__DBGpr_dbl("Extension Value ", oldval[IDX_PM_EXT1] );

	FIg_set_value ( form, JF_HR, oldval[IDX_PM_HOLE] );
	__DBGpr_dbl("Scallop Radius Value ", oldval[IDX_PM_HOLE] );

	FIg_set_value ( form, JF_GG, oldval[IDX_PM_GRD] );
	__DBGpr_dbl("Ground Gap Value ", oldval[IDX_PM_GRD] );

	FIg_set_value ( form, JF_OS, oldval[IDX_PM_OSET] );
	__DBGpr_dbl("Offset Value ", oldval[IDX_PM_OSET] );

	FIg_set_value ( form, JF_SP, oldval[IDX_PM_SPAC] );
	__DBGpr_dbl("Spacing Value ", oldval[IDX_PM_SPAC] );

	FIg_set_value ( form, JF_SW, oldval[IDX_PM_STWI] );
	__DBGpr_dbl("Strip Width Value ", oldval[IDX_PM_STWI] );

	if( (int)oldval[IDX_PM_TYPE]  == IDX_J3 )
		FIg_set_text (form, JF_TY, NAM_J3);
	else if( (int)oldval[IDX_PM_TYPE]  == IDX_J4 )
		FIg_set_text (form, JF_TY, NAM_J4 );
	else	FIg_set_text (form, JF_TY, NAM_J5 );
	__DBGpr_int("Plate Type ", (int)oldval[IDX_PM_TYPE] );

	FIg_set_state ( form, JF_GO, (IGRint)oldval[IDX_PM_GROP] );
	__DBGpr_int("Grid Option ", (IGRint)oldval[IDX_PM_GROP] );

	FIg_set_state ( form, JF_DR, (IGRint)oldval[IDX_PM_DIR]  );
	__DBGpr_int("Jig Direction ", (IGRint)oldval[IDX_PM_DIR]  );

	FIg_disable( form, JF_SW );
	FIg_disable( form, JF_GO );
	FIg_disable( form, JF_TY );

	FIg_disable( form, 19 );
	FIg_disable( form, 20 );
	FIg_disable( form, 21 );

wrapup:
	End
	return retFlag ;
}

main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/
{

  IGRint	response;     
  IGRint	i;
  IGRint	m;
  IGRint	msg;
  IGRint	pos, toggle;
  IGRint	selFlag;
  IGRint	exitFlag;
  IGRint	numAttrs;
  IGRint	sts;
  IGRint 	error;
  IGRchar	tmpStr[80] ;
  TGRobj_env	offsetSrfOE, tmpOE ;
  BSrc		rc ;

  /* initialize some parameters before we start */
  test_wakeup = 1;		/* flag for wakeup function */
  form_exists = FALSE;		/* flag for delete function */
  form_displayed = FALSE;	/* flag for sleep  function */
  not_done = TRUE;		/* Set this to FALSE when done with form */
  exitFlag = 1;
  tmpStr[0]  = '\0' ;
  form_st.gadget_label = -1 ;
  message("Modify Plate Jig Options");

again:

  if( form_st.gadget_label == FI_EXECUTE ) {
     LocateOE( "VLjigMgr", "Identify Plate Jig Manager or hit F1 to quit",
                        &jigMacOE, tmpStr, FALSE);
  }
  else {
     LocateOE( "VLjigMgr", "Identify Plate Jig Manager",
                        &jigMacOE, tmpStr, FALSE);
  }

reset:

  if( !form_exists ) { 
	form_init();      
  }
  message(TITLE_STRING);

  FillInForm() ; 

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/
  while (not_done )
  {
      __DBGpr_int("case", form_st.gadget_label);

      /* Suspend the command file and wait for the form */
      ci$get (	prompt   = "Fill in the form",
		response = &response );
              
      UI_status("");
      strcpy( msgStr, "" ) ;
      __DBGpr_int("case", form_st.gadget_label);
	
      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){

        case FI_CANCEL:		// Quit Button 
          not_done = 0;		// Stop the loop
	  exitFlag = 0;		// exit the program
          FIf_erase ( form );	// Erase the form 
          break;
	
	case JF_MS:
	case JF_EX:
        case JF_HR:
        case JF_GG:
        case JF_OS:
        case JF_SP:
        case JF_SW:
			break;

        case FI_ACCEPT:
          if( ModifyMacro() ) {
		not_done = FALSE;
		FIf_erase ( form ); 
	  }
	  else {
		not_done = TRUE ;
	  }
          break;

        } /* END switch ( g_label ) */

	UI_status( msgStr ) ;

    }     /* END while ( not done ) */

wrapup:

    status("") ;
    prompt("") ;
    message("") ;
    if ( exitFlag == 0 ) exit;

}
