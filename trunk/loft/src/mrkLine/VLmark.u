/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	I/LOFT:
		PPL file to define the template of the mark object's macro
		definition.  See VLMark.S for more information.

*============================================================================*/

#include	<stdio.h>
#include	"OMerrordef.h"
#include	"ciminimum.h"
#include	"cimacros.h"
#include	"ci_mac_def.h"
#include	"macro.h"
#include	"AS_status.h"
#include	"parametric.h"

#include	"vldbgmacros.h"
#include	"vlmark.h"

extern		ASsuper_construct();

/* ========================================================================= */
/* the main function is the one implementing the definition creation	     */
/* ========================================================================= */

main ()
{
	IGRlong		sts;
	IGRchar		*temp_names[VLMrkMaxNumTemplates];
	IGRchar		*feet_names[VLMrkNumFeet],
			tmp_temp[VLMrkMaxNumTemplates * 20],
			fnames[(VLMrkNumFeet - 10) *  11 ];
	IGRint		i, temp_types[VLMrkMaxNumTemplates];
	IGRchar		temp_buff[VLMrkMaxNumTemplates];
	IGRchar		feet_buff[VLMrkNumFeet];
	GRobj 	 	ci_mac_def1;
	IGRint		temp_number, feet_number,
			currentFoot, currentName ;		// counters 

	temp_number =  VLMrkMaxNumTemplates	;
	feet_number =  VLMrkNumFeet		;

	temp_names[VLMrkCollIndex] = VLMrkCollName	;
	temp_types[VLMrkCollIndex] = other_generic	;

	temp_names[VLMrkPlateIndex] = VLMrkPlateName	;
	temp_types[VLMrkPlateIndex] = macro_generic	| other_generic ;
							
	temp_names[VLMrkStiffIndex] = VLMrkStiffName	;
	temp_types[VLMrkStiffIndex] = macro_generic	| other_generic ;

        for (i=3; i<VLMrkMaxNumTemplates; i=i+1){
           sprintf(&tmp_temp[i*20], "%s%d",VLMrkGrCrvName, (i-3) );
	   temp_names[i]  = &tmp_temp[i*20];
           temp_types[i] = curve_generic ;
        }

		// first twelve feet given full names 

	feet_names[VLFulLinIndex]	= VLFullLineName	;
	feet_names[VLMrkParIndex]	= VLMrkParamsName	;
	feet_names[VLFirMrkIndex]	= VLFirstMrkName	;
	feet_names[VLSecMrkIndex]	= VLSecondMrkName	;
	feet_names[VLThrMrkIndex]	= VLThirdMrkName	;
	feet_names[VLForMrkIndex]	= VLFourthMrkName	;
	feet_names[VLFifMrkIndex]	= VLFifthMrkName	;
	feet_names[VLSixMrkIndex]	= VLSixthMrkName	;
	feet_names[VLSevMrkIndex]	= VLSeventhMrkName	;
	feet_names[VLEigMrkIndex]	= VLEighthMrkName	;
	feet_names[VLNinMrkIndex]	= VLNinethMrkName	;
	feet_names[VLTenMrkIndex]	= VLTenthMrkName	;

		// the rest given shortened names */
	currentName = 0;
	for ( currentFoot = 12; currentFoot < VLMrkNumFeet ; 
						currentFoot = currentFoot+1 )  {     
	      sprintf( &fnames[currentName * 11], "%dth mark", currentFoot+1 ) ;
		fnames[(currentName * 11) + 10 ] = 0;
		feet_names[currentFoot] = &fnames[currentName*11] ;
		currentName=currentName+1 ;
	}

  	ci_mac_def1 = NULL_OBJID;
  	ac$cimacdef( 	cimacdef          = ci_mac_def1		,
			name		  = VLMacroMark		,
			status 	          = &sts		,
              		temp_num          = temp_number		,
			temp_names        = temp_names		,
			temp_types        = temp_types		,
	      		extern_feet_num   = feet_number		,
	 		extern_feet_names = feet_names );

	__DBGpr_obj( "Placed macro defn", ci_mac_def1 );

return OM_S_SUCCESS;

}

/*********************	End of Mark.u			***********************/
