/***************************************************************************
 * INGR - PPL
 *
 * File:        PCetWeb2d.u
 *
 * Description:	PPL macro for placing end treatments on the web view of profile cards
 *
 * Dependencies:
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      02/17/00        mjablko         creation date
 *      02/18/00        jhanson         ellipse shape added
 *
 ***************************************************************************/

#define VD_PPL

// DEBUG INFO
//***********

//#define DEBUG

// INCLUDES
//***********
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "vd_ve.h"
#include "v_edgedef.h"
#include "v_edgemacros.h"
#include "vdparmacros.h"
#include "vdsetmacros.h"
#include "vldbgmacros.h"
#include "grwireframe.h"
#include "grdpb.h"
#include "grdpbmacros.h"
#include "fontmacros.h"
#include "cotxmacros.h"

#include "vldbgmacros.h"

// Macro constants
//******************
#define MAX_FEET      60
#define MAX_TEMP      23
#define MAX_CHA_TEMP  20

// CI_MACRO variables
//**********************
GRobj           ci_mac_def1;
int             stat, msg, grCount;
int             temp_types[MAX_TEMP];
char           *temp_names[MAX_TEMP], *feet_names[MAX_FEET];
char            txt[15], buff[MAX_FEET*MAX_CHA_TEMP];
struct GRmd_env MOD_ENV;

// Macro templates
//*******************
struct GRobj_env MacroCS;
double           FrameHeight, FrameWidth;
char             TopLabel[10], BottLabel[10];
int              BeamType, Flip;
int              ETType, Ttype, Btype;
double           TFlCut, BFlCut, TFlSn, BFlSn, FlCut, WebAngDist, 
                 Stock, CopeDepth, CopeRad, FlgDelta;
double           WebAngle, Thor, Tvert, Trad, Bhor, Bvert, Brad, BeamHeight;

// Auxilary global variables
//*****************************
struct ret_struct     expr;
struct GRid           CI_MACRO_ID,  GRid_list[MAX_FEET];
struct IGRdisplay     dis;
struct GRvg_construct cst;

// Global variables
//****************
double TopWebRatio, BotWebRatio;
int    Sim;

double dim_txt_ht ;
double lbl_txt_ht ;
double lbl_pnt[3] ;
double txt_cs[16] ;

int sign ;
int flip , sts ;
int count ;

char dmtxt[10] ;

int     mcsign;
//double vwcs[16], macs[16];
double mcxvec[3], mcyvec[3], mczvec[3], mcorigin[3];
double vwxvec[3], vwyvec[3], vwzvec[3], vworigin[3];

double p0[3], p1[3], p2[3], p3[3], p4[3], p5[3], p6[3];
double p7[3], p8[3], p9[3], p10[3], p11[3], p12[3];
double p13[3], p14[3], p15[3], p16[3], p17[3], p18[3];
double p19[3], p20[3], p21[3], p22[3], p23[3], p24[3];
double p25[3], p26[3], p27[3], p28[3], p29[3];
double p30[3], p31[3], p32[3], p33[3], p34[3], p35[3];
double p36[3], p37[3], p38[3], p39[3], p40[3], p41[3];
double p42[3], p43[3], p44[3], p45[3], p46[3], p47[3];
double p51[3], p52[3], p53[3], p54[3], p55[3], p56[3];
double p57[3], p58[3], p59[3], p60[3], p61[3], p62[3];

extern	char *strncpy ();
extern	char *strrchr ();
extern  free(), abs(), fasb();
extern 	int	init_cnst_list();
extern 	GRretrieve_font(), GRplace_text(),
	GRdpb_get(),
	GRang_place_text(),
	BSac2ptctvc(),
	BSellctaxrm(),
  	GRsymbology_options(),
        GRcreate_linestring(),
        GRcreate_conic_by_edge();
extern  EX_get_oid_nodname(), EX_get_modid_given_osnum();
extern  GRdisplay_object ();
extern  BSmdstptcv();
extern  BSactivsplt();

#include "SupMacros.h"
#include "PC2d.h"


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

    int i, j;

    temp_names[0]  = "FrameHeight";       temp_types[0]  = double_type;
    temp_names[1]  = "FrameWidth";        temp_types[1]  = double_type;
    temp_names[2]  = "WebAngle";          temp_types[2]  = double_type;
    temp_names[3]  = "TopLabel";          temp_types[3]  = text_type;
    temp_names[4]  = "BottLabel";         temp_types[4]  = text_type;
    temp_names[5]  = "ETType";            temp_types[5]  = double_type;
    temp_names[6]  = "Ttype";             temp_types[6]  = double_type;
    temp_names[7]  = "Thor";              temp_types[7]  = double_type;
    temp_names[8]  = "Tvert";             temp_types[8]  = double_type;
    temp_names[9]  = "Trad";              temp_types[9]  = double_type;
    temp_names[10] = "Btype";             temp_types[10] = double_type;
    temp_names[11] = "Bhor";              temp_types[11] = double_type;
    temp_names[12] = "Bvert";             temp_types[12] = double_type;
    temp_names[13] = "Brad";              temp_types[13] = double_type;
    temp_names[14] = "BeamType";          temp_types[14] = double_type;
    temp_names[15] = "BeamHeight";        temp_types[15] = double_type;
    temp_names[16] = "FlCut";             temp_types[16] = double_type;
    temp_names[17] = "Stock";             temp_types[17] = double_type;
    temp_names[18] = "CopeDepth";         temp_types[18] = double_type;
    temp_names[19] = "CopeRad";           temp_types[19] = double_type;
    temp_names[20] = "Flip";              temp_types[20] = double_type;
    temp_names[21] = "FlgDelta";          temp_types[21] = double_type;
    temp_names[22] = "MacroCS";           temp_types[22] = ref_generic;

    for ( i=0; i<MAX_FEET; i=i+1) {
        j = i * MAX_CHA_TEMP;
        sprintf( &buff[j], "pcetweb_%d", i );
        feet_names[i] = &buff[j];
    }
    ci_mac_def1 = NULL_OBJID;

    ac$cimacdef( cimacdef =  ci_mac_def1,
                 status            = &stat,
                 name              = "PCetWeb2d",
                 temp_num          = MAX_TEMP,
                 temp_names        = temp_names,
                 temp_types        = temp_types,
                 extern_feet_num   = MAX_FEET,
                 extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{

    construct_comp();

    if( GRid_list[0].objid == NULL_OBJID )
        return(0);

    ci$send( msg = message  ci_macro.set_all_extern_feet( &stat,
                                                          MAX_FEET,
                                                          GRid_list,
                                                          &MOD_ENV ),
             targetid = CI_MACRO_ID.objid,
             targetos = CI_MACRO_ID.osnum);
    return(1) ;
}

/* ========================================================================= */

place ()
{
    construct_comp();

    if( GRid_list[0].objid == NULL_OBJID )
        return(0);

    ci$send( msg = message  ci_macro.set_all_extern_feet( &stat,
                                                          MAX_FEET,
                                                          GRid_list,
                                                          &MOD_ENV ),
             targetid = CI_MACRO_ID.objid,
             targetos = CI_MACRO_ID.osnum);
    return(1);
}

/* =========================================================================


 * ========================================================================= */

construct_comp()
{
    /* Initialize and get input data */
    initialize();

    /* start laying out the points */
    Construct_graphics( ETType );

#ifdef DEBUG
    printf("grCount: %d\n", grCount);
#endif

    /* null out the next id for some kind of checking later */
    GRid_list[grCount].objid = NULL_OBJID;
}


/* ========================================================================= */

int initialize()
{
    double angle;


    /* Collect input data */
    getinput();

    /* compute the web angle distance */
    if( WebAngle != 90 ) {
        angle = fabs( WebAngle - 90 ) * PI/180;
        WebAngDist = BeamHeight * tan( angle ) ;
    }
    else
        WebAngDist = 0.0;

    /* initialize the graphics counter */
    grCount = 0;

    /* set the dimension text height */
    dim_txt_ht = DIM;

    /* set the label text height */
    lbl_txt_ht = LABEL;
    dimension_text_height  = lbl_txt_ht;

    /* Get coordinate system matrices */
    compute_cs( MacroCS.obj_id, txt_cs, mcorigin, mcxvec, mcyvec, mczvec );

    /* Set orientation */
    if( Flip == 0)
        Flip = 1;
    else
        Flip = -1;

}


/* ========================================================================= */

int getinput()
{

    SetProc( PCetWeb2dGetInput ); Begin

    /* GET PARAMETER VALUES */
    getIntParm    ( CI_MACRO_ID, "Flip", &Flip );
    getDoubleParm ( CI_MACRO_ID, "FrameHeight", &FrameHeight );
    getDoubleParm ( CI_MACRO_ID, "FrameWidth", &FrameWidth );
    getIntParm    ( CI_MACRO_ID, "BeamType", &BeamType );
    getIntParm    ( CI_MACRO_ID, "ETType", &ETType );
    getTextParm   ( CI_MACRO_ID, "TopLabel", TopLabel );
    getTextParm   ( CI_MACRO_ID, "BottLabel", BottLabel );
    getIntParm    ( CI_MACRO_ID, "Ttype", &Ttype );
    getDoubleParm ( CI_MACRO_ID, "Thor", &Thor );
    getDoubleParm ( CI_MACRO_ID, "Tvert", &Tvert );
    getDoubleParm ( CI_MACRO_ID, "Trad", &Trad );
    getDoubleParm ( CI_MACRO_ID, "WebAngle", &WebAngle );
    getIntParm    ( CI_MACRO_ID, "Btype", &Btype );
    getDoubleParm ( CI_MACRO_ID, "Bhor", &Bhor );
    getDoubleParm ( CI_MACRO_ID, "Bvert", &Bvert );
    getDoubleParm ( CI_MACRO_ID, "Brad", &Brad );
    getDoubleParm ( CI_MACRO_ID, "FlCut", &FlCut );
    getDoubleParm ( CI_MACRO_ID, "BeamHeight", &BeamHeight );
    getDoubleParm ( CI_MACRO_ID, "Stock", &Stock );
    getDoubleParm ( CI_MACRO_ID, "CopeDepth", &CopeDepth );
    getDoubleParm ( CI_MACRO_ID, "CopeRad", &CopeRad );
    getDoubleParm ( CI_MACRO_ID, "FlgDelta", &FlgDelta );

    /* Get MacroCS */
    msg = getobj( CI_MACRO_ID, MAX_TEMP - 1, &MacroCS );

    __DBGpr_obj("Got coordinate System", MacroCS.obj_id );

    if( !( msg&1 ) ) return FALSE;

    if( BottLabel == "" )
        Sim = 0;
    else
        Sim = 1;
    return;
    End
}

/* ========================================================================= */

double Feat_along_vector( FeatureSize, FrameHeight, FrameAngleDist )
double FeatureSize, FrameHeight, FrameAngleDist;
{
    double value;

    value = FeatureSize*sqrt(FrameHeight*FrameHeight+FrameAngleDist*FrameAngleDist)/FrameHeight;

#ifdef DEBUG
    printf ("Feature Projected Height %f\n", value);
    printf ("Feature Size %f\n", FeatureSize);
#endif

    return( value);
}

/* ========================================================================= */

Construct_graphics ( type )
int type;
{
    double tmp[3];
    double theight;
    char text_string[128];
    int len;
    struct GRid TEXT;

    /* If Web Angle == 0 then wrong parameters are read
       from the table or macro is simply not prepared
       for profile card extraction. Since the rest of
       features may be correct, do nothing and let
       the user sketch missing one manually */

    if( WebAngle < 10 )
        return;

    switch( type ) {
        case STRAIGHT:
            straight_cut();
            break;
        case SNIPE:
            snipe_cut();
            break;
        case BEAMLIM:
            beam_limited_cut();
            break;
        case BEAMLIMR:
            beam_limited_rad_cut();
            break;
        case JOG:
            jog_cut();
            break;
        case TRANSDN:
            trans_down_cut();
            break;
        case WEBASFLG:
            webas_flg();
            break;
        default:
            straight_cut();
            printf("PCetWeb2d:Default ET - given type %d\n", type);
            break;
    }
}

/* ========================================================================= *
 *
 *     STRAIGHT CUT
 *
 * ========================================================================= */

straight_cut()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;
    double TFhor, TFvert, TFrad, BFhor, BFvert, BFrad, pm1[3], pm2[3];
    int dim_pos;
    char Ttxt[10], Btxt[10];

    sprintf( Ttxt, "%.0f", Trad );
    sprintf( Btxt, "%.0f", Brad );

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();

    /* Construct top feature - external points will be:
           p21 - left connect point
           p22 - right connect point */

    switch ( Ttype ) {
        case 0:
            construct_corner( p14, p21, p22 );
            break;

        case 1:
            if( Stock > 0.1 && Sim ) {
                construct_corner( p14, p21, p22 );
                break;
            }
/*
            if( Thor < 0.1 || Tvert < 0.1 ) {
                construct_corner( p14, p21, p22 );
                break;
            }
*/
            if( Thor == Tvert ) {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else if (Thor > Tvert ) {
                TFhor  = WEBBIGSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p12, p14, p13, TFhor, TFvert, p21, p22 );
            construct_snipe_dimension( p14, p21, p22, Thor, Tvert, TOP );
            break;

        case 2:
            if( Thor == Tvert ) {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Thor > Tvert ) {
                TFhor  = FrameHeight * WEBEXTSCALL;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBEXTSCALL;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p12, p14, p13, TFhor, TFvert, TFrad, p21, p22, Ttxt );
            break;

        default:
            construct_corner( p14, p21, p22 );
            break;
    }

    /* Construct bottom feature - external connect points will be:
           p23 - left connect point
           p24 - right connect point */

    switch ( Btype ) {
        case 0:
            construct_corner( p13, p23, p24 );
            break;

        case 1:
            if( Stock > 0.1 && Sim ) {
                construct_corner( p13, p23, p24 );
                break;
            }
            if( Bhor == Bvert ) {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            }
            else if (Bhor > Bvert ) {
                BFhor  = WEBBIGSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            }
            else {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p11, p13, p14, BFhor, BFvert, p23, p24 );
            construct_snipe_dimension( p13, p23, p24, Bhor, Bvert, BOTTOM );
            break;

        case 2:
            if( Bhor == Bvert ) {
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Bhor > Bvert ) {
                BFhor  = FrameHeight * WEBEXTSCALL;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBEXTSCALL;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p11, p13, p14, BFhor, BFvert, BFrad, p23, p24, Btxt );
            break;

        default:
            construct_corner( p13, p23, p24 );
            break;
    }

    /* Connect points */
    /* Place end line */
    placeLine( GRid_list, &grCount, p22, p24, 0, 0 );

    /* place top flange */
    if( BeamType == FLAT || BeamType == BTEE )
        placeLine( GRid_list, &grCount, p12, p21, 0, 0 );
    else
        construct_top_flange( p12, p21, FlCut );

    /* place bottom flange */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == TEE || BeamType == BULB )
        placeLine( GRid_list, &grCount, p11, p23, 0, 0 );
    else
        construct_bottom_flange( p11, p23, FlCut );

    construct_label();

    /* Place Dimensions */
    if(WebAngle != 90 ) {
        if( WebAngle > 90 )
            dim_pos = DIM_BELOW;
        else if( WebAngle < 90 )
            dim_pos = DIM_ABOVE;
        sprintf( txt, "%.0f", WebAngDist );
        place_linear_dim( GRid_list, &grCount, p13, p14, dim_pos, DIM_TXT_INSIDE, txt, 6.0);
    }
    /* Place top feature dimension */
    if( Thor != Tvert ) {
        if( Thor > Tvert ) {
            sprintf( txt, "%.0f", Thor );
            place_linear_dim( GRid_list, &grCount, p14, p21, DIM_ABOVE, DIM_TXT_INSIDE, txt, 3.0);
        }
    }
    /* Place bottom feature dimension */
    if( Bhor != Bvert ) {
        if( Bhor > Bvert ) {
            sprintf( txt, "%.0f", Bhor );
            place_linear_dim( GRid_list, &grCount, p13, p23, DIM_BELOW, DIM_TXT_INSIDE, txt, 3.0);
        }
    }

    /* If PIPE place the center line */
    if( BeamType == PIPE ) {

        /* Left mid point */
        varY = FrameHeight/2;
        v_scale( mcyvec, varY, tmp );
        v_add( p1, tmp, pm1  );

        /* Right bottom point */
        varX = FrameWidth*1.2;
        v_scale( mcxvec, varX, tmp );
        v_add( pm1, tmp, pm2);

        placeLine( GRid_list, &grCount, pm1, pm2, 4, 0 );
    }

    /* Place stock line */
    //    if(Stock > 0.1)
    //        drawstock();

    /* If top flange is sniped, place a piece to show the delta */
    drawTopFlgSnipeDelta();

    /* if bottom flange is sniped, place a piece to show the delta */
    if (BeamType == ITEE)
    drawBotFlgSnipeDelta();
}

/* ========================================================================= *
 *
 *     SNIPE CUT
 *
 * ========================================================================= */

snipe_cut()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;
    double TFhor, TFvert, TFrad, BFhor, BFvert, BFrad;
    int dim_pos;
    char Btxt[10];

    sprintf( Btxt, "%.0f", Brad );
    WebAngle = 90;

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();

    /* Construct top feature - external points will be:
           p21 - left connect point
           p22 - right connect point */

    if( BeamType == FLAT )
        construct_snipe( p12, p14, p13, FrameWidth * 0.5, FrameHeight * 0.75, p21, p22 );
    else
        construct_jog( p12, p14, p13, FrameWidth * 0.5, FrameHeight * 0.75,
                       FrameHeight * 0.15, FrameHeight * 0.05, Trad, p21, p22 );

    /* Construct bottom feature - external connect points will be:
           p23 - left connect point
           p24 - right connect point */

    construct_corner( p13, p23, p24 );

    /* Connect points */

    /* Place end line */
    placeLine( GRid_list, &grCount, p22, p24, 0, 0 );

    /* place top flange */
    if( BeamType == FLAT || BeamType == BTEE )
        placeLine( GRid_list, &grCount, p12, p21, 0, 0 );
    else
        construct_top_flange( p12, p21, FlCut );

    /* place bottom flange */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == TEE || BeamType == BULB )
        placeLine( GRid_list, &grCount, p11, p23, 0, 0 );
    else
        construct_bottom_flange( p11, p23, FlCut );

    construct_label();

    /* Place Dimensions */

    if(WebAngle != 90 ) {
        if( WebAngle > 90 )
            dim_pos = DIM_BELOW;
        else if( WebAngle < 90 )
            dim_pos = DIM_ABOVE;
        sprintf( txt, "%.0f", WebAngDist );
        place_linear_dim( GRid_list, &grCount, p13, p14, dim_pos, DIM_TXT_INSIDE, txt, 6.0);
    }

    /* Place Dimensions */
    /* nose height */
    if( Flip == 1 )
        dim_pos = DIM_RIGHT;
    else
        dim_pos = DIM_LEFT;
    sprintf( txt, "%.0f", Bvert );
    place_linear_dim( GRid_list, &grCount, p13, p22, dim_pos, DIM_TXT_INSIDE, txt, 3.0);

    /* snipe length */
    sprintf( txt, "%.0f", Bhor );
    place_linear_dim( GRid_list, &grCount, p21, p22, DIM_ABOVE, DIM_TXT_INSIDE, txt, 4.0);

    /* Place stock line */
    //    if(Stock > 0.1)
    //        drawstock();

    /* If top flange is sniped, place a piece to show the delta */
    drawTopFlgSnipeDelta();

    /* if bottom flange is sniped, place a piece to show the delta */
    if (BeamType == ITEE)
    drawBotFlgSnipeDelta();

}

/* ========================================================================= *
 *
 *     BEAM CUT BY BEAM
 *
 * ========================================================================= */

beam_limited_cut()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;
    double TFhor, TFvert, TFrad, BFhor, BFvert, BFrad;
    int dim_pos;
    char Ttxt[10], Btxt[10];


    sprintf( Ttxt, "%.0f", Trad );
    sprintf( Btxt, "%.0f", Brad );

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();

    /* Construct cut out for flange - external points will be:
           p17 - left connect point
           p18 - right connect point
           p19 - cut out corner point */


    if (CopeDepth < 0.1)
    {
        construct_rect_cut( p12, p14, p13, FrameWidth * BMCUTLEN, FrameHeight * 0.0001,
                            p17, p18, p19 );
    }
    else
    {
        construct_rect_cut( p12, p14, p13, FrameWidth * BMCUTLEN, FrameHeight * BMCUTHGT,
                            p17, p18, p19 );
    }

    /* dimension cope */
    if( FlgDelta == 0.0 ) {
        sprintf( txt, "%.0f", FlCut );
        place_linear_dim ( GRid_list, &grCount, p17, p14, DIM_ABOVE, DIM_TXT_INSIDE, txt, 5.0);
    }

    /* Construct top feature - external points will be:
           p21 - left connect point
           p22 - right connect point */

    switch ( Ttype ) {
        case 0:
            construct_corner( p18, p21, p22 );
            break;

        case 1:
            if( Stock > 0.1 && Sim ) {
                construct_corner( p18, p21, p22 );
                break;
            }
            if( Thor == Tvert ) {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else if (Thor > Tvert ) {
                TFhor  = WEBBIGSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p19, p18, p13, TFhor, TFvert, p21, p22 );
            construct_snipe_dimension( p18, p21, p22, Thor, Tvert, TOP );
            break;

        case 2:
            if( Thor == Tvert ) {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Thor > Tvert ) {
                TFhor  = FrameHeight * WEBEXTSCALL;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBEXTSCALL;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p19, p18, p13, TFhor, TFvert, TFrad, p21, p22, Ttxt );
            break;

        default:
            construct_corner( p18, p21, p22 );
            break;
    }

    /* Construct bottom feature - external connect points will be:
           p23 - left connect point
           p24 - right connect point */

    switch ( Btype ) {
        case 0:
            construct_corner( p13, p23, p24 );
            break;

        case 1:
            if( Stock > 0.1 && Sim ) {
                construct_corner( p13, p23, p24 );
                break;
            }
            if( Bhor == Bvert ) {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            }
            else if (Bhor > Bvert ) {
                BFhor  = WEBBIGSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            }
            else {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p11, p13, p14, BFhor, BFvert, p23, p24 );
            construct_snipe_dimension( p13, p23, p24, Bhor, Bvert, BOTTOM );
            break;

        case 2:
            if( Bhor == Bvert ) {
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Bhor > Bvert ) {
                BFhor  = FrameHeight * WEBEXTSCALL;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBEXTSCALL;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p11, p13, p14, BFhor, BFvert, BFrad, p23, p24, Btxt );
            break;

        default:
            construct_corner( p13, p23, p24 );
            break;
    }

    /* Connect points */
    /* Place end line */
    placeLine( GRid_list, &grCount, p22, p24, 0, 0 );
    placeLine( GRid_list, &grCount, p21, p19, 0, 0 );

    /* place top flange */
    if( BeamType == FLAT || BeamType == BTEE )
        placeLine( GRid_list, &grCount, p12, p17, 0, 0 );
    else
        construct_top_flange( p12, p17, 0.0 );

    /* place bottom flange */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == TEE || BeamType == BULB )
        placeLine( GRid_list, &grCount, p11, p23, 0, 0 );
    else
        construct_bottom_flange( p11, p23, FlCut );

    construct_label();

    /* Place Dimensions */
    if(WebAngle != 90 ) {
        if( WebAngle > 90 )
            dim_pos = DIM_BELOW;
        else if( WebAngle < 90 )
            dim_pos = DIM_ABOVE;
        sprintf( txt, "%.0f", WebAngDist );
        place_linear_dim( GRid_list, &grCount, p13, p14, dim_pos, DIM_TXT_INSIDE, txt, 6.0);
    }

    /* Place bottom feature dimension */
    if( Bhor != Bvert ) {
        if( Bhor > Bvert ) {
            sprintf( txt, "%.0f", Bhor );
            place_linear_dim( GRid_list, &grCount, p13, p23, DIM_BELOW, DIM_TXT_INSIDE, txt, 3.0);
        }
    }

    if( Flip == -1 )
        dim_pos = DIM_LEFT;
    else
        dim_pos = DIM_RIGHT;
    sprintf( txt, "%.0f", CopeDepth );
    place_linear_dim ( GRid_list, &grCount, p37, p18, dim_pos, DIM_TXT_INSIDE, txt, 3.0);

    /* Place stock line */
    //    if(Stock > 0.1 && Sim )
    //      drawstock();

    /* If top flange is sniped, place a piece to show the delta */
    drawTopFlgSnipeDelta();

    /* if bottom flange is sniped, place a piece to show the delta */
    if (BeamType == ITEE)
    drawBotFlgSnipeDelta();
}

/* ========================================================================= *
 *
 *     BEAM CUT BY BEAM WITH ADDITIONAL SCALLOP
 *
 * ========================================================================= */

beam_limited_rad_cut()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV, pc[3], ps[3], pb[3];
    double TFhor, TFvert, TFrad, BFhor, BFvert, BFrad;
    int dim_pos;
    char Ttxt[10], Btxt[10];


    sprintf( Ttxt, "%.0f", Trad );
    sprintf( Btxt, "%.0f", Brad );

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();

    /* Construct cut out for flange - external points will be:
           p17 - left connect point
           p18 - right connect point
           p19 - cut out corner point */

    construct_rect_cut( p12, p14, p13, FrameWidth * BMCUTLEN, FrameHeight * BMCUTHGT, p17, p18, p19 );

    /* dimension cope */
    sprintf( txt, "%.0f", FlCut );
    place_linear_dim ( GRid_list, &grCount, p17, p14, DIM_ABOVE, DIM_TXT_INSIDE, txt, 5.0);

    construct_rect_cut_scallop( p17, p19, p18, WEBSNIPE*FrameWidth/2 );

    v_scale( mcxvec, -WEBSNIPE*FrameWidth/2*Flip, tmp );
    v_add( p19, tmp, pc );
    v_scale( mcyvec, -WEBSNIPE*FrameWidth/2, tmp );
    v_add( pc, tmp, ps );
    v_scale( mcxvec, -WEBSNIPE*FrameWidth*Flip, tmp );
    v_add( p19, tmp, pb );
    sprintf( txt, "%.0f", CopeRad );
    place_radial_dim ( GRid_list, &grCount, WEBSNIPE*FrameWidth/2, txt, pb, pc, ps, 1.0, Flip );

    /* Construct top feature - external points will be:
           p21 - left connect point
           p22 - right connect point */

    switch ( Ttype ) {
        case 0:
            construct_corner( p18, p21, p22 );
            break;

        case 1:
            if( Stock > 0.1 && Sim ) {
                construct_corner( p18, p21, p22 );
                break;
            }
            if( Thor == Tvert ) {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else if (Thor > Tvert ) {
                TFhor  = WEBBIGSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p19, p18, p13, TFhor, TFvert, p21, p22 );
            construct_snipe_dimension( p18, p21, p22, Thor, Tvert, TOP );
            break;

        case 2:
            if( Thor == Tvert ) {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Thor > Tvert ) {
                TFhor  = FrameHeight * WEBEXTSCALL;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBEXTSCALL;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p19, p18, p13, TFhor, TFvert, TFrad, p21, p22, Ttxt );
            break;

        default:
            construct_corner( p18, p21, p22 );
            break;
    }

    /* Construct bottom feature - external connect points will be:
           p23 - left connect point
           p24 - right connect point */

    switch ( Btype ) {
        case 0:
            construct_corner( p13, p23, p24 );
            break;

        case 1:
            if( Stock > 0.1 && Sim ) {
                construct_corner( p13, p23, p24 );
                break;
            }
            if( Bhor == Bvert ) {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            }
            else if (Bhor > Bvert ) {
                BFhor  = WEBBIGSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            }
            else {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p11, p13, p14, BFhor, BFvert, p23, p24 );
            construct_snipe_dimension( p13, p23, p24, Bhor, Bvert, BOTTOM );
            break;

        case 2:
            if( Bhor == Bvert ){
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Bhor > Bvert ) {
                BFhor  = FrameHeight * WEBEXTSCALL;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBEXTSCALL;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p11, p13, p14, BFhor, BFvert, BFrad, p23, p24, Btxt );
            break;

        default:
            construct_corner( p13, p23, p24 );
            break;
    }

    /* Connect points */
    /* Place end line */
    placeLine( GRid_list, &grCount, p22, p24, 0, 0 );
    placeLine( GRid_list, &grCount, p21, p19, 0, 0 );

    /* place top flange */
    if( BeamType == FLAT || BeamType == BTEE )
        placeLine( GRid_list, &grCount, p12, p17, 0, 0 );
    else
        construct_top_flange( p12, p17, 0.0 );

    /* place bottom flange */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == TEE || BeamType == BULB )
        placeLine( GRid_list, &grCount, p11, p23, 0, 0 );
    else
        construct_bottom_flange( p11, p23, FlCut );

    construct_label();

    /* Place Dimensions */
    if(WebAngle != 90 ) {
        if( WebAngle > 90 )
            dim_pos = DIM_BELOW;
        else if( WebAngle < 90 )
            dim_pos = DIM_ABOVE;
        sprintf( txt, "%.0f", WebAngDist );
        place_linear_dim( GRid_list, &grCount, p13, p14, dim_pos, DIM_TXT_INSIDE, txt, 6.0);
    }

    /* Place bottom feature dimension */
    if( Bhor != Bvert ) {
        if( Bhor > Bvert ) {
            sprintf( txt, "%.0f", Bhor );
            place_linear_dim( GRid_list, &grCount, p13, p23, DIM_BELOW, DIM_TXT_INSIDE, txt, 3.0);
        }
    }

    if( Flip == -1 )
        dim_pos = DIM_LEFT;
    else
        dim_pos = DIM_RIGHT;
    sprintf( txt, "%.0f", CopeDepth );
    place_linear_dim ( GRid_list, &grCount, p37, p18, dim_pos, DIM_TXT_INSIDE, txt, 5.0);

    /* Place stock line */
    //    if(Stock > 0.1 && Sim )
    //      drawstock();

    /* If top flange is sniped, place a piece to show the delta */
    drawTopFlgSnipeDelta();

    /* if bottom flange is sniped, place a piece to show the delta */
    if (BeamType == ITEE)
    drawBotFlgSnipeDelta();

}

/* ========================================================================= *
 *
 *     JOG CUT
 *
 * ========================================================================= */

jog_cut()
{
    double tmp[3], aux[3], varX, varY;

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();


    /* Construct top feature - external points will be:
           p21 - left connect point
           p22 - right connect point */

    construct_jog( p12, p14, p13, FrameWidth * 0.5, FrameHeight * 0.75, FrameHeight * 0.15, FrameHeight * 0.05, CopeRad, p21, p22 );

    /* Construct bottom feature - external connect points will be:
           p23 - left connect point
           p24 - right connect point */

    construct_corner( p13, p23, p24 );

    /* Connect points */

    /* Place end line */
    placeLine( GRid_list, &grCount, p22, p24, 0, 0 );

    /* place top flange */
    if( BeamType == FLAT || BeamType == BTEE )
        placeLine( GRid_list, &grCount, p12, p21, 0, 0 );
    else
        construct_top_flange( p12, p21, FlCut );

    /* place bottom flange */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == TEE || BeamType == BULB )
        placeLine( GRid_list, &grCount, p11, p23, 0, 0 );
    else
        construct_bottom_flange( p11, p23, FlCut );

    construct_label();

    /* Place Dimensions */
    /*
    if(WebAngle != 90 ) {
        if( WebAngle > 90 )
            dim_pos = DIM_BELOW;
        else if( WebAngle < 90 )
            dim_pos = DIM_ABOVE;
        sprintf( txt, "%.0f", WebAngDist );
        place_linear_dim( GRid_list, &grCount, p13, p14, dim_pos, DIM_TXT_INSIDE, txt, 6.0);
        } */
    /* Place Dimensions */
    /*
    if( Flip == 1 )
        dim_pos = DIM_RIGHT;
    else
        dim_pos = DIM_LEFT;
    sprintf( txt, "%.0f", Bvert );
    place_linear_dim( GRid_list, &grCount, p13, p22, dim_pos, DIM_TXT_INSIDE, txt, 3.0);
    */

    /* Place stock line */
    //    if(Stock > 0.1)
    //        drawstock();

    /* If top flange is sniped, place a piece to show the delta */
    drawTopFlgSnipeDelta();

    /* if bottom flange is sniped, place a piece to show the delta */
    if (BeamType == ITEE)
    drawBotFlgSnipeDelta();
}


/* ========================================================================= *
 *
 *     TRANSITION GOING DOWN CUT
 *
 * ========================================================================= */

trans_down_cut()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;
    double TFhor, TFvert, TFrad, BFhor, BFvert, BFrad;
    int dim_pos;
    char Ttxt[10], Btxt[10];

    sprintf( Ttxt, "%.0f", Trad );
    sprintf( Btxt, "%.0f", Brad );

    /* Place frame & boundary points */
    construct_frame_points();
    construct_boundary_points();

    /* Construct top feature - external points will be:
           p21 - left connect point
           p22 - right connect point */

    switch ( Ttype ) {
        case 0:
            construct_corner( p14, p21, p22 );
            break;

        case 1:
            if( Thor == Tvert ) {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else if (Thor > Tvert ) {
                TFhor  = WEBBIGSNIPE * FrameWidth;
                TFvert = WEBSNIPE * FrameHeight;
            }
            else {
                TFhor  = WEBSNIPE * FrameWidth;
                TFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p12, p14, p13, TFhor, TFvert, p21, p22 );
            construct_snipe_dimension( p14, p21, p22, Thor, Tvert, TOP );
            break;

        case 2:
            if( Thor == Tvert ){
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else if ( Thor > Tvert ) {
                TFhor  = FrameHeight * WEBEXTSCALL;
                TFvert = FrameHeight * WEBSCALLOP;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            else {
                TFhor  = FrameHeight * WEBSCALLOP;
                TFvert = FrameHeight * WEBEXTSCALL;
                TFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p12, p14, p13, TFhor, TFvert, TFrad, p21, p22, Ttxt );
            break;

        default:
            construct_corner( p14, p21, p22 );
            break;
    }

    /* Construct bottom feature - external connect points will be:
           p23 - left connect point
           p24 - right connect point */

    switch ( Btype ) {
        case 0:
            construct_corner( p13, p23, p24 );
            break;

        case 1:
            if( Bhor == Bvert ){
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            } else if (Bhor > Bvert ) {
                BFhor  = WEBBIGSNIPE * FrameWidth;
                BFvert = WEBSNIPE * FrameHeight;
            } else {
                BFhor  = WEBSNIPE * FrameWidth;
                BFvert = WEBBIGSNIPE * FrameHeight;
            }
            construct_snipe( p11, p13, p14, BFhor, BFvert, p23, p24 );
            construct_snipe_dimension( p13, p23, p24, Bhor, Bvert, BOTTOM );
            break;

        case 2:
            if( Bhor == Bvert ){
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            } else if ( Bhor > Bvert ) {
                BFhor  = FrameHeight * WEBEXTSCALL;
                BFvert = FrameHeight * WEBSCALLOP;
                BFrad  = FrameHeight * WEBSCALLOP;
            } else {
                BFhor  = FrameHeight * WEBSCALLOP;
                BFvert = FrameHeight * WEBEXTSCALL;
                BFrad  = FrameHeight * WEBSCALLOP;
            }
            construct_scallop( p11, p13, p14, BFhor, BFvert, BFrad, p23, p24, Btxt );
            break;

        default:
            construct_corner( p13, p23, p24 );
            break;
    }

    /* Place stock line */
    //    if(Stock > 0.1)
    //      drawstock();

    /* If top flange is sniped, place a piece to show the delta */
    drawTopFlgSnipeDelta();

    /* if bottom flange is sniped, place a piece to show the delta */
    if (BeamType == ITEE)
    drawBotFlgSnipeDelta();

}
/* ========================================================================= */ 

webas_flg()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;
    int orient;
    double  dbl_temp, WebRatio, FlgRatio, FeatureRatio, Ratio, Dim;
    double TopSetBack, BottSetBack;
    char label[20];


    /* p1 - origin */
    v_equal( mcorigin , p1 );

    /* p2 top point */
    varY = FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p1, tmp, p2 );

    FlgRatio = FLGCUT;
    FeatureRatio = WEBSNIPE;

    /* place top and bottom points */

    if( WebAngle == 90 ) {
        TopSetBack = 1;
        BottSetBack = 1;
    }
    else if( WebAngle < 90 ) {
        TopSetBack = 0.85;
        BottSetBack = 1;
    }
    else {
        TopSetBack = 1;
        BottSetBack = 0.85;
    }

    Ratio = (FlgRatio + FeatureRatio) * 1.5 ;

    varX = Flip * (1-Ratio) * FrameWidth;
    varY = Flip * (1-Ratio) * FrameWidth;

    printf("varX = %f\tvarY = %f\n", varX, varY );

    /* p3 top right point */
    v_scale( mcxvec, varX, tmp );
    v_add( p2, tmp, p3 );

    /* p6 bottom right point */
    v_scale( mcxvec, varY, tmp );
    v_add( p1, tmp, p6 );

    /* place points for snipe */

    /* p14 top flange cut point, used to create p4 */
    varY = - FLGSNIPE * FrameHeight * 1.3 ;
    v_scale( mcyvec, varY, tmp );
    v_add( p3, tmp, p14 );

    /* p4 top flange snipe point */
    varX = Flip * Ratio * FrameWidth * TopSetBack;
    v_scale( mcxvec, varX, tmp );
    v_add( p14, tmp, p4 );

    /* p15 bottom flange cut point, used to create p5 */
    varY = FLGSNIPE * FrameHeight * 1.3 ;
    v_scale( mcyvec, varY, tmp );
    v_add( p6, tmp, p15 );

    /* p5 bottom flange snipe point */
    varX = Flip * Ratio * FrameWidth * BottSetBack;
    v_scale( mcxvec, varX, tmp );
    v_add( p15, tmp, p5 );

    /* Connect Points */
    placeLine ( GRid_list, &grCount, p2, p3, 0, 0 );
    placeLine ( GRid_list, &grCount, p6, p1, 0, 0 );
    placeLine ( GRid_list, &grCount, p3, p4, 0, 0 );
    placeLine ( GRid_list, &grCount, p4, p5, 0, 0 );
    placeLine ( GRid_list, &grCount, p5, p6, 0, 0 );

    /* PLACE LABEL */

    /* p51 bottom label height point */
    varY = 0.5 * FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p1, tmp, p51 );

    /* p52 bottom label point */
    varX = Flip * 0.3 * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p51, tmp, p52 );

    /* p53 top label point */
    /*
    varY = 0.3 * FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p52, tmp, p53 );
    */
    /* p54 bottom label point */
    //varX = Flip * 0.25 * FrameWidth;
    /*
    varX = 0.25 * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p53, tmp, p54 );
    */

    if(Stock > 0.1) {
        strcpy( label, BottLabel );
        strcat( label, " S" );
    }
    else
        strcpy( label, BottLabel );

    //place_label( GRid_list, &grCount, p53, TopLabel, dim_txt_ht, txt_cs );
    place_label( GRid_list, &grCount, p52, label, dim_txt_ht, txt_cs);

    
    /* PLACE DIMENSIONS */

    /* Place dimension if flange corners are not equal */
    Dim = BeamHeight - Bvert - Tvert;
    /*
    if( FlSn < 0.1 && LFlSn != RFlSn ) {
        sprintf(txt, "%.0f", LFlSn);
        if (WebSn > 0.1)
            place_linear_dim( GRid_list, &grCount, p3, p17, orient, 0, txt, 5.0);
        else
            place_linear_dim( GRid_list, &grCount, p3, p6, orient, 0, txt, 5.0);

        orient = 1;
        sprintf(txt, "%.0f", RFlSn);
        if (WebSn > 0.1)
            place_linear_dim( GRid_list, &grCount, p6, p18, orient, 0, txt, 5.0);
        else
            place_linear_dim( GRid_list, &grCount, p6, p3, orient, 0, txt, 5.0);

    }
    */
    /* Place nose dimension */ 
    if( Flip == -1 )
        orient = 3;
    else
        orient = 2;
    sprintf(txt, "%.0f", Dim );
    place_linear_dim( GRid_list, &grCount, p4, p5, orient, 0, txt, 3.0);

    if( WebAngle < 90 )
        orient = 0;
    else if( WebAngle > 90 )
        orient = 1;
    Dim = Dim*tan((fabs(90 - WebAngle) * PI / 180) );
    sprintf(txt, "%.0f", Dim);
    place_linear_dim( GRid_list, &grCount, p4, p5, orient, 2, txt, 4.0);
}



/* ========================================================================= */ 

construct_corner( crnr_pt, opt1, opt2 )
double *crnr_pt, *opt1, *opt2;
{
    /* Connect the points for the top corner feature */
    v_equal( crnr_pt, opt1 );
    v_equal( crnr_pt, opt2 );
}

/* ========================================================================= */

construct_snipe( lpt1, crnr_pt, lpt2, len1, len2, opt1, opt2 )
double *lpt1, *lpt2, *crnr_pt, len1, len2, *opt1, *opt2;
{
    double tmp[3], vec_line1[3], vec_line2[3];

    /* construct vectors between points */
    vec_along_line( crnr_pt, lpt1, vec_line1 );
    vec_along_line( crnr_pt, lpt2, vec_line2 );

    /* point along line1 */
    v_scale( vec_line1, len1, tmp );
    v_add( crnr_pt, tmp, opt1 );

    /* point along line2 */
    v_scale( vec_line2, len2, tmp );
    v_add( crnr_pt, tmp, opt2 );

    /* connect snipe points */
    placeLine( GRid_list, &grCount, opt1, opt2, 0,0 );
//    placeLine( GRid_list, &grCount, lpt1, crnr_pt, 0,0 );
//    placeLine( GRid_list, &grCount, lpt2, crnr_pt, 0,0 );
}

/* ========================================================================= */

construct_jog( lpt1, crnr_pt, lpt2, len1, len2, dpth, rad, rad_dim, opt1, opt2 )
double *lpt1, *lpt2, *crnr_pt, len1, len2, dpth, rad, rad_dim, *opt1, *opt2;
{
    double tmp[3], vec_line1[3], vec_line2[3];
    double tpt1[3], tpt2[3], tpt3[3], tpt4[3];
    int dim_pos;

    /* construct vectors between points */
    vec_along_line( crnr_pt, lpt1, vec_line1 );
    vec_along_line( crnr_pt, lpt2, vec_line2 );

    /* point along line1 */
    v_scale( vec_line1, len1, tmp );
    v_add( crnr_pt, tmp, opt1 );

    /* point along line2 */
    v_scale( vec_line2, len2, tmp );
    v_add( crnr_pt, tmp, opt2 );

    /* depth point along line2 */
    v_scale( vec_line2, dpth, tmp );
    v_add( opt1, tmp, tpt1 );

    /* place fillet and dimension it */
    fillet_pts(opt1, tpt1, opt2, rad, tpt3, tpt2, tpt4);
    create_arc_by_center( GRid_list, &grCount, tpt3, tpt2, tpt4, 1, 0, 0);

    sprintf(txt, "%.0f", rad_dim);
    place_radial_dim ( GRid_list, &grCount, rad, txt, tpt2, tpt3, tpt4, 1.0, Flip );

    /* dimension jog depth */
    if( Flip == 1 )
        dim_pos = DIM_RIGHT;
    else
        dim_pos = DIM_LEFT;
    sprintf(txt, "%.0f", Tvert);
    place_linear_dim( GRid_list, &grCount, opt1, tpt1, dim_pos, DIM_TXT_INSIDE, txt, 3.0);


    /* connect snipe points */
    placeLine( GRid_list, &grCount, opt1, tpt2, 0,0 );
    placeLine( GRid_list, &grCount, tpt4, opt2, 0,0 );
}

/* ========================================================================= */

construct_scallop( lpt1, crnr_pt, lpt2, len1, len2, rad, opt1, opt2, txt )
double *lpt1, *lpt2, *crnr_pt, len1, len2, rad, *opt1, *opt2;
char   *txt;
{
    double tmp1[3], tmp2[3], vec_line1[3], vec_line2[3], aux[3];
    double ap1[3], ap2[3], ap3[3], int_pt[3], angle, ratio1, ratio2;

    angle_3_pts( lpt1, crnr_pt, lpt2, &angle );
    ratio1 = len1 - rad + rad / cos( angle - PI / 2 );
    ratio2 = len2 - rad + rad / cos( angle - PI / 2 );

    /* construct vectors between points */
    vec_along_line( crnr_pt, lpt1, vec_line1 );
    vec_along_line( crnr_pt, lpt2, vec_line2 );

    /* point along line1 */
    v_scale( vec_line1, ratio1, tmp1 );
    v_add( crnr_pt, tmp1, opt1 );

    /* point along line2 */
    v_scale( vec_line2, ratio2, tmp2 );
    v_add( crnr_pt, tmp2, opt2 );

    /* intersection point */
    v_comb( len1, vec_line1, len2, vec_line2, aux );
    v_add( crnr_pt, aux, int_pt );

    fillet_pts( opt1, int_pt, opt2, rad, ap3, ap1, ap2 );

//    placeLine( GRid_list, &grCount, int_pt, ap1, 0, 0 );
//    placeLine( GRid_list, &grCount, int_pt, ap2, 0, 0 );
//    placeLine( GRid_list, &grCount, ap3, ap1, 0, 0 );
//    placeLine( GRid_list, &grCount, ap3, ap2, 0, 0 );

    /* Place scallop */
    create_arc_by_center ( GRid_list, &grCount, ap3, ap1, ap2, 1, 0, 0);
    placeLine( GRid_list, &grCount, opt2, ap2, 0, 0 );
    placeLine( GRid_list, &grCount, opt1, ap1, 0, 0 );

    /* Place scallop dimension */
    place_radial_dim ( GRid_list, &grCount, rad, txt, ap1, ap3, ap2, 1.0, Flip );
}

/* ========================================================================= */

construct_rect_cut( lpt1, crnr_pt, lpt2, len1, len2, opt1, opt2, opt3 )
double *lpt1, *lpt2, *crnr_pt, len1, len2, *opt1, *opt2, *opt3;
{
    double tmp[3], vec_line1[3], vec_line2[3], int_pt[3];

    /* construct vectors between points */
    vec_along_line( crnr_pt, lpt1, vec_line1 );
    vec_along_line( crnr_pt, lpt2, vec_line2 );

    /* point along line1 */
    v_scale( vec_line1, len1, tmp );
    v_add( crnr_pt, tmp, opt1 );

    /* point along line2 */
    v_scale( vec_line2, len2, tmp );
    v_add( crnr_pt, tmp, opt2 );

    /* intersection point */
    v_comb( len1, vec_line1, len2, vec_line2, tmp );
    v_add( crnr_pt, tmp, opt3 );

    /* connect snipe points */
    placeLine( GRid_list, &grCount, opt1, opt3, 0,0 );
}

/* ========================================================================= */

construct_rect_cut_scallop( p1, pc, p2, rad )
double *p1, *pc, *p2, rad;
{
    double tmp[3], vec_line1[3], vec_line2[3], int_pt[3];
    double tp1[3], tp2[3], tp3[3];

    /* construct vectors between points */
    vec_along_line( pc, p1, vec_line1 );
    vec_along_line( pc, p2, vec_line2 );

    /* Add center point */
    v_scale( vec_line2, rad, tmp );
    v_add( pc, tmp, tp1 );

    /* Add end sweep point */
    v_scale( vec_line2, rad, tmp );
    v_add( tp1, tmp, tp2 );

    /* Add mid sweep point */
    v_scale( vec_line1, -rad, tmp );
    v_add( tp1, tmp, tp3 );

    /* Place scalop */
    create_arc_by_center (GRid_list, &grCount, tp1, pc, tp3, 1, 0, 0);
    create_arc_by_center (GRid_list, &grCount, tp1, tp3, tp2, 1, 0, 0);

    /* Set external points */
    v_equal( tp2, pc );
}

/* ========================================================================= */

construct_snipe_dimension( cntr_pt, start_pt, end_pt, len1, len2, position )
double *cntr_pt, *start_pt, *end_pt, len1, len2;
int     position;
{
    double mid_pt[3], dist;
    int dim_pos, flip;

    if( len1 == len2 ) {
        find_mid_pt( start_pt, end_pt, mid_pt );
        sprintf( txt, "SN %.0f", len1 );
        place_snipe_dim( GRid_list, &grCount, dist_2_pts(mid_pt, cntr_pt)/2, txt,
                         start_pt, cntr_pt, end_pt, 3.0, Flip );
    }
    else {
        if( Flip == 1 )
            dim_pos = DIM_RIGHT;
        else
            dim_pos = DIM_LEFT;

        if( position == BOTTOM ) {
            sprintf( txt, "%.0f", len1 );
            place_linear_dim( GRid_list, &grCount, p23, p24, DIM_BELOW, DIM_TXT_INSIDE, txt, 3.0 );
            sprintf( txt, "%.0f", len2 );
            place_linear_dim( GRid_list, &grCount, p23, p24, dim_pos, DIM_TXT_INSIDE, txt, 3.0 );
        }
        else {
            sprintf( txt, "%.0f", len1 );
            place_linear_dim( GRid_list, &grCount, p21, p22, DIM_ABOVE, DIM_TXT_INSIDE, txt, 3.0 );
            sprintf( txt, "%.0f", len2 );
            place_linear_dim( GRid_list, &grCount, p21, p22, dim_pos, DIM_TXT_INSIDE, txt, 3.0 );
        }
    }
}

/* ========================================================================= */

construct_label()
{
    double varX, varY, tmp[3];
    char label[20];

    /* PLACE LABEL */

    /* p51 bottom label height point */
    varY = 0.5 * FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p11, tmp, p51 );

    /* p52 bottom label point */
    varX = Flip * 0.3 * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p51, tmp, p52 );

    /* p53 top label point */
    /*
    varY = 0.3 * FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p52, tmp, p53 );
    */
    /* p54 bottom label point */
    //varX = Flip * 0.25 * FrameWidth;
    /*
    varX = 0.25 * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p53, tmp, p54 );
    */

    if(Stock > 0.1) {
        strcpy( label, BottLabel );
        strcat( label, " S" );
    }
    else
        strcpy( label, BottLabel );

    //place_label( GRid_list, &grCount, p53, TopLabel, dim_txt_ht, txt_cs );
    place_label( GRid_list, &grCount, p52, label, dim_txt_ht, txt_cs);

    return;
}


/* ========================================================================= */

construct_top_flange( lpt1, lpt2, cope )
double *lpt1, *lpt2, cope;
{
    double scale, tmp[3], varX, varY;
    char   txt[30];

    if( cope != 0.0 )
        scale = FLGCUT;
    else
        scale = 0;

#ifdef DEBUG
    printf("FLGCUT = %f\tSCALE = %f\tCOPE = %f\n", FLGCUT, scale, cope );
#endif

    /* p36 - bottom right point */
    varX = Flip * -FrameWidth * scale;
    v_scale( mcxvec, varX, tmp );
    v_add( lpt2, tmp, p36 );

    /* p37 - top right point */
    varY = FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( p36, tmp, p37 );

    /* p38 - top left point */
    varY = FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( lpt1, tmp, p38 );

    /* Connect points */
    placeLine( GRid_list, &grCount, p37, p38, 0, 0 );
    placeLine( GRid_list, &grCount, p36, lpt2, 0, 0 );

    if ( FlgDelta == 0.0 )
        placeLine( GRid_list, &grCount, p37, p36, 0, 0 );

    if( BeamType == TEE || BeamType == ITEE )
        placeLine( GRid_list, &grCount, lpt1, p36, 0, 0 );
    else
        placeLine( GRid_list, &grCount, lpt1, p36, 2, 0 );

    sprintf( txt, "%f", cope );

    /* ADD FLG CUT */
    if ( txt[0] == '-' ) {
        /* p39 - bottom snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p36, tmp, p39 );

        /* p40 - top snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p37, tmp, p40 );

        placeLine( GRid_list, &grCount, p39, p40, 0, 0 );
    }

    /* PLACE DIMENSION */
    if( cope != 0.0 ) {
        sprintf( txt, "%.0f", fabs(cope) );
        place_linear_dim( GRid_list, &grCount, p37, p21, DIM_ABOVE, DIM_TXT_INSIDE, txt, 6.0 );
    }
}

/* ========================================================================= */

construct_bottom_flange( lpt1, lpt2, cope )
double *lpt1, *lpt2, cope;
{
    double scale, tmp[3], varX, varY;
    char   txt[30];

    if( FlCut != 0.0 )
        scale = FLGCUT;
    else
        scale = 0;

#ifdef DEBUG
    printf("FLGCUT = %f\tSCALE = %f\n", FlCut, scale );
#endif

    /* p31 - bottom right point */
    varX = Flip * -FrameWidth * scale;
    v_scale( mcxvec, varX, tmp );
    v_add( lpt2, tmp, p31 );

    /* p32 - top right point */
    varY = -FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( p31, tmp, p32 );

    /* p33 - top left point */
    varY = -FrameHeight * FLGTHK;
    v_scale( mcyvec, varY, tmp );
    v_add( lpt1, tmp, p33 );

    /* Connect points */
    placeLine( GRid_list, &grCount, p32, p33, 0, 0 );
    placeLine( GRid_list, &grCount, p31, lpt2, 0, 0 );

    if (FlgDelta == 0) {
        placeLine( GRid_list, &grCount, p32, p31, 0, 0 );
    }

    if( BeamType == ITEE )
        placeLine( GRid_list, &grCount, lpt1, p31, 0, 0 );
    else if( BeamType == PIPE )
        placeLine( GRid_list, &grCount, lpt1, p31, 2, 0 );

    sprintf( txt, "%f", cope );

    /* ADD FLG CUT */
    if ( txt[0] == '-' )
    {
        /* p34 - bottom snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p31, tmp, p34 );

        /* p35 - top snipe point */
        varX = Flip * -FrameWidth * FLGSNIPE;
        v_scale( mcxvec, varX, tmp );
        v_add( p32, tmp, p35 );

        placeLine( GRid_list, &grCount, p34, p35, 0, 0 );
    }

}


/* ========================================================================= */
PlaceDimensions()
{

    int orient;
    double ThorStock;

    /* place top feature dimensions */

    switch( Ttype ) {
        case 2:
            if (Thor == Tvert) {
                if( Trad != 0 )
                    sprintf(txt, "%.0f", Trad);
                else
                    sprintf(txt, "%.0f", Thor);
                place_radial_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p3, p4, p5, 1.0, Flip );
            }
            else if (Thor > Tvert) {
                if( Trad != 0 )
                    sprintf(txt, "%.0f", Trad);
                else
                    sprintf(txt, "%.0f", Tvert);
                place_radial_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p3, p19, p20, 1.0, Flip );

                if (Stock > 0) {
                    ThorStock = Thor + Stock;
                }
                else {
                    ThorStock = Thor;
                }

                sprintf(txt, "%.0f", ThorStock);
                place_linear_dim (GRid_list, &grCount, p3, p4, 0, 1, txt, 3.0);
            }
            else if (Tvert > Thor) {
                if( Trad != 0 )
                    sprintf(txt, "%.0f", Trad);
                else
                    sprintf(txt, "%.0f", Thor);
                place_radial_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p5, p20, p19, 1.0, Flip );
                sprintf(txt, "%.0f", Tvert);
                if( Flip == 1 )
                    orient = 2;
                else
                    orient = 3;
                place_linear_dim (GRid_list, &grCount, p5, p4, orient, 2, txt, 3.0);
            }
            break;
        case 1:
            sprintf(txt, "SN %.0f", Thor);
            place_snipe_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p3, p4, p5, 1.0, Flip );
            break;
/*
  sprintf(txt, "%.0f", Tvert);
  place_linear_dim (GRid_list, &grCount, p5, p3, 2, 2, txt, 3.0);
  sprintf(txt, "%.0f", Thor);
  place_linear_dim (GRid_list, &grCount, p5, p3, 0, 0, txt, 3.0);
  break;
*/
    }

    /* place bottom feature dimensions */
    if (Btype == 2) {
        if (Bhor == Bvert) {
            if( Brad != 0 )
                sprintf(txt, "%.0f", Brad);
            else
                sprintf(txt, "%.0f", Bhor);
            place_radial_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p6, p7, p8, 1.0, Flip );
        }
        else if (Bhor > Bvert) {
            if( Brad != 0 )
                sprintf(txt, "%.0f", Brad);
            else
                sprintf(txt, "%.0f", Bvert);
            place_radial_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p8, p22, p23, 1.0, Flip );
            sprintf(txt, "%.0f", Bhor);
            place_linear_dim (GRid_list, &grCount, p8, p7, 1, 1, txt, 3.0);
        }
        else if (Bvert > Bhor) {
            if( Brad != 0 )
                sprintf(txt, "%.0f", Brad);
            else
                sprintf(txt, "%.0f", Bhor);
            place_radial_dim ( GRid_list, &grCount, (FEATSIZE*FrameHeight), txt, p6, p22, p23, 1.0, Flip );
            sprintf(txt, "%.0f", Bvert);
            if( Flip == 1 )
                orient = 2;
            else
                orient = 3;
            place_linear_dim (GRid_list, &grCount, p6, p7, orient, 1, txt, 3.0);
        }
    }
    else if (Btype == 1) {
        sprintf(txt, "%.0f", Bvert);
        place_linear_dim (GRid_list, &grCount, p6, p8, 2, 1, txt, 3.0);
        sprintf(txt, "%.0f", Bhor);
        place_linear_dim (GRid_list, &grCount, p6, p8, 1, 1, txt, 3.0);
    }

    /* dimension flange cut back */
    if (ETType == 0 || ETType == 1 || ETType == 4) {
        if (FlCut != 0) {
            sprintf(txt, "%.0f", FlCut);
            place_linear_dim (GRid_list, &grCount, p17, p4, 0, 1, txt, 3.0);
        }
    }
    else {
        if (FlCut != 0 && ETType != 2 ) {
            sprintf(txt, "%.0f", FlCut);
            place_linear_dim (GRid_list, &grCount, p17, p9, 0, 1, txt, 3.0);
        }
    }

    if (BeamType == CHAN || BeamType == ITEE) {
        sprintf(txt, "%.0f", FlCut);
        place_linear_dim (GRid_list, &grCount, p33, p7, 1, 1, txt, 3.0);
    }
    /* place web angle distance dimension */
    if (WebAngle > 90) {
        sprintf(txt, "%.0f", WebAngDist);
        place_linear_dim (GRid_list, &grCount, p7, p4, 1, 1, txt, 3.0);
    }
    else if (WebAngle < 90) {
        sprintf(txt, "%.0f", WebAngDist);
        place_linear_dim (GRid_list, &grCount, p7, p4, 0, 1, txt, 3.0);
    }
}

/* ========================================================================= */

construct_frame_points()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;

    /* PLACE FRAME POINTS */

    /* Left bottom point */
    v_equal( mcorigin , p1 );

    /* Left top point */
    varY = FrameHeight;
    v_scale( mcyvec, varY, tmp );
    v_add( p1, tmp, p2 );

    /* Right bottom point */
    varX = FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p1, tmp, p3 );

    /* Right top point */
    varX = FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p2, tmp, p4 );
}

/* ========================================================================= */

construct_boundary_points()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, top_fl_ratio, bot_fl_ratio;;

    /* PLACE BOUNDARY POINTS */

    /* p11 - origin */
    /* If no bottom flange put boundary on the origin */
    if( BeamType == FLAT || BeamType == ANGLE || BeamType == BULB || BeamType == TEE )
        bot_fl_ratio = 0;
    /* else raise it bt the FLGTHK */
    else
        bot_fl_ratio = FLGTHK;

    /* Place point */
    varY = FrameHeight * bot_fl_ratio;
    v_scale( mcyvec, varY, tmp );
    v_add( p1, tmp, p11 );

    /* p12 - left top point */
    /* If no top flange put boundary on the frame point */
    if( BeamType == FLAT || BeamType == BTEE )
        top_fl_ratio = 0;
    /* else raise it bt the FLGTHK */
    else
        top_fl_ratio = FLGTHK;

    /* Place point */
    varY = FrameHeight * top_fl_ratio;
    v_scale( mcyvec, varY, tmp );
    v_sub( p2, tmp, p12 );

    /* p14 - Top and p13 - Bottom right points depend on Web Angle */
    if (WebAngle == 90) {
        TopWebRatio = 1;
        BotWebRatio = 1;
    }
    else if (WebAngle > 90) {
        TopWebRatio = 1;
        BotWebRatio = (1-WEBANGLE);
    }
    else if (WebAngle < 90) {
        TopWebRatio = (1-WEBANGLE);
        BotWebRatio = 1;
    }
    corner_points( Flip * TopWebRatio * FrameWidth, Flip * BotWebRatio * FrameWidth, p14, p13 );
}

/* ========================================================================= */

int corner_points( top_width, bottom_width, top_pt, bottom_pt )
double top_width, bottom_width, *top_pt, *bottom_pt;
{
    double tmp[3], varX;

    /* top right point */
    varX = top_width;
    v_scale( mcxvec, varX, tmp );
    v_add( p12, tmp, top_pt );

    /* bottom right point */
    varX = bottom_width;
    v_scale( mcxvec, varX, tmp );
    v_add( p11, tmp, bottom_pt );

    return;
}

/* ========================================================================= */
drawstock()
{
    double tmp[3], aux[3], vec_line[3], varX, varY, varV;

    /* top stock point */
    varX = Flip * STOCK * FrameWidth;
    v_scale( mcxvec, varX, tmp );
    v_add( p22, tmp, p52);

    /* bottom stock point */
    varX = Flip * STOCK * FrameWidth;
    v_scale( mcxvec, varX, tmp);
    v_add( p24, tmp, p53);

    placeLine ( GRid_list, &grCount, p52, p53, 2, 0 );
    placeLine ( GRid_list, &grCount, p52, p22, 2, 0 );
    placeLine ( GRid_list, &grCount, p53, p24, 2, 0 );

}

/* ========================================================================= */

drawTopFlgSnipeDelta()
{
    double tmp[3], aux[3], vec_line[3], varX, varY;

    //printf("FlgDelta %f\t\tFlCut %f\n", FlgDelta, FlCut );

    if( fabs(FlgDelta) > 0.0 ) {
        //if( FlCut < 0.1 ) {
            /* top flange delta point */
            varX = Flip * FrameWidth * FLBIGSNIPE/5;
            v_scale( mcxvec, varX, tmp );
            v_add( p37, tmp, p54);

            /* bottom flange delta point */
            varX = Flip * FrameWidth * FLBIGSNIPE/5;
            v_scale( mcxvec, varX, tmp);
            v_add( p36, tmp, p55);

            placeLine ( GRid_list, &grCount, p37, p54, 0, 0 );
            placeLine ( GRid_list, &grCount, p54, p55, 0, 0 );
            placeLine ( GRid_list, &grCount, p55, p36, 0, 0 );
            //}
    }
}

/* ========================================================================= */

drawBotFlgSnipeDelta()
{
    double tmp[3], aux[3], vec_line[3], varX, varY;

    if (fabs(FlgDelta) > 0) {
        //if (FlCut < 0.1) {
            /* top flange delta point */
            varX = Flip * FrameWidth * FLBIGSNIPE/5;
            v_scale( mcxvec, varX, tmp );
            v_add( p32, tmp, p56);

            /* bottom flange delta point */
            varX = Flip * FrameWidth * FLBIGSNIPE/5;
            v_scale( mcxvec, varX, tmp);
            v_add( p31, tmp, p57);

            placeLine ( GRid_list, &grCount, p32, p56, 0, 0 );
            placeLine ( GRid_list, &grCount, p56, p57, 0, 0 );
            placeLine ( GRid_list, &grCount, p57, p31, 0, 0 );
            //}
    }
}

/* ========================================================================= */

drawTopFlgCut()
{
}
drawBotFlgCut()
{
}
drawTopCorner0()
{
}
drawBotCorner0()
{
}
drawBotCorner1()
{
}
drawBotCorner2()
{
}
