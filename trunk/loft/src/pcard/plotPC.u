/* $Id: plotPC.u,v 1.3 2002/02/07 18:40:51 ramarao Exp $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        loft/src/pcard/plotPC.u
 *
 * Description: PPL to automatically create plot files for all profile cards
 *	        in the design file.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: plotPC.u,v $
 *      Revision 1.3  2002/02/07 18:40:51  ramarao
 *      Fixed CR# 5920.
 *
 *      Revision 1.2  2001/10/05 14:13:18  ramarao
 *      Fixed TR# 5520, 5604, 5605, 5607.
 *
 *      Revision 1.1  2001/05/09 15:57:55  ramarao
 *      Implemented CR# 5185.
 *
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      04/27/01        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDsa.h"
#include "VDgeom.h"
#include "pidef.h"
#include "plotmacros.h"
#include "vlquerydef.h"

#define MAX_WINDOW      40

extern 	COcreate_plotfile(), VLgetMacrosAtStep(), EX_filename1(),
	VDosValidate(), VDpms_findall_ancestryobjects(), VLbrowseFctInTree(),
	VLfilterDef(), VD_findFileInDirOrProductPaths(), COget_fence_range(),
	VD_bulkDeleteByGRids(), VD_bulkDisplayByGRids();

extern IGRchar	*getenv();

extern GRclassid	OPP_VSbeam_class_id;

struct GRmd_env         cur_env;

struct pcmk_count {
  IGRint	pcmk_no;
  IGRint	count;
} ;

IGRint GetPcmkCount( array_count, pcmk_array, pcmk_no )
IGRint			*array_count;
struct pcmk_count	*pcmk_array;
IGRint			pcmk_no;
{
IGRint		i, pcmk_index;

    for( i=0; i<(*array_count); i=i+1 )
    {
        if( pcmk_array[i].pcmk_no == pcmk_no ) 
	{
	   pcmk_array[i].count = pcmk_array[i].count + 1 ;
	   pcmk_index = pcmk_array[i].count ;
	   break;
        }
    }

    if( i == (*array_count) )
    {
        pcmk_array[(*array_count)].pcmk_no = pcmk_no ;
	pcmk_array[(*array_count)].count = 1;
	(*array_count) = (*array_count) + 1 ;
	pcmk_index = 1;
    }

    return pcmk_index;
}

CreatePlotFile( fp, border, filename, absColorPathName )
FILE		*fp;
struct GRid 	border;
IGRchar		*filename;
IGRchar		*absColorPathName;
{
BSrc			rc;
IGRlong                 sts, msg;
IGRshort                world;
IGRdouble               range[12];
IGRchar                 status[128];
struct GRid             model, windowId, fenceId;
struct GRobj_env        drwBrOv;
struct GRmd_env         model_env;
struct IGRcv_prism	*cvprism;

    cvprism = NULL; 

    sts = ci$send ( msg = message ACheader.ACfind_model
                                     ( &msg, &model),
                    targetid = border.objid,
                    targetos = border.osnum  );

    drwBrOv.mod_env = cur_env;

    sts = ci$send ( msg = message GRowner.GRget_matrix(
                             &msg,&drwBrOv.mod_env.md_env.matrix_type,
                             drwBrOv.mod_env.md_env.matrix,
                             &model_env.md_env.matrix_type,
                             model_env.md_env.matrix ),
                    targetid = border.objid,
                    targetos = border.osnum );

    world = TRUE;
    sts = ci$send ( msg = message VDlink.GRgetrang(
                             &msg, &model_env.md_env.matrix_type,
                             model_env.md_env.matrix,
                             &world, range ),
                    targetid = model.objid,
                    targetos = model.osnum  );

    range[0] = range[0] + 25.0 ;

    begincmd_key( "GRPRcFn" );   /* Place Rectangular Fence */
    ci$put( point = &range[0] );
    ci$put( point = &range[3] );
    endcmd();

    cvprism = NULL; 

    sts = plot$get_fence_range( msg = &msg, module = &cur_env, fence = &fenceId,
			        window = &windowId, world = range, view = &range[6],
			        cvprism = &cvprism );
    VD_bulkDisplayByGRids( &cur_env, GRbe, 1, &fenceId );
    VD_bulkDeleteByGRids( &cur_env, 1, &fenceId );
    
    plot$create_plotfile( 
		msg         = &msg,
                module      = &cur_env,
                dbtype      = "3d",
                range       = range,
                window      = &windowId,
		cvprism     = cvprism,
                plotfile    = filename,
                color_table = absColorPathName,
                status      = status );

    if( fp != NULL ) 
    {
	fprintf( fp, "<%s> --- %s\n", filename, status );
	fflush( fp );
    }

    if( cvprism ) { free( cvprism ); cvprism = NULL; }

    return;
}

main()
{
IGRlong			sts, msg, isConsumed;
IGRint			i, count, numObjects, pcmk_no, array_cnt, pcmk_index;
GRclassid		classid;
GRobjid			*list;
GRspacenum		osnum;
IGRchar                 filename[128], pcmk[40], queue_name[40],
			cur_file[128], unit_no[40], tmpString[40], *p,
			absColorPathName[1024], color_table[40], penName[40],
			printfile[40], logfile[40], absPenName[128];
struct GRid             border;
struct GRobj_env	beam, *list_obj;
struct pcmk_count	*pcmk_array;
FILE			*fp, *printfp;

  count = 0;
  list  = NULL;
  pcmk_array = NULL;

  numObjects = 0;
  list_obj = NULL;

  fp = NULL;
  printfp = NULL;

  printfile[0] = '\0';
  queue_name[0] = '\0';

  message( "Create Plot Files for Profile Cards" );

  ex$filename( name = cur_file, len = 128 );
  p = strrchr( cur_file, '/' ) ;
  strcpy( cur_file, p+1 );

  cur_file[4] = '\0';

  sprintf( tmpString, "Enter Unit Number[ %s ]", cur_file );

  status( "Press Enter to accept the default" );
  ci$get( prompt   = tmpString, string = unit_no );
  if( strlen(unit_no) != 4 ) strcpy( unit_no, cur_file );
  status( "" );

  while( 1 )
  {
    ci$get( prompt = "Would you like to create a script file for submitting plots? [y/n]",
	    string = tmpString );
    if( tmpString[0] == 'Y' || tmpString[0] == 'y' ||
        tmpString[0] == 'N' || tmpString[0] == 'n' ) break;
  }

  if( tmpString[0] == 'Y' || tmpString[0] == 'y' )
  {
     ci$get( prompt = "Enter the queue name", string = queue_name );
     if( queue_name[0] != '\0' )
     {
        status( "Press Enter to accept the default" );
        ci$get( prompt = "Enter qpr output File Name[ printPC.sh ]", 
	        string = printfile );
        if( strlen( printfile ) < 1 )  strcpy( printfile, "printPC.sh" );
        printfp = fopen( printfile, "w" );

        status( "Press Enter to accept the default" );
        strcpy( tmpString, "Enter pen File Name[ plotPC.pen ]" );
        ci$get( prompt   = tmpString, string = penName );
        if( penName[0] == '\0' ) strcpy( penName, "plotPC.pen" );
        VD_findFileInDirOrProductPaths( &msg, penName, ".", "config",
                                        absPenName ) ;
      }
  }

  status( "Press Enter to accept the default" );
  strcpy( tmpString, "Enter Color Table File Name[ bwplot.tbl ]" );
  while( 1 )
  {
     absColorPathName[0] = '\0' ;
     ci$get( prompt   = tmpString, string = color_table );
     if( strlen( color_table ) < 1 )  strcpy( color_table, "bwplot.tbl" );
     VD_findFileInDirOrProductPaths( &msg, color_table, ".", "config",
                                     absColorPathName ) ;
     if( absColorPathName[0] != '\0' ) break;
  }

  status( "Press Enter to accept the default" );

  ci$get( prompt = "Enter Log File Name[ pcplot.log ]", string = logfile );
  if( strlen( logfile ) < 1 )  strcpy( logfile, "pcplot.log" );

  status( "" );
  
  ci$get_module_info( md_env = &cur_env );
  classid = OPP_VSbeam_class_id ;

  for( osnum = 0; VDosValidate(osnum); osnum=osnum+1 )
  {
     count = 0;

     VDpms_findall_ancestryobjects( osnum, 1, &classid, &count, NULL );

     if( count < 1 ) continue;
  
     if( list ) { free( list ); list = NULL; }
   
     array_cnt = 0;
     if( pcmk_array ) { free( pcmk_array ); pcmk_array = NULL; }

     pcmk_array = ( struct pcmk_count * ) malloc( 
				count*sizeof( struct pcmk_count ) );
     if( pcmk_array == NULL ) goto wrapup;

     list = ( OM_S_OBJID * )malloc( count*sizeof(OM_S_OBJID) );
     if( list == NULL ) goto wrapup;

     VDpms_findall_ancestryobjects( osnum, 1, &classid, &count, list );

     for( i=0; i<count; i=i+1 )
     {
        isConsumed    = 0;

        sts = ci$send(  msg     = message NDmacro.ACtest_consumed( 
						&isConsumed ),
		     targetid = list[i],
		     targetos = osnum );
        if( !(sts&1) || isConsumed ) continue;

	beam.obj_id.objid = list[i];
        beam.obj_id.osnum = osnum;

	numObjects = 0;
	if( list_obj ) { free( list_obj ); list_obj = NULL; }
        VLbrowseFctInTree( &beam, VL_Q_TOP_SOURCE, NULL,
                VL_Q_DOWN_DIRECT,VLgetMacrosAtStep, &numObjects, &list_obj );
	if( numObjects < 1 ) continue;

        VLfilterDef(numObjects,list_obj,&numObjects,"PCardText");
	if( numObjects < 1 ) continue;

	vdobj$GetParent( objOE = &list_obj[0], idx = 1, parentID = &border );

        vdsa$GetStruct( objOE = &beam,
                        name = "SA_AST:StagingTree:0:pcmk",
                        txt   = pcmk );

        sprintf( tmpString, "Creating Plot Files for pcmk# %s", pcmk );
        status( tmpString );

	sscanf( pcmk, "%d", &pcmk_no );

	pcmk_index = GetPcmkCount( &array_cnt, pcmk_array, pcmk_no );

	//sprintf( filename, "sh%s_%s.plt", unit_no, pcmk );
	sprintf( filename, "%s_%.4d_%.2dpc.plt", unit_no, 
					pcmk_no, pcmk_index );

	if( fp == NULL ) fp = fopen( logfile, "w" );

	CreatePlotFile( fp, border, filename, absColorPathName );
        if( queue_name[0] != '\0' && printfp != NULL )
	{
	   if( absPenName[0] != '\0' )
	   {
	      fprintf( printfp, "qpr -q %s -t igds -o \" -e 8.5x14\" -e IPLOTSRV_DEFAULT_PEN_TABEL=%s %s\n", queue_name, absPenName, filename );
	   }
	   else
           {
              fprintf( printfp, "qpr -q %s -t igds -o \" -e 8.5x14\" %s\n",
                           queue_name, filename );
           }
	   fflush( printfp );
	}
     }
  }

  if( printfile[0] != '\0' )
  {
     sprintf( tmpString, "chmod +x %s", printfile );
     sh( tmpString );
  }

  p = getenv("PLOTSHEETS" );
  if( p != NULL )
  {
      sprintf( tmpString, "mv %s_* %s %s", unit_no, printfile, p );
      sh( tmpString );
  }

wrapup:
  if( list ) { free( list ); list = NULL; }
  if( pcmk_array ) { free( pcmk_array ); pcmk_array = NULL; }
  if( list_obj ) { free( list_obj ); list_obj = NULL; }
  if( fp != NULL ) fclose( fp );
  if( printfp != NULL ) fclose( printfp );
  return 1;
}
