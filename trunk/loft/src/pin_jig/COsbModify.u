/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/pin_jig/COsbPlace.u
 *
 * Description: PPL to place a steel band macro.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/23/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "nddef.h"
#include "ndmacros.h"
#include "VDchn.h"
#include "VDexp.h"
#include "VDefp.h"
#include "VDobj.h"
#include "coparamac.h"
#include "vlsband.h"
#include "vlquerydef.h"
#include "vldbgmacros.h"

#define vdsDEBUG	1
#define vdserrDEBUG	1

#define EXP_DOUBLE      0
#define MAX_FEET        200

#define COMMAND_NAME 		"Modify Steel Bands"
#define FORM_NAME		"VLsbMgr.frm"

Form				form;
struct CIform_st 		form_st;
IGRint				row, col, num_rows, nb_bndsrf, form_labels[60],
				form_displayed,form_exists, not_done, num_srfs,
				test_wakeup, neat_ft_count, recompute;
IGRchar         		msgStr[128], srf_name[128], job_no[128], 
				unit_no[128], job_desc[128];
struct GRmd_env			loc_env;
struct GRid			neat_cont, neat_feet[200], endpts[50];
struct GRobj_env		surface, srf_list[20], bndsrf[20], neatOE,
				st_band[100];
struct GRvg_construct   	cnst;

extern 	FIg_is_valid(), FIg_get_attr(), FIg_set_state_off(), 
	FIfld_set_active_row(), FIfld_set_value(), FIfld_set_text(),
	FImcf_set_select(), FImcf_get_active_col(), FIfld_pos_cursor(),
	FIfld_get_list_select(), FIg_get_state(), FIfld_set_line_color();

extern  VSsbGetBndSrfObjs(), VSbulkDisplayByGRobj_envs(), VLsbGetMoldSurface(),
	ASmake_source_from_env(), EX_get_global(), AClib_dir(), ASend_fence(),
	ACconstruct_path(), VDSloadMacroLibrary(), ASstart_var_fence(),
	VSbulkDisplayByGRids(), VLendpts(), VLsame_point(), dblcpy(), VLplPt(),
	VLinitCnst(), VLgetMacrosAtStep(), VLbrowseFctInTree(), VLfilterDef(),
	FIg_set_state_on(), NDwait_batch(), NDget_mod_batch(), NDexec_batch();

extern  GRclassid 	OPP_VSplate_class_id, OPP_GR3dpoint_class_id ;

IGRstat message_bar( inPrompt )
IGRchar         *inPrompt;
{
   FIg_set_text( form, G_MESSAGE_FIELD, inPrompt );	
   return 1;
}

DisableAllExceptCancel()
{
   IGRint       i, attr ;

   for( i=0; i<60; i=i+1 )
   {
       form_labels[i] = 0 ;
       if( i == FI_CANCEL ) 	continue;
       if( ! ( FIg_is_valid( form, i )) )
       {
          FIg_get_attr( form, i, &attr ) ;
          if( !( attr & FI_NOT_DISPLAYED ) )
          {
             FIg_disable( form, i );
             form_labels[i] = 1 ;
          }
       }
    }
}

EnableAllExceptCancel()
{
   IGRint       i;
   for( i=0; i<60; i=i+1 )
   {
       if( i == FI_CANCEL )  	continue;
       if( form_labels[i] ) FIg_enable( form, i );
   }
}

wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
        /* Display the form unless the command file is just starting */
        __DBGpr_int("I'm now waking up, test_wakeup",test_wakeup);
        if ( test_wakeup == 1 && not_done ) {
            if( form )
            {
                EnableAllExceptCancel();
                form_displayed = TRUE; /* Set flag for sleep function */
            }
        }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
        /* Erase the form if it is displayed */
        if ( form_displayed == TRUE ) {
                DisableAllExceptCancel();
                form_displayed = FALSE;
        }
}

delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
        int     i ;

        __DBGpr_int("form_displayed", form_displayed);
        __DBGpr_int("form_exists", form_exists);
        /* Erase the form if it is displayed */
        if ( form_displayed == TRUE ) {
                FIf_erase ( form );
                form_displayed = FALSE;
        }
        /* Delete the form if it exists */
        if ( form_exists ) {
                if( form ) {
  			VDahFrmSavePositionInFile(form);
  			if (form) VIf_delete(form);
  			form = NULL;
                }
        }
	for( i=0; i<num_rows; i=i+1 )
	  if( endpts[i].objid != NULL_OBJID )
	  {
     	      ci$send(msg = message GRvg.GRdelete( &msg, &loc_env ),
                        targetid = endpts[i].objid,
                        targetos = endpts[i].osnum );
	  }

        not_done = 0 ;
}

IGRint	GetName( object, name )
struct GRid		object;
IGRchar			*name;
{
   ci$send(  msg = message GRgraphics.GRgetname( &msg, name ),
		targetid = object.objid,
		targetos = object.osnum  );
}

IGRint check_dir()
{
IGRint		i, sel, pos, ok;
IGRchar		stat[128], dir1[28], dir2[128];

   for( i=0; i<num_rows; i=i+1 )
   {
      ok = 0;
      FIfld_get_text( form, G_BAND_MCF, i, 1, 128, stat, &sel, &pos );
      if( strcmp( stat, "" ) && atoi(stat) )
      {
	FIfld_get_text( form, G_BAND_MCF, i, 3, 128, dir1, &sel, &pos );
	if( strcmp( dir1, "" ) )
	{
	   FIfld_get_text( form, G_BAND_MCF, i, 4, 128, dir2, &sel, &pos );
	   if( strcmp( dir2, "" ) )
	   {
	     if( strcmp( dir1, dir2 ) )
	     {
		__DBGpr_str("First String ", dir1 );
		__DBGpr_str("Second String ", dir2 );
		if(   ( !strncmp( dir1, "FWD", 3 ) && 
				strncmp( dir2, "AFT", 3  ) ) || 
		      ( !strncmp( dir1, "AFT", 3 ) && 
				strncmp( dir2, "FWD", 3  ) ) || 
		      ( !strncmp( dir1, "IB", 2  ) && 
				strncmp( dir2, "OB", 2   ) ) || 
		      ( !strncmp( dir1, "OB", 2  ) && 
				strncmp( dir2, "IB", 2   ) ) || 
		      ( !strncmp( dir1, "UP", 2  ) && 
				strncmp( dir2, "DOWN", 4 ) ) || 
                      ( !strncmp( dir1, "DOWN", 4) && 
				strncmp( dir2, "UP", 2   ) ) )
		{
		   ok = 1;
		   sprintf( stat, "%d", i+1 );
		   FIfld_set_text( form, G_BAND_MCF, i, 0, stat, FALSE );
		}
	     }
	   }
	}
      }
      if( !ok ) FIfld_set_text( form, G_BAND_MCF, i, 0, "**", FALSE );
   }
   return 0;
}

IGRstat LocatePlates( inPrompt, num, list, single_pl )
IGRchar         *inPrompt;
IGRint		*num;
TGRobj_env	**list;
TGRobj_env	*single_pl;
{
IGRint		i, response, sts;
TGRobj_env	objOE;

   *num = 0;
   if( *list ) { free( *list ); *list = NULL; }
   single_pl->obj_id.objid = NULL_OBJID;

   DisableAllExceptCancel();

   if( num_srfs ) 
      VSbulkDisplayByGRobj_envs( GRhd, num_srfs, srf_list );

   sts = ci$locate(prompt  = inPrompt,
                   classes = "VSplate",
                   owner_action = LC_RIGID_OWNER |
                                  LC_RIGID_COMP  |
                                  LC_FLEX_COMP   |
                                  LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS,
                   stackable    = 1,
                   response     = &response,
                   md_env       = &objOE.mod_env,
                   obj          = &objOE.obj_id.objid,
                   osnum        = &objOE.obj_id.osnum);

   dp$erase_hilite( msg = &msg );

   if (!(sts & 1)) response = 0;

   switch(response) {

    case EX_OBJID:   // Object Set

      /* Grab Located Objects */
      as$start_fence(	set       = &objOE.obj_id,
			set_env   = &objOE.mod_env,
		 	nb_obj    = num,
			p_obj_env = list );
      ASend_fence();
      break;

    case EX_DATA:    // Single Object
      *single_pl = objOE ;
      break;

   } // Switch

   EnableAllExceptCancel();

   FIg_disable( form, G_ADD );
   FIg_disable( form, G_DELETE );
   FIg_disable( form, G_BAND_MCF );

   return 1;

}

IGRstat LocateOE( inPrompt, selOE, objName, check)
IGRchar         *inPrompt;
TGRobj_env      *selOE;
IGRchar         *objName;
IGRint          check;
{
  IGRint  		i, attr, response, labels[60] ;
  OM_S_CLASSLIST	eligibleClasses ;
  OMuword		classids[2] ;

        if( selOE->obj_id.objid != NULL_OBJID ) {
		VSbulkDisplayByGRobj_envs( GRhd, 1, selOE );
        }

        for( i=0; i<60; i=i+1 )
        {
           labels[i] = 0 ;
           if( ! ( FIg_is_valid( form, i )) )
           {
              FIg_get_attr( form, i, &attr ) ;
              if( !( attr & FI_NOT_DISPLAYED ) )
              {
                 FIg_disable( form, i );
                 labels[i] = 1 ;
              }
           }
        }

        classids[0] = OPP_VSplate_class_id ;

        eligibleClasses.w_count   = 1 ;
        eligibleClasses.w_flags   = OM_CLST_subclass ;
        eligibleClasses.p_classes = classids ;

        ci$locate(
                obj             = &selOE->obj_id.objid,
                osnum           = &selOE->obj_id.osnum,
                md_env          = &selOE->mod_env,
                response        = &response,
		eligible_classes= &eligibleClasses,
                prompt          = inPrompt,
                stackable       = TRUE ,
                properties      = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                owner_action    = LC_RIGID_COMP  | LC_RIGID_OWNER |
                                  LC_FLEX_COMP   | LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS );

        msgStr[0] = '\0' ;
        if( selOE->obj_id.objid != NULL_OBJID ) {
	 	GetName( selOE->obj_id, objName );
		__DBGpr_str("Returned name is ",objName);
        }

wrapup:
   return TRUE;
}

IGRint	GetProperIndex( str )
IGRchar		*str;
{

   switch( str[0] )
   {
	case  'A': return 1;
	case  'F': return 2;
	case  'I': return 3;
	case  'O': return 4;
	case  'D': return 5;
	case  'U': return 6;
   }
}	

IGRchar*	GetProperDirName( dir )
IGRint	dir;
{

   switch( dir )
   {
        case  1: return "AFT";
        case  2: return "FWD";
        case  3: return "IB";
        case  4: return "OB";
        case  5: return "DOWN";
        case  6: return "UP";
   }
}

IGRint FillEdgeInfo()
{
IGRlong		sts;
IGRint		i, dir;

  sts = vdchn$GetList(  objID   = &neat_cont,
                        chnIDx  = VDCHN_IDX_TO_COMPONENTS,
                        maxCnt  = MAX_FEET,
                        cnt     = &neat_ft_count,
			outIDs	= neat_feet );

  for( i=0; i<(neat_ft_count/2); i=i+1 )
  {
     vdexp$Get( objID = &neat_feet[2*i+1], jnt =&dir );
     FIfld_set_text( form, G_BAND_MCF, i, 3, GetProperDirName(dir), FALSE );
  }
  num_rows = neat_ft_count/2;

}

IGRint  CheckIfSteelBandModified( ind )
{
IGRint                  i, nb_attr, attr_change, cn_type, sel, pos,
			lines;
IGRchar                 macName[128], stat[128];
struct GRobj_env        boxOE;
struct ACrg_coll        attrib[NB_SB_ATTR];

   vdobj$GetTemplate( objID      = &st_band[ind].obj_id,
                      nth        = 1,
                      templateOE = &boxOE );

   ci$send ( msg =  message ACrg_collect.AClist_attribute( &msg,
                                NB_SB_ATTR, attrib, &nb_attr ),
                targetid = boxOE.obj_id.objid,
                targetos = boxOE.obj_id.osnum );

   attr_change = 0;

   FIg_get_text( form, G_UNIT_NUMBER, stat  );
   if( strcmp( attrib[IDX_SB_UNITNO].desc.value.att_txt, stat ) )
   {
        attr_change = 1;
        strcpy( attrib[IDX_SB_UNITNO].desc.value.att_txt, stat );
   }

   FIg_get_text( form, G_JOB_NUMBER, stat  );
   if( strcmp( attrib[IDX_SB_JOBNO].desc.value.att_txt, stat ) )
   {
        attr_change = 1;
        strcpy( attrib[IDX_SB_JOBNO].desc.value.att_txt, stat );
   }

   FIg_get_text( form, G_JOB_DESC, stat  );
   if( strcmp( attrib[IDX_SB_JOBDESC].desc.value.att_txt, stat ) )
   {
        attr_change = 1;
        strcpy( attrib[IDX_SB_JOBDESC].desc.value.att_txt, stat );
   }

   FIfld_get_text( form, G_BAND_MCF, ind, 1, 128, stat, &sel, &pos );
   if( strcmp( attrib[IDX_SB_BANDNO].desc.value.att_txt, stat ) )
   {
        attr_change = 1;
        strcpy( attrib[IDX_SB_BANDNO].desc.value.att_txt, stat );
   }

   FIfld_get_text( form, G_BAND_MCF, ind, 2, 128, stat, &sel, &pos );
   if( strcmp( attrib[IDX_SB_BANDDESC].desc.value.att_txt, stat ) )
   {
        attr_change = 1;
        strcpy( attrib[IDX_SB_BANDDESC].desc.value.att_txt, stat );
   }

   FIfld_get_text( form, G_BAND_MCF, ind, 5, 128, stat, &sel, &pos );
   if( fabs( attrib[IDX_SB_STOCK].desc.value.att_exp - atof(stat) ) > 0.0001 )
   {
        attr_change = 1;
        attrib[IDX_SB_STOCK].desc.value.att_exp = atof(stat);
   }

   recompute = 0 ;
   FIg_get_state( form, G_DATUM_LINES, &lines );
   if( ((int)attrib[IDX_SB_WATERLINES].desc.value.att_exp) != lines )
   {
	attrib[IDX_SB_WATERLINES].desc.value.att_exp = lines;
	attr_change = 1;
	recompute   = 1;
   }

   FIg_get_state( form, G_MARKING_LINES, &lines );
   if( ((int)attrib[IDX_SB_MARKINGLINES].desc.value.att_exp) != lines )
   {
        attrib[IDX_SB_MARKINGLINES].desc.value.att_exp = lines;
        attr_change = 1;
        recompute   = 1;
   }

   FIfld_get_text( form, G_BAND_MCF, ind, 4, 128, stat, &sel, &pos );
   if( strcmp( stat, 
	GetProperDirName((int)attrib[IDX_SB_START_DIR].desc.value.att_exp) ) )
   {
	attrib[IDX_SB_START_DIR].desc.value.att_exp = GetProperIndex( stat );
	attr_change = 1;
        recompute   = 1;
   }

   if( attr_change )
   {
        ci$send ( msg =  message ACrg_collect.ACmod_list_attribute( &msg,
                                                NB_SB_ATTR, attrib ),
                targetid = boxOE.obj_id.objid,
                targetos = boxOE.obj_id.osnum );
   }

   cn_type   = ND_COMP;
   if( recompute )
   {
        nd$wait_batch(  type       = GR_GEOM_POSTED,
                        nb_obj     = 1,
                        l_object   = &st_band[ind].obj_id,
                        l_obj_info = &cn_type );
   }
   return 1;
}

IGRint  ModifySteelBands()
{
IGRlong                 sts, msg;
IGRint                  i, sel, pos, b_mod;
IGRchar                 stat[128], mess[128];

   for( i=0; i<num_rows; i=i+1 )
   {
      FIfld_get_text( form, G_BAND_MCF, i, 0, 128, stat, &sel, &pos );
      if( !strcmp( stat, "**" ) ) break;
   }

   if( i < num_rows )
   {
      sprintf( mess, "Fix the problem in Row %d", i+1 );
      message_bar( mess );
      goto wrapup;
   }

   dp$erase_hilite( msg = &msg );
   for( i=0; i<num_rows; i=i+1 )   CheckIfSteelBandModified(i);

   if( recompute )
   {
     nd$mod_batch( request     = ND_INQ,
                   p_ret_mode  = &b_mod );
     if( b_mod != ND_DEFER ) nd$exec_batch();
   }

   return 1;

wrapup:
   return 0;
}


int FillDataInForm()
{
IGRint                  i, numObjects, nb_attr;
IGRchar                 macName[128], stock_str[128];
struct GRobj_env        tmp_objOE, boxOE, *list_obj;
struct ACrg_coll	attrib[NB_SB_ATTR];

   vdobj$Get  (objOE = &neatOE, macName = macName );
   if( !strcmp( macName, "steel_band" ) )
   {
      vdobj$GetTemplate( objID      = &neatOE.obj_id,
                         nth        = 0,
                         templateOE = &tmp_objOE );

      vdchn$GetList(  objOE   = &tmp_objOE,
                      chnIDx  = VDCHN_IDX_TO_OWNERS,
                      maxCnt  = 1,
                      cnt     = &i,
                      outIDs  = &neatOE );
   }
   __DBGpr_obj("Neat Contour Macro ", neatOE.obj_id );

   numObjects = 0;
   list_obj   = NULL;

   VLbrowseFctInTree( &neatOE, VL_Q_TOP_SOURCE, NULL, VL_Q_DOWN_DIRECT,
                      VLgetMacrosAtStep, &numObjects, &list_obj );
   VLfilterDef(numObjects,list_obj,&numObjects,"steel_band" );
   __DBGpr_int("Number Of Steel Band Macros ", numObjects );

   num_rows = numObjects;

   for( i=0; i<numObjects; i=i+1 )
   {	
	FIfld_set_text( form, G_BAND_MCF, i, 0, itoa(i+1), FALSE );
	st_band[i] = list_obj[i];
        vdobj$GetTemplate( objID      = &st_band[i].obj_id,
                           nth        = 1,
                           templateOE = &boxOE );

        ci$send ( msg =  message ACrg_collect.AClist_attribute( &msg,
                                NB_SB_ATTR, attrib, &nb_attr ),
                targetid = boxOE.obj_id.objid,
                targetos = boxOE.obj_id.osnum );
	if( i==0 )
	{
	   FIg_set_text( form, G_UNIT_NUMBER, 
				attrib[IDX_SB_UNITNO].desc.value.att_txt );
	   FIg_set_text( form, G_JOB_NUMBER, 
				attrib[IDX_SB_JOBNO].desc.value.att_txt );
	   FIg_set_text( form, G_JOB_DESC, 
				attrib[IDX_SB_JOBDESC].desc.value.att_txt );
	   if( ((int)attrib[IDX_SB_WATERLINES].desc.value.att_exp ) == 1 )
		FIg_set_state_on( form, G_DATUM_LINES );

           if( ((int)attrib[IDX_SB_MARKINGLINES].desc.value.att_exp ) == 1 )
                FIg_set_state_on( form, G_MARKING_LINES );
	}
	FIfld_set_text( form, G_BAND_MCF, i, 3, 
	     GetProperDirName( (int)attrib[IDX_SB_SIDE].desc.value.att_exp ),
	     FALSE );

        FIfld_set_text( form, G_BAND_MCF, i, 4, 
           GetProperDirName( (int)attrib[IDX_SB_START_DIR].desc.value.att_exp),
           FALSE );
	FIfld_set_text( form, G_BAND_MCF, i, 1, 
		attrib[IDX_SB_BANDNO].desc.value.att_txt, FALSE );
	FIfld_set_text( form, G_BAND_MCF, i, 2, 
                attrib[IDX_SB_BANDDESC].desc.value.att_txt, FALSE );

	sprintf( stock_str, "%g", attrib[IDX_SB_STOCK].desc.value.att_exp );
	FIfld_set_text( form, G_BAND_MCF, i, 5, stock_str, FALSE );

   }

wrapup:
  if( list_obj ) free( list_obj );
  return 1;
}

int main()
{
IGRlong		msg;
IGRint		sts, response, i, j, count, sel, pos, srf_row, srf_pos, num_pl,
		multi_select;
IGRchar		str[50], stat[128], path[200], macName[100], *p;
struct GRid	csId, macID, mksrc_pl[30];
TVDvlaID	macVLA;
enum GRdpmode   DisplayMode;
struct GRobj_env *list;

  test_wakeup = 1;              /* flag for wakeup function */
  form_exists = FALSE;          /* flag for delete function */
  form_displayed = FALSE;       /* flag for sleep  function */
  not_done  = TRUE;             /* Set this to FALSE when done with form */
  list      = NULL;
  count     = 0;
  nb_bndsrf = 20;
  num_srfs  = 0;
  p         = NULL;
  DisplayMode = GRhd;
  surface.obj_id.objid = NULL_OBJID;

  VLinitCnst( &cnst );

  message( COMMAND_NAME );

  VDSloadMacroLibrary( "band_av" );

  while (not_done )
  {    
      macName[0] = '\0';
      if( !ci$locate(
                obj             = &neatOE.obj_id.objid,
                osnum           = &neatOE.obj_id.osnum,
                md_env          = &neatOE.mod_env,
                response        = &response,
                classes         = "nci_macro",
                prompt          = "Locate Neat Contour/Steel Band",
                stackable       = TRUE ,
                properties      = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                owner_action    = LC_RIGID_COMP  | LC_RIGID_OWNER |
                                  LC_FLEX_COMP   | LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS ) ) return 1;
      __DBGpr_obj("Selected Macro ", neatOE.obj_id );
      vdobj$Get  (objOE = &neatOE, macName = macName );
      if(!strcmp( macName, "steel_band" ) || !strcmp( macName, "neat_cont"))
      not_done = FALSE;
  }

  for( i=0; i<50; i=i+1 )	endpts[i].objid = NULL_OBJID;

  sts = init_form();
  if (!(sts & 1)) goto wrapup;

  num_rows = 0;
  row      = -1;
  col      = -1;

  sts = FillDataInForm();
  if (!(sts & 1)) goto wrapup;

  not_done = TRUE;

  message_bar("Fill-in the information" );
  while (not_done )
  {
    /* Suspend the command file and wait for the form */
    ci$get (  prompt   = "Fill in the form",
              response = &response );

    UI_status(""); /* clear the status field*/
    message_bar("");
    switch ( form_st.gadget_label )
    {
       case FI_CANCEL: 
       {
	   dp$erase_hilite( msg = &msg );
	   not_done = FALSE;
	   FIf_erase ( form );
	   break;
       }

       case FI_ACCEPT: 
       {
	   dp$erase_hilite( msg = &msg );
	   if( ModifySteelBands() )
	   {
	      not_done = FALSE;
              FIf_erase ( form );
	   }
	   else FIg_set_state_off( form, FI_ACCEPT );
           break;
       }

       case G_UNIT_NUMBER:
       {
	   FIg_get_text( form, G_UNIT_NUMBER, unit_no );
	   break;
       }

       case G_JOB_NUMBER:
       {
	   FIg_get_text( form, G_JOB_NUMBER, job_no );
           break;
       }

       case G_JOB_DESC:
       {
	   FIg_get_text( form, G_JOB_DESC, job_desc );
           break;
       }

       case G_SURFACE_LOCATE:
       {
	   surface.obj_id.objid = NULL_OBJID ;
	   num_pl = 0 ;
	   j = 0;
	   multi_select = 0 ;
	   LocatePlates( "Identify Plate or Move on", &num_pl, 
			 &list, &surface );
	   if( surface.obj_id.objid != NULL_OBJID || num_pl != 0 )
	   {
	     if( surface.obj_id.objid == NULL_OBJID )
	     {
		surface = list[j];
		j = j+ 1;
		multi_select = 1;
	     }

pl_loop:
	     for( i=0; i<num_srfs; i=i+1 )
	     {
	        if( srf_list[i].obj_id.objid == surface.obj_id.objid &&
		    srf_list[i].obj_id.osnum == surface.obj_id.osnum )
	         break;
	     }
	     if( i != num_srfs )
	     {
	        message_bar("Plate is already selected" );
	        UI_status("Plate is already selected");
	     }
	     else if( num_srfs == 20 )
	     {
	        message_bar("Maxinum number of plates locatable: 20" );
	        UI_status("Maxinum number of plates locatable: 20");
	     }
	     else
	     {
		GetName( surface.obj_id, srf_name );
	        p = strstr( srf_name, ":ref:" );
	        if( p ) strcpy( srf_name, p+4 );
	        FIfld_set_text( form, G_SURFACE_LIST, num_srfs, 0, 
			        srf_name, FALSE );
	        srf_list[num_srfs] = surface ;
	        num_srfs = num_srfs + 1 ;
	     }
	     if( multi_select && j < num_pl ) 
	     {
		surface = list[j];
		j = j + 1;
		goto pl_loop;
	     }
	   }
	   FIg_set_state_off( form, G_SURFACE_LOCATE );
	   if( list ) { free ( list ); list = NULL; }
	   break;
       }

       case G_SURFACE_DELETE:
       {
	 dp$erase_hilite( msg = &msg );
	 j = 0;
	 for( i=0; i<num_srfs; i=i+1 )
	 {
	   FIfld_get_select( form, G_SURFACE_LIST, i, 0, &srf_pos);
           if( !srf_pos )	
	   {
		srf_list[j].obj_id.objid = srf_list[i].obj_id.objid;
		j = j + 1 ;
	   }
	 }

	 FIfld_delete_rows( form, G_SURFACE_LIST, 0, num_srfs );
	 num_srfs = j ;

	 for( i=0; i<num_srfs; i=i+1 )
	 {
           GetName( srf_list[i].obj_id, srf_name );
           p = strstr( srf_name, ":ref:" );
           if( p ) strcpy( srf_name, p+4 );
           FIfld_set_text( form, G_SURFACE_LIST, i, 0,
                           srf_name, FALSE );
	 }

         FIg_set_state_off( form, G_SURFACE_DELETE );
         break;
       }

       case G_SHOW_EDGES:
       {
	  if( num_srfs )
          {
	      neat_cont.objid = NULL_OBJID;
	      neat_cont.osnum = loc_env.md_id.osnum;
	      ASmake_source_from_env( &csId, &loc_env, &mksrc_pl[0] );

	      vdvla_id$Construct(vla = &macVLA);
	      vdchn$GetChildrenByClass(	objOE     = &srf_list[0],
                           		className = "nci_macro",
                           		vla       = &macVLA);

	      for( i = 0; 
		   vdvla_id$GetAt(vla = &macVLA, nth = i, objID = &macID);
		   i = i +1 )
	      {
		  vdobj$Get( objID = &macID, macName = macName );
  		  if( !strcmp( macName, "neat_cont" ) ) 
		  {
		     neat_cont = macID;
		     break;
		  }
	      }
	      vdvla_id$Delete(vla = &macVLA);

	      if( neat_cont.objid == NULL_OBJID )
	      {
	          for( i=0; i<num_srfs; i=i+1 )
		     ASmake_source_from_env( &srf_list[i].obj_id,
					 &loc_env, &mksrc_pl[i+1] );

   	          ci$send(msg      = message  nci_macro.init
              		( &msg, 0,"neat_cont", num_srfs+1, 
			  mksrc_pl, NULL,  &loc_env ),
               		targetid = neat_cont.objid,
               		targetos = neat_cont.osnum );
	      }

   	      FIg_enable( form, G_ADD );
   	      FIg_enable( form, G_DELETE );
   	      FIg_enable( form, G_BAND_MCF );

	      FillEdgeInfo();
	      message_bar( "Fill Steel Band Information" );
          }
	  else message_bar( "Select Plates to see the edges" );
	  FIg_set_state_off( form, G_SHOW_EDGES );
	  break;
       }

       case G_SURFACE_NAME:
       {
	   for( i=0; i<nb_bndsrf; i=i+1 )
	   {
	      FIfld_get_list_select( form,  G_SURFACE_NAME, i, 0, &sel );
	      if( sel ) 
	      {
		dp$erase_hilite( msg = &msg );
		surface = bndsrf[i];
                for( i=0; i<num_srfs; i=i+1 )
                {
             	   if( srf_list[i].obj_id.objid == surface.obj_id.objid &&
                       srf_list[i].obj_id.osnum == surface.obj_id.osnum )
                    break;
                }
           	if( i != num_srfs )
           	{
              	   message_bar("Plate is already selected" );
                   UI_status("Plate is already selected");
                }
                else if( num_srfs == 20 )
           	{
              	   message_bar("Maxinum number of plates locatable: 20" );
                   UI_status("Maxinum number of plates locatable: 20");
                }
                else
                {
	           GetName( surface.obj_id, srf_name );
                   p = strstr( srf_name, ":ref:" );
                   if( p ) strcpy( srf_name, p+4 );
                   FIfld_set_text( form, G_SURFACE_LIST, num_srfs, 0,
                              srf_name, FALSE );
                   VSbulkDisplayByGRobj_envs( GRhd, 1, &surface );
                   __DBGpr_obj("Normal is Displated ", surface.obj_id );
                   VLsbGetMoldSurface( &msg, &surface, GRhd, NULL );
 
                   srf_list[num_srfs] = surface ;
              	   num_srfs = num_srfs + 1 ;
           	}
		break;
	      }
  	   }
           break;
       }

       case G_SURFACE_LIST:
       {
	   VIfld_get_active_row( form, G_SURFACE_LIST, &srf_row, &srf_pos);
	   FIfld_get_select( form, G_SURFACE_LIST, srf_row, 0, &srf_pos);
	   if( srf_pos )
           {
             FIfld_set_select( form, G_SURFACE_LIST, srf_row, 0, TRUE );
             VSbulkDisplayByGRobj_envs( GRhd, 1, &srf_list[srf_row] );
           }
	   else
	   {
	     FIfld_set_select( form, G_SURFACE_LIST, srf_row, 0, FALSE );
	     VSbulkDisplayByGRobj_envs( GRhe, 1, &srf_list[srf_row] );
	   }
	   break;
       }

       case G_BAND_MCF:
       {
	   dp$erase_hilite( msg = &msg );
	   for( i=0; i<num_rows; i=i+1 )
		FImcf_set_select( form, G_BAND_MCF, i, FALSE );
	   FIg_erase( form, G_DIRECTION );
	   FIg_erase( form, G_KEY_IN );

           VIfld_get_active_row( form, G_BAND_MCF, &row, &pos);
           FImcf_get_active_col( form, G_BAND_MCF, &col, &pos);
	   __DBGpr_int("Row ", row );
	   __DBGpr_int("Column ", col );

	   VSbulkDisplayByGRobj_envs( GRhd, 1, &st_band[row] );
	   if( endpts[row].objid != NULL_OBJID )
	      VSbulkDisplayByGRids( &loc_env, GRhd, 1, &endpts[row] );

	   FIfld_set_select( form, G_BAND_MCF, row, col, TRUE );
	   FIfld_get_text( form, G_BAND_MCF, row, col, 128, 
			   stat, &sel, &pos );
	   if( col == 0 )
	   {
		FImcf_set_select( form, G_BAND_MCF, row, TRUE );
		if( !(strcmp(stat, "**") ) )
		  message_bar("Insufficient Information for this band" );
	   }
	   else if( col == 3 || col == 4 ) 
	   {
	        if( col == 4 )
		{
		    FIg_display( form, G_DIRECTION );
		    FIg_set_text( form, G_DIRECTION, stat );
		}
	   }
	   else 
	   {
		FIg_display( form, G_KEY_IN );
		FIfld_pos_cursor( form, G_KEY_IN, 0, 0, 0, 0, 0 );
		FIg_set_text( form, G_KEY_IN, stat );
	   }

	   break;
       }

       case G_DIRECTION:
       {
	   FIg_get_text( form, G_DIRECTION, str );
	   FIfld_set_text( form, G_BAND_MCF, row, col, str, FALSE );
	   FIg_erase( form, G_DIRECTION );
	   break;
       }
       case G_KEY_IN:
       {
           FIg_get_text( form, G_KEY_IN, str );
	   if(  col == 1 && !strlen(str) ) 
           {
		FIfld_set_text( form, G_BAND_MCF, row, col, "", FALSE );
		FIg_erase( form, G_KEY_IN );
		break;
	   }

           if( col == 1 && !atoi(str) )
	   {
	      message_bar("Enter an integer value");
	      FIfld_pos_cursor( form, G_KEY_IN, 0, 0, 0, 0, 0 );
	   }
	   else
	   {
	      FIfld_set_text( form, G_BAND_MCF, row, col, str, FALSE );
              FIg_erase( form, G_KEY_IN );
	   }
	   break;
       }
    }
    check_dir();
  }

wrapup:
  return 1;
}

init()
{
int i;

  form = NULL;
  for( i=0; i<20; i=i+1 ) srf_list[i].obj_id.objid = NULL_OBJID;
}

int init_form()
{
IGRint	sts, retFlag;
Form 	existingForm;

  retFlag = 0;
  sts = VI_get_form_by_name(FORM_NAME, &existingForm);
  if (sts == FI_SUCCESS)
  {
      UI_status("Place Steel Bands command is active" );
      return 0;
  }

  VIf_new(100, FORM_NAME, ci_notification, &form);
  if (form == NULL)
  {
      printf("Can not Initialize the Steel Bands Form\n" );
      goto wrapup;
  }
  form_exists = TRUE;  /* Flag for delete function */
  VDahFrmLoadPositionFromFile( form );
  VIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );

  VIf_display( form );
  form_displayed = TRUE;  /* Flag for sleep function */

  FIg_disable( form, G_SHOW_EDGES );
  FIg_disable( form, G_SURFACE_LIST );
  FIg_disable( form, G_SURFACE_LOCATE );
  FIg_disable( form, G_SURFACE_DELETE );
  FIg_disable( form, G_SURFACE_NAME );

  retFlag = 1;

wrapup:
  return retFlag;
}


/* ---------------------------------
 * Gadget handling
 */
form_notification()
{
  ci$put( response = MOVE_ON );  /* Give control to the main function */
  return 1;
}

