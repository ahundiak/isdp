/* $Id $  */
/* --------------------------------------------------------------------
 * I/LOFT
 *
 * File:        src/pin_jig/COklPlace.u
 *
 * Description: Command PPL for key lines placement.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      08/08/00        Rama Rao        File Creation.
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"
#include "VDchn.h"
#include "coparamac.h"
#include "vsplatedef.h"
#include "vlkline.h"
#include "vldbgmacros.h"

#define vdsDEBUG        1
#define vdserrDEBUG     1

#define COMMAND_NAME            "Place Key Lines"
#define FORM_NAME               "VLkLine.frm"

Form                            form;
IGRint                          form_displayed, form_exists, not_done, num_pl,
                                num_plts, test_wakeup, form_labels[60],
				nb_bndsrf;
IGRchar                         plt_name[128], job_no[128], unit_no[128], 
				job_desc[128], frm_name[128];
struct CIform_st                form_st;
struct GRmd_env                 loc_env;
struct GRobj_env                plate, frame, plt_list[20], bndsrf[20];
struct GRvg_construct           cnst;

extern fabs();

extern FIg_is_valid(), FIg_get_attr(), FIg_set_state_off(), FIg_set_value();

extern 	ASstart_var_fence(), ASend_fence(), VSbulkDisplayByGRobj_envs(),
	VLinitCnst(), EX_get_global(), ASmake_source_from_env(),
	VDSloadMacroLibrary();

extern GRclassid	OPP_EMSplane_class_id;

IGRlong message_bar( inPrompt )
IGRchar         *inPrompt;
{
   FIg_set_text( form, G_MESSAGE_FIELD, inPrompt );
   return 1;
}

DisableAllLabels()
{
   IGRint       i, attrib ;

   for( i=0; i<60; i=i+1 )
   {
       form_labels[i] = 0 ;
       if( i == FI_CANCEL )     continue;
       if( ! ( FIg_is_valid( form, i )) )
       {
          FIg_get_attr( form, i, &attrib ) ;
          if( !( attrib & FI_NOT_DISPLAYED ) )
          {
             FIg_disable( form, i );
             form_labels[i] = 1 ;
          }
       }
    }
}

EnableAllLabels()
{
   IGRint       i;
   for( i=0; i<60; i=i+1 )
   {
       if( i == FI_CANCEL )     continue;
       if( form_labels[i] ) FIg_enable( form, i );
   }
}

wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
        /* Display the form unless the command file is just starting */
        __DBGpr_int("I'm now waking up, test_wakeup",test_wakeup);
        if ( test_wakeup == 1 && not_done ) {
            if( form )
            {
                EnableAllLabels();
                form_displayed = TRUE; /* Set flag for sleep function */
            }
        }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
        /* Erase the form if it is displayed */
        if ( form_displayed == TRUE ) {
                DisableAllLabels();
                form_displayed = FALSE;
        }
}

delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
        int     i ;

        __DBGpr_int("form_displayed", form_displayed);
        __DBGpr_int("form_exists", form_exists);
        /* Erase the form if it is displayed */
        if ( form_displayed == TRUE ) {
                FIf_erase ( form );
                form_displayed = FALSE;
        }
        /* Delete the form if it exists */
        if ( form_exists ) {
                if( form ) {
                        VDahFrmSavePositionInFile(form);
                        if (form) VIf_delete(form);
                        form = NULL;
                }
        }
        not_done = 0 ;
}

IGRint  GetName( object, name )
struct GRid             object;
IGRchar                 *name;
{
   ci$send(  msg = message GRgraphics.GRgetname( &msg, name ),
                targetid = object.objid,
                targetos = object.osnum  );
}

IGRstat LocateFrame( inPrompt, selOE, objName, check)
IGRchar         *inPrompt;
TGRobj_env      *selOE;
IGRchar         *objName;
IGRint          check;
{
  IGRint                i, response, labels[60] ;
  OM_S_CLASSLIST        eligibleClasses ;
  OMuword               classids[2] ;

        if( selOE->obj_id.objid != NULL_OBJID ) {
                VSbulkDisplayByGRobj_envs( GRhd, 1, selOE );
        }

        DisableAllLabels();

        classids[0] = OPP_EMSplane_class_id ;

        eligibleClasses.w_count   = 1 ;
        eligibleClasses.w_flags   = OM_CLST_subclass ;
        eligibleClasses.p_classes = classids ;

        ci$locate(
                obj             = &selOE->obj_id.objid,
                osnum           = &selOE->obj_id.osnum,
                md_env          = &selOE->mod_env,
                response        = &response,
                eligible_classes= &eligibleClasses,
                prompt          = inPrompt,
                stackable       = TRUE ,
                properties      = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                owner_action    = LC_RIGID_COMP  | LC_RIGID_OWNER |
                                  LC_FLEX_COMP   | LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS );

        EnableAllLabels();

        if( selOE->obj_id.objid != NULL_OBJID ) {
                GetName( selOE->obj_id, objName );
                __DBGpr_str("Returned name is ",objName);
        }

wrapup:
   return TRUE;
}

IGRstat LocatePlates( inPrompt, num, list, single_pl )
IGRchar         *inPrompt;
IGRint          *num;
TGRobj_env      **list;
TGRobj_env      *single_pl;
{
IGRint          i, response, sts;
TGRobj_env      objOE;

   *num = 0;
   if( *list ) { free( *list ); *list = NULL; }
   single_pl->obj_id.objid = NULL_OBJID;

   DisableAllLabels();

   if( num_plts )
      VSbulkDisplayByGRobj_envs( GRhd, num_plts, plt_list );

   sts = ci$locate(prompt  = inPrompt,
                   classes = "VSplate",
                   owner_action = LC_RIGID_OWNER |
                                  LC_RIGID_COMP  |
                                  LC_FLEX_COMP   |
                                  LC_FLEX_OWNER  |
                                  LC_REF_OBJECTS,
                   stackable    = 1,
                   response     = &response,
                   md_env       = &objOE.mod_env,
                   obj          = &objOE.obj_id.objid,
                   osnum        = &objOE.obj_id.osnum);

   dp$erase_hilite( msg = &msg );

   if (!(sts & 1)) response = 0;

   switch(response) {

    case EX_OBJID:   // Object Set

      /* Grab Located Objects */
      as$start_fence(   set       = &objOE.obj_id,
                        set_env   = &objOE.mod_env,
                        nb_obj    = num,
                        p_obj_env = list );
      ASend_fence();
      break;
      break;

    case EX_DATA:    // Single Object
      *single_pl = objOE ;
      break;

   } // Switch

   EnableAllLabels();

   return 1;

}

IGRint  PlaceKeyLines()
{
IGRlong                 msg;
IGRint			i;
struct ACrg_coll        attr[3];
struct GRid             TEMP[22], pl_key;

   dp$erase_hilite( msg = &msg );

   strcpy( attr[0].name, NAM_KL_UNITNO );
   attr[0].desc.type = AC_ATTRIB_TEXT;
   strcpy( attr[0].desc.value.att_txt, unit_no );

   strcpy( attr[1].name, NAM_KL_JOBNO );
   attr[1].desc.type = AC_ATTRIB_TEXT;
   strcpy( attr[1].desc.value.att_txt, job_no );

   strcpy( attr[2].name, NAM_KL_JOBDESC );
   attr[2].desc.type = AC_ATTRIB_TEXT;
   strcpy( attr[2].desc.value.att_txt, job_desc );

   TEMP[0]       = frame.obj_id ;
   ASmake_source_from_env( &TEMP[0],&loc_env,&TEMP[0]);

   TEMP[1].objid = NULL_OBJID ;
   TEMP[1].osnum = loc_env.md_id.osnum ;

   ci$send( msg      = message ACrg_collect.ACadd_list_attribute(
                                        &msg, 3, attr ),
                targetid = TEMP[1].objid,
                targetos = TEMP[1].osnum );

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = TEMP[1].objid,
                targetos = TEMP[1].osnum );

   for( i=0; i<num_plts; i=i+1 )
	ASmake_source_from_env( &plt_list[i].obj_id,&loc_env,&TEMP[i+2]);

   pl_key.objid = NULL_OBJID ;
   pl_key.osnum = loc_env.md_id.osnum ;

   ci$send(msg      = message  nci_macro.init
              ( &msg, 0,"plate_key", num_plts+2, TEMP, NULL,  &loc_env ),
               targetid = pl_key.objid,
               targetos = pl_key.osnum );

   ci$send( msg      = message NDnode.NDchg_state(
                                                ND_DEL_NO_CH | ND_WAIT_DEL,
                                                ND_DEL_NO_CH | ND_WAIT_DEL ),
                targetid = pl_key.objid,
                targetos = pl_key.osnum );

wrapup:
   return 1;
}

int main()
{
IGRlong         msg;
IGRint          sts, response, i, j, row, col, pos, multi_select;
IGRchar		*p;
struct GRobj_env *list;

  test_wakeup = 1;              /* flag for wakeup function */
  form_exists = FALSE;          /* flag for delete function */
  form_displayed = FALSE;       /* flag for sleep  function */
  not_done  = TRUE;             /* Set this to FALSE when done with form */
  list = NULL;
  frame.obj_id.objid = NULL_OBJID ;

  VLinitCnst( &cnst );
  ci$get_module_info( md_env = &loc_env);

  message( COMMAND_NAME );

  VDSloadMacroLibrary( "band_av" );

  sts = init_form();
  if (!(sts & 1)) goto wrapup;

  get_unitname_and_srf();

  while (not_done )
  {
    /* Suspend the command file and wait for the form */
    ci$get (  prompt   = "Fill in the form",
              response = &response );

    UI_status(""); /* clear the status field*/
    message_bar("");
    switch ( form_st.gadget_label )
    {
       case FI_CANCEL:
       {
           dp$erase_hilite( msg = &msg );
           not_done = FALSE;
           FIf_erase ( form );
           break;
       }

       case FI_ACCEPT:
       {
           dp$erase_hilite( msg = &msg );
           if( PlaceKeyLines() )
           {
              not_done = FALSE;
              FIf_erase ( form );
           }
           else FIg_set_state_off( form, FI_ACCEPT );
           break;
       }

       case G_UNIT_NUMBER:
       {
           FIg_get_text( form, G_UNIT_NUMBER, unit_no );
           break;
       }

       case G_JOB_NUMBER:
       {
           FIg_get_text( form, G_JOB_NUMBER, job_no );
           break;
       }

       case G_JOB_DESC:
       {
           FIg_get_text( form, G_JOB_DESC, job_desc );
           break;
       }

       case G_PLATE_LOCATE:
       {
           plate.obj_id.objid = NULL_OBJID ;
           num_pl = 0 ;
           j = 0;
           multi_select = 0 ;
           LocatePlates( "Identify Plate or Move on", &num_pl,
                         &list, &plate );
           if( plate.obj_id.objid != NULL_OBJID || num_pl != 0 )
           {
             if( plate.obj_id.objid == NULL_OBJID )
             {
                plate = list[j];
                j = j+ 1;
                multi_select = 1;
             }

pl_loop:
             for( i=0; i<num_plts; i=i+1 )
             {
                if( plt_list[i].obj_id.objid == plate.obj_id.objid &&
                    plt_list[i].obj_id.osnum == plate.obj_id.osnum )
                 break;
             }
             if( i != num_plts )
             {
                message_bar("Plate is already selected" );
                UI_status("Plate is already selected");
             }
             else if( num_plts == 20 )
             {
                message_bar("Maxinum number of plates locatable: 20" );
                UI_status("Maxinum number of plates locatable: 20");
             }
             else
             {
                GetName( plate.obj_id, plt_name );
		if( strlen( plt_name ) == 0 ) strcpy( plt_name, "No Name" );
                p = strstr( plt_name, ":ref:" );
                if( p ) strcpy( plt_name, p+4 );
                FIfld_set_text( form, G_PLATE_LIST, num_plts, 0,
                                plt_name, FALSE );
                plt_list[num_plts] = plate ;
                num_plts = num_plts + 1 ;
             }
             if( multi_select && j < num_pl )
             {
                plate = list[j];
                j = j + 1;
                goto pl_loop;
             }
           }
           FIg_set_state_off( form, G_PLATE_LOCATE );
           if( list ) { free ( list ); list = NULL; }
           break;
       }

       case G_PLATE_REMOVE:
       {
         dp$erase_hilite( msg = &msg );
         j = 0;
         for( i=0; i<num_plts; i=i+1 )
         {
           FIfld_get_select( form, G_PLATE_LIST, i, 0, &pos);
           if( !pos )
           {
                plt_list[j].obj_id.objid = plt_list[i].obj_id.objid;
                j = j + 1 ;
           }
         }

         FIfld_delete_rows( form, G_PLATE_LIST, 0, num_plts );
         num_plts = j ;

         for( i=0; i<num_plts; i=i+1 )
         {
           GetName( plt_list[i].obj_id, plt_name );
           p = strstr( plt_name, ":ref:" );
           if( p ) strcpy( plt_name, p+4 );
           FIfld_set_text( form, G_PLATE_LIST, i, 0,
                           plt_name, FALSE );
         }

         FIg_set_state_off( form, G_PLATE_REMOVE );
         break;
       }

       case G_PLATE_LIST:
       {
           VIfld_get_active_row( form, G_PLATE_LIST, &row, &pos);
           FIfld_get_select( form, G_PLATE_LIST, row, 0, &pos);
           if( pos )
           {
             FIfld_set_select( form, G_PLATE_LIST, row, 0, TRUE );
             VSbulkDisplayByGRobj_envs( GRhd, 1, &plt_list[row] );
           }
           else
           {
             FIfld_set_select( form, G_PLATE_LIST, row, 0, FALSE );
             VSbulkDisplayByGRobj_envs( GRhe, 1, &plt_list[row] );
           }
           break;
       }

       case G_FRAME_LOCATE:
       {
           LocateFrame( "Identify Frame / Move on", &frame, frm_name, FALSE );
           __DBGpr_obj("Located Frame ", frame.obj_id );

           if( frame.obj_id.objid != NULL_OBJID && strrchr( frm_name, ':' ) != NULL )
               FIg_set_text( form, G_FRAME_NAME, strrchr( frm_name, ':' )+1 );
           else FIg_set_text( form, G_FRAME_NAME, "No Name" );

           FIg_set_state_off( form, G_FRAME_LOCATE );
           break;
       }
    }
  }

wrapup:
  if( list ) { free ( list ); list = NULL; }
  return 1;
}

int init_form()
{
IGRint  sts, retFlag;
Form    existingForm;

  retFlag = 0;
  sts = VI_get_form_by_name(FORM_NAME, &existingForm);
  if (sts == FI_SUCCESS)
  {
      UI_status("Place Key Lines command is active" );
      return 0;
  }

  VIf_new(100, FORM_NAME, ci_notification, &form);
  if (form == NULL)
  {
      printf("Can not Initialize the Form\n" );
      goto wrapup;
  }
  form_exists = TRUE;  /* Flag for delete function */
  VDahFrmLoadPositionFromFile( form );
  VIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );

  VIf_display( form );

  form_displayed = TRUE;  /* Flag for sleep function */

  retFlag = 1;

wrapup:
  return retFlag;
}

/* ---------------------------------
 * Gadget handling
 */
form_notification()
{
  ci$put( response = MOVE_ON );  /* Give control to the main function */
  return 1;
}

get_unitname_and_srf()
{
        IGRchar                 filename[132], srf_name[132];
        IGRint                  i, var_size[3];
        IGRint                  bad_var;
        struct  EX_var_list     ex_var[4];

        var_size[0] = sizeof(filename);
        ex_var[0].var = EX_CUR_FILENAME;
        ex_var[0].var_value = &filename[0];
        ex_var[0].num_bytes = &var_size[0];
        var_size[1] = NULL;

        msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

        __DBGpr_str("Design File Name ", filename );
        if( strlen(filename) > 4 )      strncpy( unit_no, filename, 4 );
        else                            strcpy ( unit_no, filename    );
        __DBGpr_str("Unit Number ", unit_no );

        FIg_set_text( form, G_UNIT_NUMBER, unit_no );

        __DBGpr_int("Number Of Bounded Surfaces ", nb_bndsrf );
        if( nb_bndsrf )
        {
           FIfld_set_num_rows( form, G_SURFACE_NAME, nb_bndsrf );
           for( i=0; i<nb_bndsrf; i=i+1 )
           {
              GetName( bndsrf[i].obj_id, srf_name );
              __DBGpr_str( "Surface Name ", srf_name );
              FIfld_set_list_text( form, G_SURFACE_NAME, i, 0,
                                   srf_name, FALSE );
           }
        }

        ci$get_module_info( md_env = &loc_env);
}
