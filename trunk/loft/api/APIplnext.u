/***************************************************************************
 * I/LOFT
 *
 * File:	api/APIplnext.u
 *
 * Description:
 *		Example file to use API for modification of base line for:
 *
 *			- Next Butt
 *			- Next Seam
 *
 * Dependencies:
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *			i-paris		creation date
 *
 ***************************************************************************/

#include "cieveryone.h"
#include "cimacros.h"
#include "vlglinedef.h"
#include "vlAPImacros.h"

extern		strcpy();
extern		strcat();
extern	int	printf();
extern	int	sprintf();
extern	int	UI_status();

#define MAX_WATER_LINE	30

main()
{

long			sts;
int			response;

struct	GRid		hullId;
struct	GRmd_env	hullEnv;
struct	GRid		previousId;
struct	GRmd_env	previousEnv;
struct	GRid		propagDirId;
struct	GRmd_env	propagDirEnv;
int			nbWaterLine;
struct	GRid		waterLineId[MAX_WATER_LINE];
struct	GRmd_env	waterLineEnv[MAX_WATER_LINE];

long			loc_msg;
struct	GRid		constructId;
char			txt[1024];
int			type;


	message("test place_next_<lines> apis");

	sts =
	ci$locate(	prompt	= "Locate the Hull (at least a surface)",
			md_env		= &hullEnv,
			response	= &response,
			obj		= &hullId.objid,
			osnum		= &hullId.osnum );
	if( ! (sts&1))	goto wrapup;

	sts =
	ci$locate(	prompt		= "Locate Previous",
			md_env		= &previousEnv,
			response	= &response,
			obj		= &previousId.objid,
			osnum		= &previousId.osnum );
	if( ! (sts&1))	goto wrapup;

	sts =
	ci$locate(	prompt		= "Locate Propagation Direction",
			md_env		= &propagDirEnv,
			response	= &response,
			obj		= &propagDirId.objid,
			osnum		= &propagDirId.osnum );
	if( ! (sts&1))	goto wrapup;

get_type:

	// get type of constructed object
	type = 0;
	ci$get(	value	= type,
		rc      = sts,
		prompt	= "Gives object type(nb=1,ns=2)[all]" );

	if( ! (sts&1))	type = 0;
	if( type < 0 || type > 2 )	goto get_type;


	for( nbWaterLine = 0; sts & 1 && nbWaterLine < MAX_WATER_LINE; ){

	  sts =
	  ci$locate(	prompt		= "Locate support Line",
			md_env		= &waterLineEnv[nbWaterLine],
			response	= &response,
			obj		= &waterLineId[nbWaterLine].objid,
			osnum		= &waterLineId[nbWaterLine].osnum );
	  if( sts & 1 )	nbWaterLine = nbWaterLine + 1;
	}
	if( ! nbWaterLine )	goto wrapup;

	// ******************************** Create the base lines

	if( type == 0 || type == 1 ){

	  sts =
	  vl$place_next_butt(	msg		= &loc_msg,
				hullId		= &hullId,
				hullEnv		= &hullEnv,
				propagDirId	= &propagDirId,
				propagDirEnv	= &propagDirEnv,
				previousId	= &previousId,
				previousEnv	= &previousEnv,
				length		= 1000.,
				nbWaterLine	= nbWaterLine,
				waterLineId	= waterLineId,
				waterLineEnv	= waterLineEnv,
				constructedId	= &constructId );

	  strcpy( txt, "place_next_butt" );

	  if( ! (sts&loc_msg&1)) 
		strcat( txt, " :: ERROR\n");
	  else	
		sprintf( txt, "%s :: %d/%d\n", 
				txt, constructId.objid, constructId.osnum );

	  printf( "%s", txt );
	  UI_status( txt );
	}

	if( type == 0 || type == 2 ){

	  sts =
	  vl$place_next_seam(	msg		= &loc_msg,
				hullId		= &hullId,
				hullEnv		= &hullEnv,
				propagDirId	= &propagDirId,
				propagDirEnv	= &propagDirEnv,
				previousId	= &previousId,
				previousEnv	= &previousEnv,
				width1		= 300.,
				nbLimit		= nbWaterLine,
				limitId		= waterLineId,
				limitEnv	= waterLineEnv,
				constructedId	= &constructId );

	  strcpy( txt, "place_base_seam" );

	  if( ! (sts&loc_msg&1))
		strcat( txt, " :: ERROR\n");
	  else	
		sprintf( txt, "%s :: %d/%d\n",
				txt, constructId.objid, constructId.osnum );

	  printf( "%s", txt );
	  UI_status( txt );
	}

wrapup :
	return	1;
}
