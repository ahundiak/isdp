/* $Id: VSpxcnstfeet.I,v 1.4 2002/02/13 22:29:20 jayadev Exp $  */

/*************************************************************************
 * I/STRUCT
 *
 * File:	vsprofile / VSpxcnstfeet.I
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VSpxcnstfeet.I,v $
 *	Revision 1.4  2002/02/13 22:29:20  jayadev
 *	fix for TR# MP6011
 *	
 *	Revision 1.3  2001/01/26 22:19:43  jayadev
 *	changes for etl#6024
 *	
# Revision 1.2  2000/05/03  17:48:58  pinnacle
# Replaced: struct/vsprofile/VSpxcnstfeet.I for:  by rchennup for Service Pack
#
#
# Revision 1.5  1998/06/24  15:49:50  pinnacle
# tr179801135
#
# Revision 1.3  1998/05/19  19:18:16  pinnacle
# TR179801097
#
# Revision 1.2  1998/05/13  18:54:26  pinnacle
# TR179801097
#
# Revision 1.1  1998/04/30  10:08:06  pinnacle
# STRUCT 2.5.1
#
# Revision 1.4  1998/02/04  16:14:58  pinnacle
# Replaced: vsprofile/VSpxcnstfeet.I for:  by svkadamb for struct
#
# Revision 1.3  1997/11/25  11:12:46  pinnacle
# Replaced: vsprofile/VSpxcnstfeet.I for:  by svkadamb for struct
#
# Revision 1.2  1997/09/29  15:35:50  pinnacle
# TR179700969
#
# Revision 1.1  1997/05/08  14:03:58  pinnacle
# Struct 250
#
# Revision 1.5  1996/07/29  15:25:18  pinnacle
# Replaced: vsprofile/VSpxcnstfeet.I for:  by s240_int for struct
#
*
* History:
* MM/DD/YY   AUTHOR	DESCRIPTION
* 07/29/96   Suresh	TR179602371 Project Cross-section onto surface crash
* 09/29/97   ah        TR179700969 Cardinal Points
*                      Not sure where the change is, Suresh did it
* 02/04/98   Suresh	TR179701986. The surface used for minimum 
*			distace calculation should be the input 
*			surface, but not the extended surface.
*			If the surface is intersecting with beam solid
*			then do project the profile on the surface, but
*			get the result by intersecting the solid with
*			the surface
* 05/12/98   ah        TR179801097 Intersect fails when the beam axis just touches
*                      the cutting surface, use project in this case
* 05/19/98   ah        TR179801097 No graphics when offset is used because
*                      the offset curve is getting deleted.
* 05/27/98   ah        TR179801097 The tr that would not die!
*                      Problem getting the bean rep and problem with the intersect
*                      of the sfsolid with surface
* 06/24/98   ah        TR179801135 Getting face name mismatch
* 05/03/00   Jayadev   Planarity flag sent to VSintersectCurveAndSurface
*			etl#1899 & 1491 
* 01/26/00   Jayadev   VSmakeInfinitePlaneNew() function for etl#6024 
*			replacing VSmakeInfinitePlane()
* 02/13/02   Jayadev   TR# MP6011 - Gracefully exit with a message when
*                      the beam doesn't have both the supports 
*************************************************************************/
class implementation VSprjCrsSctn ;

#include <stdlib.h>
#include "exmacros.h"
#include "bserr.h"
#include "bsparameters.h"
#include "bsicmpcvoff.h"
#include "EMSmsgdef.h"
#include "vspart.h"
#include "vssplitdef.h"
#include "vsdatamacros.h"
#include "vsmiscmacros.h"
#include "vsgeommacros.h"
#include "vsdbgmacros.h"
#include "vdAPImacros.h"

#define ACCEPT_SURFACE_OFF_CURVE

/*
 * Includes of function prototypes.
 */
#include "bscveval.h"
#include "bsmdistcvsf.h"
#include "bsmkvec.h"
#include "bsnorvec.h"
#include "bsgeom_cvsf.h"
#include "bssftgeomsf.h"
#include "bsxgmsfdst.h"
#include "bsdistptpt.h"
#include "bsfreecv.h"
#include "vsbeamdef.h"
#include "vsbeamproto.h"
#include "vsexpvalue.h"
#include "vsintcvsf.h"
#include "vsvecmxproto.h"
#include "vsvirtualinf.h"

from VSpart		import		VSgetSupports ;
from VSbeam		import		VSextractProfile ;
from VSfeature		import		VSforwardToSource ;

extern OMuword		OPP_EMSsubbs_class_id;

/*----------------------------------------------------------------------------*/
method ACconstruct_feet(long		*msg ;
			int		purpose,
			                count ;
			struct GRid	list[] ;
			struct GRmd_env	*myEnv ;
			int		*feetCount ;
			struct GRid 	*feetList ) {
  
  long			sts ;	  /* OM return code		*/
  double		cvOffset, /* Offset of beam's profile	*/
                        intParam ;/* Param. of intersection pnt.*/
  IGRpoint		intPnt ;  /* Inters. point axis/surface	*/
  struct GRobj_env	surface,  /* Graphic surface id and env.*/
                        bigPlane, /* Big plane			*/
                        compSol,  /* solid of source beam	*/
		       	*p_sf ;	  /* Pnter to sf. to project to */
  VSsuppList		bmSupps ; /* Supports of beam		*/
  int			scnt ;	  /* Count of supports (unused)	*/
  struct IGRbsp_curve	*axisGeom;/* Geometry of beam's axis	*/
  struct IGRbsp_surface	*sfGeom ; /* Geometry of input surface	*/
  IGRvector		prjVec ;  /* Vector of projection	*/
  struct GRmd_env      	bmEnv ;	  /* Module environment of beam	*/
  struct GRid		bmId,	  /* Id of parent beam		*/
                        compCurve,/* composite curve of solidbeam */
		       	profile,  /* Profile generated by beam	*/
		       	offPrfl,  /* Offset  of profile		*/
		       	*p_cv ;	  /* Pnter to curve to project. */
  struct GRsymbology	mySymb ;  /* My symbology		*/
  struct GRvg_construct	cst ;	  /* Construction list		*/
  
  VSdspRep		myRep ;	  /* My display representation	*/
  VSdspRep              beamRep;
	
  
  struct IGRbsp_surface 	*srfGeom ;
  struct BSgeom_bsp_surf 	extSfGeom, gmsf ;
  IGRint			option, i, type = 0;
  BSrc			bsrc ;
  IGRpoint		point1, point2;
  IGRdouble		dist, dist_out;
  IGRboolean		uleft, vleft, uright, vright,
       			interFailed  = FALSE,
                        interFailedX = FALSE;  // TR179801135
  IGRboolean		tst_all = 1,is_planar=FALSE;
  struct GRid		ext_surface;
  struct GRobj_env	beamOE;
  GRrange	       	box ;
		
  
  /*
   * Indices of parents.
   */
#define	BEAM	0
#define	SURF	1
#define EXPR	2
  /*
   * Indices of beam's supports.
   */
#define bmSURF	0
#define bmAXIS	1
  
  SetProc( VSprjCrsSctn_ACconstruct_feet ) ; Begin ; __DBGpr_me() ;
  
  axisGeom = NULL ; sfGeom = NULL ;
  srfGeom =  NULL ; 
  ext_surface.objid = NULL_OBJID;
  compCurve.objid = NULL_OBJID;
  
  feetList[0].objid	= profile.objid		= offPrfl.objid
    = bigPlane._objid	= NULL_OBJID ;
  
  if( count == 2 ) {
    /*
     * No curve offset.
     */
    cvOffset = 0 ;
  } else {
    sts = VSexpValue( list[EXPR].objid, list[EXPR].osnum,
		      &cvOffset ) ;
    __CheckRC( sts, 1, "VSexpValue", wrapup ) ;
  }
  __DBGpr_dbl( "Curve offset", cvOffset ) ;
  
  /*
   * Get graphics of parent surface.
   */
  sts = om$send(	msg	= message NDnode.ASreturn_go(
    &surface._grid,
    &surface._matrix_type,
    surface._matrix ),
			targetid= list[SURF].objid,
			targetos= list[SURF].osnum ) ;
  __CheckRC( sts, 1, "NDnode.ASreturn_go", wrapup ) ;
  __DBGpr_obj( "Graphic surface", surface._grid ) ;
  
  surface._md_os = surface._osnum ;
  ex$get_modid(	mod_osnum	= surface._md_os,
		mod_id		= &surface._md_id ) ;
  
  /*
   * Fill construction list.
   */
  sts = om$send(	msg	= message GRvg.GRgetsymb( msg, &mySymb ),
			mode	= purpose & VS_K_InitialPlacement
			? OM_e_wrt_message
			: OM_e_wrt_object,
			targetid= my_id ) ;
  __CheckRC( sts, *msg, "GRvg.GRgetsymb", wrapup ) ;
  
  vs$fill_cnst_list(	Env_info	= myEnv,
			Display		= &mySymb.display_attr,
			Level		= mySymb.level,
			Cnst_list	= cst ) ;
  
  /*
   * Get beam's axis.
   * REMAINDER : beam's axis is support #1.
   * If this object is inside a macro, then list[BEAM] is a pretend, since
   * we are sending VS-specific messages, we have to get the id of the
   * beam pointed to by that pretend (pretends do not understand VS
   * messages).
   */
  VSgetVirtualInfo( msg, list + BEAM, &bmEnv, &bmId ) ;
  
#ifdef vsDEBUG
  ShowObj( &bmId ) ;
#endif
  /*
   * TR# MP6011 - look for both the supports to exist 
   */
  bmSupps[bmSURF].obj_id.objid = NULL_OBJID;
  bmSupps[bmAXIS].obj_id.objid = NULL_OBJID;

  sts = om$send(	msg	= message VSpart.VSgetSupports(
    msg, &bmEnv, &scnt, bmSupps ),
			targetid= bmId.objid,
			targetos= bmId.osnum ) ;
  __CheckRC( sts, *msg, "VSpart.VSgetSupports", wrapup ) ;
  if((bmSupps[bmSURF].obj_id.objid == NULL_OBJID) ||
     (bmSupps[bmAXIS].obj_id.objid == NULL_OBJID))
  {
    printf("\n ERROR: BEAM[%d,%d] supports missing \n",
               bmId.objid, bmId.osnum);
    sts = 0; *msg = 0; goto wrapup;
  } 
  /*
   * If input surface is a plane make it big enough so intersection will
   * work, use beam's axis as input to make sure that plane will be
   * extended so as to encompass axis and apply a scaling factor to
   * ensure that beam's body will be in it too.
   */
  
  sts = VSbeamBox( msg, &bmId, &bmEnv, box ) ;
  __CheckRC( sts, *msg, "VSbeamBox", wrapup ) ;
  
  if( vs$is_surface_planar(	surfId	= &surface._grid,
				surfEnv	= &surface.mod_env,
				msg	= msg ) ) {
    is_planar = TRUE;
    /*
     * Commented for TR TR179600241 
     * Instead of making a bigger plane which fits the given range
     * box there is no harm in making an Infinite Plate
     */
    /*
      sts = vs$makeBiggerPlane(
      msg		= msg,
      inPlane		= &surface,
      elementRng	= box,
      scale		= 100.,
      cst		= &cst,
      bigPlane	= &bigPlane._grid ) ;
      __CheckRC( sts, *msg, "vs$makeBiggerPlane", wrapup ) ;
    */
    
    /************* commented for etl#6024 **********************************

		sts = VSmakeInfinitePlane( 	msg, 
						&surface, 
						&cst, 
						&bigPlane._grid );
		__CheckRC( sts, *msg, "VSmakeInfinitePlane", wrapup ) ;

		************* commented for etl#6024 **********************************/
    
    beamOE.obj_id = bmId;
    beamOE.mod_env= bmEnv;
    sts = VSmakeInfinitePlaneNew( 	msg,
					&beamOE, 
					&surface, 
					&cst, 
					&bigPlane._grid );
    __CheckRC( sts, *msg, "VSmakeInfinitePlaneNew", wrapup ) ;
    
    bigPlane.mod_env = surface.mod_env ;
    p_sf = &bigPlane ;
  } else {
    /*
     * Extend the surface linearly to the box range
     * oterwise it will fail if the surface is not encompassing
     * the beams cross section
     */
    sts = vs$get_geometry(  msg     = msg,
			    grobjId = &surface.obj_id,
			    grobjEnv= &surface.mod_env,
			    geometry= &srfGeom ) ;
    if( !(sts & *msg & 1 ) )		goto NO_EXT;
    
    uleft = uright = vleft = vright = TRUE ;
    gmsf.bounded = TRUE ;
    gmsf.bspsf = srfGeom ;
    gmsf.sfgen_cv = NULL;
    extSfGeom.bspsf    = NULL;
    extSfGeom.sfgen_cv = NULL;
    
    BSsftgeomsf ( &gmsf, tst_all, type, &bsrc );
    if ( bsrc != BSSUCC )
    {
      goto	NO_EXT;
    } 
    else 
    {
      if ( gmsf.sfgen_cv != NULL )
      {
	BSfreecv ( msg, gmsf.sfgen_cv );
	gmsf.sfgen_cv = NULL;
      }
    }
    for ( i = 0; i < 3 ; i++ )
    {
      point1[i] = box[i] ;
      point2[i] = box[i+3] ;
    }
    
    dist = BSdistptpt( &bsrc, point1, point2 );
    option = 0;
    
    BSxgmsfdst ( &gmsf, dist, option, uleft,uright, vleft, vright,
		 &extSfGeom, &dist_out, &bsrc );
    if( bsrc != BSSUCC )	goto NO_EXT;
    
    srfGeom = extSfGeom.bspsf;
    
    cst.geometry = (char *)srfGeom ;
    
    ext_surface.osnum = surface.obj_id.osnum ;
    
    sts = om$construct(  	classid = OPP_EMSsubbs_class_id,
				osnum   = OM_Gw_current_OS,
				p_objid = &ext_surface.objid );
    
    sts = om$send( msg = message GRgraphics.GRconstruct(&cst),
		   targetid = ext_surface.objid,
		   targetos = ext_surface.osnum );
    
    surface._grid = ext_surface ;
    NO_EXT :
      _FREE( srfGeom ); 
    p_sf = &surface ;
    
  }
  
  /*
   * Intersect surface and axis of beam, if no solution is found, take
   * end of beam which is closest to surface, if several solutions are
   * found, well take the first one.
   */
  
  vs$get_geometry(	msg	= msg,
			grobjId	= &bmSupps[bmAXIS]._grid,
			grobjEnv= &bmSupps[bmAXIS].mod_env,
			geometry= &axisGeom ) ;
  __CheckRC( 1, *msg, "vs$get_geometry", wrapup ) ;
  
  sts = VSintersectCurveAndSurface(	msg,
					&bmSupps[bmAXIS]._grid,
					&bmSupps[bmAXIS].mod_env,
					&p_sf->_grid,
					&p_sf->mod_env,
					is_planar,
					intPnt,
					&intParam ) ;
  
  if( !( sts & 1 & *msg ) ) {
    /*
     * No intersection.
     */
    
#ifdef ACCEPT_SURFACE_OFF_CURVE
    
    int		num ;		/* Points at min dist.	*/
    double	*T = NULL,	/* Parms on curve	*/
                *UV= NULL,	/* Parms on surface	*/
                dist ;		/* Minimum distance	*/
    IGRpoint	*cvPnt = NULL,	/* Points on curve	*/
                *sfPnt = NULL ;	/* Points on surface	*/
    
    interFailed = TRUE ;
    __DBGpr_com( "No intersection" ) ;
    __DBGpr_mat( "Matrix", p_sf->_matrix ) ;
    
    vs$get_geometry(	msg	= msg,
			grobjId	= &surface._grid,
			grobjEnv= &surface.mod_env, 
			geometry= &sfGeom ) ;
    __CheckRC( 1, *msg, "vs$get_geometry", wrapup ) ;
    
    BSmdistcvsf(	axisGeom,
			sfGeom,
			&num,
			&T,
			&UV,
			&cvPnt,
			&sfPnt,
			&dist,
			msg ) ;
    
    if( BSERROR( *msg ) ) { *msg = EMS_E_BSerror ; goto wrapup ; }
    
    intParam = T[0] ;
    VSvccpy( intPnt, cvPnt[0] ) ;
    
    _FREE( T ) ; _FREE( UV ) ; _FREE( cvPnt ) ; _FREE( sfPnt ) ;
#else
    goto wrapup ;
    
#endif /* ACCEPT_SURFACE_OFF_CURVE */
  }
  /* --------------------------------
   * TR179801097 Pretend intersection fails if the axis
   * just barely touches the surface.  The problem is that later on
   * the surface-surface intersections tend to fail so want to use
   * projection
   */
  else {
    
    /* ----------------------------------------------------------
     * Dealing with parameter values here so cannot use tolerance
     * If this causes problem then need to check the min distance
     */
    if ((intParam > .9999) || (intParam < .0001)) {
      interFailed  = TRUE;
      interFailedX = TRUE; // Special flag so this project uses same profile
      // That intersect would use, TR179801135
      
    }
  }
  
  __DBGpr_dbl( "Param. for section", intParam ) ;
  
  /*
   * We shall use the tangent to axis at `intParam' as a projection
   * vector of cross-section onto surface.
   */
  
  if( vs$is_curve_linear( msg = msg, curveGeom = axisGeom ) ) {
    
    BSmkvec( msg, prjVec, axisGeom->poles, axisGeom->poles + 3 ) ;
    
  } else {
    double	eval[6] ;  /* Buffer for BScveval	*/
    
    BScveval(
      axisGeom,		/* IN  : curve geometry	*/
      intParam,		/* IN  : t of evaluation*/
      1,			/* IN  : point+tangent	*/
      (IGRpoint *) eval,	/* OUT : buffer		*/
      msg ) ;
    if( BSERROR( *msg ) ) { *msg = EMS_E_CurveError ; goto wrapup ; }
    VSvccpy( prjVec, eval + 3 ) ;
  }
  
  BSnorvec( msg, prjVec ) ;
  __DBGpr_vec( "Projection vector", prjVec ) ;
  
  /*
   * Now ask beam to generate a profile at the desired t-parameter, with
   * our display representation.
   */
  /* TR179801097 Works better when sent to the beam vice my_id */
  sts = om$send(	msg	 = message ACncpx.ACget_NV_rep( &beamRep ),
			targetid= bmId.objid,
			targetos= bmId.osnum ) ;
  
  /* If the beam is in a 2d rep then use the 3d rep and project
   * Dont't really like this but it is the way the original intersect
   * worked. TR179801135
   */
  if (beamRep & AC_2D_REP) {
    interFailed = TRUE;
    beamRep = AC_3D_REP;
  }
  
  if( interFailed) {
    
    /* ----------------------------------------------------------------
     * TR179801135
     * If the intersection has failed or the beam was a 2d rep then
     * always use a 3d rep
     * If we pretend it failed because the surface just touched the beam end
     * then follow the intersection rule and use the beam's rep
     */ 
    if (interFailedX) myRep = beamRep;
    else              myRep = AC_3D_REP;
    sts = om$send(msg = message 
		  VSbeam.VSextractProfile(
		    msg,
		    &bmEnv,
		    &bmSupps[bmSURF],
		    &bmSupps[bmAXIS],
		    intParam,
		    &cst,
		    myRep,
		    &profile ),
		  targetid= bmId.objid,
		  targetos= bmId.osnum ) ;
    __CheckRC( sts, *msg, "VSbeam.VSextractProfile", wrapup ) ;
    
    __DBGpr_obj( "Extracted profile", profile ) ;
    
    /*
     * Now offset profile curve if requested.
     */
    if( cvOffset != 0. ) {
      
      sts = vs$offsetCurve(msg	= msg,
			   cvEnv	= myEnv,
			   cvId	= &profile,
			   offset	= cvOffset,
			   normal	= NULL,
			   cst	= &cst,
			   offCvId	= &offPrfl ) ;
      __CheckRC( sts, *msg, "cvOffset", wrapup ) ;
      
      if( *msg == EMS_I_Fail ) {
	/*
	 * Did not offset because value of `cvOffset' was bad.
	 */
	p_cv	      = &profile ;
	offPrfl.objid = NULL_OBJID ;
      } else {
	p_cv	      = &offPrfl ;
      }
      __DBGpr_obj( "Offset of profile", offPrfl ) ;
    } else {
      p_cv		      = &profile ;
    }
    
    /*
     * At last project (offset) profile onto input surface.
     */
    
    sts = vs$projectCompCurveOntoSurface( 
      msg	 = msg,
      compId	 = p_cv,
      compEnv	 = myEnv,
      vector	 = prjVec,
      surfaceId  = &p_sf->_grid,
      surfaceEnv = &p_sf->mod_env,
      cst        = &cst,
      projection = feetList ) ;
    __CheckRC( sts, *msg, "vs$projectCompCurveOntoSurface", wrapup);
    
  } else {
    /*
     * do an intersection of the beam and the surface
     */
    /*
     * Get solid component of source beam.
     */
    __DBGpr_com(" Doing Intersection of solid and surface ");
    
    myRep = beamRep;
    
    sts = om$send(	msg	= message VSfeature.VSforwardToSource(
      msg,
      OM_e_wrt_object,
      message NDmacro.ACreturn_foot(
	msg, VS_K_bmGrCmpName,
	&compSol._grid, NULL, NULL )),
			targetid= bmId.objid,
			targetos= bmId.osnum ) ;
    __CheckRC( sts, *msg, "NDmacro.ACreturn_foot", wrapup ) ;
    
    compSol.mod_env = bmEnv ;
    /*
     * Intersect solid components of source beam with parent surface.
     * NOTE: we do not use `EMintersect_two_element' here since the
     * composite curve it will give out will not have its components
     * ordered in the same way as the solid components ( which is a
     * composite surface ).
     */
    /* -----------------------------------------------------------
     * TR179801097 This is failing on a simple test case.
     * int2elem works but the above note implies there may be an
     * ordering issue.
     */
    sts = VSinterCompSurfWithSurf( msg, &compSol, p_sf, 
				   &cst, &compCurve ) ;
    __CheckRC( sts, *msg, "VSinterCompSurfWithSurf", wrapup ) ;
    
    /*
     * Now offset result if requested.
     */
    if( count > 2 ) {
      struct IGRplane planeOfCv ;
      IGRvector	offsetVec ;
      IGRpoint	plPoint ;
      
      planeOfCv.point = plPoint ;
      planeOfCv.normal= offsetVec ;
      sts = om$send(	msg	= message GRvg.GRdetplane(
	msg,
	&cst.env_info->_MATRIX_TYPE,
	cst.env_info->_MATRIX,
	&planeOfCv ),
			targetid= compCurve.objid,
			targetos= compCurve.osnum ) ;
      /*
       * if curve is not planar, the above will fail: 
       * do not offset.
       */
      __DBGpr_vec( "Offset vec", offsetVec ) ;
      __DBGpr_vec( "Pl point", plPoint ) ;
      if( sts & 1 & *msg ) {
	if( cvOffset != 0. ) {
	  sts = vs$offsetCurve(	
	    msg	= msg,
	    cvEnv 	= myEnv,
	    cvId  	= &compCurve,
	    offset 	= cvOffset,
	    normal 	= NULL,
	    cst	        = &cst,
	    offCvId	= &offPrfl ) ;
	  __CheckRC( sts, *msg, "cvOffset", wrapup ) ;
	  
	  if( *msg != EMS_I_Fail ) {
	    vs$bulk_delete( 
	      grids	= &compCurve,
	      theEnv	= myEnv ) ;
	    compCurve = offPrfl ;
	    offPrfl.objid = NULL_OBJID; // TR179801097
	    
	  } /* Else :
	     *
	     * Did not offset because value of
	     * `cvOffset' was bad.
	     */
	}
      } else {
	__DBGpr_com( "Comp. curve not planar " ) ;
      } 
    }
    feetList[0] = compCurve ;
  }
  
  *feetCount = 1 ;
  
  /* Store my rep */
  om$send(msg = message ACncpx.ACput_NV_rep( myRep ),
	  targetid= my_id ) ;
  
  __DBGpr_obj( "Projection of profile", feetList[0] ) ;
  /*
   * Update object tag, don't check return code: will be
   * OM_W_NOTTAGGED if object has no tag connection.
   */
  om$change_tag_version() ;
  
  wrapup :
    _FREE( axisGeom ) ; _FREE( sfGeom ) ;
  /*
   * Get rid of temporary objects.
   */
  if( ext_surface.objid != NULL_OBJID )
    vs$bulk_delete( grids 	= &ext_surface , 
		    theEnv 	= cst.env_info );
  
  vs$bulk_delete( grids = &profile, theEnv = cst.env_info ) ;
  vs$bulk_delete( grids = &offPrfl, theEnv = cst.env_info ) ; 
  
  vs$bulk_delete( objenvs = &bigPlane ) ;
  
  if( !( sts & 1 & *msg ) ) {
    vs$bulk_delete( grids	= feetList,
		    theEnv	= cst.env_info ) ;
    
    vs$bulk_delete( grids = &compCurve,
		    theEnv= myEnv ) ;
    
    if( purpose & VS_K_InitialPlacement ) {
      if( *msg & 1 ) *msg = MSFAIL ;
      sts = OM_W_ABORT ;
    } else {
      if( *msg & 1 ) *msg = EMS_E_NoSolution ;
      sts = OM_S_SUCCESS ;
    }
  }
  End
    return sts ;
  
} /* method ACconstruct_feet */
/*----------------------------------------------------------------------------*/

end implementation VSprjCrsSctn ;
