/* $Id: COpla_cs2el.u,v 1.1.1.1 2001/01/04 21:10:02 cvs Exp $  */

/***************************************************************************
 * I/STRUCT
 *
 * File:	pplcmd/COpla_cs2el.u	
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COpla_cs2el.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:10:02  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/30  10:08:06  pinnacle
# STRUCT 2.5.1
#
# Revision 1.2  1998/02/03  19:23:48  pinnacle
# TR179702554
#
# Revision 1.1  1997/05/08  14:03:58  pinnacle
# Struct 250
#
# Revision 1.2  1996/10/16  12:46:10  pinnacle
# Replaced: pplcmd/COpla_cs2el.u for:  by s241_int for struct
#
# Revision 1.1  1996/09/06  10:02:02  pinnacle
# Created: pplcmd/COpla_cs2el.u by svkadamb for struct
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *			suresh		Creation	
 *      02/03/98        ah              TR179702554 Would not compile under Solaris, 
 *                                      Cleaned up the header files
 ***************************************************************************/
/*
	------------------------------------------------------------------

	File Name :		COpla_cs2el.u
	
	Creation  :		Suresh

	Description :

		This macro constructs a coordinate system 
		between a beam and a beam or plate.
		The coordinate system will be later used to place an
		end cut macro.
		This files takes all the graphical inputs 
		and the inputs from the form needed for the macro

	History :
	
	July 29, 1996  : creation date.

	------------------------------------------------------------------
*/
#include "VDppl.h"
#include "msdef.h"
#include "msmacros.h"

#include "vsmiscpplmac.h"
#include "vsdbgmacros.h"

#include "vscsby2el.h"
#include "vsgadgetCS.h"
#include "VSmsg.h"

#define FORM_NAME	"VScsBy2El.frm"
#define FORM_LABEL	100
#define EXP_DOUBLE	0


/* 
 * external variables ( Used by more than one function in this file ) 
 */

Form 			frm;
struct GRsymbology      symbl;
struct GRmd_env         rmy_md_env;
struct GRid 		rotate_objid;
int			toggle_value;
double                  prev_rotang;
OM_S_CLASSLIST  	locate_eligible_thing;
struct GRid 		TEMP[MAX_TEMP],swap;
//struct GRmd_env 	MOD_ENV;
GRobj 			MAC1;
int 			suc,i;
IGRchar			mes_f[80];
GRclassid       	fromClass[2];
int			form_displayed,form_exists,it_is_a_plate;
long			stat;
int 			options[5];

struct CIform_st   	form_st;

extern	OMuword		OPP_VSplate_class_id,
			OPP_VSbeam_class_id;


/* 
 * External functions 
 */
extern 			FIf_new(), 
			FIf_display(), 
			FIf_erase(), 
			FIf_delete(),
			FIf_is_valid(),
			FIf_set_cmd_oid_os();
			
extern			FIg_set_text(), 
			FIg_enable(), 
			FIg_disable(), 
			FIfld_set_select(),
			FIfld_get_active_row(),
			FIg_set_state_off(), 
			FIg_get_state(), 
			FIg_erase(), 
			FIg_display();

extern 			GRdpb_get(), 
			GRsymbology_options(), 
			GRdisplay_object();

extern 			DPmacupdate();

extern int	 	ci_notification();

extern 			EXputq2();

extern	 		ASmake_source_from_env();
extern long 		EXP_create_double();

/*==========================================================================*/
main()
{
	while(1)
	{
        
step1:
	if(!ci$locate(	prompt       = "Identify Beam",
			classes      = "VSbeam",
			properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
			owner_action = LC_RIGID_COMP  | 
				       LC_RIGID_OWNER | LC_FLEX_COMP | 
				       LC_FLEX_OWNER  | LC_REF_OBJECTS,
			obj          = &(TEMP[0].objid),
			osnum        = &(TEMP[0].osnum),
			md_env       = &MOD_ENV    )) break;
	ASmake_source_from_env( &TEMP[0],&MOD_ENV,&TEMP[0]);	

	locate_eligible_thing.w_count  = 2;
	locate_eligible_thing.w_flags  = 1;
 
	fromClass[0] = OPP_VSplate_class_id;
	fromClass[1] = OPP_VSbeam_class_id;
	
	locate_eligible_thing.p_classes  = fromClass;
 
	if(!ci$locate( prompt       	= "Identify Plate/Beam",
                       eligible_classes = &locate_eligible_thing,
                       properties   	= LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                       owner_action 	= LC_RIGID_COMP  |
                                     	  LC_RIGID_OWNER | LC_FLEX_COMP |
                                    	  LC_FLEX_OWNER  | LC_REF_OBJECTS,
	               obj          	= &(TEMP[1].objid),
                       osnum        	= &(TEMP[1].osnum),
                       md_env       	= &MOD_ENV    )) goto step1;
	ASmake_source_from_env( &TEMP[1],&MOD_ENV,&TEMP[1]);	

   	ci$get_module_info(md_env = &MOD_ENV);
        if (vs$is_ancestry_valid(   object   = &( TEMP[1] ),
                                    classid  = OPP_VSplate_class_id ) == TRUE)
                it_is_a_plate = 1;
        else
                it_is_a_plate = 0;


	stat = form_init();   	

        for(i=IDX_CS_OPT;i<MAX_TEMP;i=i+1)
	{
                TEMP[i].objid = NULL_OBJID;
 
                stat = exp$create(    
				exp_name   = NULL,
				exp_value  = (IGRdouble) options[i-IDX_CS_OPT],
				osnum      = MOD_ENV.md_id.osnum,
				p_exp_id   = &(TEMP[i].objid),
				p_osnum    = &(TEMP[i].osnum) );
		if (!(stat&1)) {
			__DBGpr_com("Problems at creating expression\n");
		}
	}

	MAC1 = NULL_OBJID;   
   	ci$send(msg = message nci_macro.init( &suc,
                                        0,
				        "pla_cs2el",
					7,
					TEMP,
					NULL,
                                        &MOD_ENV ),
		targetid = MAC1,
	        targetos = MOD_ENV.md_id.osnum );
	if( suc == 0 ){
		write("placement of nci_macro \"pla_cs2el\" failed\n");
		status("placement of nci_macro \"pla_cs2el\" failed");
      		ci$send(msg = message Root.delete(0),
			targetid = MAC1,
			targetos = MOD_ENV.md_id.osnum );
	}
	}
}
/*==========================================================================*/
init(){
	strcpy(mes_f,"<Assoc> Place Coordinate System By 2 Elements");
}
/*==========================================================================*/
wakeup(){
	message(mes_f);
	if( form_displayed ) 
		FIf_display(frm);
}
/*==========================================================================*/
void return_error()
{
	status(" PPL Program  Unsuccessful ");
	status ("");
	message(""); 
	exit;
}
/*==========================================================================*/
int  form_init()
{
	int         error;
	int         sts1, ii, i_ret;
	char        sstr[33];
 
	i_ret = 0;
	ii = 0;
	sts1  = 1;
	error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &frm );
	if ( frm == NULL )
	{
		return_error();
	}
 
	form_exists = TRUE;
 
	error = FIf_set_cmd_oid_os( frm, MY_ID, OM_Gw_current_OS );
	if ( error )
	{
        	form_exists = FALSE;
		return_error();
	}
	FIfld_set_select(frm,G_INTER,0,0,1);
	FIfld_set_select(frm,G_ORIGIN,0,0,1);
	FIfld_set_select(frm,G_YAXIS,0,0,1);
 
	FIg_erase(frm,G_INT_PLATE_OP0_TEXT);
	FIg_erase(frm,G_INT_PLATE_OP1_TEXT);
	FIg_erase(frm,G_INT_PLATE_OP2_TEXT);
	FIg_erase(frm,G_INT_PLATE_OP3_TEXT);
	FIg_erase(frm,G_INT_BEAM_OP0_TEXT);
	FIg_erase(frm,G_INT_BEAM_OP1_TEXT);
	FIg_erase(frm,G_INT_BEAM_OP2_TEXT);
	FIg_erase(frm,G_INT_BEAM_OP3_TEXT);
 
	FIg_erase(frm,G_YAXIS_OP0_TEXT);
	FIg_erase(frm,G_YAXIS_OP1_0_TEXT);
	FIg_erase(frm,G_YAXIS_OP1_1_TEXT);
 
	for (i = 0;i < OPTIONS_NUMBER; i = i + 1)
		options[i] = 0; 

	if (it_is_a_plate) 
        	FIg_display(frm,G_INT_PLATE_OP0_TEXT);
	else
        	FIg_display(frm,G_INT_BEAM_OP0_TEXT);

	FIg_display(frm,G_YAXIS_OP0_TEXT);

	error = FIf_display( frm );

	if ( error )
	{
		return_error();
	}
 
	form_displayed = TRUE;  /* Flag for sleep function */

	while (1)
	{
		ci$get( response = &msg, prompt="Set Parameters");
		if( msg == MOVE_ON )
		{
			FIf_delete( frm );
			form_displayed = FALSE;
			break;
		}
	}
	return error&1 ;
}
/*==========================================================================*/
void form_notification()
{
	int             status, msg, suc;
	double  	mat[16], diff;
	int 		row, pos;
	char 		array[200];
	int		response;

	status = OM_S_SUCCESS;
	suc = OM_E_INVARG;

	if (frm == NULL ) return_error();

	FIg_set_text(frm,47," ");
 
	if (	form_st.gadget_label != FI_CANCEL && 
		form_st.gadget_label != FI_CVT_TO_PERM_WIN &&
		TEMP[1].objid == NULL_OBJID) {
		ex$message( msgnumb = VS_E_Need_PlOrBeam , buff = array);
		ex$message( msgnumb = VS_E_Need_Inputs , buff = array);
		FIg_set_text(frm,47,array);

		if (form_st.gadget_label == FI_ACCEPT)
			FIg_set_state_off(frm,FI_ACCEPT);
		return_error();
  	}

	switch (form_st.gadget_label) {

	case FI_ACCEPT :

		status = ci$send ( 	msg = message CEO.erase_form_by_label(
								frm, 0, &suc),
					targetid = my_id );

		FIfld_get_active_row(frm,G_INTER,&(options[0]),&pos);
		FIfld_get_active_row(frm,G_ORIGIN,&(options[1]),&pos);
		FIg_get_state(frm,G_GEN_XAXIS,&(options[2]));
		FIg_get_state(frm,G_XAXIS,&(options[3]));
		FIfld_get_active_row(frm,G_YAXIS,&(options[4]),&pos);
 
		FIg_set_state_off(frm,FI_ACCEPT);

		FIf_erase ( frm );
		ci$put ( response = MOVE_ON );

		break;

	case FI_CANCEL :
			status = ci$send ( msg = message CEO.erase_form_by_label
			                                        ( frm, 0, &suc),
					   targetid = my_id);

			FIg_set_state_off(frm,FI_CANCEL);
			FIf_delete( frm );
			response = TERMINATE ;
			ex$putque ( msg = &msg, response = &response ) ; 
			break;
	case G_INTER :

		FIfld_get_active_row(frm,G_INTER,&row,&pos);
		FIg_erase(frm,G_INT_PLATE_OP0_TEXT);
		FIg_erase(frm,G_INT_PLATE_OP1_TEXT);
		FIg_erase(frm,G_INT_PLATE_OP2_TEXT);
		FIg_erase(frm,G_INT_PLATE_OP3_TEXT);
		FIg_erase(frm,G_INT_BEAM_OP0_TEXT);
		FIg_erase(frm,G_INT_BEAM_OP1_TEXT);
		FIg_erase(frm,G_INT_BEAM_OP2_TEXT);
		FIg_erase(frm,G_INT_BEAM_OP3_TEXT);

		switch (row) {

	        case 0 :
			if (it_is_a_plate) 
				FIg_display(frm,G_INT_PLATE_OP0_TEXT);
			else
				FIg_display(frm,G_INT_BEAM_OP0_TEXT);
			break;
		case 1 :
			if (it_is_a_plate) 
				FIg_display(frm,G_INT_PLATE_OP1_TEXT);
			else
				FIg_display(frm,G_INT_BEAM_OP1_TEXT);
			break;
		case 2 :
			if (it_is_a_plate) 
				FIg_display(frm,G_INT_PLATE_OP2_TEXT);
			else
				FIg_display(frm,G_INT_BEAM_OP2_TEXT);
			break;
		case 3 :
			if (it_is_a_plate) 
				FIg_display(frm,G_INT_PLATE_OP3_TEXT);
			else
				FIg_display(frm,G_INT_BEAM_OP3_TEXT);
			break;
		}
		break;

	case G_YAXIS :

	FIfld_get_active_row(frm,G_YAXIS,&row,&pos);
	FIg_erase(frm,G_YAXIS_OP0_TEXT);
	FIg_erase(frm,G_YAXIS_OP1_0_TEXT);
	FIg_erase(frm,G_YAXIS_OP1_1_TEXT);

	switch (row) {

		case 0 :

			FIg_display(frm,G_YAXIS_OP0_TEXT);
			break;

		case 1 :
			FIg_get_state(frm,G_GEN_XAXIS, &pos);
			if (pos) {
				FIg_display(frm,G_YAXIS_OP0_TEXT);
			} else {
				FIg_get_state(frm,G_XAXIS, &pos);
				if (pos)
					FIg_display(frm,G_YAXIS_OP1_1_TEXT);
				else
					FIg_display(frm,G_YAXIS_OP1_0_TEXT);
			}
			break;	
	}
	break;
 
	case G_GEN_XAXIS :
		FIfld_get_active_row(frm,G_YAXIS,&row,&pos);
		if (row) {
			FIg_erase(frm,G_YAXIS_OP0_TEXT);
			FIg_erase(frm,G_YAXIS_OP1_0_TEXT);
			FIg_erase(frm,G_YAXIS_OP1_1_TEXT);
		}
		FIg_get_state(frm,G_GEN_XAXIS, &pos);
		if (pos) {
			FIg_display(frm,G_YAXIS_OP0_TEXT);
			FIg_disable(frm,G_YAXIS);
      		} else {
			FIg_enable(frm,G_YAXIS);
			if (row) {
				FIg_get_state(frm,G_XAXIS, &pos);
				if (pos)
					FIg_display(frm,G_YAXIS_OP1_1_TEXT);
				else
					FIg_display(frm,G_YAXIS_OP1_0_TEXT);
			}
		}
	break;
 
	case G_XAXIS :
		FIg_get_state(frm,G_GEN_XAXIS, &pos);
		if(!pos) {
			FIfld_get_active_row(frm,G_YAXIS,&row,&pos);
			if (row) {
				FIg_erase(frm,G_YAXIS_OP0_TEXT);
				FIg_erase(frm,G_YAXIS_OP1_0_TEXT);
				FIg_erase(frm,G_YAXIS_OP1_1_TEXT);
				FIg_get_state(frm,G_XAXIS, &pos);
				if (pos)
					FIg_display(frm,G_YAXIS_OP1_1_TEXT);
				else
					FIg_display(frm,G_YAXIS_OP1_0_TEXT);
			}
		}
		break;
	}
}
/*==========================================================================*/
sleep(){
	if( form_displayed )
		FIf_erase(frm);
}
/*==========================================================================*/
