/* $Id: VSreportStr.u,v 1.2 2002/04/15 14:51:45 ahundiak Exp $  */
 /* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	VSreportStr.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VSreportStr.u,v $
 *	Revision 1.2  2002/04/15 14:51:45  ahundiak
 *	ah
 *	
 *	Revision 1.1  2001/01/17 14:58:46  ramarao
 *	*** empty log message ***
 *	
# Revision 1.5  2000/09/25  15:13:30  pinnacle
# Replaced: struct/pplapp/VSreportStr.u for:  by jvhanson for Service Pack
#
# Revision 1.4  2000/09/21  20:57:08  pinnacle
# Replaced: struct/pplapp/VSreportStr.u for:  by jvhanson for Service Pack
#
# Revision 1.3  2000/09/21  18:34:42  pinnacle
# Replaced: struct/pplapp/VSreportStr.u for:  by jvhanson for Service Pack
#
# Revision 1.2  2000/09/21  15:50:50  pinnacle
# Replaced: struct/pplapp/VSreportStr.u for:  by jvhanson for Service Pack
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	09/20/00	jvh		Creation date
 *      04/04/02        ah              Tweak include files to compile
 * -------------------------------------------------------------------*/

#include "VDppl.h"

#include "cieveryone.h"
#include "cimacros.h"
#include "OMindex.h"
#include "grmacros.h"
#include "VDmem_ppl.h"
#include "EMSopt.h"

#define  ALLOCSIZE	2000
//extern IGRint          free();
#define  tmpfilename	".process.log"
#define MEM_FREE( arg ) if( arg ){ free( arg ); arg = 0;}
extern GRget_properties( );
extern GRsymbology_options();
extern VDgetName();
extern IGRint EX_get_global();


/* added support to report information about this ppl */
#include "VDpplInfo.h"
ppl_info()
{
	VDpplInitInfo( &PPL_INFO );

	/* Define Command info structure */

	strcpy( PPL_INFO.title, "Report Structural Levels" );
        strcpy( PPL_INFO.product, "ISDP I/STRUCT" );
        strcpy( PPL_INFO.version, "02.06.01.15" );
        strcpy( PPL_INFO.desc_short, "List all the levels that structure is on" );

        PPL_INFO.desc_count = 2 ;   /* maximnum 10 */
	
        PPL_INFO.desc[0]="\tThis command will scan an active object space and report all of the structure and the levels that they occupy." ;
        PPL_INFO.desc[1]="\tThe report will be output to .process.log in the local directory. If this command is run from VSvalidate then the output will be posted back into the VSvalidate form so the user can do something with the results." ;
	return 1;
}

main(){
//int argc;
//char **argv;


  IGRchar		msgstr[512];
  int		        i, jj, i0, j0, k0, k, m0, cnt, cnt1, sts;
  long     		msg;
  double		pnt[3];
  double 		num;
  IGRchar		msg_str[512], name[128];
  IGRchar		pad[10];
  
  struct GRid	        obj_id;
  struct GRmd_env       MOD_ENV;
  IGRchar		lev[6];
  IGRchar		objstr[10];
  IGRint		objstrlen;
  struct GRid           macro;
  IGRint		inc;
  IGRint		count;
  IGRint		max_obj;
  IGRchar		classname[128];
  IGRushort 		options;
  IGRint		numbdrys;
  IGRshort           	props;
  struct GRsymbology	symb;
  FILE			*logfile ;
  OM_S_OBJID	        *list;
  IGRchar         	filename[128];
  IGRint		var_size;
  IGRint          	bad_var ;
  struct EX_var_list	ex_var[2];
  IGRint		filenamelen;
 
  if( logfile == NULL ){
	  logfile = ( FILE * ) fopen( tmpfilename , "w") ;
	  if ( logfile == NULL) {
		printf("could not open the log file \n" ) ;
		fclose( logfile);
		exit;
	  }
  }

  message ( "Report level that struct elements are on" );
  
  var_size = 1024;

  ex_var[0].var = 1;
  ex_var[0].var_value = &filename[0];
  ex_var[0].num_bytes = &var_size;

  ex_var[1].var = NULL;

  msg = EX_get_global( 0, &ex_var[0], &bad_var);
  filenamelen = strlen( filename );
  
  list = NULL;

  ci$get_module_info ( md_env = &MOD_ENV );
	
  max_obj = OM_GA_OSDs[MOD_ENV.md_id.osnum]->CurSpaceMapSize;

  #ifdef DEBUG
  printf("Scanning %d objects looking for structure\n",max_obj);
  #endif
  
  list = _MALLOC( ALLOCSIZE, OM_S_OBJID );
  
  if( list == NULL ){ 
  	printf("failed on malloc\n");
  	goto wrapup;
  }
  
  inc = ALLOCSIZE;
  
  count = 0;
  
  sprintf(msgstr,"Scanning %d elements for structure", max_obj );
  status( msgstr );
  
  objstrlen = strlen(itoa(max_obj));
  
  for(i=0;i<max_obj;i=i+1)
  {
      if( i == max_obj/2   ){ status("50% of the file read");}
      if( i == max_obj/4   ){ status("25% of the file read");}
      if( i == max_obj*3/4 ){ status("75% of the file read");}

     msg = om$get_classname(objid = i,
                osnum = MOD_ENV.md_id.osnum,
                classname = classname );

     if(!(msg&1)) continue;
     
     // check classid to see if it is a surface
                
     msg = om$is_ancestry_valid(subclassname = classname,
                superclassname = "VSbeam");
                
     if( (msg != OM_S_SUCCESS) ){
     
         sts = om$is_ancestry_valid(subclassname = classname,
                superclassname = "VSplate");
                
         if( (sts != OM_S_SUCCESS) ){
            continue;
         }
     }
     

     obj_id.osnum  = MOD_ENV.md_id.osnum;
     obj_id.objid  = i;
     
     /* check to see if the suface is visible */
     
     GRget_properties( &obj_id , &props );
     
     if((! (props & GRIS_DISPLAYABLE) ) ||
        (! (props & GRIS_LOCATABLE  ) )) {
        
        #ifdef DEBUG
        printf(" Object is NON LOCATE/NON DISPLAY, so skip it id[%d, %d]\n", 
        	obj_id.objid, obj_id.osnum );
        #endif
        
        continue;
     }
     
     #ifdef DEBUG
     printf("om$is_ancestry_valid id[%d,2] count=%d classname[%s] msg=%d\n",
     		 i,count, classname, msg );
     #endif

     count = count + 1;
     
     if( count >= inc ){
     	inc = inc + ALLOCSIZE;
     	_REALLOC( list, inc, OM_S_OBJID );
     }
     
     /* save the objid of the surface */
     list[ count - 1 ] = i;
     
   }

   status("100% of file read");
   
   jj=count;
   sprintf ( msgstr, "Number of structure elements found=%d \n", jj  );
   
   #ifdef DEBUG
   printf("%s", msgstr );				
   #endif
   
   fprintf ( logfile , "%s", msgstr );
   
   #ifdef DEBUG   
   for ( i0=0; i0 < jj; i0=i0+1){
      printf("id[%d]=[%d, 2]\n", i0, list[i0] );
   }
   #endif
        
   sprintf(msgstr,"writing output for %d struct objects", jj );
   status(msgstr);
   
   obj_id.osnum = 2;
   
   for(j0=0;j0<jj;j0=j0+1){
    
      #ifdef DEBUG
      printf("i[%d] of %d,",j0, jj );
      #endif
      
      if( j0 == jj/2   ){ status("50% of the objects are output");}
      if( j0 == jj/4   ){ status("25% of the objects are output");}
      if( j0 == jj*3/4 ){ status("75% of the objects are output");}

      obj_id.objid  = list[j0];
          
      gr$get_symbology( object_id = &obj_id, symb = &symb);
         
      msg = om$get_classname(objid = obj_id.objid,
                osnum = obj_id.osnum,
                classname = classname );
      
      ci$send(msg = message GRvg.GRgetname(
                &msg,
                name),
                targetid = obj_id.objid,
                targetos = obj_id.osnum);

      if( strcmp( name, "") == 0 ){ 
      		strcpy( name, "Unnamed");
      }else{
      	//trim the filename out of the path
      	for( m0 = 0; m0<strlen( name )-(filenamelen+2); m0=m0+1){
      		name[m0] = name[m0+filenamelen+2];
      	}
      	name[m0] = 0;
      }
            
      #ifdef DEBUG
      printf("5loop j0=%d, jj=%d\n", j0,jj);
      #endif
      
      if( symb.level < 100){ 
      	sprintf(lev,"  %d", symb.level );
      }else if( symb.level < 1000) {  
      	sprintf(lev," %d", symb.level );
      }else{ 
        sprintf(lev,"%d", symb.level );
      }
      
      strcpy( pad, "");
      m0 = strlen( itoa( obj_id.objid ));
      for( k=m0;k<objstrlen;k=k+1){
      	strcat( pad," ");
      } 
      strcat( pad, itoa( obj_id.objid ));
      
      //sprintf( msgstr , "level[%s] ID[%s, 2] classname[%s]\t%s\n", 
      //			 lev , pad, classname, name );
      
      sprintf( msgstr , "lv[%s] %s ID[%s, 2] class[%s]\n", 
      			 lev , name, pad, classname );
      			
      #ifdef DEBUG
      printf ( "%s", msgstr );
      #endif
      fprintf ( logfile , "%s", msgstr );
      
   }
   status("all of the objects are output");
   #ifdef DEBUG
   printf ( "\n");
   #endif

wrapup:

  _FREE( list );
  
  if( logfile != NULL ){
    fclose( logfile);
    logfile = NULL;
  }
  
  status("sorting the data");
  
  sprintf( msgstr, "/usr/bin/cat %s | sort > .tmpfile;/usr/bin/mv .tmpfile %s",
  		tmpfilename, tmpfilename );
  sh( msgstr );
  
  /* if a filename was specified copy the hidden file to a visible one*/
/*
  printf("argc=%d\n",argc );
  
  if( argc == 1 ){
     sprintf(msgstr , "cp %s %s",
            tmpfilename,  (char *)argv[1] );
     sh( msgstr );
  }
*/
  status("output is in .process.log");  

}
