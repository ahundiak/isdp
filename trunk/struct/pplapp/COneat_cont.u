/* $Id $  */

/*************************************************************************
 * I/STRUCT
 *
 * File:        pplapp/COneat_cont.u
 *
 * Description: Command PPL to place neat_cont macro.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY   AUTHOR   	DESCRIPTION
 *      07/18/00   Rama Rao     File Creation
 *************************************************************************/

#include "VDppl.h"
#include "coparamac.h"

extern 	ASmake_source_from_env(), ASstart_var_fence(), ASend_fence(),
	VSbulkDisplayByGRobj_envs();

#define MAX_TEMP	31

main()
{
IGRlong			sts, msg, response;
IGRint			i, j, locNum, num_plates;
IGRchar			inPrompt[50], path[200];
struct GRid		neat_cont, csId, TEMP[MAX_TEMP];
struct GRobj_env	objOE, *locOEs, plateOE[MAX_TEMP-1];
struct GRmd_env		loc_env;

   message( "Place Neat Contour" );

   locNum     = 0;
   num_plates = 0;
   locOEs     = NULL;
   path[0]    = '\0' ;

   ci$get_module_info( md_env = &loc_env );

   sts = ci$locate(  prompt       = "Locate Coordinate Sytem / Move on for Base CS",
                     classes      = "GRgencs",
                     owner_action =  LC_RIGID_OWNER |
                                     LC_RIGID_COMP  |
                                     LC_FLEX_COMP   |
                                     LC_FLEX_OWNER  |
                                     LC_REF_OBJECTS,
                     stackable    = 1,
                     response     = &response,
                     md_env       = &objOE.mod_env,
                     obj          = &csId.objid,
                     osnum        = &csId.osnum);
   if( !(sts & 1) )
   {
	sts = di$give_pathname(osnum = loc_env.md_id.osnum, pathname = path );
	if( (sts&1) && path[0] != '\0' )
        {
	   strcat( path, ":usr:BASEcoordsys" );
	   sts = di$translate( objname = path,
			       p_objid = &csId.objid,
			       p_osnum = &csId.osnum   );
  	}
   }

   while( 1 )
   {
      locNum = 0;
      if( locOEs ) { free( locOEs ); locOEs = NULL; }

      if( !num_plates )		strcpy( inPrompt, "Locate Plate(s)" );
      else			
      {
	VSbulkDisplayByGRobj_envs( GRhd, num_plates, plateOE );
	strcpy( inPrompt, "Locate Plate(s) / Move on" );
      }

      sts = ci$locate( 	prompt       = inPrompt,
			classes      = "VSplate",
                    	owner_action = 	LC_RIGID_OWNER |
                                   	LC_RIGID_COMP  |
                                   	LC_FLEX_COMP   |
                                   	LC_FLEX_OWNER  |
                                   	LC_REF_OBJECTS,
                    	stackable    = 1,
                    	response     = &response,
                    	md_env       = &objOE.mod_env,
                    	obj          = &objOE.obj_id.objid,
                    	osnum        = &objOE.obj_id.osnum);

      if (!(sts & 1)) break;;

      switch( response ) 
      {
           case EX_OBJID:   // Object Set
	   {
      	      /* Grab Located Objects */
      	      as$start_fence(	set       = &objOE.obj_id,
				set_env   = &objOE.mod_env,
				nb_obj    = &locNum,
				p_obj_env = &locOEs );

      	      for(i = 0; i < locNum; i = i + 1 ) 
	      {
	        if( num_plates >= MAX_TEMP-1 ) 
		{
		   status(" Can not select more than 30 plates" );
		   goto wrapup;
	        }
	        for(j = 0; j < num_plates; j = j + 1 )
	           if( plateOE[j].obj_id.objid == locOEs[i].obj_id.objid &&
		       plateOE[j].obj_id.osnum == locOEs[i].obj_id.osnum )
		     break;

		if( j == num_plates )
		{
		   plateOE[num_plates] = locOEs[i];
		   num_plates = num_plates + 1;	
		}
      	      }

      	      ASend_fence();
      	      break;
	   }

    	   case EX_DATA:    // Single Object
	   {
	      if( num_plates >= MAX_TEMP-1 )
	      {
		status(" Can not select more than 30 plates" );
		goto wrapup;
	      }
              for(j = 0; j < num_plates; j = j + 1 )
                 if( plateOE[j].obj_id.objid == objOE.obj_id.objid &&
                     plateOE[j].obj_id.osnum == objOE.obj_id.osnum )
                   break;

              if( j == num_plates )
              {
                 plateOE[num_plates] = objOE;
                 num_plates = num_plates + 1;         
              }
              break;
	   }
	}
   }

   dp$erase_hilite( msg = &msg );

   while( 1 )
   {
      if( !num_plates ) break;

      strcpy( inPrompt, "Locate Trimming Curve(s) / Move on" );
      sts = ci$locate(  prompt       = inPrompt,
                        classes      = "GRcurve",
                        owner_action =  LC_RIGID_OWNER |
                                        LC_RIGID_COMP  |
                                        LC_FLEX_COMP   |
                                        LC_FLEX_OWNER  |
                                        LC_REF_OBJECTS,
                        stackable    = 1,
                        response     = &response,
                        md_env       = &objOE.mod_env,
                        obj          = &objOE.obj_id.objid,
                        osnum        = &objOE.obj_id.osnum);
      if( !(sts&1) ) break;

      plateOE[num_plates] = objOE;
      num_plates = num_plates + 1;
   }

   dp$erase_hilite( msg = &msg );

   ASmake_source_from_env( &csId, &loc_env, &TEMP[0] );

   for( i=0; i<num_plates; i=i+1 ) 
	ASmake_source_from_env( &plateOE[i].obj_id, &loc_env, &TEMP[i+1] );	

   neat_cont.objid = NULL_OBJID;
   neat_cont.osnum = loc_env.md_id.osnum;

   sts = ci$send(msg = message  nci_macro.init(
			&msg, 0, "neat_cont", num_plates+1, TEMP, 
			NULL, &loc_env ),
		targetid = neat_cont.objid,
		targetos = neat_cont.osnum );

wrapup:
   if( locOEs ) { free( locOEs ); locOEs = NULL; }
   return 1;
}
