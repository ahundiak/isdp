/* $Id $  */
/* --------------------------------------------------------------------
 * I/STRUCT	--	STRUCTURAL DETAILING MACROS
 *
 * File:	feature_id.u
 *
 * Description:	CI macro which returns values for miscellaneous bracket 
 *		flange parameters.  Use to customize bracket macros to suit
 *		local shipyard and/or project standards.
 *
 * Macro Inputs:
 *   chock_number	Chock type:  1 - 7.
 *   letter	   	ID letter (0 = 'A', 1 = 'B', 2 = 'C').
 *
 * Macro Outputs:
 *   id			Chock type ID.
 *   pcmk		Standard piece mark string.
 *
 * Instructions:
 *   Customize code only within the marked area in the construct_comp()
 * function.  This is where the output values are set.  In a design file,
 * set the working macro library to the desired target library for the
 * CI macro.  Compile the .u file, which creates a macro named 'et_params'
 * in the working library.  Both the .e file and the macro library must
 * be local or in a global ppl/bin directory in order to place or
 * recompute the macro.
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      07/25/00        Tom Sauer 	File Creation.
 *
 *****************************************************************************/

#include	"VDppl.h"
#include 	"ci_mac_def.h"
#include	"AS_status.h"
#include	"VDtypedef.h"
#include	"VDexp.h"	// for vdexp$Get().

// Set the number of templates and the number of feet.

#define	NUM_TEMP	1
#define	NUM_FEET 	1

// Set the macro name.  Macro name must match the .u file name.

#define MACRO_NAME 	"feature_id"

IGRdouble		exps[NUM_TEMP];
IGRchar 		*temp_names[NUM_TEMP];
IGRchar			*feet_names[NUM_FEET];
IGRint			temp_types[NUM_TEMP];
IGRint			stat, i;
GRobj 			ci_mac_def1;
struct GRid		CI_MACRO_ID, OUTPUT_GRID[NUM_FEET];

// EDIT:  add user variables as required.

IGRchar		id[20];		// Used to pass output to macro.
IGRchar		pcmk[20];

extern GRclassid OPP_ASsource_class_id;
extern GRclassid OPP_ACpretend_class_id;

extern GRdpb_get();
extern EX_get_modid_given_osnum();

extern int 	sprintf(),
		printf();
extern		ASsuper_construct();


/* ========================================================================= */
/* the main function is the one implementing the definition creation         */
/* ========================================================================= */

main ()
{
  // Fill in all the template names and types.

  temp_names[0]  = "IDString";  
  temp_types[0]  = text_type;
//  temp_types[0] = parameter_generic;	// An expression.

  feet_names[0]  = "id";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef            =  ci_mac_def1,
		status 	            = &stat,
	 	name                = MACRO_NAME,
              	temp_num            = NUM_TEMP,
		temp_names          = temp_names,
		temp_types          = temp_types,
	      	extern_feet_num     = NUM_FEET,
	 	extern_feet_names   = feet_names );
}

/* ========================================================================= */

construct_comp()
{

// Initialize the expression id.

  for ( i=0; i<NUM_FEET; i=i+1)
  {
    OUTPUT_GRID[i].objid = NULL_OBJID;
    OUTPUT_GRID[i].osnum = MOD_ENV.md_id.osnum;
  }

// Get the template expressions and values.

  getExpressionText( 0, id );

// ********** End customizations **************

// Create the expression feet.

  stat = ci$send( msg = message Gtext_exp.create( NULL, id, &msg ),
		  targetid = OUTPUT_GRID[0].objid,
		  targetos = OUTPUT_GRID[0].osnum );
  as$status( sts = stat );
}

//NOTHING SHOULD HAVE TO BE DONE BELOW HERE
/* ========================================================================= */

compute ()
{
  int i;

  construct_comp();

  for( i=0; i<NUM_FEET; i=i+1)
  {
     if( OUTPUT_GRID[i].objid == NULL_OBJID) return(0); 
  }

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, NUM_FEET, OUTPUT_GRID, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}

/* ========================================================================= */

place ()
{
int i;

  construct_comp();


  for( i=0; i<NUM_FEET; i=i+1)
  {
     if( OUTPUT_GRID[i].objid == NULL_OBJID) return(0); 
  }

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, NUM_FEET, OUTPUT_GRID, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}


/* ========================================================================= */

/* --------------------------------------------
 * Utility for extracting obj_env from source
 */
int
VDpplGetObjectEnv( objID, objOE )
  TGRid*	objID;
  TGRobj_env*	objOE;
{
  IGRstat	retFlag;
  IGRstat	sts, suc;
  GRclassid	classID;

// Init
  retFlag = 0;
  objOE->obj_id.objid = NULL_OBJID;

// Filter Nulls.

  if ( ( objID == NULL ) ||
       ( objID->objid == 0 ) || 
       ( objID->objid == NULL_OBJID ) )
    goto wrapup;

// Check to see if ASsource or ACpretend.

  classID = 0;
  om$get_classid(
    objid = objID->objid,
    osnum = objID->osnum,
    p_classid = &classID
  );
  sts = om$is_ancestry_valid(
    subclassid   = classID,
    superclassid = OPP_ASsource_class_id
  );
  if ( sts == OM_S_SUCCESS ) goto have_source;
  sts = om$is_ancestry_valid(
    subclassid   = classID,
    superclassid = OPP_ACpretend_class_id
  );
  if ( sts == OM_S_SUCCESS ) goto have_source;

// Object is in the same os and needs no translation

  objOE->obj_id = *objID;
  gr$get_module_env( buffer = &objOE->mod_env );
  retFlag = 1;
  goto wrapup;

have_source:
  /* A return_foot works properly for nested macros
   * Get the beam as desired, a nested macro is actually a
   * component and does not really have a parent
   * this message gets sent to an ACpretdef object
   */
  sts = ci$send( 
    msg = message NDmacro.ACreturn_foot(
      &suc,  ".", 
      &objOE->obj_id,
      &objOE->mod_env.md_env.matrix_type,
       objOE->mod_env.md_env.matrix
    ),
    targetid = objID->objid,
    targetos = objID->osnum 
  );

//printf("The foot: %d,%d\n",objOE->obj_id.osnum,objOE->obj_id.objid);

/* I origianlly used this return_go which matches some
 * of regular dot i code
 * but we get the beam solid instead of the beam itself for nested
 * unnested works through ref files.
 *
 * Need to test on nested macro with beam in ref file
 * Might want to replace the dotI code with a return foot?
 */
/*
  // Get the object
  sts = ci$send(
    msg	= message NDnode.ASreturn_go(
      &objOE->obj_id,
      &objOE->mod_env.md_env.matrix_type,
       objOE->mod_env.md_env.matrix),
    targetid = objID->objid,
    targetos = objID->osnum 
  );
*/
  // Set md_id to the reference file
  objOE->mod_env.md_id.osnum = objOE->obj_id.osnum;
  sts = ex$get_modid(
    mod_osnum =  objOE->mod_env.md_id.osnum, 
    mod_id    = &objOE->mod_env.md_id.objid
  );
  if (!(sts & 1)) goto wrapup;
 
  retFlag = 1;

wrapup:
  return retFlag;
}

/* --------------------------------------------
 * Gets the parent of a macro
 */
int
VDpplGetParent( macroID, index, parentOE )
  TGRid*	macroID;
  IGRint	index;
  TGRobj_env*	parentOE;
{
  IGRstat	retFlag;
  IGRstat	sts, msg;
  TGRid		parentID;

// Init

  retFlag = 0;
  parentOE->obj_id.objid = NULL_OBJID;
  parentID.objid = NULL_OBJID;

// Get the parent object

  sts = ci$send( 
    msg = message ACcpx.ACfind_exp_temp_obj(&msg,index,&parentID),
    targetid = macroID->objid,
    targetos = macroID->osnum 
  );
  if (!(sts & msg & 1)) goto wrapup;
  if (parentID.objid == NULL_OBJID) goto wrapup;

// Un Source it

  VDpplGetObjectEnv( &parentID, parentOE );

  if ( parentOE->obj_id.objid == NULL_OBJID ) goto wrapup;

  retFlag = 1;

wrapup:
  return retFlag;
}

// This is a function that uses the template index and returns a text string.

int
getExpressionText( index, text )
  IGRint	index;
  IGRchar*	text;
{
  IGRint	msg, stat;
  TGRobj_env	parentOE;

// Get the input expression by index.

  VDpplGetParent( &CI_MACRO_ID, index, &parentOE );

  if ( parentOE.obj_id.objid != NULL_OBJID ) 
  {
    vdexp$Get( objOE = &parentOE, txt = text );
    return( 0 );
  }
  else
  {
    return( 1 );
  }
}

//This is a function that uses the template index and returns a double value
int	Get_expression_value(index, outval)
int	index;
double	*outval;
{
struct GRid	CUV,GCV;
int		msg,stat;
double		exp;
IGRshort	mat_type;
IGRdouble	matrix[16];

      //get the input expression by index
      msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,index,&CUV),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );

#ifdef DEBUG
      write("ACcpx.ACfind_exp_temp_obj stat =",stat,"\n");
#endif

     if( !(msg&stat&1) ) return;

     msg = ci$send( msg = message NDmacro.ACreturn_foot(	
		&stat,	".", &GCV, &mat_type, matrix ),
		targetid = CUV.objid,
		targetos = CUV.osnum );

     if( !(msg&stat&1) ){
		status(" bad element " );
		return -1;
     }

     msg = ci$send( msg = message expression.NDgive_value(&exp),
                targetid = CUV.objid,
		targetos = CUV.osnum );

     if ( msg != 1)//if this was an ACpretend
     {
     	msg = ci$send( msg = message expression.NDgive_value(&exp),
                targetid = GCV.objid,
		targetos = GCV.osnum );
     }

#ifdef DEBUG
     printf("CUV[%d, %d], GCV[%d, %d], msg= %d, exp=[%.3f]\n",
		CUV.objid,CUV.osnum,GCV.objid,GCV.osnum,msg, exp);
#endif

     *outval = exp;
     return msg;
}
