/* $Id $  */
/* --------------------------------------------------------------------
 * I/STRUCT
 *
 * File:        struct/pplapp/PartMark.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log $
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/18/00        Rama Rao        Header Creation.
 *      07/08/00        ah              Used vdexp to get text expression value
 * -------------------------------------------------------------------*/

#if 0
#define DEBUG 		1	 /* for debugging purpose */
#define DEBUGPLUS 	1	 /* for debugging purpose */
#endif

#define MACRO_NAME	"PartMark"
#define MAX_TEMP	3
#define MAX_FEET	2
#define MAX_CHAR_FEET	10

#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "AS_status.h"
#include "nddef.h"
#include "exmacros.h"
#include "vsgeommacros.h"
#include "cotxmacros.h"

#include "VDppl.h"
#include "VDobj.h"
#include "VDexp.h"

//#include "vsdrw.h"

enum VS_e_DirectionType {
                                VShorizontal,
                                VSvertical
} ;
typedef enum VS_e_DirectionType VSdirectionType ;

enum VS_e_drwTxDir              {
                                        VShoriz = 100,
                                        VSpara  = 110,
                                        VSortho = 120
} ;
typedef enum VS_e_drwTxDir VSdrwTxDir ;


extern			EX_get_modid_given_osnum(), VSfindDirOfCvInXYPlane(),
			VSgetDirType(), VSfindMidPtCvInXYPlane(),
			VSdrwGetMidTxOrientAndJust(), init_cnst_list(),
			GRplace_text(), free(), isalnum();

struct GRid 	CI_MACRO_ID ;    
struct GRid 	GEOM[MAX_FEET] ; 

IGRlong	place_text( text, crv_id, crv_env, outpt )
IGRchar		*text;
struct GRid	*crv_id;
struct GRmd_env *crv_env;
struct GRid	*outpt;
{
IGRlong			sts, msg;
IGRint			hasNoDir, txJust, txLength;
IGRvector		cvDir, midTn;
IGRpoint		midPt;
IGRmatrix               txMx;
struct IGRbsp_curve	*crv_geom;
VSdirectionType         cvDirType ;
  
  crv_geom = NULL;
  txLength = strlen( text );

  vs$get_geometry( msg      = &msg,
                   grobjId  = crv_id,
                   grobjEnv = crv_env,
                   geometry = &crv_geom ) ;
  if( !(msg&1) ) goto wrapup;

  VSfindDirOfCvInXYPlane( &msg, crv_geom, cvDir, &hasNoDir ) ;
  if( hasNoDir ) 
  {
     cvDir[0] = 1. ; cvDir[1] = cvDir[2] = 0. ;
     cvDirType = VShorizontal ;
  } 
  else 
  {
     cvDirType = VSgetDirType( cvDir ) ;
  }

  VSfindMidPtCvInXYPlane( &msg, crv_geom, midPt, midTn ) ;
  
  VSdrwGetMidTxOrientAndJust( &msg, midTn, cvDirType, VSpara, txMx, &txJust ) ;

  init_cnst_list();
  get_symb();
  dis.color      = cnst_list.color;
  dis.weight     = cnst_list.weight;
  dis.style      = cnst_list.style;

  sts = co$place_text(	msg		= &msg,
			ModuleInfo	= &MOD_ENV,
			lbs_matrix	= txMx,
			text_string	= text,
			text_length	= &txLength,
			ActiveDisplay	= &dis,
			ActiveLevel	= cnst_list.level,
			origin		= midPt,
			flags		= 0,
			buffer		= outpt );

wrapup:
  if( crv_geom ) 	free( crv_geom );
  return 1;
}

IGRlong copyGeometry(compute_flag, gr_obj )
        IGRboolean      compute_flag ; /* I : FALSE (place), TRUE (compute) */
        struct GRid     *gr_obj  ;        /* O : list of tangent lines */
{
IGRshort		rc;
IGRlong			rc_evaluate, sts, msg;
IGRint 			i, num_lines, num_ent, i_msg, length;
IGRchar			textExp[128], *p;
struct GRid             OBJ;
struct GRmd_env         OBJ_ENV;
struct GRobj_env	textOE;
struct ret_struct	expr;
 
    num_lines   = 0;
    num_ent     = 0;
    rc_evaluate = 1;

    ci$get_module_info(md_env = &MOD_ENV);

    gr_obj [0].objid = NULL_OBJID;
    gr_obj [0].osnum = MOD_ENV.md_id.osnum;

    gr_obj [1].objid = NULL_OBJID;
    gr_obj [1].osnum = MOD_ENV.md_id.osnum;

    sts = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&i_msg,1,&OBJ),
              targetid = CI_MACRO_ID.objid,
              targetos = CI_MACRO_ID.osnum );
    if( !(sts&i_msg&1) )return;

    #if DEBUG 
	printf("OBJ = %d, %d\n", OBJ.objid, OBJ.osnum) ;
    #endif

    sts = ci$send( msg = message  ACcpx.ACfind_temp_struct(&msg,"Type",
				&expr, &MOD_ENV ),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
    strcpy( textExp, expr.var.text_st.text_string );
    length = strlen( textExp );

    for( i=0; i<length; i=i+1 )  
	if( !isalnum(textExp[i] ) )   break;

    if( i != length ) 
    {
        vdobj$GetTemplate(objID = &CI_MACRO_ID, nth = 2, templateOE = &textOE);
        ci$send( msg = message expression.list( textExp ),
                        targetid = textOE.obj_id.objid,
                        targetos = textOE.obj_id.osnum );
	p = strchr( textExp, '=' );
	if( p )
        {
	   strcpy( textExp, p+1 );
	   p = strchr( textExp, ' ' );
	   if( p ) *p = '\0' ;
        }
    }

    #if DEBUG 
	printf("Text = %s\n", expr.var.text_st.text_string );
    #endif

    sts = ci$send( msg      = message NDmacro.ACreturn_foot(
                                        &msg ,
                                        "",
                                        &OBJ,
                                        &OBJ_ENV.md_env.matrix_type,
                                        OBJ_ENV.md_env.matrix ),
                 targetid = OBJ.objid,
                 targetos = OBJ.osnum) ;
    if (!(sts & 1)) 
    {
        #ifdef DEBUG
        printf("Problem when sending NDmacro.ACreturn_foot() message \n") ;
        #endif
        rc_evaluate = 0 ;
        goto quit ;
    }
    OBJ_ENV.md_id.osnum = OBJ.osnum ;
    ex$get_modid( mod_osnum = OBJ_ENV.md_id.osnum,
		  mod_id    = &OBJ_ENV.md_id.objid );

    sts = ci$send( msg        = message GRgraphics.GRcopy(
                                                         &msg,
                                                         &OBJ_ENV,
                                                         &MOD_ENV,
                                                         &gr_obj [0].objid ),
                        targetid = OBJ.objid,
                        targetos = OBJ.osnum  );

    if( !( sts & 1 ) ){
         #if DEBUG 
              printf( "mapgeom.u -  GRgraphics.GRcopy error\n" ) ;
         #endif
         return 0;
    }

    place_text( textExp, &OBJ, &OBJ_ENV, &gr_obj [1] );

quit:
    return rc_evaluate;
}



/* ------------------------------------------------------------------------- */
/*    The main function is the one implementing the definition creation      */
/* ------------------------------------------------------------------------- */


main ()
{
IGRint  i ;
IGRlong stat;
IGRchar *temp_names[MAX_TEMP] ;
IGRchar *feet_names[MAX_FEET] ;
IGRchar buffer[MAX_CHAR_FEET * MAX_FEET] ;
IGRint  temp_types[MAX_TEMP]  ;
GRobj   ci_mac_def1    ;

    temp_names[0] = "Structure"  ;
    temp_types[0] = macro_generic ;

    temp_names[1] = "InputGeom"  ;
    temp_types[1] = other_generic | line_generic | curve_generic | conic_generic ; 

    temp_names[2] = "Type";
    temp_types[2] = parameter_generic ;

    feet_names[0] =  "Geom";
    feet_names[1] =  "text";

    ci_mac_def1 = NULL_OBJID ;

    ac$cimacdef(cimacdef          = ci_mac_def1,
		status 	          = &stat, 	
		name              = MACRO_NAME,
              	temp_num          = MAX_TEMP, 		
		temp_names        = temp_names,
		temp_types	  = temp_types,
	      	extern_feet_num   = MAX_FEET,
		extern_feet_names = feet_names ) ;

}

place ()
{
IGRboolean  compute_flag ;
IGRlong     sts, msg ;

    compute_flag = FALSE ;
    sts = copyGeometry(compute_flag, &GEOM[0]) ; /* get surface boundaries */
    if (!(sts & 1)) 
    {
	#ifdef DEBUG
	printf("\nplace() : error in copyGeometry()\n\n") ; 
	#endif
	return 0 ;
    }

    #if DEBUG 
      printf("MAX_FEET = %d, GEOM[0] = %d, %d, GEOM[1] = %d, %d\n", MAX_FEET,
                GEOM[0].objid, GEOM[0].osnum, GEOM[1].objid, GEOM[1].osnum );
    #endif

    sts = ci$send(msg = message ci_macro.set_all_extern_feet
				(&msg, 2, GEOM, &MOD_ENV),
	targetid = CI_MACRO_ID.objid,
	targetos = CI_MACRO_ID.osnum) ; as$status(sts = sts) ;
    if (!(sts & msg & 1)) 
    {
	printf("Error with ci_macro.set_all_extern_feet() in place() method \n") ;
	return 0 ;
    }

    return 1 ;
} /* place() */

compute ()
{
IGRboolean  compute_flag ;
IGRlong     sts, msg ;

    compute_flag = TRUE ;
    sts = copyGeometry(compute_flag, &GEOM[0]) ;
    if (!(sts & 1)) 
    {
	#ifdef DEBUG
	printf("\ncompute() : error in copyGeometry()\n\n") ; 
	#endif
	return 0 ;
    }

    sts = ci$send(msg = message ci_macro.set_all_extern_feet
				(&msg, MAX_FEET, &GEOM[0], &MOD_ENV),
	targetid = CI_MACRO_ID.objid,
	targetos = CI_MACRO_ID.osnum) ; as$status(sts = sts) ;
    if (!(sts & msg & 1)) 
    {
	#ifdef DEBUG
	printf("Error with ci_macro.set_all_extern_feet() in compute() method \n") ;
	#endif
	return(0) ;
    }
    return(1);
} /* compute() */
