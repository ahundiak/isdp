/* $Id: forms_annot.u,v 1.1.1.1 2001/01/04 21:07:41 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/vdannot/imp / forms_annot.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: forms_annot.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:41  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
 * FROM         Ad Zuurhout
 *
 * DESCRIPTION
 *              This ppl file contains a copy information of the ppl file
 *              "dim_forms.u", which is loaded optionally in GRNUC.
 *              In case this was not done, the command object "Place
 *              Formatted Text With Leader" and "Place Item Number" failed.
 *
 *              Therefor a copy of the information is defined in this
 *              ppl command.
 *
 * CREATION     30-SEP-1992
 */

#include "cieveryone.h"
#include "cisend.h"
#include "cievent.h"
#include "cierrordef.h"
#include "cilocate.h"
#include "ciexec.h"
#include "madef.h"
#include "msdef.h"

#include "fontdef.h"
#include "font.h"
#include "fontmacros.h"

#include "asbox.h"

#include "FI.h"
#include "FEI.h"
#include "CIforms.h"
#include "exfi.h"

#include "dimdef.h"
#include "dimformdef.h"
#include "dim.h"
#include "dimmacros.h"
#include "dimform.h"
#include "dimdload.h"
#include "dimfmext.h"
#include "dimglobal.h"
#include "dimgraph.h"
#include "form_env.h"
#include "form_loc.h"
#include "dm_status.h"
#include "igrtypedef.h"
#include "OMminimum.h"
#include "igewindef.h"
#include "igecolordef.h"
#include "igecolmacros.h"
#include "ctype.h"
#include "dimcomplex.h"
#include "msdef.h"
#include "msmacros.h"
#include "DMmsg.h"


extern int printf(), sprintf(),fprintf();
extern char *malloc();
extern int free();
extern int GRget_font_info();
extern ASsuper_construct();
extern ci_notification();
extern strtok();
/*extern IGEgetnmfrclr();*/
/*extern IGEgetclrfrnm();*/
extern DMset_SR_lockout();
extern FIg_reset();
extern FIg_enable();
extern DMget_scale();
extern MSmessage();

extern struct DMenv_param frm_env;
extern struct DMloc_param frm_loc;
extern struct DMmisc_param frm_misc;
extern struct DMsenv_param frm_senv;
extern struct DMglobal_param frm_glob;
extern struct DMweld_param frm_weld;
extern struct DMgadget_stack edit_stack;
extern int    frm_state;
extern struct GRid Dim_grid;
#ifdef X11
extern int FI_lock_SR_in_Display;
#endif

IGRshort GEOM_TYPE, DISPLAY_TYPE;

int super_user;
struct CIform_st form_st;

	/*****************************************************

	This variable indicates the current state of gadget
	selection, data selection and active stack:

	Possible Values:

	STATE_NONE		- Neither editing a dimension
				  nor changing the global dim
				  parameters.

				  This state is possible when
				  the user chooses "edit dim"
				  command and the command is
				  waiting for the user to
				  locate a dimension. All the
				  gadgets are turned off and
				  no "dm" keyins are allowed.

	STATE_GLOBAL		- All changes are to the global
				  parameters and to any active
				  dimensions (in placement).
				  This is the normal state. All
				  gadgets are turned ON. Stack
				  if OFF.

	STATE_DIMENSION		- Changes are to a single or a
				  group of dimensions. This
				  state is possible when the
				  edit dimension command is
					  active and a dimension is
				  located. The command would
				  wait for the user to make
				  all the changes and apply
				  those changes to the dimesion
				  object(s).

	STATE_REPLAY		- Replay of chages - form display
				  should not be affected.

	*****************************************************/

extern struct DMkeyin_desc DMkeyin_list[];
extern struct DMform_info DMform_list[FORM_COUNT+1];
int SRstatus[FORM_COUNT];

	/*****************************************************

	Information on the forms being maintained by this PPL
	file. This information include the names, ids, display
	status etc.

	The last entry in the array stores dummy information
	for supporting the "dm" keyin not on the form.

	*****************************************************/

char input_status[80];

#define FORM_DISPLAYED is_form_displayed((int)p_dm_gadget->form_no)

struct
{
	char	selection[MAX_LABEL_COUNT];
	char	display[MAX_LABEL_COUNT];
} display_status[FORM_COUNT];

OMuword current_os;		/* Module Object Space */
OMuword transient_os;		/* Transient Object Space */

init()
{
	int form_no, label;

	trace_in("init");

	ASsuper_construct();

	ci$get_module_info(md_os = &current_os);
	transient_os = my_os();
	frm_state = STATE_GLOBAL;
	Dim_grid.objid = NULL_OBJID;
	edit_stack.count = 0;
	super_user = FALSE;

	for (form_no=0; form_no<FORM_COUNT; form_no=form_no+1)
	{
		DMform_list[form_no].form_id = NULL;

		for (label=0; label<MAX_LABEL_COUNT; label=label+1)
		{
			display_status[form_no].selection[label] = ON;
			display_status[form_no].display[label] = OFF;
		}
	}

	RETURN(TRUE);
}

stack_gadget(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int index;
	int form_no, label;

	trace_in("stack_gadget");

	if (!p_dm_gadget->stackable) RETURN(TRUE);

	if (edit_stack.count >= (EDIT_STACK_SIZE - 1))
	{
		write("stack_gadget: Stack Overflow\n");
		RETURN(FALSE);
	}
	else if (edit_stack.count < 0)
	{
		write("stack_gadget: Stack Underflow\n");
		RETURN(FALSE);
	}

	form_no = p_dm_gadget->form_no;
	label = p_dm_gadget->label;

/*
	for (index=0; index<edit_stack.count; index=index+1)
	{
		if (edit_stack.gadget[index].form_no == form_no
		&&  edit_stack.gadget[index].label == label)
		{
			edit_stack.gadget[index] = *p_dm_gadget;
			RETURN(TRUE);
		}
	}
*/
	edit_stack.gadget[edit_stack.count] = *p_dm_gadget;
	edit_stack.count = edit_stack.count + 1;
	RETURN(TRUE);
}

update_active_dim()
{
	IGRint  sts, rc;
	struct GRid env_grid, senv_grid;
	int on, off;
	extern OM_S_CHANSELECT ND_children;

	trace_in("update_active_dim");

	dm$get_dim_param(type = DM_ENV_PARAM, p_grid = &env_grid);
	dm$get_dim_param(type = DM_SENV_PARAM, p_grid = &senv_grid);
	
	sts =
	ci$send(msg = message DMroot.test_state((IGRshort)(DIM_IN_PLACEMENT), &on, &off),
		targetid = env_grid.objid,
		targetos = env_grid.osnum,
		p_chanselect = &ND_children);
	dm$status(sts = sts, action = RET_STATUS);

	if (on)
	{
		sts =
		ci$send(msg = message DMroot.set_dim_state(BIT_OR, (IGRchar)(DIM_NEEDS_UPDATE)),
			targetid = env_grid.objid,
			targetos = env_grid.osnum,
			p_chanselect = &ND_children);
		dm$status(sts = sts, action = RET_STATUS);

		if (frm_misc.tog_term) ci$put(cmd_key = "DMTgTr");
	}

	sts =
	ci$send(msg = message DMroot.test_state((IGRshort)(DIM_IN_PLACEMENT), &on, &off),		targetid = senv_grid.objid,
		targetos = senv_grid.osnum,
		p_chanselect = &ND_children);
	dm$status(sts = sts, action = RET_STATUS);

	if (on)
	{
		sts =
		ci$send(msg = message DMroot.set_dim_state(BIT_OR, (IGRchar)(DIM_NEEDS_UPDATE)),
			targetid = senv_grid.objid,
			targetos = senv_grid.osnum,
			p_chanselect = &ND_children);
		dm$status(sts = sts, action = RET_STATUS);
	}

	RETURN(TRUE);
}

update_global_attr(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	IGRint sts, target;
	struct GRmd_env md_env;
	IGRchar g_type, g_mask;
	IGRboolean compute;

	compute = FALSE;
	target = PASS_TO_ALLOS;

	if (p_dm_gadget->form_no == FORM_ENVIRON)
	{
		switch (p_dm_gadget->label)
		{
			case GAD_DET_COLR:
			g_mask = DIM_DETACHED;
			g_type = DIM_DETACHED;
			break;

			case GAD_DRVG_COLR:
			g_mask = DIM_DRIVING;
			g_type = DIM_DRIVING;
			break;

			case GAD_DIM_COLR:
			g_mask = DIM_DRIVING;
			g_type = 0;
			break;

			case GAD_DIM_MODE:
			g_mask = 0;
			g_type = 0;
			if (get_value_int(p_dm_gadget) == DETAILING_MODE)
				target = PASS_TO_CUROS;
			break;

			default:
			return(TRUE);
		}
	}
	else if (p_dm_gadget->form_no == NOT_ON_FORM)
	{
		switch (p_dm_gadget->label)
		{
			case KEY_DIM_DISP:
			g_mask = 0;
			g_type = 0;
			break;

			case KEY_VIEW_ANG:
			g_mask = 0;
			g_type = 0;
			break;

			case KEY_REF_TYPE:
			g_mask = DIM_REFERENCE;
			g_type = DIM_REFERENCE;
			compute = TRUE;
			break;

			default:
			return(TRUE);
		}
	}
	else return(TRUE);

	ci$get_module_info(md_env = &md_env);

	sts =
	DMglupdate(
		target,
		g_type,
		g_mask,
		(char)'\0',
		(char)'\0',
		compute,
		&md_env);
	dm$status(sts = sts);

	return(TRUE);
}

set_state(state)
int state;
{
	int num;

	trace_in ("init_flags");

	frm_state = state;
	for (num=0; num<FORM_COUNT; num=num+1)
	{
		if (DMform_list[num].form_id)
		{
			if (is_form_displayed(num))
				display_form(num);
		}
	}

	RETURN(TRUE);
}

sr_status(form_no)
int form_no;
{
	int num;
	int mask, display;
	Form form_id;

	trace_in("sr_status");

	for (num=0; num<FORM_COUNT; num=num+1)
	{
		if ((num == form_no) || (num == DMform_list[form_no].parent))
			continue;

		form_id = DMform_list[num].form_id;
		if (form_id == NULL) continue;

		FIf_is_displayed(form_id, &display);
		if (display)
		{
			FIf_get_attr(form_id, &mask);
			if (mask & FI_SAVE_RESTORE) RETURN(TRUE);
		}
	}

	RETURN(FALSE);
}

display_form(form_no)
int form_no;
{
	int sts, rc;
	struct EXFI_data_st wrn_str[3];
	Form form_id, parent_id;
	int parent_no;
	int x_orig, y_orig;
	int x_parent, y_parent;
	int display, num, mask;

	trace_in ("display_form");

	if (frm_state == STATE_REPLAY) RETURN(TRUE);

	if (sr_status(form_no))
	{
		/* A Save Restore Form is up */
		if (!is_form_displayed(form_no))
			ex$message(msgnumb = DM_I_SaveRestoreFrmActive);

		RETURN(TRUE);
	}

	if (DMform_list[form_no].form_id == NULL)
	{
		sts =
		FIf_new(form_no, DMform_list[form_no].form_name,
			ci_notification, &DMform_list[form_no].form_id);
		fi$status(form_no = form_no, comment = "FIf_new");

		sts =
		FIf_set_cmd_oid_os(DMform_list[form_no].form_id,
					MY_ID, OM_Gw_current_OS);
		fi$status(form_no = form_no, comment = "FIf_new");
	}

	form_id = DMform_list[form_no].form_id;

	sts = FIf_is_displayed(form_id, &display);
	fi$status(form_no = form_no, comment = "FIf_is_displayed");

	load_form(form_no);

	if (!display)
	{
		if ((DMform_list[form_no].sr_display == SR_DSP_FORCE) ||
		(DMform_list[form_no].sr_display == SR_DSP_AUTO))
		{
			sts = FIf_get_attr(form_id, &mask);
			fi$status(form_no = form_no, comment = "FIf_get_attr");

			mask = mask | FI_SAVE_RESTORE;
                        sts = DMset_SR_lockout();

                        FIg_enable(form_id, FI_CVT_TO_PERM_WIN);

			sts = FIf_set_attr(form_id, mask);
			fi$status(form_no = form_no, comment = "FIf_set_attr");
		}

		x_orig = DMform_list[form_no].x_orig;
		y_orig = DMform_list[form_no].y_orig;

		if (x_orig == -1)
		{
			sts = FIf_get_location(form_id, &x_orig, &y_orig);
			fi$status(form_no = form_no, comment = "FIfget_location");
		}

		parent_no = DMform_list[form_no].parent;
		if (parent_no != -1) /* sub form */
		{
			parent_id = DMform_list[parent_no].form_id;

			sts = FIf_get_location(parent_id, &x_parent, &y_parent);
			fi$status(form_no = form_no, comment = "FIf_get_location");

			x_orig = x_orig + x_parent;
			y_orig = y_orig + y_parent;
		}

		sts = FIf_set_location(form_id, x_orig, y_orig);
		fi$status(form_no = form_no, comment = "FIf_set_location");

		sts = FIf_display(form_id);
		fi$status(form_no = form_no, comment = "FIf_display");

#ifdef X11
                if ((DMform_list[form_no].sr_display == SR_DSP_FORCE) ||
                    (DMform_list[form_no].sr_display == SR_DSP_AUTO))
                {
                    /*
                        Make darned sure that the xforms s/r behavior gets
                        restored to the normal setting; otherwise s/r
                        forms won't come out of FIf_display and most
                        commands can't handle that.  See TR119301239.
                        This really should be a call to an xforms
                        function; we just got lucky that this global is
                        accessible.  I have filed a worksheet requesting a
                        function interface.  --Mike 02/10/93
                    */

                    FI_lock_SR_in_Display = 0;
                }
#endif
	}

	for (num=0; num<FORM_COUNT; num=num+1)
		SRstatus[num] = sr_status(num);

	RETURN(TRUE);
}

erase_form(form_no)
int form_no;
{
	int sts;
	int num;
	Form form_id;
	int display;

	trace_in("erase_form");
  
	form_id = DMform_list[form_no].form_id;
	if (form_id == NULL) RETURN(TRUE);

	sts = FIf_is_displayed(form_id, &display);
	fi$status(form_no = form_no, comment = "FIf_is_displayed");

	if (display)
	{
		sts = FIf_erase(form_id);
		fi$status(form_no = form_no, comment = "FIf_erase");
	}

	for (num=0; num<FORM_COUNT; num=num+1)
		SRstatus[num] = sr_status(num);

	RETURN(TRUE);
}

refresh_form(form_no)
int form_no;
{
	int sts;
	Form form_id;
	int num, display;

	trace_in("refresh_form");

	if (frm_state == STATE_DIMENSION)
	{
		sts = load_dim_info(Dim_grid);
		dm$status(sts = sts, action = RET_STATUS);
	}

	for (num=0; num<FORM_COUNT; num=num+1)
	{
		if (num == form_no) continue;
		form_id = DMform_list[num].form_id;
		if (form_id == NULL) continue;

		sts = FIf_is_displayed(form_id, &display);
		fi$status(form_no = form_no, comment = "FIf_is_displayed");

		if (display) display_form(num);
	}

	RETURN(TRUE);
}

locate_label(locate, form_no, label)
int locate;
int form_no;
int label;
{
	int sts, rc;
	Form form_id;

	trace_in("locate_label");

	form_id = DMform_list[form_no].form_id;
	if (form_id == NULL || SRstatus[form_no])
		RETURN(TRUE);

	if (locate)
	{
		sts = FIg_disable(form_id, label);
		fi$status(form_no = form_no, label = label, comment = "FIg_disable");
	}
	else
	{
		sts = FIg_enable(form_id, label);
		fi$status(form_no = form_no, label = label, comment = "FIg_enable");
	}

	RETURN(TRUE);
}

select_label(select, form_no, label)
int select;
int form_no;
int label;
{
	trace_in("select_label");

	if (SRstatus[form_no]) RETURN(TRUE);
	if (select)
		display_label(form_no, label);
	else	erase_label(form_no, label);
	display_status[form_no].selection[label] = select;

	RETURN(TRUE);
}

display_label(form_no, label)
int form_no;
int label;
{
	int sts;
	Form form_id;

	trace_in("display_label");

	form_id = DMform_list[form_no].form_id;
	if (form_id == NULL || SRstatus[form_no])
		RETURN(TRUE);
	sts = FIg_display(form_id, label);
	fi$status(form_no = form_no, label = label, comment = "FIg_display");

	RETURN(TRUE);
}

erase_label(form_no, label)
int form_no;
int label;
{
	int sts;
	Form form_id;

	trace_in("erase_label");

	form_id = DMform_list[form_no].form_id;
	if (form_id == NULL || SRstatus[form_no])
		RETURN(TRUE);
	sts = FIg_erase(form_id, label);
	fi$status(form_no = form_no, label = label, comment = "FIg_erase");

	RETURN(TRUE);
}

display_gadget(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int  sts, rc;
	Form form_id;
	int  label;
	int  form_no;
	int  selection;
	int  display;
	struct EXFI_data_st fi_data;

	trace_in ("display_gadget");

	label      = p_dm_gadget->label;
	form_no    = p_dm_gadget->form_no;
	form_id    = DMform_list[form_no].form_id;
	selection  = display_status[form_no].selection[label];

	if (form_id == NULL ||  SRstatus[form_no]) RETURN(TRUE);

	sts = FIg_get_attr(form_id, label, &display);
	fi$status(form_no = form_no, label = label, comment = "FIg_get_attr");

	if (display & FI_NOT_DISPLAYED) display = FALSE;
	else display = TRUE;

	if (selection == OFF)
	{
		if (display) erase_label(form_no, label);
	}
	else
	{
		sts = DMput_by_value(p_dm_gadget);
		dm$status(sts = sts, action = RET_STATUS);

//		if (!display)
		display_label(form_no, label);
	}

	RETURN(TRUE);
}

form_notification()
{
	int sts, redirect;
	struct DM_data_st dm_gadget;

	trace_in("form_input");

	if (form_st.form_label >= FORM_COUNT)
	{
		write("Illegal form_label ", form_st.form_label, "\n");
		RETURN(FALSE);
	}

	dm_gadget.origin = FORM_INPUT;

	/* - Resolve duplicate gadgets - */

	redirect = FALSE;

	/*
	printf("form_label = %d, gadget_label = %d\n", form_st.form_label,
			form_st.gadget_label);
	*/

	if (form_st.form_label == FORM_LOCAL)
	{
		if (form_st.gadget_label == GAD_TXT_HEIGHT)
		{
			FIg_get_value(form_st.form_ptr, GAD_TXT_HEIGHT, &form_st.value);
			dm_gadget.form_no = FORM_ENVIRON;
			dm_gadget.label = GAD_TXT_HEIG;
			dm_gadget.type = DIM_DOUBLE;
			dm_gadget.val.dvalue = form_st.value;
			dm_gadget.stackable = TRUE;
			redirect = TRUE;
		}
	}

	if (form_st.form_label == FORM_ENVIRON)
	{
		if ((form_st.gadget_label == GAD_COMM_ORIG_DOT) ||
		    (form_st.gadget_label == GAD_COMM_ORIG_CIRCLE) ||
		    (form_st.gadget_label == GAD_COMM_ORIG_NONE))
		{
			dm_gadget.form_no = FORM_ENVIRON;
			dm_gadget.label = GAD_COMM_ORIG;
			dm_gadget.type = DIM_INT;
			dm_gadget.stackable = TRUE;

			if (form_st.gadget_label == GAD_COMM_ORIG_DOT)
				dm_gadget.val.ivalue = 0;
			else if(form_st.gadget_label == GAD_COMM_ORIG_CIRCLE)
				dm_gadget.val.ivalue = 1;
			else	dm_gadget.val.ivalue = 2; 

			redirect = TRUE;
		}
	}

	if (!redirect)
	{
		sts = DMform_to_internal(&form_st, &dm_gadget);
		dm$status(sts = sts, action = RET_STATUS);
	}

	sts = user_input(&dm_gadget);
	dm$status(sts = sts, action = RET_STATUS);

	RETURN(TRUE);
}

keyboard_input(p_dm_keyboard)
struct DMkeyboard *p_dm_keyboard;
{
	int  sts;
	struct DM_data_st dm_gadget;

	trace_in("keyboard_input");

	p_dm_keyboard->status[0] = '\0';
	dm_gadget.origin = KEYBOARD_INPUT;
	dm_gadget.stackable = TRUE;

	sts = DMkeyboard_to_internal(p_dm_keyboard, &dm_gadget);
	if (!(sts & 1))
	{
		status(p_dm_keyboard->status);
		return(TRUE);
	}

	if (dm_gadget.label == SUPER_USER)
	{
		super_user = sval_int(dm_gadget);
		status(p_dm_keyboard->response);
		return(TRUE);
	}

	if (dm_gadget.label<0 && dm_gadget.form_no==NOT_ON_FORM && !super_user)
	{
		strcpy(p_dm_keyboard->status, "Parameter name not found");
		status(p_dm_keyboard->status);
		return(TRUE);
	}

	status(p_dm_keyboard->status);

	sts = DMinternal_to_keyboard(&dm_gadget, p_dm_keyboard, FALSE);
	error_chk(sts);

	input_status[0] = '\0';
	sts = user_input(&dm_gadget);
	error_chk(sts);

	if (strlen(input_status) > 0)
		status(input_status);
	else	status(p_dm_keyboard->response);

	RETURN(TRUE);
}

load_data()
{

	trace_in("load_data");

	if (frm_state != STATE_GLOBAL)
		RETURN(TRUE);

	dm$get_dim_param(type = DM_ENV_PARAM, p_data = &frm_env);
	dm$get_dim_param(type = DM_LOC_PARAM, p_data = &frm_loc);
	dm$get_dim_param(type = DM_MISC_PARAM, p_data = &frm_misc);
	dm$get_dim_param(type = DM_SENV_PARAM, p_data = &frm_senv);
	frm_misc.tog_term = FALSE;

	RETURN(TRUE);
}

save_data()
{
	int mod_type;

	trace_in("save_data");

	if (frm_state != STATE_GLOBAL)
		RETURN(TRUE);

	dm$put_dim_param(type = DM_ENV_PARAM, p_data = &frm_env);
	dm$put_dim_param(type = DM_LOC_PARAM, p_data = &frm_loc);
	dm$put_dim_param(type = DM_MISC_PARAM, p_data = &frm_misc);
	DMmerge_senv(&frm_senv, &frm_env, &frm_loc, &frm_misc);
	dm$put_dim_param(type = DM_SENV_PARAM, p_data = &frm_senv);
	dm$put_dim_param(type = DM_GLOB_PARAM, p_data = &frm_glob);
	dm$put_dim_param(type = DM_WELD_PARAM, p_data = &frm_weld);

	update_active_dim();

	RETURN(TRUE);
}

user_input(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int sts;
	int msg, target;
	struct GRmd_env md_env;

	trace_in ("user_input");

	switch (frm_state)
	{
		/**************/
		case STATE_GLOBAL:
		/**************/

		load_data();

		frm_misc.tog_term = FALSE;

		if ((p_dm_gadget->label == GAD_DIM_MODE) &&
		     (p_dm_gadget->form_no == FORM_ENVIRON))
		{
			ci$get_module_info(md_env = &md_env);

			if (get_value_int(p_dm_gadget) == MODELING_MODE)
				target = PASS_TO_CUROS;
			else	target = PASS_TO_REFOS;

			sts =
			DMdisplay_update(
				(char)'\0',
				(char)'\0',
				(char)'\0',
				(char)'\0',
				TRUE,
				FALSE,
				FALSE,
				0,
				NULL,
				target,
				&md_env);
			dm$status(sts = sts);
		}

		if (((p_dm_gadget->label == KEY_VIEW_ANG) ||
		     (p_dm_gadget->label == KEY_DIM_DISP))&&
		     (p_dm_gadget->form_no == NOT_ON_FORM))
		{
			ci$get_module_info(md_env = &md_env);

			sts =
			DMdisplay_update(
				(char)'\0',
				(char)'\0',
				(char)'\0',
				(char)'\0',
				TRUE,
				FALSE,
				FALSE,
				0,
				NULL,
				PASS_TO_ALLOS,
				&md_env);
			dm$status(sts = sts);
		}

		sts = process_gadget_input(p_dm_gadget);
		dm$status(sts = sts, action = RET_STATUS);

		save_data();
		update_global_attr(p_dm_gadget);

		RETURN(TRUE);

		/**************/
		case STATE_DIMENSION:
		/**************/

		sts = process_gadget_input(p_dm_gadget);
		dm$status(sts = sts, action = RET_STATUS);

		sts = stack_gadget(p_dm_gadget);
		dm$status(sts = sts, action = RET_STATUS);

		RETURN(TRUE);

		default:

		if (p_dm_gadget->form_no != NOT_ON_FORM)
		{
			switch (p_dm_gadget->label)
			{
				case GAD_CHECK:
				gadget_input_CHECK(p_dm_gadget);
				break;

				case GAD_RESTORE:
				gadget_input_RESTORE(p_dm_gadget);
				break;

				default:
				break;
			}
		}

		RETURN(TRUE);
	}
}

replay_stack()
{
	int sts, i;

	trace_in("replay_stack");

	frm_state = STATE_REPLAY;

	sts = load_dim_info(Dim_grid);
	dm$status(sts = sts, action = RET_STATUS);

	for (i=0; i<edit_stack.count; i=i+1)
	{
		sts = process_gadget_input(&edit_stack.gadget[i]);
		dm$status(sts = sts, action = RET_STATUS);
	}

	RETURN(TRUE);
}

warning(flag)
int flag;
{
	int form_no;
	Form form_id;

	trace_in("warning");

	if ((flag == CI_W_CLOSING_DGN) || (flag == CI_W_WRITING_DGN))
	{
		for (form_no=0; form_no<FORM_COUNT; form_no=form_no+1)
		{
			form_id = DMform_list[form_no].form_id;
			if (form_id)
			{
				FIf_erase(form_id);
				FIf_delete(form_id);
				DMform_list[form_no].form_id = NULL;
			}
		}

		ci$delete(file_name = "dim_forms");
	}

	RETURN(TRUE);
}

select_gadgets(form_no)
int form_no;
{
	int label;
	char *selection;

	trace_in("select_gadgets");

	selection = display_status[form_no].selection;
	switch (frm_state)
	{
		case STATE_NONE:

		for (label=0; label<MAX_LABEL_COUNT; label=label+1)
			selection[label] = OFF;
		break;

		default:

		for (label=0; label<MAX_LABEL_COUNT; label=label+1)
			selection[label] = ON;
		break;
	}

	RETURN(TRUE);
}

process_gadget_input(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int form_no;
	int label;

	trace_in("process_gadget_input");

	form_no = p_dm_gadget->form_no;
	label = p_dm_gadget->label;

	if (form_no != NOT_ON_FORM)
	{
		if (label == GAD_CHECK)
		{
			gadget_input_CHECK(p_dm_gadget);
			RETURN(TRUE);
		}
		else if (label == GAD_RESTORE)
		{
			gadget_input_RESTORE(p_dm_gadget);
			RETURN(TRUE);
		}
	}

	switch(form_no)
	{
		case FORM_ENVIRON:

		process_input_FORM_ENVIRON(p_dm_gadget);
		break;

		case FORM_LOCAL:

		process_input_FORM_LOCAL(p_dm_gadget);
		break;

		case FORM_DIMTERM:

		process_input_FORM_DIMTERM(p_dm_gadget);
		break;

		case FORM_FORMAT:

		process_input_FORM_FORMAT(p_dm_gadget);
		break;

		case FORM_DECACC_PRI:
		case FORM_DECACC_SEC:
		case FORM_DECACC_ANG:

		process_input_FORM_DECACC(p_dm_gadget);
		break;

		case FORM_FRAACC_PRI:
		case FORM_FRAACC_SEC:
		case FORM_FRAACC_ANG:

		process_input_FORM_FRAACC(p_dm_gadget);
		break;

		case FORM_DISPLAY:

		process_input_FORM_DISPLAY(p_dm_gadget);
		break;

		case FORM_ANG_ROFF:

		process_input_FORM_ANG_ROFF(p_dm_gadget);
		break;

		case NOT_ON_FORM:

		process_input_NOT_ON_FORM(p_dm_gadget);
		break;

		default:

		printf("process_gadget_input: Unknown form %d\n", form_no);
		break;
	}

	RETURN(TRUE);
}

process_input_FORM_ENVIRON(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int label;

	trace_in("process_input_FORM_ENVIRON");

	label = p_dm_gadget->label;

	switch (label)
	{
		case GAD_DIM_STAN:
		gadget_input_DIM_STAN(p_dm_gadget); break;

		case GAD_DUAL_MODE:
		gadget_input_DUAL_MODE(p_dm_gadget); break;

		case GAD_DIM_COLR:
		gadget_input_DIM_COLR(p_dm_gadget); break;

		case GAD_DET_COLR:
		gadget_input_DET_COLR(p_dm_gadget); break;

		case GAD_DRVG_COLR:
		gadget_input_DRVG_COLR(p_dm_gadget); break;

		case GAD_DIM_MODE:
		gadget_input_DIM_MODE(p_dm_gadget); break;

		case GAD_TXT_HEIG:
		gadget_input_TXT_HEIG(p_dm_gadget); break;

		case GAD_TXT_FONT:
		gadget_input_TXT_FONT(p_dm_gadget); break;

		case GAD_DIM_LAYR:
		gadget_input_DIM_LAYR(p_dm_gadget); break;

		case GAD_DELIMITER:
		gadget_input_DELIMITER(p_dm_gadget); break;

		case GAD_LIN_OFFS:
		gadget_input_LIN_OFFS(p_dm_gadget); break;

		case GAD_SYM_POSN:
		gadget_input_SYM_POSN(p_dm_gadget); break;

		case GAD_PROJ_OFFS:
		gadget_input_PROJ_OFFS(p_dm_gadget); break;

		case GAD_TXT_YOFF:
		gadget_input_TXT_YOFF(p_dm_gadget); break;

		case GAD_TXT_WEIG:
		gadget_input_TXT_WEIG(p_dm_gadget); break;

		case GAD_DIM_WEIG:
		gadget_input_DIM_WEIG(p_dm_gadget); break;

		case GAD_PROJ_EXTN:
		gadget_input_PROJ_EXTN(p_dm_gadget); break;

		case GAD_TOL_WEIG:
		gadget_input_TOL_WEIG(p_dm_gadget); break;

		case GAD_TOL_SIZE:
		gadget_input_TOL_SIZE(p_dm_gadget); break;

		case GAD_ASP_RATI:
		gadget_input_ASP_RATI(p_dm_gadget); break;

		case GAD_LEADING:
		gadget_input_LEADING(p_dm_gadget); break;

		case GAD_TRAILING:
		gadget_input_TRAILING(p_dm_gadget); break;

		case GAD_UNITS:
		gadget_input_UNITS(p_dm_gadget); break;

		case GAD_UNIT_SEL:
		gadget_input_UNIT_SEL(p_dm_gadget); break;

		case GAD_ANG_UNITS:
		gadget_input_ANG_UNITS(p_dm_gadget); break;

		case GAD_COMM_ORIG:
		gadget_input_COMM_ORIG(p_dm_gadget); break;

		case GAD_TER_SELECT:
		gadget_input_TER_SELECT(p_dm_gadget); break;

		case GAD_LIN_DISP:
		gadget_input_LIN_DISP(p_dm_gadget); break;

		case GAD_TER_LIMIT:
		gadget_input_TER_LIMIT(p_dm_gadget); break;

		case GAD_LABEL:
		gadget_input_LABEL(p_dm_gadget); break;

		case GAD_SUB_LABEL:
		gadget_input_SUB_LABEL(p_dm_gadget); break;

		case GAD_MAX_SUB:
		gadget_input_MAX_SUB(p_dm_gadget); break;

		default:
		printf("Unknown gadget %d\n", label);
		break;
	}

	RETURN(TRUE);
}

process_input_FORM_LOCAL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int label;

	trace_in("process_input_FORM_LOCAL");

	label = p_dm_gadget->label;

	switch(label)
	{
		case GAD_DISPLAY_PARAMS:
		gadget_input_DISPLAY_PARAMS(p_dm_gadget); break;

		case GAD_TOG_TERM:
		gadget_input_TOG_TERM(p_dm_gadget); break;

		case GAD_TOLE_SELECT:
		gadget_input_TOLE_SELECT(p_dm_gadget); break;

		case GAD_TOLE_DISPLAY:
		gadget_input_TOLE_DISPLAY(p_dm_gadget); break;

		case GAD_TOLE_UP:
		gadget_input_TOLE_UP(p_dm_gadget); break;

		case GAD_TOLE_LOW:
		gadget_input_TOLE_LOW(p_dm_gadget); break;

		case GAD_PREFIX:
		gadget_input_PREFIX(p_dm_gadget); break;

		case GAD_SUFFIX:
		gadget_input_SUFFIX(p_dm_gadget); break;

		case GAD_PRE_DISP:
		gadget_input_PRE_DISP(p_dm_gadget); break;

		case GAD_SUF_DISP:
		gadget_input_SUF_DISP(p_dm_gadget); break;

		case GAD_DECI_FRAC:
		gadget_input_DECI_FRAC(p_dm_gadget); break;

		case GAD_PRI_ACCURACY:
		gadget_input_PRI_ACCURACY(p_dm_gadget); break;

		case GAD_SEC_ACCURACY:
		gadget_input_SEC_ACCURACY(p_dm_gadget); break;

		case GAD_ANG_ACCURACY:
		gadget_input_ANG_ACCURACY(p_dm_gadget); break;

		case GAD_NTS_ULINE:
		gadget_input_NTS_ULINE(p_dm_gadget); break;

		case GAD_OVERRIDE:
		gadget_input_OVERRIDE(p_dm_gadget); break;

		case GAD_AUT_CENT:
		gadget_input_AUT_CENT(p_dm_gadget);
		break;

		default:
		printf("process_input_FORM_LOCAL: Unknown label %d\n", label);
		break;
	}

	RETURN(TRUE);
}

process_input_FORM_DISPLAY(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int  label;

	trace_in("process_input_FORM_DISPLAY");

	label   = p_dm_gadget->label;
	p_dm_gadget->stackable = TRUE;

	switch(label)
	{
		case GAD_TXT_ORIE:
		frm_loc.txt_orie = get_value_int(p_dm_gadget);
		if (FORM_DISPLAYED) group_output_FORM_DISPLAY();
		break;

		case GAD_TXT_POSN:
		frm_loc.txt_posn = get_value_toggle(p_dm_gadget);
		if (FORM_DISPLAYED) gadget_output_TXT_POSN();
		break;

		case GAD_ORI_DISP:
		if (get_value_toggle(p_dm_gadget))
			frm_loc.proj_disp = frm_loc.proj_disp | PROJ_DISP_ORI;
		else	frm_loc.proj_disp = frm_loc.proj_disp & (~PROJ_DISP_ORI);
		if (FORM_DISPLAYED) gadget_output_ORI_DISP();
		break;

		case GAD_MEA_DISP:
		if (get_value_toggle(p_dm_gadget))
			frm_loc.proj_disp = frm_loc.proj_disp | PROJ_DISP_MEA;
		else	frm_loc.proj_disp = frm_loc.proj_disp & (~PROJ_DISP_MEA);
		if (FORM_DISPLAYED) gadget_output_MEA_DISP();
		break;

		case GAD_PROJ_ANGL:
		frm_env.proj_angl = get_value_double(p_dm_gadget);
		if (FORM_DISPLAYED) gadget_output_PROJ_ANGL();
		break;

		case GAD_SCA_FACT:
		gadget_input_SCA_FACT(p_dm_gadget); break;



		default:
		printf("FORM_DISPLAY: Unknown label %d\n", label);
		break;
	}

	RETURN(TRUE);
}

process_input_FORM_DIMTERM(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	trace_in("process_input_FORM_DIMTERM");

	erase_form((int)(p_dm_gadget->form_no));
	p_dm_gadget->stackable = TRUE;
	frm_env.ter_type  = map_gadget_value(p_dm_gadget);
	frm_env.ter_type0 = frm_env.ter_type;
	gadget_output_TER_TYPE();

	RETURN(TRUE);
}

process_input_FORM_FORMAT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	trace_in("process_input_FORM_FORMAT");

	erase_form((int)FORM_FORMAT);
	p_dm_gadget->stackable = TRUE;
	frm_loc.tole_mode = map_gadget_value(p_dm_gadget);
	group_output_TOLE_MODE();

	RETURN(TRUE);
}


process_input_FORM_DECACC(p_dm_gadget) struct DM_data_st *p_dm_gadget;
{
	int accuracy;

	trace_in("process_input_FORM_DECACC");

	erase_form((int)(p_dm_gadget->form_no));
	p_dm_gadget->stackable = TRUE;
	accuracy = map_gadget_value(p_dm_gadget);

	switch(p_dm_gadget->form_no)
	{
		case FORM_DECACC_PRI:
		frm_loc.primary.decacc = accuracy;
		gadget_output_PRI_ACCURACY();
		break;

		case FORM_DECACC_SEC:
		frm_loc.secondary.decacc = accuracy;
		gadget_output_SEC_ACCURACY();
		break;

		case FORM_DECACC_ANG:
		frm_loc.angular.decacc = accuracy;
		gadget_output_ANG_ACCURACY();
		break;

		default:
		printf("process_input_FORM_DECACC: Unknown form %d\n",
			p_dm_gadget->form_no);
		RETURN(FALSE);
	}

	RETURN(TRUE);
}

process_input_FORM_FRAACC(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int accuracy;

	trace_in("process_input_FORM_FRAACC");

	erase_form((int)(p_dm_gadget->form_no));
	p_dm_gadget->stackable = TRUE;
	accuracy = map_gadget_value(p_dm_gadget);

	switch(p_dm_gadget->form_no)
	{
		case FORM_FRAACC_PRI:
		frm_loc.primary.fraacc = accuracy;
		gadget_output_PRI_ACCURACY();
		break;

		case FORM_FRAACC_SEC:
		frm_loc.secondary.fraacc = accuracy;
		gadget_output_SEC_ACCURACY();
		break;

		case FORM_FRAACC_ANG:
		frm_loc.angular.fraacc = accuracy;
		gadget_output_ANG_ACCURACY();
		break;

		default:
		printf("process_input_FORM_FRAACC: Unknown form %d\n",
			p_dm_gadget->form_no);
		RETURN(FALSE);
	}

	RETURN(TRUE);
}

process_input_FORM_ANG_ROFF(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char decacc, roff_unit;

	trace_in("process_input_FORM_ANG_ROFF");

	erase_form((int)FORM_ANG_ROFF);
	p_dm_gadget->stackable = TRUE;

	decacc = frm_loc.angular.decacc;
	roff_unit = frm_loc.angular.ang_roff_unit;

	if ((p_dm_gadget->form_no == FORM_ANG_ROFF) &&
	    (p_dm_gadget->label == SUB_FORM_LABEL))
	{
		/* Set the correct label*/
		if (p_dm_gadget->val.ivalue == 0)
			p_dm_gadget->label = GAD_ROFF_DEG;
		else if (p_dm_gadget->val.ivalue == 1)
			p_dm_gadget->label = GAD_ROFF_MIN;
		else	p_dm_gadget->label = GAD_ROFF_SEC;
	}

	switch (p_dm_gadget->label)
	{
		case GAD_DEC_ACC10: decacc = DECI_ACC10; break;
		case GAD_DEC_ACC1 : decacc = DECI_ACC1;  break;
		case GAD_ROFF_DEG : roff_unit = ANG_ROFF_UNIT_DEG; break;
		case GAD_ROFF_MIN : roff_unit = ANG_ROFF_UNIT_MIN; break;
		case GAD_ROFF_SEC : roff_unit = ANG_ROFF_UNIT_SEC; break;
		default:
		printf("process_input_FORM_ANG_ROFF: Unknown gadget %d\n",
			p_dm_gadget->label);
		RETURN(FALSE);
	}

	frm_loc.angular.decacc = decacc;
	frm_loc.angular.ang_roff_unit = roff_unit;

	if (is_form_displayed(FORM_LOCAL))
		gadget_output_ANG_ACCURACY();

	RETURN(TRUE);
}

process_input_NOT_ON_FORM(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	double bln_size, ratio;

	trace_in("process_input_NOT_ON_FORM");

	p_dm_gadget->stackable = TRUE;

	switch(p_dm_gadget->label)
	{
		case KEY_POSS_VALUES:
		gadget_input_POSS_VALUES(p_dm_gadget); break;

		case KEY_ACT_VALUES:
		gadget_input_ACT_VALUES(p_dm_gadget); break;

		case KEY_FRAC_FONT:
		gadget_input_FRAC_FONT(p_dm_gadget); break;

		case KEY_TER_TYPE0:
		gadget_input_TER_TYPE0(p_dm_gadget); break;

		case KEY_PRI_TOLE_UP:
		gadget_input_PRI_TOLE_UP(p_dm_gadget); break;

		case KEY_PRI_TOLE_LOW:
		gadget_input_PRI_TOLE_LOW(p_dm_gadget); break;

		case KEY_PRI_TOLE_SYM:
		gadget_input_PRI_TOLE_SYM(p_dm_gadget); break;

		case KEY_SEC_TOLE_UP:
		gadget_input_SEC_TOLE_UP(p_dm_gadget); break;

		case KEY_SEC_TOLE_LOW:
		gadget_input_SEC_TOLE_LOW(p_dm_gadget); break;

		case KEY_SEC_TOLE_SYM:
		gadget_input_SEC_TOLE_SYM(p_dm_gadget); break;

		case KEY_TER_DISP:
		gadget_input_TER_DISP(p_dm_gadget); break;

		case KEY_TXT_WIDT:
		gadget_input_TXT_WIDT(p_dm_gadget); break;

		case KEY_PRI_LEADING:
		gadget_input_PRI_LEADING(p_dm_gadget); break;

		case KEY_SEC_LEADING:
		gadget_input_SEC_LEADING(p_dm_gadget); break;

		case KEY_PRI_TRAILING:
		gadget_input_PRI_TRAILING(p_dm_gadget); break;

		case KEY_SEC_TRAILING:
		gadget_input_SEC_TRAILING(p_dm_gadget); break;

		case KEY_PRI_UNITS:
		gadget_input_PRI_UNITS(p_dm_gadget); break;

		case KEY_SEC_UNITS:
		gadget_input_SEC_UNITS(p_dm_gadget); break;

		case KEY_PRI_LABEL:
		gadget_input_PRI_LABEL(p_dm_gadget); break;

		case KEY_PRI_SUB_LABEL:
		gadget_input_PRI_SUB_LABEL(p_dm_gadget); break;

		case KEY_SEC_LABEL:
		gadget_input_SEC_LABEL(p_dm_gadget); break;

		case KEY_SEC_SUB_LABEL:
		gadget_input_SEC_SUB_LABEL(p_dm_gadget); break;

		case KEY_BLN_TYPE:
		frm_senv.bln_type = get_value_int(p_dm_gadget);
		break;

		case KEY_BLN_SIZE:
		bln_size = get_value_double(p_dm_gadget);
		if(bln_size < 1.5)
		    strcpy(input_status, "Balloon Size Ratio must be atleast 1.5");
		else	frm_senv.bln_size = bln_size;
		break;

		case KEY_NUM_SIDES:
		frm_senv.num_sides = get_value_int(p_dm_gadget);
		break;

		case KEY_ANNOT_ORIE:
		frm_senv.an_orie = get_value_int(p_dm_gadget);
		break;

		case KEY_ANNOT_POSN:
		frm_senv.an_posn = get_value_int(p_dm_gadget);
		break;

		case KEY_CTXT_POSN:
		frm_loc.ctxt_posn = get_value_int(p_dm_gadget);
		break;

		case KEY_DATUM_TERM:
		frm_senv.datum_ter_type = get_value_int(p_dm_gadget);
		break;

		case KEY_CAR_SPAC:
		frm_misc.std_param.dm_car_spac = get_value_double(p_dm_gadget);
		break;

		case KEY_LIN_SPAC:
		frm_misc.std_param.dm_lin_spac = get_value_double(p_dm_gadget);
		break;

		case KEY_REF_TYPE:
		frm_glob.ref_type = get_value_int(p_dm_gadget);
		if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
		break;

		case KEY_DIM_DISP:
		frm_glob.disp_type = get_value_int(p_dm_gadget);
		break;

		case KEY_VIEW_ANG:
		frm_glob.view_angle = get_value_double(p_dm_gadget);
		break;

		case GAP_TXT_CLEARANCE:
		frm_misc.std_param.dm_text_clear = get_value_double(p_dm_gadget);
		break;

		case GAP_PRE_SUFF:
		frm_misc.std_param.dm_pre_suf_gap = get_value_double(p_dm_gadget);
		break;

		case GAP_SYMBOL:
		frm_misc.std_param.dm_sym_gap = get_value_double(p_dm_gadget);
		break;

		case GAP_DUAL_DIM:
		frm_misc.std_param.dm_dual_off = get_value_double(p_dm_gadget);
		break;

		case GAP_TOL_HOR:
		frm_misc.std_param.dm_tol_hor_gap = get_value_double(p_dm_gadget);
		break;

		case GAP_TOL_VER:
		frm_misc.std_param.dm_tol_ver_gap = get_value_double(p_dm_gadget);
		break;

		case GAP_VER_LIMI:
		frm_misc.std_param.dm_lim_ver_gap = get_value_double(p_dm_gadget);
		break;

		case GAP_BOX_HOR:
		frm_misc.std_param.dm_box_hor_gap = get_value_double(p_dm_gadget);
		break;

		case GAP_BOX_VER:
		frm_misc.std_param.dm_box_ver_gap = get_value_double(p_dm_gadget);
		break;

		case KEY_TERM_SIZE:

		ratio = 1.0;
		if ((frm_env.dim_stan == DIM_STAN_ISO) ||
		    (frm_env.dim_stan == DIM_STAN_JIS) ||
		    (frm_env.dim_stan == DIM_STAN_DIN))
			ratio = 1.4;

		frm_env.ter_heig_r = ratio * get_value_double(p_dm_gadget);
		frm_env.ter_widt_r = get_value_double(p_dm_gadget);
		break;

		case KEY_AUT_SUPPRESS:
		frm_misc.aut_dia = get_value_int(p_dm_gadget);
		break;

		case KEY_PROJ_METHOD:
		frm_weld.proj_method = get_value_int(p_dm_gadget);
		break;

		case KEY_ANSI_WELD:
		frm_weld.ansi_weld = get_value_toggle(p_dm_gadget);
		break;

		case KEY_DASH_LINE:
		frm_weld.dash_line = get_value_toggle(p_dm_gadget);
		break;

		default:
		printf("NOT_ON_FORM: Unknown key %d\n", p_dm_gadget->label);
		RETURN(FALSE);
	}

	RETURN(TRUE);
}

map_gadget_value(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int index;
	int option;
	int form_no;
	int label;
	int map_size;
	struct lab_val *map;

	trace_in("map_gadget_value");

	form_no = p_dm_gadget->form_no;
	label   = p_dm_gadget->label;
	map_size = DMform_list[form_no].map_size;
	map      = DMform_list[form_no].map;

	if (p_dm_gadget->origin == FORM_INPUT)
	{
		for (index=0; index<map_size; index=index+1)
			if (label == map[index].label)
				RETURN(map[index].ivalue);

		printf("map_gadget_value: ERROR form_no=%d, label=%d\n",
				form_no, label);
		RETURN(-1);
	}
	else if (p_dm_gadget->origin == KEYBOARD_INPUT)
	{
		if (p_dm_gadget->type != DIM_INT)
		{
			printf("map_gadget_value: ERROR in gadget type %d\n",
					p_dm_gadget->type);
			RETURN(-1);
		}

		option = p_dm_gadget->val.ivalue;
		if (option < 0 || option >= map_size)
		{
			printf("map_gadget_value: ERROR in option %d\n",
					option);
			RETURN(-1);
		}

		RETURN(map[option].ivalue);
	}
}

load_form(form_no)
int form_no;
{
	trace_in ("load_form");

	load_data();
	select_gadgets(form_no);

	switch (form_no)
	{
		/*---------------*/
		case FORM_ENVIRON:
		/*---------------*/

		group_output_ENV_MISC();
		group_output_DUAL_MODE();
		group_output_TXT_SIZE();
		group_output_SYMBOLOGY();
		group_output_GRAPHIC_PARAMETERS();
		group_output_ESCAPE_SEQUENCES();
		group_output_DISPLAY();
		group_output_ENV_INDEP();

		break;

		/*---------------*/
		case FORM_LOCAL:
		/*---------------*/

		group_output_LOC_MISC();
		group_output_DISPLAY_PARAMS();
		group_output_DIMN_MODE();
		group_output_TOLE_MODE();
		group_output_LOC_DISPLAY();
		group_output_ACCURACY();
		group_output_OVERRIDE();
		group_output_LOC_INDEP();

		break;

		/*---------------*/
		case FORM_DISPLAY:
		/*---------------*/

		group_output_FORM_DISPLAY();
		break;

		/*---------------*/
		case FORM_DIMTERM:
		/*---------------*/

		load_FORM_DIMTERM();
		break;

		/*---------------*/
		case FORM_DECACC_PRI:
		case FORM_DECACC_SEC:
		case FORM_DECACC_ANG:
		/*---------------*/

		load_FORM_DECACC(form_no);
		break;

		/*---------------*/
		case FORM_FRAACC_PRI:
		case FORM_FRAACC_SEC:
		case FORM_FRAACC_ANG:
		/*---------------*/

		load_FORM_FRAACC(form_no);
		break;

		/*---------------*/
		case FORM_FORMAT:
		/*---------------*/

		load_FORM_FORMAT();
		break;

		/*---------------*/
		case FORM_ANG_ROFF:
		/*---------------*/

		load_FORM_ANG_ROFF();
		break;

		default:

		printf("load_form: Unknown form_no %d\n", form_no);
		RETURN(FALSE);
	}

	RETURN(TRUE);
}

load_FORM_FORMAT()
{
	int symbol_index;

	trace_in("load_FORM_FORMAT");

	if (frm_glob.ref_type == REF_TYPE_PARENS)
		symbol_index = SYM_REFTYPE_PARENS;
	else if (frm_glob.ref_type == REF_TYPE_SUFFIX)
		symbol_index = SYM_REFTYPE_SUFFIX;
	else if (frm_glob.ref_type == REF_TYPE_SUBFIX)
		symbol_index = SYM_REFTYPE_SUBFIX;

	FIg_set_symbol_index(
		DMform_list[FORM_FORMAT].form_id,
		GAD_FORMAT_REF,
		symbol_index);

	single_select(
		FORM_FORMAT,
		DMform_list[FORM_FORMAT].map_size,
		DMform_list[FORM_FORMAT].map,
		frm_loc.tole_mode);

	RETURN(TRUE);
}

load_FORM_DIMTERM()
{
	trace_in("load_FORM_DIMTERM");

	single_toggle(
		FORM_DIMTERM,
		DMform_list[FORM_DIMTERM].map_size,
		DMform_list[FORM_DIMTERM].map,
		(int)frm_env.ter_type);

	RETURN(TRUE);
}

load_FORM_DECACC(form_no)
int form_no;
{
	char decacc;

	trace_in("load_FORM_DECACC");

	switch(form_no)
	{
		case FORM_DECACC_PRI:
		decacc = frm_loc.primary.decacc; break;

		case FORM_DECACC_SEC:
		decacc = frm_loc.secondary.decacc; break;

		case FORM_DECACC_ANG:
		decacc = frm_loc.angular.decacc; break;

		default:
		printf("load_FORM_DECACC: Unknown form %d\n", form_no);
		RETURN(FALSE);
	}

	single_select(
		form_no,
		DMform_list[form_no].map_size,
		DMform_list[form_no].map,
		decacc);

	RETURN(TRUE);
}

load_FORM_ANG_ROFF()
{
	int flag;
	char decacc;
	Form form_id;

	trace_in("load_FORM_ANG_ROFF");

	form_id = DMform_list[FORM_ANG_ROFF].form_id;
	if (form_id == NULL) RETURN(FALSE);

	if (frm_loc.angular.decacc == DECI_ACC10)
	{
		FIg_hilite(form_id, GAD_DEC_ACC10);
		FIg_unhilite(form_id, GAD_DEC_ACC1);
	}
	else
	{
		FIg_unhilite(form_id, GAD_DEC_ACC10);
		FIg_hilite(form_id, GAD_DEC_ACC1);
	}

	flag = (frm_loc.angular.ang_roff_unit == ANG_ROFF_UNIT_DEG);
	put_value_toggle(FORM_ANG_ROFF, GAD_ROFF_DEG, flag);
	flag = (frm_loc.angular.ang_roff_unit == ANG_ROFF_UNIT_MIN);
	put_value_toggle(FORM_ANG_ROFF, GAD_ROFF_MIN, flag);
	flag = (frm_loc.angular.ang_roff_unit == ANG_ROFF_UNIT_SEC);
	put_value_toggle(FORM_ANG_ROFF, GAD_ROFF_SEC, flag);

	RETURN(TRUE);
}

char *get_option(form_no, label, value)
int form_no;
int label;
int value;
{
	int index;
	int map_size;
	struct lab_val *map;
	char *option;
	int  keyin_index;

	trace_in("get_option");

	map_size = DMform_list[form_no].map_size;
	map = DMform_list[form_no].map;

	keyin_index = DMget_keyin_index(form_no, label);
	if (keyin_index == -1)
	{
		printf("get_option: ERROR - no entry form_no=%d, label=%d\n",
			form_no, label);
		RETURN(FALSE);
	}

	for (index=0; index<map_size; index=index+1)
		if (map[index].ivalue == value)
		{
			option = DMkeyin_list[keyin_index].option[index];
			if (option == NULL)
				printf("get_option: No such option %d\n",
						index);
			RETURN(option);
		}

	printf("get_option_index: No mapping\n");
	RETURN(NULL);
}

load_FORM_FRAACC(form_no)
int form_no;
{
	char fraacc;

	trace_in("load_FORM_FRAACC");

	switch(form_no)
	{
		case FORM_FRAACC_PRI:
		fraacc = frm_loc.primary.fraacc; break;

		case FORM_FRAACC_SEC:
		fraacc = frm_loc.secondary.fraacc; break;

		case FORM_FRAACC_ANG:
		fraacc = frm_loc.angular.fraacc; break;

		default:
		printf("load_FORM_DECACC: Unknown form %d\n", form_no);
		RETURN(FALSE);
	}

	single_select(
		form_no,
		DMform_list[form_no].map_size,
		DMform_list[form_no].map,
		fraacc);

	RETURN(TRUE);
}

single_select(form_no, map_size, map, value)
int form_no;
int map_size;
struct lab_val *map;
int value;
{
	int index;
	Form form_id;

	trace_in("single_select");

	form_id = DMform_list[form_no].form_id;
	if (form_id == NULL) RETURN(TRUE);

	for (index=0; index<map_size; index=index+1)
	{
		if (map[index].ivalue == value)
			FIg_hilite(form_id, map[index].label);
		else	FIg_unhilite(form_id, map[index].label);
	}

	RETURN(TRUE);
}

single_toggle(form_no, map_size, map, value)
int form_no;
int map_size;
struct lab_val *map;
int value;
{
	int index;
	Form form_id;

	trace_in("single_toggle");

	form_id = DMform_list[form_no].form_id;
	if (form_id == NULL) RETURN(TRUE);

	for (index=0; index<map_size; index=index+1)
	{
		put_value_toggle(
			form_no,
			map[index].label,
			(map[index].ivalue == value));
	}

	RETURN(TRUE);
}

group_output_ENV_MISC()
{
	trace_in("group_output_ENV_MISC");

	gadget_output_CHECK(FORM_ENVIRON);

	RETURN(TRUE);
}

gadget_input_CHECK(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	erase_form((int)(p_dm_gadget->form_no));
}

gadget_output_CHECK(form_no)
int form_no;
{
	put_value_toggle(form_no, GAD_CHECK, FALSE);
}

group_output_LOC_MISC()
{
	trace_in("group_output_LOC_MISC");

	gadget_output_CHECK(FORM_LOCAL);

	RETURN(TRUE);
}

gadget_input_RESTORE(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int num;

	for (num=0; num<FORM_COUNT; num=num+1)
		SRstatus[num] = sr_status(num);
}

/* - POSSIBLE_VALUES - */

gadget_input_POSS_VALUES(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMlist_keyins(val_alpha(p_dm_gadget));
}

gadget_input_ACT_VALUES(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMactive_values(val_alpha(p_dm_gadget), &frm_env, &frm_loc, &frm_misc, &frm_senv, &frm_glob, &frm_weld);
}

group_output_DUAL_MODE()
{
	int mea_unit, sel_flag;

	trace_in("group_output_DUAL_MODE");

	if (frm_env.dual_mode == DUAL_MODE_OFF)
	{
		select_label(OFF, FORM_ENVIRON, GAD_UNIT_SEL);
		select_label(ON, FORM_ENVIRON, LAB_PRIMARY);
		mea_unit = frm_env.pri_unit;
	}
	else
	{
		select_label(OFF, FORM_ENVIRON, LAB_PRIMARY);
		select_label(ON, FORM_ENVIRON, GAD_UNIT_SEL);
		if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
			mea_unit = frm_env.pri_unit;
		else	mea_unit = frm_env.sec_unit;
	}

	sel_flag = (mea_unit == MEA_UNIT_FEET_INCHES);
	select_label(sel_flag, FORM_ENVIRON, GAD_SUB_LABEL);
	select_label(sel_flag, FORM_ENVIRON, LAB_SUB_LABEL);
	select_label(sel_flag, FORM_ENVIRON, GAD_MAX_SUB);
	select_label(sel_flag, FORM_ENVIRON, LAB_MAX_SUB);

	gadget_output_DELIMITER();
	gadget_output_DUAL_MODE();
	gadget_output_UNIT_SEL();
	gadget_output_UNITS();
	gadget_output_LEADING();
	gadget_output_TRAILING();
	gadget_output_LABEL();
	gadget_output_SUB_LABEL();
	gadget_output_MAX_SUB();
	gadget_output_ANG_UNITS();

	RETURN(TRUE);
}

gadget_input_DUAL_MODE(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.dual_mode = get_value_int(p_dm_gadget);
	if (frm_env.dual_mode == DUAL_MODE_ON)
	{
		frm_misc.tole_dsp = TOLE_DSP_PRIMARY;
		frm_misc.unit_sel     = UNIT_SEL_PRIMARY;
	}

	if (FORM_DISPLAYED) group_output_DUAL_MODE();
	if (is_form_displayed(FORM_LOCAL))
	{
		group_output_TOLE_MODE();
		group_output_ACCURACY();
	}
}

gadget_output_DUAL_MODE()
{
	put_value_toggle(FORM_ENVIRON, GAD_DUAL_MODE, (int)frm_env.dual_mode);
}

gadget_input_UNIT_SEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.unit_sel = get_value_toggle(p_dm_gadget);
	group_output_DUAL_MODE();
}

gadget_output_UNIT_SEL()
{
	put_value_toggle(FORM_ENVIRON, GAD_UNIT_SEL, (int)frm_misc.unit_sel);
}

gadget_input_UNITS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char mea_unit;

	mea_unit = get_value_int(p_dm_gadget);

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
	{
		if (frm_env.pri_unit != mea_unit)
		{
			frm_env.pri_unit = mea_unit;
			fill_label_info(UNIT_SEL_PRIMARY);
		}
	}
	else
	{
		if (frm_env.sec_unit != mea_unit)
		{
			frm_env.sec_unit = mea_unit;
			fill_label_info(!UNIT_SEL_PRIMARY);
		}
	}

	if (FORM_DISPLAYED)
	{
		group_output_DUAL_MODE();
		group_output_TXT_SIZE();
	}
}

gadget_output_UNITS()
{
	int mea_unit;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		mea_unit = frm_env.pri_unit;
	else	mea_unit = frm_env.sec_unit;

	put_value_roll(FORM_ENVIRON, GAD_UNITS, (int)mea_unit);
}

gadget_input_LEADING(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		frm_loc.primary.leading = get_value_toggle(p_dm_gadget);
	else	frm_loc.secondary.leading = get_value_toggle(p_dm_gadget);

	if (FORM_DISPLAYED) gadget_output_LEADING();
}

gadget_output_LEADING()
{
	int leading;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		leading = frm_loc.primary.leading;
	else	leading = frm_loc.secondary.leading;

	put_value_toggle(FORM_ENVIRON, GAD_LEADING, leading);
}

gadget_input_TRAILING(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		frm_loc.primary.trailing = get_value_toggle(p_dm_gadget);
	else	frm_loc.secondary.trailing = get_value_toggle(p_dm_gadget);

	if (FORM_DISPLAYED) gadget_output_TRAILING();
}

gadget_output_TRAILING()
{
	int trailing;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		trailing = frm_loc.primary.trailing;
	else	trailing = frm_loc.secondary.trailing;

	put_value_toggle(FORM_ENVIRON, GAD_TRAILING, trailing);
}

gadget_input_PRI_UNITS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{ 
	char pri_unit;

	pri_unit = get_value_int(p_dm_gadget);
	if (frm_env.pri_unit != pri_unit)
	{
		frm_env.pri_unit = pri_unit;
		fill_label_info(UNIT_SEL_PRIMARY);
	}

	if (is_form_displayed(FORM_ENVIRON))
	{
		group_output_DUAL_MODE();
		group_output_TXT_SIZE();
	}
}

gadget_input_PRI_LEADING(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.primary.leading = get_value_toggle(p_dm_gadget);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_LEADING();
}

gadget_input_PRI_TRAILING(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.primary.trailing = get_value_toggle(p_dm_gadget);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_TRAILING();
}

gadget_input_SEC_UNITS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char sec_unit;

	sec_unit = get_value_int(p_dm_gadget);
	if (frm_env.sec_unit != sec_unit)
	{
		frm_env.sec_unit = sec_unit;
		fill_label_info(!UNIT_SEL_PRIMARY);
	}

	if (is_form_displayed(FORM_ENVIRON)) group_output_DUAL_MODE();
}

gadget_input_SEC_LEADING(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.secondary.leading = get_value_toggle(p_dm_gadget);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_LEADING();
}

gadget_input_SEC_TRAILING(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.secondary.trailing = get_value_toggle(p_dm_gadget);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_TRAILING();
}

gadget_input_LABEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char *label;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		label = frm_loc.primary.label;
	else	label = frm_loc.secondary.label;

	DMstrncpy(label, p_dm_gadget->val.alpha, 9);
	if (FORM_DISPLAYED) gadget_output_LABEL();
}

gadget_output_LABEL()
{
	char *label;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		label = frm_loc.primary.label;
	else	label = frm_loc.secondary.label;

	put_value_alpha(FORM_ENVIRON, GAD_LABEL, label);
}

gadget_input_SUB_LABEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char *sub_label;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		sub_label = frm_loc.primary.sub_label;
	else	sub_label = frm_loc.secondary.sub_label;

	DMstrncpy(sub_label, p_dm_gadget->val.alpha, 9);
	if (FORM_DISPLAYED) gadget_output_SUB_LABEL();
}

gadget_output_SUB_LABEL()
{
	char *sub_label;

	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
		sub_label = frm_loc.primary.sub_label;
	else	sub_label = frm_loc.secondary.sub_label;

	put_value_alpha(FORM_ENVIRON, GAD_SUB_LABEL, sub_label);
}

gadget_input_PRI_LABEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.primary.label, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_LABEL();
}

gadget_input_PRI_SUB_LABEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.primary.sub_label, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_SUB_LABEL();
}

gadget_input_SEC_LABEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.secondary.label, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_LABEL();
}

gadget_input_SEC_SUB_LABEL(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.secondary.sub_label, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_ENVIRON)) gadget_output_SUB_LABEL();
}

gadget_input_MAX_SUB(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.max_sub = get_value_int(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_MAX_SUB();
}

gadget_output_MAX_SUB()
{
	put_value_int(FORM_ENVIRON, GAD_MAX_SUB, (int)frm_loc.max_sub);
}

gadget_input_DELIMITER(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
	   frm_loc.primary.deci_char = get_value_toggle(p_dm_gadget);
	else
	   frm_loc.secondary.deci_char = get_value_toggle(p_dm_gadget);

	if (FORM_DISPLAYED) gadget_output_DELIMITER();
}

gadget_output_DELIMITER()
{
	if (frm_misc.unit_sel == UNIT_SEL_PRIMARY)
	   put_value_toggle(FORM_ENVIRON, GAD_DELIMITER, (int)frm_loc.primary.deci_char);
	else
	   put_value_toggle(FORM_ENVIRON, GAD_DELIMITER, (int)frm_loc.secondary.deci_char);
}

group_output_TXT_SIZE()
{
	trace_in("group_output_TXT_SIZE");

	gadget_output_TXT_HEIG();
	gadget_output_ASP_RATI();
	if (is_form_displayed(FORM_LOCAL)) gadget_output_TXT_HEIGHT();

	RETURN(TRUE);
}

gadget_input_TXT_HEIG(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	IGRdouble conv_factor;

	DMtxt_conv_fact(CONV_TO_FILE_UNITS, &conv_factor, frm_env.pri_unit);
	if( get_value_double(p_dm_gadget) > 0.000)
		frm_env.txt_heig = get_value_double(p_dm_gadget) * conv_factor;
	frm_env.txt_widt = frm_env.txt_heig * frm_misc.asp_rati_r;

	if (FORM_DISPLAYED) group_output_TXT_SIZE();
}

gadget_output_TXT_HEIG()
{
	IGRdouble conv_factor;

	DMtxt_conv_fact(CONV_TO_DIM_UNITS, &conv_factor, frm_env.pri_unit);
	put_value_double(FORM_ENVIRON, GAD_TXT_HEIG, frm_env.txt_heig * conv_factor);
}

gadget_output_TXT_HEIGHT()
{
	IGRdouble conv_factor;

	if (frm_glob.dim_mode == MODELING_MODE)
	{
		DMtxt_conv_fact(CONV_TO_DIM_UNITS, &conv_factor, frm_env.pri_unit);
		put_value_double(FORM_LOCAL, GAD_TXT_HEIGHT, frm_env.txt_heig * conv_factor);
	}
}

gadget_input_ASP_RATI(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if( get_value_double(p_dm_gadget) > 0.000)
		frm_misc.asp_rati_r = get_value_double(p_dm_gadget);
	frm_env.txt_widt = frm_env.txt_heig * frm_misc.asp_rati_r;
	if (FORM_DISPLAYED) group_output_TXT_SIZE();
}

gadget_output_ASP_RATI()
{
	put_value_double(FORM_ENVIRON, GAD_ASP_RATI, frm_misc.asp_rati_r);
} 

gadget_input_TXT_WIDT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	IGRdouble conv_factor;

	DMtxt_conv_fact(CONV_TO_FILE_UNITS, &conv_factor, frm_env.pri_unit);
	frm_env.txt_widt = get_value_double(p_dm_gadget) * conv_factor;
	frm_misc.asp_rati_r = frm_env.txt_widt / frm_env.txt_heig;
	if (is_form_displayed(FORM_ENVIRON)) group_output_TXT_SIZE();
}

group_output_SYMBOLOGY()
{
	int flag;

	trace_in("group_output_SYMBOLOGY");

	flag = (frm_glob.dim_mode == MODELING_MODE) &&
	       (frm_state == STATE_GLOBAL);
	select_label(flag, FORM_ENVIRON, LAB_MODL_LINE);
	select_label(flag, FORM_ENVIRON, LAB_DRVG_COLR);
	select_label(flag, FORM_ENVIRON, GAD_DRVG_COLR);

	if(flag)
	{
		select_label(0, FORM_ENVIRON, LAB_DIM_COLR);
		select_label(1, FORM_ENVIRON, LAB_DRVN_COLR);
	}
	else
	{
		select_label(0, FORM_ENVIRON, LAB_DRVN_COLR);
		select_label(1, FORM_ENVIRON, LAB_DIM_COLR);
	}

	flag = (frm_state == STATE_GLOBAL);
	select_label(flag, FORM_ENVIRON, GAD_DIM_MODE);

	gadget_output_DIM_LAYR();
	gadget_output_DIM_COLR();
	gadget_output_DIM_WEIG();
	gadget_output_TXT_WEIG();
	gadget_output_TOL_WEIG();
	gadget_output_TXT_FONT();
	gadget_output_DIM_MODE();
	gadget_output_DET_COLR();
	gadget_output_DRVG_COLR();

	RETURN(TRUE);
}

gadget_input_DIM_LAYR(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int layer;

	layer = get_value_int(p_dm_gadget);
	if (layer < 1024)
		frm_env.dim_layr = layer;
	else	strcpy(input_status, "invalid layer");

	if (FORM_DISPLAYED) gadget_output_DIM_LAYR();
}

gadget_output_DIM_LAYR()
{
	put_value_int(FORM_ENVIRON, GAD_DIM_LAYR, (int)frm_env.dim_layr);
}

gadget_input_DET_COLR(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	short color;

	process_color(&color, p_dm_gadget);

	if (color <= 0)
		strcpy(input_status, "Invalid Color");
	else	frm_glob.detached_color = color;

	if (FORM_DISPLAYED) gadget_output_DET_COLR();
}

gadget_output_DET_COLR()
{
	IGRchar	string[20];

	sprintf(string,"%d",frm_glob.detached_color);
	put_value_alpha(FORM_ENVIRON, GAD_DET_COLR, string);
}

gadget_input_DRVG_COLR(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	short color;

	process_color(&color, p_dm_gadget);

	if (color <= 0)
		strcpy(input_status, "Invalid Color");
	else	frm_glob.driving_color = color;

	if (FORM_DISPLAYED) gadget_output_DRVG_COLR();
}

gadget_output_DRVG_COLR()
{
	IGRchar	string[20];

	sprintf(string,"%d",frm_glob.driving_color);
	put_value_alpha(FORM_ENVIRON, GAD_DRVG_COLR, string);
}

gadget_input_DIM_MODE(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_glob.dim_mode = get_value_int(p_dm_gadget);
	if (frm_glob.dim_mode == MODELING_MODE)
		frm_glob.disp_type == DEFAULT_DISPLAY;
	else	frm_glob.disp_type == DISPLAY_ALL;

	if (FORM_DISPLAYED) group_output_SYMBOLOGY();
	if (is_form_displayed(FORM_LOCAL)) group_output_OVERRIDE();
}

gadget_output_DIM_MODE()
{
	put_value_int(FORM_ENVIRON, GAD_DIM_MODE, (int)frm_glob.dim_mode);
}

gadget_input_DIM_COLR(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	short color;

	process_color(&color, p_dm_gadget);

	if (color <= 0)
		strcpy(input_status, "Invalid Color");
	else
	{
		if (frm_glob.dim_mode == MODELING_MODE)
			frm_glob.driven_color = color;
		else	frm_env.dim_colr = color;
	}

	if (FORM_DISPLAYED) gadget_output_DIM_COLR();
}

gadget_output_DIM_COLR()
{
	IGRchar	string[20];
	IGRshort color;

	if (frm_glob.dim_mode == MODELING_MODE)
		color = frm_glob.driven_color;
	else	color = frm_env.dim_colr;

	sprintf(string,"%d",color);
	put_value_alpha(FORM_ENVIRON, GAD_DIM_COLR, string);
}

gadget_input_DIM_WEIG(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.dim_weig = get_value_int(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_DIM_WEIG();
}

gadget_output_DIM_WEIG()
{
	put_value_int(FORM_ENVIRON, GAD_DIM_WEIG, (int)frm_env.dim_weig);
}

gadget_input_TXT_WEIG(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.txt_weig = get_value_int(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_TXT_WEIG();
}

gadget_output_TXT_WEIG()
{
	put_value_int(FORM_ENVIRON, GAD_TXT_WEIG, (int)frm_env.txt_weig);
}

gadget_input_TOL_WEIG(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.tol_weig = get_value_int(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_TOL_WEIG();
}

gadget_output_TOL_WEIG()
{
	put_value_int(FORM_ENVIRON, GAD_TOL_WEIG, (int)frm_env.tol_weig);
}

gadget_input_TXT_FONT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int rc;
	char txt_font[16];
	char fra_font[16];

	DMstrncpy(txt_font, p_dm_gadget->val.alpha, 16);
	if (!strcmp(txt_font, "default"))	strcpy (fra_font, "deffrac");
	else if (!strcmp(txt_font, "0"))	strcpy (fra_font, "frac0");
	else if (!strcmp(txt_font, "23"))	strcpy (fra_font, "frac23");
	else if (!strcmp(txt_font, "ansi2"))	strcpy (fra_font, "ansifrac2");
	else if (!strcmp(txt_font, "ansi3"))	strcpy (fra_font, "ansifrac3");
	else					strcpy (fra_font, "");

	DMretrieve_font(&rc, current_os, txt_font, &frm_env.text_font);
	if (fra_font[0]) DMretrieve_font(&rc, current_os, fra_font, &frm_env.frac_font);

	if (FORM_DISPLAYED) gadget_output_TXT_FONT();
}

gadget_output_TXT_FONT()
{
	int rc;
	struct vfont_entry font_info;

	font$get_info(
		msg = &rc,
		font_num = &frm_env.text_font,
		font_info = &font_info);
	if (rc == MSFAIL)
	{
		printf("Error font$get_info: font_num = %d\n",
				frm_env.text_font);
		strcpy(font_info.vfontname, "???");
	}

	put_value_alpha(FORM_ENVIRON, GAD_TXT_FONT, font_info.vfontname);
}

gadget_input_FRAC_FONT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int rc;
	char fra_font[16];

	DMstrncpy(fra_font, p_dm_gadget->val.alpha, 16);
	DMretrieve_font(&rc, current_os, fra_font, &frm_env.frac_font);
}

group_output_GRAPHIC_PARAMETERS()
{
	trace_in("group_output_GRAPHIC_PARAMETERS");

	gadget_output_PROJ_OFFS();
	gadget_output_PROJ_EXTN();
	gadget_output_LIN_OFFS();
	gadget_output_TXT_YOFF();

	RETURN(TRUE);
}

gadget_input_SCA_FACT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	IGRdouble scale;

	scale = -1.0;

	if ((frm_state == STATE_DIMENSION)
	||  (frm_state == STATE_REPLAY))
	{
		if (!(GEOM_TYPE & DIM_DRIVING) 
		&&  !(GEOM_TYPE & DIM_IMPORTED)
		&&  !(DISPLAY_TYPE & DIM_AUTO_SCALED))
			scale = get_value_double(p_dm_gadget);
	}
	else	scale = get_value_double(p_dm_gadget);	
	
	if (scale > 0.0)
		frm_env.sca_fact = scale;
	else	strcpy(input_status, "Invalid Scale");

	if (FORM_DISPLAYED) gadget_output_SCA_FACT();
}

gadget_output_SCA_FACT()
{
	IGRint status;
	IGRdouble scale;
	Form form_id;

	scale = -1.0;

	if ((frm_state == STATE_DIMENSION)
	||  (frm_state == STATE_REPLAY))
	{
		if (GEOM_TYPE & DIM_DRIVING)
			scale = 1.0;
		else if (!(GEOM_TYPE & DIM_IMPORTED))
			scale = frm_env.sca_fact;
		
	}
	else scale = frm_env.sca_fact;

	if (scale > 0.0)
		put_value_double(FORM_DISPLAY, GAD_SCA_FACT, frm_env.sca_fact);
	else
	{
		form_id = DMform_list[FORM_DISPLAY].form_id;

		status = FIg_reset(form_id, GAD_SCA_FACT);
        	if (status != FI_SUCCESS)
        	{
               		/*|FIg_erase Fails */
                	return(OM_E_ABORT);
        	}
	}
}

gadget_output_PROJ_ANGL()
{
	put_value_double(FORM_DISPLAY, GAD_PROJ_ANGL, frm_env.proj_angl);
}

gadget_input_PROJ_OFFS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.proj_offs_r = get_value_double(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_PROJ_OFFS();  
}

gadget_output_PROJ_OFFS()
{
	put_value_double(FORM_ENVIRON, GAD_PROJ_OFFS, frm_env.proj_offs_r);
}

gadget_input_PROJ_EXTN(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.proj_extn_r = get_value_double(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_PROJ_EXTN();
}

gadget_output_PROJ_EXTN()
{
	put_value_double(FORM_ENVIRON, GAD_PROJ_EXTN, frm_env.proj_extn_r);
}

gadget_input_LIN_OFFS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.lin_offs_r = get_value_double(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_LIN_OFFS();  
}

gadget_output_LIN_OFFS()
{
	put_value_double(FORM_ENVIRON, GAD_LIN_OFFS, frm_env.lin_offs_r);
}

gadget_input_TXT_YOFF(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.txt_yoff_r = get_value_double(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_TXT_YOFF();  
}

gadget_output_TXT_YOFF()
{
	put_value_double(FORM_ENVIRON, GAD_TXT_YOFF, frm_env.txt_yoff_r);
}

group_output_ESCAPE_SEQUENCES()
{
	trace_in("group_output_ESCAPE_SEQUENCES");

	gadget_output_TOL_SIZE();

	RETURN(TRUE);
}

gadget_input_TOL_SIZE(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.tol_size_r = get_value_double(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_TOL_SIZE();
}

gadget_output_TOL_SIZE()
{
	put_value_double(FORM_ENVIRON, GAD_TOL_SIZE, frm_env.tol_size_r);
}

group_output_DISPLAY()
{
	trace_in("group_output_DISPLAY");

	gadget_output_LIN_DISP();

	RETURN(TRUE);
}

gadget_input_LIN_DISP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.lin_disp = get_value_toggle(p_dm_gadget);
	if (FORM_DISPLAYED) group_output_DISPLAY();
}

gadget_output_LIN_DISP()
{
	put_value_toggle(FORM_ENVIRON, GAD_LIN_DISP, (int)frm_loc.lin_disp);
}

group_output_ENV_INDEP()
{
	trace_in("group_output_ENV_INDEP");

	if (frm_state == STATE_GLOBAL)
	{
		select_label(OFF, FORM_ENVIRON, GAD_EDIT_TITLE);
		select_label(ON,  FORM_ENVIRON, GAD_TITLE);
	}
	else
	{
		select_label(OFF, FORM_ENVIRON, GAD_TITLE);
		select_label(ON,  FORM_ENVIRON, GAD_EDIT_TITLE);
	}

	gadget_output_DIM_STAN();
	gadget_output_COMM_ORIG();
	gadget_output_SYM_POSN();
	gadget_output_TER_TYPE();
	gadget_output_TER_LIMIT();

	RETURN(TRUE);
}

gadget_input_DIM_STAN(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int   sts, msg;
	int   stan;
	struct DMglobal_param loc_glob;
	struct DMweld_param loc_weld;

	stan = get_value_int(p_dm_gadget);

	if (frm_state == STATE_GLOBAL)
	{
		sts = DMset_dim_stan(&msg, stan);
		dm$status(sts = sts, action = RET_STATUS);
		dm$status(sts = msg, action = RET_STATUS);

		load_data();
	}
	else
	{
		sts =
		DMinit_dim_params(stan, current_os, &frm_env, &frm_loc, &frm_misc, &frm_senv,&loc_glob,&loc_weld);
		dm$status(sts = sts, action = RET_STATUS);
	}

	refresh_form(-1); 	/* Refresh ALL displayed forms */
	status("");
}

gadget_output_DIM_STAN()
{
	put_value_roll(FORM_ENVIRON, GAD_DIM_STAN, (int)frm_env.dim_stan);
}

gadget_output_TXT_POSN()
{
	put_value_roll(FORM_DISPLAY, GAD_TXT_POSN, (int)frm_loc.txt_posn);
}

gadget_input_TER_LIMIT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.ter_limit_r = get_value_double(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_TER_LIMIT();
}

gadget_output_TER_LIMIT()
{
	put_value_double(FORM_ENVIRON, GAD_TER_LIMIT, frm_misc.ter_limit_r);
}

gadget_input_SYM_POSN(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.sym_posn = get_value_int(p_dm_gadget);
	if (FORM_DISPLAYED) group_output_ENV_INDEP();
}

gadget_output_SYM_POSN()
{
	put_value_roll(FORM_ENVIRON, GAD_SYM_POSN, (int)frm_env.sym_posn);
}

gadget_input_COMM_ORIG(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	int value;

	value = get_value_int(p_dm_gadget);
	if(value == 0)
		frm_env.comm_origin = TER_TYPE_DOT;
	else if (value == 1)
		frm_env.comm_origin = TER_TYPE_CIRCLE;
	else	frm_env.comm_origin = TER_TYPE_BLANK;

	if (FORM_DISPLAYED) gadget_output_COMM_ORIG();
}

gadget_output_COMM_ORIG()
{
	int form_no, sts;
	int value, label;
	Form form_id;

	form_no = FORM_ENVIRON;
	form_id = DMform_list[form_no].form_id;
	
	if ( form_id == NULL ||	SRstatus[form_no] ) RETURN(TRUE);

	if (frm_env.comm_origin == TER_TYPE_DOT)
		label = GAD_COMM_ORIG_DOT;
	else if (frm_env.comm_origin == TER_TYPE_CIRCLE)
		label = GAD_COMM_ORIG_CIRCLE;
	else	label = GAD_COMM_ORIG_NONE;

	sts = FIg_set_state(form_id, label, 1);
	fi$status(form_no = form_no, label = label, comment = "FIg_set_state");

	sts = FIg_display(form_id, label);
	fi$status(form_no = form_no, label = label, comment = "FIg_display");
}

gadget_output_TER_TYPE()
{
	int form_no, sts;
	int symbol;
	Form form_id;

	form_no = FORM_ENVIRON;
	form_id = DMform_list[form_no].form_id;
	
	if ( form_id == NULL ||	SRstatus[form_no] ) RETURN(TRUE);

	symbol = frm_env.ter_type + 119;

	sts = FIg_erase(form_id, GAD_TER_TYPE);
	fi$status(form_no = form_no, label = GAD_TER_TYPE, comment = "FIg_display");

	if (frm_env.ter_type == TER_TYPE_BLANK)
	   symbol = 0;

	sts = FIg_set_symbol_index(form_id, GAD_TER_TYPE, symbol);
	fi$status(form_no = form_no, label = GAD_TER_TYPE, comment = "FIg_set_symbol_index");

	sts = FIg_display(form_id, GAD_TER_TYPE);
	fi$status(form_no = form_no, label = GAD_TER_TYPE, comment = "FIg_display");
}

gadget_input_TER_SELECT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	gadget_output_TER_SELECT();
	display_form(FORM_DIMTERM);
}

gadget_output_TER_SELECT()
{
	put_value_toggle(FORM_ENVIRON, GAD_TER_SELECT, OFF);
}

gadget_input_TER_TYPE0(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.ter_type0 = get_value_int(p_dm_gadget);
}

gadget_input_ANG_UNITS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.ang_unit =  get_value_int(p_dm_gadget);

	if (frm_env.ang_unit == ANG_UNIT_DEG_MIN_SEC
	&&  frm_loc.angular.decacc != DECI_ACC10)
		frm_loc.angular.decacc = DECI_ACC1;

	if (FORM_DISPLAYED) gadget_output_ANG_UNITS();
	if (is_form_displayed(FORM_LOCAL)) gadget_output_ANG_ACCURACY();
}

gadget_output_ANG_UNITS()
{
	put_value_roll(FORM_ENVIRON, GAD_ANG_UNITS, (int)frm_env.ang_unit);
}

gadget_input_NTS_ULINE(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_env.nts_uline = !frm_env.nts_uline;
	if (FORM_DISPLAYED) gadget_output_NTS_ULINE();
}

gadget_output_NTS_ULINE()
{
	put_value_hilite(FORM_LOCAL, GAD_NTS_ULINE, !((int)frm_env.nts_uline));
}

group_output_FORM_DISPLAY()
{

	trace_in("group_output_FORM_DISPLAY");

	gadget_output_CHECK(FORM_DISPLAY);
	gadget_output_TXT_ORIE();
	gadget_output_TXT_POSN();
	gadget_output_ORI_DISP();
	gadget_output_MEA_DISP();
	gadget_output_PROJ_ANGL();
	gadget_output_SCA_FACT();

	RETURN(TRUE);
}

group_output_LOC_DISPLAY()
{
	int flag;

	trace_in("group_output_LOC_DISPLAY");

	flag = (frm_state == STATE_GLOBAL);
	select_label(flag, FORM_LOCAL, GAD_AUT_CENT);
	gadget_output_PREFIX();
	gadget_output_SUFFIX();
	gadget_output_PRE_DISP();
	gadget_output_SUF_DISP();
	gadget_output_AUT_CENT();

	RETURN(TRUE);
}

gadget_input_PREFIX(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_misc.prefix, p_dm_gadget->val.alpha, EXFI_STRLEN);
	if (FORM_DISPLAYED) gadget_output_PREFIX();
}

gadget_output_PREFIX()
{
	put_value_alpha(FORM_LOCAL, GAD_PREFIX, frm_misc.prefix);
}

gadget_input_SUFFIX(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_misc.suffix, p_dm_gadget->val.alpha, EXFI_STRLEN);
	if (FORM_DISPLAYED) gadget_output_SUFFIX();
}

gadget_output_SUFFIX()
{
	put_value_alpha(FORM_LOCAL, GAD_SUFFIX, frm_misc.suffix);
}

gadget_input_PRE_DISP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.prefix_disp = get_value_toggle(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_PRE_DISP();
}

gadget_output_PRE_DISP()
{
	put_value_toggle(FORM_LOCAL, GAD_PRE_DISP, (int)frm_misc.prefix_disp);
}

gadget_input_SUF_DISP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.suffix_disp = get_value_toggle(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_SUF_DISP();
}

gadget_output_SUF_DISP()
{
	put_value_toggle(FORM_LOCAL, GAD_SUF_DISP, (int)frm_misc.suffix_disp);
}

group_output_DISPLAY_PARAMS()
{
	trace_in("group_output_DISPLAY_PARAMS");

	gadget_output_DISPLAY_PARAMS();

	RETURN(TRUE);
}

gadget_input_DISPLAY_PARAMS(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	gadget_output_DISPLAY_PARAMS();
	display_form(FORM_DISPLAY);
}

gadget_output_DISPLAY_PARAMS()
{
	put_value_toggle(FORM_LOCAL, GAD_DISPLAY_PARAMS, OFF);
}

gadget_output_TXT_ORIE()
{
	put_value_roll(FORM_DISPLAY, GAD_TXT_ORIE, (int)frm_loc.txt_orie);
}

gadget_output_ORI_DISP()
{
	put_value_toggle(FORM_DISPLAY, GAD_ORI_DISP, (int)frm_loc.proj_disp & PROJ_DISP_ORI);
}
 
gadget_output_MEA_DISP()
{
	put_value_toggle(FORM_DISPLAY, GAD_MEA_DISP, (int)frm_loc.proj_disp & PROJ_DISP_MEA);
}
 
gadget_input_AUT_CENT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.aut_cent = get_value_toggle(p_dm_gadget);
	if (FORM_DISPLAYED) gadget_output_AUT_CENT();
}

gadget_output_AUT_CENT()
{
	put_value_toggle(FORM_LOCAL, GAD_AUT_CENT, (int)frm_misc.aut_cent);
}

group_output_DIMN_MODE()
{
	trace_in("group_output_DIMN_MODE");

	gadget_output_TOG_TERM();

	RETURN(TRUE);
}

gadget_input_TOG_TERM(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.tog_term = TRUE;
	if (FORM_DISPLAYED) group_output_DIMN_MODE();
}

gadget_output_TOG_TERM()
{
	put_value_toggle(FORM_LOCAL, GAD_TOG_TERM, OFF);
}

group_output_TOLE_MODE()
{
	int index;
	int label;
	int map_size;
	struct lab_val *map;

	trace_in("group_output_TOLE_MODE");

	select_label(OFF, FORM_LOCAL, GAD_SEC_TOLE_UP);
	select_label(OFF, FORM_LOCAL, GAD_SEC_TOLE_LOW);

	if (frm_loc.tole_mode == TOLE_MODE_OFF
	||  frm_loc.tole_mode == TOLE_MODE_BOX
	||  frm_loc.tole_mode == TOLE_MODE_REF)
	{
		select_label(OFF, FORM_LOCAL, LAB_TOLE_UP);
		select_label(OFF, FORM_LOCAL, LAB_TOLE_LOW);
		select_label(OFF, FORM_LOCAL, LAB_TOLE_SYM);
		select_label(OFF, FORM_LOCAL, LAB_TOLE_PRI);
		select_label(OFF, FORM_LOCAL, GAD_TOLE_DISPLAY);
		select_label(OFF, FORM_LOCAL, GAD_TOLE_UP);
		select_label(OFF, FORM_LOCAL, GAD_TOLE_LOW);
	}
	else
	{
		if (frm_env.dual_mode == DUAL_MODE_OFF)
		{
			select_label(OFF, FORM_LOCAL, GAD_TOLE_DISPLAY);
			select_label(ON, FORM_LOCAL, LAB_TOLE_PRI);
		}
		else
		{
			select_label(OFF, FORM_LOCAL, LAB_TOLE_PRI);
			select_label(ON, FORM_LOCAL, GAD_TOLE_DISPLAY);
		}

		switch(frm_loc.tole_mode)
		{
			case TOLE_MODE_UP_LOW:
			case TOLE_MODE_LIMITS:

			select_label(OFF, FORM_LOCAL, LAB_TOLE_SYM);
			select_label(ON, FORM_LOCAL, LAB_TOLE_UP);
			select_label(ON, FORM_LOCAL, LAB_TOLE_LOW);
			select_label(ON, FORM_LOCAL, GAD_TOLE_UP);
			select_label(ON, FORM_LOCAL, GAD_TOLE_LOW);
			break;

			case TOLE_MODE_MIDDLE:

			select_label(OFF, FORM_LOCAL, LAB_TOLE_UP);
			select_label(OFF, FORM_LOCAL, LAB_TOLE_LOW);
			select_label(OFF, FORM_LOCAL, GAD_TOLE_LOW);
			select_label(ON, FORM_LOCAL, GAD_TOLE_UP);
			select_label(ON, FORM_LOCAL, LAB_TOLE_SYM);
			break;

			default:

			printf("TOLE_SELECT: Unknown tole_mode %d\n",
					frm_loc.tole_mode);
			RETURN(FALSE);
		}
	}

	switch (frm_loc.tole_mode)
	{
		case TOLE_MODE_OFF:
		index = SYM_FORMAT_OFF; break;

		case TOLE_MODE_UP_LOW:
		index = SYM_FORMAT_UP_LOW; break;

		case TOLE_MODE_MIDDLE:
		index = SYM_FORMAT_MIDDLE; break;

		case TOLE_MODE_LIMITS:
		index = SYM_FORMAT_LIMITS; break;

		case TOLE_MODE_BOX:
		index = SYM_FORMAT_BOX; break;

		case TOLE_MODE_REF:
		switch (frm_glob.ref_type)
		{
			case REF_TYPE_PARENS:
			index = SYM_REFTYPE_PARENS; break;

			case REF_TYPE_SUFFIX:
			index = SYM_REFTYPE_SUFFIX; break;

			case REF_TYPE_SUBFIX:
			index = SYM_REFTYPE_SUBFIX; break;

			default:
			printf("Unknown ref_type\n");
			break;
		}
		break;

		default:
		printf("Unknown tole_mode\n");
		break;
	}

	if( DMform_list[FORM_LOCAL].form_id != NULL )
	{
	  FIg_set_symbol_index(
		  DMform_list[FORM_LOCAL].form_id,
		  GAD_TOLE_SELECT,
		  index);
	}

	gadget_output_TOLE_SELECT();
	gadget_output_TOLE_DISPLAY();
	gadget_output_TOLE_UP();
	gadget_output_TOLE_LOW();

	RETURN(TRUE);
}

gadget_input_TOLE_SELECT(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	display_form(FORM_FORMAT);
}

gadget_output_TOLE_SELECT()
{
	put_value_toggle(FORM_LOCAL, GAD_TOLE_SELECT, OFF);
}

gadget_input_TOLE_DISPLAY(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_misc.tole_dsp = get_value_toggle(p_dm_gadget);
	group_output_TOLE_MODE();
}

gadget_output_TOLE_DISPLAY()
{
	put_value_toggle(FORM_LOCAL, GAD_TOLE_DISPLAY, (int)frm_misc.tole_dsp);
}

gadget_input_PRI_TOLE_UP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.primary.tole_up, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
}

gadget_input_PRI_TOLE_LOW(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.primary.tole_low, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
}

gadget_input_PRI_TOLE_SYM(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_misc.pri_tole_sym, p_dm_gadget->val.alpha, 8);
	if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
}

gadget_input_SEC_TOLE_UP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.secondary.tole_up, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
}

gadget_input_SEC_TOLE_LOW(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_loc.secondary.tole_low, p_dm_gadget->val.alpha, 9);
	if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
}

gadget_input_SEC_TOLE_SYM(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	DMstrncpy(frm_misc.sec_tole_sym, p_dm_gadget->val.alpha, 8);
	if (is_form_displayed(FORM_LOCAL)) group_output_TOLE_MODE();
}

gadget_input_TOLE_UP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char *tole_up;

	p_dm_gadget->stackable = TRUE;

	if (frm_env.dual_mode == DUAL_MODE_OFF || frm_misc.tole_dsp == TOLE_DSP_PRIMARY)
	{
		if (frm_loc.tole_mode == TOLE_MODE_MIDDLE)
			tole_up = frm_misc.pri_tole_sym;
		else	tole_up = frm_loc.primary.tole_up;
	}
	else
	{
		if (frm_loc.tole_mode == TOLE_MODE_MIDDLE)
			tole_up = frm_misc.sec_tole_sym;
		else	tole_up = frm_loc.secondary.tole_up;
	}

	DMstrncpy(tole_up, p_dm_gadget->val.alpha, 9);
}

gadget_input_TOLE_LOW(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	char *tole_low;

	p_dm_gadget->stackable = TRUE;

	if (frm_env.dual_mode == DUAL_MODE_OFF || frm_misc.tole_dsp == TOLE_DSP_PRIMARY)
		tole_low = frm_loc.primary.tole_low;
	else	tole_low = frm_loc.secondary.tole_low;

	DMstrncpy(tole_low, p_dm_gadget->val.alpha, 9);
}

gadget_output_TOLE_UP()
{
	char *tole_up;

	if (frm_env.dual_mode == DUAL_MODE_OFF || frm_misc.tole_dsp == TOLE_DSP_PRIMARY)
	{
		if (frm_loc.tole_mode == TOLE_MODE_MIDDLE)
			tole_up = frm_misc.pri_tole_sym;
		else	tole_up = frm_loc.primary.tole_up;
	}
	else
	{
		if (frm_loc.tole_mode == TOLE_MODE_MIDDLE)
			tole_up = frm_misc.sec_tole_sym;
		else	tole_up = frm_loc.secondary.tole_up;
	}

	put_value_alpha(FORM_LOCAL, GAD_TOLE_UP, tole_up);
}

gadget_output_TOLE_LOW()
{
	char *tole_low;

	if (frm_env.dual_mode == DUAL_MODE_OFF || frm_misc.tole_dsp == TOLE_DSP_PRIMARY)
		tole_low = frm_loc.primary.tole_low;
	else	tole_low = frm_loc.secondary.tole_low;

	put_value_alpha(FORM_LOCAL, GAD_TOLE_LOW, tole_low);
}

group_output_ACCURACY()
{
	trace_in("group_output_ACCURACY");

	select_label((int)frm_env.dual_mode, FORM_LOCAL, GAD_SEC_ACCURACY);
	select_label((int)frm_env.dual_mode, FORM_LOCAL, LAB_SEC_ACCURACY);

	gadget_output_DECI_FRAC();
	gadget_output_PRI_ACCURACY();
	gadget_output_SEC_ACCURACY();
	gadget_output_ANG_ACCURACY();

	RETURN(TRUE);
}

gadget_input_DECI_FRAC(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.deci_frac = get_value_toggle(p_dm_gadget);
	if (FORM_DISPLAYED) group_output_ACCURACY();
}

gadget_output_DECI_FRAC()
{
	put_value_toggle(FORM_LOCAL, GAD_DECI_FRAC, (int)frm_loc.deci_frac);
}

gadget_input_PRI_ACCURACY(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if (frm_loc.deci_frac == DECIMAL_MODE)
		display_form(FORM_DECACC_PRI);
	else	display_form(FORM_FRAACC_PRI);
}

gadget_output_PRI_ACCURACY()
{
	int  form_no;
	char *pri_acc;
	int accuracy;

	if (frm_loc.deci_frac == DECIMAL_MODE)
	{
		form_no = FORM_DECACC_PRI;
		accuracy = frm_loc.primary.decacc;
	}
	else
	{
		form_no = FORM_FRAACC_PRI;
		accuracy = frm_loc.primary.fraacc;
	}

	pri_acc = get_option(form_no, SUB_FORM_LABEL, accuracy);
	put_value_alpha(FORM_LOCAL, GAD_PRI_ACCURACY, pri_acc);
	set_select_off(FORM_LOCAL, GAD_PRI_ACCURACY);
}

gadget_input_SEC_ACCURACY(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if (frm_loc.deci_frac == DECIMAL_MODE)
		display_form(FORM_DECACC_SEC);
	else	display_form(FORM_FRAACC_SEC);
}

gadget_output_SEC_ACCURACY()
{
	int  form_no;
	char *sec_acc;
	int accuracy;

	if (frm_loc.deci_frac == DECIMAL_MODE)
	{
		form_no = FORM_DECACC_SEC;
		accuracy = frm_loc.secondary.decacc;
	}
	else
	{
		form_no = FORM_FRAACC_SEC;
		accuracy = frm_loc.secondary.fraacc;
	}

	sec_acc = get_option(form_no, SUB_FORM_LABEL, accuracy);
	put_value_alpha(FORM_LOCAL, GAD_SEC_ACCURACY, sec_acc);
	set_select_off(FORM_LOCAL, GAD_SEC_ACCURACY);
}

gadget_input_ANG_ACCURACY(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	if (frm_env.ang_unit == ANG_UNIT_DEG_MIN_SEC)
		display_form(FORM_ANG_ROFF);
	else
	{
		if (frm_loc.deci_frac == DECIMAL_MODE)
			display_form(FORM_DECACC_ANG);
		else	display_form(FORM_FRAACC_ANG);
	}
}

gadget_output_ANG_ACCURACY()
{
	int  form_no;
	int  len;
	char *ang_acc, *ang_roff;
	char ang_fmt[32];
	int accuracy;

	if (frm_env.ang_unit == ANG_UNIT_DEG_MIN_SEC)
	{
		form_no = FORM_DECACC_ANG;
		if (frm_loc.angular.decacc != DECI_ACC10)
			accuracy = DECI_ACC1;
		else	accuracy = DECI_ACC10;

		switch (frm_loc.angular.ang_roff_unit)
		{
			case ANG_ROFF_UNIT_DEG: ang_roff = "deg"; break;
			case ANG_ROFF_UNIT_MIN: ang_roff = "min"; break;
			case ANG_ROFF_UNIT_SEC: ang_roff = "sec"; break;
			default: ang_roff = NULL; break;
		}
	}
        else
	{
		ang_roff  = NULL;
		if (frm_loc.deci_frac == DECIMAL_MODE)
		{
			form_no = FORM_DECACC_ANG;
			accuracy = frm_loc.angular.decacc;
		}
		else
		{
			form_no = FORM_FRAACC_ANG;
			accuracy = frm_loc.angular.fraacc;
		}
	}

	ang_acc = get_option(form_no, SUB_FORM_LABEL, accuracy);

	if (ang_roff)
	{
		len = sprintf(ang_fmt, "%s-%s", ang_acc, ang_roff);
		ang_fmt[len] = '\0';
	}
	else	strcpy(ang_fmt, ang_acc);

	put_value_alpha(FORM_LOCAL, GAD_ANG_ACCURACY, ang_fmt);
	set_select_off(FORM_LOCAL, GAD_ANG_ACCURACY);
}

/* group OVERRIDE */

group_output_OVERRIDE()
{
	trace_in("group_output_OVERRIDE");

	if (frm_glob.dim_mode == MODELING_MODE)
	{
		select_label(OFF, FORM_LOCAL, LAB_OVERRIDE);
		select_label(OFF, FORM_LOCAL, GAD_OVERRIDE);
		select_label(OFF, FORM_LOCAL, GAD_NTS_ULINE);
		select_label(ON, FORM_LOCAL, LAB_TXT_HEIGHT);
		select_label(ON, FORM_LOCAL, GAD_TXT_HEIGHT);
	}
	else
	{
		select_label(OFF, FORM_LOCAL, LAB_TXT_HEIGHT);
		select_label(OFF, FORM_LOCAL, GAD_TXT_HEIGHT);
		select_label(ON, FORM_LOCAL, LAB_OVERRIDE);
		select_label(ON, FORM_LOCAL, GAD_OVERRIDE);
		select_label(ON, FORM_LOCAL, GAD_NTS_ULINE);
	}

	gadget_output_NTS_ULINE();
	gadget_output_OVERRIDE();
	gadget_output_TXT_HEIGHT();

	RETURN(TRUE);
}

gadget_input_OVERRIDE(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	double dval;
	extern int sscanf();

	get_value_alpha(frm_misc.dim_override, p_dm_gadget);

	if (frm_misc.dim_override[0] == '\0')
		frm_misc.mod_comp = MOD_COMP_DYNAMIC;
	else
	{
		frm_misc.mod_comp = MOD_COMP_STATIC;
		if ((frm_env.dual_mode == DUAL_MODE_ON)
		&&  (!sscanf(frm_misc.dim_override, "%lf", &dval)))
			ex$message(msgnumb=DM_I_OverrideIncmpDualMd);
	}

	if (FORM_DISPLAYED) group_output_OVERRIDE();
}

gadget_output_OVERRIDE()
{
	put_value_alpha(FORM_LOCAL, GAD_OVERRIDE, frm_misc.dim_override);
}

/* group INDEPENDANT */

group_output_LOC_INDEP()
{
	trace_in("group_output_LOC_INDEP");

	RETURN(TRUE);
}

gadget_input_TER_DISP(p_dm_gadget)
struct DM_data_st *p_dm_gadget;
{
	frm_loc.ter_disp = get_value_int(p_dm_gadget);
}

put_value_toggle(form_no, label, state)
int form_no;
int label;
int state;
{
	struct DM_data_st dm_gadget;

	dm_gadget.form_no = form_no;
	dm_gadget.label = label;
	dm_gadget.type = DIM_TOGGLE;
	dm_gadget.val.ivalue = state;

	display_gadget(&dm_gadget);
}

put_value_roll(form_no, label, ivalue)
int form_no;
int label;
int ivalue;
{
	struct DM_data_st dm_gadget;

	dm_gadget.form_no = form_no;
	dm_gadget.label = label;
	dm_gadget.type = DIM_ROLL;
	dm_gadget.val.ivalue = ivalue;

	display_gadget(&dm_gadget);
}

put_value_int(form_no, label, ivalue)
int form_no;
int label;
int ivalue;
{
	struct DM_data_st dm_gadget;

	dm_gadget.form_no = form_no;
	dm_gadget.label = label;
	dm_gadget.type = DIM_INT;
	dm_gadget.val.ivalue = ivalue;

	display_gadget(&dm_gadget);
}

put_value_alpha(form_no, label, alpha)
int form_no;
int label;
char *alpha;
{
	struct DM_data_st dm_gadget;

	dm_gadget.form_no = form_no;
	dm_gadget.label = label;
	dm_gadget.type = DIM_ALPHA;
	DMstrncpy(dm_gadget.val.alpha, alpha, EXFI_STRLEN);

	display_gadget(&dm_gadget);
}

put_value_double(form_no, label, dvalue)
int form_no;
int label;
double dvalue;
{
	struct DM_data_st dm_gadget;

	dm_gadget.form_no = form_no;
	dm_gadget.label = label;
	dm_gadget.type = DIM_DOUBLE;
	dm_gadget.val.dvalue = dvalue;

	display_gadget(&dm_gadget);
}

is_form_displayed(form_no)
int form_no;
{
	Form form_id;
	int display;

	trace_in("is_form_displayed");

	if (frm_state == STATE_REPLAY) RETURN(FALSE);

	if (form_id = DMform_list[form_no].form_id)
	{
		FIf_is_displayed(form_id, &display);
		RETURN(display);
	}

	RETURN(FALSE);
}

put_value_hilite(form_no, label, hilite)
int form_no, label, hilite;
{
	trace_in("put_value_hilite");

	if (DMform_list[form_no].form_id == NULL) RETURN(TRUE);

	if (hilite)
		FIg_hilite(DMform_list[form_no].form_id, label);
	else	FIg_unhilite(DMform_list[form_no].form_id, label);

	RETURN(TRUE);
}

set_select_off(form_no, label)
int form_no, label;
{
	IGRint sts;

	trace_in("set_select_off");

	if (DMform_list[form_no].form_id == NULL)
		return(TRUE);

	FIfld_set_select(
		DMform_list[form_no].form_id,
		label,
		0,
		0,
		FALSE);

	return(TRUE);
}

fill_label_info(unit_sel)
int unit_sel;
{
	char mea_unit;
	char label[9];
	char sub_label[9];

	if (unit_sel == UNIT_SEL_PRIMARY)
		mea_unit = frm_env.pri_unit;
	else	mea_unit = frm_env.sec_unit;

	if (mea_unit == MEA_UNIT_FEET_INCHES)
	{
		strcpy(label, "' - ");
		strcpy(sub_label, "\"");
	}
	else
	{
		label[0] = '\0';
		sub_label[0]='\0';
	}

	if (unit_sel == UNIT_SEL_PRIMARY)
	{
		strcpy(frm_loc.primary.label, label);
		strcpy(frm_loc.primary.sub_label, sub_label);
	}
	else
	{
		strcpy(frm_loc.secondary.label, label);
		strcpy(frm_loc.secondary.sub_label, sub_label);
	}

	return(TRUE);
}

load_dim_info(dim_grid)
struct GRid dim_grid;
{
	IGRint sts;

	GEOM_TYPE = 0;
	DISPLAY_TYPE = 0;

	sts =
        ci$send(msg = message DMroot.inq_geom_type((IGRchar *)&GEOM_TYPE),
                targetid = dim_grid.objid,
                targetos = dim_grid.osnum);
        dm$status(sts = sts, action = RET_STATUS);

	if ((GEOM_TYPE & DIM_DRIVING) || (GEOM_TYPE & DIM_IMPORTED))
		return(TRUE);

	sts =
        ci$send(msg = message DMroot.inq_display_type((IGRchar *)&DISPLAY_TYPE),
                targetid = dim_grid.objid,
                targetos = dim_grid.osnum);
        dm$status(sts = sts, action = RET_STATUS);

	return(TRUE);
}
