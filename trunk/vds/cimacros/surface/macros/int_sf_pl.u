/* $Id: int_sf_pl.u,v 1.1.1.1 2001/01/04 21:07:21 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/surface/macros / int_sf_pl.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: int_sf_pl.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:21  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bstypes.h"
#include "bserr.h"
#include "bsconic.h"
#include "emsedgedef.h"
#include "macro.h"
#include "nddef.h"
#include "AS_status.h"


#define  AS_DEBUG 1

#define   MAX_FEET		30
#define   MAX_CHA_FEET		7
#define   MAX_TEMP		2 	/* number of templates */

#define   VERBOSE 		1
#define VDS_DATA_REDUCTION      1

/*#define   DEBUG	         	1 /* */

/* Intersection between a surface (or a bounded plane) and a plane taken 
/* as infinite
/* */


struct GRid		CI_MACRO_ID;
GRobj 			ci_mac_def1;
IGRchar			*temp_names[MAX_TEMP], *feet_names[MAX_FEET];
IGRint			temp_types[MAX_TEMP];

struct IGRbsp_surface   *bsp_surf1;

struct IGRplane		plane;

struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct GRid		SUR, SUR2, GRid_list[MAX_FEET];


char	 	 	buff[MAX_FEET*MAX_CHA_FEET];

long			stat, status, msg;
IGRboolean		ext;
BSrc			rc;
double			plane_space[6], matrix[16], **pts, **tans, **pars;
int			elem_type, type_flag, *numpts, numgrps, num_inter, i;
int			nb_sf2;
short			matrix_type;
struct IGRpolyline      geom;
struct GRprops	 	properties;
struct GRid		*obj_int;
struct GRlc_info 	located_object;
struct GRlc_info	plane_object;
GRclassid		obj_classid;

extern GRclassid	OPP_EMSplane_class_id, OPP_EMSsurface_class_id;

extern int 	init_cnst_list(), ASsuper_construct(),
		sprintf(),
		printf(),
		BSmkvec(),
		free(),
		BSfreecv(),
		SMelem_(),
		VDint(),
		VDSfree(),
		BSsf_pl_int(),
		ACcreate_def_temp();

extern	char	*malloc();
extern	long	VDSapplyDataReduction();
extern	double	fabs(), BSdistptpt(), BSdotp();


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
 for (i=0; i<MAX_FEET; i=i+1)
  {
	sprintf(&buff[i*MAX_CHA_FEET],"resi%d",i);
	feet_names[i] = &buff[i*MAX_CHA_FEET];
  }

  temp_names[0] = "surface";  
  temp_types[0] = other_generic;
  temp_names[1] = "plane";
  temp_types[1] = other_generic;

  ci_mac_def1 = NULL_OBJID;



  ac$cimacdef( 	cimacdef          	= ci_mac_def1,
		status 	          	= &stat,
		name              	= "int_sf_pl",
             	temp_num  		= MAX_TEMP,
 		temp_names 		= temp_names,
                temp_types 		= temp_types,
	      	extern_feet_num 	= MAX_FEET, 
		extern_feet_names 	= feet_names);
 return(1);
}

/* ========================================================================= */

place ()
{
  sf_pl_intersect();
  if( num_inter == 0 ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, num_inter, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }

  return(1);
}


/* ========================================================================= */

compute ()
{
  sf_pl_intersect();
  if( num_inter == 0 ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, num_inter, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }
  return(1);
}

/* ========================================================================= */

sf_pl_intersect()
{

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.geometry		= NULL;
  cst.class_attr	= 0;
  cst.name		= 0;


  num_inter = 0;

# ifdef DEBUG
  printf("surf_intersect begin\n"); 
# endif

  plane.point  = &plane_space[0];
  plane.normal = &plane_space[3];

  for(i=0;i<MAX_FEET;i=i+1) GRid_list[i].objid = NULL_OBJID;


  status = ci$send( msg      = message  ACcpx.ACfind_exp_temp_obj(&stat,1,&SUR2),
           	 targetid = CI_MACRO_ID.objid,
           	 targetos = CI_MACRO_ID.osnum );

  if( !(status&stat&1) ) return 0;

  status = ci$send( msg      = message NDmacro.ACreturn_foot(	
				&stat ,
				"",
				&SUR2, 
				&matrix_type, 
				matrix ),
	   	targetid = SUR2.objid,
	   	targetos = SUR2.osnum );

  if( !(status&stat&1) ) return 0;

  status = ci$send(msg = message GRvg.GRgeomprops(&msg, &matrix_type, matrix,
						 &properties),
	  	    targetid = SUR2.objid,
	  	    targetos = SUR2.osnum );
  as$status(action = RET_STATUS); 

  if(properties.planar != TRUE)
   {
    printf("The second element is not planar\n");
    return 0;
   }

   status = ci$send (msg = message GRvg.GRdetplane(&msg, &matrix_type, matrix, &plane),
	  	    targetid = SUR2.objid,
	  	    targetos = SUR2.osnum );
        
   as$status(action = RET_STATUS);   

#  ifdef DEBUG
   printf("plan: %d, %d\n", SUR2.objid, SUR2.osnum);
   printf("plan: u: %lf, %lf, %lf, v:%lf, %lf, %lf\n",
           plane.point[0],  plane.point[1], plane.point[2],
  	   plane.normal[0], plane.normal[1], plane.normal[2]);
 
#  endif

  status = ci$send( msg      = message  ACcpx.ACfind_exp_temp_obj(&stat,0,&SUR),
           	 targetid = CI_MACRO_ID.objid,
           	 targetos = CI_MACRO_ID.osnum );

  if(stat == 0 ) return 0;

  status = ci$send( msg      = message NDmacro.ACreturn_foot(	
				&stat ,
				"",
				&SUR, 
				&located_object.module_info.md_env.matrix_type, 
				located_object.module_info.md_env.matrix ),
	   	targetid = SUR.objid,
	   	targetos = SUR.osnum );

  if( !stat ) return 0;
# ifdef DEBUG
  printf("surf: %d, %d\n", SUR.objid, SUR.osnum);
# endif

 status = om$get_classid(osnum     = SUR.osnum, 
			 objid     = SUR.objid, 
			 p_classid = &obj_classid);
 if( om$is_ancestry_valid(subclassid = obj_classid,
			  superclassid = OPP_EMSsurface_class_id ) != OM_S_SUCCESS)
  {
   printf("The first template has to be not a surface\n");
   return 0;
  }

 obj_int = NULL;

 located_object.located_obj  = SUR;
 located_object.geom_parms.u = 0.5;
 located_object.geom_parms.v = 0.5;
 located_object.geom_parms.polygon_inx = 0;
 located_object.geom_parms.leaf_id.objid = NULL_OBJID;

 located_object.module_info.md_id.objid = MOD_ENV.md_id.objid;
 located_object.module_info.md_id.osnum = located_object.located_obj.osnum;

 status = ci$send( msg = message EMSsurface.EMintplane(&cst,
                          &plane,
                          &located_object,
                          &numgrps,
                          &obj_int,
                          &msg),
           	  	  targetid = SUR.objid,
 	   	  	  targetos = SUR.osnum );
 as$status(action = RET_STATUS); 

#ifdef	VDS_DATA_REDUCTION
/*
 * EF/AZ
 * Execute data reduction (Don't check about return code because the function
 *			   returns something; even if it fails).
 */
	
  plane_object.located_obj 	= SUR2;
  plane_object.module_info	= MOD_ENV;
  plane_object.module_info.md_id.objid = MOD_ENV.md_id.objid;
  plane_object.module_info.md_id.osnum = SUR2.osnum ;
  
  VDSapplyDataReduction(	&msg,
				&located_object,	/* Not Used */
				&plane_object,	/* Not Used */
				&cst,
				numgrps,
				obj_int );

#endif	/* VDS_DATA_REDUCTION */

  for(i=0;i<numgrps;i=i+1)
     {
#     ifdef DEBUG
      printf("intersection #: %d, obj: %d, %d\n", i, obj_int[i].objid, obj_int[i].osnum);
#     endif
      GRid_list[i] = obj_int[i];
      }
      
  if(obj_int != NULL) free(obj_int);
  num_inter = numgrps;

  return(1);

}




