/* $Id: VDCrEdTbPr.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/obsolete/cmd / VDCrEdTbPr.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDCrEdTbPr.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
	 92/08/13	This file is OBSOLETE
 */
   
/****************************************************************************

 $Header: /export/home/cvs/isdp/vds/cimacros/obsolete/cmd/VDCrEdTbPr.u,v 1.1.1.1 2001/01/04 21:07:20 cvs Exp $

 $Log: VDCrEdTbPr.u,v $
 Revision 1.1.1.1  2001/01/04 21:07:20  cvs
 Initial import to CVS

# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
Revision 142.0  91/05/30  16:48:25  phillip
COMMENT : Robert's Command to create & manage a table of parameters via an ascii file.

Revision 142.1  91/06/25  16:48:25  phillip
COMMENT : Added Forms interface, merged create & edit commands via
		toggle for place macro, though expressions are always created.
		TABLE_PATH parameter is checked, if it doesn't exist and
		set to current directory, ie PWD.
		This is PPL, watch out for globals.

Revision 142.2  91/08/25  16:48:25  phillip
COMMENT : 	User Interface changes.

		TABLE_PATH now works like the $PATH variable, ie
		directories are separated by ":";
		Alphanumeric (ASCII) keys are now supported;
		Lists providing available choices for the directory,
		table name and key implemented on form fields.

		This is PPL, watch out for globals.
*****************************************************************************/

#include "OMminimum.h"
#include "OMmacros.h"
#include "ciminimum.h"
#include "cisend.h"
#include "cilocate.h"
#include "cisymb.h"
#include "cievent.h"
#include "ci_mac_def.h"
#include "DIdef.h"
#include "DItypedef.h"
#include "DIglob.h"
#include "DIprims.h"
#include "DImacros.h"

#include <stdio.h>
#include <limits.h>
#include <stdio.h>
#include <sys/types.h>	// for reading unix dir
#include <dirent.h>	// for reading unix dir
// assoc debug 
#include "AS_debug.h"
#include "AS_status.h"
//#define  AS_DEBUG 1
#undef	AS_DEBUG

// forms stuff 
#include "FI.h"
#include "CIforms.h"
/* Gadgets */

#define MESSAGE		10
#define TABLE_NAME      18
#define PARAM_VALUES    19
#define PARAM_NAMES     20
#define KEY        	21
#define DIR_NAME        22
#define PLACE_MACRO     23


/* Externs */

extern int DB_debug()			;
extern int ci_notification()		;
extern int FIf_new()			;
extern int FIf_delete()			;
extern int FIf_get_attr()		;
extern int FIf_set_attr()		;
extern int FIg_get_text_length()	;
extern int FIg_get_state()		;
extern int FIg_get_text()		;
extern int FIg_get_value()		;
extern int FImcf_get_active_col()	;
extern int FIg_get_text_length()	;
extern int FIfld_get_text()		;
extern int FIf_set_cmd_oid_os()		;
extern int FIfld_set_text()		;
extern int FIfld_set_list_default_text();
extern int FIf_display()		;
extern int FIg_get_type()		;
extern int FIfld_get_active_row()	;
extern int FIfld_get_text_length()	;
extern int FImcf_set_num_cols()		;
extern int FImcf_set_scroll_link()	;
extern int FIfld_get_value()		;
extern int FIfld_set_value()		;
extern int FIfld_set_mode()		;



extern double	atof()		;
extern int	CIexpand()	;
extern int	sprintf()	;
extern int	DImain()	;
extern int	DIfast_trans()	;
extern int	DIpwd()  	;
extern char	*strtok()	;
extern char 	*getenv()	;	
//extern int	putenv()	;	
extern int	strncmp()	;
extern DIR    *	 opendir();
extern struct dirent * readdir();

#define DEBUG 1
#define MAX_COLS 	20	// number of parameters
#define MAX_LINES	1024	// lines in file
#define FORM_NAME "VDParamTable"
#define MAIN_PROMPT "Enter Values Via Form"
#define CREATE_NE	10
#define CREATE_NE_MSG	"Create name expression failed"
#define CREATE_KE	11
#define CREATE_KE_MSG	"Create key expression failed"
#define CREATE_PE	12
#define CREATE_PE_MSG	"Create parameter expression failed"
#define GIVE_PE		13
#define GIVE_PE_MSG	"Give parameter value failed"
#define READ_PE		14
#define READ_PE_MSG	"Error reading parameter name"
#define FILE_NW		15
#define FILE_NW_MSG	"Error opening file "
#define FILE_NF_MSG	"Could not find table file "
#define KEY_NF_MSG	"Could not find key in table file "
#define BLANK		""
#define PLACE_MACRO_MSG "Table macro placed and exps deleted"
#define EDIT_ONLY_MSG	" Table Modified"
#define PROCESSING	" Processing parameters..."
#define BAD_DIR		"Unable to open directory, check protection or type"




	FILE	*pmfile			; // File stream.
OM_S_CHANSELECT xxx;
struct GRmd_env MOD_ENV;
struct CIform_st form_st;

int	suc,j,i,stat;
char    dirname[80],name[20],reponse[80];
int     osn; 
int	place_macro, fileexists, keyexists;	// Global Booleans
struct  GRid	TP[2],MAC;
GRobj	TEMP[40],PRET,TMP;
char    wk_name[40],num_name[40];
char    pname[20];
char    *ename[MAX_COLS],jname[800];
char    *xname[MAX_COLS],jxname[800];
char	*lines[MAX_LINES];
char    key[20];
int	numb_params;
double  feet_values[20];
char    *test_form_ptr;  /* Pointer to form */
char	DI_pwd[PATH_MAX];
char	*envname		;	// environment var for path

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


init_form()
{
 IGRlong        status, rc;		// general return codes 
 IGRint         row;                    // row of field on form 

/*|init_form*/
  if ( ! (int) test_form_ptr )
     FIf_new(test_form_ptr, FORM_NAME, ci_notification, &test_form_ptr);
  if ( test_form_ptr )
  {
    FIf_set_cmd_oid_os( test_form_ptr, MY_ID, OM_Gw_current_OS );
    lines[0] = getenv( "TABLE_PATH" ) ;  // using lines as temp var
    /*" lines[0] is %s \n", lines[0] */
    find_dir( lines[0] );
    find_tables( dirname );		// global should now have dir name
    /*|before change num of cols*/
    status = FImcf_set_num_cols( test_form_ptr, PARAM_NAMES, MAX_COLS );
    if ( status != FI_SUCCESS ) /*" num col names stat %d\n", status */;
    /*|after change num of cols*/
    status = FImcf_set_num_cols( test_form_ptr, PARAM_VALUES, MAX_COLS );
    if ( status != FI_SUCCESS ) /*" num col values stat %d\n", status */;
    status= FImcf_set_scroll_link( test_form_ptr,PARAM_VALUES, PARAM_NAMES );
    if ( status != FI_SUCCESS ) /*| Error setting scroll */;
    status= FIg_get_state( test_form_ptr, PLACE_MACRO, &place_macro );
    if ( status != FI_SUCCESS ) /*| Error getting state */;

#ifdef AS_DEBUG
    /*| setting form to normal window to prevent lockup*/
      FIf_get_attr( test_form_ptr, &i );
	row = 0; //~(FI_SAVE_RESTORE | FI_DISPLAY_COLLAPSED);
	  printf( "\nsetting form to normal window\n " );
	    FIf_set_attr( test_form_ptr, row );
#endif
    FIf_display( test_form_ptr );
  }
  else
  {
    /*| Form not initialised */
    exit;
  }

  for( i = 0 ; i < MAX_COLS ; i = i + 1 ) ename[i] = &jname[i*40] ;
  for( i = 0 ; i < MAX_COLS ; i = i + 1 ) xname[i] = &jxname[i*40] ;
  /*| find current directory for translates */
  di$pwd( dirname = DI_pwd );
  /*|init_form end*/
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*.wakeup */
wakeup() { message( "Construct table" ) ; }

main()
{
 int		response,status;
 init_form();
 while ( 1 )
 {
  /*| before get event */
  FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, MAIN_PROMPT, FALSE );
  ci$get(	prompt	= MAIN_PROMPT,
		response= &response );
  if ( response == D_RESET )
   {
     status = process_input();
     switch( status )
     {
      case CREATE_NE:
       FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, CREATE_NE_MSG, FALSE );
      break;

      case CREATE_KE:
       FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, CREATE_KE_MSG, FALSE );
      break;

      case CREATE_PE:
       FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, CREATE_PE_MSG, FALSE );
      break;

      case GIVE_PE:
       FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, GIVE_PE_MSG, FALSE );
      break;

      case FILE_NW:
       FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, FILE_NW_MSG, FALSE );
      break;

      default:
       FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, BLANK, FALSE );
      break;
     }
   }
 }
}

/*----------------------------------------------------------------------------*/
double strtod( ptr, next ) char *ptr, **next ; {
	double d ;
/*|strtod*/
	while( isspace( *ptr ) ) ptr = ptr + 1 ;
	d = atof( ptr ) ;
	*next = ptr ;
	return d ;

} // strtod


process_input() {

 double val;
 int	sel_flag, r_pos, text_len;
 char  *next;

/*|process_input*/
 ci$get_module_info(md_env = &MOD_ENV);


  FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, PROCESSING, FALSE );
/*| set names */
  if(tab_exists(name,&j,xname))
       {
	   /*|tab exists */
           i=0;
           while(i<j){
	   /*" tab exists i is %d j is %d\n", i, j */
		
		FIfld_get_value( test_form_ptr, PARAM_VALUES, 0, i,
				   &val, &sel_flag, &r_pos );
		feet_values[i] = val;
		suc = di$translate(	objname = xname[i],
					path	= DI_pwd,
					p_objid	= &TEMP[i],
					p_osnum = &osn ) ;
                if( !( suc & SUCC ) ) 
		{
		  sprintf( wk_name, "%f", val ); 
		  TEMP[i] = NULL_OBJID;
   		  osn=MOD_ENV.md_id.osnum;
		  suc = 0;
		  /*"trying to create %s, with val %s\n", xname[i], wk_name */
  		  stat = ci$send(  msg      = message expression.create
		 				( xname[i], wk_name , &suc ),
                   		targetid = TEMP[i],
		   		targetos = osn );
   		  if( suc != 1 || stat != 1   ) {
		   as$status( sts = stat ); }
		  i=i+1;
		}
		else i=i+1;
           }
       }
  else
       {
	j = 0 ;
	while(1){
	 /*" tab doesn't exist i is %d\n", i */
	 suc = 
    	   FIfld_get_text_length( test_form_ptr, PARAM_NAMES, 0, j, &text_len );
	 if ( suc != FI_SUCCESS )  return ( READ_PE );
	 if ( text_len <= 1 || text_len >= 40 ) 
	  {
	   /*" finish params at %d\n", j */
	   break;
	  }
	 else
	  /*"length is %d\n", text_len */;
	  *ename[j] = '\0';
	 suc =
            FIfld_get_text ( test_form_ptr, PARAM_NAMES, 0, j, 
			      40, ename[j], &sel_flag, &r_pos );
	 /*" text_len is %d, text %s \n", text_len, ename[j] */
	 if ( suc != FI_SUCCESS )  return ( READ_PE );
	 suc = di$translate(	objname = ename[j],
				path	= DI_pwd,
					p_objid	= &TEMP[j],
					p_osnum = &osn ) ;
           if( !( suc & SUCC ) ) 
	    {
		FIfld_get_value( test_form_ptr, PARAM_VALUES, 0, j,
				   &val, &sel_flag, &r_pos );
		sprintf( wk_name, "%f", val ); 
		/*"for param %s got val %s\n", ename[j], wk_name */
		stat = 0; suc = 0;
		TEMP[j] = NULL_OBJID;
   		osn=MOD_ENV.md_id.osnum;
  	 	stat = ci$send(  msg      = message expression.create
		 				( ename[j], wk_name, &suc ),
                   		targetid = TEMP[j],
		   		targetos = osn );
   		if( suc != 1 || stat != 1   ){return( CREATE_PE );}
		feet_values[j] = val;
		j = j + 1;
	    }
           else 
		{
		
  		suc = ci$send(  msg      = message expression.NDgive_value
		 				( &feet_values[j] ),
                   		targetid = TEMP[j],
		   		targetos = osn);
   		if( suc != OM_S_SUCCESS ){return( GIVE_PE );}
		j = j + 1;
		}
        }
       } 
    stat =  pm_in( name, j, ename,key,feet_values ) ;
    if ( !stat ) return ( FILE_NW );
  if ( place_macro )
  {

  for(i=0;i<2;i=i+1)
    {
    TP[i].objid=NULL_OBJID;
    TP[i].osnum=MOD_ENV.md_id.osnum;
    }

  for(i=0;i<10;i=i+1)
   {
   sprintf( num_name, "%s%d",name,i) ;
   suc = di$translate(	objname = num_name,
			path	= DI_pwd,
					p_objid	= &TMP,
					p_osnum = &osn ) ;
           if( !( suc & 1 ) ) break ;
   }
  sprintf( reponse, "Name of table occurence-%s\n",num_name ) ;
  /*" reponse is %s", reponse*/
  sprintf( wk_name, "%s_nm",num_name ) ;
  suc=1;
  stat = ci$send(  msg      = message text_exp.create
		 				( wk_name ,name , &suc ),
                   		targetid = TP[1].objid,
		   		targetos = TP[1].osnum);
  if( suc != 1 || stat != 1  ) {return( CREATE_NE ); }
  sprintf( wk_name, "%s_key",num_name ) ;
  /*" key is %s wk_name is %s\n", key, wk_name */
  stat = ci$send(  msg      = message text_exp.create
		 				( wk_name ,key , &suc ),
                   		targetid = TP[0].objid,
		   		targetos = TP[0].osnum);
   if( suc != 1 || stat != 1   ){return( CREATE_KE );}
   /*| before init macro */
   MAC.objid = NULL_OBJID;
   MAC.osnum=MOD_ENV.md_id.osnum;
   ci$send(msg      = message  nci_macro.init( &suc,
						    0,
						    "table",
						    2,
						    TP,
   						    0,
						    &MOD_ENV ),
	         targetid = MAC.objid,
		 targetos = MAC.osnum);
   ci$send(msg      = message  GRvg.GRputname( &suc,num_name),
	         targetid = MAC.objid,
		 targetos = MAC.osnum);

   xxx.type=OM_e_name;
   xxx.u_sel.name ="NDchildren.children";   
   for(i=0;i<j;i=i+1)
    {
    PRET  = NULL_OBJID;
    sprintf( pname,"P%d",i ) ;
    ci$send(msg      = message  ACpretend.ACplace(0,&MAC.objid,pname),
	         targetid = PRET,
		 targetos = MOD_ENV.md_id.osnum);
    stat=ci$send(msg      = message  Root.move_chan
		(xxx,TEMP[i],osn,xxx),
	         targetid = PRET,
		 targetos = MOD_ENV.md_id.osnum);
    stat=ci$send(msg      = message  NDnode.NDdelete
		(&MOD_ENV),
	         targetid = TEMP[i],
		 targetos = MOD_ENV.md_id.osnum);
    }
    FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, PLACE_MACRO_MSG, FALSE );
  }
  else
  {
    FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, EDIT_ONLY_MSG, FALSE );
  }
   
} // process_input

/*----------------------------------------------------------------------------*/
int isspace( c ) char c ; {

/*|in isspace*/
	return c == ' ' || c == '\t' || c == 'n' ;
/*|out  isspace*/
}
/*----------------------------------------------------------------------------*/
int pm_in( type, feet_count, feet_names ,key,feet_values)
		char	*type,
			**feet_names;
		char    *key;
		double  *feet_values;
		int	feet_count	; {

	FILE	*pmfilel			; // File stream.
	char	tmp[1+99]	, // Path name to PM file.
		pmexpn[1+PATH_MAX]	; // Expanded path name to PM file.
	int	i, j, rc		;
 	double  val			;
	int	sel_flag, r_pos		;

/*|in pm_in */
	strcpy( pmexpn, dirname 	 ) ;
	strcat( pmexpn, "/"		 ) ;
	strcat( pmexpn, type		 ) ;
	strcat( pmexpn, ".t"		 ) ;
	if ( keyexists )
	{
	  /*"OPENING FILE %d keyexists\n", pmfile */
	  if( ( pmfile = fopen( pmexpn, "r" ) ) != NULL ) {
	    /*" opened file %d for read\n", pmfile */
	    for( i=0; i<MAX_LINES; i=i+1 )
	    {
	     lines[i] = om$malloc( size=BUFSIZ );
		if( fgets( lines[i], BUFSIZ, pmfile ) == NULL ) {
		 om$dealloc( ptr=lines[i] );
		 if ( i ) i=i-1;
		 break;
		}
		else if ( !strncmp( key, lines[i], strlen(key) ) )
		 {
		  strcpy( lines[i], key );
		  strcat( lines[i], "\t\t" );
		  for ( j=0; j<feet_count ; j=j+1 )
		  {
		   	//use wkname a temp var 
		   sprintf( wk_name, "%.4f", feet_values[j] ); 
		   strcat( lines[i], wk_name );
		   strcat( lines[i], "\t" );
		  }
		  strcat( lines[i], "\n" );
		 } // if found key
	     }	// for all lines in file
	    fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
	  if( ( pmfile = fopen( pmexpn, "w" ) ) != NULL ) {
	    for ( j=0; j<=i; j=j+1 )
	    {
	     fputs( lines[j], pmfile);
	     om$dealloc( ptr=lines[j] );
	    }
	    fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
	     
	   }// if file is there

	    return ( TRUE );
	 }// if file is there
	 else	rc = FALSE	;
	} // if keyexists
        else
	{
	 /*"OPENING FILE %d key doesn't exist\n",pmfile */
	 if( ( pmfile = fopen( pmexpn, "a" ) ) != NULL ) { 
	    if ( ! fileexists )
	     {
		/*| writing names */
		fprintf( pmfile, "\t\t" ) ;
		for( i = 0 ; i < feet_count ; i = i + 1 ) {
			fprintf( pmfile, "%s\t", feet_names[i] ) ;
		FIfld_get_value( test_form_ptr, PARAM_VALUES, 0, i,
				   &val, &sel_flag, &r_pos );
		feet_values[i] = val;
		}
	        fprintf( pmfile, "\n" ) ;
	     }
	    fprintf( pmfile, "%s\t\t",key ) ;
	    for( i = 0 ; i < feet_count ; i = i + 1 ) {
			fprintf( pmfile, "%.4f\t", feet_values[i] ) ;
		}
	    fprintf( pmfile, "\n" ) ;
	    fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
	    rc = TRUE 		;
	    fileexists = TRUE 	;
	    keyexists = TRUE	;
	} else	rc = FALSE	;
      }		// key doesn't exist 

/*| out pm_in */
	return rc ;
} // pm_in

int tab_exists(type,   feet_count, feet_names )

		char	*type	;
		int	*feet_count	;
		char	**feet_names	; {

	FILE	*pmfilel			;
	char	pmpath[1+PATH_MAX]	,
		pmexpn[1+PATH_MAX]	,
		line[1+BUFSIZ]		,
		tmp[100]		,
		*ptr			,
		*next			,
		*dirpath		;
	
	int	i, rc			;

/*| in tab exists */
	strcpy( pmexpn, dirname 	 ) ;
	strcat( pmexpn, "/"		 ) ;
	strcat( pmexpn, type 		 ) ;
	strcat( pmexpn, ".t"		 ) ;
	if( ( pmfile = fopen( pmexpn, "r" ) ) != NULL ) {
//		Use 1st line to count feet.
		if( fgets( line, BUFSIZ, pmfile ) == NULL ) {
			rc = FALSE	;
			fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
			goto WRAPUP	;
		}
		*feet_count = 0 ; ptr = line ;
		do {
			next = strtok( ptr, " \t\n" ) ;
			ptr = NULL ;
			if( next != NULL ) {
			      /*"tab_e: foot = <%s>\n", next */
                        sprintf(feet_names[*feet_count],"%s", next ) ;
			*feet_count = *feet_count + 1 ;}
		} while( next != NULL ) ;
			/*"tab_e: feet-count %d\n", *feet_count */
	        rc = TRUE 	;
		fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
		fileexists = TRUE;
  	}
	else 
	{
	   rc= FALSE;
	   fileexists=FALSE;
	}
WRAPUP:
/*| out tab exists */
    return rc;

} //  end tab_exists

/*----------------------------------------------------------------------------*/

int key_exists( type, feet_count, feet_vals )
		char	*type	;
		int	feet_count	;
		double  *feet_vals; 		{

	FILE	*pmfilel			;
	char	pmpath[1+PATH_MAX]	,
		pmexpn[1+PATH_MAX]	,
		line[1+BUFSIZ]		,
		tmp[100]		,
		*ptr			,
		*next			,
		*dirpath		;
	
	int	i, rc			;
			rc = FALSE	;
/*.key_exists*/
	strcpy( pmexpn, dirname 	 ) ;
	strcat( pmexpn, "/"		 ) ;
	strcat( pmexpn, type 		 ) ;
	strcat( pmexpn, ".t"		 ) ;
	if( ( pmfile = fopen( pmexpn, "r" ) ) != NULL ) {
	/*" open file is %d\n", pmfile */
		if( fgets( line, BUFSIZ, pmfile ) == NULL ) {
			rc = FALSE	;
			fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
			goto WRAPUPK	;
		}
		/*"got line %s\n", line */
		 keyexists=FALSE;
		 while( fscanf( pmfile, "%s", tmp ) != EOF )
		 {
		     /*"tmp is %s\n", tmp */
		     if ( !strcmp( tmp, key ) )
		      {
			for ( i=0; i<feet_count; i=i+1 )
			 {
			  fscanf( pmfile, "%s", tmp );
			  feet_vals[i] = atof( tmp ); /*strtod( tmp, &next );*/
			/*"key_e: feet-val %f\n", feet_vals[i]*/
			 }
			keyexists = TRUE;
			break;
		      }
		 }
	        rc = TRUE 	;
		fclose( pmfile ) ;
	    /*" closed file %d \n", pmfile */
		fileexists = TRUE;
  	}
	else 
	{
	   rc= FALSE;
	   fileexists=FALSE;
	   keyexists=FALSE;
	}
WRAPUPK:
/*| out key exists */
    return rc;

}

int Get_text ( test_form_ptr, g_label, text, text_size )
       Form    test_form_ptr;            /* Pointer to the form     */
       int     g_label;       /* The label of the gadget */
       char ** text;          /* The text contained in the field */
       int   * text_size;     /* The space allocated for the text */
{
    int status; 
    int text_len;
    int field_type;
    int select_flag;
    int row ;
    int col ;
    int pos ;
/*.Get_text*/
    FIg_get_type ( test_form_ptr, g_label, &field_type );

    if ( field_type == FI_MULTI_COL )
    {
        /*|Get the col for the MCF */

        FImcf_get_active_col ( test_form_ptr, g_label, &col, &pos );

    }

    /*|Get the row for the field or MCF */

    FIfld_get_active_row ( test_form_ptr, g_label, &row, &pos );
    FIfld_get_text_length ( test_form_ptr, g_label, row, col, &text_len );

    /*|Increment text_len because of NULL */

    text_len = text_len +1;

    if ( * text_size < text_len )
    {
        if ( * text_size > 0 )
        {
           /*|Realloc space for larger string */
           * text = om$realloc ( ptr= * text, size=text_len );
        }
        else
        {
           /*|Calloc space for string */
           * text = om$calloc ( num=1, size=text_len );
        }
        * text_size = text_len;
    }

    if (  * text == NULL )
    {
      * text_size = 0;
      return ( FI_NO_MEMORY );
    }

    status = FIfld_get_text ( test_form_ptr, g_label, row, col, * text_size,
                            * text, &select_flag, &pos );
    return ( status );
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*		form interface function					    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
form_notification ( )
{
  char   	* text		 ;		/* text ptr for string fields*/
  int      	text_size	 ;		/* size of string */
  double        fld_value	 ;		/* value from numeric fields*/
  int           status		 ;		/* general return code */
  int     	g_label		 ; 		/* gadget label */
  int		col, pos	 ;		/* column & posn from MCF */

  g_label = form_st.gadget_label;       /* The label of the gadget */
/*.form_notify*/  
  switch ( form_st.gadget_label )
  {

    case FI_CANCEL:     /* Member of group FI_CTRL_GROUP */
     ci$put( response = TERMINATE );
          /* Erase the displayed form */

         FIf_delete ( test_form_ptr );

    break;

    case FI_EXECUTE:     /* Member of group FI_CTRL_GROUP */

     ci$put( response = D_RESET );
    break;

    case FI_ACCEPT:     /* Member of group FI_CTRL_GROUP */

     process_input();
     ci$put( response = TERMINATE );
          /* Erase the displayed form */

         FIf_delete( test_form_ptr );

          /* Process form data */

    break;

    case PARAM_NAMES:     /* Sequenced to     */
     status = Get_text ( test_form_ptr, g_label, & text, & text_size );
     if ( text == NULL ) return;
     status = FImcf_get_active_col ( test_form_ptr, g_label, &col, &pos );
     /*" try transl with name %s & path %s", text, DI_pwd */
     suc = di$translate( objname = text,
			path	= DI_pwd,
			 p_objid = &TEMP[col],
			 p_osnum = &osn ) ;
    if ( suc & 1 )
     {
	suc = ci$send(  msg      = message expression.NDgive_value
		 				( &feet_values[col] ),
                   		targetid = TEMP[col],
		   		targetos = osn);
	as$status( sts = suc );
	FIfld_set_value( test_form_ptr, PARAM_VALUES, 0, col,
			   feet_values[col], FALSE );
     }
    else
    /*| didn't find the expression */;

    if ( text ) om$dealloc( ptr = text );
    break;

    case PARAM_VALUES:     /* Sequenced to     */
    break;

    case TABLE_NAME:     /* Sequenced to     */
                             /* Field Type:    ASCII    */
       text_size = 0;
      /* Get the text string */
      status = Get_text ( test_form_ptr, g_label, & text, & text_size );
      /*" status is %d\n", status */
      if ( status != FI_SUCCESS )
        {
          /*|Code to handle error */
	  if ( text ) om$dealloc( ptr = text );
          return;
        }
     else {
       /*" Code to process text string %s\n", text */
	strcpy( name, text );
	i = 0;
	if ( tab_exists( name, &j, xname ) )
	 {
	  /*| tab exists*/
	  FImcf_set_num_cols( test_form_ptr, PARAM_NAMES, MAX_COLS );
	  FImcf_set_num_cols( test_form_ptr, PARAM_VALUES, MAX_COLS );
	  while ( i<j )
	  {
	   /*| set text */
	   FIfld_set_text( test_form_ptr, PARAM_NAMES, 0, i, xname[i], FALSE );
	   FIfld_set_mode( test_form_ptr, PARAM_NAMES, i, FI_REVIEW );
	   i = i + 1;
	  }
	  for( ;i<MAX_COLS; i=i+1 ) { // clear the rest 
	    FIfld_set_text( test_form_ptr, PARAM_NAMES, 0, i, "", FALSE );
	    FIfld_set_value( test_form_ptr, PARAM_VALUES, 0, i, 0.0, FALSE );
	  }
	  check_table( &j );
	  read_in_keys( name, j );
	 }  // if tab exists
	 else
	 {
	  FImcf_set_num_cols( test_form_ptr, PARAM_NAMES, MAX_COLS );
	  FImcf_set_num_cols( test_form_ptr, PARAM_VALUES, MAX_COLS );
	  j=MAX_COLS;
	  while( 0 /*NEVER*/ )
	  {
	   FIfld_set_text( test_form_ptr, PARAM_NAMES, 0, i, "", FALSE );
	   FIfld_set_mode( test_form_ptr, PARAM_NAMES, i, FI_INSERT );

	   i = i + 1;
	  }
	 }   // else tab isn't there
	if ( text ) om$dealloc( ptr = text );
       }  // else got something
    break;

    case DIR_NAME:     /* Sequenced to     */
                             /* Field Type:    ASCII    */
      /* Get the text string */
      text_size = 0;
      status = Get_text ( test_form_ptr, g_label, & text, & text_size );

      if ( status != FI_SUCCESS )
        {
         /* Code to handle error */
	 if ( text ) om$dealloc( ptr = text );
         return;
        }
      else { 
		/* Code to process text string "text" */
	find_dir( text );
	if ( find_tables( dirname ) == OM_S_SUCCESS ) {
	   if ( check_table( &numb_params ) ) 
	      read_in_keys( name, numb_params );
	   else /*| table not found in dir */;
	}
	else {
	  /*| dir not accessible */
          FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, BAD_DIR, FALSE );
        }
        if ( text ) om$dealloc( ptr = text );
      }  // else got something
    break;

    case KEY:     /* Sequenced to     */
                             /* Field Type:    ASCII      */

          /* Get the value of the current active row */
     text_size = 0;
     status = Get_text ( test_form_ptr, g_label, & text, & text_size );

     if ( status != FI_SUCCESS )
       {
         /*|Code to handle error */
         if ( text ) om$dealloc( ptr = text );
         return;
       }
     else {
       strcpy( key, text );
       /*" got key %s\n", key */
       if ( text ) om$dealloc( ptr = text );
       check_table( &numb_params ); 
     }
   break;

    case PLACE_MACRO:
     status= FIg_get_state( test_form_ptr, PLACE_MACRO, &place_macro );
     if ( status != FI_SUCCESS ) /*| Error getting state */;

  } /* END switch ( g_label ) */

} /* END notification_routine() */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                             delete function                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*.delete*/
delete()
  {
  if ( test_form_ptr ) FIf_delete( test_form_ptr );
}

find_dir( input_name )
 char *	input_name;    // change to dir name and put result in dirname
{
/*.find_dir*/
    if ( input_name == NULL || !strcmp( input_name, "." ) )
    {
     input_name= getenv("PWD") ;
     strcpy( dirname , input_name);
     /*" looking at current directory %s\n", dirname */
    }
    else { /* treat as straight directory */
     expand_TABLE_PATH( input_name, dirname );
    }
    FIfld_set_text( test_form_ptr, DIR_NAME, 0, 0,
                     dirname, FALSE );

} // find_dir

/* ie see whether form values are valid after a key or
	directory change */
check_table( num_params )  
int  *	num_params;
{
 int count;
/*.check_table*/
  	if(tab_exists(name,num_params,xname))
	{
  	   FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, MAIN_PROMPT, FALSE );
	   if( key_exists( name, *num_params, feet_values ) )
	    {
	     /*| writing existing values to form for this key*/
	      for ( count=0; count<*num_params; count=count+1 )
		  FIfld_set_value( test_form_ptr, PARAM_VALUES, 0, count,
				   feet_values[count], FALSE );
	    }
	   else 
            FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, KEY_NF_MSG, FALSE );
	}
	else {
	   fileexists=FALSE;
	   keyexists=FALSE;
           FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, FILE_NF_MSG, FALSE );
	}
} // check_table

read_in_keys( tablename, num_params ) 
char * tablename;
int	num_params;
{
  int		i,j,rc			;
  char		fullname[1+PATH_MAX]	;
  char		key[20]			;
  char		line[BUFSIZ+1]		;
/*.read_in_keys*/
  strcpy( fullname, dirname 	 ) ;
  strcat( fullname, "/"		 ) ;
  strcat( fullname, tablename 	 ) ;
  strcat( fullname, ".t"		 ) ;
  if( ( pmfile = fopen( fullname, "r" ) ) != NULL ) {
    if( fgets( line, BUFSIZ, pmfile ) == NULL ) {
    	  rc = FALSE	;
	  /*| unable to find data */
    }
    else {
	i=1;
	while ( fscanf( pmfile, "%s", key ) != EOF )
	{
		FIfld_set_list_default_text( test_form_ptr,
						KEY,
						i, 0, key,
						FALSE );
		i=i+1;
		for ( j=0; j<num_params; j=j+1 ) fscanf( pmfile, "%s", key );
	}// end while 
	/*" found %d keys\n", i-1 */
	clear_to_end_of_list( i, KEY );
	rc = TRUE 	;
	}
  } // if readable
 else	/*| unable to open file */;
   
 fclose( pmfile ) ;
 return ( rc );
}// read_in_keys

find_tables( dir_name )
char	*	dir_name	;
{

  DIR		*	 dirp;	// pointer to unix dir 
  struct dirent	*	 dp;	// directory entry info
  int			 i, len   ;
  char			 name[15] ;
/*.find_tables*/
  dirp	=	opendir( dir_name );
  if ( dirp == NULL ) { 
    FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, BAD_DIR, FALSE );
    return( OM_E_NODIREXISTS );
  }
  i=1;
  while( ( dp = readdir( dirp ) ) != NULL ) {
    if ( (len = strlen( dp->d_name ) ) > 1 ) {
      if ( !strcmp( dp->d_name+len-2, ".t" ) ) {
	/*" %s is  a .t file\n", dp->d_name */
	strcpy( name, dp->d_name );
	name[len-2] = '\0';
	FIfld_set_list_default_text( test_form_ptr,
					TABLE_NAME,
					i, 0, name,
					FALSE );
	i=i+1;
     }
     else	/*" found %s a none .t file\n", dp->d_name */;
   }
   else		/*| less than 2 char filename */;
 }// end while 
 clear_to_end_of_list( i, TABLE_NAME );
 closedir( dirp );
 if ( i == 1 ) {
   /*| couldn't open dir */
   FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, BAD_DIR, FALSE );
   return ( OM_E_INACCESSABLE_FILE );
 }
 else {
   /*| opened dir & found table */
   FIfld_set_text( test_form_ptr, MESSAGE, 0, 0, MAIN_PROMPT, FALSE );
   return ( OM_S_SUCCESS );
 }

} //find_tables

clear_to_end_of_list( start, label ) 
int	start, label	;
{

 for ( i=start; i<10; i=i+1 ) 
	FIfld_set_list_default_text( test_form_ptr,
					label,
					i, 0, "",
					FALSE );

}  // clear list


expand_TABLE_PATH( TABLE_PATH, directory )
char *	TABLE_PATH;		// table path var
char *  directory;		// 1st readable unix dir
{
 char * ptr;
 char * next;
 char table_path[PATH_MAX];
 int 	row;
 DIR		*	 dirp;	// pointer to unix dir 
 struct dirent	*	 dp;	// directory entry info

/*.expand_path*/
 row = 0;
 if ( TABLE_PATH != NULL ) {
   ptr  = next = table_path;
   strcpy( table_path, TABLE_PATH );
   do { 
     dirp	=	opendir( next );
     if ( dirp == NULL ) { 
       /*"couldn't open dir %s\n", next */
       if ( next != (char *)table_path )
	ptr = NULL; 
     }
     else if ( ( dp = readdir( dirp ) ) != NULL ) {
       /*" found dir %s\n", next */
       closedir( dp );
       if ( !row ) strcpy( directory, next );
       FIfld_set_list_default_text( test_form_ptr,
					DIR_NAME,
					row, 0, next,
					FALSE );
        row=row+1;
	ptr = NULL;
       } //else dir
   }    while( (next = strtok( ptr, ":" ) ) !=NULL ); // while 
  /*"found %d dirs\n", row */
 }  // if path
 else {
  /*| no path defined */
  strcpy( directory, "." );
 } 

} // expand fn
