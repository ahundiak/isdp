/* $Id: pardel.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / pardel.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: pardel.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.2  1996/08/07  16:33:54  pinnacle
# TR179601878 Assoc Partial Delete
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 *      08/08/96        AH              TR179601878 Assoc Partial Delete
 *                                      pardel replaced with pardel1
 *                                      to support closed curves
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   

#include <stdio.h>

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "EMSmsgdef.h"
#include "AS_status.h"

#define	MAX_SEG		10
#define EPS 1.e-6

IGRlong			EMS_ret;
IGRshort		mat_type;
IGRdouble		matrix[16];
IGRboolean      	want_status;
IGRchar 		*temp_names[3], *feet_names[2], str[40], tmp[40];

IGRint			stat, msg, i, j, num_surfaces;
GRobj 			ci_mac_def1, list[1], COMP, SURF;

IGRdouble               org[3], out_in[20], pnt[6], scaling_factor;

IGRint			chan_index;

OM_S_CHANSELECT		notify_chan, to_object;

IGRdouble		density;

struct GRid		CUV, GCV, CI_MACRO_ID, GRid_list[2], MPROP;
struct	GRid		par_list[3];

struct GRmd_env		MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;

struct IGRpolyline      geom;


extern		BScveval(), BSmdstptcv(), ASextract_cv();



extern int 		init_cnst_list(),
			sprintf(),
			printf(),
			ASsuper_construct();

extern IGRboolean ASbroadcast_in_progress;

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  temp_names[0]  = "curve";  
  temp_names[1]  = "pt1";  
  temp_names[2]  = "pt2";  
  feet_names[0]  = "cv1";
  feet_names[1]  = "cv2";

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef =  ci_mac_def1,
		status 	 = &stat, 	name = "pardel",
              	temp_num = 3, 		temp_names = temp_names,
	      	extern_feet_num = 2, 	extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{
IGRint		nb_comp;


  construct_comp( &nb_comp, GRid_list );

  if( nb_comp == 0 )	return	0;

  if( (GRid_list[0].objid == NULL_OBJID) &&
      (GRid_list[1].objid == NULL_OBJID)    ) return(0); 

   ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, nb_comp, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );


  return(1);
}

/* ========================================================================= */

place ()
{
IGRlong		msg, sts;
struct	GRid	my_as_sup;
IGRint		nb_comp;

  construct_comp( &nb_comp, GRid_list );


  if( nb_comp == 0 )	return	0;

  if( (GRid_list[0].objid == NULL_OBJID) &&
      (GRid_list[1].objid == NULL_OBJID)    ) return(0); 

	/*| get support */
	sts = ci$send(	msg	 = message ACcpx.ACfind_exp_temp_obj
					( &msg, 0, &my_as_sup ),
			targetid = CI_MACRO_ID.objid,
			targetos = CI_MACRO_ID.osnum );
	as$status( sts = sts );

	/*| consume support */
	consume_and_display( my_as_sup, 1, 0, &MOD_ENV );

  ci$send( msg = message  ci_macro.set_all_extern_feet
	 ( &stat, nb_comp, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}

/* ========================================================================= */
NDdelete(md_env)

struct GRmd_env *md_env;

{

struct GRid	my_as_sup;
	

	   if( md_env->md_id.objid == -1 ) goto wrapup ;

           ci$send( msg = message  ACcpx.ACfind_exp_temp_obj
					(&stat,0,&my_as_sup),
                    targetid = CI_MACRO_ID.objid,
	            targetos = CI_MACRO_ID.osnum );
	   if(!stat) goto wrapup;

	   consume_and_display( my_as_sup, 0, 1, md_env );

wrapup:
        ci$send( msg      = message ov_ci_mac.NDdelete(md_env),
	         targetid = CI_MACRO_ID.objid,
	         targetos = CI_MACRO_ID.osnum,
                 mode     = WRT_message );
 return(1);
}


/* ========================================================================= */

construct_comp( num_seg, seg_list )

IGRint		*num_seg;
struct	GRid	*seg_list;

{

struct	GRid	sup_go;
IGRlong		sts;
struct	GRmd_env	sup_env;
struct	GRid		bsp_to_del;

      seg_list[0].objid = NULL_OBJID;
      seg_list[0].osnum = MOD_ENV.md_id.osnum;
      seg_list[1].objid = NULL_OBJID;
      seg_list[1].osnum = MOD_ENV.md_id.osnum;

      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj
					(&stat,0,&par_list[0]),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj
					(&stat,1,&par_list[1]),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );
      ci$send( msg     = message  ACcpx.ACfind_exp_temp_obj
					(&stat,2,&par_list[2]),
 	      targetid = CI_MACRO_ID.objid,
	      targetos = CI_MACRO_ID.osnum );


 	sts = ci$send(msg = message NDnode.ASreturn_go(&sup_go,
						   &sup_env.md_env.matrix_type,
						    sup_env.md_env.matrix),
		  targetid = par_list[0].objid,
		  targetos = par_list[0].osnum);
	as$status( sts = sts, action = RET_STATUS );
	/*" sup_go : id/os = (%d/%d)\n", sup_go.objid, sup_go.osnum */

	/*| copy du graphic */
	sts = ci$send(msg          = message GRgraphics.GRcopy(&msg,
                	                  &sup_env,&MOD_ENV,
                        	          &(bsp_to_del.objid)),
		   targetid = sup_go.objid,
		   targetos = sup_go.osnum);
	as$status( sts = sts );
	bsp_to_del.osnum	= MOD_ENV.md_id.osnum;

	LLbs_part_del( bsp_to_del, par_list, &MOD_ENV, seg_list, num_seg );
/*^
	printf(" nb_seg : %d\n", *num_seg );
	printf(" GRid : %d, %d \n", seg_list[0].objid, seg_list[1].objid );
*/
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                          FCT LLbs_part_del                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


LLbs_part_del( bsp_to_split, parents, md_env, segment, nseg )
struct	GRid	bsp_to_split;
struct	GRid	*parents;
struct	GRmd_env	*md_env;
struct	GRid		*segment;
IGRint			*nseg;
{
  IGRint    in_parents;          /* Index of the current parent of the modif  */
  IGRint    index0;              /* Index for a loop                          */
  IGRint    index1;              /* Index for a loop                          */
  IGRlong   status,msg,actmsg; 
  struct ret_struct  pointdef[2];/* Definition of the 2 points for the par. d.*/
  struct    GRprops   props;     /* Properties of the support                 */
  IGRchar *bc;
  IGRlong size_geom;
  IGRlong rc,rc1;

IGRdouble	par[2], start_u, end_u;
IGRdouble	 start_array[MAX_SEG], end_array[MAX_SEG];

IGRdouble	start_save[MAX_SEG], end_save[MAX_SEG];

IGRdouble	start_pt[MAX_SEG*3], end_pt[MAX_SEG*3];
IGRdouble *start_delete,*end_delete;

  enum delseg_state { BEFORE,DURING,AFTER};
  enum delseg_state  actual_state;
  IGRint i,iseg;
  struct GRid my_grid,tmp_to_split,active_owner;
  IGRboolean old_broad;
  struct GRparms split_parm;
  IGRpoint split_point;
  OM_S_OBJID bspline1,bspline2;
  int nb_obj;
  double dist;


  /*| Ask if the curve is closed */
  /* In this case the curve is splited at begin point of first
     partial delete */

 status = ci$send (msg  = message GRvg.GRgeomprops(&msg,
                                  &(md_env->md_env.matrix_type),
                                  md_env->md_env.matrix,
                                  &props),
              targetos = bsp_to_split.osnum,
              targetid = bsp_to_split.objid);
  as$status(action = RET_STATUS);

  status = ci$send(msg = message GRvg.GRgetsize(&msg,
                                  &md_env->md_env.matrix_type,
                                   md_env->md_env.matrix,
                                   &size_geom),
              targetos = bsp_to_split.osnum,
              targetid = bsp_to_split.objid);
  as$status(action = RET_STATUS);

  bc =  om$malloc(size = size_geom);

  status = ci$send(msg = message GRvg.GRgetgeom(&msg,
                                  &(md_env->md_env.matrix_type),
                                  md_env->md_env.matrix,
                                  bc),
              targetos = bsp_to_split.osnum,
              targetid = bsp_to_split.objid);
  as$status(action = RET_STATUS);


  /*
     Compute all the curvilinear abscissa
     and sort the partial delete
  */

  in_parents = 1;
  *nseg = 1;
  start_array[0] = 0; 
  end_array[0] = 1;
  if(props.closed) end_array[0] = 0.9999;

      /*| Get the 2 points of the deleted area */
      /* and project them on the B_spline */

      for(index1=0;index1<2;index1=index1+1){
	
         status=ci$send(msg = message NDnode.NDgive_structure(&msg,
						&pointdef[index1], md_env),
                        targetos = parents[index1+in_parents].osnum,
                        targetid = parents[index1+in_parents].objid);
         as$status(action = GOTO_VALUE, value = wrapup );

         msg = BSmdstptcv(bc,pointdef[index1].var.point_st.pt,&par[index1],
			  split_point,&dist,&rc1);
      }

  if (par[0] < par[1])
     {
      start_u = par[0];
      end_u = par[1];
     }
  else
     {
      start_u = par[1];
      end_u = par[0];
     }



/*" insert %lf %lf in partial delete\n",start_u,end_u */

actual_state = BEFORE;

/*| save first the previous limits */

for(iseg=0 ; iseg<*nseg ; iseg=iseg+1)
  {
   start_save[iseg] = start_array[iseg];
   end_save[iseg] = end_array[iseg];
   /*" %lf %lf\n",start_save[iseg],end_save[iseg] */
  }

/* Add the new deleted area */
i = 0;
for(iseg=0 ; iseg<*nseg ; iseg=iseg+1)
  {
   if(i >= 2*MAX_SEG)
     {
      /*"to many segments, bool_seg interupted\n"*/
      break;
     }

	/*"on %lf %lf state was %d\n",actual_state,start_save[iseg],end_save[iseg] */

    switch (actual_state)
     {
      case BEFORE :				/*| BEFORE */
	    if(end_save[iseg] + EPS < start_u)
               {				/*| --> BEFORE */
		i=i+1;
		break;
	       }

	    else
	       {				/*|BEFORE --> DURING */
		actual_state = DURING;
		if(start_array[iseg] + EPS < start_u)
                  {			        /*|STORE end_array start_u */
		   end_array[i] = start_u;
			i=i+1;
                  }
                }
	  
      case DURING :				/*| DURING */
		if(end_save[iseg] - EPS < end_u)
		  { /*| DURING --> DURING */
		    break;
		  }
		else
		  {				/*|DURING --> AFTER */
		   actual_state = AFTER;
		   if(start_save[iseg] + EPS < end_u)
		     {				/*|STORE end_u end_save */
		      start_array[i] = end_u;
		      end_array[i] = end_save[iseg];
			i=i+1;
		      break;
		     }
                  }

      case AFTER  :				/*| AFTER */
		  start_array[i] = start_save[iseg];
		  end_array[i] = end_save[iseg];
		  i=i+1;
	    break;

     }  /* end switch */
    }     /* end for    */

    *nseg = i;
    /*" nseg = %d\n", *nseg */

  /*" evaluate begin and end of points of %d segments\n",*nseg */

  for(iseg = 0;iseg <*nseg;iseg=iseg+1)
     {
      /*" start %lf end %lf\n",start_array[iseg],end_array[iseg] */
      BScveval(bc,start_array[iseg],0,&start_pt[iseg*3],&rc);
      BScveval(bc,end_array[iseg],0,&end_pt[iseg*3],&rc);
     }

  /*| Compute the segments to split */

  old_broad = ASbroadcast_in_progress;
  ASbroadcast_in_progress = TRUE;
/*
  gr$get_active_owner ( msg=&actmsg,active_owner=&active_owner);
  if(actmsg == MSSUCC) gr$clear_active_owner(msg= &actmsg);
*/
  for(iseg = 0;iseg < *nseg; iseg=iseg+1)
    {
     if(iseg != *nseg-1) 
       {
  	status = ci$send(msg          = message GRgraphics.GRcopy(&msg,
                                  		md_env,md_env,
                                  		&(tmp_to_split.objid)),
                   	targetid = bsp_to_split.objid,
                   	targetos = bsp_to_split.osnum);
  	tmp_to_split.osnum=md_env->md_id.osnum;
	if(!(status&1)) break;
       }
     else
       {
	 tmp_to_split = bsp_to_split;
       }

     status = ASextract_cv(tmp_to_split,&start_pt[iseg*3],&end_pt[iseg*3],
			   md_env,&segment[iseg]);
     /*"segment %d %d\n",segment[iseg].objid,segment[iseg].osnum */
    }

  ASbroadcast_in_progress = old_broad;
/*
  if(actmsg == MSSUCC)
                    gr$put_active_owner(msg=&actmsg,active_owner=&active_owner);
*/

  wrapup :
  if(bc!= NULL) om$dealloc(ptr = bc);
  return(OM_S_SUCCESS);
}/* end method ASbs_part_del */

/* ***************** FCT consume_and_display () ***********************	*/

consume_and_display( as_sup, c_mod, d_mod, md_env )

struct	GRid		as_sup;
IGRshort		c_mod;
IGRshort		d_mod;
struct	GRmd_env	*md_env;

{
IGRlong			sts, msg;
struct	GRid		go_sup;
struct	GRmd_env	sup_env;
enum	GRdpmode	pen;


	sts = ci$send(	msg	 = message NDnode.ASreturn_go(
					&go_sup,
					&sup_env.md_env.matrix_type,
					sup_env.md_env.matrix ),
			targetid = as_sup.objid,
			targetos = as_sup.osnum );
	as$status( sts = sts );

	if( c_mod ){

		if( d_mod )	pen = GRbd;
		else		pen	= GRbehe;

		sts = ci$send(	msg	 = message GRgraphics.GRdisplay(
						&msg,
						&sup_env.md_env.matrix_type,
						sup_env.md_env.matrix,
						&pen,
						&md_env->md_id ),
				targetid = go_sup.objid,
				targetos = go_sup.osnum );
		as$status( sts = sts );

		sts = ci$send( msg	 = message NDmacro.ACconsume( 
						&msg,
						"",
						0,
						0,
						md_env ),
				targetid = as_sup.objid,
				targetos = as_sup.osnum );
		as$status( sts = sts );

	} else {

		sts = ci$send(	msg	 = message NDnodein.ACunconsume
						( &msg, "" ),
				targetid = as_sup.objid,
				targetos = as_sup.osnum );
		as$status( sts = sts );

		if( d_mod )	pen = GRbd;
		else		pen	= GRbehe;
	
		sts = ci$send(	msg	 = message GRgraphics.GRdisplay(
						&msg,
						&sup_env.md_env.matrix_type,
						sup_env.md_env.matrix,
						&pen,
						&md_env->md_id ),
				targetid = go_sup.objid,
				targetos = go_sup.osnum );
		as$status( sts = sts );
	  }

return	1;
}

