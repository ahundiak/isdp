/* $Id: collision.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / collision.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: collision.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1996/01/29  22:09:32  pinnacle
# Replaced: ./cimacros/wireframe/macros/collision.u for:  by azuurhou for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
	 92/07/22	Get rid of internal data (not used)
	 92/08/10	Change templates names
 */
   
/*
	File name :	collision.u
	Product :	I/VDS - PPMmacro library

	Description :	<Assoc> Detect Collision

								- 92/05/12 -
		This command echoes a bip whenever there is a collision 
		between object1 and object2, and constructs a point at the
		center of the collision.
		If there is no collision, a point is constructed
		between the range boxes of both objects.
 */

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "AS_status.h"
#include "grmacros.h"
#include "emssfintdef.h"

#define MAX_FEET		100
#define MAX_CHA_FEET		7
#define MAX_CHA_ROOT		4

IGRchar 		*temp_names[2], *feet_names[MAX_FEET];
IGRint			temp_types[2];

IGRchar 	 	buff[MAX_FEET*MAX_CHA_FEET];
GRobj 			ci_mac_def1 ;
struct GRid		CI_MACRO_ID ;

struct GRsymbology 	symb;
IGRshort     	        props,set,set_props;

IGRshort		mat_type;

IGRint			stat, msg, i, num_inter, feet_index[MAX_FEET];

IGRdouble 	        matrix[16];


struct GRid		SUR ,GRid_list[MAX_FEET];
struct GRid		*GRint;
struct GRlc_info        obj1,obj2;
struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct IGRpolyline      geom;


extern char	*malloc() ;
extern		printf(), sprintf() ;
extern int 	EMintersect_two_element() ;
extern int 	init_cnst_list(), free()  ;
extern		ASsuper_construct() ;


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */


main ()
{

  temp_names[0] = "element1";  
  temp_names[1] = "element2";

  temp_types[0] = ~0;
  temp_types[1] = ~1;

  set_feet_name();

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          = ci_mac_def1,
		status 	          = &stat, 	
		name              = "collision",
              	temp_num          = 2, 		
		temp_names        = temp_names,
		temp_types        = temp_types,
	      	extern_feet_num   = 1, 	
		extern_feet_names = feet_names );


}

/* ========================================================================= */

compute ()
{

  intersect();
  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  stat = ci$send( msg = message  ci_macro.set_all_extern_feet
					(&msg, 1 , GRid_list, &MOD_ENV),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;

  return(1);
}

/* ========================================================================= */

place ()
{

  intersect();
  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  stat = ci$send( msg = message  ci_macro.set_all_extern_feet
					(&msg, 1, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;

  return(1);
}


/* ========================================================================= */


intersect()
{
unsigned IGRshort trim_opt ;
IGRpoint	  aux_point ; /* Point to construct macro occurrence */

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;

  if( dis.weight < 3)   dis.weight = 3; 

  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE ;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.class_attr	= 0;
  cst.name		= 0;


  GRid_list[0].objid = NULL_OBJID;

  /*
	Get first parent
   */

  stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&msg, 0, &SUR),
                 targetid = CI_MACRO_ID.objid,
                 targetos = CI_MACRO_ID.osnum );
  if( !(msg&stat&1) ) return 0 ;

  msg = MSSUCC ;
  stat = ci$send(msg = message NDnode.ASreturn_go(&obj1.located_obj,
                                       &obj1.module_info.md_env.matrix_type,
                                       obj1.module_info.md_env.matrix),
                  targetid = SUR.objid,
                  targetos = SUR.osnum);
  if( !(msg&stat&1) ) return 0 ;

/***
  stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
				&msg,
				"",
				&obj1.located_obj, 
				&obj1.module_info.md_env.matrix_type, 
				obj1.module_info.md_env.matrix ),
	   targetid = SUR.objid,
	   targetos = SUR.osnum );
  if( !(msg&stat&1) ) return 0 ;
 **/

  obj1.module_info.md_id.osnum = obj1.located_obj.osnum;

  /*
	Get second parent
   */

  stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&msg, 1, &SUR),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum );
  if(!(msg&stat&1) ) return 0 ;

  msg = MSSUCC ;
  stat = ci$send(msg = message NDnode.ASreturn_go(&obj2.located_obj,
                                       &obj2.module_info.md_env.matrix_type,
                                       obj2.module_info.md_env.matrix),
                  targetid = SUR.objid,
                  targetos = SUR.osnum);
  if( !(msg&stat&1) ) return 0 ;

/***
  stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
				&msg,
				"",
				&obj2.located_obj, 
				&obj2.module_info.md_env.matrix_type, 
				obj2.module_info.md_env.matrix ),
	   targetid = SUR.objid,
	   targetos = SUR.osnum );
  if( !(msg&stat&1) ) return 0 ;
 **/

  obj2.module_info.md_id.osnum = obj2.located_obj.osnum;

  /*
	Compute intersection
   */

  trim_opt = EMSINT_TRIM_HANDLESTOP | 
                         	   EMSINT_TRIM_OUTPUT | 
				   EMSINT_TRIM_BDRYISAREA |
                          	   EMSINT_TRIM_COPLANAR | 
				   EMSINT_TRIM_PROCOVERLAP ;

  num_inter = 0 ;
  EMintersect_two_element(&obj1,&obj2,trim_opt,&cst,&num_inter,&GRint,&msg) ;
  if (!(msg & 1))	return 0 ; /* error */

  #ifdef DEBUG
  printf("num_inter is %d \n", num_inter) ;
  #endif

  if (num_inter == 0) {

	#ifdef DEBUG
	printf("No collision \n") ;
	#endif

	stat = get_medium_point(&obj1, &obj2, aux_point) ;
	if (!(stat & 1)) { clean_inter() ; return 0 ; }
	}

  else {

	#ifdef DEBUG
	printf("Collision ! \n") ;
	#endif

	/* Beep terminal to flag intersections */
  	write("") ;

	/* Occurrence is a displayable point at the center of the collision */
	stat = get_collision_point(&MOD_ENV, GRint, num_inter, aux_point) ;
	if (!(stat & 1)) { clean_inter() ; num_inter = 0 ; return 0 ; }
	}

  /*
	Construct collision macro occurrence
   */
  
  clean_inter() ;

  geom.num_points = 1 ;
  geom.points     = &aux_point[0] ;
  cst.geometry    = (IGRchar *)&geom ;

  GRid_list[0].objid = NULL_OBJID;
  GRid_list[0].osnum = MOD_ENV.md_id.osnum;

  stat = ci$send( msg       = message GR3dpoint.GRaltconstruct(&cst),
           targetid  = GRid_list[0].objid,
 	   targetos  = GRid_list[0].osnum) ; as$status(sts = stat) ;

  msg = *cst.msg ;
  if (!(stat & msg & 1)) 
	{ num_inter = 0 ; return 0 ; }
  else 
	{ num_inter = 1 ; return 1 ; } /* success */
} /* intersect() */


/* ======================================================================= */


clean_inter()
/*
	Description :
		Free memory and delete intermediate objects generated
		by the EMintersect_two_element() call.
 */
{
IGRint i ;

#ifdef DEBUG
printf("	---> Call to clean_inter() \n") ;
#endif

for (i=0 ; i<num_inter ; i=i+1) {
	stat = ci$send(msg = message GRgraphics.GRdelete(&msg,&MOD_ENV),
             		targetid = GRint[i].objid , 
			targetos = GRint[i].osnum) ;
	as$status(sts = stat) ;
	}
free(GRint) ;
return 1 ;
} /* clean_inter() */


/* ======================================================================= */


set_feet_name()
{
   for (i=0; i<MAX_FEET; i=i+1)
   {
	sprintf(&buff[i*MAX_CHA_FEET],"resi%d",i);
	feet_names[i] = &buff[i*MAX_CHA_FEET];
   }
} /* set_feet_name() */


/* ======================================================================== */


get_medium_point(obj1_ptr, obj2_ptr, aux_point)
	struct GRlc_info *obj1_ptr, *obj2_ptr ;	/* I */
	IGRpoint	 aux_point   ; /* O */
/*
	Description :					92/05/12
		Constructs a medium point between the two range boxes
		of obj1_ptr and obj2_ptr.  This function should be called if 
		there is no collision.
		A return code of 1 is for success.
 */
{
GRrange		range1, range2 ;
IGRboolean 	world ;
IGRlong		stat, msg ;

	#ifdef DEBUG
	printf("	---> Call to get_medium_point() \n") ;
	#endif

world = 1 ; /* in world coordinates */

stat = ci$send(msg = message GRvg.GRgetrang(&msg,
				&obj1_ptr->module_info.md_env.matrix_type,
				obj1_ptr->module_info.md_env.matrix,
				&world,
				range1),
		targetid = obj1_ptr->located_obj.objid,
	 	targetos = obj1_ptr->located_obj.osnum) ; as$status(sts = stat) ;
if (!(stat & msg & 1)) return 0 ;

stat = ci$send(msg = message GRvg.GRgetrang(&msg,
				&obj2_ptr->module_info.md_env.matrix_type,
				obj2_ptr->module_info.md_env.matrix,
				&world,
				range2),
		targetid = obj2_ptr->located_obj.objid,
	 	targetos = obj2_ptr->located_obj.osnum) ; as$status(sts = stat) ;
if (!(stat & msg & 1)) return 0 ;

for (i = 0 ; i < 3 ; i = i+1) {
	aux_point[i] = 
   0.5 * (0.5 * (range1[i] + range1[i+3]) + 0.5 * (range2[i] + range2[i+3])) ;
	}

return 1 ; /* success */
} /* get_medium_point() */


/* ======================================================================== */


get_collision_point(mod_env_ptr, GRint_list, list_num, aux_point)
	struct GRmd_env *mod_env_ptr ;	/* I */	
	struct GRid	*GRint_list ;	/* I : list of intersection objects */
	IGRint		list_num    ;   /* I */
	IGRpoint	aux_point   ; 	/* O */
/*
	Description :					92/05/12
		Constructs a point at the center of the collision between the 
		two objects.  This function should be called if there is a 
		collision.
		A return code of 1 is for success.
 */
{
OMuword			object_class ;
IGRint			i, j, num_comp, count ;
struct GRid		*tmp_list    ;
IGRboolean		world ;
GRrange			range ;
IGRchar			class_name[256] ;
IGRlong			stat, msg    ;
extern GRclassid	OPP_GRgrgrp_class_id    ;

   #ifdef DEBUG
   printf("	---> Call to get_collision_point() \n") ;
   printf("	list_num is %d \n", list_num) ;
   om$get_classname(	osnum = GRint_list[0].osnum,
		 	objid = GRint_list[0].objid,
		 	classname = class_name) ;
   printf("	GRint_list[0] is %d / %d \n", 	GRint_list[0].objid,
						GRint_list[0].osnum) ;
   printf("	class name    is %s \n", class_name) ;
   #endif

if (list_num <= 0) return 0 ;

tmp_list = NULL  ;
aux_point[0] = 0 ; aux_point[1] = 0 ; aux_point[2] = 0 ;

om$get_classid( objid	   = GRint_list[0].objid,
		osnum	   = GRint_list[0].osnum,
	 	p_classid  = &object_class) ;

/*
	Test if we have a graphic group
 */

if( om$is_ancestry_valid( superclassid = OPP_GRgrgrp_class_id,
			  subclassid   = object_class) == OM_S_SUCCESS ) {

	#ifdef DEBUG
	printf("We have a graphic group \n") ;
	#endif

     	stat = ci$send( msg = message GRowner.GRget_number_components( 
 				&msg,
			       	&num_comp),
	  	 	targetid = GRint_list[0].objid,
	  	 	targetos = GRint_list[0].osnum ) ; 
	as$status(sts = stat) ; if (! (stat & msg & 1)) return 0 ;
	if (num_comp == 0) return 0 ;

	tmp_list = (struct GRid *) malloc(num_comp * sizeof(struct GRid)) ;
	if (tmp_list == NULL) return 0 ;

	stat = ci$send( msg = message GRowner.GRget_components( 
				&msg,
				mod_env_ptr,
				tmp_list,
				num_comp, /* max number of comps to be read */
				&count,
			     	(IGRint) 0,
				(IGRint) OM_K_MAXINT ),
	  	 	targetid = GRint_list[0].objid,
	  	 	targetos = GRint_list[0].osnum );
	as$status(sts = stat) ; 
	if (! (stat & msg & 1)) {free(tmp_list) ; return 0 ;}

	} /* if graphic group */

else {

	#ifdef DEBUG
	printf("No graphic group \n") ;
	#endif

	tmp_list = (struct GRid *) malloc(list_num * sizeof(struct GRid)) ;
	if (tmp_list == NULL) return 0 ;

	for (j=0 ; j<list_num ; j=j+1) tmp_list[j] = GRint_list[j] ;
	count = list_num ;
	} /* else */

/*
	Compute collision points
 */

#ifdef DEBUG
printf("%d components have been stored \n", count) ;
#endif

world = 1 ;
for (i = 0 ; i < count ; i = i+1) {

	stat = ci$send(msg = message GRvg.GRgetrang(&msg,
				&mod_env_ptr->md_env.matrix_type,
				mod_env_ptr->md_env.matrix,
				&world,
				range),
		targetid = tmp_list[i].objid,
	 	targetos = tmp_list[i].osnum) ; as$status(sts = stat) ;
	if (!(stat & msg & 1)) {
		if (tmp_list != NULL) free(tmp_list) ;
		return 0 ;
		}

	for (j = 0 ; j < 3 ; j = j+1) {
		aux_point[j] = aux_point[j] + 0.5 * (range[j] + range[3+j]) ;
		}

	} /* for count */

for (j = 0 ; j < 3 ; j = j+1) {
	aux_point[j] = aux_point[j] / count ;
	}

if (tmp_list != NULL) free(tmp_list) ;
return 1 ; /* success */
} /* get_collision_point() */


/* ======================================================================== */

