/* $Id: cpyalong.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / cpyalong.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: cpyalong.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/01/15  15:57:38  pinnacle
# AS_status
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *  MM/DD/YY  AUTHOR  DESCRIPTION
 *  01/15/98  ah      Move AS_status.h down so it compiles on Solaris
 *
 * -------------------------------------------------------------------*/

/*
	 VDS 2.0 - PPM macro library - 92/07/09 (alc)
 */
   
/*
   History :
   -------
	92/02/10	Use ex$get_modid() just after NDmacro.ACreturn_foot()
			(also : Macro occurrences in reference files )
	92/07/30	Get rid of NDcopy_to_root() (no longer needed in 2.0) 
 */

#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bserr.h"
#include "exmacros.h"
#include "AS_status.h"

extern  int	printf()			;
extern 		ASsuper_construct()		;
extern 		EX_get_modid_given_osnum() 	;

#define  EPSILON       1.E-13
#define  MACRO_NAME    "cpyalong"   /* Name of the macro                      */
#define  NB_TEMPLATE   4            /* Number of template of the macro        */
#define  NB_FEET       100          /* Number of feet of the macro            */
#define  MAX_CHA_FEET  7

/* Definition of the names of the objects of the macro                        */

#define  NCOPY      "n_copy"       /* scale factor                            */
#define  ST_CD_SYS  "st_coord_sys" /* Start Coordinate system                 */
#define  SPINE      "neutral_curve"/* neutral curve                           */
#define  OBJ_TO_CPY "obj_to_copy"  /* Object to copy                          */

  char buff[NB_FEET*MAX_CHA_FEET];/* intermiate buffer			      */
  char *template_name[NB_TEMPLATE];/* Names of the templates of the macro     */
  char *feet_name[NB_FEET];        /* Names of the feet of the macro          */
  int  temp_types[NB_TEMPLATE];    /* define the type of template	      */
  struct GRid temp_obj[NB_TEMPLATE];/* Template objects of the macro          */
  GRobj  macro_def_id;             /* Identifier of the macro definition      */
  GRobj  dummy;			   /* just a variable			      */
  struct GRid	GRid_list[NB_FEET];/* the grid feet of the macros	      */


  extern int	sprintf();

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                           cons_cpy along curve                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*int    status;                      Returned status of messages             */
  long    msg;                      /* Returned status of messages             */
  double length;                   /* Length of the hole                      */
  double diameter;                 /* Diameter of the hole                    */
  double tpars[NB_FEET];	   /* params along the curve		      */
  double tstart;		   /* start param to place the first copy     */
  double tend;			   /* end param to place the last copy        */
  struct IGRdisplay display;       /* Attributes for the display              */
  struct GRvg_construct const;     /* Attributes for the construction         */
  struct GRid      CI_MACRO_ID;    /* Objid of the occurence of the macro     */
  struct GRid      referential;    /* Objid of the coordinate system          */
  struct GRid      original_obj;   /* Original object                         */
  struct GRid      miror_obj;      /* Object obtained by miror                */
  struct GRmd_env  MOD_ENV;        /* Environment for construction            */
  struct GRmd_env  from_env;       /* Environment for construction            */
  double           tmp_matrix[16]; /* Tempory matrix                          */
  double           trans_matrix[16];/* Tempory matrix                         */
  double	   dncopy;          /* ncopy factor                           */
  int		   ncopy;
  short            mat_type;       /* Matrix type of the graphic object       */
  short            four;           /* Dimension of the matrix                 */
  struct GRid      newobjid;       /* Objid of the referential                */
  struct GRid      CUV;            /* Objid of                                */
  struct GRid      OFOOT;	   /* just variable		   	      */
  struct IGRbsp_curve *cv;         /* abstract geometry of the spine	      */
  int 		   i, j, jj, nfeet;
  long		   size, rc;
  OMuword	   ass_cl, ft_cl ;
  
  struct ret_struct	st_ref;    /* ref which define the original position  */
  struct ret_struct	expr;      /* give the number of copy                 */

  double		zref[3];   /* z axis reference to verify if the       */
                                   /* current z axis swap his direction       */
  double		xcou[3];   /* the current x dir                       */
  double		zcou[3];   /* the current z direction                 */
  double		eval[12];  /* current point 1 and 2 derivate          */
  double		loc_mat[16];/* local cs on the curve                  */
  double		totlen;    /* total length of the curve		      */
  double		lencou;    /* current length from 0.0                 */



  extern int    	MAidmx();
  extern int 		MAinvmx();
  extern int 		MAmulmx();
  extern int 		MAtypemx();
  extern char 		*malloc();
  extern int 		free();
  extern int    	BScveval();
  extern int    	BScrossp();
  extern int    	BSnorvec();
  extern double 	BSdotp();
  extern IGRboolean 	BSarclength();
  extern int		BSiarcln();
 
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               main function                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

  int    stat;                   /* Returned status of the definition       */

main()
  {
  /*
  Description : Create the definition of the macro
  Constraint  : none
  */ 

  /* Declare the template names */

  int i, j;

  template_name[0] = NCOPY;
  template_name[1] = ST_CD_SYS;
  template_name[2] = SPINE;
  template_name[3] = OBJ_TO_CPY;

  temp_types[0] = parameter_generic | double_type;
  temp_types[1] = ref_generic;
  temp_types[2] = ~0;
  temp_types[3] = ~0;

  /* Declare the feet names */

   for (i=0; i<NB_FEET; i=i+1) {
	j = i * MAX_CHA_FEET;
	sprintf(&buff[j],"copy%d",i);
	feet_name[i] = &buff[j];
   }

  /* Construct the macro definition */

  macro_def_id = NULL_OBJID;

  ac$cimacdef(  cimacdef          = macro_def_id,
		status            = &stat,
		name              = MACRO_NAME,
		temp_num          = NB_TEMPLATE,
		temp_names        = template_name,
		temp_types	  = temp_types,
		extern_feet_num   = NB_FEET,
		extern_feet_names = feet_name  );

}/* end main */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               place function                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

place()

  /*
  Description : Place an occurence of the macro definition
  Constraint  : none
  */ 
  {
  /* Construct the miror object */

  cpy_obj_along();

  /* Connect the feet of the occurence */

  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  ci$send
    (msg      = message ci_macro.set_all_extern_feet
                        (&stat,nfeet,GRid_list,&MOD_ENV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  return(1);
}/* end place */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                               compute function                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

compute()

  /*
  Description : recompute an occurence of the macro definition
  Constraint  : none
  */ 
  {
  /* Construct the miror object */

  cpy_obj_along();

  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  /* Change the feet of the occurence */

  ci$send
    (msg      = message ci_macro.set_all_extern_feet
                        (&stat,nfeet,GRid_list,&MOD_ENV),
     targetid = CI_MACRO_ID.objid,
     targetos = CI_MACRO_ID.osnum);

  return(1);

}/* end compute */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

cpy_obj_along(){

  GRid_list[0].objid = NULL_OBJID;  
  miror_obj.objid = NULL_OBJID;  
  miror_obj.osnum = MOD_ENV.md_id.osnum;
  four = 4;
  cv = NULL;

  /*---------------------------------------*/
  /* Get the expression for number of copy */
  /*---------------------------------------*/

   stat = ci$send( msg = message ACcpx.ACfind_exp_temp_struct(&msg, 0,
						 (char *) &expr,&MOD_ENV),
	    	targetid = CI_MACRO_ID.objid, 
		targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;
   if( !(msg&stat&1) ) return OM_E_ABORT ;
   ncopy = fabs(expr.var.root_pm_st.value);
   if( ncopy > NB_FEET ) ncopy = NB_FEET;
   #ifdef DEBUG
	write("ncopy = ",ncopy,"\n");
   #endif

  /*------------------------------------------*/
  /* Get the matrix of the from referential   */
  /*------------------------------------------*/


  stat = ci$send(msg = message ACcpx.ACfind_exp_temp_struct(&msg,1,
                                                 (char *)&st_ref, &MOD_ENV ),  
     	targetid = CI_MACRO_ID.objid,
     	targetos = CI_MACRO_ID.osnum) ; as$status(sts = stat) ;
   if( !(msg&stat&1) ) return OM_E_ABORT ;

  /*------------------------------------------*/
  /* Get the spline curve                     */
  /*------------------------------------------*/

   stat = ci$send(msg      = message ACcpx.ACfind_exp_temp_obj(&msg,2,&CUV),
          targetid = CI_MACRO_ID.objid,
          targetos = CI_MACRO_ID.osnum) ; as$status(sts = stat) ;
   if( !(msg&stat&1) ) return OM_E_ABORT ;

   stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&msg,
						".",
						&original_obj, 
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix ),
	   targetid = CUV.objid,
	   targetos = CUV.osnum ) ; as$status(sts = stat) ;
   if( !(msg&stat&1) ) return OM_E_ABORT ;

   from_env.md_id.osnum = original_obj.osnum ;
   ex$get_modid(mod_osnum = from_env.md_id.osnum,
	        mod_id    = &from_env.md_id.objid) ;

   stat = ci$send( msg = message GRvg.GRgetsize( &msg,
			     		       &from_env.md_env.matrix_type,
			     		       from_env.md_env.matrix,
			     		       &size ),
	  	 targetid = original_obj.objid,
	  	 targetos = original_obj.osnum );
   as$status(sts = stat) ;
   if( !(msg&stat&1) ) return OM_E_ABORT ;

    cv = (struct IGRbsp_curve *) malloc(size);
    if (cv == NULL) {
		stat = 0 ; as$status(sts = stat) ;
		return OM_E_ABORT ;
		}

    stat = ci$send( msg = message GRvg.GRgetgeom( &msg,
			     		 &from_env.md_env.matrix_type,
			     		 from_env.md_env.matrix,
			     		 cv),
	  	 targetid = original_obj.objid,
	  	 targetos = original_obj.osnum ) ; as$status(sts = stat) ;
    if (!( stat & msg & 1)) { 
	if( cv != NULL ) { free(cv); cv = NULL;}
	return OM_E_ABORT ;
  	}

  /*-------------------------*/
  /* Get the object to copy  */
  /*-------------------------*/

  stat = ci$send(msg      = message ACcpx.ACfind_exp_temp_obj(&msg,3,&CUV),
          targetid = CI_MACRO_ID.objid,
          targetos = CI_MACRO_ID.osnum) ; as$status(sts = stat) ;
  if(!( stat & msg & 1)) { 
	if( cv != NULL ) { free(cv); cv = NULL;}
	return OM_E_ABORT ;
  	}

  stat = ci$send( msg      = message NDmacro.ACreturn_foot(	
						&msg,
						".",
						&original_obj, 
						&from_env.md_env.matrix_type, 
					        from_env.md_env.matrix ),
	   targetid = CUV.objid,
	   targetos = CUV.osnum ) ; as$status(sts = stat) ;
  if(!( stat & msg & 1)) { 
	if( cv != NULL ) { free(cv); cv = NULL;}
	return OM_E_ABORT ;
  	}

   from_env.md_id.osnum = original_obj.osnum ;
   ex$get_modid(mod_osnum = from_env.md_id.osnum,
	        mod_id    = &from_env.md_id.objid) ;

  /* --- evaluate the equaly space points --- */

  tstart = 0.0;
  tend   = 1.0;
  dncopy = ncopy;

  if( ncopy == 0 ) {
	if( cv != NULL ) { free(cv); cv = NULL;}
	return OM_E_ABORT ;
	}
  else if( ncopy == 1 ) tpars[0] = 0;
  else if( ncopy == 2 ) { tpars[0] = 0.0; tpars[1] = 1.0; }
  else{

  	/* --- evaluate the total length --- */
   
  	BSarclength(&rc,cv,&tstart,&tend,&totlen);
  	if( rc != BSSUCC ){ 
		#ifdef DEBUG
		write("error in BSarclength rc = ",rc,"\n");
		#endif
		if( cv != NULL ) { free(cv); cv = NULL;}
		return OM_E_ABORT ;
  	}

  	#ifdef DEBUG
		write(" BSarclength totlen = ",totlen,"\n");
	#endif

	if( cv->phy_closed == TRUE ) i = ncopy + 1;
	else			     i = ncopy;

  	dncopy = totlen / ( i - 1);
	tpars[0]   = 0.0;
	tpars[i-1] = 1.0;

  	for( j=1; j<(i-1); j=j+1 ){  
	
		lencou = j * dncopy;
		zref[0] = lencou;
	   
		BSiarcln(&rc,cv,&tstart,&zref[0],&tend,&tpars[j],lencou);
  		if( rc != BSSUCC ){ 
			#ifdef DEBUG
			write("error in BSiarcln rc = ",rc,"\n");
			#endif
			if( cv != NULL ) { free(cv); cv = NULL;}
			return OM_E_ABORT ;
  		}
 
        }
	#ifdef DEBUG
	 for( j=0; j<ncopy; j=j+1 )write("tpars[",j,"] = ",tpars[j],"\n");
	#endif

  }

  /* --- evaluate the zref vector --- */

 
  BScveval( cv, (tpars[0]),(int) 2, eval, &rc );
  BScrossp(&rc,&(eval[6]),&(eval[3]),zref);

  if( BSdotp(&rc,zref,zref) < EPSILON ){

   	eval[6] = -1.0*eval[4];
  	eval[7] = eval[3];
   	eval[8] = 0.0;

   	if( (fabs(eval[6]) < EPSILON ) && ( fabs(eval[7]) < EPSILON) ) 
							eval[6] = 1.0;
   	BScrossp(&rc,&eval[6],&eval[3],zref);

  }

   	BSnorvec(&rc,zref);

  #ifdef DEBUG
	 write(" zref = ", zref[0],zref[1],zref[2],"\n");
  #endif

  for( j=0; j<ncopy; j=j+1 ){  

  	/*-------------------------------------------------------------*/
  	/* compute the transformation matrix to map the graphic object */ 
  	/*-------------------------------------------------------------*/

	tstart = tpars[j];
        
  	BScveval( cv, tstart, (int)2, eval, &rc );
	#ifdef DEBUG
		write("tpars[",j,"] = ",tpars[j],"\n");
		write("point[",j,"] = ", eval[0],eval[1],eval[2],"\n");
		write("dv[",j,"] = ", eval[3],eval[4],eval[5],"\n");
		write("d2v[",j,"] = ", eval[6],eval[7],eval[8],"\n");
	#endif
  	BScrossp(&rc,&(eval[6]),&(eval[3]),zcou);
 
        /* --- check the second derivate exist --- */

  	if( fabs(BSdotp(&rc,zcou,zcou)) < EPSILON ){
		BScrossp(&rc,&(eval[3]),zref,&(eval[6]));
		BScrossp(&rc,&(eval[6]),&(eval[3]),zcou);
	}

	/* --- check if zcou and zref have the same direction --- */

	if( BSdotp(&rc,zcou,zref) < EPSILON ){
		for(i=0;i<3;i=i+1){
			eval[i+6] = -1.0*eval[i+6];
			zcou[i]   = -1.0*zcou[i];
		}
	}

	BScrossp(&rc,&(eval[3]),zcou,&(eval[6]));

	/* --- normalize the x y z vector */

	BSnorvec(&rc,&(eval[3]));
	BSnorvec(&rc,&(eval[6]));
	BSnorvec(&rc,zcou);

  	MAidmx(&msg,loc_mat);

        jj = 0;
    	for(i=0;i<3;i=i+1){
 
		loc_mat[jj]   = eval[6+i]; 
		loc_mat[jj+1] = eval[3+i];
		loc_mat[jj+2] = zcou[i]; 
		loc_mat[jj+3] = eval[i];
		zref[i]       = zcou[i];
		jj = jj + 4;
 
    	}

  	MAinvmx(&msg,&four,st_ref.var.ref_st.t,tmp_matrix);
  	MAmulmx(&msg,&four,&four,&four,loc_mat,tmp_matrix,trans_matrix);
  	MAtypemx(&msg,trans_matrix,&mat_type);


  	/*-----------------------------------------------*/
  	/*| first We copy the original object            */
  	/*-----------------------------------------------*/


  	stat = ci$send( msg	   = message GRgraphics.GRcopy(  
							 &msg,
							 &from_env,
                                             	         &MOD_ENV,
							 &GRid_list[j].objid ),
                  	targetid = original_obj.objid,
	          	targetos = original_obj.osnum ) ;
	as$status(sts = stat) ;
  	if( !( stat & msg & 1 ) ){
		#ifdef DEBUG
  		printf( "cpyalong.u -  GRgraphics.GRcopy error\n" ) ;
		#endif
		j = j-1 ;
		goto wrapup ;
		}

	GRid_list[j].osnum = MOD_ENV.md_id.osnum;

  	/*-----------------------------------------------*/
  	/*| We now can apply the xform to the object     */
  	/*-----------------------------------------------*/

  	dummy = NULL_OBJID ;
#ifdef DEBUG
  printf( " before GRxform  [%d,%d]\n", 
        GRid_list[j].osnum, GRid_list[j].objid ) ;
#endif

  	stat = ci$send(	msg	 = message GRgraphics.GRxform(  &msg,
								&MOD_ENV,
								&mat_type,
								trans_matrix,
								&dummy ),
			targetid = GRid_list[j].objid,
	        	targetos = GRid_list[j].osnum  );
	as$status(sts = stat) ;
  	if( !( stat & msg & 1 ) ){
		#ifdef DEBUG
  		printf( " GRgraphics.GRxform error\n" );
		#endif
		goto wrapup;
  		}

  	GRid_list[j].objid = dummy;

#ifdef DEBUG
  printf( " obj recieved from GRgraphics.GRxform  [%d,%d]\n", 
        GRid_list[j].osnum, GRid_list[j].objid ) ;
#endif
      nfeet = j+1;
  }/* end of loop on on the number of copies */


#ifdef DEBUG
  for( j=0; j<NB_FEET; j=j+1 ){
	write("GRid[",j,"] = ",GRid_list[j].objid,GRid_list[j].osnum,"\n"); 
  }  
#endif
  
  
  if( cv != NULL ){ free(cv); cv = NULL;}
  return OM_S_SUCCESS ;

wrapup:
  for( i=0;i<=j;i=i+1 ){
     		ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
             	targetid = GRid_list[i].objid,
             	targetos = GRid_list[i].osnum );

		GRid_list[i].objid = NULL_OBJID;
  }
  if( cv != NULL ){ free(cv); cv = NULL;}
  return OM_E_ABORT ;

}/* end cpy_obj_along */
  
