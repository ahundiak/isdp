/* $Id: crv_pro_n.u,v 1.4 2001/11/30 22:44:08 hans Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/macros / crv_pro_n.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: crv_pro_n.u,v $
 *	Revision 1.4  2001/11/30 22:44:08  hans
 *	Fix for TR# MP5171
 *	
 *	Revision 1.3  2001/04/19 18:09:23  ramarao
 *	Fixed TR# 4484.
 *
 *	Revision 1.2  2001/01/19 21:29:45  hans
 *	SP16 modifications
 *
 * History:
 *  MM/DD/YYYY    AUTHOR  DESCRIPTION
 *  01/15/98      ah      Move AS_status.h down so it compiles on Solaris
 *  10/24/2000    HF      Replace EMSsubbs.EMproject_curve_along_surface_normals
 *                        with function VDproject_curve_along_surface_normals
 *  11/30/2001    HF      Fix for TR# MP5171
 *                        Curve(line) to project perpendicular to plane ==>>
 *                        invisible projection point
 *
 * -------------------------------------------------------------------*/

/*
	------------------------------------------------------------------

	File name :		crv_pro_n.u
	Revision date :		92/12/09
	Authors :		Jean-Luc LOSCHUTZ
	Product :		I/VDS - PPMmacro library

	Description :
	-----------

		<Assoc> Project Curve Onto Surface along Normals

	History :
	-------
	89/?/?   jll Creation date
	92/09/10 jll To be concistant with crv_pro_v, I just had
			2 extra templates to take unto account or
			not the boundaries and if we want an
			approximation of the result.
			I try to speed up the system, so I perform a
			project along vector if the surface is a plane.

			templates added:
  			temp_names[2] = "trim", consider boundaries or not
					of the plane to construct;
  			temp_names[3] = "app", approximation required if
			linestring.
	92/12/10 alc Handle the case of a point to be projected on a surface

	----------------------------------------------------------------------
 */

#include <stdio.h>
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "cimath.h"
#include "nddef.h"
#include "macro.h"
#include "cimath.h"
#include "bserr.h"
#include "bsdistptpt.h"
#include "msdef.h"
#include "emssfintdef.h"
#include "igrdp.h"
#include "exmacros.h"
#include "grmacros.h"
#include "dp.h"
#include "AS_status.h"

#include "emsmapdef.h"		/* EMMapBnd_ options */
#include "grdpbdef.h"
#include "grdpbmacros.h"

#define MAX_FEET	33
#define MAX_CHA_FEET	7

GRobj			ci_mac_def1,*CURVES;
IGRboolean		want_status_messages,TrimRequired, AppRequired, cv_is_pt;
IGRboolean		Planar;
OMuword			temp_cl ;
IGRchar			buff[MAX_FEET*MAX_CHA_FEET];
IGRchar			*temp_names[4], *feet_names[MAX_FEET];
IGRint			 temp_types[4];
IGRint			num_temp;
int			num_crvs, stat, msg, i, j, k;
IGRlong			num_crv, EMSretmsg, size, rc;
IGRdouble               t_plan[6], dst, bastol;
struct GRid		CI_MACRO_ID;

struct GRid		CUV, GRid_list[MAX_FEET];
struct GRvg_construct	cst;
struct GRlc_info	curve1,surface1;
struct GRmd_env		MOD_ENV;
struct IGRdisplay	dis;
struct ret_struct	trim;
struct IGRplane         plane;
struct IGRbsp_curve     *crv, *pj_crv;

/* -> 92/12/09 */
IGRint			action ;
IGRdouble		in_point[6] ;
IGRdouble		proj_point[3] ;
struct GRparms		proj_parms ;
struct IGRpolyline	polyline, point_geom ;
struct IGRpolyline	geom ;

/* <- 92/12/09 */

extern GRclassid 	OPP_GRpoint_class_id ;

extern int 		init_cnst_list(),
			BSalloccv(),
			free();
extern			ASsuper_construct();
extern 	IGRchar     	*malloc();
extern 			EX_get_modid_given_osnum() ;
extern 	IGRboolean	BSprj_cv_pl(),
			BSfreecv();
extern	IGRdouble	BSdistptpt();

extern GRdpb_get();

extern int VDcomment;

// >>>>> HF: 10/24/2000
IGRushort               extra_options;
IGRboolean              keep_nat_bnd;
extern IGRint           VDproject_curve_along_surface_normals();
// <<<<< HF: 10/24/2000

/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{

  temp_names[0] = "srf1";
  temp_names[1] = "crv1";
  temp_names[2] = "trim";
  temp_names[3] = "app";

  temp_types[0] = other_generic;
  temp_types[1] = point_generic | curve_generic | conic_generic | line_generic;
  temp_types[2] = parameter_generic | double_type;
  temp_types[3] = parameter_generic | double_type;

  set_feet_name();

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef(  cimacdef          = ci_mac_def1,
                status            = &stat,
                name              = "crv_pro_n",
                temp_num          = 4,
                temp_names        = temp_names,
                temp_types        = temp_types,
                extern_feet_num   = MAX_FEET,
                extern_feet_names = feet_names );
}

/* ========================================================================= */

compute ()
{
  construct_comp();

  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
           (&stat, num_crv, GRid_list, &MOD_ENV ),
           targetid = CI_MACRO_ID.objid,
           targetos = CI_MACRO_ID.osnum);
  return(1);
}

/* ========================================================================= */

place ()
{
  construct_comp();

  if( GRid_list[0].objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
           (&stat, num_crv, GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );

  return(1);
}


/* ========================================================================= */

construct_comp()
{
  num_crv = 0 ; /* number of feet */
  GRid_list[0].objid = NULL_OBJID;
  GRid_list[0].osnum = MOD_ENV.md_id.osnum;
  crv    = NULL;
  pj_crv = NULL;

/*-------------------------------------------------------------------------*/
/*---	just need to know how many templates I got, to manage old and new  */
/*---   macro instances							   */
/*-------------------------------------------------------------------------*/

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
                                                    0,OM_K_MAXINT,&num_temp),
                 targetid = CI_MACRO_ID.objid,
                 targetos = CI_MACRO_ID.osnum);
  if(!(stat&1)) return OM_E_ABORT ;

  if( num_temp == 4 )
  {
    stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( &msg,
                                                                 2,
                                                                 (char *) &trim,
                                                                 &MOD_ENV  ),
                    targetid = CI_MACRO_ID.objid,
                    targetos = CI_MACRO_ID.osnum );
    if( !(msg&stat&1) )
    {
      write(" bad trim expression \n " );
      return OM_E_ABORT;
    }

    if( (IGRint) trim.var.root_pm_st.value == 1 )
         TrimRequired = TRUE;
    else TrimRequired = FALSE;

    stat = ci$send( msg = message  ACcpx.ACfind_exp_temp_struct( &msg,
                                                                 3,
                                                                 (char *) &trim,
                                                                 &MOD_ENV  ),
                    targetid = CI_MACRO_ID.objid,
                    targetos = CI_MACRO_ID.osnum ) ; as$status(sts = stat) ;
    if( !(msg&stat&1) )
    {
      write(" bad approximation expression \n " );
      return OM_E_ABORT ;
    }

    if( (IGRint) trim.var.root_pm_st.value == 1 )
      AppRequired = TRUE;
    else
      AppRequired = FALSE;

  }
  else
  {
    TrimRequired = FALSE;
    AppRequired  = FALSE;
  }

/*-------------------------------------------------------------------------*/
/*---		retrieve the curve					---*/
/*-------------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,1,&CUV),
                 targetid = CI_MACRO_ID.objid ,
                 targetos = CI_MACRO_ID.osnum);
  if( !(msg&stat&1) ) return;

  msg = ci$send( msg      = message NDmacro.ACreturn_foot( &stat ,
                                                           "",
                                                           &curve1.located_obj,
                                                           &curve1.module_info.md_env.matrix_type,
                                                           curve1.module_info.md_env.matrix ),
                 targetid = CUV.objid,
                 targetos = CUV.osnum );

  if( !(msg&stat&1) )
  {
    write(" bad curve as template\n");
    return;
  }

  curve1.module_info.md_id.osnum = curve1.located_obj.osnum;

/*-------------------------------------------------------------------------*/
/*---		retrieve the surface					---*/
/*-------------------------------------------------------------------------*/

  msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,0,&CUV),
                 targetid = CI_MACRO_ID.objid ,
                 targetos = CI_MACRO_ID.osnum);
  if( !(msg&stat&1) ) return;

  msg = ci$send( msg      = message NDmacro.ACreturn_foot( &stat ,
                                                           "",
                                                           &surface1.located_obj,
                                                           &surface1.module_info.md_env.matrix_type,
                                                           surface1.module_info.md_env.matrix ),
                 targetid = CUV.objid,
                 targetos = CUV.osnum );

  if( !(msg&stat&1) )
  {
    write(" bad surface as template\n");
    return;
  }

  surface1.module_info.md_id.osnum = surface1.located_obj.osnum;

  init_cnst_list();
  get_symb();

  dis.color      = cnst_list.color;
  dis.weight     = cnst_list.weight;
  dis.style      = cnst_list.style;

  cst.msg        = &msg;
  cst.properties = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display    = &dis;
  cst.env_info   = &MOD_ENV;
  cst.newflag    = 0;
  cst.level      = cnst_list.level;
  cst.geometry   = NULL;
  cst.class_attr = 0;
  cst.name       = 0;

/*==========================================================================*/
/*---  here depending to the TrimRequired, AppRequired the the type of   ---*/
/*---  surface on which we will project, I perform perform a project     ---*/
/*---  along vector or along normal                                      ---*/
/*==========================================================================*/

/* -> 92/12/09 : handle the point case */

  om$get_classid(osnum		= curve1.located_obj.osnum,
                 objid		= curve1.located_obj.objid,
                 p_classid	= &temp_cl ) ;

  if (om$is_ancestry_valid(	superclassid = OPP_GRpoint_class_id,
				subclassid   = temp_cl ) == OM_S_SUCCESS)
  {
#ifdef DEBUG
    printf("Point case \n") ;
#endif

    polyline.points = &in_point[0] ;
    action = 1 ; /* Get point */

    stat = ci$send(msg = message GRlinear.GRgetpolyline(&msg,
                                                        &curve1.module_info.md_env.matrix_type,
                                                        curve1.module_info.md_env.matrix,
                                                        &action,
                                                        &polyline),
                   targetid = curve1.located_obj.objid,
                   targetos = curve1.located_obj.osnum) ;
    as$status(sts = stat, action = GOTO_VALUE, value = wrapup) ;
    if (! (msg & 1)) goto wrapup ;

    stat = ci$send(msg   = message GRgraphics.GRptproject( &msg,
                                                           &cst.env_info->md_env.matrix_type,
                                                           cst.env_info->md_env.matrix,
                                                           &in_point[0],       /* I */
                                                           &proj_point[0],     /* O */
                                                           &proj_parms),       /* O */
                   targetid = surface1.located_obj.objid,
                   targetos = surface1.located_obj.osnum) ;
    as$status(sts = stat, action = GOTO_VALUE, value = wrapup) ;
    if (! (msg & 1)) goto wrapup ;

    /*
        Construct the projection point
    */

    point_geom.num_points = 1 ;
    point_geom.points     = &proj_point[0]   ;
    cst.geometry          = (char *)&point_geom ;

    if (cst.display->weight < 3)
    {
      cst.display->weight = 3 ;
    }

    stat = ci$send(msg = message GR3dpoint.GRaltconstruct(&cst),
                   targetid = GRid_list[0].objid,
                   targetos = GRid_list[0].osnum) ;
    as$status(sts = stat, action = GOTO_VALUE, value = wrapup) ;

    num_crv = 1 ;
    return OM_S_SUCCESS ;

  } /* point case */


/* <- 92/12/09 : handle the point case */


  plane.point   = &t_plan[0];
  plane.normal  = &t_plan[3];
  num_crvs = 0;

  stat = ci$send( msg = message  GRvg.GRdetplane(&msg,
                                                 &surface1.module_info.md_env.matrix_type,
                                                 surface1.module_info.md_env.matrix,
                                                 &plane ),
                  targetid = surface1.located_obj.objid,
                  targetos = surface1.located_obj.osnum ) ;
  as$status(sts = stat) ;
  if (!(stat & msg & 1)) Planar = FALSE;
  else			 Planar = TRUE;


  if( ( Planar == TRUE) && (TrimRequired == FALSE) )
  {

#ifdef DEBUG
    printf("Located surface is a plane, and Trim is FALSE \n") ;
#endif


    stat = ci$send( msg = message GRvg.GRgetsize(&msg,
                                                 &curve1.module_info.md_env.matrix_type,
                                                 curve1.module_info.md_env.matrix,
                                                 &size ),
                    targetid = curve1.located_obj.objid,
                    targetos = curve1.located_obj.osnum ) ; as$status(sts = stat) ;
    if (!(stat & msg & 1))
    {
#ifdef DEBUG
      printf("Error in GRvg.GRgetsize() \n") ;
#endif
      stat = OM_E_ABORT ; goto wrapup ;
    }

    crv = (struct IGRbsp_curve *) malloc(size);
    if (crv == NULL)
    {
#ifdef DEBUG
      printf("Unable to malloc %d bytes for crv \n", size) ;
#endif
      stat = OM_E_ABORT ; goto wrapup ;
    }

    stat = ci$send( msg = message GRvg.GRgetgeom(&msg,
                                                 &curve1.module_info.md_env.matrix_type,
                                                 curve1.module_info.md_env.matrix,
                                                 crv ),
                    targetid = curve1.located_obj.objid,
                    targetos = curve1.located_obj.osnum ) ; as$status(sts = stat) ;
    if (!(stat & msg & 1))
    {
#ifdef DEBUG
      printf("Error in GRvg.GRgetgeom() \n") ;
#endif
      stat = OM_E_ABORT ; goto wrapup ;
    }

    BSalloccv( (short) crv->order,
               (long ) crv->num_poles,
               (short) crv->rational,
               (short) crv->num_boundaries,
               &pj_crv,
               &msg ) ;
    if( msg != BSSUCC )
    {
#ifdef DEBUG
      printf("Erro in BSalloccv for pj_crv\n");
#endif
      stat = OM_E_ABORT ; goto wrapup ;
    }

    BSprj_cv_pl( &msg, crv, &plane.point[0], &plane.normal[0], &plane.normal[0], pj_crv);
    if( msg != BSSUCC )
    {
#ifdef DEBUG
      printf("Error in BSprj_cv_pl\n");
#endif
      stat = OM_E_ABORT ; goto wrapup;
    }

    cst.geometry = (char *)pj_crv;

    // HF: 10/04/2001 Fix for TR# MP5171
    // Check if the curve-projection is collapsed to a point...
    cv_is_pt = 0;
    if ( pj_crv->num_poles == 2 )
    {
      dst = BSdistptpt(&rc, &pj_crv->poles[0], &pj_crv->poles[3]);

      gr$get_basis_tolerance(buffer = &bastol);
      if ( dst <= bastol)
      {
        cv_is_pt = 1;
      }

      if (VDcomment)
      {
        printf("BSprj_cv_pl: num_poles = %d, dist = %lf, bastol = %lf, cv_is_pt = %d\n",
               pj_crv->num_poles, dst, bastol, cv_is_pt);
      }
    }

    if (! cv_is_pt)
    {
      stat = ci$send( msg      = message GRbcsubbc.GRconstruct(&cst),
                      targetid = GRid_list[0].objid,
                      targetos = GRid_list[0].osnum );
    }
    else		// HF: 10/04/2001 Fix for TR# MP5171
    {
      geom.num_points = 1;
      geom.points     = &pj_crv->poles[0];
      cst.geometry    = (char *)&geom ;

      if (cst.display->weight < 3)
      {
	cst.display->weight = 3 ;
      }

      stat = ci$send( msg      = message GR3dpoint.GRaltconstruct(&cst),
                      targetid = GRid_list[0].objid,
                      targetos = GRid_list[0].osnum );
    }

    as$status(sts = stat);
    if (!(stat & 1))
    {
      stat = OM_E_ABORT ; goto wrapup;
    }
    else
      stat = OM_S_SUCCESS ;

    num_crv  = 1;
    goto wrapup;
  } /* if (plane and trim is false) */
  else
  {
#ifdef DEBUG
    printf("General case \n") ;
#endif

    want_status_messages = FALSE;

   stat =
   ci$send(msg= message EMSsubbs.EMproject_curve_along_surface_normals(
					&curve1,
                                        &surface1,
                                        &cst,
                                        want_status_messages,
                                        TrimRequired,
                                        &num_crv,
                                        &CURVES,
                                        &EMSretmsg),
                    targetid = surface1.located_obj.objid ,
                    targetos = surface1.located_obj.osnum );
    as$status(sts = stat, action = GOTO_VALUE, value = wrapup) ;
/*
    Commeneted this as part of TR# 4484.
    keep_nat_bnd = 1;    // Should be made into an extra template !!!
    if (keep_nat_bnd)
    {
      //TrimRequired  = 1;
      extra_options = EMMapBnd_NoClip | EMMapBnd_NoFixing | EMMapBnd_NoRmvColEds;
    }

    stat =
      VDproject_curve_along_surface_normals( extra_options,
                                            &curve1,
                                            &surface1,
                                            &cst,
                                             want_status_messages,
                                             TrimRequired,
                                            &num_crv,
                                            &CURVES,
                                            &EMSretmsg);

    //printf("TrimRequired = %d, num_crv = %d\n",TrimRequired, num_crv);

    as$status(sts = stat, action = GOTO_VALUE, value = wrapup) ;
    if (! (msg & 1)) goto wrapup ;
*/

    num_crvs = num_crv ;
  }

#ifdef DEBUG
  write("curve msg=",msg,"number of curve=",num_crvs,'\n');
#endif


  if( num_crvs > 0 )
  {
    for(i=0;i<num_crvs;i=i+1)
    {
      GRid_list[i].objid = CURVES[i];
      GRid_list[i].osnum = MOD_ENV.md_id.osnum;
    }
  }
  for(i=num_crvs; i<MAX_FEET; i=i+1)
  {
    GRid_list[i].objid = NULL_OBJID;
    GRid_list[i].osnum = MOD_ENV.md_id.osnum;
  }

 wrapup:

  if( crv    != NULL ) om$dealloc(ptr=crv);
  if( pj_crv != NULL ) BSfreecv(&msg,pj_crv);
  return stat ;
}


/* ======================================================================== */

set_feet_name()
{
  for (k=0; k<MAX_FEET; k=k+1)
  {
    j = k * MAX_CHA_FEET;
    sprintf(&buff[j],"resi%d",k);
    feet_names[k] = &buff[j];
  }
}

/* ======================================================================== */
