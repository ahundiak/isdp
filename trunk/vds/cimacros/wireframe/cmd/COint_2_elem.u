/* $Id: COint_2_elem.u,v 1.1.1.1 2001/01/04 21:07:22 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/cimacros/wireframe/cmd / COint_2_elem.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COint_2_elem.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:22  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/02/01  14:11:52  pinnacle
# ah
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.2  1997/02/28  18:30:56  pinnacle
# Replaced: cimacros/wireframe/cmd/COint_2_elem.u for:  by v241_int for vds.241
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *      02/01/98        ah              Moved AS_status.h down
 * -------------------------------------------------------------------*/

/*
	------------------------------------------------------------------
	
	File name :		COint_2_elem.u
	Revision date :		92/10/26
	Authors :		Jean-Luc LOSCHUTZ
				Alain CLAUDE
	Product :		I/VDS 2.1 - PPMmacro library

	Description :
	-----------

		<Assoc> Wireframe and Surface - intersect two elements.

		Intersect two elements with an associative expression for
		each located object, and an approximation expression
		to compute intersection.

		This macro is owned by 5 templates : 
			- 2 objects 	(surf1 and surf2)
			- 3 expressions (trim1, trim2 and approx)

		Range of trim1 and trim2 expressions is :
			0	INF_B	infinite object    (line  or plane)
			1	IMP_B	imposed boundaries (surface)
			2	NAT_B	natural boundaries (plane or surface)

		The 3rd expression (0 or 1) is used to turn on/off approximation
		using JLL algorithm (implemented in the IntTwoSurf() function).

	History :
	-------
	91/10/18 <Assoc> Intersect two elements - Design date.
	92/02/07 Add expressions support (trim1/2, approx), and handle 4 
			types of geometry (plane, surf, line, curve).
	92/02/19 Set default values to 0 (infinite).
	92/07/22 Get rid of internal data (not used)
	92/10/26 Use previous expressions values when locating second object
			another time 
	------------------------------------------------------------------
 */

#include "cieveryone.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "ciexec.h"
#include "EMSssprops.h"
#include "EMSmsgdef.h"
#include "msdef.h"
#include "stdio.h"
#include "AS_status.h"

#define MACRO_NAME	"int_2_elem"
#define NUM_TEMP	5

struct GRid 	TEMP[NUM_TEMP] ;
struct GRmd_env MOD_ENV ;
GRobj 		ci_mac_bib_FileId ;
GRobj 		MAC1    ;
IGRint		flag_for_wakeup   ; 
IGRint          resp_exp ;
IGRint          num_ent ;
IGRint 		suc     ;
IGRchar         txt[20] ;
IGRchar		loc_mes[81], loc_prompt[81], exp_prompt[81] ;
OMuword		classid[2]  ;
double		exp_default ;

struct OM_sd_classlist	classlist ;
extern ASmake_source_from_env();


/*
	------------------------------------------------------------------
 */


main()
{

IGRlong	sts ;
char 	buffer[200] ;

while (1) {

   flag_for_wakeup = 0 ; /* concerning status field for expression message */
   loc_obj1 :
   if(!ci$locate( prompt       = "Identify object 1 ",
                  properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                  owner_action = LC_RIGID_COMP  |
                                 LC_RIGID_OWNER | LC_FLEX_COMP |
                                 LC_FLEX_OWNER  | LC_REF_OBJECTS,
		  eligible_classes = &classlist,
                  obj          = &(TEMP[0].objid),
                  osnum        = &(TEMP[0].osnum),
                  md_env       = &MOD_ENV    )) {
	break ;
	}
   sts = ASmake_source_from_env( &TEMP[0],&MOD_ENV,&TEMP[0]) ;	
   as$status(sts = sts) ;

   resp_exp = 0 ; /* flag to indicate that no expression has been created */
   while (1) {
        message(loc_mes);
	status("Reset to create expressions") ;
	flag_for_wakeup = 1 ;

	loc_obj2 :
	ci$locate( 	prompt       = "Identify object 2 ",
                  	properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                  	owner_action = LC_RIGID_COMP  |
                                 LC_RIGID_OWNER | LC_FLEX_COMP |
                                 LC_FLEX_OWNER  | LC_REF_OBJECTS,
 	          	eligible_classes = &classlist,
	          	obj          = &(TEMP[1].objid),
                  	osnum        = &(TEMP[1].osnum),
			response     = &M_response,
                  	md_env       = &MOD_ENV    ) ;
	status("") ;
	flag_for_wakeup = 0 ;
	if (M_response == EX_RJT_MOVEON) {
		ask_expressions() ;
		if (resp_exp)
			goto loc_obj2 ; /* continue */
		else
			goto loc_obj1 ; /* redo     */
		}
	else if (M_response == EX_DATA || M_response == EX_OBJID) {
		if (resp_exp == 0) {
			cre_default_expressions() ;
			}
		sts = ASmake_source_from_env( &TEMP[1],&MOD_ENV,&TEMP[1]) ;
		as$status(sts = sts) ;
		}
	else if (M_response == EX_BACK_UP) {
		goto loc_obj1 ;
		}
	else {
		#ifdef DEBUG
		printf("Unknown M_response \n") ; 
		#endif
		exit ;
		}

   	MAC1 = NULL_OBJID ;   
   	sts = ci$get_module_info(md_env = &MOD_ENV) ;
	as$status(sts = sts) ;

   	sts = ci$send(msg = message nci_macro.init( 	&suc,
                                        	0,
				        	MACRO_NAME,
						NUM_TEMP,
						TEMP,
						NULL,
                                        	&MOD_ENV ),
	   targetid = MAC1,
	   targetos = MOD_ENV.md_id.osnum );
	as$status(sts = sts) ;

	if( suc == 0 ){
		sprintf(buffer, "placement of nci_macro \"%s\" failed", MACRO_NAME) ;
		write (buffer, "\n\n") ;
		status(buffer) ;
      		ci$send(msg = message Root.delete(0),
			targetid = MAC1,
			targetos = MOD_ENV.md_id.osnum );
	        }
	   #ifdef DEBUG
	   else
		write("placement of nci_macro successful \n\n") ;
	   #endif
      } 
 }    
 return ;
}     /* main() */

/*
	------------------------------------------------------------------
 */

init() 
{
strcpy(loc_mes,"<Assoc> Intersect Elements");

om$get_classid( classname = "GRcurve",
	 	p_classid = &classid[0]) ;
om$get_classid( classname = "EMSsurface",
	 	p_classid = &classid[1]) ;
classlist.w_count = 2;
classlist.w_flags = OM_CLST_subclass;
classlist.p_classes = classid;

ci$load(file_name = "ci_mac_bib.u",
	load 	  = LOAD,
	file_id   = &ci_mac_bib_FileId,
	stat 	  = &suc) ;

if (suc != CI_S_SUCCESS) {
	exit ;
	}
return ;
} /* init() */

/*
	------------------------------------------------------------------
 */

wakeup(){
        message(loc_mes);
	if (flag_for_wakeup) {
		status("Reset to create expressions") ;
		}
	return ;
} /* wakeup() */

/*
	------------------------------------------------------------------
 */

ask_expressions()
{
	#ifdef DEBUG
	printf("ask_expressions() function \n") ;
	#endif
	resp_exp = 0 ;

	ask1 :
		/* Expression 1 */
		strcpy(loc_prompt,
		    "Enter trim value for object 1 (0=none/2=trimmed):"); 
		strcpy(exp_prompt, "Enter trim value (0=none/2=trimmed):") ;
		exp_default = 0 ;
		suc = 0 ;
		push (char *) &suc, loc_mes, loc_prompt, exp_prompt, 
			exp_default, (char *)&TEMP[2] ;
		ci$run(	file_id = &ci_mac_bib_FileId,
			entry  = "loc_exp") ;
		if (suc != 1) {
			return ; /* => redo locate obj1 */
			}

	ask2 :
		/* Expression 2 */
		strcpy(loc_prompt,
		    "Enter trim value for object 2 (0=none/2=trimmed):" ); 
		strcpy(exp_prompt, "Enter trim value (0=none/2=trimmed):") ;
		exp_default = 0 ;
		suc = 0 ;
		push (char *) &suc, loc_mes, loc_prompt, exp_prompt, 
			exp_default, (char *)&TEMP[3] ;
		ci$run(	file_id = &ci_mac_bib_FileId,
			entry  = "loc_exp") ;
		if (suc != 1) {
			goto ask1 ;
			}	

		/* Expression 3 : approximation expression */
		/* 
		   if true switch to jll algorithm to get a B-spline
		   instead of a linestring (I/EMS)
		 */ 
		strcpy(loc_prompt,
			"Approximation (0=exact/1=approximate):");
		strcpy(exp_prompt,
			"Enter Approximation (0=exact/1=approximate):") ;
		exp_default = 0 ;
		suc = 0 ;
		push (char *) &suc, loc_mes, loc_prompt, exp_prompt, 
			exp_default, (char *)&TEMP[4] ;
		ci$run(	file_id = &ci_mac_bib_FileId,
			entry  = "loc_exp") ;
		if (suc != 1) {
			goto ask2 ;
			}	
		resp_exp = 1 ; /* => OK to continue */
		return ;
} /* ask_expressions() */

/*
	------------------------------------------------------------------
 */

cre_default_expressions() {
	#ifdef DEBUG
	printf("cre_default_expressions() function \n") ;
	#endif

        push (char *)&suc, (IGRdouble)0.0, (char *)&TEMP[2];
        ci$run( file_id = &ci_mac_bib_FileId,
 	         entry   = "CreDefUnExp" );
        if( suc != MSSUCC ) exit;

        push (char *)&suc, (IGRdouble)0.0, (char *)&TEMP[3];
        ci$run( file_id = &ci_mac_bib_FileId,
 	         entry   = "CreDefUnExp" );
        if( suc != MSSUCC ) exit;

	/* Approximation */
        push (char *)&suc, (IGRdouble)0.0, (char *)&TEMP[4];
        ci$run( file_id = &ci_mac_bib_FileId,
 	         entry   = "CreDefUnExp" );
        if( suc != MSSUCC ) exit;

	resp_exp = 1;
	return ;
} /* cre_default_expressions() */

/*
	------------------------------------------------------------------
 */

