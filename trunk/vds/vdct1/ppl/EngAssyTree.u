
/***************************************************************************
 * I/VDS
 *
 * File:        vdct1/ppl/EngAssyTree.u
 *
 * Description: PPL for definition of Foundation Assemblies
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: EngAssyTree.u,v $
 *      Revision 1.2  2001/01/12 14:47:05  art
 *      sp merge
 *
# Revision 1.1  2000/04/20  18:46:16  pinnacle
# Created: vds/vdct1/ppl/EngAssyTree.u by pnoel for Service Pack
#
# Revision 1.3  2000/03/24  20:35:06  pinnacle
# ah
#
# Revision 1.2  2000/03/13  15:43:10  pinnacle
# ah
#
# Version: 1.0  2000/03/02  Initiation
# pn
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 03/02/00  pn      Creation
 * 
 *
 ***************************************************************************/

#include "header.h"
#include "VDct1Attrs.h"
#include "VDfrm.h"
#include "vdprocinfo.h"


/* --------------------------------------------------
 * Activity Rules control
 * 
 * IGRstat          O -  ACTION_OK (0 or 1) 
 * TVDctBaseInfo    I/O  BASE_INFO
 * TVDctBaseInfo    I/O  BASE_INFO_PARENT
 * IGRchar          I -  LOCATION       The calling location or action sets rules 
 *
 */

// external functions
//from VDSroot import VDprocAttr;
extern VDSverify_login();
//extern VDSRislogin();
//extern GRconfirm_box();
//extern VDnotify_box();


/* --------------------------------------------------
 * I - NODE_PARENT_ID  (of ParentID)
 * I - PIECE_OE   (of *modelOE) 
 * O - NODE_TYPE  (of *nodeType)
 */


  
IGRstat getTypeForModelObject()
 {
   IGRint retFlag;           
   retFlag = 0;
// currently a no-op 
    retFlag = 1;
  
wrapup:

  return retFlag;
  
}

/* --------------------------------------------------
 * Validate child type
 * I - NODE_PARENT_ID (of the parent)
 * I - BASE_INFO (of the parent)
 * I - NODE_TYPE (of child)
 */
IGRstat isChildTypeValid()
{
  
  IGRstat retFlag;
  IGRstat traceFlag;
  
  IGRint sts;
  
  IGRchar        *parentType,*childType;
  IGRchar        *buf;
  
  // Init
  retFlag   = 1;
  traceFlag = 0;
  
  // set up data types to same type
  parentType = BASE_INFO.nodeType;
  childType  = NODE_TYPE;
  
  /*
   * Rules management for valid Child types 
   * Tells if making a certain type of node is acceptable
   * This logically says no except for exceptions which are sent to wrapup
   * Built this way to be easy to understand and alter quickly.
   */

   if (traceFlag) 
     printf(">>> isChildTypeValid\nParent Node Type %s \nChild Node Type %s\n",
	  parentType,childType);

   // Test for valid childType for GROUP parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ENGTREE)){
     // OK ASSY2, ENGASSY2, ENGASSY6, PARTS, GROUP
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_GROUP))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY2)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY6)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))    goto wrapup;
   }
      
   // Test for valid childType for GROUP parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_GROUP)){
     // OK ASSY2, ENGASSY2, ENGASSY6, PARTS,GROUP
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_GROUP))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY2)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY6)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))    goto wrapup;
   }
   
   // Test for valid childType for ENGASSY2 parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ENGASSY2)){
     // OK ASSY2, ENGASSY2, PART
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY2)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))     goto wrapup;
   }

   // Test for valid childType for ENGASSY6 parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ENGASSY6)){
     // OK ASSY2, ENGASSY2, PARTS, PART
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ENGASSY2)) goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PARTS))    goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))     goto wrapup;
   }
   
   // Test for valid childType for ASSY2 parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_ASSY2)){
     // OK PART
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))     goto wrapup;
   }

   // Test for valid childType for PARTS parentType
   if(!strcmp(parentType,VDCT1_ENG_NODE_TYPE_PARTS)){
     // OK ASSY2, PART
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_ASSY2))   goto wrapup;
     if(!strcmp(childType,VDCT1_ENG_NODE_TYPE_PART))    goto wrapup;
   }

   //Test for valid childType for PART parentType (no valid types)

    // no acceptable conditions found!
  retFlag = 0;
  
// oh well  
wrapup:
  if (traceFlag)printf("<<< isChildTypeValid ,%d \n\n",retFlag);
  return retFlag;
}
/* --------------------------------------------------
 * Initialize the count to 1
 */
IGRstat computeNodePartCount()
{
  IGRstat retFlag;
  IGRstat sts;
  
  TVDfld        countFld;
  IGRdouble     cutLen;
  TVDctBaseInfo baseInfo;
  // Init
  retFlag = 0;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COUNT, fld = &countFld);
  if (*countFld.name == 0) goto wrapup;
  strcpy(countFld.val.txt,"1");

  // Make sure have model object
  if (PIECE_OE.obj_id.objid == NULL_OBJID) goto wrapup;
  
  // Based on type
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSbeam");
  if (sts & 1) {
    cutLen = 0.0;
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name  = VDCT1_ISDP_ATTR_CUT_LENGTH,
		   dbl   = &cutLen);
    sprintf(countFld.val.txt,"%.2f",cutLen / 1000.0);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &countFld);
    retFlag = 1;
    goto wrapup;
  }

  
      
  // Update
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &countFld);
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

extern VDstrupr();



/*********************************************************************
 *  Compute the mino_isdp
 */
IGRstat computeNodePartMinoISDP()
{
  IGRstat     retFlag;
  IGRstat     sts;
  
  TVDfld      fld;
  IGRchar     partNum[128];     //beam pat_num
  IGRchar     matlGrade[128];   //plate or beam grade
  IGRchar     equipPartNum[128];    //equipment eqp_partnum
  IGRdouble   plateThk;    //plate thickness
  
  IGRchar     minoISDP[256]; 
  
  //init
  retFlag = 0;
  *partNum = 0;
  *matlGrade = 0;
  *minoISDP = 0;
  plateThk = 0.0;
  

  //check to see if we have an object
  if (PIECE_OE.obj_id.objid == NULL_OBJID) {
    retFlag = 1;
    goto wrapup;
  }
 

    // compute for Equipment
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VDequipment");
  
  if (sts & 1) {
    // get the eqp_partno
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_EQP_PARTNO,
		   txt = equipPartNum);

    // set equipment minoISDP
    strcat(minoISDP,equipPartNum);
    

    // update on tree
        vdcol$GetAttr(objID = &NODE_ID,
		  name = VDCT1_ATTR_MINO_ISDP,
		  fld = &fld);

    if (*fld.name) {
      strcpy(fld.val.txt,minoISDP);
      vdcol$UpdAttrs(objID = &NODE_ID,
		    cnt = 1,
		    fld = &fld);

    }
    }
  
  //compute for a beam
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSbeam");
  if (sts & 1) {
    strcpy(minoISDP,"BM ");
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_GRADE,
		   txt = matlGrade);
    strcat(minoISDP,matlGrade);
    strcat(minoISDP," ");
    // minoISDP should now equal BM GRADE
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_PART_NUM,
		   txt = partNum);
    strcat(minoISDP,partNum);
    // minoISDP is complete for beam

    // update on tree
    vdcol$GetAttr(objID = &NODE_ID,
		  name = VDCT1_ATTR_MINO_ISDP,
		  fld = &fld);
    if (*fld.name) {
      strcpy(fld.val.txt,minoISDP);
      vdcol$UpdAttrs(objID = &NODE_ID,
		    cnt = 1,
		    fld = &fld);
    }
    retFlag = 1;
    goto wrapup;
  }
  // compute for a plate
  
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSplate");
  if (sts & 1) {
    //strcpy(minoISDP,"PL ");
    
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_GRADE,
		   txt = matlGrade);
    //strcat(minoISDP,matlGrade);
    //strcat(minoISDP," ");
    // minoISDP should now equal PL GRADE
    vdsa$GetStruct(objOE = &PIECE_OE,
		   name = VDCT1_ISDP_ATTR_PLATE_THK,
		   dbl = &plateThk);
    
    //strcat(minoISDP,plateThk);
    sprintf(minoISDP,"PL %s %.1f",matlGrade,plateThk);
    

    // minoISDP is complete for plate

    // update on tree
    vdcol$GetAttr(objID = &NODE_ID,
		  name = VDCT1_ATTR_MINO_ISDP,
		  fld = &fld);
    if (*fld.name) {
      strcpy(fld.val.txt,minoISDP);
      vdcol$UpdAttrs(objID = &NODE_ID,
		    cnt = 1,
		    fld = &fld);
    }
  
  
    retFlag = 1;
    goto wrapup;
  }

wrapup:
  return retFlag;
  
}

/* -------------------------------------------------
 * Compute a part node
 */
IGRstat computeNodePart()
{
  IGRstat retFlag;
  IGRstat sts;
  IGRchar buf[256],tmp[256];
  IGRchar partEquipNo[256];
  IGRchar unitEquipNo[256];
  TGRid   parentID, nodeID;
  TGRobj_env  parentOE;
  TVDctBaseInfo baseInfo;
  
  TVDfld  fld;
  
  // Init
  retFlag = 0;

  // Make sure got a model object
  if (PIECE_OE.obj_id.objid == NULL_OBJID) {
    retFlag = 1;
    goto wrapup;
  }

  
#if 0    
 //compute for a beam the Unit Number OK, CS
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSbeam");  
  if (sts & 1){ 
    // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  }
  
  // compute for Equipment
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VDequipment");
  if (sts & 1) {
    // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  }
  
  // compute for Plate
  sts = vdobj$IsAncestryValid(objOE = &PIECE_OE,
			      superClassName = "VSplate");
  if (sts & 1) {
    // Do it
  sts = vdct1$CSGetNodeMatrix(nodeID = &NODE_ID,
			      csOE   = &PIECE_OE);
  }
#endif 

  // Build the isdp_name
  *buf = 0;
  vdsa$GetStruct(objOE = &PIECE_OE, name = VDCT1_ISDP_ATTR_EQP_FAMILY,  txt = tmp);
  strcpy(buf,tmp);
  strcat(buf,":");
  vdsa$GetStruct(objOE = &PIECE_OE, name = VDCT1_ISDP_ATTR_EQP_PARTNO,  txt = tmp);
  strcat(buf,tmp);
  strcat(buf,":");
  vdsa$GetStruct(objOE = &PIECE_OE, name = VDCT1_ISDP_ATTR_EQP_PARTREV, txt = tmp);
  strcat(buf,tmp);
  strcat(buf,":");
  vdobj$Get(objOE = &PIECE_OE, objName = tmp);
  strcat(buf,tmp);
  
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ISDP_NAME, fld = &fld);
  if (*fld.name) {
    VDstrupr(buf);
    strcpy(fld.val.txt,buf);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);
  }
  
  // Add the path
  vdobj$Get(objOE = &PIECE_OE, objPath = tmp);
  
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ISDP_PATH, fld = &fld);
  if (*fld.name) {
    VDstrupr(tmp);
    strcpy(fld.val.txt,tmp);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);
  }
  
  // Other attributes
  VDct1CopyAttributeFromModelToNode(&NODE_ID,
				    VDCT1_ATTR_UNIT,
				    &PIECE_OE,
				    VDCT1_ISDP_ATTR_UNIT);

  // VDct1CopyAttributeFromModelToNode(&NODE_ID,
  //    VDCT1_ATTR_COMPARTMENT,
				      //    &PIECE_OE,
  //    VDCT1_ISDP_ATTR_COMPARTMENT);



  // Pull zone from 
  sprintf(buf,"%s:%s:%s:%s:",
	  BASE_INFO.setType,
	  BASE_INFO.setName,
	  BASE_INFO.nodeType,
	  BASE_INFO.nodeName);

  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_ZONE, fld = &fld);
  if (*fld.name) {
    VDstrupr(buf);
    strcpy(fld.val.txt,buf);
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &fld);
  }

  // count is based on object type
  // computeNodePartCount();

  // MINO ISDP is based on grade and part_num for beams
  //                       grade and plate_thk for plates
  computeNodePartMinoISDP();
  

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* -------------------------------------------------
 * Compute the node
 */
IGRstat computeNode()
{
  IGRstat retFlag;
  
  // Init
  retFlag = 1;
  
  // Frozen nodes do not get recomputed

  // Is it a part?
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) {
    retFlag = computeNodePart();
  
    goto wrapup;
  }
  
  // Failed
  retFlag = 0;

  // oh well
wrapup:
  return retFlag;
  
}

/* -------------------------------------------------
 * Returns the value for mbom assembly identifier
 */
IGRstat getAttributeValue_tmbom_assy()
{
  TGRid parentID;
  TGRid childID;
  
  TVDctBaseInfo baseInfo;

  // For assemblies (ENG) the mino
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY2)) {
    vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO, fld = &FLD);
    strcpy(FLD.name,VDCT1_ATTR_MBOM_ASSY);
    return 1;
  }

  // For assemblies (2) the mino
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ASSY2)) {
    vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO, fld = &FLD);
    strcpy(FLD.name,VDCT1_ATTR_MBOM_ASSY);
    return 1;
  }

  // Not a part then not defined
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) {
    strcpy(FLD.val.txt,"");
    FLD.type = VDFLD_TYPE_TXT;
    return 1;
  }

  // Look up until an ASSY is found
  parentID = NODE_ID;
  
parent_loop:

  childID = parentID;
  
  vdct1$GetTree1Parent(objID = &childID, nth = 0, outID = &parentID);
  if (parentID.objid == NULL_OBJID) {
    parentID = NODE_ID; // Part has no assy parent
    goto got_it;
  }
  vdct1$GetBaseInfo(objID = &parentID, baseInfo = &baseInfo);

  if(strcmp(baseInfo.nodeType,VDCT1_ENG_NODE_TYPE_ENGASSY2)) {
    if(strcmp(baseInfo.nodeType,VDCT1_ENG_NODE_TYPE_ASSY2)) goto parent_loop; 
  }

got_it:

  vdcol$GetAttr(objID = &parentID, name = VDCT1_ATTR_MINO, fld = &FLD);
  strcpy(FLD.name,VDCT1_ATTR_MBOM_ASSY);
  return 1;

}

/* -------------------------------------------------
 * Tree specific attribute processing
 */
IGRstat getAttributeValue()
{
  if (!strcmp(FLD.name,VDCT1_ATTR_MBOM_ASSY)) {
    return getAttributeValue_tmbom_assy();
  }
  return 0;
}

/* -------------------------------------------------
 * Individual stage information for NODE_INDEX
 */
IGRstat getNodeTypeInfo()
{
  NODE_CNT = 7;
  // This sets the DO-IT box content in the Node Form selection
  switch(NODE_INDEX) {

  case 0:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_PART);
    strcpy(NODE_TYPE_INFO.desc, "PART");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 1:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_PARTS);
    strcpy(NODE_TYPE_INFO.desc, "PARTS_NODE");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 2:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ENGASSY2);
    strcpy(NODE_TYPE_INFO.desc, "ENGASSY[2]");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 3:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ENGASSY6);
    strcpy(NODE_TYPE_INFO.desc, "ENGASSY[6]");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 4:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ASSY2);
    strcpy(NODE_TYPE_INFO.desc, "ASSY2");
    strcpy(NODE_TYPE_INFO.level,"U00");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 5:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_GROUP);
    strcpy(NODE_TYPE_INFO.desc, "GROUP");
    strcpy(NODE_TYPE_INFO.level,"U01");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;

  case 5:
    strcpy(NODE_TYPE_INFO.type, VDCT1_ENG_NODE_TYPE_ENGTREE);
    strcpy(NODE_TYPE_INFO.desc, "ENG_ASSY_TREE");
    strcpy(NODE_TYPE_INFO.level,"002");
    strcpy(NODE_TYPE_INFO.table,"vdct1_engassy");
    return 1;
  }

  memset(&NODE_TYPE_INFO,0,sizeof(TVDctNodeTypeInfo));

  return 0;
}

/* -------------------------------------------------
 * Class filters, all root
 */
IGRstar getFilter()
{
 
#if 0  
  om$get_classid(classname = "GRvg",
		 p_classid = &CLASS_LIST.p_classes[0]);
  CLASS_LIST.w_count = 1;
#endif
#if 1
  om$get_classid(classname = "VSplate",
		 p_classid = &CLASS_LIST.p_classes[0]);  
  om$get_classid(classname = "VSbeam",
		 p_classid = &CLASS_LIST.p_classes[1]);  
  om$get_classid(classname = "VDequipment",
		 p_classid = &CLASS_LIST.p_classes[2]);  
  om$get_classid(classname = "GRgencs",
		 p_classid = &CLASS_LIST.p_classes[3]);
  CLASS_LIST.w_count = 4;
#endif
  return 1;
}

/* -------------------------------------------------
 * Assorted information about the set type
 */
IGRstar getSetTypeInfo()
{
  strcpy(SET_TYPE_INFO.type,"EngAssyTree");
  strcpy(SET_TYPE_INFO.rev, "000");
  strcpy(SET_TYPE_INFO.desc,"EngAssyTree");
  
  strcpy(SET_TYPE_INFO.nodeTable,"vdct1_engassy");
  strcpy(SET_TYPE_INFO.leafTable,"vdct1_engassy");

  return 1;
}

/* -------------------------------------------------
 * Say something if ppl is run by user
 */
main()
{
  getSetTypeInfo();

  printf("%s %s %s\n",
    SET_TYPE_INFO.type,
    SET_TYPE_INFO.rev,
    SET_TYPE_INFO.desc);

  return 1;
}

/* --------------------------------------------------
 * Used to retrieve attribute information
 */
IGRint        ATTR_INDEX; // Attribute Index
TVDctAttrName ATTR_NAMEX; // Attribute Name
TVDctAttrInfo ATTR_INFO;  // Attribute Information

/* --------------------------------------------------
 * For a given set wide attribute name, fill in the info
 * I - ATTR_NAMEX
 * O - ATTR_INFO
 */
IGRstat getAttrInfo()
{ 
  IGRstat retFlag;
  
  // Init 
  retFlag = 1;
  memset(&ATTR_INFO,0,sizeof(TVDctAttrInfo));

  // Trick to allow sharing standard attributes
#include "attribute.h"

  // Not found
  retFlag = 0;
  
wrapup:
  return retFlag;
}

/* -------------------------------------------
 * Computes the setName for Trees
 */
IGRstat computeSetName()
{
  IGRstat       retFlag, seqNo;
  IGRint       *a_minoIndex;
  TVDctBaseInfo parentBaseInfo;
  IGRchar       buf[256];


  // init
  retFlag = 0;

  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_ENGTREE)) goto wrapup;
 
  
  seqNo = seqNo +1;
  sprintf(buf,"%d",seqNo);
     
  // Rule: ENG_ASSY_TREE  get named by the number
  if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ENGTREE)) {

    //look up unique number from ost_mino_index (database lookup)
    vdct1$PostGetNextMinoIndex(hullNum     = "LPD17",
			       unitNum     = "C60000",
			       groupCode   = buf,
			       a_minoIndex = &a_minoIndex);  
    //generate buf
    sprintf(buf,"%6s%04d","LPD17.",a_minoIndex);
    strcpy(BASE_INFO.setName,buf);

    retFlag = 1;
    goto wrapup; 
  }

 
  
  // oh well
  

  // say bye
wrapup:

    return retFlag;

}

/* --------------------------------------------
 * Computes the nodeName for certain nodes
 */
IGRstat computeNodeName()
{
  IGRstat       retFlag;
  IGRint       *a_minoIndex;
  TVDfld        hullFld;
  TVDfld        unitFld;  
  TVDctBaseInfo parentBaseInfo;
  IGRchar       buf[256];
  IGRstat       seqNo;
  IGRchar       seqBuf[128];
  
  // init
  retFlag = 0;

  // Rule: Go home if it is a PART
  if (!strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) goto wrapup;
  
  // Get it
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_UNIT, fld = &unitFld);
  vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_AV_HULL, fld = &hullFld);
   
  seqNo = seqNo +1;
  sprintf(seqBuf,"%d",seqNo);
  // look up unique number from ost_mino_index (database lookup)
  vdct1$PostGetNextMinoIndex(hullNum     = hullFld.val.txt,
			     unitNum     = unitFld.val.txt,
			     groupCode   = seqBuf,
			     a_minoIndex = &a_minoIndex);
  // generate buf
  sprintf(buf,"%11s.%04d",parentBaseInfo.nodeName,a_minoIndex);
  strcpy(NODE_NAME,buf);
  strcpy(BASE_INFO.nodeName,buf);
  vdct1$SetBaseInfo(objID = &NODE_ID, baseInfo = &BASE_INFO);
  retFlag = 1;
      
 
  // say bye
wrapup:

    return retFlag;

}


/* --------------------------------------------------
 * Pull in standard helper functions
 */
#include "compute.h"

/* --------------------------------------------------
 * Traffic director for computing the mino number
 */
IGRstat computeMino()
{
  IGRstat retFlag;
  IGRstat sts;
  IGRchar buf[128];
  
  TVDfld minoFld;
  TVDfld commodityFld;
  TVDfld shortFld;
  TVDfld hullFld;
  TVDfld unitFld;
  
  // Init
  retFlag = 0;
 
 // And build it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_MINO_ISDP, fld = &unitFld); 
  if (*unitFld.name == 0) goto wrapup;
  if (!strcmp(unitFld.val.txt,"")) sprintf(unitFld.val.txt,"2311");

  // setup an UNIT_NO
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &unitFld);
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}

/* --------------------------------------------------
 * Set the UNIT_WT attribute
 */
IGRstat setAttributeUnitWt()
{
  IGRstat retFlag;
  TVDfld  unitWtFld;
  
  // init
  retFlag = 0;
  
  // Get the  UNIT_WT attribute accessed
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_UNIT_WT, fld = &unitWtFld);
  if (*unitWtFld.name == 0) goto wrapup;

  // set the value and update the fields // always KG
  sprintf(unitWtFld.val.txt,"KG");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &unitWtFld);  

  // success!
  retFlag = 1;
  // oh well
wrapup:
  // go home
  return retFlag;
  
}




/* --------------------------------------------------
 * Initialize the Count to 1
 */
IGRstat setAttributeCount()
{
  IGRstat         retFlag;
  IGRint          i;
  IGRint          childCount, parentCount;
  TVDfld          countFld, parentCountFld;
  TVDctBaseInfo   parentBaseInfo, baseInfo;
  IGRchar         parentNodeType[256], nodeType[256], count[256];
  TGRid           childID;
  
  // Init
  retFlag = 0;
  
    // get the baseInfo of the node and its parent
  vdct1$GetBaseInfo(objID = &NODE_ID, baseInfo = &baseInfo);
  vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &parentBaseInfo);
  strcpy(nodeType,baseInfo.nodeType);
  strcpy(parentNodeType,parentBaseInfo.nodeType);

  // non part nodes get a default value of 0
  if (strcmp(nodeType,VDCT1_ENG_NODE_TYPE_PART)) {  
  // Get it
  vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COUNT, fld = &countFld);
  if (*countFld.name == 0) goto wrapup;

  // load up a default "0" for all not included in the rules below
  strcpy(countFld.val.txt,"0");
  vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &countFld);
  }
  

// Rule: PART nodes get a default value of 1
  if (!strcmp(nodeType,VDCT1_ENG_NODE_TYPE_PART)) {  
    vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_COUNT, fld = &countFld);
  // Update default value
    strcpy(countFld.val.txt,"1");
    vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &countFld);
    }
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}



/* ----------------------------------------------------
 * computeWeight
 */
IGRstat computeWeight()
{
  IGRstat       retFlag;
  IGRdouble     childWeight, parentWeight, cfactor;
  IGRint        i, sts, flag;
  TVDfld        weightFld;
  TVDctBaseInfo baseInfo, parentBaseInfo;
  IGRchar       weight[256], nodeType[256], unitWt[256], buf[256];
  TGRid         childID;
  IGRstat       traceFlag;
  TGRobj_env    objOE;
  VDprcAttr     mp;
  IGRlong       suc;

  // init
  traceFlag = 0;
  retFlag = 0;
  i = 0;

  // Hello
  if (traceFlag) printf(">>> computeWeight()\n");
  

  // arg check
  if(NODE_ID.objid == NULL_OBJID) goto wrapup;

  // set the memory available
  memset(&mp,0,sizeof(VDprcAttr));
  if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART)) goto wrapup;
  
  // get the objOE of the node

  vdct1$GetNodeModelObject(nodeID  = &NODE_ID,
			   modelOE = &objOE);
 if(traceFlag) {
   vdobj$Print(objOE = &objOE);
 }

 // Get the objects name
  vdobj$Get(objOE = &objOE, objName = baseInfo.nodeName);
  //VDstrupr(baseInfo.nodeName);
      // Get PART node weight attribute
    // send a message to get the data from model
    flag = 0xFF;
    
    sts = ci$send( msg      = message VDSroot.VDprocAttr(&suc,&objOE.mod_env,flag,&mp),
		   targetid = objOE.obj_id.objid,
		   targetos = objOE.obj_id.osnum );

      vdcol$GetAttr(objID = &NODE_ID, name = VDCT1_ATTR_WEIGHT, fld = &weightFld);
      strcpy(weight,weightFld.val.txt);
      
      // write the weight attribute for the  PART
      if (mp.mass == 0) { 
	sprintf(buf,"0.0");
      }
      else {
	sprintf(buf,"%f",mp.mass);
      }
      
      sprintf(weightFld.val.txt,"%s",buf);
      
      vdcol$UpdAttrs(objID = &NODE_ID, cnt = 1, fld = &weightFld);

    goto wrapup;
  

    retFlag = 1;
  
wrapup:
    if (traceFlag) printf("<<< computeWeight(%d)\n",retFlag);
  return retFlag;
  
}



// ------------------------------------
IGRstat summaryNode()
{
  IGRstat     retFlag;
  TGRid       parentID, childID;
  IGRdouble   wt, wtChild;
  IGRint      i, cnt;
  IGRint      count, cgX, cgY, cgZ;
  IGRstat     countChild, cgXChild, cgYChild, cgZChild;
  TVDfld      wtFld, countFld, cgFld;
  IGRchar     weight[256], ccnt[256], ctrgrav[256], buf[256], null[256];
  IGRchar     c;

  // init
  retFlag = 0;
  sprintf(null,"");
  wt = 0.0;
  count = 0;
  
  // arg check
  if (NODE_PARENT_ID.objid == NULL_OBJID) goto wrapup;

  // get all the children 
  for (i = 0; (vdct1$GetTree1Child(objID = &NODE_PARENT_ID,       
				   nth   = i,    
				   outID = &childID)); i = i + 1) {
    
    // with each child get the attribute data to be processed
    vdcol$GetAttr(objID = &childID, name = VDCT1_ATTR_WEIGHT, fld = &wtFld);  
    strcpy(weight,wtFld.val.txt);
    if (!isdigit(weight[0])) strcpy(weight,"0.0");
    
    wtChild = atof(weight);
    
    vdcol$GetAttr(objID = &childID, name = VDCT1_ATTR_COUNT, fld = &countFld);  
    strcpy(cnt,countFld.val.txt);
    if (!isdigit(ccnt[0])) strcpy(ccnt,"0");
    countChild = atoi(ccnt);
  
    // process each child attribute data if needed

    // get the totals  
    wt = wt + wtChild;
    count = count + countChild;
  }

  // send the totals where they belong
    vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_WEIGHT, fld = &wtFld); 
    sprintf(buf,"%f",wt);
    strcpy(wtFld.val.txt,buf);    
    vdcol$UpdAttrs(objID = &NODE_PARENT_ID, cnt = 1, fld = &wtFld);    

    vdcol$GetAttr(objID = &NODE_PARENT_ID, name = VDCT1_ATTR_COUNT, fld = &countFld); 
    sprintf(buf,"%d",count);
    strcpy(countFld.val.txt,buf);
    vdcol$UpdAttrs(objID = &NODE_PARENT_ID, cnt = 1, fld = &countFld);  
  
    // keep the KG in the UNIT_WT attribute by updating it.
    setAttributeUnitWt();

  // get the next parent up the tree
    vdct1$GetTree1Parent(objID = &NODE_PARENT_ID, outID = &parentID);  
    NODE_PARENT_ID.objid = parentID.objid;
    NODE_PARENT_ID.osnum = parentID.osnum;

wrapup:
  return retFlag;
  
}
/* --------------------------------------------------
 * Called when node is created
 * I - NODE_PARENT_ID       If NULL_OBJID, top node, use SET_ID
 * I - SET_ID               Used for top node in tree
 * I - NODE_TYPE
 * I - NODE_NAME
 * O - NODE_ID
 *
 * Not alot of error checking here, rely on the
 * calling program to do things right    
 */
IGRstat createNodex()
{
  IGRstat       retFlag,sts;
  TVDfld        fld;
  IGRchar       buf[128];
  IGRint       *a_minoIndex;
  
  TVDfld        groupFld;
  TVDfld        hullFld;
  TVDfld        unitFld;  
  TVDctBaseInfo parentBaseInfo;
  

  // Init
  retFlag = 0;
  
  NODE_ID.objid = NULL_OBJID;

  if (NODE_PARENT_ID.objid == NULL_OBJID) NODE_ID.osnum = SET_ID.osnum;
  else                                    NODE_ID.osnum = NODE_PARENT_ID.osnum;
  
  // Make the set object
  vdct1$CreateBaseObject(osnum     = NODE_ID.osnum,
                         classType = VDCT1_CLASS_TYPE_NODE,
                         objID     = &NODE_ID);
  if (NODE_ID.objid == NULL_OBJID) goto wrapup;

  // Connect to parent or the set
  if (NODE_PARENT_ID.objid == NULL_OBJID) {
    
    vdct1$ConnectMgrChild(mgrID   = &SET_ID,
			  childID = &NODE_ID);

    vdct1$GetBaseInfo(objID = &SET_ID, baseInfo = &BASE_INFO);

  vdct1$SetBaseInfo(objID = &NODE_ID, baseInfo = &BASE_INFO);
  }
  else {
    vdct1$ConnectTree1Child(treeID  = &NODE_PARENT_ID,
			    childID = &NODE_ID);

    vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &BASE_INFO);
  }

  // Set info
  strcpy(BASE_INFO.nodeName,NODE_NAME);
  strcpy(BASE_INFO.nodeType,NODE_TYPE);
  vdct1$SetBaseInfo(objID = &NODE_ID, baseInfo = &BASE_INFO);

  // Sets ATTR_NAMEX for each available attribute
  for(ATTR_INDEX = 0; getNodeAttrName(); ATTR_INDEX = ATTR_INDEX + 1) {
     
    // Get the full info
    getAttrInfo();

    // Check for setup error
    if (*ATTR_INFO.name != 0) {
	
      vdfld$Set(fld  = &fld, 
		name = ATTR_INFO.name, 
		type = ATTR_INFO.type);

      vdcol$UpdAttrs(objID = &NODE_ID, 
		     fld   = &fld, 
		     cnt   = 1);
    }
  }

  // Pull down some values and set them
  // GROUP, ENG_ASSY[2], ENG_ASSY{6], ASSY[2] and some to PARTS
  pullDownAttribute(VDCT1_ATTR_AV_HULL);
  pullDownAttribute(VDCT1_ATTR_CONT_HULL);
  pullDownAttribute(VDCT1_ATTR_COST_CODE);
  pullDownAttribute(VDCT1_ATTR_COM_CODE);
  pullDownAttribute(VDCT1_ATTR_LABOR_CODE);
  pullDownAttribute(VDCT1_ATTR_ZONE);
  pullDownAttribute(VDCT1_ATTR_UNIT);
  pullDownAttribute(VDCT1_ATTR_COMPARTMENT);
  pullDownAttribute(VDCT1_ATTR_DWG_NUM);
  pullDownAttribute(VDCT1_ATTR_DETAIL);
  pullDownAttribute(VDCT1_ATTR_PALLET);
  pullDownAttribute(VDCT1_ATTR_LINE_IDENT);
  pullDownAttribute(VDCT1_ATTR_MINO);
  pullDownAttribute(VDCT1_ATTR_MINO_ISDP);
  pullDownAttribute(VDCT1_ATTR_FIAN);
  pullDownAttribute(VDCT1_ATTR_ISDP_NAME);
  pullDownAttribute(VDCT1_ATTR_STOCK);
  pullDownAttribute(VDCT1_ATTR_UNIT_WT);
  pullDownAttribute(VDCT1_ATTR_DESC);
  pullDownAttribute(VDCT1_ATTR_REMARKS);
  pullDownAttribute(VDCT1_ATTR_REVISION);
  pullDownAttribute(VDCT1_ATTR_ASSY_DATE);
  pullDownAttribute(VDCT1_ATTR_FROZEN);
 
 
  // Some initial setting
  setAttributeCount();

  // Do some computing
  computeMino();
  computeDate   (VDCT1_ATTR_ASSY_DATE);
  computeVersion(VDCT1_ATTR_REVISION);
  
  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
/* ------------------------------------------------
 * Controls
 * createNodex() operation
 * I - NODE_PARENT_ID       If NULL_OBJID, top node, use SET_ID
 * I - SET_ID               Used for top node in tree
 * I - NODE_TYPE
 * I - NODE_NAME
 * O - NODE_ID
 */ 
IGRstat createNode()
{
  IGRint        retFlag;
  IGRint        sts, I;
  TGRid         fndNodeID, partNodeID, nodeID, parentID, parentNodeID;
  IGRchar       parentName[128], buf[256];
  TVDctNodeType a_nodeType;
  IGRchar       partEquipNo[256], unitEquipNo[256], nullString[256];
  TVDctBaseInfo baseInfo;
  IGRstat       traceFlag;
  
  traceFlag = 0;
  
  retFlag   = 0;
  sts = 0;
  sprintf(nullString,"");
  if (traceFlag) printf(">>> createNode\n");
  
  // check if the dataBase is closed
  sts =  VDSverify_login();

  // check the rules if the dataBase is closed
  if(!(sts & 1)){
  
  // Rule: if the dataBase is closed no making ENGASSY
    //if (!strcmp(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ENGASSY)) {
    printf("Error: Database Closed\nThis action requires an open Database\n\n");
    //goto wrapup;
     //}
    
  }
  
  // save existing name
  vdct1$GetBaseInfo(objID = &NODE_PARENT_ID, baseInfo = &BASE_INFO); 
  strcpy(parentName,BASE_INFO.nodeName);

  // make the first node
  sts = createNodex(); 

  // all tests done
  retFlag = 1  ;

  // oh well
wrapup:
  if (traceFlag) printf("<<< createNode %d\n",retFlag);
  
  return retFlag;
}

/* --------------------------------------------------
 * Called when set is created
 * I - MGR_ID       set is linked to it, created using mgr osnum
 * I - SET_TYPE     Little bit redundant, keep for now
 * I - SET_TYPE_REV Use unless blank then use default
 * I = SET_NAME
 * O - SET_ID       NULL_OBJID if fails
 *
 * Not alot of error checking here, rely on the
 * calling program to check things
 */

IGRstat createSet()
{
  IGRstat       retFlag;
  TVDctBaseInfo baseInfo;
  
  // Init
  retFlag = 0;
  SET_ID.objid = NULL_OBJID;
 
  // Make the set object
  vdct1$CreateBaseObject(osnum     = MGR_ID.osnum,
                         classType = VDCT1_CLASS_TYPE_SET,
                         objID     = &SET_ID);

  if (SET_ID.objid == NULL_OBJID) goto wrapup;

  // Connect to manager
  vdct1$ConnectMgrChild(mgrID   = &MGR_ID,
   		        childID = &SET_ID);

  // Set info
  memset(&baseInfo,0,sizeof(TVDctBaseInfo));
  strcpy(baseInfo.setName,SET_NAME);
  strcpy(baseInfo.setType,SET_TYPE);

  if (*SET_TYPE_REV) strcpy(baseInfo.setTypeRev,SET_TYPE_REV);
  else {
    getSetTypeInfo();
    strcpy(baseInfo.setTypeRev,SET_TYPE_INFO.rev);
  }
  
  vdct1$SetBaseInfo(objID = &SET_ID, baseInfo = &baseInfo);

  // Create Top Level Node
  strcpy(NODE_TYPE,VDCT1_ENG_NODE_TYPE_ENGTREE);
  strcpy(NODE_NAME,SET_NAME);
  NODE_PARENT_ID.objid = NULL_OBJID; 

  createNode();

  // Done
  retFlag = 1;
  
wrapup:
  return retFlag;
}
// ------------------------------------
// used to compute attributes after the modelOE is attached
IGRstat computeNodeAttr()
{
  IGRstat retFlag;
  IGRstat traceFlag;
  
  //init
  retFlag = 0;
  traceFlag = 0;
  

  if (traceFlag) printf(">>> computeNodeAttr\n");
  // add the computations locations here for modelOE dB access!
  computeWeight();

  // success
  retFlag = 1;
  // go home
wrapup:
  if (traceFlag) printf("<<< computeNodeAttr(%d)\n",retFlag);
  
  return retFlag;
  
}

// ------------------------------------

IGRstat pplNodeRulesOK()
{ 
  IGRstat retFlag;

  retFlag = 1;

  // put rules for universal application here
  // set retFlag = 0; to prevent action

  // location checks
  // -------------------  Rename Rules -----------------------------------
  // is renaming allowed for this item?
  if (!strcmp(LOCATION,VDCT1_ACTION_RENAME_NODE)) {

    // Rule: PART node 
    if (strcmp(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART))     retFlag = 0;
 
  }

  // ------------------- Duplicate Rename Rules --------------------------
  // duplicate Rename names prevented?
  if (!strcmp(LOCATION,VDCT1_ACTION_R_NODE_DUP)) {

    // Rule: YES to All
    
    goto wrapup;
  }

  // ------------------ Deletion Rules -----------------------------------
  // do we delete?  uses BASE_INFO_PARENT only 
  if (!strcmp(LOCATION,VDCT1_ACTION_DELETE_NODE)) {

    // Rule: YES to All

    goto wrapup;

  }  

  // ----------------- Creation of Duplicate Node Rules ------------------
  // do we test for duplicates in Create Node?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_NODE_DUP)) {
  
    // Rule: Yes to All

    goto wrapup;
  } 

  // ----------------- Model Node Creation Rules ------------------------
  // do we test for duplicates in CreateModelNode?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_MODEL_NODE)) {
   
    // Rule:Any Item selected from a model has to be a part
    // this may change but for now it is a part
    strcpy(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART);
    // There is no reset of the retFlag it is OK to continue
 
    goto wrapup;
  }

  // ----------------- Model Node Creation Attr Rules -----------------
  // do we create this node?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_MODEL_ATTRS)) { 
    
    // Rule:
    strcpy(BASE_INFO.nodeType,VDCT1_ENG_NODE_TYPE_PART);
    goto wrapup;
    }
 
  // ----------------- Model Node Creation Attr Rules -----------------
  // do we go compute the attribute values?
  if (!strcmp(LOCATION,VDCT1_ACTION_C_MODEL_ATTR)) { 
    
    // Rule: Yes to All
    goto wrapup;
    }

wrapup:
  // lets send back the baseInfo 
  ACTION_OK = retFlag;
  
  return retFlag;
}










