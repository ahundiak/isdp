/* $Id: split_poles.u,v 1.1.1.1 2001/01/04 21:09:03 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/vdppl / split_poles.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: split_poles.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:03  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.2  1998/02/05  21:24:34  pinnacle
# Replaced: vdppl/split_poles.u for:  by mdong for vds
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.2  1995/11/16  05:28:04  pinnacle
# Replaced: vdppl/split_poles.u for:  by ksundar for vds.240
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *	11/16/95	Sundar		deaclared system as extern int
 * -------------------------------------------------------------------*/

/*
  This command will find and separate cooincident poles on a given set
	of surfaces. This was written to alleviate a problem encountered 
	with files created from the hull design tool "fastship"

   Written by Jim Hanson
   Date		8/3/92
*/

#include <stdio.h>

#include "cieveryone.h"
#include "cimacros.h"
#include "cigetargs.h"
//#include "ci_easy.h"
// extern	void		EMinitvgcnstr();
// extern	IGRboolean	EMgetvgcnstr();
#include "ci_surface.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "growner.h"
#include "msdef.h"
#include "EMSsfparms.h"
#include "grdpbmacros.h"
#include "grdpb.h"

short  		OMsts,last;
char 		name[30], *ptr, string1[132], string2[132];
struct		GRevent grevent;
struct GRmd_env	MOD_ENV12;
struct GRid	SURFACE;
double		vec1[3],vec2[3],vec3[3],vec4[3],vec5[3];
double		vlen1, vlen2, vlen, inc, tst, pnt[3];
int		i,j,k,unum,vnum, comb, count;
struct GRid	set_grid;     /* GRid of the graphic set */
IGRlong		resp;
struct IGRbsp_surface	*bsp;
struct GRobj_env *if_obj;
struct GRid	fence_grid,clipping_grid;
struct GRid	*l_obj;
IGRint		icount, countb, countc, size_ob, surf_count,start;
GRspacenum	osnum;
double		mult;
extern int 	GRfindmod();
extern int 	system();
//extern char	strrchr();
char		tst1[132], tst2[132];
FILE		*file_ptr;


main( argc, argv)
int	argc;
char	**argv;
{
double	cht;
int	tval,i;
extern int GRdpb_get();

  file_ptr = NULL;

  system("who am i > /usr/tmp/me");

  file_ptr = fopen( "/usr/tmp/me", "r" );
  fgets( name, 80, file_ptr );
  fclose( file_ptr );

  strcpy(tst1 , strrchr((char *)argv[0],'/'));

  tval=0;

  for(i=0;i<strlen(tst1);i=i+1) {
	tst1[i]=tst1[i+1];
	tval=tval+tst1[i];
  }

  if( strcmp(tst1,"split_poles") != 0 || tval != 1198 )
  {
	strcpy(tst2,"Hey \"");
	strcat(tst2,name);
	strcat(tst2,"\", my name is split_poles.e! ");
	status(tst2);
	exit;
  }

  GRfindmod(&dspGRid);

  message("Find and separate coincident poles");
  ci$get_module_info( md_env = &MOD_ENV12);

  gr$get_chord_height_tolerance(msg = &msg,
                              sizbuf = sizeof(double),
                              buffer = &cht,
                              nret = NULL);
#ifdef DEBUG
  write("cht=",cht,'\n');
#endif

  strcpy(tst2,"Key in offset value[");
  strcat(tst2,ntoa(cht*2));
  strcat(tst2,"]");
  ci$get(value=inc, prompt=tst2);
  if(inc < cht*2) inc = cht*2;


  while(1)
  {
	surf_count = 0;

	ci$getevent(	event 		= &grevent,
			response 	= &resp ,
			prompt		= "Locate set to check" ,
			stackable 	= 1 ,
			mask 		= GRm_SPECIFIED_OBJ | GRm_RESET | GRm_DATA);

 	set_grid.objid = grevent.located_object[0].located_obj.objid;
 	set_grid.osnum = grevent.located_object[0].located_obj.osnum;

	#ifdef DEBUG
	  write("resp=",resp,'\n');
	#endif
	if( resp == 1) 
	{
		mod_surf1(); 
		continue;
	}

	if( resp == RESET) break;
	if( resp == SPECIFIED_OBJ ) 
	{
		/* get clipping polygon */

		gr$gsget_fence( msg = &msg,fence_id = &clipping_grid );

		if( msg != MSSUCC ) clipping_grid.objid = NULL_OBJID;

		countc = 0;

        	gr$gsinqcount(	msg = &msg,
			count = &countc,
			senderid = NULL_OBJID,
			object_id = &set_grid );
			
        	if( msg != MSSUCC ) 
		{ 
			write( "gr$gsinqcount failed" ); 
			exit; 
		}

		#ifdef DEBUG
		  write( countc," objects in fence \n");
		#endif

		size_ob = countc * sizeof( struct GRobj_env );

		ptr = malloc( size_ob );

		if_obj = ( struct GRobj_env *) ptr;

        	if(  if_obj == NULL) 
		{ 
			write( "malloc failed" ); 
			exit; 
		}

		l_obj  = ( struct GRid * ) if_obj;

        	gr$gsget_objects(	msg = &msg,
					array = if_obj,
					size = size_ob,
					count = &countc,
					from_obj = 0,
					to_obj  = countc - 1,
					senderid = NULL_OBJID,
					object_id = &set_grid);

		#ifdef DEBUG
		  write("got past gr$gsget_objects\n");
		#endif

		for( icount=0; icount<countc; icount=icount+1 ) 
		{

			/* Skip objects not in selected osnum. */
			if( MOD_ENV12.md_id.osnum != if_obj[icount].obj_id.osnum ) continue;

			/* Do not take clipping polygon */
		       	if(   if_obj[icount].obj_id.objid == clipping_grid.objid
	        	   && if_obj[icount].obj_id.osnum == clipping_grid.osnum )
								 continue;

			l_obj[countb].objid = if_obj[icount].obj_id.objid;
			l_obj[countb].osnum = if_obj[icount].obj_id.osnum;
			countb = countb + 1;

			OMsts = om$get_classname( objid	= l_obj[countb-1].objid,
						  osnum	= l_obj[countb-1].osnum,
                	        		  classname	= name  );

			#ifdef DEBUG
			  write("checking ancestry\n");
			#endif

			if( om$is_ancestry_valid( subclassname = name,
				  superclassname = "EMSsubbs" ) == 1 )
			{
				mod_surf1();
			}
 		}/* end of for( icount=0; icount<countc; icount=icount+1 )*/

	}/* end of if( resp == SPECIFIED_OBJ )*/

  }/* end of while(1) */

}/* end of main() */

mod_surf1()
{
  surf_count = surf_count +1;
  strcpy( string1,"checking suface ");
  strcat( string1, itoa(surf_count));
  status(string1);

#ifdef DEBUG
  write("found a surface\n");
#endif

  SURFACE = l_obj[countb-1];

  md$get_surface_geometry( GRid_in = SURFACE, surface_struct = bsp);

  display = 1; // erase
  ci$send(msg = message GRgraphics.GRdisplay( 
		&msg, 
		&MOD_ENV.md_env.matrix_type, 
		MOD_ENV.md_env.matrix, 
		&display,
		&dspGRid), 
  targetid = SURFACE.objid, 
  targetos = SURFACE.osnum);

#ifdef DEBUG
  write("GRdisplay msg=",msg,'\n');
#endif

  unum = bsp->u_num_poles;
  vnum = bsp->v_num_poles;
  count = 0;
  last = 0;
  for(i=0;i<unum;i=i+1)
  {
	for(j=0;j<vnum;j=j+1)
	{
		comb=i*3+j*3*unum;

		#ifdef DEBUG
		write("i,u[",i,"], j,v[",j,"], comb[",comb,"], ",
			bsp->poles[comb+0],bsp->poles[comb+1],bsp->poles[comb+2],"\n");
		#endif



		if( comb+3*unum > unum*(vnum-1)*3 )
		{
		    	last = 2;
			#ifdef DEBUG
			write("END\n");
			#endif
		}
		else if( j == 0 )
		{
			last = 0;
			start = 1;
			#ifdef DEBUG
			write("START\n");
			#endif
		}
		else if(start == 0)
		{
			last=1;
			#ifdef DEBUG
			write("MIDDLE\n");
			#endif
		}
		
		/* check if the poles are on top of each other */
		if(
		   bsp->poles[comb+0] == bsp->poles[comb+3*unum+0] &&
		   bsp->poles[comb+1] == bsp->poles[comb+3*unum+1] &&
	  	   bsp->poles[comb+2] == bsp->poles[comb+3*unum+2])
		{

			#ifdef DEBUG
			write("we have found identical poles, start=",start,'\n');
			#endif
			count=count+1;
			continue;
		}else {start = 0;}
			
		if(count > 0)
		{
			strcpy(string2, string1);
			strcat(string2,", adjusting u ");
			strcat(string2, itoa(count+1));
			strcat(string2, " poles");
			status(string2);

			/* GET THE VECTOR DIRECTION TO THE NEXT POLE */
			if( last == 2)
			{

				for(k=0;k<3;k=k+1)
				vec1[k]=bsp->poles[comb-((count+1)*3*unum)+k]-
						bsp->poles[comb+k];

				#ifdef DEBUG
		    		write("We are at the last pole. Count=",count,'\n');
				write("dup[",
					bsp->poles[comb+0],
					bsp->poles[comb+1],
					bsp->poles[comb+2],
					"]\npre[",
					bsp->poles[comb-((count+1)*3*unum)+0],
					bsp->poles[comb-((count+1)*3*unum)+1],
					bsp->poles[comb-((count+1)*3*unum)+2],
					"]\n");
				#endif			
			}
			else if( last == 0)
			{
				for(k=0;k<3;k=k+1)
					vec1[k]=bsp->poles[comb+3*unum+k]-
						bsp->poles[comb+k];
				#ifdef DEBUG
				write("dup[",bsp->poles[comb+0],
					bsp->poles[comb+1],
					bsp->poles[comb+2],"]\nnxt[",
					bsp->poles[comb+(3*unum)+0],
					bsp->poles[comb+(3*unum)+1],
					bsp->poles[comb+(3*unum)+2],
					"]\n");	
				#endif
			}
			else
			{
				for(k=0;k<3;k=k+1)
				{
				vec2[k]=bsp->poles[comb+k]-
					bsp->poles[comb-((count+1)*3*unum)+k];
				vec1[k]=bsp->poles[comb+k]-
					bsp->poles[comb+3*unum+k];
				}
				#ifdef DEBUG
				write( "pre[",
					bsp->poles[comb-((count+1)*3*unum)+0],
					bsp->poles[comb-((count+1)*3*unum)+1],
					bsp->poles[comb-((count+1)*3*unum)+2],
					"]\ndup[",
					bsp->poles[comb+0],
					bsp->poles[comb+1],
					bsp->poles[comb+2],
					"]\nnxt[",
					bsp->poles[comb+(3*unum)+0],
					bsp->poles[comb+(3*unum)+1],
					bsp->poles[comb+(3*unum)+2],
					"]\n");
				#endif
			}

			/* COMPUTE THE LENGTH OF THE VECTOR */
			vlen1=sqrt(vec1[0]*vec1[0]+vec1[1]*vec1[1]+vec1[2]*vec1[2]);
			vlen2=sqrt(vec2[0]*vec2[0]+vec2[1]*vec2[1]+vec2[2]*vec2[2]);

			#ifdef DEBUG 
			write("vec1=",vec1,vlen1,"\nvec2=",vec2,vlen2,'\n');
			#endif

			/* CREATE A NEW VECT THE LEN OF THE KEYED IN OFFSET */

			if( count*inc > vlen1)
			{
				#ifdef DEBUG
				write("u dir using 1/(count+1), vlen1=",vlen1," count=",count,"vlen1/count+1=",vlen1/(count+1),"\n");
				#endif
				v_scale(vec1,vlen1/((count+2)*v_len(vec1)),vec3);
			}
			else
			{
				#ifdef DEBUG
				write("u dir using inc\n");
				#endif
				v_scale(vec1,inc/v_len(vec1),vec3);
			}

			if( count*inc > vlen2)
			{
				#ifdef DEBUG
				write("u dir using 1/(count+2), vlen2=",vlen2,"vlen2/((count+2)*v_len(vec2))=",vlen2/((count+2)*v_len(vec2)),"\n");
				#endif
				v_scale(vec2,vlen2/((count+2)*v_len(vec2)),vec4);
			}
			else
			{
				#ifdef DEBUG
				write("u dir using inc\n");
				#endif
				v_scale(vec2,inc/v_len(vec2),vec4);
			}


			/* ADJUST THE POLES ON THE SURFACE */

			mult = count/2.0;
			for( k=0;k<count+1;k=k+1)
			{
				if(last != 1 && k == count) 
				{
					#ifdef DEBUG
					write("last=",last,", count=",count,", and k=",k,", so I'm breaking\n");
					#endif
					break;
				}

				#ifdef DEBUG
				write("count[",count,"], u[",i,"], v[",j-(count-k)-1,"]\n");
				#endif


				if( last == 0)
				{
				bsp->poles[comb-(k*3*unum)+0] = 
					bsp->poles[comb-(k*3*unum)+0] + 
					(vec3[0]*(count-k));
				bsp->poles[comb-(k*3*unum)+1] = 
					bsp->poles[comb-(k*3*unum)+1] + 
					(vec3[1]*(count-k));
				bsp->poles[comb-(k*3*unum)+2] = 
					bsp->poles[comb-(k*3*unum)+2] + 
					(vec3[2]*(count-k));
				}
				else if( last == 2)
				{

				bsp->poles[comb-((count-k)*3*unum)+0] = 
					bsp->poles[comb-((count-k)*3*unum)+0] + 
					(vec3[0]*(count-k));
				bsp->poles[comb-((count-k)*3*unum)+1] = 
					bsp->poles[comb-((count-k)*3*unum)+1] + 
					(vec3[1]*(count-k));
				bsp->poles[comb-((count-k)*3*unum)+2] = 
					bsp->poles[comb-((count-k)*3*unum)+2] + 
					(vec3[2]*(count-k));
				}
				else
				{

				#ifdef DEBUG
				write("pole num=",comb-((count-k)*3*unum),'\n');
				write("bf mod[",bsp->poles[comb-((count-k)*3*unum)+0],',');
				write(bsp->poles[comb-((count-k)*3*unum)+1],',');
				write(bsp->poles[comb-((count-k)*3*unum)+2],"]\n");
				#endif
					if( k >= count/2.0)
					{
						if(mult < 0) mult=mult+1;
						#ifdef DEBUG
						write("k>=count/2, len mult=",mult,"\n");
						#endif
						v_equal(vec4,vec5);
						bsp->poles[comb-((count-k)*3*unum)+0] = 
							bsp->poles[comb-((count-k)*3*unum)+0] + 
							(vec5[0]*mult);
						bsp->poles[comb-((count-k)*3*unum)+1] = 
							bsp->poles[comb-((count-k)*3*unum)+1] + 
							(vec5[1]*mult);
						bsp->poles[comb-((count-k)*3*unum)+2] = 
							bsp->poles[comb-((count-k)*3*unum)+2] + 
							(vec5[2]*mult);
						mult=mult+1;

					}
					else
					{
						#ifdef DEBUG
						write("k<count/2, mult=",mult,"\n");
						#endif
			
						v_equal(vec3,vec5);
						bsp->poles[comb-((count-k)*3*unum)+0] = 
							bsp->poles[comb-((count-k)*3*unum)+0] + 
							(vec5[0]*mult);
						bsp->poles[comb-((count-k)*3*unum)+1] = 
							bsp->poles[comb-((count-k)*3*unum)+1] + 
							(vec5[1]*mult);
						bsp->poles[comb-((count-k)*3*unum)+2] = 
							bsp->poles[comb-((count-k)*3*unum)+2] + 
							(vec5[2]*mult);
						mult=mult-1;
					}
					#ifdef DEBUG
					write("af mod[",bsp->poles[comb-((count-k)*3*unum)+0],',');
					write(bsp->poles[comb-((count-k)*3*unum)+1],',');
					write(bsp->poles[comb-((count-k)*3*unum)+2],"]\n");
					#endif
				}

				#ifdef DEBUG
				ci$get(point = pnt);
				#endif

			}/* end of for( k=0;k<count;k=k+1)*/
		}/* end of if(count > 0)*/
		last=0;
		count=0;
	}/*end of for(j=0;j<vnum;j=j+1)*/
  }/*end of for(i=0;i<unum;i=i+1)*/

  count = 0;
  for(i=0;i<vnum;i=i+1)
  {
	for(j=0;j<unum;j=j+1)
	{
		comb=(i*3*unum)+(j*3);
		#ifdef DEBUG
		write("i,v[",i,"], j,u[",j,"], comb[",comb,"], next[", 
			comb+3*unum,"] ", bsp->poles[comb+0],
			bsp->poles[comb+1], bsp->poles[comb+2],'\n');
		#endif

		//if( comb+3*unum > unum*(vnum-1)*3)
		if( j >= unum - 1)
		{
		    	last = 2;
			#ifdef DEBUG
			write("END\n");
			#endif
		}
		else if( j == 0 )
		{
			last = 0;
			start = 1;
			#ifdef DEBUG
			write("START\n");
			#endif
		}
		else if(start == 0)
		{
			last=1;
			#ifdef DEBUG
			write("MIDDLE\n");
			#endif
		}

		if( bsp->poles[comb+0] ==  bsp->poles[comb+3] &&
		    bsp->poles[comb+1] ==  bsp->poles[comb+4] &&
		    bsp->poles[comb+2] ==  bsp->poles[comb+5])		
		{

			#ifdef DEBUG
			write("we have found identical poles\n");
			#endif
			count=count+1;
			continue;
		}else {start = 0;}

		if(count > 0)
		{
			strcpy(string2, string1);
			strcat(string2,", adjusting v ");
			strcat(string2, itoa(count+1));
			strcat(string2, " poles");
			status(string2);

			/* GET THE VECTOR DIRECTION TO THE NEXT POLE */
			if( last == 2)
			{
				for(k=0;k<3;k=k+1)
				   vec1[k]=bsp->poles[comb-((count+1)*3)+k]-
					bsp->poles[comb+k];
				#ifdef DEBUG
		    		write("We are at the last pole. Count=",count,'\n');
				write("last [",comb-((count+1)*3)+k,"]-[",comb+k,"]\n");
				write( "dup[",
					bsp->poles[comb+0],
					bsp->poles[comb+1],
					bsp->poles[comb+2],
					"]\npre[",
					bsp->poles[comb-((count+1)*3)+0],
					bsp->poles[comb-((count+1)*3)+1],
					bsp->poles[comb-((count+1)*3)+2],
					"]\n");
				#endif			
			}
			else if( last == 0)
			{
				for(k=0;k<3;k=k+1)
					vec1[k]=bsp->poles[comb+3+k]-
						bsp->poles[comb+k];
				#ifdef DEBUG
				write("dup[",
					bsp->poles[comb+0],
					bsp->poles[comb+1],
					bsp->poles[comb+2],
					"]\nnxt[",
					bsp->poles[comb+3+0],
					bsp->poles[comb+3+1],
					bsp->poles[comb+3+2],
					"]\n");
				#endif	
			}
			else
			{
				for(k=0;k<3;k=k+1)
				{
				vec2[k]=bsp->poles[comb+k]-
					bsp->poles[comb-((count+1)*3)+k];
				vec1[k]=bsp->poles[comb+k]-
					bsp->poles[comb+3+k];
				}

				#ifdef DEBUG
				write( "pre[",
					bsp->poles[comb-((count+1)*3)+0],
					bsp->poles[comb-((count+1)*3)+1],
					bsp->poles[comb-((count+1)*3)+2],
					"]\ndup[",
					bsp->poles[comb+0],
					bsp->poles[comb+1],
					bsp->poles[comb+2],
					"]\nnxt[",
					bsp->poles[comb+(3)+0],
					bsp->poles[comb+(3)+1],
					bsp->poles[comb+(3)+2],
					"]\n");
				#endif			
			}


			/* COMPUTE THE LENGTH OF THE VECTOR */
			vlen1=sqrt(vec1[0]*vec1[0]+vec1[1]*vec1[1]+vec1[2]*vec1[2]);
			vlen2=sqrt(vec2[0]*vec2[0]+vec2[1]*vec2[1]+vec2[2]*vec2[2]);

			#ifdef DEBUG 
			write("vec1=",vec1,vlen1,"\nvec2=",vec2,vlen2,'\n');
			#endif

			/* CREATE A NEW VECT THE LEN OF THE KEYED IN OFFSET */



			if( count*inc > vlen1)
			{
				#ifdef DEBUG
				write("v dir using vlen1=",vlen1," vlen1/((count+2)*v_len(vec1)=",vlen1/((count+2)*v_len(vec1)),"\n");
				#endif
				v_scale(vec1,vlen1/((count+2)*v_len(vec1)),vec3);
			}
			else
			{
				#ifdef DEBUG
				write("v dir using inc\n");
				#endif
				v_scale(vec1,inc/v_len(vec1),vec3);
			}

			if( count*inc > vlen2)
			{
				#ifdef DEBUG
				write("v dir using  vlen2=",vlen2,"1/count+2=",1/(count+2),"\n");
				#endif
				v_scale(vec2,vlen2/((count+2)*v_len(vec2)),vec4);
			}
			else
			{
				#ifdef DEBUG
				write("v dir using inc\n");
				#endif
				v_scale(vec2,inc/v_len(vec2),vec4);
			}

			/* ADJUST THE POLES ON THE SURFACE */


			mult = count/2.0;
			for( k=0;k<count+1;k=k+1)
			{
				if(last != 1 && k == count) 
				{
					#ifdef DEBUG
					write("last=",last,", count=",count,", and k=",k,", so I'm breaking\n");
					#endif
					break;
				}

				#ifdef DEBUG
				write("count[",count,"], u[",i,"], v[",j-(count-k)-1,"]\n");
				#endif

				if( last == 0)
				{
					#ifdef DEBUG
					write("start pole[",comb-(k*3),"]\n");
					#endif
					bsp->poles[comb-(k*3)+0] = 
						bsp->poles[comb-(k*3)+0] + 
						(vec3[0]*(count-k));
					bsp->poles[comb-(k*3)+1] = 
						bsp->poles[comb-(k*3)+1] + 
						(vec3[1]*(count-k));
					bsp->poles[comb-(k*3)+2] = 
						bsp->poles[comb-(k*3)+2] + 
						(vec3[2]*(count-k));
				}
				else if( last == 2)
				{
					#ifdef DEBUG
					write("END pole[",comb-((count-k)*3),"]\n");
					#endif

					bsp->poles[comb-((count-k)*3)+0] = 
						bsp->poles[comb-((count-k)*3)+0] + 
						(vec3[0]*(count-k));
					bsp->poles[comb-((count-k)*3)+1] = 
						bsp->poles[comb-((count-k)*3)+1] + 
						(vec3[1]*(count-k));
					bsp->poles[comb-((count-k)*3)+2] = 
						bsp->poles[comb-((count-k)*3)+2] + 
						(vec3[2]*(count-k));

				}
				else
				{

					#ifdef DEBUG
					write("pole num=",comb-((count-k)*3),'\n');
					write("bf mod[",bsp->poles[comb-((count-k)*3)+0],',');
					write(bsp->poles[comb-((count-k)*3)+1],',');
					write(bsp->poles[comb-((count-k)*3)+2],"]\n");
					#endif
					if( k >= count/2.0)
					{
						if(mult < 0) mult=mult+1;
						#ifdef DEBUG
						write("k>=count/2, len mult=",mult,"\n");
						#endif
						v_equal(vec4,vec5);
						bsp->poles[comb-((count-k)*3)+0] = 
							bsp->poles[comb-((count-k)*3)+0] + 
							(vec5[0]*mult);
						bsp->poles[comb-((count-k)*3)+1] = 
							bsp->poles[comb-((count-k)*3)+1] + 
							(vec5[1]*mult);
						bsp->poles[comb-((count-k)*3)+2] = 
							bsp->poles[comb-((count-k)*3)+2] + 
							(vec5[2]*mult);
						mult=mult+1;
					}
					else
					{
						#ifdef DEBUG
						write("k<count/2, mult=",mult,"\n");
						#endif
						v_equal(vec3,vec5);
						bsp->poles[comb-((count-k)*3)+0] = 
							bsp->poles[comb-((count-k)*3)+0] + 
							(vec5[0]*mult);
						bsp->poles[comb-((count-k)*3)+1] = 
							bsp->poles[comb-((count-k)*3)+1] + 
							(vec5[1]*mult);
						bsp->poles[comb-((count-k)*3)+2] = 
							bsp->poles[comb-((count-k)*3)+2] + 
							(vec5[2]*mult);
						mult=mult-1;
					}
					#ifdef DEBUG
					write("af mod[",bsp->poles[comb-((count-k)*3)+0],',');
					write(bsp->poles[comb-((count-k)*3)+1],',');
					write(bsp->poles[comb-((count-k)*3)+2],"]\n");
					#endif
				}

				#ifdef DEBUG
				ci$get(point = pnt);
				#endif
			}/* end of for(count) */
		} /* end of if(count > 0) */
		last=0;
		count=0;
	}/* end of for(j=0;j<unum;j=j+1) */
  }/* end of for(i=0;i<vnum;i=i+1)*/

post:

  size_of_surface = 0;
  ci$send( msg = message GRvg.GRpostabsg( 
		&msg,
		&MOD_ENV12,
		&size_of_surface,
		bsp,
		&SURFACE.objid ),
  targetid = SURFACE.objid,
  targetos = SURFACE.osnum );

#ifdef DEBUG
  write("GRpostabsg msg =",msg,'\n');
#endif


  display = 0; // draw
  ci$send(msg = message GRgraphics.GRdisplay( 
		&msg, 
		&MOD_ENV.md_env.matrix_type, 
		MOD_ENV.md_env.matrix, 
		&display,
		&dspGRid), 
  targetid = SURFACE.objid, 
  targetos = SURFACE.osnum);

#ifdef DEBUG
  write("GRdisplay msg=",msg,'\n');
#endif

  status("");	
  if (ptr != NULL)  free(ptr);
  if (bsp != NULL) free( bsp);
}
