/* $Id: COz_FixRT1.u,v 1.1 2001/01/18 20:38:22 hans Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/vdppl/COz_FixRT.u
 *
 * Description: Empty the refill the range tree
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COz_FixRT1.u,v $
 *	Revision 1.1  2001/01/18 20:38:22  hans
 *	SP16 additions/modifications
 *	
# Revision 1.2  2000/10/25  18:26:02  pinnacle
# Replaced: vds/vdppl/COz_FixRT1.u for:  by rchennup for Service Pack
#
# Revision 1.1  2000/10/25  16:20:10  pinnacle
# Created: vds/vdppl/COz_FixRT1.u by rchennup for Service Pack
#
# Revision 1.2  2000/08/25  20:27:32  pinnacle
# Replaced: vds/vdppl/COz_FixRT.u for:  by jwfrosch for Service Pack
#
# Revision 1.3  2000/03/31  21:55:14  pinnacle
# Replaced: vdppl/COz_FixRT.u for:  by impd252 for vds
#
 *
 * History:
 * MM/DD/YY  AUTHOR  DESCRIPTION
 * 01/18/00  ah      TR179900921 Another rtree problem
 * -------------------------------------------------------------------*/

#include "VDppl.h"
#include "VDobj.h"

#include "OMDB.h"
#include "OMindex.h"
#include "OMrtreedef.h"

extern VDclassid OPP_ACrg_collect_class_id;
extern VDclassid OPP_ACmodel_class_id;
extern VDclassid OPP_GRgraphics_class_id;
extern VDclassid OPP_GRrtree_class_id;
extern VDclassid OPP_OMrtree_class_id;
extern int       VDcomment;
extern VDpms_find_objects();
extern VSrdbDelCachedDefs();
extern GRdpb_get(), VDrtUpdateNonLeaves(), VDrtDelKeysInRTree();

OM_S_CHANSELECT       my_chansel[1];

TGRobj_env  objOE;
TGRobj_env *objlist;
int         total, sz, cnt, idx;

/* --------------------------------------------
 * Process each object
 */
IGRstat process()
{
#define MAX_OBJ		10

  int     i0, chcnt, obj_count, add_to_RTree, f_defer_flag;
  GRclassid clid;
  OM_S_OBJECT_LINKAGE   channel_objids[MAX_OBJ];
  IGRstat retFlag;
  IGRstat sts;
  IGRstat msg;
  OM_S_OBJECT_LINKAGE   objet;

  retFlag = 0;

  // Try to delete any OMrtree objects...
  sts = om$get_classid ( osnum     = objOE.obj_id.osnum,
                         objid     = objOE.obj_id.objid,
                         p_classid = &clid );

  // This does NOT work ...
//    if ( sts & 1 && (clid == OPP_OMrtree_class_id ))
//    {
//      sts =
//      ci$send(msg      = message Root.delete(f_defer_flag),
//  //    ci$send(msg      = message OMrtree.delete(f_defer_flag),
//  //            mode     = OM_e_wrt_object,
//              targetos = objOE.obj_id.osnum,
//              targetid = objOE.obj_id.objid);
//      if (VDcomment)
//      {
//        printf("Trying to delete OMrtree object: objOE[%d] = [%d,%d], sts = %#x\n", cnt, objOE.obj_id.osnum, objOE.obj_id.objid, sts);
//  //        om$report_error(sts = sts);
//      }
//      cnt = cnt + 1;
//      return 1;
//    }

/*
  // First, regardless, remove every object from GRrtree...
  ci$send(msg      = message GRgraphics.GRremwrng(&msg,&objOE.mod_env),
          targetos = objOE.obj_id.osnum,
          targetid = objOE.obj_id.objid);
*/

  // Filter all but ACpretendin and ASsourcein
  sts = vdobj$IsAncestryValid(objOE = &objOE, superClassID = OPP_GRgraphics_class_id);
  if (!(sts & 1)) goto wrapup;

  // Skip ACmodel
  sts = vdobj$IsAncestryValid(objOE = &objOE, superClassID = OPP_ACmodel_class_id);
  if (sts & 1) goto wrapup;

  // Skip ACrg_collect
  sts = vdobj$IsAncestryValid(objOE = &objOE, superClassID = OPP_ACrg_collect_class_id);
  if (sts & 1) goto wrapup;

  objet.osnum    = objOE.obj_id.osnum;
  objet.S_objid  = objOE.obj_id.objid;
  add_to_RTree   = 1;

  // Check to_owner channel
  sts = om$get_channel_count ( osnum            =  objet.osnum,
                               objid            =  objet.S_objid,
                               p_chanselect     = &my_chansel[0],
                               count            = &chcnt );
  if ( chcnt > 0 && (sts & 1) )
  {
    // Get owners
    sts = om$get_channel_objects( osnum        =  objet.osnum,
                                  objid        =  objet.S_objid,
                                  p_chanselect = &my_chansel[0],
                                  list         =  channel_objids,
                                  size         =  MAX_OBJ,
                                  count        = &obj_count );

    if ( obj_count > 0 && (sts & 1) )
    {
      if ( obj_count > MAX_OBJ )
      {
        printf("obj_count[%d] > MAX_OBJ[%d] for objOE[%d,%d]\n", obj_count, MAX_OBJ, objOE.obj_id.osnum, objOE.obj_id.objid);
        obj_count = MAX_OBJ;
      }
      for( i0=0; i0 < obj_count; i0=i0+1)
      {
        sts = om$get_classid ( osnum     = channel_objids[i0].osnum,
                               objid     = channel_objids[i0].S_objid,
                               p_classid = &clid );

        // Check if owner is of class ACmodel or ACrg_collect
        if ( sts & 1 && (clid == OPP_ACmodel_class_id || clid == OPP_ACrg_collect_class_id))
        {
          // DO NOT add to RangeTree
          add_to_RTree = 0;

          objlist[total] = objOE;
          total          = total + 1;

          if ( total == sz )
          {
            sz = sz + 100;
            objlist = (struct GRobj_env *) om$realloc ( ptr  = objlist,
                                                        size = sz * sizeof (struct GRobj_env) );
            if ( objlist == NULL )
            {
              retFlag = -12321;
              goto wrapup;
            }
            if (VDcomment)
            {
              printf("om$realloc ( ptr  = objlist); sz = %d\n", sz);
            }
          }

          if (VDcomment)
          {
            printf("objOE = [%d,%d], owner[%d] = [%d,%d], chcnt = %d, obj_count = %d\n",
                   objet.osnum, objet.S_objid, i0, channel_objids[i0].osnum, channel_objids[i0].S_objid, chcnt, obj_count);
          }
          break;
        }
      }
    }
  }

#if 1
//    ci$send(msg      = message GRgraphics.GRremwrng(&msg,&objOE.mod_env),
//            targetos = objOE.obj_id.osnum,
//            targetid = objOE.obj_id.objid);
#endif

  if (add_to_RTree)
  {
    ci$send(msg = message GRgraphics.GRaddwrng(&msg,&objOE.mod_env),
            targetos = objOE.obj_id.osnum,
            targetid = objOE.obj_id.objid);
  }
  // Done
  retFlag = 1;

wrapup:
  return retFlag;
}

/* ---------------------------------------------
 * Cycles through os and process objects
 */
main()
{
  IGRstat sts, msg;
  IGRuint i,max;

  IGRchar buf[128];
  GRclassid             class_id;
  OM_S_OBJID           *list;

  message("Fix the Range Tree");

  UI_status("Deleting Keys ....");
  VDrtDelKeysInRTree();

  // Cycle through current os
  gr$get_module_env(buffer = &objOE.mod_env);
  objOE.obj_id.osnum       =  objOE.mod_env.md_id.osnum;

  my_chansel[0].type       = OM_e_name;
  my_chansel[0].u_sel.name = "to_owners";

  sz = 100;
  objlist = (struct GRobj_env *) om$malloc ( size = sz * sizeof (struct GRobj_env) );
  if ( objlist == NULL )
    goto wrapup;

  // Cycle through again to fill back up
  UI_status("Filling Range Tree...");
  max = OM_GA_OSDs[objOE.obj_id.osnum]->CurSpaceMapSize;
  for(i = 0; i < max; i = i + 1)
  {
    if (!(i % 1000))
    {
      sprintf(buf,"Filling Range Tree %d of %d...",i,max);
      UI_status(buf);
    }

    objOE.obj_id.objid = i;

    sts = process();
    if ( sts == -12321 )
      goto wrapup;
  }

  // Postprocessing is necessary...
  for(i = 0; i < total; i = i + 1)
  {
    ci$send(msg      = message GRgraphics.GRremwrng ( &msg, &objlist[i].mod_env),
            targetos = objlist[i].obj_id.osnum,
            targetid = objlist[i].obj_id.objid);

    if (VDcomment)
    {
      printf("GRgraphics.GRremwrng[%d] = [%d,%d], msg = %d\n",
             i, objlist[i].obj_id.osnum, objlist[i].obj_id.objid, msg);
    }
  }

  list = NULL;
  class_id = OPP_OMrtree_class_id;
  sts = VDpms_find_objects ( (OMuword)2, (OMuword)class_id, &cnt, list );

  if (VDcomment)
  {
    printf ( "\nVDpms_find_objects() : sts = %d, Number of OMrtree objects = %d\n", sts, cnt );
    fflush ( 0 );
  }

  /*
   * Delete cached graphics and DB info in current model.
   * (NOTE: this will not delete user-made composite profiles since they
   * are stored in the active file when created and do not correspond to
   * anything in the RDB).
   */
  VSrdbDelCachedDefs();

  UI_status("Updating Non-Leaf Entries ...");
  VDrtUpdateNonLeaves();

wrapup:

  UI_status("Range Tree Rebuilt");

  om$dealloc ( ptr = objlist );
  return 1;
}
