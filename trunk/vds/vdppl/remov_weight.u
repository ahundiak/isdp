#include <stdio.h>

#include "cieveryone.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "EMSmsgdef.h"
#include "msdef.h"
#include "ciexec.h"
#include "cievent.h"
#include "AS_status.h"
#include "OMprimitives.h"

#include "growner.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "grmacros.h"
#include "dpdef.h"
#include "dpmacros.h"
#include "bserr.h"
#include "bsnorkts.h"

char                    loc_mes[80];
IGRlong                 msg;
IGRint                  rem_cv, rem_sf;

struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay       dis;

struct GRid            *LOCATED_ID;
struct GRobj_env       *COMP_ENV;

OMuword                 classid[2];
struct OM_sd_classlist  classlist;

extern int              free(),
                        init_cnst_list();
extern int              VDcomment;

extern char             *malloc();
extern                  ASmake_source_from_env();
extern int              BSrmsfwghts(), BSrmcvwghts();

extern                  GRgs_fun();
extern                  GRgsmgr_fun();
extern                  DPdisbyoid(), DPerase_hilite();

extern unsigned short   OPP_EMSsubbs_class_id;
extern unsigned short   OPP_GRcurve_class_id;
extern unsigned short   OPP_GRbcsubbc_class_id;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

main_remove( i0, TEMP )

  IGRint                 i0;
  struct GRid            TEMP;

{
  IGRlong                stat, OMsts;
  IGRint                 cnt, rc, sz;
  OMuword                clid;

  struct GRid            NEW;
  struct GRpost_info     post_info;
  struct IGRbsp_surface *sf;
  struct IGRbsp_curve   *cv;

  ci$get_module_info    ( md_env = &MOD_ENV );
//  ASmake_source_from_env( &TEMP, &MOD_ENV, &TEMP);

  printf ("Surface/Curve[%d] = [%d,%d]\n", i0, TEMP.osnum, TEMP.objid);

  ci$send ( msg = message GRvg.GRgetsize ( &stat,
                                           &MOD_ENV.md_env.matrix_type,
                                            MOD_ENV.md_env.matrix,
                                           &sz ),
            targetid = TEMP.objid,
            targetos = TEMP.osnum );

  sf  = NULL;
  cv  = NULL;
  cnt = 0;

  om$get_classid( objid     = TEMP.objid,
                  osnum     = TEMP.osnum,
                  p_classid = &clid);
  if ( VDcomment )
  {
    printf ("clid = %d, OPP_EMSsubbs_class_id = %d, OPP_GRcurve_class_id = %d\n",
            clid, OPP_EMSsubbs_class_id, OPP_GRcurve_class_id);
  }

  if ( om$is_ancestry_valid ( subclassid = clid, superclassid = OPP_EMSsubbs_class_id  ) == OM_S_SUCCESS )
  {
    sf = (struct IGRbsp_surface *) malloc ( sz * ( sizeof ( char ) ) );

    ci$send ( msg = message GRvg.GRgetgeom ( &stat,
                                             &MOD_ENV.md_env.matrix_type,
                                              MOD_ENV.md_env.matrix,
                                             ( char * ) sf ),
              targetid = TEMP.objid,
              targetos = TEMP.osnum );

//    BSnorkts ( &rc, &sf->u_order, &sf->u_num_poles, sf->u_knots );
//    BSnorkts ( &rc, &sf->v_order, &sf->v_num_poles, sf->v_knots );

    cnt = BSrmsfwghts ( sf, &rc);
    if ( VDcomment )
    {
      printf ("BSrmsfwghts() rc = %d, cnt = %d\n", rc, cnt);
    }
    if ( rc == BSSUCC )
    {
      post_info.construct_flag = FALSE;
      OMsts = ci$send ( msg = message GRvg.GRpostabsg ( &stat,
                                                        &MOD_ENV,
                                                        &post_info,
                                                        ( char * ) sf,
                                                        &NEW.objid ),
                        targetid = TEMP.objid,
                        targetos = TEMP.osnum );
      rem_sf = rem_sf + cnt;
    }
  }
  else if ( om$is_ancestry_valid ( subclassid = clid, superclassid = OPP_GRcurve_class_id ) == OM_S_SUCCESS )
  {
    cv = (struct IGRbsp_curve *) malloc ( sz * ( sizeof ( char ) ) );

    ci$send ( msg = message GRvg.GRgetgeom ( &stat,
                                             &MOD_ENV.md_env.matrix_type,
                                              MOD_ENV.md_env.matrix,
                                             ( char * ) cv ),
              targetid = TEMP.objid,
              targetos = TEMP.osnum );

    BSnorkts ( &rc, &cv->order, &cv->num_poles, cv->knots );

    cnt = BSrmcvwghts ( cv, &rc);
    if ( VDcomment )
    {
      printf ("BSrmcvwghts() rc = %d, cnt = %d\n", rc, cnt);
    }
    if ( rc == BSSUCC )
    {
      post_info.construct_flag = FALSE;
      OMsts = ci$send ( msg = message GRvg.GRpostabsg ( &stat,
                                                        &MOD_ENV,
                                                        &post_info,
                                                        ( char * ) cv,
                                                        &NEW.objid ),
                        targetid = TEMP.objid,
                        targetos = TEMP.osnum );
      rem_cv = rem_cv + cnt;
    }
  }
  if ( sf )
  {
    free(sf);
    sf = NULL;
  }
  if ( cv )
  {
    free(cv);
    cv = NULL;
  }
}

/*==========================================================================*/
init()
{
  strcpy(loc_mes,"Remove superfluous weights from Surfaces / Curves");

  init_cnst_list();
  get_symb();

  dis.color           = cnst_list.color;
  dis.weight          = cnst_list.weight;
  dis.style           = cnst_list.style;

  cst.msg             = &msg;
  cst.properties      = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display         = &dis;
  cst.env_info        = &MOD_ENV;
  cst.newflag         = 0;
  cst.level           = cnst_list.level;
  cst.geometry        = NULL;
  cst.class_attr      = 0;
  cst.name            = 0;

  classid[0]          = OPP_EMSsubbs_class_id;
  classid[1]          = OPP_GRcurve_class_id;

  classlist.w_count   = 2;
  classlist.w_flags   = OM_CLST_subclass;
  classlist.p_classes = classid;
  rem_sf              = 0;
  rem_cv              = 0;
}

wakeup()
{
  message(loc_mes);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

get_elements_in_fence( OBJ_ID )

struct  GRid            OBJ_ID;
{
  char         *fnc_ptr;
  int           count, msg, sts, size_ob, sze;
  struct GRid   OBJET, clipping_grid;

  /* get clipping polygon */

  gr$gsget_fence( msg = &msg,fence_id = &clipping_grid );

  if( msg != MSSUCC ) clipping_grid.objid = NULL_OBJID;

  OBJET.objid = OBJ_ID.objid;
  OBJET.osnum = OBJ_ID.osnum;

  count = 0;
  gr$gsinqcount(        msg             = &msg,
                        count           = &count,
                        senderid        = NULL_OBJID,
                        object_id       = &OBJET );

  if( msg != MSSUCC )
  {
    fprintf(stderr, "gr$gsinqcount failed" );
    return (0);
  }

  size_ob       = count * sizeof(struct GRobj_env);
  fnc_ptr       = om$malloc( size =  size_ob);
  COMP_ENV      = (struct GRobj_env *) fnc_ptr;

  if ( COMP_ENV == NULL ) return (0);

  sze           = count * sizeof(struct GRid);
  fnc_ptr       = om$malloc( size =  sze);
  LOCATED_ID    = (struct GRid *) fnc_ptr;

  if ( LOCATED_ID == NULL ) return (0);

  //    Inquire fence for content.

  sts = gr$gsget_objects (      msg             = &msg,
                                array           = COMP_ENV,
                                size            = size_ob,
                                count           = &count,
                                from_obj        = 0,
                                to_obj          = count -1,
                                senderid        = NULL_OBJID,
                                object_id       = &OBJET);

  if ( !( sts & OM_S_SUCCESS ) )
  {
    fprintf(stderr, "gr$gsget_objects error ; sts = %d , msg = %d\n",sts,msg ) ;
    om$report_error( sts = sts ) ;
    return (0) ;
  }

  return (count);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

process_elements_in_fence( count, COMP_ENV )

int                      count;
struct  GRobj_env       *COMP_ENV;
{
  char          OK;
  int           i0, nr_elm;

  OMuword       clid;
  struct GRid   TEMP;

  /* ------------------------------------------------------------------ */

  nr_elm = 0;

  // Now find all elements of class     : EMSsubbs

  for (i0=0; i0<count; i0=i0+1)
  {
    om$get_classid( objid         = COMP_ENV[i0].obj_id.objid,
                    osnum         = COMP_ENV[i0].obj_id.osnum,
                    p_classid = &clid);

    if ( om$is_ancestry_valid ( subclassid = clid, superclassid = OPP_EMSsubbs_class_id  ) == OM_S_SUCCESS ||
         om$is_ancestry_valid ( subclassid = clid, superclassid = OPP_GRcurve_class_id ) == OM_S_SUCCESS )
    {
      LOCATED_ID[nr_elm].osnum = COMP_ENV[i0].obj_id.osnum;
      LOCATED_ID[nr_elm].objid = COMP_ENV[i0].obj_id.objid;

      dp$display ( msg  = &msg,
                   mode = GRhd,
                   oids = &LOCATED_ID[nr_elm] );

      nr_elm = nr_elm + 1;
    }
  }

  OK = 'y';
  ci$get ( char         = OK,
           prompt       = "Move-On(YES) to Continue ? (Y/N) [Y]" );

  dp$erase_hilite(msg   = &msg);

  if ( OK == 'n' )
    return (1);

//  if ( VDcomment )
  {
    printf ("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf ("Number of Surfaces + Curves = %d\n", nr_elm);
    for (i0=0; i0 < nr_elm; i0=i0+1)
    {
      TEMP = LOCATED_ID[i0];

      main_remove ( i0, TEMP );
    }
  }
  printf ("\nNumber of Surfaces + Curves = %d, Modified: Curves = %d, Surfaces = %d\n", nr_elm, rem_cv, rem_sf);
  printf ("------------------------------------------------------------------------\n");

  return (1);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

generate_surfcurv_list()
{
  int           count, resp;
  double        rep_pos[3];

  struct        GRid            OBJ_ID;
  struct        GRid            TEMP;
  struct        GRevent         grevent;

  /* ------------------------------------------------------------------ */

  ci$getevent(event             = &grevent,
              response          = &resp ,
              prompt            = "Locate Surfaces / Curves to modify",
              stackable         = 1,
              mask              = GRm_SPECIFIED_OBJ | GRm_DATA | GRm_RESET );

  OBJ_ID.objid = grevent.located_object[0].located_obj.objid;
  OBJ_ID.osnum = grevent.located_object[0].located_obj.osnum;

  if( resp == SPECIFIED_OBJ )
  {
    count = get_elements_in_fence( OBJ_ID );

    if ( count ) process_elements_in_fence( count, COMP_ENV );

    status("");
  }
  else if( resp == DATA )
  {
    rep_pos[0]  = grevent.event.button.x;
    rep_pos[1]  = grevent.event.button.y;
    rep_pos[2]  = grevent.event.button.z;
    ci$put (point = rep_pos);

    ci$locate ( prompt           = "Identify Surface / Curve",
                eligible_classes = &classlist,
                properties       = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                owner_action     = LC_RIGID_COMP  |
                                   LC_RIGID_OWNER | LC_FLEX_COMP |
                                   LC_FLEX_OWNER  | LC_REF_OBJECTS,
                obj              = &(TEMP.objid),
                osnum            = &(TEMP.osnum),
                response         = &resp,
                md_env           = &MOD_ENV );

    printf ("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    main_remove ( 0, TEMP );
    printf ("\nModified: Curves = %d, Surfaces = %d\n", rem_cv, rem_sf);
    printf ("------------------------------------------------------------------------\n");
  }
  else if( resp == RESET )
  {
    status( "Located object not a Fence or Surface" ) ;
  }

  if( COMP_ENV != NULL )
  {
    om$dealloc(ptr = COMP_ENV);
    COMP_ENV = NULL;
  }

  if( LOCATED_ID != NULL )
  {
    om$dealloc(ptr = LOCATED_ID);
    LOCATED_ID = NULL;
  }

  return (1);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

main()
{
    generate_surfcurv_list();
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
