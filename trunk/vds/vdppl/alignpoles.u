/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*	Execute "ci=toggle [c] [f] [m]" for different levels of debug print	*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

#include <stdio.h>

#include "cieveryone.h"
#include "ciminimum.h"
#include "cimacros.h"
#include "EMSmsgdef.h"
#include "msdef.h"
#include "ciexec.h"
#include "cievent.h"
#include "AS_status.h"
#include "OMprimitives.h"

#include "growner.h"
#include "grgs.h"
#include "grgsmacros.h"
#include "grmacros.h"
#include "dpdef.h"
#include "dpmacros.h"
#include "bserr.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*				Global Variables				*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

char                    loc_mes[80];
IGRint                  npols;
IGRlong                 msg, direc, num_align, acc_prompt;
IGRdouble               align_val, align_tol;

struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay       dis;

struct GRid             display_info, SURF,
                       *SURFACE_ID,
                       *GRid_pols;
struct GRobj_env       *COMP_ENV;

extern                  VDcomment, VDfunct, VDmethod;
extern unsigned short   OPP_EMSsubbs_class_id;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

extern char            *malloc();
extern int              free(), init_cnst_list(), GRfindmod ();
extern                  ASmake_source_from_env();
extern                  GRgs_fun();
extern                  GRgsmgr_fun();
extern                  EMdpb_get_trans();
extern                  DPdisbyoid(), DPerase_hilite();

extern void             BSsfarrev0 ();
extern IGRdouble        BSdistptpt ();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/*				 Beginning of code				*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void init()
{
  strcpy(loc_mes,"Align Surface[s]");

  init_cnst_list();
  get_symb();

  GRfindmod ( &display_info );

  dis.color      = cnst_list.color;
  dis.weight     = 3; //cnst_list.weight;
  dis.style      = cnst_list.style;

  cst.msg        = &msg;
  cst.properties = GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display    = &dis;
  cst.env_info   = &MOD_ENV;
  cst.newflag    = 0;
  cst.level      = cnst_list.level;
  cst.geometry   = NULL;
  cst.class_attr = 0;
  cst.name       = 0;

  direc          = 0;
  num_align      = 0;
  acc_prompt     = 0;
  align_val      = 0.0;
  align_tol      = 0.0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void wakeup ()
{
  IGRint        i, msg, GRdpmode;
  IGRlong       OMsts;

  message ( loc_mes );

  if ( npols != 0 )
  {
    GRdpmode = GRhd;

    for ( i = 0; i < npols; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &MOD_ENV.md_env.matrix_type,
                                                  MOD_ENV.md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pols[i].objid,
                        targetos = GRid_pols[i].osnum );
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void sleep ()
{
  IGRint        i, msg, GRdpmode;
  IGRlong       OMsts;

  if ( npols != 0 )
  {
    GRdpmode = GRbdhe;

    for ( i = 0; i < npols; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &MOD_ENV.md_env.matrix_type,
                                                 MOD_ENV.md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pols[i].objid,
                        targetos = GRid_pols[i].osnum );
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void del_GRid ( num_poles, GRid_pol, tmp_gr, modenv )

  IGRint                 *num_poles;
  struct GRid            *GRid_pol;
  struct GRid             tmp_gr;
  struct GRmd_env         modenv;

{
  IGRint        i, msg, GRdpmode;
  IGRlong       OMsts;

  if ( *num_poles != 0 )
  {
    GRdpmode = GRbehe;

    for ( i = 0; i < *num_poles; i = i + 1 )
    {
      OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                                 &msg,
                                                 &modenv.md_env.matrix_type,
                                                  modenv.md_env.matrix,
                                                 &GRdpmode,
                                                 &display_info ),
                        targetid = GRid_pol[i].objid,
                        targetos = GRid_pol[i].osnum );

      ci$send ( msg = message GRgraphics.GRdelete ( &msg, &modenv ),
                targetid = GRid_pol[i].objid,
                targetos = GRid_pol[i].osnum );

    }
    *num_poles = 0;

    GRdpmode = GRbd;

    OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                               &msg,
                                               &modenv.md_env.matrix_type,
                                                modenv.md_env.matrix,
                                               &GRdpmode,
                                               &display_info ),
                      targetid = tmp_gr.objid,
                      targetos = tmp_gr.osnum );

    if ( GRid_pol )
    {
      free(GRid_pol);
      GRid_pol = NULL;
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void disp_sf_GRid ( bssf, trav, modenv, GRid_pols, cst )

  struct IGRbsp_surface  *bssf;
  IGRdouble              *trav;
  struct GRmd_env        *modenv;
  struct GRid            *GRid_pols;
  struct GRvg_construct  *cst;

{
  IGRint                  num_p;
  IGRint                  i, j, msg, GRdpmode;
  IGRlong                 OMsts;
  struct IGRpolyline      geom;

  geom.num_points = 1;
  cst->geometry = ( char * ) &geom;

  GRdpmode = GRhd;

  num_p = bssf->u_num_poles * bssf->v_num_poles;

  if ( bssf->rational == FALSE )
  {
    for ( i = 0; i < num_p; i = i + 1 )
    {
      j = 3 * i;
      trav[j+0] = bssf->poles[j+0];
      trav[j+1] = bssf->poles[j+1];
      trav[j+2] = bssf->poles[j+2];
    }
  }
  else
  {
    for ( i = 0; i < num_p; i = i + 1 )
    {
      j = 3 * i;
      trav[j+0] = bssf->poles[j+0] / bssf->weights[i];
      trav[j+1] = bssf->poles[j+1] / bssf->weights[i];
      trav[j+2] = bssf->poles[j+2] / bssf->weights[i];
    }
  }

  for ( i = 0; i < num_p; i = i + 1 )
  {
    j = 3 * i;
    geom.points = ( IGRdouble * ) & ( trav[j] );

    if (VDfunct) printf ( "geom.points[%d]= %lf %lf %lf\n",
                          i, geom.points[0], geom.points[1], geom.points[2] );

    GRid_pols[i].objid = NULL_OBJID;
    GRid_pols[i].osnum = 2;

    OMsts = ci$send ( msg = message GR3dpoint.GRaltconstruct ( cst ),
                      targetid = GRid_pols[i].objid,
                      targetos = GRid_pols[i].osnum );

    OMsts = ci$send ( msg = message GRgraphics.GRdisplay (
                                               &msg,
                                               &modenv->md_env.matrix_type,
                                                modenv->md_env.matrix,
                                               &GRdpmode,
                                               &display_info ),
                      targetid = GRid_pols[i].objid,
                      targetos = GRid_pols[i].osnum );
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void main_align( i0, SURF )

  IGRint      i0;
  struct GRid SURF;

{
  char                    c, str[80];
  IGRint                  stat, sz;
  IGRlong                 OMsts;
  IGRdouble               max_dst;
  IGRdouble             * poles0;
  struct GRid             NEW;
  struct IGRbsp_surface * sf;
  struct GRpost_info      post_info;

  ci$get_module_info    ( md_env = &MOD_ENV );
  ASmake_source_from_env( &SURF, &MOD_ENV, &SURF);

  ci$send ( msg = message GRvg.GRgetsize ( &stat,
                                           &MOD_ENV.md_env.matrix_type,
                                            MOD_ENV.md_env.matrix,
                                           &sz ),
            targetid = SURF.objid,
            targetos = SURF.osnum );

  sf = (struct IGRbsp_surface *) malloc ( sz * ( sizeof ( char ) ) );

  ci$send ( msg = message GRvg.GRgetgeom ( &stat,
                                           &MOD_ENV.md_env.matrix_type,
                                            MOD_ENV.md_env.matrix,
                                           ( char * ) sf ),
            targetid = SURF.objid,
            targetos = SURF.osnum );

  npols     = sf->u_num_poles * sf->v_num_poles;
  GRid_pols = (struct GRid *) malloc ( npols * ( sizeof ( struct GRid ) ) );
  poles0    = ( IGRdouble * ) malloc ( npols * 24);

//    if (VDcomment)
  {
    printf("##################################################################\n");
    printf("Surface[%2d] = [%d,%d] : num_poles = %d (%d x %d)\n",
           i0, SURF.osnum, SURF.objid, npols, sf->u_num_poles, sf->v_num_poles);
  }

  disp_sf_GRid ( sf, poles0, &MOD_ENV, GRid_pols, &cst );

  // ===========================================================================
  // This function perfoms all the required calculations for alignment of poles
  // ===========================================================================

  get_edge_info( &max_dst, poles0, sf );

  // Only allow surface to be modified:
  // - the maximum distance between poles and align_val is in between 0.0 - align_tol

  if ( max_dst > 0.0 && max_dst < align_tol )
  {
    if ( acc_prompt )
    {
      sprintf(str, "Align Poles of Surface ? [Y/N]");
      ci$get ( char = c, prompt = str );
    }
    else
    {
      c = 'Y';
    }

    if ( c == 'Y' || c == 'y' )
    {
      post_info.construct_flag = FALSE;
      OMsts = ci$send ( msg = message GRvg.GRpostabsg ( &stat,
                                                        &MOD_ENV,
                                                        &post_info,
                                                        ( char * ) sf,
                                                        &NEW.objid ),
                        targetid = SURF.objid,
                        targetos = SURF.osnum );

      num_align = num_align + 1;

      if (VDmethod)
      {
        printf("Surface     = [%d,%d]\n", SURF.osnum, SURF.objid );
        printf("Surface NEW = [%d,%d], OMsts = %d, stat = %d\n", NEW.osnum, NEW.objid, OMsts, stat );
      }
    }
  }

  del_GRid ( &npols, GRid_pols, SURF, MOD_ENV );

wrapup:

  if ( poles0 )
  {
    free(poles0);
    poles0 = NULL;
  }
  if ( sf )
  {
    free(sf);
    sf = NULL;
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

int get_elements_in_fence( OBJ_ID )

  struct  GRid            OBJ_ID;

{
  char         *fnc_ptr;
  int           count, msg, sts, size_ob, sze;
  struct GRid   OBJET, clipping_grid;

  /* get clipping polygon */

  gr$gsget_fence( msg = &msg,fence_id = &clipping_grid );

  if( msg != MSSUCC ) clipping_grid.objid = NULL_OBJID;

  OBJET.objid = OBJ_ID.objid;
  OBJET.osnum = OBJ_ID.osnum;

  count = 0;
  gr$gsinqcount(        msg             = &msg,
                        count           = &count,
                        senderid        = NULL_OBJID,
                        object_id       = &OBJET );

  if( msg != MSSUCC )
  {
    fprintf(stderr, "gr$gsinqcount failed" );
    return (0);
  }

  size_ob       = count * sizeof(struct GRobj_env);
  fnc_ptr       = om$malloc( size =  size_ob);
  COMP_ENV      = (struct GRobj_env *) fnc_ptr;

  if ( COMP_ENV == NULL ) return (0);

  sze           = count * sizeof(struct GRid);
  fnc_ptr       = om$malloc( size =  sze);
  SURFACE_ID    = (struct GRid *) fnc_ptr;

  if ( SURFACE_ID == NULL ) return (0);

  //    Inquire fence for content.

  sts = gr$gsget_objects (      msg             = &msg,
                                array           = COMP_ENV,
                                size            = size_ob,
                                count           = &count,
                                from_obj        = 0,
                                to_obj          = count -1,
                                senderid        = NULL_OBJID,
                                object_id       = &OBJET);

  if ( !( sts & OM_S_SUCCESS ) )
  {
    fprintf(stderr, "gr$gsget_objects error ; sts = %d , msg = %d\n",sts,msg ) ;
    om$report_error( sts = sts ) ;
    return (0) ;
  }

  return (count);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

int process_elements_in_fence( count, COMP_ENV )

  int                      count;
  struct  GRobj_env       *COMP_ENV;

{
  char          OK;
  int           i0, nr_elm;

  OMuword       clid, srf_classid;

  /* ------------------------------------------------------------------ */

  srf_classid = OPP_EMSsubbs_class_id;
  nr_elm = 0;

  // Now find all elements of class     : EMSsubbs

  for (i0=0; i0<count; i0=i0+1)
  {
    om$get_classid( objid         = COMP_ENV[i0].obj_id.objid,
                    osnum         = COMP_ENV[i0].obj_id.osnum,
                    p_classid = &clid);

    if ( om$is_ancestry_valid ( subclassid = clid, superclassid = OPP_EMSsubbs_class_id ) == OM_S_SUCCESS )
    {
      SURFACE_ID[nr_elm].osnum = COMP_ENV[i0].obj_id.osnum;
      SURFACE_ID[nr_elm].objid = COMP_ENV[i0].obj_id.objid;

      dp$display ( msg  = &msg,
                   mode = GRhd,
                   oids = &SURFACE_ID[nr_elm] );

      nr_elm = nr_elm + 1;
    }
  }

  OK = 'y';
  ci$get ( char         = OK,
           prompt       = "Move-On(YES) to Continue ? (Y/N) [Y]" );

  dp$erase_hilite(msg   = &msg);

  if ( OK == 'n' )
    return (1);

//  if ( VDcomment )
  {
    printf("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf ("Number of Surfaces = %d\n", nr_elm);
    num_align = 0;
    for (i0=0; i0 < nr_elm; i0=i0+1)
    {
      //printf ("SURFACE_ID[%d] = [%d,%d]\n", i0, SURFACE_ID[i0].osnum, SURFACE_ID[i0].objid);
      SURF = SURFACE_ID[i0];

      // Now call the main function from where alignments are started
      main_align ( i0, SURF );
    }
  }
  printf ("\nNumber of Surfaces = %d, Aligned = %d\n", nr_elm, num_align);
  printf("------------------------------------------------------------------------\n");

  return (1);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

int generate_surface_list()
{
  char          c, str[80];
  int           count, resp;
  IGRint        u_order, v_order;
  IGRlong       msg;
  IGRdouble     rep_pos[3];

  struct        GRid            OBJ_ID;
  struct        GRevent         grevent;

  /* ------------------------------------------------------------------ */

  gr$get_active_u_order( msg = &msg, order = &u_order);
  gr$get_active_v_order( msg = &msg, order = &v_order);

again:

  sprintf(str, "Enter Orthogonal Direction : X / Y / Z or E[xit]");

  ci$get ( char = c, prompt = str );

  direc = 0;
  if ( c == 'X' || c == 'x' || c == '0' )
  {
    direc = 0;
  }
  else if ( c == 'Y' || c == 'y' || c == '1' )
  {
    direc = 1;
  }
  else if ( c == 'Z' || c == 'z' || c == '2' )
  {
    direc = 2;
  }
  else if ( c == 'E' || c == 'e' )
  {
    return (0);
  }
  else
  {
    status("Invalid response, start again");
    goto again;
  }

  sprintf(str, "Enter Alignment Value");
  ci$get ( value = align_val, prompt = str );

  sprintf(str, "Enter Alignment Tolerance");
  ci$get ( value = align_tol, prompt = str );

  sprintf(str, "Prompt for Acceptance for every Surface ? (Y/N) [Y]");
  c = 'Y';
  ci$get ( char = c, prompt = str );
  if ( c == 'N' || c == 'n' )
  {
    acc_prompt = 0;
  }
  else
  {
    acc_prompt = 1;
  }

  sprintf (str,"Dir = %c, Align Value = %lg, Tol = %lg, Prompt = %d", direc + 88, align_val, align_tol, acc_prompt);
  status ( str );
  printf ("%s\n", str);

  sprintf(str, "Move-On(YES) to Continue ? (Y/N) [Y]");
  c = 'Y';
  ci$get ( char = c, prompt = str );
  if ( c == 'N' || c == 'n' )
    goto again;

  ci$getevent(event     = &grevent,
              response  = &resp ,
              prompt    = "Locate Surfaces to Align",
              stackable = 1,
              mask      = GRm_SPECIFIED_OBJ | GRm_DATA | GRm_RESET );

  OBJ_ID.objid = grevent.located_object[0].located_obj.objid;
  OBJ_ID.osnum = grevent.located_object[0].located_obj.osnum;

  if( resp == SPECIFIED_OBJ )
  {
    count = get_elements_in_fence( OBJ_ID );

    if ( count ) process_elements_in_fence( count, COMP_ENV );

    status("");
  }
  else if( resp == DATA )
  {
    rep_pos[0]    = grevent.event.button.x;
    rep_pos[1]    = grevent.event.button.y;
    rep_pos[2]    = grevent.event.button.z;
    ci$put (point = rep_pos);

    ci$locate(        prompt       = "Identify Surface to Align",
                      properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                      owner_action = LC_RIGID_COMP  |
                                     LC_RIGID_OWNER | LC_FLEX_COMP |
                                     LC_FLEX_OWNER  | LC_REF_OBJECTS,
                      classes      = "EMSsubbs",
                      obj          = &(SURF.objid),
                      osnum        = &(SURF.osnum),
                      response     = &resp,
                      md_env       = &MOD_ENV );

    // Now call the main function from where alignments are started
    num_align = 0;
    main_align ( 0, SURF );
  }
  else if( resp == RESET )
  {
    status( "Located object not a Fence or Surface" ) ;
  }

  if( COMP_ENV != NULL )
  {
    om$dealloc(ptr = COMP_ENV);
    COMP_ENV = NULL;
  }

  if( SURFACE_ID != NULL )
  {
    om$dealloc(ptr = SURFACE_ID);
    SURFACE_ID = NULL;
  }

  return (1);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void delete ()
{
  del_GRid ( &npols, GRid_pols, SURF, MOD_ENV );
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

main()
{
  while ( generate_surface_list() )
    ;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void get_poles ( uv, unp, vnp, edgpols, poles )

  int     uv, unp, vnp;
  double *edgpols, *poles;

{
  int k, n, m;
  if ( uv == 1 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      edgpols[n]   = poles[n];
      edgpols[n+1] = poles[n+1];
      edgpols[n+2] = poles[n+2];
    }
  }
  else if ( uv == 2 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * unp * (vnp-1) + n;
      edgpols[n]   = poles[m];
      edgpols[n+1] = poles[m+1];
      edgpols[n+2] = poles[m+2];
    }
  }
  else if ( uv == 3 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * k * unp;
      edgpols[n]   = poles[m];
      edgpols[n+1] = poles[m+1];
      edgpols[n+2] = poles[m+2];
    }
  }
  else if ( uv == 4 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * ((k+1) * unp - 1);
      edgpols[n]   = poles[m];
      edgpols[n+1] = poles[m+1];
      edgpols[n+2] = poles[m+2];
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

void set_poles ( uv, unp, vnp, edgpols, poles )

  int     uv, unp, vnp;
  double *edgpols, *poles;

{
  int k, n, m;
  if ( uv == 1 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      poles[n]   = edgpols[n]  ;
      poles[n+1] = edgpols[n+1];
      poles[n+2] = edgpols[n+2];
    }
  }
  else if ( uv == 2 )
  {
    for ( k = 0; k < unp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * unp * (vnp-1) + n;
      poles[m]   = edgpols[n]  ;
      poles[m+1] = edgpols[n+1];
      poles[m+2] = edgpols[n+2];
    }
  }
  else if ( uv == 3 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * k * unp;
      poles[m]   = edgpols[n]  ;
      poles[m+1] = edgpols[n+1];
      poles[m+2] = edgpols[n+2];
    }
  }
  else if ( uv == 4 )
  {
    for ( k = 0; k < vnp; k = k + 1 )
    {
      n = 3 * k;
      m = 3 * ((k+1) * unp - 1);
      poles[m]   = edgpols[n]  ;
      poles[m+1] = edgpols[n+1];
      poles[m+2] = edgpols[n+2];
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	*/

get_edge_info ( p_max, poles, sf )

  IGRdouble              *p_max, *poles;
  struct IGRbsp_surface  *sf;

{
  IGRint         i, j, jj, k, m, mm, index;
  IGRint         idx0[6], idx1[6], uv;
  IGRint         uord, vord, unmp, vnmp, unmk, vnmk, nk;
  IGRint         co_inc, cnt, np, num_edg;
  IGRlong        rc;
  IGRdouble      max_dst, dist, eps;
  IGRdouble      pt0[12], pt1[12];
  IGRdouble      upar[2], vpar[2], ds0[8], ds1[4];
  IGRdouble     *edgpol0, *edgpol1;

  eps     = 1e-3;

  cnt     = 0;
  co_inc  = 0;
  max_dst = 0;
  num_edg = 4;

  upar[0] = 0.0;
  upar[1] = 1.0;
  vpar[0] = 0.0;
  vpar[1] = 1.0;

  uord   = sf->u_order;
  vord   = sf->v_order;
  unmp   = sf->u_num_poles;
  vnmp   = sf->v_num_poles;
  unmk   = sf->u_num_knots;
  vnmk   = sf->v_num_knots;

  *p_max = max_dst;

  // Get the 4 vertices of the surface
  BSsfarrev0 ( &rc, sf, 2, upar, 2, vpar, pt0 ); if (BSERROR(rc)) goto wrapup;

  // Copy vertices to pt1[] and "align" each vertex
  memcpy ( &pt1[0], &pt0[0], 12 * 8 );
  for ( i=0; i < 12; i=i+3)
  {
    pt1[i+direc] = align_val;
  }

  // Check for co-incident vertices
  if (VDcomment)
  {
    printf ( ">>>>> Check for co-incident vertices <<<<<\n" );
  }
  k = 0;
  for ( i=0; i < 9; i=i+3)
  {
    for ( j=i+3; j < 12; j=j+3)
    {
      ds0[k] = BSdistptpt ( &rc, &pt0[i], &pt0[j] );
      if (VDcomment)
      {
        printf ( "pt0[%d]= %lf %lf %lf\n", i/3, pt0[i], pt0[i+1], pt0[i+2] );
        printf ( "pt0[%d]= %lf %lf %lf, ds0[%d] = %lf\n", j/3, pt0[j], pt0[j+1], pt0[j+2], k, ds0[k] );
      }
      if ( ds0[k] < eps )
      {
        idx0[co_inc] = i;
        idx1[co_inc] = j;
        co_inc       = co_inc + 1;
        num_edg      = num_edg - 1;
      }
      k = k + 1;
    }
  }
  if (VDcomment)
  {
    printf ( "num_edg = %d, co_inc = %d, k = %d\n", num_edg, co_inc, k );
    printf ( ">>>>> Check distance between vertices and the 'aligned' vertices <<<<<\n" );
  }

  // Now check distance between vertices and the "aligned" vertices
  for ( i=0; i < 12; i=i+3)
  {
    dist = BSdistptpt ( &rc, &pt0[i], &pt1[i] );

    if (VDfunct)
    {
      printf ( "i = %d, cnt = %d, ds1[%d] = %lf\n", i, cnt, i/3, ds1[i/3] );
    }
    if ( dist < align_tol )
    {
      ds1 [cnt] = dist;
      idx0[cnt] = i;
      cnt = cnt + 1;
    }
  }

  if (VDcomment)
  {
    for ( i=0; i < 12; i=i+3)
    {
      dist = BSdistptpt ( &rc, &pt0[i], &pt1[i] );
      printf ( "Original vertices: pt0[%d]= %lf %lf %lf\n", i/3, pt0[i], pt0[i+1], pt0[i+2] );
      printf ( "Aligned  vertices: pt1[%d]= %lf %lf %lf, dist = %lf\n", i/3, pt1[i], pt1[i+1], pt1[i+2], dist );
    }
    for ( i=0; i < cnt; i=i+1)
    {
      {
        printf ( "idx0[%d] = %d, ds1[%d] = %lf\n", i, idx0[i], i, ds1[i] );
      }
    }
  }

  // Only consider well behaved surfaces with 3 or 4 boundaries
  // Only ONE vertex needs to be aligned

  if ( cnt == 1 && (num_edg == 3 || num_edg == 4) )
  {
    index = idx0[0] / 3;

    if ( index == 0 || index == 1 )
    {
      m = 3 * index * (unmp - 1);
    }
    else if ( index == 2 )
    {
      m = 3 * unmp * (vnmp-1);
    }
    else if ( index == 3 )
    {
      m = 3 * (unmp * vnmp - 1);
    }
    pt0[0]         = sf->poles[m+0];
    pt0[1]         = sf->poles[m+1];
    pt0[2]         = sf->poles[m+2];

    pt1[0]         = pt0[0];
    pt1[1]         = pt0[1];
    pt1[2]         = pt0[2];
    pt1[direc]     = align_val;

    dist           = BSdistptpt ( &rc, &pt0[0], &pt1[0] );
    max_dst        = dist;
    *p_max         = max_dst;

    sf->poles[m+0] = pt1[0];
    sf->poles[m+1] = pt1[1];
    sf->poles[m+2] = pt1[2];

//    if (VDcomment)
    {
      printf ( ">>>>> Only ONE vertex needs to be aligned <<<<<\n" );
      printf ( "Original vertex: pt0[%d]= %lf %lf %lf\n", m/3, pt0[0], pt0[1], pt0[2] );
      printf ( "Aligned  vertex: pt1[%d]= %lf %lf %lf, dist = %lf\n", m/3, pt1[0], pt1[1], pt1[2], dist );
    }
  }

  // Only consider well behaved surfaces with 3 or 4 boundaries
  if ( (cnt != 2 && cnt != 3) || (num_edg != 3 && num_edg != 4) )
    goto wrapup;

  for ( i=0; i < cnt - 1; i=i+1)
  {
    jj = idx0[i];
    for ( j=i+1; j < cnt; j=j+1)
    {
      mm = idx0[j];
      uv = 0;
      if ( jj == 0 && mm == 3 || jj == 3 && mm == 0 )
      {
        uv = 1;		// Case: V = 0
        np = unmp;
        nk = unmk;
      }
      else if ( jj == 6 && mm == 9 || jj == 9 && mm == 6 )
      {
        uv = 2;		// Case: V = 1
        np = unmp;
        nk = unmk;
      }
      else if ( jj == 0 && mm == 6 || jj == 6 && mm == 0 )
      {
        uv = 3;		// Case: U = 0
        np = vnmp;
        nk = vnmk;
      }
      else if ( jj == 3 && mm == 9 || jj == 9 && mm == 3 )
      {
        uv = 4;		// Case: U = 1
        np = vnmp;
        nk = vnmk;
      }

      if ( uv == 0 )	// Invalid case, such as diagonal combinations: 0-9 or 3-6
      {
        continue;
      }
      if (VDcomment)
      {
        printf ( ">>>>> UV edge to align = %d <<<<<\n", uv );
      }

      if ( uv == 1 || uv == 2 )		// Case: V = 0 (1st row) OR V = 1 (last row)
      {
        edgpol0 = ( IGRdouble * ) malloc ( unmp * 24 );
        edgpol1 = ( IGRdouble * ) malloc ( unmp * 24 );
        get_poles ( uv, unmp, vnmp, edgpol0, poles );
        memcpy ( edgpol1, edgpol0, unmp * 24 );

        for ( k = 0; k < unmp; k = k + 1 )
        {
          m = 3 * k;
          edgpol0[m+direc] = align_val;
        }
      }
      else if ( uv == 3 || uv == 4 )	// Case: U = 0 (1st column) OR U = 1(last column)
      {
        edgpol0 = ( IGRdouble * ) malloc ( vnmp * 24 );
        edgpol1 = ( IGRdouble * ) malloc ( vnmp * 24 );
        get_poles ( uv, unmp, vnmp, edgpol0, poles );
        memcpy ( edgpol1, edgpol0, vnmp * 24 );

        for ( k = 0; k < vnmp; k = k + 1 )
        {
          m = 3 * k;
          edgpol0[m+direc] = align_val;
        }
      }

//      if (VDcomment)
      {
        max_dst = 0;
        for ( k = 0; k < np; k = k + 1 )
        {
          m = 3 * k;
          dist = BSdistptpt ( &rc, &edgpol0[m], &edgpol1[m] );
          if ( dist > max_dst )
          {
            max_dst = dist;
          }
          printf ( "edgpol0[%2d] = %lf %lf %lf, max_dst = %lg, dist = %lg\n",
                   k, edgpol0[m+0], edgpol0[m+1], edgpol0[m+2], max_dst, dist );
        }
        if ( max_dst > 0 )
        {
          for ( k = 0; k < np; k = k + 1 )
          {
            m = 3 * k;
            printf ( "edgpol1[%2d] = %lf %lf %lf\n", k, edgpol1[m+0], edgpol1[m+1], edgpol1[m+2] );
          }
        }
      }

      // Print knot vectors
      if (VDmethod)
      {
        if ( uv < 2 )
        {
          for ( k = 0; k < nk; k = k + 1 )
          {
            printf ( "Surface u_knots[%d] = %lf\n", k, sf->u_knots[k] );
          }
        }
        else
        {
          for ( k = 0; k < nk; k = k + 1 )
          {
            printf ( "Surface v_knots[%d] = %lf\n", k, sf->v_knots[k] );
          }
        }
      }

      // ============================================
      // ***** Replace edgpol1[] with edgpol0[] *****
      // ============================================
      for ( k = 0; k < np; k = k + 1 )
      {
        m = 3 * k;
        edgpol1[m+0] = edgpol0[m+0];
        edgpol1[m+1] = edgpol0[m+1];
        edgpol1[m+2] = edgpol0[m+2];
      }
      if ( max_dst > 0 )
        printf ( ">>>>> Max_Dist = %lg,  Number of poles to align = %d <<<<<\n", max_dst, np);

      set_poles ( uv, unmp, vnmp, edgpol1, poles );

      // Ignore rational for the time being ?!?!?
      // if ( sf->rational == FALSE )
      {
        for ( k = 0; k < unmp * vnmp; k = k + 1 )
        {
          m = 3 * k;
          sf->poles[m+0] = poles[m+0];
          sf->poles[m+1] = poles[m+1];
          sf->poles[m+2] = poles[m+2];
        }
      }
    }

    if ( edgpol0 )
    {
      free(edgpol0);
      edgpol0 = NULL;
    }
    if ( edgpol1 )
    {
      free(edgpol1);
      edgpol1 = NULL;
    }
  }

  *p_max   = max_dst;

wrapup:
  if ( edgpol0 )
  {
    free(edgpol0);
    edgpol0 = NULL;
  }
  if ( edgpol1 )
  {
    free(edgpol1);
    edgpol1 = NULL;
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
