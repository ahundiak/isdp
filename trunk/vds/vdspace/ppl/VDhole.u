/* $Id: VDhole.u,v 1.1.1.1 2001/01/04 21:09:23 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vdspace/ppl / VDhole.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDhole.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:23  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bstypes.h"
#include "bserr.h"
#include "bsconic.h"
#include "emsedgedef.h"
#include "EMSmsgdef.h"
#include "EMScmacros.h"
#include "macro.h"
#include "nddef.h"
#include "VDSutil_def.h"
#include "acmacros.h"
#include "DIdef.h"
#include "COmdef.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "AS_status.h"

#define   VERBOSE 	1
#define   EPSILON	1.0E-10
#define   MAX_TEMP	10 	/* number of templates */
#define	  MAX_CHA_TEMP	7
#define	  MAX_CHA_ROOT	4

#define	  MAXINT	20
#define	  ORDER		2

#define ACkeep_template 1024

/*#define   DEBUG		1*/
/*#define   DEBUG3	1*/

/* Different kind of intersections, the first word is for the support */


struct GRid		par_obj, CI_MACRO_ID,obj,mac, def_temp;
GRobj 			ci_mac_def1, ci_mac_def2;
IGRchar			*temp_names[MAX_TEMP], *feet_names[1];
IGRint			temp_types[MAX_TEMP];

struct IGRbsp_surface   **bsp_surf1,**bsp_surf2;
struct IGRbsp_curve	*bsp_curve, **merges, **pr_curve, *curve[MAX_TEMP-2], 
			*p_curve[MAX_TEMP-2], *merge_cv;
struct IGRbsp_bdry_pts  bdry;
struct IGRplane		plane[2];
struct ret_struct	temp1_rts;

struct GRmd_env         MOD_ENV;
struct GRvg_construct   cst;
struct IGRdisplay	dis;
struct GRid		SPROJ, SUR[MAX_TEMP] ,WRK_SUR,
			GRid_list;

IGRdouble		point_on[3*(MAX_TEMP-2)],range[6], v1[3], point[3],
			matrix[16], du[3], dv[3], dirvect[3],obj_range[6],
			q_pl[3], u_pl[3], u[2], q[2],us[2], qs[2], coef, fact,
			chrdht_tol,calc_tol,tol,plane_space[12],v2[3],**par1,
			**par2, *over0 , *over1 ,pt0[3], pt1[3], 
			*p_par1[MAX_TEMP-2], n_over, *p_par2[MAX_TEMP-2],
			save_pts[6*(MAX_TEMP-2)],d_par, par, parr1,parr2[2],
			*int_pts[MAX_TEMP-2], intpts1[3], intpts2[3], *end_pts,
 			**pts, **in_pts, **out_pts,
			**Xpts, **Xpar1, **Xpar2, dist1,dist2;
			

IGRboolean 	        test_degeneracy, construct_loopset, world, in_range,
			orient_known, pos_orient, wind_loopset, msg_status;

char			infinite, buff[MAX_TEMP*MAX_CHA_TEMP], path[80];

unsigned IGRchar	curve_type;

long			stat, status, msg, nput, nret;

IGRint			return_type,type_flag,snb_int,i_onecv,nb_merge,*Xnumpts,
			elem_type[MAX_TEMP],*in_nbpts,*out_nbpts,nb_retsf,
			num_merge,num_alloc, num_ent, *numpts, Xnumgrps, 
                        numgrps, n_int, total_num_poles, size, num_pts, nb_sf1,
			nb_sf2, flag, two_intersect, rev, int_flag, open_cv, 
			close_cv, split_ind, i, j, k, l;

BSrc			rc;

IGRshort		order, mat_type[MAX_TEMP-1];

GRclassid		obj_classid;
struct GRprops			properties;

extern GRclassid	OPP_EMSplane_class_id, OPP_EMSsurface_class_id, 
			OPP_GRcurve_class_id,OPP_EMScompsurf_class_id,
			OPP_EMSsfimpbnd_class_id;

extern int 	init_cnst_list(), ASsuper_construct(),
		GRdpb_get(),
		sprintf(),
		printf(),
		BSmkvec(),
		free(),
		BSfreecv(),
		BScvcv_int(),
		BSpartofcv(),
		BSrev_cv(),
		BSalloccv(),
                BSpjcvtsf(),
	        BSsfnormal(),
                BSprj_cv_pl(),
		SMelem_(),
		VDint(),
		VDSfree(),
		VDSdist2(),
		VDSfill_curve(),
		VDSorder_curves(),
		VDSorder_pt(),
		VDclose_bnd(),
		ACcreate_def_temp();

extern char        *malloc();
extern double      fabs(), BSdistptpt(), BSdotp();
extern		   BSpartofsf();

extern IGRboolean  BSfreesf();


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  struct ret_struct ret_str[MAX_TEMP];
  struct GRid def_col;
  feet_names[0] = "surf";

  temp_names[0] = "support";  
  temp_types[0] = other_generic;

  for (i=1; i<MAX_TEMP; i=i+1)
  {
	strcpy (&buff[i*MAX_CHA_TEMP],"surf");
	sprintf(&buff[i*MAX_CHA_TEMP+MAX_CHA_ROOT],"%d",i);
	temp_names[i] = &buff[i*MAX_CHA_TEMP];
        temp_types[i] = other_generic | curve_generic | line_generic | conic_generic;
  }

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          	= ci_mac_def1,
		prop 		  	= ACvariable_template|ACkeep_template,
		status 	          	= &stat,
		name              	= "VDhole",
             	temp_num  		= MAX_TEMP,
 		temp_names 		= temp_names,
                temp_types 		= temp_types,
	      	extern_feet_num 	= 1, 
		extern_feet_names 	= feet_names);

 /* Put the default value */
 ret_str[0].type = other_generic;
 ret_str[1].type = other_generic;
 ret_str[2].type = other_generic;
 ret_str[3].type = other_generic;
 ret_str[4].type = other_generic;
 ret_str[5].type = other_generic;
 ret_str[6].type = other_generic;
 ret_str[7].type = other_generic;
 ret_str[8].type = other_generic;
 ret_str[9].type = other_generic;
 mac.objid = ci_mac_def1;
 mac.osnum = AC_construct_id.osnum;

#if 0
 ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_temp	   = &def_temp,
		     value	   = ret_str);
#endif

/* Change for 2.0 */
  ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_col       = &def_temp,
		     temp_val	   = ret_str);
}

/* ========================================================================= */

place ()
{

  surf_intersect();
  if( GRid_list.objid == NULL_OBJID ) return(0);
  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }

  return(1);
}


/* ========================================================================= */

compute ()
{
  surf_intersect();

  // if( GRid_list.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }
  return(1);
}

/* ========================================================================= */

surf_intersect()

{
 /* init of pointers */

# ifdef DEBUG3
  printf("surf_intersect begin\n"); 
# endif

  over0        = NULL;
  over1        = NULL;
  end_pts      = NULL;
  numpts       = NULL;
  pts          = NULL;
  par1         = NULL;
  par2         = NULL;
  merge_cv     = NULL;
  merges       = NULL;
  pr_curve     = NULL;
  bsp_surf1    = NULL;
  bsp_surf2    = NULL;
  bsp_curve    = NULL;
  in_pts       = NULL;
  out_pts      = NULL;
  in_nbpts     = NULL;
  out_nbpts    = NULL;
  snb_int      = 0;
  bdry.points  = NULL;

  close_cv = 0;
  open_cv  = 0;

  plane[0].point  = &plane_space[0];
  plane[0].normal = &plane_space[3];
  plane[1].point  = &plane_space[6];
  plane[1].normal = &plane_space[9];

  GRid_list.objid = NULL_OBJID;

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&num_ent),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);

  if(stat == OM_E_ABORT)  return(0);


# ifdef DEBUG1
  printf("intersect surf, num_ent: %d\n", num_ent);
# endif

  if (num_ent ==0) goto wrapup;

  nput = sizeof(tol);

  gr$get_basis_tolerance(msg    = &msg, 
                         sizbuf = &nput, 
                         buffer = &tol, 
                         nret   = &nret);

# ifdef DEBUG1
  printf("basis_tolerance: %lf\n",tol);
# endif


/* ----------------------------------------------------------------------- 

  Retrieve the templates and calculate the max range of the support
  
  ----------------------------------------------------------------------- */

 for(i=0;i<num_ent;i=i+1)
   {
#    ifdef DEBUG1
     printf("Retrieve the template for the template \n");
#    endif

     msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,i,&SPROJ),
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );

     if(stat == 0 ) return(0);
     if(stat == 3 ) SUR[i] = SPROJ;
     else
      {
       /* DOES NOT WORK WITH OBJECTS BELONGING TO DIFFERENTS OS */
        stat = ci$send( msg = message ASnode.ASreturn_go( 
                                          &SUR[i], &mat_type[i], matrix ),
	      	        targetid = SPROJ.objid,
	                targetos = SPROJ.osnum );
        if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
      }

     /* we retrieve informations in two steps because the free pb if object 
     /* has been consumed */

#    ifdef DEBUG1
     printf("Retrieve the type of the element: %d, %d\n", SUR[i].objid,  
                                                         SUR[i].osnum);
#    endif

   } /* end for(i=0 ....) */


/* ----------------------------------------------------------------------- 

   we have (num_ent) objects that will give (num_ent-1) intersection cv
   we make intersection between support and surface i and create the
   intersection curve => curve[i-1] 

   ----------------------------------------------------------------------- */

 for(i=0;i<num_ent;i=i+1)
  {
    if(mat_type[i]!=2 /* MAIDMX */) 
     {      
      	stat = ci$send( msg = message GRvg.GRgeomprops(&msg, &mat_type[i], 
					matrix,&properties),
	      	        targetid = SUR[i].objid,
	                targetos = SUR[i].osnum );
      	if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
     }

#   ifdef DEBUG3
    printf("Retrieve the topologie of: %d, %d\n", SUR[i].objid,  SUR[i].osnum);
#   endif

    if(i==0)
     {
      /*| Only for the support */

      type_flag = SURF;
#     ifdef DEBUG1
      printf("type_flag: %d\n",type_flag);
#     endif
      bsp_curve = NULL;
      nb_sf1 = 0;
      stat = SMelem_(type_flag, &SUR[i], mat_type[i], matrix, &elem_type[0], 
		     &plane[0], &bsp_surf1, &bsp_curve, &nb_sf1);
      if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 
      if(elem_type[0] == CURV) 
          {printf("ERROR: support cannot be a curve\n");goto wrapup; } 
      if(nb_sf1>1) {printf("support composite not implemented\n");goto wrapup;}

#     ifdef DEBUG
      if(bsp_surf1 != NULL )
       {
         
    	for(k=0;k<nb_sf1;k=k+1)
         printf("bsp_sf1 u_num_poles: %d, v_num_poles: %d\n",bsp_surf1[k]->u_num_poles,
		bsp_surf1[k]->v_num_poles);
       }
#     endif

      if(elem_type[0] == PLAN)
       {
        printf("error no plane but surface\n");
        goto wrapup;
       }
     }
    else 
     {
      /* i<>0 */
      type_flag = SURF;
#     ifdef DEBUG1
      printf("type_flag: %d\n",type_flag);
#     endif
      bsp_curve = NULL;
      bsp_surf2 = NULL;
      nb_sf2 = 0;
      stat = SMelem_(type_flag, &SUR[i], mat_type[i], matrix, &elem_type[i], 
		     &plane[1], &bsp_surf2, &bsp_curve, &nb_sf2);
      if (!(stat&1)){ om$report_error(sts=stat); goto wrapup; } 

      if(bsp_surf2 != NULL)
       {
#     ifdef DEBUG
    	for(k=0;k<nb_sf2;k=k+1)
         printf("bsp_sf2 u_num_poles: %d, v_num_poles: %d\n",bsp_surf2[k]->u_num_poles,
		bsp_surf2[k]->v_num_poles);
#     endif
       }
      if(elem_type[i] == PLAN)
       {
        printf("error no plane but surface\n");
        goto wrapup;
       }
#     ifdef DEBUG
      if(elem_type[i] == CURV) 
                printf("curve.num_poles: %d\n",bsp_curve->num_poles);
#     endif
     }/* end else ... */

    if(i==0) continue;
    if (elem_type[i] == CURV && bsp_curve->phy_closed == TRUE && num_ent !=2)
     {
       printf("ERROR:the curve is closed and need to be alone on the support\n");
       goto wrapup;
     } 
#   ifdef DEBUG
    printf("\n\nCompute intersection between the support and the surface # %d\n", i);
    printf("elem_type[0]: %d\n",elem_type[0]);
    printf("elem_type[i]: %d\n",elem_type[i]);
#   endif
    numgrps = 0;
    num_pts = 0;
    par1 	 = NULL;
    par2         = NULL;
    numpts       = NULL;
    pts          = NULL;
    if(elem_type[0] == SURF)
     {
        if(elem_type[i] == SURF)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, SURF, bsp_surf2, NULL,1,
                         &numgrps, &numpts, &pts , &par1, &par2);

          }
         else if(elem_type[i] == COMP_SF)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, COMP_SF, bsp_surf2, NULL,nb_sf2,
                         &numgrps, &numpts, &pts , &par1, NULL);

          }
         else
          {
#           ifdef DEBUG3
            printf("project curve on surface\n");
#           endif

            BSsfnormal(bsp_surf1[0], dirvect, &rc);
            BSpjcvtsf(bsp_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
            if (rc!= BSSUCC)
             { 
               printf("surf_int, Bad projection on the surface: %d\n",rc);
               numgrps = 0;
             }
        
          }
     } 
    else 
     {
        printf("invalid support, composite support not implemented\n");
        goto wrapup;
     } 
    if(!(stat&1))
     {
        printf("surf_int: ERROR in VDint function\n");
        goto wrapup;
     }
    if(numgrps < 1) 
     {
#       ifdef DEBUG3
        printf("surf_int: (numgrp<1)no intersection found with the %d surface\n",i);
#       endif
       
        /* keep a point on a surface to extract curve in good sens */

        if(elem_type[i] == CURV)
         {
           point_on[3*(i-1)]   = bsp_curve->poles[0];
           point_on[3*(i-1)+1] = bsp_curve->poles[1];
           point_on[3*(i-1)+2] = bsp_curve->poles[2];
         }
        else if(bsp_surf2 != NULL)
         {
           point_on[3*(i-1)]   = bsp_surf2[0]->poles[0];
           point_on[3*(i-1)+1] = bsp_surf2[0]->poles[1];
           point_on[3*(i-1)+2] = bsp_surf2[0]->poles[2];
         }
        curve[i-1] = NULL;
        VDSfree(nb_sf2,&bsp_surf2); 
        if(bsp_curve != NULL) {free(bsp_curve);bsp_curve = NULL;}
        if(numpts != NULL) { free(numpts); numpts = NULL; }
        VDSfree(numgrps,&pts);
        VDSfree(numgrps,&par1);
        VDSfree(numgrps,&par2);
        continue;
     }
    num_pts = numpts[0];

#    ifdef DEBUG
     printf("surfaces intersect stat = %d, numgrps= %d\n",rc,numgrps);
     printf("num_pts: %d\n",num_pts);
     for (l=0; l<numgrps; l=l+1)
      {
        if(numpts != NULL)
         {  
  	   printf("num_pts[%d] = %d\n",l,numpts[l]);
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
	      if(pts != NULL) printf("point : %lf, %lf, %lf\n",
                                     pts[l][3*k],pts[l][3*k+1],pts[l][3*k+2]);
	    }
	   for(k=0;k<numpts[l] ;k=k+1)
	    { 
              if(par1 != NULL) printf("par1: %lf, %lf\n", par1[l][2*k], par1[l][2*k+1]);
              if(par2 != NULL) printf("par2: %lf, %lf\n", par2[l][2*k], par2[l][2*k+1]);
	    }
         }
       }
#    endif

if(numgrps > 1)
 {
   /* ----- 
     make a unique gpe if possible (because of bug in BS intersect function
     that returns sometimes 2 gpes of intersections that are contiguous instead 
     of giving only one gpe that will gather the 2)
      ------ */

   Xnumpts	= NULL;
   Xpts		= NULL;
   Xpar1	= NULL;
   Xpar2	= NULL;

   stat = VDSorder_pt(numgrps, &numpts[0], pts, par1, par2, &Xnumgrps, 
		       &Xnumpts, &Xpts, &Xpar1, &Xpar2);
   if(!(stat & 1)){printf("ERRROR VDSorder_pts\n"); goto wrapup;}

   if(Xnumgrps != 1)
    {
      /*|cannot make a unique gpe */
      if(Xnumpts != NULL) { free(Xnumpts); Xnumpts = NULL; }
      VDSfree(Xnumgrps,&Xpts);
      VDSfree(Xnumgrps,&Xpar1);
      VDSfree(Xnumgrps,&Xpar2);
    }
   else
    {
      if(numpts != NULL) { free(numpts); numpts = NULL; }
      VDSfree(numgrps,&pts);
      VDSfree(numgrps,&par1);
      VDSfree(numgrps,&par2);
      numgrps = Xnumgrps;
      numpts  = Xnumpts;
      pts     = Xpts;
      par1    = Xpar1;      
      par2    = Xpar2;      
    }
#  ifdef DEBUG
   printf("total result ====================\n");
     for (l=0; l<numgrps; l=l+1)
      {
        if(numpts != NULL)
         {  
  	   printf("num_pts[%d] = %d\n",l,numpts[l]);
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
	      if(pts != NULL) printf("point : %lf, %lf, %lf\n",
                                     pts[l][3*k],pts[l][3*k+1],pts[l][3*k+2]);
	    }
	   for(k=0;k<numpts[l] ;k=k+1)
	    { 
              if(par1 != NULL) printf("par1: %lf, %lf\n", par1[l][2*k], par1[l][2*k+1]);
              if(par2 != NULL) printf("par2: %lf, %lf\n", par2[l][2*k], par2[l][2*k+1]);
	    }
         }
      }
#  endif
 }

 num_pts = numpts[0];

 save_pts[6*(i-1)]   = pts[0][0]; 
 save_pts[6*(i-1)+1] = pts[0][1];  		/* first point of curve[i-1] */
 save_pts[6*(i-1)+2] = pts[0][2]; 

 save_pts[6*(i-1)+3] = pts[0][3*(numpts[0]-1)]; 
 save_pts[6*(i-1)+4] = pts[0][3*(numpts[0]-1)+1]; /* last point of curve[i-1] */
 save_pts[6*(i-1)+5] = pts[0][3*(numpts[0]-1)+2]; 

#ifdef DEBUG
 printf("save_pts[%d]\n",6*(i-1));
 printf("save_pts: %lf, %lf, %lf\n",save_pts[6*(i-1)],
                                    save_pts[6*(i-1)+1],save_pts[6*(i-1)+2]);
 printf("save_pts: %lf, %lf, %lf\n",save_pts[6*(i-1)+3],
                                    save_pts[6*(i-1)+4],save_pts[6*(i-1)+5]);
 printf(" \n");
#endif

 VDSfree(nb_sf2,&bsp_surf2); 
 if(bsp_curve != NULL) {free(bsp_curve);bsp_curve = NULL;}
 curve[i-1] = NULL;

 /* ---------------
    Allocate the space for the bspline curve 
    WARNING, we always take only the first intersection 
    ------------ */

#   if DEBUG3
    printf("define curve for surface/anything\n");
#   endif

    stat = VDSfill_curve(num_pts, NULL, par1[0], &curve[i-1]);
    if(!(stat & 1)){printf("ERROR VDSfill_curve\n");goto wrapup;}
      
#ifdef DEBUG
 for(k=0;k<num_pts && k<10;k=k+1)
        printf("pts: %lf, %lf, %lf\n", 
                curve[i-1]->poles[3*k],curve[i-1]->poles[3*k+1],curve[i-1]->poles[3*k+2]);
    
 for(k=0;k<num_pts + ORDER && k<10;k=k+1) printf("knot: %lf\n",curve[i-1]->knots[k]);

#endif

 if (close_cv)     	curve[i-1]->phy_closed  = TRUE; 
 else	      	curve[i-1]->phy_closed  = FALSE;   
 curve[i-1]->weights     = NULL;
 curve[i-1]->planar      = TRUE;
 curve[i-1]->non_uniform = FALSE;
 curve[i-1]->periodic    = FALSE;

 /* Deallocation of the pointeurs */

 if(numpts != NULL) { free(numpts); numpts = NULL; }
 VDSfree(numgrps,&pts);
 VDSfree(numgrps,&par1);
 VDSfree(numgrps,&par2);

 }  /* End of  for(i=0;i<num_ent;i=i+1) */

/* -------------------------------------------------------------------- 

   compute the intersection points between each curve and its successor
   in the parameter definition of the support when it is a surface, 
   in RxRxR for a plane.

   The intersection point (curve[i], curve[i+1]) will have p_par1[i+1]
   param on curve i and p_par2[i+1] on curve i+1. The last intersection 
   point (curve[num_ent-2], curve[0]) will have p_par1[0] on curve num_ent-2
   and p_par2[0] on curve 0.

   We don't treat multiple intersections except in the case of 2 curves
   intersecting each other 2 times (creating a loop) 

   -------------------------------------------------------------------- */


#ifdef DEBUG3
 for(i=0;i<num_ent-1;i=i+1)
    if(curve[i] == NULL) printf("curve[%d] est NULL\n",i);
#endif

 num_merge = 0;
 i_onecv = -1;
 for(i=0;i<num_ent-1;i=i+1)
  { 
    if(curve[i] != NULL) 
       {num_merge = num_merge + 1;i_onecv = i; }
#   ifdef DEBUG
    printf("i_onecv: %d\n",i_onecv);
#   endif
  }

# ifdef DEBUG
  printf("num_merge: %d\n",num_merge);
# endif

  if(num_merge == 0)
   {
    printf("ERROR:no intersection between support and any surface\n");
    goto wrapup;
   }
  two_intersect = 0;

for(i=-1;i<num_ent-2;i=i+1)
  {
    p_par1[i+1]  = NULL;
    p_par2[i+1]  = NULL;
    int_pts [i+1]= NULL;
    over0        = NULL;
    over1        = NULL;
    end_pts      = NULL;

#   ifdef DEBUG3
    printf("COMPUTE THE INTERSECTION POINTS of curves\n");
#   endif

    if(num_ent == 2) {/*printf("one line on support\n");*/break;}
    if(close_cv) break;
    if(open_cv && num_ent == 2) {printf("1 open_cv \n");break;}

#   ifdef DEBUG3
    printf("\n\nIntersection # %d\n",i);
#   endif


    /* ------------------------------------------------------------------

       if num_ent = 3 ie 2 curve on support, case of 2 intersections is
       treated with one cvcv_int 

       ------------------------------------------------------------------ */

    if(i==-1 && num_ent == 3) continue;/* 2 cv on support */

#   ifdef DEBUG3
    printf("cvcvint...........\n");
#   endif

    if(i==-1 )
     {
       if(curve[num_ent-2] != NULL && curve[0]!= NULL)
         BScvcv_int(&rc, curve[num_ent-2], curve[0], &n_int, &int_pts[0], 
      		    &p_par1[0], &p_par2[0], &n_over, &end_pts, &over0, &over1);
       else continue;
     }
    else 
     {
       if(curve[i] != NULL && curve[i+1] != NULL)
         BScvcv_int(&rc, curve[i], curve[i+1], &n_int, &int_pts[i+1], 
		    &p_par1[i+1], &p_par2[i+1], &n_over, &end_pts, &over0, &over1);
       else continue;
     }
    if(rc != BSSUCC || n_int < 1 || n_over > 0)
     {
       if(rc == BSSUCC && i== -1)
        {
#         ifdef DEBUG3
          printf("cv0 & cvn n'ont pas d'intersection\n");
#         endif

          open_cv = 1;
          if(p_par1[0] != NULL) {free(p_par1[0]); p_par1[0] = NULL;}
          if(p_par2[0] != NULL) {free(p_par2[0]); p_par2[0] = NULL;}
   	  if(int_pts[0]!= NULL) {free(int_pts[0]);int_pts[0] = NULL;}
   	  if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	  if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	  if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
          continue;
        }
       printf("surf_int, ERROR bad curve intersection (%d)\n", i+1);
       printf("rc: %d, nb_int: %d\n",rc,n_int);

       /* WE must deallocate the stuff */

       for(k=0; k<=i+1; k=k+1)
        {
         if(p_par1[k] != NULL) {free(p_par1[k]); p_par1[k]=NULL;}
         if(p_par2[k] != NULL) {free(p_par2[k]); p_par2[k]=NULL;}
   	 if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
        }
       for(k=0; k<num_ent-1; k=k+1)
        {
	 if(curve[k] != NULL) 
          {
            BSfreecv(&rc, curve[k]);	
            curve[k]=NULL;
	    if (rc !=BSSUCC && rc!=BSNULL) 
		{printf("BSfreecv(curve) fail rc: %d\n",rc);goto wrapup;}
	  }
        }
       goto wrapup;
      }

#   ifdef DEBUG
    printf("number of intersection: %d, de over: %d\n", n_int, n_over);
    for(k=0; k<n_int && k<10; k=k+1)
     {
       printf("coord sur le sup: %lf, %lf, %lf\n",int_pts[i+1][3*k],int_pts[i+1][3*k+1],int_pts[i+1][3*k+2]);
       printf("param: %lf\n",   p_par1[i+1][k]);
       printf("param: %lf\n\n", p_par2[i+1][k]);
     }
#   endif

    if(n_int > 2) 
     {
       printf("surf_int, Error more than two intersections\n");
       /* WE must deallocate the stuff */
       for(k=0; k<=i+1; k=k+1)
        {
          if(p_par1[k] != NULL) {free(p_par1[k]); p_par1[k] = NULL;}
          if(p_par2[k] != NULL) {free(p_par2[k]); p_par2[k] = NULL;}
   	  if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
        }
       for(k=0; k<num_ent-1; k=k+1)
        {
	  if(curve[k]!=NULL) 
           {
             BSfreecv(&rc, curve[k]); 
             curve[k]=NULL;
	     if (rc !=BSSUCC && rc!=BSNULL) 
                 {printf("BSfreecv(curve) fail\n");goto wrapup;}
           }
        }
       goto wrapup;
     }
    else if(n_int == 2)
     {
       if(num_ent != 3)
        {
          printf("surf_int, 2 intersections, NOT yet implemented\n");
          /* WE must deallocate the stuff */

          for(k=0; k<=i+1; k=k+1)
           {
            if(p_par1[k] != NULL) {free(p_par1[k]); p_par1[k] = NULL;}
            if(p_par2[k] != NULL) {free(p_par2[k]); p_par2[k] = NULL;}
   	    if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
           }
          for(k=0; k<num_ent-1; k=k+1)
           {
	    if(curve[k]!=NULL) 
             {
               BSfreecv(&rc, curve[k]); 
               curve[k]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                 {printf("BSfreecv(curve) fail\n");goto wrapup;}
             }
           }
          goto wrapup;
        }
       else
        {
#	 ifdef DEBUG
         printf(" Specific case, two curves and two intersections \n");
#	 endif

	 two_intersect=1;
         p_curve[0] = NULL;
         order 	   = curve[0]->order;
         BSalloccv(order, curve[0]->num_poles + 2 * order - 1, 
                   curve[0]->rational, curve[0]->num_boundaries ,&p_curve[0], 
                   &rc);
         if(rc != BSSUCC && rc!=BSNULL) 
          { 
            printf("surf_int, Bad allocation for the curves\n");
            for(k=0; k<=i+1; k=k+1)
             {
   	      if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
              if(p_par1[k] != NULL) {free(p_par1[k]); p_par1[k] = NULL;}
              if(p_par2[k] != NULL) {free(p_par2[k]); p_par2[k] = NULL;}
             }
            for(k=0; k<num_ent-1; k=k+1)
             {
	      if(curve[k] != NULL) 
               {
                  BSfreecv(&rc, curve[k]); 
                  curve[k]=NULL;
	          if (rc !=BSSUCC && rc!=BSNULL) 
                        {printf("BSfreecv(curve) fail\n");goto wrapup;}
	       }
             }
            goto wrapup;
          }
         d_par=(p_par1[1][1]+p_par1[1][0])/2;
         if(p_par1[1][1] > p_par1[1][0]) rev = 1;
         else		                 rev = 0;

#        ifdef DEBUG
         printf("p_par1[1][1]: %lf, p_par1[1][0]: %lf\n",p_par1[1][1],p_par1[1][0]);
         printf("curve 0 d_par: %lf\n",d_par);
#        endif


         BSpartofcv(&rc, curve[0], p_par1[1][1], d_par, p_par1[1][0], p_curve[0]);
         if(rc != BSSUCC) 
          { 
           printf("surf_int, Bad extraction of the part of curve 1\n");
	   if(p_curve[0]!=NULL)
            {
              BSfreecv(&rc, p_curve[0]); 
              p_curve[0]=NULL;
	      if (rc !=BSSUCC && rc!=BSNULL) 
                 {printf("BSfreecv(curve) fail\n");goto wrapup;}
            }
           goto wrapup;
          }
         if(p_par1[1]   != NULL) {free(p_par1[1]); p_par1[1] = NULL;}
	 if(curve[0]!=NULL)
          {
            BSfreecv(&rc, curve[0]);
            curve[0]=NULL;
	    if (rc !=BSSUCC && rc!=BSNULL) 
             {printf("BSfreecv(curve) fail\n");goto wrapup;}
          }
         if(rev)   
	  {
	    BSrev_cv(&rc, p_curve[0]);
            if(rc != BSSUCC) 
             {
               printf("surf_int, ERROR cannot reverse the curve\n");
       	       if(p_curve[0]!=NULL)
                {
                  BSfreecv(&rc, p_curve[0]);
                  p_curve[0] = NULL;
       		  if (rc !=BSSUCC && rc!=BSNULL) 
			{printf("BSfreecv(curve) fail\n");goto wrapup;}
                }
       	       goto wrapup;
             }
	  }

         if(p_curve[0]->rational)
          {
            for(k=0;k<p_curve[0]->num_poles;k=k+1)
	     {
		p_curve[0]->poles[3*k]   = p_curve[0]->poles[3*k]/
						p_curve[0]->weights[k];
		p_curve[0]->poles[3*k+1] = p_curve[0]->poles[3*k+1]/
						p_curve[0]->weights[k];
		p_curve[0]->poles[3*k+2] = p_curve[0]->poles[3*k+2]/
						p_curve[0]->weights[k];
	     }
	    p_curve[0]->rational = 0;
	    if(p_curve[0]->weights)
	      {
		free(p_curve[0]->weights);
		p_curve[0]->weights  = NULL;
	      }
          }

#        ifdef DEBUG
         printf("\n\n");
         printf("num_poles: %d\n",p_curve[0]->num_poles);
         for(k=0;k<p_curve[0]->num_poles ;k=k+1)
         printf("poles of the part curve 0: %lf, %lf, %lf\n",p_curve[0]->poles[3*k],  
         p_curve[0]->poles[3*k+1],p_curve[0]->poles[3*k+2]);
#        endif

         p_curve[1] = NULL;
         order = curve[1]->order;
         BSalloccv(order, curve[1]->num_poles + 2 * order - 1,
		   curve[1]->rational, curve[1]->num_boundaries, 
		   &p_curve[1], &rc);
         if(rc != BSSUCC && rc!=BSNULL) 
          { 
            printf("surf_int, Bad allocation for the curves\n");
            for(k=0; k<=i+1; k=k+1)
             {
   	      if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
              if(p_par1[k] != NULL) {free(p_par1[k]); p_par1[k] = NULL;}
              if(p_par2[k] != NULL) {free(p_par2[k]); p_par2[k] = NULL;}
             }
            for(k=0; k<num_ent-1; k=k+1)
             {
	      if(curve[k] != NULL) 
                {
                   BSfreecv(&rc, curve[k]); 
                   curve[k]=NULL;
	           if (rc !=BSSUCC && rc!=BSNULL) 
			{printf("BSfreecv(curve) fail\n");goto wrapup;}
		}
             }
            goto wrapup;
          }
         d_par=(p_par2[1][0]+p_par2[1][1])/2;
         if( p_par2[1][0]> p_par2[1][1]) rev = 1;
         else		                rev = 0;

#        if DEBUG
         printf("p_par2[1][0]: %lf, p_par2[1][1]: %lf\n",p_par2[1][0],p_par2[1][1]);
         printf("curve 1 d_par: %lf\n",d_par);
#        endif
     
         BSpartofcv(&rc, curve[1],p_par2[1][0], d_par,p_par2[1][1], p_curve[1]);
         if(rc != BSSUCC) 
          { 
           printf("surf_int, Bad extraction of the part of curve 0\n");
	   if(p_curve[1]!=NULL) 
             {
               BSfreecv(&rc, p_curve[1]);
	       p_curve[1]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail\n");goto wrapup;}
             }
           goto wrapup;
          }
         if(p_par2[1]   != NULL) {free(p_par2[1]); p_par2[1] = NULL;}
	 if(curve[1]!=NULL) 
          {
            BSfreecv(&rc, curve[1]);
            curve[1]=NULL;
	    if (rc !=BSSUCC && rc!=BSNULL) 
               {printf("BSfreecv(curve) fail\n");goto wrapup;}
          }
         if(rev)     
	  {
	    BSrev_cv(&rc, p_curve[1]);
            if(rc != BSSUCC) 
              { 
       		printf("surf_int, ERROR cannot reverse the curve\n");
       		if(p_curve[1]!=NULL) 
                  {
                    BSfreecv(&rc, p_curve[1]);
                    p_curve[1] = NULL;
       		    if (rc !=BSSUCC && rc!=BSNULL) 
                       {printf("BSfreecv(curve) fail\n");goto wrapup;}
		   }
       		goto wrapup;
              }
	  }
#        ifdef DEBUG
         for(k=0;k<p_curve[1]->num_poles ;k=k+1)
         printf("poles of the part_curve 1: %lf, %lf, %lf\n", p_curve[1]->poles[3*k], p_curve[1]->poles[3*k+1],p_curve[1]->poles[3*k+2]);
#        endif
         if(p_curve[1]->rational)
          {
            for(k=0;k<p_curve[1]->num_poles;k=k+1)
	     {
		p_curve[1]->poles[3*k]   = p_curve[1]->poles[3*k]/
						p_curve[1]->weights[k];
		p_curve[1]->poles[3*k+1] = p_curve[1]->poles[3*k+1]/
						p_curve[1]->weights[k];
		p_curve[1]->poles[3*k+2] = p_curve[1]->poles[3*k+2]/
						p_curve[1]->weights[k];
	     }
	    p_curve[1]->rational = 0;
	    if(p_curve[1]->weights)
	      {
		free(p_curve[1]->weights);
		p_curve[1]->weights  = NULL;
	      }
          }

         if(p_par1[0] != NULL) {free(p_par1[0]); p_par1[0] = NULL;}
         if(p_par2[0] != NULL) {free(p_par2[0]); p_par2[0] = NULL;}
   	 if(int_pts[0]!= NULL) {free(int_pts[0]); int_pts[0] = NULL;}
   	 if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	 if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	 if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
         break;
        }
     }
   if(over0   != NULL) {free(over0)  ; over0   = NULL;}
   if(over1   != NULL) {free(over1)  ; over1   = NULL;}
   if(end_pts != NULL) {free(end_pts); end_pts = NULL;}

   } /* End of   for(i=-1;i<num_ent-2;i=i+1) */
         

  /* ---------------------------------------------------------------  

     extract the good parts of  bspline curves: part between the two 
     intersection points of the curve with its adjacent curves

    ---------------------------------------------------------------- */ 

if (!two_intersect && num_merge > 1)
  {
   for(i=0;i<num_ent-1;i=i+1)
    {
      p_curve[i] = NULL;
#     ifdef DEBUG3
      printf("EXTRACT THE GOOD PARTS ...........\n");
#     endif

      if (close_cv)  break;
      if(num_ent == 2 ) {/*printf("one line on support\n");*/break;}
      if(open_cv && num_ent == 2) {printf("1 open_cv \n");break;}
      if( curve[i] == NULL)
       {
         p_curve[i] = NULL;

#        ifdef DEBUG3
         printf("curve[%d] est null, continue\n",i);
#        endif
         continue;
       }	

#     ifdef DEBUG3
      printf("Extract part of curve # %d\n",i);
#     endif


      /* -------------------------------------------------------------------- 

         Compute of the direction parameter (for now simple case of none 
         close curve) 
         par = 0 pour open_cv 

         -------------------------------------------------------------------- */

      if(i== num_ent-2)
         { 
            /* pt1 = pt(u=1 sur curve[num_ent-2]) */

            pt1[0] = save_pts[6*(num_ent-2)+3];
            pt1[1] = save_pts[6*(num_ent-2)+4];
            pt1[2] = save_pts[6*(num_ent-2)+5];

            /* pt0 = pt(u=0 sur curve[num_ent-2]);*/

            pt0[0] = save_pts[6*(num_ent-2)];
            pt0[1] = save_pts[6*(num_ent-2)+1];
            pt0[2] = save_pts[6*(num_ent-2)+2];
            if(curve[0] != NULL) 
        	{par = p_par1[0][0];
		 intpts2[0]=int_pts[0][0];
		 intpts2[1]=int_pts[0][1];
		 intpts2[2]=int_pts[0][2];
		}
            else 
             {
               dist1 = VDSdist2(&point_on[0], &pt1[0]);
	       dist2 = VDSdist2(&point_on[0], &pt0[0]);
               if(dist1 > dist2)
                    par = 0;
               else par = 1;
             }
            if(curve[num_ent-3] != NULL) 
		{parr1 = p_par2[i][0];
		 intpts1[0]=int_pts[i][0];
		 intpts1[1]=int_pts[i][1];
		 intpts1[2]=int_pts[i][2];
		}
            else 
             {
               dist1 = VDSdist2(&point_on[3*(i-1)], &pt1[0]);
	       dist2 = VDSdist2(&point_on[3*(i-1)], &pt0[0]);
               if(dist1 > dist2)
                    parr1 = 0;
               else parr1 = 1;
             }        
         }
      else   
         {
           /* pt1 = pt(u=1 sur curve[i]) */

           pt1[0] = save_pts[6*i+3];
           pt1[1] = save_pts[6*i+4];
           pt1[2] = save_pts[6*i+5];

           /* pt0 = pt(u=0 sur curve[i]);*/

           pt0[0] = save_pts[6*i];
           pt0[1] = save_pts[6*i+1];
           pt0[2] = save_pts[6*i+2];

           if(curve[i+1] != NULL)  
		{par = p_par1[i+1][0];
		 intpts2[0]=int_pts[i+1][0];
		 intpts2[1]=int_pts[i+1][1];
		 intpts2[2]=int_pts[i+1][2];
		}
           else 
             {
               dist1 = VDSdist2(&point_on[3*(i+1)], &pt1[0]);
	       dist2 = VDSdist2(&point_on[3*(i+1)], &pt0[0]);
               if(dist1 > dist2)
                    par = 0;
               else par = 1;
             }
           if(i== 0)
             {
               if(curve[num_ent -2] != NULL) 
		{parr1 = p_par2[i][0];
		 intpts1[0]=int_pts[i][0];
		 intpts1[1]=int_pts[i][1];
		 intpts1[2]=int_pts[i][2];
		}
               else 
                {
                  dist1 = VDSdist2(&point_on[3*(num_ent -2)], &pt1[0]);
	          dist2 = VDSdist2(&point_on[3*(num_ent -2)], &pt0[0]);
                  if(dist1 > dist2)
                    parr1 = 0;
                  else parr1 = 1;
                } 
             }       
            else
             {
              if(curve[i-1] != NULL) 
		{parr1 = p_par2[i][0];
		 intpts1[0]=int_pts[i][0];
		 intpts1[1]=int_pts[i][1];
		 intpts1[2]=int_pts[i][2];
		}
              else 
               {
                  dist1 = VDSdist2(&point_on[3*(i-1)], &pt1[0]);
	          dist2 = VDSdist2(&point_on[3*(i-1)], &pt0[0]);
                 if(dist1 > dist2)
                    parr1 = 0;
                 else parr1 = 1;
               } 
             }
         }
      if(p_par2[i][0] > par) 	rev = 1;
      else		   	rev = 0;

      d_par = (p_par2[i][0] + par)/2.;
      order = curve[i]->order;
      BSalloccv(order, curve[i]->num_poles + 2 * order - 1, curve[i]->rational,
                curve[i]->num_boundaries, 
                &p_curve[i], &rc);
      if(rc != BSSUCC && rc!=BSNULL) 
       { 
        printf("surf_int, Bad allocation for the curves\n");
        for(k=0; k<num_ent-1; k=k+1)
         {
	  if(curve[k]!=NULL)
            {
               BSfreecv(&rc, curve[k]); 
               curve[k] = NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                   {printf("BSfreecv(curve) fail\n");goto wrapup;}
            }
   	  if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
          if(p_par1[k]!= NULL) {free(p_par1[k]); p_par1[k]!= NULL;}
          if(p_par2[k]!= NULL) {free(p_par2[k]); p_par2[k]!= NULL;}
         }
        goto wrapup;
       }

#     ifdef DEBUG
      printf("parms: %lf, %lf, %lf\n",parr1, d_par, par);
#     endif

      BSpartofcv(&rc, curve[i], parr1, d_par, par, p_curve[i]);
      if(rc != BSSUCC) 
       { 
        printf("surf_int, Bad extraction of the part of curve # %d\n", i);
        if(p_curve[i]!=NULL) 
         {
          BSfreecv(&rc, p_curve[i]); 
          p_curve[i]= NULL;
          if (rc !=BSSUCC && rc!=BSNULL) 
             {printf("BSfreecv(curve) fail\n");goto wrapup;}
         }
        goto wrapup;
       }
      /* don't free p_par1[0] because needed for partofcv (num_ent-2) */
      if(i!= 0 && p_par1[i]   != NULL) {free(p_par1[i]); p_par1[i]= NULL;}
      if(i!= 0 && int_pts[i]  != NULL) {free(int_pts[i]); int_pts[i] = NULL;}
      if(p_par2[i]   != NULL) {free(p_par2[i]); p_par2[i]= NULL;}
      if(i>1)
       {
        /* previous curve to keep curve[i-1] at the next step */
        if(curve[i-1]!=NULL  ) 
         {
           BSfreecv(&rc, curve[i-1]); 
           curve[i-1]= NULL;
           if (rc !=BSSUCC && rc!=BSNULL) 
            {printf("BSfreecv(curve) fail\n");goto wrapup;}
         }
       }
      /* reverse the curve if not in the good sens */

      if(rev)
       {
        BSrev_cv(&rc, p_curve[i]);
        if(rc != BSSUCC) 
         { 
          printf("surf_int, ERROR cannot reverse the curve\n");
          if(p_curve[i]!=NULL)
           {
             BSfreecv(&rc, p_curve[i]); 
             p_curve[i] = NULL;
             if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");goto wrapup;}
           }
          goto wrapup;
         }
       }
   
#     ifdef DEBUG
      printf("\n");
      for(k=0;k<p_curve[i]->num_poles && k<10;k=k+1)
      printf("poles of the curves: %lf, %lf, %lf\n", p_curve[i]->poles[3*k], p_curve[i]->poles[3*k+1], p_curve[i]->poles[3*k+2]);
#     endif
      if(p_curve[i]->rational)
          {
            for(k=0;k<p_curve[i]->num_poles;k=k+1)
	     {
		p_curve[i]->poles[3*k]   = p_curve[i]->poles[3*k]/
						p_curve[i]->weights[k];
		p_curve[i]->poles[3*k+1] = p_curve[i]->poles[3*k+1]/
						p_curve[i]->weights[k];
		p_curve[i]->poles[3*k+2] = p_curve[i]->poles[3*k+2]/
						p_curve[i]->weights[k];
	     }
	    p_curve[i]->rational = 0;
	    if(p_curve[i]->weights)
	      {
		free(p_curve[i]->weights);
		p_curve[i]->weights  = NULL;
	      }
          }

    }/* end boucle i */
   if(p_par1[0]   != NULL) {free(p_par1[0]); p_par1[0]= NULL;}

   for(k=0; k<num_ent-1; k=k+1)
    {
     if(curve[k]!=NULL)
      {
        BSfreecv(&rc, curve[k]); 
        curve[k] = NULL;
        if (rc !=BSSUCC && rc!=BSNULL) 
                   {printf("BSfreecv(curve) fail\n");goto wrapup;}
      }
     if(p_par1[k]!= NULL) {free(p_par1[k]); p_par1[k]!= NULL;}
     if(p_par2[k]!= NULL) {free(p_par2[k]); p_par2[k]!= NULL;}
     if(int_pts[k] != NULL) {free(int_pts[k]); int_pts[k] = NULL;}
    }
}/* end extract part of curve */

 
if (num_merge > 1 && !(close_cv || num_ent == 2))
 {
#  ifdef DEBUG3
   printf(" order gpe of pts to fill bdry .................\n");
#  endif

   in_pts    = NULL;
   out_pts   = NULL;
   in_nbpts  = NULL;
   out_nbpts = NULL;
   snb_int   = 0;

   in_nbpts  = (int *)malloc(num_merge*sizeof(int));
   in_pts    = (double **)malloc( num_merge*sizeof(double *));
   k=0;
   for(i=0;i<num_ent -1;i=i+1)
    {
#     ifdef DEBUG 
      printf("index: %d\n",i);
#     endif

      if(p_curve[i] != NULL) 
        {
#   	  ifdef DEBUG3 
          printf("fill nb and pts \n");
#   	  endif

          in_nbpts[k] = p_curve[i]->num_poles;
          in_pts[k]   = NULL;
 	  in_pts[k]   = (double *)malloc( 3*p_curve[i]->num_poles*sizeof(double ));
          for(j=0;j<3*p_curve[i]->num_poles;j=j+1)
            in_pts[k][j]   = p_curve[i]->poles[j];
          if(p_curve[i]!=NULL)
           {
             BSfreecv(&rc, p_curve[i]); 
             p_curve[i] = NULL;
             if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");goto wrapup;}
           }
          k=k+1;
        }
    }
  
   stat = VDSorder_pt(num_merge, in_nbpts,in_pts, NULL, NULL, &snb_int, 
		      &out_nbpts, &out_pts, NULL, NULL);
   if(!(stat & 1)){printf("ERRROR VDSorder_pts\n"); goto wrapup;}

   VDSfree(num_merge,&in_pts);
   if(in_nbpts != NULL){free(in_nbpts);in_nbpts = NULL;}

#  ifdef DEBUG
   printf("snb_int: %d\n",snb_int);
   for(i=0;i<snb_int;i=i+1)
      {
        printf("out_nbpts[%d]: %d\n",i,out_nbpts[i]);
        for(k=0;k<out_nbpts[i]&& k<10;k=k+1)
          printf("out_pts: %lf, %lf, %lf\n",out_pts[i][3*k],
	                  out_pts[i][3*k+1],out_pts[i][3*k+2]);
 
      }
#  endif

   if(snb_int != 1)
    {
      printf("curve not contiguous, can't create bdry\n");
      goto wrapup;
    }
 }/* end order pts of bdry for surface */

/* ------------------------------------------------------------------------
   We create a merge curve if the support is a plane and a boundary that
   we (try to ) close with the border of the surface if the support is 
   a surface

   ----------------------------------------------------------------------- */
 
     /* GATHER ALL THE BSPLINES INTO ONE BOUNDARY */

#    ifdef DEBUG3 
     printf("surface Create a boundary ..............\n");
#    endif 

     total_num_poles = 0;
     if (close_cv|| (open_cv && num_ent == 2)|| (num_ent == 2)) 
             			total_num_poles = curve[0]->num_poles;
     else if(num_merge == 1 && i_onecv != -1)  	
				total_num_poles = curve[i_onecv]->num_poles;
     else     			total_num_poles = out_nbpts[0];

#    ifdef DEBUG3
     printf("total_num_poles: %d\n",total_num_poles);
#    endif

	/* --------------
           we allocate the space for the boundary of num_alloc 
           (6 for additionnal points if boundry need to be closed) 
	   ---------- */

     num_alloc = 0;
     bdry.num_points = total_num_poles ;
     num_alloc = bdry.num_points + 6;

#    ifdef DEBUG
     printf("num of points: %d\n", bdry.num_points);
#    endif

     bdry.points = NULL;
     bdry.points = (IGRdouble *) malloc(num_alloc * 2 * sizeof(double));
     if(bdry.points == NULL) 
         {
          printf("surf_int, Bad memory allocation\n");
          goto wrapup;
         }

     l = 0;
     if (close_cv || (open_cv && num_ent == 2) || (num_ent == 2))
      {
        for(k=0;k<curve[0]->num_poles;k=k+1)
         {
           bdry.points[l]   = curve[0]->poles[3*k]; 
           bdry.points[l+1] = curve[0]->poles[3*k+1]; 
           l = l + 2;
         }
        if(curve[0]!=NULL) 
         {
           BSfreecv(&rc, curve[0]); 
           curve[0] = NULL;
           if (rc !=BSSUCC && rc!=BSNULL) 
                  {printf("BSfreecv(curve) fail\n");goto wrapup;}
         }
      }
     else if(num_merge == 1 && i_onecv != -1)
      {
         for(k=0;k<curve[i_onecv]->num_poles;k=k+1)
           {
            	bdry.points[l]   = curve[i_onecv]->poles[3*k]; 
            	bdry.points[l+1] = curve[i_onecv]->poles[3*k+1]; 
            	l = l + 2;
           }
         if(curve[i_onecv]!=NULL) 
           {
              BSfreecv(&rc, curve[i_onecv]); 
              curve[i_onecv] = NULL;
              if (rc !=BSSUCC && rc!=BSNULL) 
                  {printf("BSfreecv(curve) fail\n");goto wrapup;}
           }
      }
     else
      {
  	  for(i=0;i<out_nbpts[0];i=i+1) 
           {
             bdry.points[l]   = out_pts[0][3*i];
             bdry.points[l+1] = out_pts[0][3*i+1];
     	     l = l + 2;
           }
          l = l - 2;
      }	

#    ifdef DEBUG 
     for(i=0; i<bdry.num_points ; i=i+1) printf("point (u,v): %lf, %lf\n", bdry.points[2*i],bdry.points[2*i+1]);
#    endif
 
     VDclose_bnd(&msg, &bdry );
     if (!(msg & 1)) {printf("error in VDclose_bnd: %d\n",msg); goto wrapup;}
#    ifdef DEBUG3 
     for(i=0; i<bdry.num_points &&i<10 ; i=i+1) printf("point (u,v): %lf, %lf\n", bdry.points[2*i],bdry.points[2*i+1]);
#    endif



  /* CREATE THE GRAPHIC OBJECT */

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.class_attr	= NULL;
  cst.name		= NULL;
  	
  GRid_list.osnum = MOD_ENV.md_id.osnum;
  GRid_list.objid = NULL_OBJID;
  




      bsp_surf1[0]->num_boundaries = 1 ;
      bsp_surf1[0]->bdrys          = &bdry;
      bsp_surf1[0]->on_off	   = /*FALSE*/ TRUE;
      cst.geometry		   = (char *) bsp_surf1[0];


    stat = ci$send(msg = message EMSgenbs.GRconstruct( &cst),
		    verbose = VERBOSE,
                    construct = 1,
        	    targetid  = GRid_list.objid,
 	            targetos  = GRid_list.osnum );
# ifdef DEBUG3
  printf("GRconstruct stat = %d, GRid_list = %d, %d\n",stat, GRid_list.objid,
                                              GRid_list.osnum);
  EFmsgReport(0,*(cst.msg),"return msg GRconstruct");
# endif

   if(*(cst.msg) == EMS_I_NoMoreLoops)
   {
    EFmsgReport(0,*(cst.msg),"return msg GRconstruct");
    printf("fail to construct boundary on surface, must delete the created surface\n");
    stat = ci$send(msg = message Root.delete( 0),
        	    targetid  = GRid_list.objid,
 	            targetos  = GRid_list.osnum );

    if (!(stat&1)) printf("fail to delete surface created\n");
    GRid_list.objid = NULL_OBJID;
    goto wrapup;
   }
 if (!(stat&1)) 
   {
    printf("EMSsubbs.GRconstruct failed\n");
    om$report_error(sts=stat);
    GRid_list.objid = NULL_OBJID;
    goto wrapup;
   }
   if(merges != NULL)
     {
      for(k=0;k<nb_merge;k=k+1) 
         {
           
           if(merges[k] != NULL)
              {
                 BSfreecv(&rc, merges[k]); 
	         if (rc !=BSSUCC && rc!=BSNULL) 
                    {printf("BSfreecv(curve) fail rc: %d\n",rc);goto wrapup;}
                 merges[k] = NULL;
              }
         }

      if(merges != NULL){free(merges);merges = NULL;}
     }
   VDSfree(num_merge,&in_pts);
   VDSfree(snb_int,&out_pts);
   VDSfree(nb_sf1,&bsp_surf1); 
   VDSfree(nb_sf2,&bsp_surf2); 
   if(bsp_curve != NULL) {free(bsp_curve); bsp_curve = NULL;}
   if(in_nbpts != NULL){free(in_nbpts);in_nbpts = NULL;}
   if(out_nbpts != NULL){free(out_nbpts);out_nbpts = NULL;}
   for(k=0;k<num_ent-1;k=k+1)
    {
	  if(curve[k]   != NULL) {BSfreecv(&rc, curve[k]);   curve[k]  = NULL;}
          if(p_curve[k] != NULL) {BSfreecv(&rc, p_curve[k]); p_curve[k]= NULL;}
    	  if(p_par2[k]  != NULL) {free(p_par2[k]);           p_par2[k] = NULL;}
   	  if(int_pts[k] != NULL) {free(int_pts[k]); int_pts[k] = NULL;}
    	  if(p_par1[k]  != NULL) {free(p_par1[k]);           p_par1[k] = NULL;}
    }
   if(pr_curve != NULL){free(pr_curve);pr_curve = NULL;}
   if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}
   if(over0       != NULL) {free(over0)      ; over0=NULL;}
   if(over1       != NULL) {free(over1)      ; over1=NULL;}
   if(end_pts     != NULL) {free(end_pts)    ; end_pts=NULL;}
   if(bdry.points != NULL) {free(bdry.points);bdry.points = NULL;}
    VDSfree(numgrps,&pts);
    VDSfree(numgrps,&par1);
    VDSfree(numgrps,&par2);
 return(1);

wrapup:
   if(merges != NULL)
     {
      for(k=0;k<nb_merge;k=k+1) 
            {BSfreecv(&rc, merges[k]); merges[k] = NULL;}
      if(merges != NULL){free(merges);merges = NULL;}
     }
   VDSfree(num_merge,&in_pts);
   VDSfree(snb_int,&out_pts);
   VDSfree(nb_sf1,&bsp_surf1); 
   VDSfree(nb_sf2,&bsp_surf2); 
   if(bsp_curve != NULL) {free(bsp_curve); bsp_curve = NULL;}
   if(in_nbpts != NULL){free(in_nbpts);in_nbpts = NULL;}
   if(out_nbpts != NULL){free(out_nbpts);out_nbpts = NULL;}
   for(k=0;k<num_ent-1;k=k+1)
    {
	  if(curve[k]!=NULL){BSfreecv(&rc, curve[k]); curve[k] = NULL;}
          if(p_curve[k]!=NULL) {BSfreecv(&rc, p_curve[k]); p_curve[k]= NULL;}
   	  if(int_pts[k] != NULL) {free(int_pts[k]); int_pts[k] = NULL;}
    	  if(p_par2[k]   != NULL) {free(p_par2[k]); p_par2[k]= NULL;}
    	  if(p_par1[k]   != NULL) {free(p_par1[k]); p_par1[k]= NULL;}
    }
   if(pr_curve != NULL){free(pr_curve);pr_curve = NULL;}
   if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}
   if(over0       != NULL) {free(over0)      ; over0=NULL;}
   if(over1       != NULL) {free(over1)      ; over1=NULL;}
   if(end_pts     != NULL) {free(end_pts)    ; end_pts=NULL;}
   if(bdry.points != NULL) {free(bdry.points);bdry.points = NULL;}
    VDSfree(numgrps,&pts);
    VDSfree(numgrps,&par1);
    VDSfree(numgrps,&par2);

  return(0);

}


