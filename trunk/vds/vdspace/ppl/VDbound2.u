/* $Id: VDbound2.u,v 1.1.1.1 2001/01/04 21:09:23 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vdspace/ppl / VDbound2.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: VDbound2.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:09:23  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*

	05-05-92 :	modif des mod_env :act_env.md_id.objid = NULL_OBJID
			for intermediate objects (no RTREE).		
*/


#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bstypes.h"
#include "bserr.h"
#include "bsconic.h"
#include "emsedgedef.h"
#include "emserr.h"
#include "exmacros.h"
#include "EMSmsgdef.h"
#include "EMS.h"
#include "EMScmacros.h"
#include "EMSopt.h"
#include "EMSbnddef.h"
#include "EMSbnd.h"
#include "emsmapdef.h"
#include "emsimpdef.h"
#include "macro.h"
#include "nddef.h"
#include "VDSutil_def.h"
#include "acmacros.h"
#include "DIdef.h"
#include "COmdef.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"
#include "EMSssprops.h"

#include "DItypedef.h"
#include "DIdef.h"

#include "AS_status.h"


#define   VERBOSE 	1
#define   EPSILON	1.0E-10
#define   MAX_TEMP	10 	/* number of templates */
#define	  MAX_CHA_TEMP	7
#define	  MAX_CHA_ROOT	4

#define	  MAXINT	20
#define	  ORDER		2
#define ACkeep_template 1024

/*
#define   DEBUG 	1
#define   DBG_TEMP 	1  
#define   DBG_PROJ 	1 
#define   DBG_INTSF 	1 
#define   DBG_INTCV 	1 
#define   DBG_PARTOF 	1 
#define   DBG_BND 	1 
#define   DBG_PARTSF 	1 
#define   DBG_CENTER 	1 

*/

/* Different kind of intersections, the first word is for the support */

struct GRmd_env         act_env,MOD_ENV, OBJ_ENV[MAX_TEMP];

struct GRid		CI_MACRO_ID,mac,def_temp,SPROJ, SUR[MAX_TEMP] , 
			comp_id,GRid_list, GRid_cv[MAX_TEMP];
			
GRobj 			ci_mac_def1;

struct GRlc_info        entries[MAX_TEMP], final_curve;

struct IGRbsp_surface   **bsp_surf1,**bsp_surf2,*par_surf;

struct IGRbsp_curve	*bsp_curve,*curve[MAX_TEMP], *p_curve[MAX_TEMP], 
			**array, *bnd_curve, *line,  *part_line, *comp_cv, 
			**tmp_curve;

struct IGRplane		plane[2], bndpl;

struct ret_struct	temp1_rts;

struct GRvg_construct   cst;

struct IGRdisplay	dis;

IGRboolean 	        test_degeneracy, construct_loopset, world, in_range,
			orient_known, pos_orient, wind_loopset, msg_status,
			tst_plan,onsurf,bstat, err_flag, all_on_surf;

IGRdouble		point_on[3*(MAX_TEMP)],range[6], v1[3], point[3],
			matrix[16], du[3], dv[3], dirvect[3],obj_range[6],
			q_pl[3], u_pl[3], u[2], q[2],us[2], qs[2], coef, fact,
			basis_tol,plane_space[12],v2[3],*points, 
			**par1,**par2, *over0 , *over1 ,pt0[3], pt1[3], pt2[3],
			pt3[3], *p_par1[MAX_TEMP], *p_par2[MAX_TEMP],
			save_pts[6*(MAX_TEMP)],d_par, par, parr1,parr2[2],
			*int_pts[MAX_TEMP],  intpts1[3], intpts2[3],*end_pts,
			**pts, *eval_pts,cht_tol, file_cht, accuracy_factor,
			*param, **Xpts, **Xpar1, **Xpar2, dist1,dist2, value,
			*int_pts0,*int_pts1,*p_par10,*p_par11,*p_par20,*p_par21,
			upar,vpar,center[3], center_pt[3],area, *length, 
			max_length, dir, start, end, base[3],area_pt[2],
			vect[3], bnd[6], dotp;

IGRlong			n_over, rotten_one, stat, msg, nput, nret,
			number_of_points, number_of_bad_curves, 
			bad_curve_indices[50];

IGRchar			*temp_names[MAX_TEMP], *feet_names[1],
			running[DI_PATH_MAX], infinite, path[80], 
			buff[MAX_TEMP*MAX_CHA_TEMP];

IGRint			temp_types[MAX_TEMP],return_type,type_flag,snb_int,
			i_onecv,nb_merge,*Xnumpts,
			elem_type[MAX_TEMP],nb_retsf,nb_gpe,*nb_cvgp,added,
			nb_create, num_merge,num_alloc, num_ent, *numpts, Xnumgrps, 
                        numgrps, n_int, total_num_poles, size, num_pts, nb_sf1,
			nb_sf2, flag, two_intersect, rev, int_flag, open_cv, 
			close_cv, split_ind, i, j, k, l, index_open[2], nb_time,
			n_int0,n_int1, found, nb_poles, p_index,index_NULL,
			tab_cv[MAX_TEMP],no_intersect,num_temp,num_pair,
			no_last_intersect,cv0pt0, cv0pt1,cv1pt0, cv1pt1,
			nb_sol, max_index, middle, num_normals;

BSrc			rc;

IGRshort		opt, opt1, order, matrix_type, mat_type[MAX_TEMP];

GRclassid		obj_classid;

unsigned IGRshort 	map_options, imp_options;

unsigned IGRchar	curve_type;

extern GRclassid	OPP_EMSplane_class_id, OPP_EMSsurface_class_id, 
			OPP_GRcurve_class_id,OPP_EMScompsurf_class_id,
			OPP_EMSsfimpbnd_class_id;

extern			EX_get_modid_given_osnum(),GRdpb_put();

extern int 		init_cnst_list(), ASsuper_construct(),
			GRdpb_get(),
			sprintf(),
			printf(),
			BSmkvec(),
			BSorthovec(),
			free(),
			BSarclen(),
			BSsfnormal(),
			BSfreecv(),
			BScvcv_int(),
			BSprptsonsf(),
			BSprptonsf(),
			BSmdistcvcv(),
			BSpartofcv(),
			BSrev_cv(),
			BSalloccv(),
                	BSconstprcv(),
			BSpjcvtsf(),
	        	BSsfptseval(),
	        	BSsfevaln(),
			BSptperpsf(),
                	BSctrarplcv(),
			BSprj_cv_pl(),
			SMelem_(),
			VDint(),
			VDSfree(),
			VDSdist2(),
			VDSfill_curve(),
			VDSorder_curves(),
			VDadd_cv_to_close(),
			VDSorder_gpe(),
			VDSorder_pt(),
			ACcreate_def_temp();

extern char        	*malloc();
extern double      	fabs(), BSdistptpt(), BSdotp();
extern		   	BSpartofsf();
extern int	   	EFmsgReport();
extern IGRboolean  	BSfreesf();
extern			GRdpb_put(), UI_status(), UI_message();


/* ========================================================================= */
/* the main function is the one implementing the definition creation
/* ========================================================================= */

main ()
{
  struct ret_struct ret_str[MAX_TEMP];

  feet_names[0] = "surf";

  temp_names[0] = "accuracy_factor";  
  temp_types[0] = double_type;

  temp_names[1] = "is_infinite";
  temp_types[1] = text_type;

  temp_names[2] = "support";  
  temp_types[2] = other_generic;

  for (i=3; i<MAX_TEMP; i=i+1)
  {
	strcpy (&buff[i*MAX_CHA_TEMP],"surf");
	sprintf(&buff[i*MAX_CHA_TEMP+MAX_CHA_ROOT],"%d",(i-3));
	temp_names[i] = &buff[i*MAX_CHA_TEMP];
        temp_types[i] = other_generic | curve_generic | line_generic | conic_generic;
  }

  ci_mac_def1 = NULL_OBJID;

  ac$cimacdef( 	cimacdef          	= ci_mac_def1,
		prop 		  	= ACvariable_template|ACkeep_template,
		status 	          	= &stat,
		name              	= "VDbound2",
             	temp_num  		= MAX_TEMP,
 		temp_names 		= temp_names,
                temp_types 		= temp_types,
	      	extern_feet_num 	= 1, 
		extern_feet_names 	= feet_names);

 /* Put the default value */

 ret_str[0].type = double_type;
 ret_str[1].type = text_type;
 ret_str[2].type = other_generic;
 ret_str[3].type = other_generic;
 ret_str[4].type = other_generic;
 ret_str[5].type = other_generic;
 ret_str[6].type = other_generic;
 ret_str[7].type = other_generic;
 ret_str[8].type = other_generic;
 ret_str[9].type = other_generic;
 ret_str[0].var.root_pm_st.value = 1;
 strcpy(ret_str[1].var.text_st.text_string, "y");
 mac.objid = ci_mac_def1;
 mac.osnum = AC_construct_id.osnum;

#if 0
 ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_temp	   = &def_temp,
		     value	   = ret_str);
#endif

 /* Modification for version 2.0 */
  ac$create_def_temp( search_option = USER_SPECIFIED,
		     search_path   = ".", 
		     symbology     = CHG_LAYER | CHG_COLOR | CHG_WEIGHT | CHG_STYLE,
		     macro 	   = &mac,
		     def_col       = &def_temp,
		     temp_val	   = ret_str);

  
}


/* ========================================================================= */

place ()
{
IGRlong		msg, sts;
struct	GRid	my_as_sup;

  surf_intersect();
  if( GRid_list.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }

  return(1);
}


/* ========================================================================= */

compute ()
{
  surf_intersect();

  if( GRid_list.objid == NULL_OBJID ) return(0);

  ci$send( msg = message  ci_macro.set_all_extern_feet
		(&stat, 1, &GRid_list, &MOD_ENV ),
	   targetid = CI_MACRO_ID.objid,
	   targetos = CI_MACRO_ID.osnum );
 if (stat!=OM_S_SUCCESS) 
  {
   printf("failure in set_all_extern feet\n");
   return(0);
  }
  return(1);
}

/* ========================================================================= */

surf_intersect()

{
 IGRchar	props, bndprops;

 /* init of pointers */

# ifdef DEBUG
  printf("surf_intersect begin\n"); 
# endif
  over0       	= NULL;
  over1        	= NULL;
  end_pts      	= NULL;
  numpts       	= NULL;
  pts          	= NULL;
  eval_pts      = NULL;
  param      	= NULL;
  par1         	= NULL;
  par2         	= NULL;
  bsp_surf1    	= NULL;
  bsp_surf2    	= NULL;
  bsp_curve    	= NULL;
  comp_cv      	= NULL;
  par_surf     	= NULL;
  nb_cvgp      	= NULL;
  array        	= NULL;
  bnd_curve    	= NULL;
  line	       	= NULL;
  part_line	= NULL;
  tmp_curve    	= NULL;
  length       	= NULL;
  Xnumpts	= NULL;
  Xpts		= NULL;
  Xpar1		= NULL;
  Xpar2		= NULL;
  int_pts0	= NULL;
  int_pts1	= NULL;
  p_par11	= NULL;
  p_par10	= NULL;
  p_par20	= NULL;
  p_par21	= NULL;
  points	= NULL;
  snb_int      	= 0;
  nb_gpe       	= 0;
  nb_create    	= 0;
  added        	= 0;
  max_index    	= 0;
  close_cv 	= 0;
  open_cv  	= 0;
  err_flag 	= FALSE;
  index_open[0] = -1;
  index_open[1] = -1;

  			  
  plane[0].point  = &plane_space[0];
  plane[0].normal = &plane_space[3];
  plane[1].point  = &plane_space[6];
  plane[1].normal = &plane_space[9];

  
  for(i=0;i<MAX_TEMP;i=i+1){
  	curve[i] 		= NULL;
  	p_curve[i] 		= NULL;
  	p_par1[i]  		= NULL;
  	p_par2[i]  		= NULL;
  	int_pts[i]  		= NULL;
	SUR[i].objid 		= NULL_OBJID;
	GRid_cv[i].objid 	= NULL_OBJID;
  }
  comp_id.objid = NULL_OBJID;
  GRid_list.objid = NULL_OBJID;

  nput = sizeof(struct GRmd_env);

  gr$get_module_env(	msg    = &msg, 
                        sizbuf = &nput, 
                        buffer = &act_env, 
                        nret   = &nret);
  if(!(msg&1)){ 
    	printf("error gr$get_module_env\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }
  act_env.md_id.objid = NULL_OBJID; /* construct intermediate obj (no RTREE) */

  stat = ci$send(msg = message NDnode.NDget_objects(ND_ROOT,NULL,0,NULL,
					     0,OM_K_MAXINT,&num_temp),
	   	  targetid = CI_MACRO_ID.objid,
	   	  targetos = CI_MACRO_ID.osnum);

  if(stat == OM_E_ABORT)  return(0);

  num_ent = num_temp -1;

# ifdef DBG_TEMP
  printf("intersect surf, num_ent: %d\n", num_ent);
# endif

  if (num_ent ==0) {err_flag = TRUE;goto wrapup;}
  nput = sizeof(basis_tol);

  gr$get_basis_tolerance(msg    = &msg, 
                         sizbuf = &nput, 
                         buffer = &basis_tol, 
                         nret   = &nret);
  if(!(msg&1)){ 
    	printf("error gr$get_basis_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }
  nput = sizeof(file_cht);

  gr$get_chord_height_tolerance(msg    = &msg, 
                         	sizbuf = &nput, 
                         	buffer = &file_cht, 
                         	nret   = &nret);

  if(!(msg&1)){ 
    	printf("error gr$get_chord_height_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }
# ifdef DBG_TEMP
  printf("basis_tolerance: %lf\n",basis_tol);
  printf("cht tol : %lf\n",file_cht);
# endif


  stat = ci$send(msg = message ACcpx.ACfind_temp_struct(&msg,
                                                  "accuracy_factor",
                                                  (char *)&temp1_rts,
                                                  &MOD_ENV),
                       verbose = VERBOSE,
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );
  as$status(sts = stat);
  accuracy_factor =  temp1_rts.var.root_pm_st.value;

  if(accuracy_factor <= 0 || accuracy_factor > 1) {
	UI_status("ERROR accuracy_factor must be include in  ]0, 1]");
	err_flag = TRUE;
	goto wrapup;
  }


# ifdef DBG_TEMP
  printf("accuracy_factor: %lf\n",accuracy_factor);
  printf("cht tol : %lf\n",file_cht);
# endif
  cht_tol = file_cht / accuracy_factor;

# ifdef DBG_TEMP
  printf("new cht tol : %lf\n",cht_tol);
# endif


  nput = sizeof(cht_tol);

  gr$put_chord_height_tolerance
                        (msg    = &msg,
                         sizbuf = &nput,
                         buffer = &cht_tol);

  if(!(msg&1)){ 
    	printf("error gr$put_chord_height_tolerance\n"); 
    	err_flag = TRUE;
    	goto wrapup;
  }

  /*   Retrieve the template template :is_infinite  */

  stat = ci$send(msg = message ACcpx.ACfind_temp_struct(&msg,
                                                  "is_infinite",
                                                  (char *)&temp1_rts,
                                                  &MOD_ENV),
                       verbose = VERBOSE,
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );
  as$status(sts = stat);

  infinite = temp1_rts.var.text_st.text_string[0];

# ifdef DBG_TEMP
  printf("infinite: %c\n",infinite);
# endif



/* ----------------------------------------------------------------------- 

  Retrieve the templates and calculate the max range of the support
  
  ----------------------------------------------------------------------- */

 for(i=0;i<num_ent-1;i=i+1)
   {
#    ifdef DEBUG
     printf("Retrieve the template for the template \n");
#    endif

     msg = ci$send( msg = message  ACcpx.ACfind_exp_temp_obj(&stat,i+2,&SPROJ),
           	       targetid = CI_MACRO_ID.objid,
           	       targetos = CI_MACRO_ID.osnum );

     if(stat !=1 ) return(0);
/*     if(stat == 3 ) SUR[i] = SPROJ;*/
     else
      {
       /* DOES NOT WORK WITH OBJECTS BELONGING TO DIFFERENTS OS */
        stat = ci$send( msg = message ASnode.ASreturn_go( 
                                          &SUR[i], 
                                          &OBJ_ENV[i].md_env.matrix_type, 
                                          OBJ_ENV[i].md_env.matrix ),
	      	        targetid = SPROJ.objid,
	                targetos = SPROJ.osnum );
        if (!(stat&1))
		{ as$status(sts=stat); err_flag = TRUE;goto wrapup; } 
      }

      OBJ_ENV[i].md_id = MOD_ENV.md_id;

     /* we retrieve informations in two steps because the free pb if object 
     /* has been consumed */

#    ifdef DEBUG
     printf("Retrieve the type of the element: %d, %d\n", SUR[i].objid,  
                                                         SUR[i].osnum);
#    endif

     if(i==0)
      {
        /* Only for the support */

#          ifdef DEBUG
           printf("Retrieve the range of the support\n");
#          endif

           world = TRUE;
           stat = ci$send( msg = message GRgraphics.GRgetrang(&msg, 
           					&OBJ_ENV[i].md_env.matrix_type, 
						OBJ_ENV[i].md_env.matrix, 
						&world, 
						range),
		verbose = VERBOSE,
              targetid = SUR[0].objid,
 	      targetos = SUR[0].osnum );
	   as$status(sts=stat); 
           if (!(msg&stat&1)){ 
        	printf("ERROR in GRgraphics.GRgetrang of %d %d\n",
			SUR[0].objid,SUR[0].osnum); 
		err_flag = TRUE;
		goto wrapup; 
	   } 

#          ifdef DBG_TEMP
           printf("range support: %lf, %lf, %lf, %lf, %lf, %lf\n",range[0],
                   range[1],range[2],range[3],range[4],range[5]);
#          endif
      }
     else 
      {
        /* i<>0 */
        /* Look for the max range : plan will be extended of that range */

        world = TRUE;
        stat = ci$send( msg = message GRgraphics.GRgetrang(&msg, 
        					&OBJ_ENV[i].md_env.matrix_type, 
						OBJ_ENV[i].md_env.matrix, 
						&world, obj_range),
		    verbose  = VERBOSE,
                    targetid = SUR[i].objid,
 	            targetos = SUR[i].osnum );

	as$status(sts=stat); 
        if (!(msg&stat&1)){ 
        	printf("ERROR in GRgraphics.GRgetrang\n" ); 
		err_flag = TRUE;
		goto wrapup; 
	} 
#       ifdef DBG_TEMP
        printf("range support: %lf, %lf, %lf, %lf, %lf, %lf\n",range[0],
                range[1],range[2],range[3],range[4],range[5]);
           
	printf("range %d: %lf, %lf, %lf, %lf, %lf, %lf\n",i,obj_range[0],
                obj_range[1],obj_range[2],obj_range[3],obj_range[4],obj_range[5]);
#       endif

	for(k=0;k<3;k=k+1)
	 {
	  if(range[k]   > obj_range[k]  ) range[k]   = obj_range[k];
	  if(range[k+3] < obj_range[k+3]) range[k+3] = obj_range[k+3];
	 }
      }
   } /* end for(i=0 ....) */


/* ----------------------------------------------------------------------- 

   we have (num_ent-1) objects that will give (num_ent-2) intersection cv
   we make intersection between support and surface i and create the
   intersection curve => curve[i-1] 

   ----------------------------------------------------------------------- */

 for(i=0;i<num_ent-1;i=i+1)
  {

#   ifdef DBG_TEMP
    printf("Retrieve the topologie of: %d, %d\n", SUR[i].objid,  SUR[i].osnum);
#   endif

    if(i==0)
     {
      /*| Only for the support */

      if (infinite != 'y' && infinite != 'Y') type_flag = SURF;
      else 				      type_flag = PLAN;

      bsp_curve = NULL;
      nb_sf1 = 0;
      stat = SMelem_(type_flag, &SUR[0], OBJ_ENV[i].md_env.matrix_type, 
      			OBJ_ENV[i].md_env.matrix, &elem_type[0], 
		     	&plane[0], &bsp_surf1, &bsp_curve, &nb_sf1);
      if (!(stat&1)){ 
      		UI_status("ERROR fonction SMelem_"); 
      		err_flag = TRUE;
      		goto wrapup; 
      	} 
      if(elem_type[0] == CURV){
          	UI_status("ERROR: support cannot be a curve");	
		err_flag = TRUE;
		goto wrapup; 
      } 
      if(nb_sf1>1) {
          	UI_status("ERROR: support composite not implemented");	
		err_flag = TRUE;
		goto wrapup;
      }
      stat = ci$send( msg = message EMSsubbs.EMget_props(&msg, &props),
			verbose = VERBOSE,
              		targetid = SUR[0].objid,
 	      		targetos = SUR[0].osnum );
 	      
      if (!(stat&1)){ props = 0x00; }


#     ifdef DBG_TEMP
      if(bsp_surf1 != NULL )
       {
         
    	for(k=0;k<nb_sf1;k=k+1)
         printf("bsp_sf1 u_num_poles: %d, v_num_poles: %d\n",bsp_surf1[k]->u_num_poles,
		bsp_surf1[k]->v_num_poles);
       }
#     endif

		
      if(elem_type[0] == PLAN)
       {
#       ifdef DBG_TEMP
        printf("plane[0].point: %lf, %lf, %lf\n",plane[0].point[0],plane[0].point[1],
                 plane[0].point[2]);
        printf(" plane[0].normal: %lf, %lf, %lf\n",plane[0].normal[0],plane[0].normal[1],
		plane[0].normal[2]);
#       endif

	/* Compute the diagonal of the range */
        fact = 1.1 * BSdistptpt(&rc, range, &(range[3]));
	if(rc != BSSUCC) {printf("ERROR BSdistptpt,\n");err_flag = TRUE;goto wrapup;}
       }
     }
    else 
     {
      /* i<>0 */
      if (infinite != 'y' && infinite != 'Y') type_flag = SURF;
      else 				      type_flag = PLAN;

#     ifdef DBG_TEMP
      printf("type_flag: %d\n",type_flag);
#     endif
      bsp_curve = NULL;
      bsp_surf2 = NULL;
      nb_sf2 = 0;
      stat = SMelem_(type_flag, &SUR[i], OBJ_ENV[i].md_env.matrix_type, 
      			OBJ_ENV[i].md_env.matrix, &elem_type[i], 
		     	&plane[1], &bsp_surf2, &bsp_curve, &nb_sf2);
      if (!(stat&1)){ 
      		UI_status("ERROR fct SMelem_"); 
      		err_flag = TRUE;
      		goto wrapup; 
      } 

#     ifdef DBG_TEMP
      if(bsp_surf2 != NULL)
       {
    	for(k=0;k<nb_sf2;k=k+1)
         printf("bsp_sf2 u_num_poles: %d, v_num_poles: %d\n",bsp_surf2[k]->u_num_poles,
		bsp_surf2[k]->v_num_poles);
       }
      if(elem_type[i] == PLAN)
       {
         printf("plane[1].point: %lf, %lf, %lf\n",plane[1].point[0],
                plane[1].point[1],plane[1].point[2]);
         printf("plane[1].normal: %lf, %lf, %lf\n",plane[1].normal[0],
	        plane[1].normal[1],plane[1].normal[2]);
       }
      if(elem_type[i] == CURV) 
                printf("curve.num_poles: %d\n",bsp_curve->num_poles);
#     endif
     }/* end else ... */

        /* keep a point on a surface to extract curve in good sens */


        if(elem_type[i] == PLAN)
         {
           point_on[3*i]   = plane[1].point[0];
           point_on[3*i+1] = plane[1].point[1];
           point_on[3*i+2] = plane[1].point[2];
         }
        else if(elem_type[i] == CURV)
         {
           point_on[3*i]   = bsp_curve->poles[0];
           point_on[3*i+1] = bsp_curve->poles[1];
           point_on[3*i+2] = bsp_curve->poles[2];
           if (bsp_curve->phy_closed == TRUE && num_ent-1 !=2)
           {
                UI_status("ERROR: One curve is closed ");
                err_flag = TRUE;
                goto wrapup;
           } 
         }
        else if(elem_type[i] == SURF)
         {
	   if(i==0)
	    {
           	point_on[3*i]   = bsp_surf1[0]->poles[0];
           	point_on[3*i+1] = bsp_surf1[0]->poles[1];
           	point_on[3*i+2] = bsp_surf1[0]->poles[2];
		
            }
	   else
            {
           	point_on[3*i]   = bsp_surf2[0]->poles[0];
           	point_on[3*i+1] = bsp_surf2[0]->poles[1];
           	point_on[3*i+2] = bsp_surf2[0]->poles[2];
	    }
       
         }

    if(i==0) continue;

#   ifdef DBG_INTSF
    printf("\n\nCompute intersection between the support and the surface # %d\n", i);
    printf("elem_type[0]: %d\n",elem_type[0]);
    printf("elem_type[%d]: %d\n",i,elem_type[i]);
#   endif
    if(elem_type[i] == CURV) sprintf(running,"%s%d%s","Project curve ",i," on the support");
    else sprintf(running,"%s%d","intersect the support and the surface",i);
    UI_status(running);		

    numgrps = 0;
    num_pts = 0;
    par1 	 = NULL;
    par2         = NULL;
    numpts       = NULL;
    pts          = NULL;
    if(elem_type[0] == SURF)
     {

         if(elem_type[i] == PLAN)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, PLAN, NULL, &plane[1],1,
                         &numgrps, &numpts, &pts , &par1, NULL);
          }
         else if(elem_type[i] == SURF)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, SURF, bsp_surf2, NULL,1,
                         &numgrps, &numpts, &pts , &par1, &par2);

          }
         else if(elem_type[i] == COMP_SF)
          {
            stat = VDint(SURF, bsp_surf1, NULL, 1, COMP_SF, bsp_surf2, NULL,nb_sf2,
                         &numgrps, &numpts, &pts , &par1, NULL);

          }
         else
          {
#           ifdef DBG_PROJ
            printf("project curve on surface ..............\n");
#           endif
	
		/* ----------
			we take the normal to the surface at a middle pt
			of the curve which have a projection on the surface.
			by default, we take normal at u=.5, v=.5 of surf

		-------- */
	    if(bsp_surf1[0]->planar == TRUE){
		BSsfnormal(bsp_surf1[0], dirvect, &rc);
            	if (rc!= BSSUCC){ 
                  printf("ERROR BSsfnormal when project curve onto surface\n");
                  err_flag = TRUE;
		  goto wrapup;
            	}
	    }
	    else{

	    	BSsfevaln(bsp_surf1[0], .5, .5, 1, &num_normals,base, dirvect, &rc);
            	if (rc!= BSSUCC){ 
                  printf("ERROR BSsfevaln when project curve onto surface\n");
                  err_flag = TRUE;
		  goto wrapup;
            	}

#           	ifdef DBG_PROJ
	    	printf("default normal at u,v .5 = %lf, %lf, %lf\n",dirvect[0], dirvect[1], dirvect[2]);
	    	printf("at the base: %lf, %lf,%lf\n",base[0], base[1], base[2]);
#           	endif
	    	num_pair = 0;
	    	dist1    = 0.;
	    	middle   = (int)(bsp_curve->num_poles/2);
#              	ifdef DBG_PROJ
	       	printf("point on cv to project on surf: %lf, %lf, %lf\n",
				bsp_curve->poles[3*middle],
				bsp_curve->poles[3*middle+1],
				bsp_curve->poles[3*middle+2]);
#              	endif
	       	BSptperpsf(&rc,bsp_surf1[0],&bsp_curve->poles[3*middle],
			  &num_pair, &upar,&vpar,base,&dist1);
               	if (rc!= BSSUCC){ 
                  printf("ERROR BSptperpsf when project curve onto surface\n");
                  goto wrapup;
                  }
#               ifdef DBG_PROJ
	        printf("num_pair of projection: %d\n",num_pair);
#               endif
	        if(num_pair == 1 ){
#           	      ifdef DBG_PROJ
		      printf("upar: %lf, vpar: %lf\n",upar, vpar);
		      printf("base: %lf, %lf,%lf\n",base[0], base[1], base[2]);
		      printf("dist: %lf\n",dist1);
#           	      endif
	    	      BSsfevaln(bsp_surf1[0], upar, vpar, 1, &num_normals,
				base, dirvect, &rc);
            	      if (rc!= BSSUCC){ 
                  	printf("ERROR BSsfevaln when project curve onto surface\n");
                  	err_flag = TRUE;
		  	goto wrapup;
            	      }
	        }
	    }
#           ifdef DBG_PROJ
	    printf("dirvect: %lf, %lf,%lf\n",dirvect[0], dirvect[1], dirvect[2]);
#           endif

            BSpjcvtsf(bsp_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
            if (rc!= BSSUCC){ 
               printf("ERROR BSpjcvtsf Bad projection on the surface: %d\n",rc);
               numgrps = 0;
             }
        
          }
     }
    else if(elem_type[0] == PLAN)
     {

         if(elem_type[i] == PLAN)
          {
            stat = VDint(PLAN, NULL, &plane[0], 1, PLAN, NULL, &plane[1],1,
                         &numgrps, &numpts, &pts , NULL, NULL);
          }
         else if(elem_type[i] == SURF)
          {
            stat = VDint(PLAN, NULL, &plane[0], 1, SURF, bsp_surf2,NULL,1,
                         &numgrps, &numpts, &pts , NULL, &par2);

          }
         else if(elem_type[i] == COMP_SF)
          {
            stat = VDint(PLAN, NULL, &plane[0], 1, COMP_SF, bsp_surf2,NULL,nb_sf2,
                         &numgrps, &numpts, &pts , NULL, NULL);
          }
         else
          {
#           ifdef DBG_PROJ
            printf("project curve on plan\n");
#           endif

            dirvect[0] = plane[0].normal[0];
            dirvect[1] = plane[0].normal[1];
            dirvect[2] = plane[0].normal[2];
            curve[i-1] = NULL;
            BSalloccv(	bsp_curve->order, 
			bsp_curve->num_poles, 
			bsp_curve->rational, 
			bsp_curve->num_boundaries,
 			&curve[i-1], 
			&rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
              	UI_status("ERROR Bad dynamic allocation ");
              	err_flag = TRUE;
	      	goto wrapup;
             }
            BSprj_cv_pl(&rc, bsp_curve, &plane[0].point[0], &plane[0].normal[0], 
			dirvect, curve[i-1]); 
            if(rc!=BSSUCC)
             {
                 printf("ERROR BSprj_cv_pl: no projection curve\n");
	         if(curve[i-1] != NULL) 
                  {
                    BSfreecv(&rc, curve[i-1]); 
                    curve[i-1]=NULL;
	            if (rc !=BSSUCC && rc!=BSNULL){
			printf("ERROR BSfreecv(curve) fail rc: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		    }
                  }
                 VDSfree(nb_sf2,&bsp_surf2); 
   	         if(bsp_curve != NULL) 
                  {
                    free(bsp_curve);
                    bsp_curve = NULL;	
                  }
    	         if(numpts != NULL) { free(numpts); numpts = NULL; }
    	         VDSfree(numgrps,&pts);
    	         VDSfree(numgrps,&par1);
    	         VDSfree(numgrps,&par2);
                 continue;
             }

#           ifdef DBG_PROJ
            printf("curve.order: %d\n",curve[i-1]->order);
            printf("curve.rationnal: %d\n",curve[i-1]->rational);
            printf("curve[i-1]->num_knots : %d\n",curve[i-1]->num_knots);
            if(curve[i-1]->rational)
            {
              for(k=0;k< curve[i-1]->num_poles ;k=k+1)
               printf("weight: %lf\n", curve[i-1]->weights[k]);
            }
            for(k=0;k< curve[i-1]->num_poles ;k=k+1)
            printf("proj_pts: %lf, %lf, %lf\n", curve[i-1]->poles[3*k],
                                            curve[i-1]->poles[3*k+1],
					    curve[i-1]->poles[3*k+2]);
#           endif

            coef = 0;
            for(k=0;k<3;k=k+1) 
               coef = coef + fabs(curve[i-1]->poles[k] - 
			      curve[i-1]->poles[3*(curve[i-1]->num_poles-1)+k]);
#      	    ifdef DBG_PROJ
	    printf("close curve ?, coef: %lf\n",coef);
#           endif

	    if (coef < basis_tol)
		{
#       	  ifdef DBG_PROJ
		  printf("close curve\n");
#       	  endif
		  close_cv = 1;
       		}
             VDSfree(nb_sf2,&bsp_surf2); 
   	     if(bsp_curve != NULL) 
                { free(bsp_curve); bsp_curve = NULL;}
    	     if(numpts != NULL) { free(numpts); numpts = NULL; }
    	     VDSfree(numgrps,&pts);
    	     VDSfree(numgrps,&par1);
    	     VDSfree(numgrps,&par2);
             continue;
          }
     } 
    else 
     {
        UI_status("ERROR invalid support, composite support not implemented");
        err_flag = TRUE;
	goto wrapup;
     } 

    if(!(stat&1))
     {
        UI_status("ERROR surf_int: in VDint function");
        err_flag = TRUE;
	goto wrapup;
     }
    if(numgrps < 1) 
     {
#       ifdef DBG_INTSF
        printf("surf_int: (numgrp<1)no intersection found with the %d surface\n",i);
#       endif
        curve[i-1] = NULL;
        VDSfree(nb_sf2,&bsp_surf2); 
        if(bsp_curve != NULL) {free(bsp_curve); bsp_curve = NULL;}
        if(numpts != NULL)    { free(numpts)  ; numpts    = NULL; }
        VDSfree(numgrps,&pts);
        VDSfree(numgrps,&par1);
        VDSfree(numgrps,&par2);
        continue;
     }
    num_pts = numpts[0];

#    ifdef DBG_INTSF
     printf("surfaces intersect stat = %d, numgrps= %d\n",rc,numgrps);
     printf("num_pts: %d\n",num_pts);
     for (l=0; l<numgrps; l=l+1)
      {
        if(numpts != NULL)
         {  
  	   printf("num_pts[%d] = %d\n",l,numpts[l]);
	   for(k=0;k<numpts[l] ;k=k+1)
	    { 
	      if(pts != NULL) printf("point : %lf, %lf, %lf\n",
                                     pts[l][3*k],pts[l][3*k+1],pts[l][3*k+2]);
	    }
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
              if(par1 != NULL) printf("par1: %lf, %lf\n", par1[l][2*k], par1[l][2*k+1]);
              if(par2 != NULL) printf("par2: %lf, %lf\n", par2[l][2*k], par2[l][2*k+1]);
	    }
         }
       }
#    endif
max_index = 0;
if(numgrps > 1)
 {

   /* ----- 
     make a unique gpe if possible (because of bug in BS intersect function
     that returns sometimes 2 gpes of intersections that are contiguous instead 
     of giving only one gpe that will gather the 2)
      ------ */
   UI_status("Try to make a unique gpe of intersection");
   Xnumpts	= NULL;
   Xpts		= NULL;
   Xpar1	= NULL;
   Xpar2	= NULL;

   stat = VDSorder_pt(numgrps, &numpts[0], pts, par1, par2, &Xnumgrps, 
		       &Xnumpts, &Xpts, &Xpar1, &Xpar2);
   if(!(stat & 1)){
   	UI_status("ERROR surf_int in VDSorder_pts");
   	err_flag = TRUE;
   	goto wrapup;
   }

   if(Xnumgrps != 1)
    {
      /*|cannot make a unique gpe */
      if(Xnumpts != NULL) { free(Xnumpts); Xnumpts = NULL; }
      sprintf(path,"%s%d%s","support and surface ",i," have more than one intersection");
      UI_message(path);
      UI_status("WARNING: only take longest intersection with support");
      VDSfree(Xnumgrps,&Xpts);
      VDSfree(Xnumgrps,&Xpar1);
      VDSfree(Xnumgrps,&Xpar2);
      tmp_curve = NULL;
      tmp_curve = (struct IGRbsp_curve **)
                malloc(numgrps * sizeof (struct IGRbsp_curve *));
      if(tmp_curve  == NULL) {
              	UI_status("ERROR Bad dynamic allocation ");
        	err_flag = TRUE;
		goto wrapup;
      }
      length = NULL;
      length = (double *)malloc(numgrps * sizeof (double));
      if(length  == NULL) {
              	UI_status("ERROR Bad dynamic allocation ");
        	err_flag = TRUE;
		goto wrapup;
      }
     max_length = 0;
     max_index  = 0;
     for (l=0; l<numgrps; l=l+1){
    	stat = VDSfill_curve(numpts[l], pts[l], NULL, &tmp_curve[l]);
    	if(!(stat & 1)){
    		UI_status("ERROR surf_int in VDSfill_curve\n");
    		err_flag = TRUE;
    		goto wrapup;
    	}
	start = 0;
	dir   = .5;
	end   = 1;
    	BSarclen(&rc, &bstat, tmp_curve[l], &start, &end, &dir, &length[l]);
    	if (rc!= BSSUCC ) { 
               	printf("ERROR surf_int, in BSarclen \n");
               	err_flag = TRUE;
		goto wrapup;
        } 
    	if( tmp_curve[l]!= NULL) 
                  {
                    BSfreecv(&rc, tmp_curve[l]); 
                    tmp_curve[l]=NULL;
	            if (rc !=BSSUCC && rc!=BSNULL){
			printf("BSfreecv(curve) fail rc: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		    }
                  }
#       ifdef DBG_INTSF
	printf("length[%d]: %lf\n",l,	length[l]);
#       endif
	if(length[l] > max_length){
		max_length = length[l];
		max_index = l;
	}
     }
#   ifdef DBG_INTSF
    printf("maxlength: %lf, maxindex: %d\n",max_length,max_index);
#   endif
    if(curve[i-1] != NULL) 
                  {
                    BSfreecv(&rc, curve[i-1]); 
                    curve[i-1]=NULL;
	            if (rc !=BSSUCC && rc!=BSNULL) 
                     {
			printf("BSfreecv(curve) fail rc: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		     }
                  }
    if(tmp_curve != NULL){
    	for (l=0; l<numgrps; l=l+1){
    		if( tmp_curve[l]!= NULL) 
                  {
                    BSfreecv(&rc, tmp_curve[l]); 
                    tmp_curve[l]=NULL;
	            if (rc !=BSSUCC && rc!=BSNULL){
			printf("BSfreecv(curve) fail rc: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		    }
                  }
    		}
    	free(tmp_curve);tmp_curve = NULL;
    }
    if( length!= NULL){free(length);length = NULL;}
    }
   else
    {
      if(numpts != NULL) { free(numpts); numpts = NULL; }
      VDSfree(numgrps,&pts);
      VDSfree(numgrps,&par1);
      VDSfree(numgrps,&par2);
      numgrps = Xnumgrps;
      numpts  = Xnumpts;
      pts     = Xpts;
      par1    = Xpar1;      
      par2    = Xpar2; 
      max_index = 0;     
    }
#  ifdef DBG_INTSF
   printf("total result ====================\n");
     for (l=0; l<numgrps; l=l+1)
      {
        if(numpts != NULL)
         {  
  	   printf("num_pts[%d] = %d\n",l,numpts[l]);
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
	      if(pts != NULL) printf("point : %lf, %lf, %lf\n",
                                     pts[l][3*k],pts[l][3*k+1],pts[l][3*k+2]);
	    }
	   for(k=0;k<numpts[l] && k<10;k=k+1)
	    { 
              if(par1 != NULL) printf("par1: %lf, %lf\n", par1[l][2*k], par1[l][2*k+1]);
              if(par2 != NULL) printf("par2: %lf, %lf\n", par2[l][2*k], par2[l][2*k+1]);
	    }
         }
      }
#  endif
 }
#ifdef DBG_INTSF
 printf("max_index: %d\n",max_index);
#endif

 num_pts = numpts[max_index];

 save_pts[6*(i-1)]   = pts[max_index][0]; 
 save_pts[6*(i-1)+1] = pts[max_index][1];  		/* first point of curve[i-1] */
 save_pts[6*(i-1)+2] = pts[max_index][2]; 

 save_pts[6*(i-1)+3] = pts[max_index][3*(numpts[max_index]-1)]; 
 save_pts[6*(i-1)+4] = pts[max_index][3*(numpts[max_index]-1)+1]; /* last point of curve[i-1] */
 save_pts[6*(i-1)+5] = pts[max_index][3*(numpts[max_index]-1)+2]; 


 VDSfree(nb_sf2,&bsp_surf2); 
 if(bsp_curve != NULL) {free(bsp_curve);bsp_curve = NULL;}
 curve[i-1] = NULL;

 /* ---------------
    Allocate the space for the bspline curve 
    WARNING, we always take only the first intersection 
    ------------ */

 if(elem_type[0] == PLAN )
  {
    if(elem_type[i] == PLAN)
     {
#      ifdef DBG_INTSF
       printf("define curve for plan /plan \n");
#      endif

       /* q,u point and vector of plane */
       q_pl[0] = pts[max_index][0];
       q_pl[1] = pts[max_index][1];
       q_pl[2] = pts[max_index][2];
 
       u_pl[0] = pts[max_index][0] - pts[max_index][3];
       u_pl[1] = pts[max_index][1] - pts[max_index][4];
       u_pl[2] = pts[max_index][2] - pts[max_index][5];
       BSalloccv(ORDER, num_pts, 0, 0, &curve[i-1], &rc);
       if(rc != BSSUCC && rc!=BSNULL) 
           { 
              	UI_status("ERROR Bad dynamic allocation ");
            	err_flag = TRUE;
		goto wrapup;
           }
       curve[i-1]->order     = ORDER;
       curve[i-1]->num_poles = num_pts;
       curve[i-1]->num_knots = num_pts + 2 * (ORDER - 1);

       /* Compute the end points of the line to do the intersection */

       BSmkvec(&rc, v1, range    , q_pl);
       BSmkvec(&rc, v2, &range[3], q_pl);
       
       if(BSdotp(&rc,v1,v2) <= 0)
	{
#	  ifdef DBG_INTSF
	  printf("The point of the infinit line is inside the range\n");
#	  endif
        }
       else
	{
#	  ifdef DBG_INTSF
	  printf("The point of the infinit line is not inside the range\n");
#	  endif

	  fact = fact + BSdistptpt(&rc, q_pl, range);
        }

       for(k=0;k<3;k=k+1)
         {
           curve[i-1]->poles[k]   = q_pl[k] - fact * u_pl[k];
           curve[i-1]->poles[k+3] = q_pl[k] + fact * u_pl[k];

#	   ifdef DBG_INTSF
	   printf("fact: %lf. Pole (q,u): %lf,%lf\n",fact,curve[i-1]->poles[k],curve[i-1]->poles[k+3]);
#	   endif

           curve[i-1]->knots[k+1] = (double) k/ (num_pts-1);
         }
       curve[i-1]->knots[0]         = 0;
       curve[i-1]->knots[num_pts+1] = 1;
  
     }/* end elem_type[i] = plan */
    else 
     {
#      ifdef DBG_INTSF
       printf("define curve for plan/not plan\n");
#      endif

       stat = VDSfill_curve(num_pts, pts[max_index], NULL, &curve[i-1]);
       if(!(stat & 1)){
       		UI_status("ERROR surf_int in VDSfill_curve");
       		err_flag = TRUE;
       		goto wrapup;
       	}
     }
  }/* end elem_type[0] = plan */
 else
  {
#   ifdef DBG_INTSF
    printf("define curve for surface/anything\n");
#   endif

    stat = VDSfill_curve(num_pts,  NULL, par1[max_index], &curve[i-1]);
    if(!(stat & 1)){
    	UI_status("ERROR surf_int in VDSfill_curve");
    	err_flag = TRUE;
    	goto wrapup;
    }
  }
      
#ifdef DBG_INTSF
 for(k=0;k<num_pts && k<10;k=k+1)
        printf("pts: %lf, %lf, %lf\n", 
                curve[i-1]->poles[3*k],curve[i-1]->poles[3*k+1],curve[i-1]->poles[3*k+2]);
    
 for(k=0;k<num_pts + ORDER && k<10;k=k+1) printf("knot: %lf\n",curve[i-1]->knots[k]);

#endif

 if (close_cv)     	curve[i-1]->phy_closed  = TRUE; 
 else	      	curve[i-1]->phy_closed  = FALSE;   
 curve[i-1]->weights     = NULL;
 curve[i-1]->planar      = TRUE;
 curve[i-1]->non_uniform = FALSE;
 curve[i-1]->periodic    = FALSE;

 /* Deallocation of the pointeurs */

 if(numpts != NULL) { free(numpts); numpts = NULL; }
 VDSfree(numgrps,&pts);
 VDSfree(numgrps,&par1);
 VDSfree(numgrps,&par2);

 }  /* End of  for(i=0;i<num_ent-1;i=i+1) */

/* -------------------------------------------------------------------- 

   compute the intersection points between each curve and its successor
   in the parameter definition of the support when it is a surface, 
   in RxRxR for a plane.

   The intersection point (curve[i], curve[i+1]) will have p_par1[i+1]
   param on curve i and p_par2[i+1] on curve i+1. The last intersection 
   point (curve[num_ent-3], curve[0]) will have p_par1[0] on curve num_ent-3
   and p_par2[0] on curve 0.

   We don't treat multiple intersections except in the case of 2 curves
   intersecting each other 2 times (creating a loop) 

   -------------------------------------------------------------------- */


#ifdef DBG_INTCV
 for(i=0;i<num_ent-2;i=i+1)
    if(curve[i] == NULL) printf("curve[%d] est NULL\n",i);
#endif

 num_merge = 0;
 i_onecv = -1;
 k = 0;
 for(i=0;i<num_ent-2;i=i+1)
  { 
    if(curve[i] != NULL) 
       {tab_cv[k] = i;k = k+ 1;num_merge = num_merge + 1;i_onecv = i; }
#   ifdef DBG_INTCV
    printf("i_onecv: %d\n",i_onecv);
#   endif
  }

# ifdef DBG_INTCV
  printf("num_merge: %d\n",num_merge);
  for(i=0;i<num_merge;i=i+1) printf("tab[%d]: %d\n",i,tab_cv[i]);
# endif


  if(num_merge == 0)
   {
    	UI_status("ERROR: no intersection between support and any surface");
    	err_flag = TRUE;
	goto wrapup;
   }
  if(num_merge == 1)
   {
    
#      	ifdef DBG_INTCV
	printf("num_merge == 1  curve %d\n",i_onecv);
#       endif

    	coef = 0;
        for(k=0;k<3;k=k+1) 
        coef = coef + fabs(curve[i_onecv]->poles[k] - 
			      curve[i_onecv]->poles[3*(curve[i_onecv]->num_poles-1)+k]);
#      	ifdef DBG_INTCV
	printf("close curve ?, coef: %lf\n",coef);
#       endif

	if (coef < basis_tol)
	  {
#       	  ifdef DBG_INTCV
		  printf("close curve\n");
#       	  endif
		  close_cv = 1;
       	  }
   }
  two_intersect = 0;

if(elem_type[0] == PLAN && num_merge == 1 && !close_cv) 
 {
  UI_status("ERROR: Cannot create a bounded plane with an open curve");
  err_flag = TRUE;
  goto wrapup;
 }
no_intersect = 0;
no_last_intersect = 0;
open_cv  = 0;
i=-1;

#   ifdef DBG_INTCV
    printf("COMPUTE THE INTERSECTION POINTS of curves\n");
#   endif
    UI_status("Compute the intpts of curves on the support");		

while(i<num_merge-1)
  {
    p_par1[i+1]  = NULL;
    p_par2[i+1]  = NULL;
    int_pts[i+1] = NULL;
    over0        = NULL;
    over1        = NULL;
    end_pts      = NULL;

#   ifdef DBG_INTCV
    printf("i: %d, num_merge: %d ...................\n",i,num_merge);
    printf("no_int: %d, no_last: %d\n",no_intersect,no_last_intersect);
    printf("open_cv: %d\n",open_cv);
#   endif

    if(close_cv) break;
    if(num_merge == 1) break;



    /* ------------------------------------------------------------------

       if num_ent = 4 ie 2 curve on support, case of 2 intersections is
       treated with one cvcv_int 

       ------------------------------------------------------------------ */

    if(i==-1 && num_merge == 2) {i=i+1;continue;}/*2 cv on support */
    n_int = 0;
    if(i==-1 )
     {
#   	 ifdef DBG_INTCV
         printf("intersect cv[%d] et cv[%d]\n",tab_cv[num_merge-1],tab_cv[0]);
#   	 endif

         BScvcv_int(&rc, curve[tab_cv[num_merge-1]], curve[tab_cv[0]], &n_int, 
		    &int_pts[0], &p_par1[0], &p_par2[0], &n_over, &end_pts, 
		    &over0, &over1);
     }
    else 
     {
#   	 ifdef DBG_INTCV
         printf("intersect cv[%d] et cv[%d]\n",tab_cv[i],tab_cv[i+1]);
#   	 endif
         BScvcv_int(&rc, curve[tab_cv[i]], curve[tab_cv[i+1]], &n_int, 
		    &int_pts[i+1], &p_par1[i+1], &p_par2[i+1], &n_over, 
		    &end_pts, &over0, &over1);
     }


    if(rc != BSSUCC || n_over > 0 || (n_int < 1 && open_cv > 0))
     {
       UI_status("ERROR bad curve intersection ");
       printf("surf_int, ERROR bad curve intersection (%d)\n", i+1);
       printf("rc: %d, nb_int: %d\n",rc,n_int);

       /* WE must deallocate the stuff */

       for(k=0; k<=i+1; k=k+1)
        {
         if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
         if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	 if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
        }
       for(k=0; k<num_ent-2; k=k+1)
        {
	 if(curve[k] != NULL) 
          {
            BSfreecv(&rc, curve[k]);	
            curve[k]=NULL;
	    if (rc !=BSSUCC && rc!=BSNULL) 
	     {	printf("BSfreecv(curve) fail rc: %d\n",rc);
		err_flag = TRUE;
		goto wrapup;
	     }
	  }
         }
       err_flag = TRUE;
       goto wrapup;
      }
    if(num_merge == 2 && n_int < 2)
      {
#       ifdef DBG_INTCV
        printf("num_merge == 2 && n_int < 2\n");
#       endif
        if(n_int < 1)
           {
             UI_status("ERROR ,2 cv without any intersection");
	     err_flag = TRUE;
	     goto wrapup;
           }
	open_cv = open_cv + 1;
	index_open[0] = tab_cv[i];
	index_open[1] = tab_cv[i+1];
        break;
      } 
    else if(n_int < 1 )
      {
#         ifdef DBG_INTCV
          printf("n_int < 1: %d\n",n_int);
          if(i != -1)printf("cv (%d) & cv (%d) n'ont pas d'intersection\n",tab_cv[i],tab_cv[i+1]);
#         endif

          if(i == -1)
           {
#            ifdef DBG_INTCV
             printf("i==-1\n");
#            endif
	     index_open[0] = tab_cv[0];
	     index_open[1] = tab_cv[num_merge-1];
             no_last_intersect = 1;
	     i = i+1;
	     continue;
           }
	  else if(no_intersect==0 && !(i == 0 && no_last_intersect) && i!=num_merge -2)
           {
#   	     ifdef DBG_INTCV
             printf("met no_intersect to 1\n");
#            endif
	     no_intersect = 1;
             index_open[0] = tab_cv[i];
             index_open[1] = tab_cv[i+1];
	     i = i+1;
	     continue;
           }
          else if((no_last_intersect && i==0) || no_intersect )
           {
#   	        ifdef DBG_INTCV
	        printf("consider curve [%d] as NULL\n",tab_cv[i]);
#   	        endif
                num_merge = num_merge - 1;
                for(k=i;k<num_merge; k=k+1) 
                 {
                  tab_cv[k] = tab_cv[k+1];
#   	          ifdef DBG_INTCV
                  printf("k: %d, tab[k]: %d\n",k,tab_cv[k]);
#   	          endif
                 }
#   	        ifdef DBG_INTCV
                printf("num_merge after suppressing 1 index: %d\n",num_merge); 
#   	        endif
		if(no_last_intersect && i==0) no_last_intersect = 0;
                if(no_intersect) no_intersect = 0;
	        i = i-1;
	        continue;
           } 
          else 
           {
#   	     ifdef DBG_INTCV
             printf("else\n");
#   	     endif
	     if(i== num_merge-2 && !no_last_intersect)
              {
#   	        ifdef DBG_INTCV
                printf("i== num_merge-2 && !no_last_intersect\n");
#   	        endif
                open_cv = open_cv + 1;
	        index_open[0] = tab_cv[i];
	        index_open[1] = tab_cv[i+1];
                i=i+1;
                break;
              }
	     else if(i== num_merge-2 && no_last_intersect)
              {
#   	        ifdef DBG_INTCV
                printf("suppress curve n-1 and make intersect (n-2 & 0)\n");
#   		endif
                no_last_intersect = 0;
                num_merge = num_merge - 1;
#   	        ifdef DBG_INTCV
                printf("num_merge: %d\n",num_merge);
                printf("intersect cv[%d] & cv [%d]\n",tab_cv[num_merge-1],tab_cv[0]);
#   		endif
                BScvcv_int(&rc, curve[tab_cv[num_merge-1]], curve[tab_cv[0]], 
			   &n_int, &int_pts[0], &p_par1[0], &p_par2[0], 
			   &n_over, &end_pts, &over0, &over1);

                if(rc != BSSUCC || n_over > 0 || (n_int < 1 && open_cv > 0))
                 {
                   printf("surf_int, ERROR bad curve intersection (%d)\n", i+1);
                   printf("rc: %d, nb_int: %d\n",rc,n_int);

                   for(k=0; k<=i+1; k=k+1)
                    {
                     if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
                     if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	             if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
                    }
                   for(k=0; k<num_ent-2; k=k+1)
                    {
	             if(curve[k] != NULL) 
                      {
                        BSfreecv(&rc, curve[k]);	
                        curve[k]=NULL;
	                if (rc !=BSSUCC && rc!=BSNULL) 
		         {
				printf("BSfreecv(curve) fail rc: %d\n",rc);
				err_flag = TRUE;
				goto wrapup;
			 }
	              }
                     }
                   err_flag = TRUE;
		   goto wrapup;
                  }
                 else if(n_int < 1 )
      		  {
#   	           ifdef DBG_INTCV
          	   printf("n-2  & 0  n'ont pas d'intersection\n");
#   		   endif
	           open_cv =  open_cv + 1;
	           if(elem_type[0] == PLAN ) 
 	            {
  		         printf("cannot create a bounded plane with an open curve\n");
       		         for(k=0; k<=i+1; k=k+1)
        	          {
         	            if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
         	            if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	 	            if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
        	          }
       		         for(k=0; k<num_ent-2; k=k+1)
        	          {
	 	            if(curve[k] != NULL) 
          	             {
            		         BSfreecv(&rc, curve[k]);	
            		         curve[k]=NULL;
	    		         if (rc !=BSSUCC && rc!=BSNULL) 
				  {
				    printf("BSfreecv(curve) fail rc: %d\n",rc);
				    err_flag = TRUE;
				    goto wrapup;
				  }
	  	             }
        	          }
  		         err_flag = TRUE;
			 goto wrapup;
                     }  
	           index_open[0] = tab_cv[num_merge-1];
	           index_open[1] = tab_cv[0];
                   break;
                  }
                 else
                  {
#   		   ifdef DBG_INTCV
                   printf("n_int > 1\n");
#   		   endif
		   i = i+1;
                   break;
                  }
             }

           }
      }
     else 
      { 
#      ifdef DBG_INTCV
       printf(" n_int >= 1 : %d\n",n_int);
#      endif
       if(n_int > 2) 
        {
          printf("surf_int, Error more than two intersections\n");
          /* WE must deallocate the stuff */
          for(k=0; k<=i+1; k=k+1)
           {
             if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
             if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	     if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
           }
          for(k=0; k<num_ent-2; k=k+1)
           {
	     if(curve[k]!=NULL) 
              {
                BSfreecv(&rc, curve[k]); 
                curve[k]=NULL;
	        if (rc !=BSSUCC && rc!=BSNULL) 
                 {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		 }
              }
           }
          err_flag = TRUE;
	  goto wrapup;
        }/* end n_int >2 */
       else if(n_int == 2)
        {
 #       ifdef DBG_INTCV
         printf(" n_int == 2 \n");
 #       endif
         if(num_merge > 2)
           {
             printf("surf_int, 2 intersections, NOT yet implemented\n");
             /* WE must deallocate the stuff */

             for(k=0; k<=i+1; k=k+1)
              {
   	       if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
               if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
               if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
              }
             for(k=0; k<num_ent-2; k=k+1)
              {
	       if(curve[k]!=NULL) 
                {
                  BSfreecv(&rc, curve[k]); 
                  curve[k]=NULL;
	          if (rc !=BSSUCC && rc!=BSNULL) 
                    {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		    }
                }
              }
             err_flag = TRUE;
	     goto wrapup;
           }/* n_int =2 & more than 2 curves */
          else
           {
#           ifdef DBG_PARTOF
            printf(" Specific case, two curves and two intersections \n");
#           endif
	    UI_status("Extract partof curves between intpts");

	    two_intersect=1;
            p_curve[0] = NULL;
            order 	   = curve[0]->order;
            BSalloccv(order, curve[0]->num_poles + 2 * order - 1, 
                      curve[0]->rational, curve[0]->num_boundaries ,&p_curve[0], 
                      &rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
               printf("surf_int, Bad allocation for the curves\n");
               for(k=0; k<=i+1; k=k+1)
                {
   	         if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
                 if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
                 if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
                }
               for(k=0; k<num_ent-2; k=k+1)
                {
	         if(curve[k] != NULL) 
                  {
                     BSfreecv(&rc, curve[k]); 
                     curve[k]=NULL;
	             if (rc !=BSSUCC && rc!=BSNULL) 
                      {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		      }
	          }
                }
               err_flag = TRUE;
	       goto wrapup;
             }
            d_par=(p_par1[1][1]+p_par1[1][0])/2;
            if(p_par1[1][1] > p_par1[1][0]) rev = 1;
            else		                 rev = 0;

#           ifdef DBG_PARTOF

            printf("p_par1[1][1]: %lf, p_par1[1][0]: %lf\n",p_par1[1][1],p_par1[1][0]);
            printf("curve 0 d_par: %lf\n",d_par);
#           endif

            BSpartofcv(&rc, curve[0], p_par1[1][1], d_par, p_par1[1][0], p_curve[0]);
            if(rc != BSSUCC) 
             { 
              printf("surf_int, Bad extraction of the part of curve 1\n");
	      if(p_curve[0]!=NULL)
               {
                 BSfreecv(&rc, p_curve[0]); 
                 p_curve[0]=NULL;
	         if (rc !=BSSUCC && rc!=BSNULL) 
                  {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		  }
               }
              err_flag = TRUE;
	      goto wrapup;
             }
            if(p_par1[1]   != NULL) {free(p_par1[1]); p_par1[1] = NULL;}
	    if(curve[0]!=NULL)
             {
               BSfreecv(&rc, curve[0]);
               curve[0]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
             }

            if(rev)   
	     {
	       BSrev_cv(&rc, p_curve[0]);
               if(rc != BSSUCC) 
                {
                  printf("surf_int, ERROR cannot reverse the curve\n");
       	          if(p_curve[0]!=NULL)
                   {
                     BSfreecv(&rc, p_curve[0]);
                     p_curve[0] = NULL;
       		     if (rc !=BSSUCC && rc!=BSNULL) 
		      {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		      }
                   }
       	          err_flag = TRUE;
		  goto wrapup;
                }
	     }
#           ifdef DBG_PARTOF
            printf("\n\n");
            printf("num_poles: %d\n",p_curve[0]->num_poles);
            for(k=0;k<p_curve[0]->num_poles ;k=k+1)
            printf("poles of the part curve 0: %lf, %lf, %lf\n",p_curve[0]->poles[3*k],  
            p_curve[0]->poles[3*k+1],p_curve[0]->poles[3*k+2]);
#           endif
            if(p_curve[0]->rational)
             {
               for(k=0;k<p_curve[0]->num_poles;k=k+1)
	        {
		   p_curve[0]->poles[3*k]   = p_curve[0]->poles[3*k]/
						p_curve[0]->weights[k];
		   p_curve[0]->poles[3*k+1] = p_curve[0]->poles[3*k+1]/
						p_curve[0]->weights[k];
		   p_curve[0]->poles[3*k+2] = p_curve[0]->poles[3*k+2]/
						p_curve[0]->weights[k];
	        }
	       p_curve[0]->rational = 0;
	       if(p_curve[0]->weights)
	         {
		   free(p_curve[0]->weights);
		   p_curve[0]->weights  = NULL;
	         }
             }

            p_curve[1] = NULL;
            order = curve[1]->order;
            BSalloccv(order, curve[1]->num_poles + 2 * order - 1,
		   curve[1]->rational, curve[1]->num_boundaries, 
		   &p_curve[1], &rc);
            if(rc != BSSUCC && rc!=BSNULL) 
             { 
               printf("surf_int, Bad allocation for the curves\n");
               for(k=0; k<=i+1; k=k+1)
                {
   	         if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
                 if(p_par1[k] != NULL) {free(p_par1[k]);  p_par1[k]  = NULL;}
                 if(p_par2[k] != NULL) {free(p_par2[k]);  p_par2[k]  = NULL;}
                }
               for(k=0; k<num_ent-2; k=k+1)
                {
	         if(curve[k] != NULL) 
                   {
                      BSfreecv(&rc, curve[k]); 
                      curve[k]=NULL;
	              if (rc !=BSSUCC && rc!=BSNULL) 
			{	
				printf("BSfreecv(curve) fail\n");
				err_flag = TRUE;
				goto wrapup;
			}
		   }
                }
               err_flag = TRUE;
	       goto wrapup;
             }
            d_par=(p_par2[1][0]+p_par2[1][1])/2;
            if( p_par2[1][0]> p_par2[1][1]) rev = 1;
            else		                rev = 0;

# 	    ifdef DBG_PARTOF
            printf("p_par2[1][0]: %lf, p_par2[1][1]: %lf\n",p_par2[1][0],p_par2[1][1]);
            printf("curve 1 d_par: %lf\n",d_par);
# 	    endif
     
            BSpartofcv(&rc, curve[1],p_par2[1][0], d_par,p_par2[1][1], p_curve[1]);
            if(rc != BSSUCC) 
             { 
              printf("surf_int, Bad extraction of the part of curve 0\n");
	      if(p_curve[1]!=NULL) 
                {
                  BSfreecv(&rc, p_curve[1]);
	          p_curve[1]=NULL;
	          if (rc !=BSSUCC && rc!=BSNULL) 
                    {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		    }
                }
              err_flag = TRUE;
	      goto wrapup;
             }
            if(p_par2[1]   != NULL) {free(p_par2[1]); p_par2[1] = NULL;}
	    if(curve[1]!=NULL) 
             {
               BSfreecv(&rc, curve[1]);
               curve[1]=NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                  {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		  }
             }
            if(rev)     
	     {
	       BSrev_cv(&rc, p_curve[1]);
               if(rc != BSSUCC) 
                 { 
       		   printf("surf_int, ERROR cannot reverse the curve\n");
       		   if(p_curve[1]!=NULL) 
                     {
                       BSfreecv(&rc, p_curve[1]);
                       p_curve[1] = NULL;
       		       if (rc !=BSSUCC && rc!=BSNULL) 
                          {
				printf("BSfreecv(curve) fail\n");
				err_flag = TRUE;
				goto wrapup;
			  }
		      }
       		   err_flag = TRUE;
		   goto wrapup;
                 }
	     }
#           ifdef DBG_PARTOF
            for(k=0;k<p_curve[1]->num_poles ;k=k+1)
            printf("poles of the part_curve 1: %lf, %lf, %lf\n", p_curve[1]->poles[3*k], p_curve[1]->poles[3*k+1],p_curve[1]->poles[3*k+2]);
#           endif
            if(p_curve[1]->rational)
             {
               for(k=0;k<p_curve[1]->num_poles;k=k+1)
	        {
		   p_curve[1]->poles[3*k]   = p_curve[1]->poles[3*k]/
						p_curve[1]->weights[k];
		   p_curve[1]->poles[3*k+1] = p_curve[1]->poles[3*k+1]/
						p_curve[1]->weights[k];
		   p_curve[1]->poles[3*k+2] = p_curve[1]->poles[3*k+2]/
						p_curve[1]->weights[k];
	        }
	       p_curve[1]->rational = 0;
	       if(p_curve[1]->weights)
	         {
		   free(p_curve[1]->weights);
		   p_curve[1]->weights  = NULL;
	         }
             }/* rational */

            if(p_par1[0] != NULL) {free(p_par1[0]) ; p_par1[0]  = NULL;}
            if(p_par2[0] != NULL) {free(p_par2[0]) ; p_par2[0]  = NULL;}
   	    if(int_pts[0]!= NULL) {free(int_pts[0]); int_pts[0] = NULL;}
   	    if(over0     != NULL) {free(over0)     ; over0      = NULL;}
   	    if(over1     != NULL) {free(over1)     ; over1      = NULL;}
   	    if(end_pts   != NULL) {free(end_pts)   ; end_pts    = NULL;}
            break;
           } /* end 2 cv, 2 intersections */
        } /* n_int == 2 */

       else if(( no_intersect && i!=0)|| (i==num_merge-2 && no_last_intersect))
        {
#         ifdef DBG_INTCV 
	  printf("index %d a une intersect mais pas avec la pcdte\n",i);
#         endif
          open_cv =  open_cv + 1;
          if(i==num_merge-2 && no_last_intersect && no_intersect)
              {
              	UI_status("ERROR more than one opening, cannot close curve");
		err_flag = TRUE;
		goto wrapup;
              }
	  else if(elem_type[0] == PLAN ) 
 	    {
  		printf("cannot create a bounded plane with an open curve\n");
       		for(k=0; k<=i+1; k=k+1)
        	 {
         	   if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
         	   if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
   	 	   if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
        	 }
       		for(k=0; k<num_ent-2; k=k+1)
        	 {
	 	   if(curve[k] != NULL) 
          	    {
            		BSfreecv(&rc, curve[k]);	
            		curve[k]=NULL;
	    		if (rc !=BSSUCC && rc!=BSNULL) 
			  {
				printf("BSfreecv(curve) fail rc: %d\n",rc);
				err_flag = TRUE;
				goto wrapup;
			  }
	  	    }
        	  }
  		err_flag = TRUE;
		goto wrapup;
            } /* end open and plan */ 
	  else if(i==num_merge-2 && no_last_intersect)
            {
	     index_open[0] = tab_cv[num_merge-1];
	     index_open[1] = tab_cv[0];
            }
          else
            {
	     index_open[0] = tab_cv[i-1];
	     index_open[1] = tab_cv[i];
            }
          i=i+1;
#         ifdef DBG_INTCV 
          printf("index_open: %d, %d\n",index_open[0],index_open[1]);
#         endif
	  if(i==num_merge-2 && no_last_intersect) no_last_intersect = 0;
          if( no_intersect && i!=0)               no_intersect = 0;
	}/* end if( no_intersect && i!=0||i==num_merge-2 && no_last_intersect)*/
      else
       {
#        ifdef DBG_INTCV 
         printf("good intersection\n");
         printf("number of intersection: %d, de over: %d\n", n_int, n_over);
         for(k=0; k<n_int && k<10; k=k+1)
          {
            printf("coord sur le sup: %lf, %lf, %lf\n",int_pts[i+1][3*k],int_pts[i+1][3*k+1],int_pts[i+1][3*k+2]);
            printf("param: %lf\n",   p_par1[i+1][k]);
            printf("param: %lf\n\n", p_par2[i+1][k]);
          }
#        endif
	i=i+1;
       }
      }/* end else de n_int > 1*/

   if(over0   != NULL) {free(over0)  ; over0   = NULL;}
   if(over1   != NULL) {free(over1)  ; over1   = NULL;}
   if(end_pts != NULL) {free(end_pts); end_pts = NULL;}
   } /* End of   while i < num_merge-1 */

# ifdef DBG_INTCV 
  printf("end while no_intersect: %d, no_last: %d, open_cv: %d\n",no_intersect,no_last_intersect, open_cv);
  for(i=0;i<num_merge;i=i+1) printf("tab[%d]: %d\n",i,tab_cv[i]);
# endif

  if(no_intersect ) open_cv =  open_cv + 1;
# ifdef DBG_INTCV 
  printf("open_cv: %d\n",open_cv);
  if(open_cv)  printf("index_open: %d, %d\n",index_open[0],index_open[1]);
# endif
  if(open_cv > 1) 
      { 
        UI_status("ERROR more than one opening in the curve, cannot close");
        err_flag = TRUE;
        goto wrapup;
      }

if(elem_type[0] == PLAN && open_cv) 
 {
  UI_status("ERROR: Cannot create a bounded plane with an open curve");
  err_flag = TRUE;
  goto wrapup;
 }
  
nb_poles   =  0;
found      =  0;
index_NULL = -1;
cv0pt0	   =  1;
cv0pt1	   =  1;
cv1pt0	   =  1;
cv1pt1	   =  1;

if ((elem_type[0] != PLAN && !two_intersect) && 
                  (open_cv || (num_merge == 1 && !close_cv)) )
{
#ifdef DBG_BND
 printf("\ntry to find the boundary of the surface that close the curve\n\n");
#endif
UI_status("Try to close the curve with the surface boundaries");

 p_par10  = NULL;
 p_par20  = NULL;
 int_pts0 = NULL;
 p_par11  = NULL;
 p_par21  = NULL;
 int_pts1 = NULL;
 over0    = NULL;
 over1    = NULL;
 end_pts  = NULL;
 nb_sol   = 1; 
 
 if(num_merge == 1 && !close_cv)
  {
#   ifdef DBG_BND
    printf("num_merge == 1 && !close_cv\n");
#   endif
    
    if(curve[tab_cv[0]]->poles[0] == 0 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)] == 0 )
     {
          	opt      = 1;		/* u cst */
          	value    = 0.;    
		order    = bsp_surf1[0]->v_order;
		nb_poles = bsp_surf1[0]->v_num_poles ;
     }
    else if(curve[tab_cv[0]]->poles[0] == 1 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)] == 1 )
     {
          	opt      = 1;		/* u cst */
          	value    = 1.;    
		order    = bsp_surf1[0]->v_order;
		nb_poles = bsp_surf1[0]->v_num_poles ;
     }
    else if(curve[tab_cv[0]]->poles[1] == 0 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)+1] == 0 )
     {
          	opt      = 2;		/* v cst */
          	value    = 0.;    
		order    = bsp_surf1[0]->u_order;
		nb_poles = bsp_surf1[0]->u_num_poles ;
     }
    else if(curve[tab_cv[0]]->poles[1] == 1 && 
        curve[tab_cv[0]]->poles[ 3*(curve[tab_cv[0]]->num_poles-1)+1] == 1 )
     {
          	opt      = 2;		/* v cst */
          	value    = 1.;    
		order    = bsp_surf1[0]->u_order;
		nb_poles = bsp_surf1[0]->u_num_poles ;
     }
    else
     {
      		UI_status("ERROR: Cannot close the only curve");
		err_flag = TRUE;
		goto wrapup;
     }
    tst_plan = FALSE;
    bnd_curve = NULL;
    BSalloccv(order, nb_poles ,  bsp_surf1[0]->rational, 0,  &bnd_curve, &rc);
    if(rc != BSSUCC && rc!=BSNULL) 
       	  { 
              	UI_status("ERROR Bad dynamic allocation ");
	    	err_flag = TRUE;
		goto wrapup;
	  }
    BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,bnd_curve);
    if(rc != BSSUCC)
	{printf("ERROR  BSconstprcv: %d\n",rc);err_flag = TRUE;goto wrapup;}

#   ifdef DBG_BND
    printf("bnd_curve result ----------\n");
    printf("nb_pole: %d\n",bnd_curve->num_poles);
    for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#   endif

#   ifdef DBG_BND
    printf("transform curve %d to param by project \n",i);
#   endif
    numgrps = 0;
    numpts  = NULL;
    pts     = NULL;
    par1    = NULL;


#   ifdef DBG_PROJ
    printf("curve is on surface, take normal to vector defined by 2 near pt on cv\n");
#   endif

    /* curve is on surface, take normal to vector defined by 2 near pt on cv */

    if(bsp_surf1[0]->planar == TRUE){
	BSsfnormal(bsp_surf1[0], dirvect, &rc);
        if (rc!= BSSUCC){ 
                  printf("surf_int, Bad BSsfnormal\n");
                  err_flag = TRUE;
		  goto wrapup;
        }
    }
    else{
    	middle   = (int)(bnd_curve->num_poles/2);
       	BSprptonsf(&rc,bsp_surf1[0], &bnd_curve->poles[3*middle],
		   &upar,&vpar,&onsurf);
       	if(rc != BSSUCC){
		printf("ERROR  BSprptonsf: %d\n",rc);
		err_flag = TRUE;
		goto wrapup;
	}
	BSsfevaln(bsp_surf1[0], upar, vpar, 1, &num_normals,
		  base, dirvect, &rc);
	if (rc!= BSSUCC){ 
                  	printf("surf_int, Bad BSsfevaln\n");
                  	err_flag = TRUE;
		  	goto wrapup;
	}

    }

#   ifdef DBG_PROJ
    printf("dirvect: %lf, %lf,%lf\n",dirvect[0], dirvect[1], dirvect[2]);
#   endif

    BSpjcvtsf(bnd_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
    if (rc!= BSSUCC ){ 
               	printf("surf_int, Bad projection on the surface: %d\n",rc);
               	err_flag = TRUE;
		goto wrapup;
    } 
    if(numgrps > 1) {
		UI_status("ERROR transform pt to param give more than one gp");
        	err_flag = TRUE;
		goto wrapup;
    } 
    nb_poles = numpts[0];
    if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve);bnd_curve =NULL;}
    stat = VDSfill_curve(nb_poles, NULL, par1[0], &bnd_curve);
    if(!(stat & 1)){
    	UI_status("ERROR VDSfill_curve");
    	err_flag = TRUE;
    	goto wrapup;
    }
    VDSfree(numgrps,&par1);
    VDSfree(numgrps,&pts);
    if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}

#   ifdef DBG_BND
    printf("bnd_curve result param ----------\n");
    printf("nb_pole: %d\n",bnd_curve->num_poles);
    for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#   endif

#   ifdef DBG_BND
    printf("intersect bnd avec curve[0] ----------\n"); 
#   endif

    BScvcv_int(&rc, bnd_curve, curve[tab_cv[0]], &n_int0, &int_pts0, 
     	       &p_par10, &p_par20, &n_over, &end_pts, &over0, &over1);

    if(rc != BSSUCC || n_over > 0)
	      {
                 printf(" ERROR in BScvcv_int \n");
	         err_flag = TRUE;
		 goto wrapup;
	      }
    if(n_int0 < 2 )
              {
                UI_status("ERROR: bnd_curve & cv[0] ont moins de 2 intersection");
 		printf("cannot close the curve\n");
		err_flag = TRUE;
		goto wrapup;
              }
    if(over0     != NULL) {free(over0)  ; over0   = NULL;}
    if(over1     != NULL) {free(over1)  ; over1   = NULL;}
    if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
    found = 1;
  }
 else
  {

#  ifdef DBG_BND
   printf("find the number of solution to close the curve\n");

   printf("index 0: %d\n",index_open[0]);
   printf("index 1: %d\n",index_open[1]);
   printf("cv0pt0: %lf, %lf\n",curve[index_open[0]]->poles[0],curve[index_open[0]]->poles[1]);
   printf("cv0pt1: %lf, %lf\n",curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)],
              curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)+1]);
   printf("cv1pt0: %lf, %lf\n",curve[index_open[1]]->poles[0],curve[index_open[1]]->poles[1]);
   printf("cv1pt1: %lf, %lf\n",curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)],
              curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)+1]);
#  endif

   if(curve[index_open[0]]->poles[0] != 0 && curve[index_open[0]]->poles[0] != 1
      && curve[index_open[0]]->poles[1] != 0 && curve[index_open[0]]->poles[1] != 1)
    {
#     ifdef DBG_BND
      printf("open 0 pt0 is not on the border of the surface\n");
#     endif

      cv0pt0 = 0;
    }
   if(curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)] != 0 
    && curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)] != 1
    && curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)+1] != 0
    && curve[index_open[0]]->poles[3*(curve[index_open[0]]->num_poles-1)+1] != 1)
    {
#     ifdef DBG_BND
      printf("open 0 pt1 is not on the border of the surface\n");
#     endif

      cv0pt1 = 0;
    }
   if(curve[index_open[1]]->poles[0] != 0 && curve[index_open[1]]->poles[0] != 1
      && curve[index_open[1]]->poles[1] != 0 && curve[index_open[1]]->poles[1] != 1)
    {
#     ifdef DBG_BND
      printf("open 1 pt0 is not on the border of the surface\n");
#     endif

      cv1pt0 = 0;
    }
   if(curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)] != 0 
    && curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)] != 1
    && curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)+1] != 0
    && curve[index_open[1]]->poles[3*(curve[index_open[1]]->num_poles-1)+1] != 1)

    {
#     ifdef DBG_BND
      printf("open 1 pt1 is not on the border of the surface\n");
#     endif

      cv1pt1 = 0;
    }


   if( (!cv0pt0 && !cv0pt1) || (!cv1pt0 && !cv1pt1) )
    {
      	printf("ERROR: one curve doesn't intersect the border of the surface");
      	err_flag = TRUE;
	goto wrapup;
    }
   else if( cv0pt0 && cv0pt1 && cv1pt0 && cv1pt1) nb_sol = 2;
   else 					  nb_sol = 1;
  }

   if(nb_sol == 2)
    {
#       ifdef DBG_BND
      	printf("\n nb_sol = 2 close the curve with the bnd the nearest\n\n");
#       endif

      	if(index_open[0] != num_ent - 3) index_NULL = index_open[0]+1;
      	else			         index_NULL = 0;

#       ifdef DBG_BND
      	printf("index of a null curve: %d\n",index_NULL);
#       endif

       	pt0[0] = save_pts[6*index_open[0]];
       	pt0[1] = save_pts[6*index_open[0]+1];
       	pt0[2] = save_pts[6*index_open[0]+2];

       	pt1[0] = save_pts[6*index_open[0]+3];
       	pt1[1] = save_pts[6*index_open[0]+4];
       	pt1[2] = save_pts[6*index_open[0]+5];

#       ifdef DBG_BND
	printf("point_on: %lf, %lf, %lf\n",point_on[3*(index_NULL+1)],
		point_on[3*(index_NULL+1)+1],point_on[3*(index_NULL+1)+2]);
#       endif
 
       	dist1 = VDSdist2(&point_on[3*(index_NULL+1)], &pt1[0]);
       	dist2 = VDSdist2(&point_on[3*(index_NULL+1)], &pt0[0]);

#       ifdef DBG_BND
	printf("pt0: %lf, %lf, %lf\n",pt0[0],pt0[1],pt0[2]);
	printf("pt1: %lf, %lf, %lf\n",pt1[0],pt1[1],pt1[2]);
#       endif

       	if(dist1 > dist2)
	 { 
     	   pt2[0] = pt0[0];
     	   pt2[1] = pt0[1];
     	   pt2[2] = pt0[2];
	 }
       	else 
	 {
 	   pt2[0] = pt1[0];
 	   pt2[1] = pt1[1];
 	   pt2[2] = pt1[2];
	 }
#       ifdef DBG_BND
        printf("pt2 : %lf, %lf, %lf is the nearest\n",pt2[0],pt2[1],pt2[2]);
	printf("verify the second end point\n");
#       endif

           
       	pt0[0] = save_pts[6*index_open[1]];
       	pt0[1] = save_pts[6*index_open[1]+1];    /* pt u=0 of save_pts - 1*/
       	pt0[2] = save_pts[6*index_open[1]+2];

       	pt1[0] = save_pts[6*index_open[1]+3];
       	pt1[1] = save_pts[6*index_open[1]+4];
       	pt1[2] = save_pts[6*index_open[1]+5];

#       ifdef DBG_BND
	printf("pt0: %lf, %lf, %lf\n",pt0[0],pt0[1],pt0[2]);
	printf("pt1: %lf, %lf, %lf\n",pt1[0],pt1[1],pt1[2]);
	printf("point_on: %lf, %lf, %lf\n",point_on[3*(index_NULL+1)],
		point_on[3*(index_NULL+1)+1],point_on[3*(index_NULL+1)+2]);
#       endif
 
       	dist1 = VDSdist2(&point_on[3*(index_NULL+1)], &pt1[0]);
       	dist2 = VDSdist2(&point_on[3*(index_NULL+1)], &pt0[0]);
       
       	if(dist1 > dist2)
	 { 
     	   pt3[0] = pt0[0];
     	   pt3[1] = pt0[1];
     	   pt3[2] = pt0[2];
	 }
        else 
	 {
 	   pt3[0] = pt1[0];
 	   pt3[1] = pt1[1];
 	   pt3[2] = pt1[2];
	 }

#      	ifdef DBG_BND
       	printf("pt3 : %lf, %lf, %lf is the nearest\n",pt3[0],pt3[1],pt3[2]);
        printf("transform pt2 and pt3 to param\n");
#      	endif

       	BSprptonsf(&rc,bsp_surf1[0],pt2,&upar,&vpar,&onsurf);
       	if(rc != BSSUCC)
	  {printf("ERROR  BSprptonsf: %d\n",rc);err_flag = TRUE;goto wrapup;}
       	pt2[0] = upar; pt2[1] = vpar; pt2[2] =0.;

#      	ifdef DBG_BND
       	printf("pt2 : %lf, %lf, %lf \n",pt2[0],pt2[1],pt2[2]);
#      	endif

       	BSprptonsf(&rc,bsp_surf1[0],pt3,&upar,&vpar,&onsurf);
       	if(rc != BSSUCC)
	   {printf("ERROR  BSprptonsf: %d\n",rc);err_flag = TRUE;goto wrapup;}
       	pt3[0] = upar; pt3[1] = vpar; pt3[2] =0.;

#      	ifdef DBG_BND
       	printf("pt3 : %lf, %lf, %lf \n",pt3[0],pt3[1],pt3[2]);
#      	endif

        if(fabs(pt3[0]-pt2[0])< EPSILON)
            {
          	opt      = 1;		/* u cst */
          	value    = pt3[0];    
		order    = bsp_surf1[0]->v_order;
		nb_poles = bsp_surf1[0]->v_num_poles ;
            } 
       	else if (fabs(pt3[1]-pt2[1])< EPSILON)
            {
          	opt      = 2;		/* v cst */
          	value    = pt3[1];
		order    = bsp_surf1[0]->u_order;
		nb_poles = bsp_surf1[0]->u_num_poles ;
            } 
        else 
            {
	  	/* printf("cannot close the curve with this bnd\n"); */
                opt = 0;
            }
#       ifdef DBG_BND
        printf("opt: %d,value: %lf\n",opt,value);
#       endif

        if(opt)
	 {
	   tst_plan = FALSE;
	   bnd_curve = NULL;
     	   BSalloccv(order, nb_poles,bsp_surf1[0]->rational, 0,&bnd_curve, &rc);
      	   if(rc != BSSUCC && rc!=BSNULL) 
       	       { 
              	 UI_status("ERROR Bad dynamic allocation ");
	         err_flag = TRUE;
		 goto wrapup;
	       }
    	   BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,bnd_curve);
	   if(rc != BSSUCC)
	    {	
		printf("ERROR  BSconstprcv: %d\n",rc);
		err_flag = TRUE;
		goto wrapup;
	    }

#          ifdef DBG_BND
	   printf("bnd_curve result ----------\n");
	   printf("nb_pole: %d\n",bnd_curve->num_poles);
	   for(i=0;i<bnd_curve->num_poles;i=i+1)
	       printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#          endif

#          ifdef DBG_BND
  	   printf("transform curve %d to param by project\n",i);
# 	   endif
	   numgrps = 0;
	   numpts  = NULL;
           pts     = NULL;
           par1    = NULL;

    /* curve is on surface, take normal to vector defined by 2 near pt on cv */

#          ifdef DBG_PROJ
    	   printf("curve is on surface, take normal to vector defined by 2 near pt on cv\n");
#          endif

    	   if(bsp_surf1[0]->planar == TRUE){
		BSsfnormal(bsp_surf1[0], dirvect, &rc);
        	if (rc!= BSSUCC){ 
                  	printf("surf_int, Bad BSsfnormal\n");
                  	err_flag = TRUE;
		  	goto wrapup;
        	}
    	   }
    	   else{
	   	middle   = (int)(bnd_curve->num_poles/2);
       		BSprptonsf(&rc,bsp_surf1[0], &bnd_curve->poles[3*middle],
		   	   &upar,&vpar,&onsurf);
       		if(rc != BSSUCC){
			printf("ERROR  BSprptonsf: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		}
		BSsfevaln(bsp_surf1[0], upar, vpar, 1, &num_normals,
		  	  base, dirvect, &rc);
		if (rc!= BSSUCC){ 
                  	printf("surf_int, Bad BSsfevaln\n");
                  	err_flag = TRUE;
		  	goto wrapup;
	   	}
	   }
#          ifdef DBG_PROJ
    	   printf("dirvect: %lf, %lf,%lf\n",dirvect[0], dirvect[1], dirvect[2]);
#          endif

           BSpjcvtsf(bnd_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
           if (rc!= BSSUCC ){ 
               	printf("surf_int, Bad projection on the surface: %d\n",rc);
               	err_flag = TRUE;
		goto wrapup;
            } 	
    	   if(numgrps > 1) {
		UI_status("ERROR transform pt to param give more than one gp");
                err_flag = TRUE;
		goto wrapup;
            } 	
	   nb_poles = numpts[0];
  	   if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve);bnd_curve =NULL;}
  	   stat = VDSfill_curve(nb_poles, NULL, par1[0], &bnd_curve);
  	   if(!(stat & 1)){
  	   	UI_status("ERROR VDSfill_curve");
  	   	err_flag = TRUE;
  	   	goto wrapup;
  	   }
           VDSfree(numgrps,&par1);
           VDSfree(numgrps,&pts);
           if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}
#          ifdef DBG_BND
	   printf("bnd_curve result param ----------\n");
	   printf("nb_pole: %d\n",bnd_curve->num_poles);
	   for(i=0;i<bnd_curve->num_poles;i=i+1)
	    printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#          endif

#          ifdef DBG_BND
           printf("intersect bnd avec curve[index_open[0]] ----------\n"); 
#          endif
  
           BScvcv_int(&rc, bnd_curve, curve[index_open[0]], &n_int0, &int_pts0, 
      		    &p_par10, &p_par20, &n_over, &end_pts, &over0, &over1);

    	   if(rc != BSSUCC || n_over > 0)
	    {
              	printf(" ERROR in BScvcv_int \n");
	      	err_flag = TRUE;
		goto wrapup;
	    }
           if(n_int0 < 1 )
            {
#             ifdef DBG_BND
              printf("bnd_curve & cv[index_open[0]] n'ont pas d'intersection\n");
#             endif
	      printf("this bnd doesn't intersect the curve \n");
	      if(over0     != NULL) {free(over0)   ; over0    = NULL;}
   	      if(over1     != NULL) {free(over1)   ; over1    = NULL;}
   	      if(end_pts   != NULL) {free(end_pts) ; end_pts  = NULL;}
              if(p_par10   != NULL) {free(p_par10) ; p_par10  = NULL;}
              if(p_par20   != NULL) {free(p_par20) ; p_par20  = NULL;}
   	      if(int_pts0  != NULL) {free(int_pts0); int_pts0 = NULL;}
            }
   	   else
	    {
#             ifdef DBG_BND
              printf("good intersection\n");
              printf("number of intersection: %d, de over: %d\n", n_int0, n_over);
              for(k=0; k<n_int0 ; k=k+1)
               {
                 printf("coord sur le sup: %lf, %lf, %lf\n",int_pts0[3*k],int_pts0[3*k+1],int_pts0[3*k+2]);
                 printf("param: %lf\n",   p_par10[k]);
                 printf("param: %lf\n\n", p_par20[k]);
               }
              printf("intersect bnd avec curve[index_open[1]] ----------\n"); 
#             endif

	      if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	      if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	      if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
  
              BScvcv_int(&rc, bnd_curve, curve[index_open[1]], &n_int1, &int_pts1, 
      		    &p_par11, &p_par21, &n_over, &end_pts, &over0, &over1);

    	      if(rc != BSSUCC || n_over > 0)
	       {
                 	printf(" ERROR in BScvcv_int \n");
	         	err_flag = TRUE;
			goto wrapup;
	       }
              if(n_int1 < 1 )
               {
#                ifdef DBG_BND
                 printf("bnd_curve & cv[index_open[1]] n'ont pas d'intersection\n");
#                endif
	         printf("this bnd doesn't intersect the curve\n");
                 if(p_par11 != NULL) {free(p_par11);  p_par11  = NULL;}
                 if(p_par21 != NULL) {free(p_par21);  p_par21  = NULL;}
   	         if(int_pts1!= NULL) {free(int_pts1); int_pts1 = NULL;}
               }
             else
	       {
#                ifdef DBG_BND
	         printf("bnd_curve intersect the 2 end curves\n");
                 printf("good intersection\n");
                 printf("number of intersection: %d, de over: %d\n", n_int1, n_over);
                 for(k=0; k<n_int1 ; k=k+1)
                  {
                    printf("coord sur le sup: %lf, %lf, %lf\n",int_pts1[3*k],int_pts1[3*k+1],int_pts1[3*k+2]);
                    printf("param: %lf\n",   p_par11[k]);
                    printf("param: %lf\n\n", p_par21[k]);
                  }
#                endif

	         found = 1;
	       }
   	     if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	     if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	     if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
  	    }
         }/* end opt !=0 */
    }
if( !found )
 {
   
# ifdef DBG_BND
  printf("\n try all bnd to close the curve\n\n");
# endif
   nb_time = 0;
   while(nb_time < 4)
    {

#       ifdef DBG_BND
        printf("nb_time: %d ................\n\n",nb_time);
#       endif

 	switch(nb_time)
         {
       		case 0:	opt      = 1;	/* u constant = 0. */
			value    = 0.;	
			order    = bsp_surf1[0]->v_order;
			nb_poles = bsp_surf1[0]->v_num_poles ;
			break;

		case 1:	opt      = 1;	/* u constant = 1. */
			value    = 1.;	
			order    = bsp_surf1[0]->v_order;
			nb_poles = bsp_surf1[0]->v_num_poles ;
			break;

		case 2:	opt      = 2;	/* v constant = 0. */
			value    = 0.;	
			order    = bsp_surf1[0]->u_order;
			nb_poles = bsp_surf1[0]->u_num_poles ;
			break;

		case 3:	opt      = 2;	/* v constant = 1. */
			value    = 1.;	
			order    = bsp_surf1[0]->u_order;
			nb_poles = bsp_surf1[0]->u_num_poles ;
			break;

		default: printf("no more boundary surface\n");
			 break;

         } /* end switch(nb_time) */
	tst_plan = FALSE;
	bnd_curve = NULL;
     	BSalloccv(order,nb_poles ,bsp_surf1[0]->rational, 0,  &bnd_curve, &rc);
      	if(rc != BSSUCC && rc!=BSNULL) 
       	  { 
              	UI_status("ERROR Bad dynamic allocation ");
	    	err_flag = TRUE;
		goto wrapup;
	  }
    	BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,bnd_curve);
	if(rc != BSSUCC)
	   {printf("ERROR  BSconstprcv: %d\n",rc);err_flag = TRUE;goto wrapup;}

#       ifdef DBG_BND
	printf("bnd_curve result ----------\n");
	printf("nb_pole: %d\n",bnd_curve->num_poles);
	for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#       endif

#       ifdef DBG_BND
  	printf("transform curve %d to param by project \n",i);
# 	endif
	numgrps = 0;
	numpts  = NULL;
        pts     = NULL;
        par1    = NULL;

   /* curve is on surface, take normal to vector defined by 2 near pt on cv */

#       ifdef DBG_PROJ
    	printf("curve is on surface, take normal to vector defined by 2 near pt on cv \n");
#       endif

    	if(bsp_surf1[0]->planar == TRUE){
		BSsfnormal(bsp_surf1[0], dirvect, &rc);
        	if (rc!= BSSUCC){ 
                  	printf("surf_int, Bad BSsfnormal\n");
                  	err_flag = TRUE;
		  	goto wrapup;
        	}
    	}
    	else{
		middle   = (int)(bnd_curve->num_poles/2);
       		BSprptonsf(&rc,bsp_surf1[0], &bnd_curve->poles[3*middle],
		   &upar,&vpar,&onsurf);
       		if(rc != BSSUCC){
			printf("ERROR  BSprptonsf: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		}
		BSsfevaln(bsp_surf1[0], upar, vpar, 1, &num_normals,
		  	  base, dirvect, &rc);
		if (rc!= BSSUCC){ 
                  	printf("surf_int, Bad BSsfevaln\n");
                  	err_flag = TRUE;
		  	goto wrapup;
		}
	}

#       ifdef DBG_PROJ
     	printf("dirvect: %lf, %lf,%lf\n",dirvect[0], dirvect[1], dirvect[2]);
#       endif

        BSpjcvtsf(bnd_curve, bsp_surf1[0], dirvect, &numgrps, &numpts,
                      &pts,&par1, &rc);
        if (rc!= BSSUCC ){ 
               	printf("surf_int, Bad projection on the surface: %d\n",rc);
               	err_flag = TRUE;
		goto wrapup;
        } 	
    	if(numgrps > 1) {
		UI_status("ERROR transform pt to param give more than one gp");
               	err_flag = TRUE;
		goto wrapup;
        } 	
	nb_poles = numpts[0];
  	if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve);bnd_curve =NULL;}
  	stat = VDSfill_curve(nb_poles, NULL, par1[0], &bnd_curve);
  	if(!(stat & 1)){
  		UI_status("ERROR VDSfill_curve");
  		err_flag = TRUE;
  		goto wrapup;
  	}
        VDSfree(numgrps,&par1);
        VDSfree(numgrps,&pts);
        if(numpts      != NULL) {free(numpts)     ; numpts=NULL;}

#       ifdef DBG_BND
	printf("bnd_curve result param ----------\n");
	printf("nb_pole: %d\n",bnd_curve->num_poles);
	for(i=0;i<bnd_curve->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",bnd_curve->poles[3*i],bnd_curve->poles[3*i+1],bnd_curve->poles[3*i+2]);
#       endif
        
#       ifdef DBG_BND
        printf("intersect bnd avec curve[index_open[0]] ----------\n"); 
#       endif
  
        BScvcv_int(&rc, bnd_curve, curve[index_open[0]], &n_int0, &int_pts0, 
      		    &p_par10, &p_par20, &n_over, &end_pts, &over0, &over1);

    	if(rc != BSSUCC || n_over > 0)
	  {
             printf(" ERROR in BScvcv_int \n");
	     err_flag = TRUE;
	     goto wrapup;
	  }
        if(n_int0 < 1 )
          {
#           ifdef DBG_BND
            printf("bnd_curve & cv[index_open[0]] n'ont pas d'intersection\n");
#           endif

   	    nb_time = nb_time + 1;
            if(p_par10   != NULL) {free(p_par10) ; p_par10  = NULL;}
            if(p_par20   != NULL) {free(p_par20) ; p_par20  = NULL;}
   	    if(int_pts0  != NULL) {free(int_pts0); int_pts0 = NULL;}
   	    if(over0     != NULL) {free(over0)   ; over0    = NULL;}
   	    if(over1     != NULL) {free(over1)   ; over1    = NULL;}
   	    if(end_pts   != NULL) {free(end_pts) ; end_pts  = NULL;}
   	    if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve); bnd_curve=NULL;}
	    continue;
          }
   	if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}

#       ifdef DBG_BND
        printf("intersect bnd avec curve[index_open[1]] ----------\n"); 
#       endif
  
        BScvcv_int(&rc, bnd_curve, curve[index_open[1]], &n_int1, &int_pts1, 
      		    &p_par11, &p_par21, &n_over, &end_pts, &over0, &over1);

    	if(rc != BSSUCC || n_over > 0)
	  {
             printf(" ERROR in BScvcv_int \n");
	     err_flag = TRUE;
	     goto wrapup;
	  }
        if(n_int1 < 1 )
          {
#           ifdef DBG_BND
            printf("bnd_curve & cv[index_open[1]] n'ont pas d'intersection\n");
#           endif

   	    nb_time = nb_time + 1;
            if(p_par11   != NULL) {free(p_par11) ; p_par11  = NULL;}
            if(p_par21   != NULL) {free(p_par21) ; p_par21  = NULL;}
   	    if(int_pts1  != NULL) {free(int_pts1); int_pts1 = NULL;}
   	    if(over0     != NULL) {free(over0)   ; over0    = NULL;}
   	    if(over1     != NULL) {free(over1)   ; over1    = NULL;}
   	    if(end_pts   != NULL) {free(end_pts) ; end_pts  = NULL;}
   	    if(bnd_curve != NULL){BSfreecv(&rc, bnd_curve); bnd_curve=NULL;}
	    continue;
          }
        else
	 {
#          ifdef DBG_BND
	   printf("bnd_curve intersect the 2 end curves\n");
#          endif

	   found = 1;
   	   if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	   if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	   if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
           break;
	 }
   	if(over0     != NULL) {free(over0)  ; over0   = NULL;}
   	if(over1     != NULL) {free(over1)  ; over1   = NULL;}
   	if(end_pts   != NULL) {free(end_pts); end_pts = NULL;}
        if(bnd_curve != NULL){BSfreecv(&rc, bnd_curve); bnd_curve=NULL;}
   	nb_time = nb_time + 1;
    }/* end while(nb_time) */


 }/* not found */
 if( !found)
    {
      	UI_status("ERROR: cannot close the curve ");
      	err_flag = TRUE;
	goto wrapup;
    }
  else 
   {
#       ifdef DBG_BND
 	printf("intersection with curve[index0] result -------\n");
    	printf("number of intersection: %d\n", n_int0);
    	for(k=0; k<n_int0 ; k=k+1)
     	    {
       		printf("coord sur le sup: %lf, %lf, %lf\n",int_pts0[3*k],int_pts0[3*k+1],int_pts0[3*k+2]);
       		printf("param: %lf\n",   p_par10[k]);
       		printf("param: %lf\n\n", p_par20[k]);
     	    }
	if(!(num_merge == 1 && !close_cv))
         {
	   printf("intersection with curve[index1] result -------\n");
    	   printf("number of intersection: %d\n", n_int1);
    	   for(k=0; k<n_int1 ; k=k+1)
     	    {
       		printf("coord sur le sup: %lf, %lf, %lf\n",int_pts1[3*k],int_pts1[3*k+1],int_pts1[3*k+2]);
       		printf("param: %lf\n",   p_par11[k]);
       		printf("param: %lf\n\n", p_par21[k]);
     	    }
	  }
    printf("end close_cv found: %d\n",found);
#   endif
   }

 } /* end try to close */



p_index = 0;
if (!two_intersect && !close_cv )
  {
   UI_status("Extract partof curves between intpts");
   for(i=0;i<num_merge ;i=i+1)
    {
      p_curve[p_index] = NULL;
      intpts1[0]	  = -1.;
      intpts1[1]	  = -1.;
      intpts1[2]	  = -1.;

      intpts2[0]	  = -1.;
      intpts2[1]	  = -1.;
      intpts2[2]	  = -1.;

#     ifdef DBG_PARTOF
      printf("EXTRACT THE GOOD PARTS ...........\n");
#     endif


#     ifdef DBG_PARTOF
      printf("Extract part of curve # %d\n",tab_cv[i]);
#     endif

      /* -------------------------------------------------------------------- 

         Compute of the direction parameter (for now simple case of none 
         close curve) 

         -------------------------------------------------------------------- */

      if(num_merge == 1 && !close_cv)
	{
#	 ifdef DBG_PARTOF
         printf("num_merge == 1 && !close_cv\n");
#	 endif
         par   = p_par20[0];
         parr1 = p_par20[1];
	  
	}
      else if(tab_cv[i] == index_open[0])
       {
#	 ifdef DBG_PARTOF
         printf("tab_cv[i] == index_open[0]\n");
#	 endif
         if(tab_cv[i] == tab_cv[0] && index_open[1] == tab_cv[num_merge - 1])
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] == tab_cv[0] && index_open[1] == tab_cv[num_merge - 1]\n");
#	    endif
	    par   = p_par1[1][0];
	    parr1 = p_par20[0];
	    intpts1[0] = int_pts0[0];
	    intpts1[1] = int_pts0[1];
	    intpts1[2] = int_pts0[2];

	    intpts2[0] = int_pts[1][0];
	    intpts2[1] = int_pts[1][1];
	    intpts2[2] = int_pts[1][2];
          }
         else if(tab_cv[i] == tab_cv[0] && index_open[1] != tab_cv[num_merge-1])
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] == 0 && index_open[1] != tab_cv[num_merge-1]\n");
#	    endif
	    par   = p_par2[0][0];
	    parr1 = p_par20[0];
	    intpts1[0] = int_pts0[0];
	    intpts1[1] = int_pts0[1];
	    intpts1[2] = int_pts0[2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
          }
         else
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] != tab_cv[0]\n");
#	    endif
            par   = p_par2[i][0];
	    parr1 = p_par20[0];
	    intpts1[0] = int_pts0[0];
	    intpts1[1] = int_pts0[1];
	    intpts1[2] = int_pts0[2];

	    intpts2[0] = int_pts[i][0];
	    intpts2[1] = int_pts[i][1];
	    intpts2[2] = int_pts[i][2];
          }
       }
      else if(tab_cv[i] == index_open[1])
       {
#	 ifdef DBG_PARTOF
         printf("tab_cv[i] == index_open[1]\n");
#	 endif
         if(tab_cv[i] == tab_cv[num_merge-1] && index_open[0] == tab_cv[0])
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] == tab_cv[num_merge-1] && index_open[0] == tab_cv[0]\n");
#	    endif
	    par   = p_par2[num_merge-1][0];
	    parr1 = p_par21[0];
	    intpts1[0] = int_pts1[0];
	    intpts1[1] = int_pts1[1];
	    intpts1[2] = int_pts1[2];

	    intpts2[0] = int_pts[num_merge-1][0];
	    intpts2[1] = int_pts[num_merge-1][1];
	    intpts2[2] = int_pts[num_merge-1][2];
          }
         else if(tab_cv[i] == tab_cv[num_merge-1] && index_open[0] != tab_cv[0])
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] == tab_cv[num_merge-1] && index_open[0] != tab_cv[0]\n");
#	    endif
            par   = p_par1[0][0];
	    parr1 = p_par21[0];
	    intpts1[0] = int_pts1[0];
	    intpts1[1] = int_pts1[1];
	    intpts1[2] = int_pts1[2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
          }
         else
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] != tab_cv[num_merge-1]\n");
#	    endif
            par   = p_par1[i+1][0];
	    parr1 = p_par21[0];
	    intpts1[0] = int_pts1[0];
	    intpts1[1] = int_pts1[1];
	    intpts1[2] = int_pts1[2];

	    intpts2[0] = int_pts[i+1][0];
	    intpts2[1] = int_pts[i+1][1];
	    intpts2[2] = int_pts[i+1][2];
          }
       }
      else
       {
#	 ifdef DBG_PARTOF
         printf("tab_cv[i] != index_open\n");
#	 endif
         if(tab_cv[i] == tab_cv[num_merge-1])
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] == tab_cv[num_merge-1]\n");
#	    endif
	    par   = p_par1[0][0];
	    parr1 = p_par2[num_merge-1][0];
	    intpts1[0] = int_pts[num_merge-1][0];
	    intpts1[1] = int_pts[num_merge-1][1];
	    intpts1[2] = int_pts[num_merge-1][2];

	    intpts2[0] = int_pts[0][0];
	    intpts2[1] = int_pts[0][1];
	    intpts2[2] = int_pts[0][2];
          }
         else
          {
#	    ifdef DBG_PARTOF
            printf("tab_cv[i] != tab_cv[num_merge-1]\n");
#	    endif
            par   = p_par1[i+1][0];
	    parr1 = p_par2[i][0];
	    intpts1[0] = int_pts[i][0];
	    intpts1[1] = int_pts[i][1];
	    intpts1[2] = int_pts[i][2];

	    intpts2[0] = int_pts[i+1][0];
	    intpts2[1] = int_pts[i+1][1];
	    intpts2[2] = int_pts[i+1][2];
          }
       }



      d_par = (parr1 + par)/2.;
      if(parr1 > par) 	rev = 1;
      else		rev = 0;
      order = curve[tab_cv[i]]->order;
      BSalloccv(order, curve[tab_cv[i]]->num_poles + 2 * order - 1, 
		curve[tab_cv[i]]->rational,curve[tab_cv[i]]->num_boundaries, 
                &p_curve[p_index], &rc);
      if(rc != BSSUCC && rc!=BSNULL) 
       { 
        printf("surf_int, Bad allocation for the curves\n");
        for(k=0; k<num_ent-2; k=k+1)
         {
	  if(curve[k]!=NULL)
            {
               BSfreecv(&rc, curve[k]); 
               curve[k] = NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                {
			printf("BSfreecv(curve) fail\n");
			err_flag = TRUE;
			goto wrapup;
		}
            }
   	  if(int_pts[k]!= NULL) {free(int_pts[k]); int_pts[k] = NULL;}
          if(p_par1[k] != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
          if(p_par2[k] != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
         }
        err_flag = TRUE;
	goto wrapup;
       }
#     ifdef DBG_PARTOF
      printf("BSpartofcv de curve %d\n",tab_cv[i]);
      printf("parms: %lf, %lf, %lf\n",parr1, d_par, par);
#     endif

      BSpartofcv(&rc, curve[tab_cv[i]], parr1, d_par, par, p_curve[p_index]);
      if(rc != BSSUCC) 
       { 
        printf("surf_int, Bad extraction of the part of curve # %d\n", tab_cv[i]);
        if(p_curve[p_index]!=NULL) 
         {
          BSfreecv(&rc, p_curve[p_index]); 
          p_curve[p_index]= NULL;
          if (rc !=BSSUCC && rc!=BSNULL) 
             {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
         }
        err_flag = TRUE;
	goto wrapup;
       }
      /* don't free p_par1[0] because needed for partofcv (num_ent-3) */
      if(i!= 0 && p_par1[i]   != NULL) {free(p_par1[i]) ; p_par1[i]  = NULL;}
      if(i!= 0 && int_pts[i]  != NULL) {free(int_pts[i]); int_pts[i] = NULL;}
      if(p_par2[i]   != NULL)          {free(p_par2[i]) ; p_par2[i]  = NULL;}
      if(i>1)
       {
        /* previous curve to keep curve[i-1] at the next step */
        if(curve[tab_cv[i-1]]!=NULL  ) 
         {
           BSfreecv(&rc, curve[tab_cv[i-1]]); 
           curve[tab_cv[i-1]]= NULL;
           if (rc !=BSSUCC && rc!=BSNULL) 
            {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
         }
       }
      if(rev)
       {
        BSrev_cv(&rc, p_curve[p_index]);
        if(rc != BSSUCC) 
         { 
          printf("surf_int, ERROR cannot reverse the curve\n");
          if(p_curve[p_index]!=NULL)
           {
             BSfreecv(&rc, p_curve[p_index]); 
             p_curve[p_index] = NULL;
             if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
           }
          err_flag = TRUE;
	  goto wrapup;
         }
       }
#     ifdef DBG_PARTOF   

      printf("\n\nBSpartofcv de curve %d ......\n",i);
      printf("intpts1: %lf, %lf, %lf\n",intpts1[0],intpts1[1],intpts1[2]);
      printf("intpts2: %lf, %lf, %lf\n",intpts2[0],intpts2[1],intpts2[2]);
      printf("partofcv result %d\n",p_index);
      printf("pole begin : %lf, %lf, %lf\n", p_curve[p_index]->poles[0],p_curve[p_index]->poles[1],
		p_curve[p_index]->poles[2]);     
      printf("pole fin: %lf, %lf, %lf\n", p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3],
		p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3+1],
		p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3+2]);
#     endif
#     ifdef DBG_PARTOF
      printf("\n");
      printf("p_index %d\n",p_index);
            if(p_curve[p_index]->rational)
            {
              for(k=0;k< p_curve[p_index]->num_poles ;k=k+1)
               printf("weight: %lf\n", p_curve[p_index]->weights[k]);
            }
#     endif
      if(p_curve[p_index]->rational)
          {
            for(k=0;k<p_curve[p_index]->num_poles;k=k+1)
	     {
		p_curve[p_index]->poles[3*k]   = p_curve[p_index]->poles[3*k]/
						p_curve[p_index]->weights[k];
		p_curve[p_index]->poles[3*k+1] = p_curve[p_index]->poles[3*k+1]/
						p_curve[p_index]->weights[k];
		p_curve[p_index]->poles[3*k+2] = p_curve[p_index]->poles[3*k+2]/
						p_curve[p_index]->weights[k];
	     }
	    p_curve[p_index]->rational = 0;
	    if(p_curve[p_index]->weights)
	      {
		free(p_curve[p_index]->weights);
		p_curve[p_index]->weights  = NULL;
	      }
#            ifdef DBG_PARTOF
             printf("\n");
             printf("partofcv result apres /weight %d\n",p_index);
             for(k=0;k<p_curve[p_index]->num_poles ;k=k+1)
             printf("partof the curves: %lf, %lf, %lf\n", p_curve[p_index]->poles[3*k], p_curve[p_index]->poles[3*k+1], p_curve[p_index]->poles[3*k+2]);
#            endif
          }

      if(fabs(intpts1[0]+1.) > EPSILON && fabs(intpts1[1]+1.) > EPSILON && 
					fabs(intpts1[2]+1.) > EPSILON )
       {
        if(fabs(p_curve[p_index]->poles[0]-intpts1[0]) > EPSILON )
	 	p_curve[p_index]->poles[0]= intpts1[0];
      	if(fabs(p_curve[p_index]->poles[1] - intpts1[1]) > EPSILON)
		p_curve[p_index]->poles[1]= intpts1[1];
      	if(fabs(p_curve[p_index]->poles[2] - intpts1[2]) > EPSILON)
	 	p_curve[p_index]->poles[2]= intpts1[2];
       }
      if(fabs(intpts2[0]+1.) > EPSILON && fabs(intpts2[1]+1.) > EPSILON && 
					fabs(intpts2[2]+1.) > EPSILON )
       {
        if(fabs(p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3]-intpts2[0]) > EPSILON )
	 	p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3]= intpts2[0];
      	if(fabs(p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3+1] - intpts2[1]) > EPSILON)
		p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3+1]= intpts2[1];
      	if(fabs(p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3+2] - intpts2[2]) > EPSILON)
	 	p_curve[p_index]->poles[(p_curve[p_index]->num_poles-1)*3+2]= intpts2[2];
       }
     p_index = p_index + 1;

    }/* end boucle i */
   if(p_par1[0]   != NULL) {free(p_par1[0]) ; p_par1[0]  = NULL;}
   if(int_pts[0]  != NULL) {free(int_pts[0]); int_pts[0] = NULL;}



if ((elem_type[0] != PLAN && !two_intersect ) && 
                  (open_cv || (num_merge == 1 && !close_cv)) )
{
#  ifdef DBG_PARTOF
   printf("\n\nfill last p_curve with partofcv de bnd_curve\n\n");
#  endif

   p_curve[p_index] = NULL;
   par   = p_par10[0];
   if(num_merge == 1 && !close_cv) parr1 = p_par10[1];
   else 			   parr1 = p_par11[0];
   d_par = (parr1 + par)/2.;
  if(parr1 > par) 	rev = 1;
   else			rev = 0;
   order = bnd_curve->order;
   BSalloccv(order, bnd_curve->num_poles + 2 * order - 1, bnd_curve->rational,
                bnd_curve->num_boundaries, 
                &p_curve[p_index], &rc);
   if(rc != BSSUCC && rc!=BSNULL) 
       { 
        printf("surf_int, Bad allocation for the curves\n");
	if(bnd_curve!=NULL)
            {
               BSfreecv(&rc, bnd_curve); 
               bnd_curve = NULL;
	       if (rc !=BSSUCC && rc!=BSNULL) 
                 {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
            }
   	  if(int_pts0!= NULL) {free(int_pts0); int_pts0 = NULL;}
          if(p_par10 != NULL) {free(p_par10) ; p_par10  = NULL;}
          if(p_par20 != NULL) {free(p_par20) ; p_par20  = NULL;}
   	  if(int_pts1!= NULL) {free(int_pts1); int_pts1 = NULL;}
          if(p_par11 != NULL) {free(p_par11) ; p_par11  = NULL;}
          if(p_par21 != NULL) {free(p_par21) ; p_par21  = NULL;}
          err_flag = TRUE;
	  goto wrapup;
       }

#     ifdef DBG_PARTOF
      printf("parms: %lf, %lf, %lf\n",parr1, d_par, par);
#     endif

      BSpartofcv(&rc, bnd_curve, parr1, d_par, par, p_curve[p_index]);
      if(rc != BSSUCC) 
       { 
        printf("surf_int, Bad extraction of the part of curve # %d\n", i);
        if(p_curve[p_index]!=NULL) 
         {
           BSfreecv(&rc, p_curve[p_index]); 
           p_curve[p_index]= NULL;
           if (rc !=BSSUCC && rc!=BSNULL) 
             {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
         }
        err_flag = TRUE;
	goto wrapup;
       }
      if(rev)
       {
        BSrev_cv(&rc, p_curve[p_index]);
        if(rc != BSSUCC) 
         { 
          printf("surf_int, ERROR cannot reverse the curve\n");
          if(p_curve[p_index]!=NULL)
           {
             BSfreecv(&rc, p_curve[p_index]); 
             p_curve[p_index] = NULL;
             if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
           }
          err_flag = TRUE;
	  goto wrapup;
         }
       }

#     ifdef DBG_PARTOF
      printf("\n");
      printf("partofcv result %d\n",p_index);
            if(p_curve[p_index]->rational)
            {
              for(k=0;k< p_curve[p_index]->num_poles ;k=k+1)
               printf("weight: %lf\n", p_curve[p_index]->weights[k]);
            }
      for(k=0;k<p_curve[p_index]->num_poles ;k=k+1)
      printf("partof the curves: %lf, %lf, %lf\n", p_curve[p_index]->poles[3*k], p_curve[p_index]->poles[3*k+1], p_curve[p_index]->poles[3*k+2]);
#     endif

   if(bnd_curve!=NULL)
     {
        BSfreecv(&rc, bnd_curve); 
        bnd_curve = NULL;
	if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
     }
   p_index = p_index + 1;
   if(int_pts0!= NULL) {free(int_pts0); int_pts0 = NULL;}
   if(p_par10 != NULL) {free(p_par10) ; p_par10  = NULL;}
   if(p_par20 != NULL) {free(p_par20) ; p_par20  = NULL;}
   if(int_pts1!= NULL) {free(int_pts1); int_pts1 = NULL;}
   if(p_par11 != NULL) {free(p_par11) ; p_par11  = NULL;}
   if(p_par21 != NULL) {free(p_par21) ; p_par21  = NULL;}

}/* end partofcv  bnd_curve */
   for(k=0; k<num_ent-2; k=k+1)
    {
     if(curve[k]!=NULL)
      {
        BSfreecv(&rc, curve[k]); 
        curve[k] = NULL;
        if (rc !=BSSUCC && rc!=BSNULL) 
                {printf("BSfreecv(curve) fail\n");err_flag = TRUE;goto wrapup;}
      }
     if(p_par1[k]  != NULL) {free(p_par1[k]) ; p_par1[k]  = NULL;}
     if(p_par2[k]  != NULL) {free(p_par2[k]) ; p_par2[k]  = NULL;}
     if(int_pts[k] != NULL) {free(int_pts[k]); int_pts[k] = NULL;}
    }

}/* end extract part of curve */

   if(p_index > 0) num_merge = p_index ;



      /* -------------------------------------------------------------------- 
  
  	 if more that one curve, put the curves in consecutive order and 
	 verify if it makes a unique groupe or not.

         -------------------------------------------------------------------- */

if (num_merge > 1)
{
  stat = VDSorder_gpe(num_merge, &p_curve[0], &nb_gpe, &nb_cvgp, &array);
  if(!(stat & 1)){
  	UI_status("ERROR VDSorder_gpe\n");
  	err_flag = TRUE;
  	goto wrapup;
  }

# ifdef DBG_PARTOF
  printf("nb_gpe: %d\n",nb_gpe);
  for(i=0;i<nb_gpe;i=i+1)
	   {
		printf("nb_cvgp[%d]: %d\n",i,nb_cvgp[i]);
		for(k=0;k<nb_cvgp[i];k=k+1)
		 {
			printf("array[k]->num_poles: %d\n",array[k]->num_poles);
			for(j=0;j<array[k]->num_poles;j=j+1)
			  printf("order array: %lf, %lf, %lf\n",array[k]->poles[3*j],
				array[k]->poles[3*j+1],array[k]->poles[3*j+2]);
		 }
	   }
# endif

  if(nb_gpe > 1) { 
	UI_status(" ERROR, curves not contiguous "); 
	err_flag = TRUE;
	goto wrapup;
  }
}


      /* -------------------------------------------------------------------- 
  
  	 if support is surface transform p_curve to points and not param 

         -------------------------------------------------------------------- */

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &MOD_ENV;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.class_attr	= NULL;
  cst.name		= NULL;

if(close_cv == 1)
{
  nb_gpe = 1;
  nb_cvgp = NULL;
  nb_cvgp = (int *)malloc(1 * sizeof (int ));
  if(nb_cvgp == NULL)
    {
        UI_status("ERROR Bad dynamic allocation ");
        err_flag = TRUE;
	goto wrapup;
    }
  nb_cvgp[0] = 1;
  array = NULL;
  array = (struct IGRbsp_curve **)
                malloc(1 * sizeof (struct IGRbsp_curve *));
  if(array == NULL)
    {
        UI_status("ERROR Bad dynamic allocation ");
        err_flag = TRUE;
   	goto wrapup;
    }
  array[0] = curve[i_onecv];
}


if(elem_type[0] != PLAN) 
{
#      ifdef DBG_PARTSF
       printf(" ---- get the range encompassing the bnd curves ---- \n");
#      endif
       UI_status("Extract partof surface encompassing the curve");

	u[0] = 1.0; u[1] = 1.0;
	q[0] = 0.0; q[1] = 0.0;
         
 	for(i=0;i<nb_cvgp[0];i=i+1)
 	{
  	  if(array[i] != NULL)
   	   {
	     l = 0;
      	     for(k=0;k<array[i]->num_poles ;k=k+1){
		if( array[i]->poles[l]   < u[0] ) u[0] = array[i]->poles[l];
		if( array[i]->poles[l]   > q[0] ) q[0] = array[i]->poles[l];
		if( array[i]->poles[l+1] < u[1] ) u[1] = array[i]->poles[l+1];
		if( array[i]->poles[l+1] > q[1] ) q[1] = array[i]->poles[l+1];

		l = l + 3;
	      } 
           }
        }
	#if DBG_PARTSF
		printf("u[0] = %lf, q[0] = %lf\n",u[0],q[0]);
		printf("u[1] = %lf, q[1] = %lf\n",u[1],q[1]);
	#endif

      /* ---- find the lower and upper knots containing this range --- */
      /* ---- evaluate the new parameters ---- */
      /* u[0] = umin, u[1] = vmin, q[0] = umax, q[1] = vmax */


	l = bsp_surf1[0]->u_num_knots-1;
	us[0] = u[0];
	us[1] = u[1];
	qs[0] = q[0];
	qs[1] = q[1];
	
	for(k=0;k<l;k=k+1)
		if( ( u[0] > bsp_surf1[0]->u_knots[k] ) &&
		    ( u[0] < bsp_surf1[0]->u_knots[k+1] )  ){
			us[0] = bsp_surf1[0]->u_knots[k];
			break;
		} 

	for(k=0;k<l;k=k+1)
		if( ( q[0] > bsp_surf1[0]->u_knots[k] ) &&
		    ( q[0] < bsp_surf1[0]->u_knots[k+1] )  ){
			qs[0] = bsp_surf1[0]->u_knots[k+1];
			break;
		}
	#ifdef DBG_PARTSF
                printf("us[0] = %lf, qs[0] = %lf\n",us[0],qs[0]);
	#endif
 
	if( fabs(u[0]-us[0] ) > EPSILON ) u[0] = 0.9*u[0] + 0.1*us[0];
	if( fabs(q[0]-qs[0] ) > EPSILON ) q[0] = 0.9*q[0] + 0.1*qs[0];

	#ifdef DBG_PARTSF
                printf("u[0] = %lf, q[0] = %lf\n",u[0],q[0]);
	#endif

        if(fabs(q[0]-u[0]) < EPSILON)
           {
             UI_status("ERROR: degenerated curve, cannot create boundary");
             err_flag = TRUE;
	     goto wrapup;
           }

	l = bsp_surf1[0]->v_num_knots - 1;
 
	for(k=0;k<l;k=k+1)
		if( ( u[1] > bsp_surf1[0]->v_knots[k] ) &&
		    ( u[1] < bsp_surf1[0]->v_knots[k+1] )  ){
			us[1] = bsp_surf1[0]->v_knots[k];
			break;
		} 
	for(k=0;k<l;k=k+1)
		if( ( q[1] > bsp_surf1[0]->v_knots[k] ) &&
		    ( q[1] < bsp_surf1[0]->v_knots[k+1] )  ){
			qs[1] = bsp_surf1[0]->v_knots[k+1];
			break;
		}
	#ifdef DBG_PARTSF
		printf("us[1] = %lf, qs[1] = %lf\n",us[1],qs[1]);
	#endif

	if( fabs(u[1]-us[1] ) > EPSILON ) u[1] = 0.9*u[1] + 0.1*us[1];
	if( fabs(q[1]-qs[1] ) > EPSILON ) q[1] = 0.9*q[1] + 0.1*qs[1];

        if(fabs(q[1]-u[1]) < EPSILON)
           {
             UI_status("ERROR: degenerated curve, cannot create boundary");
             err_flag = TRUE;
	     goto wrapup;
           }

	#ifdef DBG_PARTSF
		printf("-partofsf- u[0] = %lf, q[0] = %lf\n",u[0], q[0]);
		printf("-partofsf- u[1] = %lf, q[1] = %lf\n",u[1], q[1]);
	#endif


      parr2[0] = u[0] * 0.5 + q[0] * 0.5 ;
      parr2[1] = u[1] * 0.5 + q[1] * 0.5 ;


      bsp_surf1[0]->num_boundaries = 0 ;
      bsp_surf1[0]->bdrys          = NULL;
      bsp_surf1[0]->on_off	   = FALSE;
      cst.geometry		   = (char *) bsp_surf1[0];

    split_ind = 2; /* split in u and v direction */

    wind_loopset = TRUE;  /* Relevant boundaries should be extracted 	*/
    msg_status   = TRUE;  /* Display status when computing 		*/

    stat = ci$send(msg = message EMSgenbs.EMpartsf(&rc, &cst, &u[0], &parr2[0],
						   &q[0], split_ind, &GRid_list.objid, 
						   &par_surf, wind_loopset, 
						   msg_status),
		    verbose = VERBOSE,
        	    targetid  = SUR[0].objid,
 	            targetos  = SUR[0].osnum );
    as$status(sts=stat); 
    if (!(rc&stat&1)){ 
        	printf("ERROR in EMSgenbs.EMpartsf\n" ); 
		err_flag = TRUE;
		goto wrapup; 
    } 

  GRid_list.osnum = MOD_ENV.md_id.osnum;
/* find the center of this array of planar (u,v) curves */

    BSctrarplcv(nb_cvgp[0],array,center, &area ,&rc);
    if (rc!= BSSUCC)
             { 
               	printf("error  BSctrarplcv\n");
               	err_flag = TRUE;
		goto wrapup;
             }

# ifdef DBG_CENTER
  printf("center on bsp_surf: %lf, %lf, %lf\n",center[0],center[1],center[2]);
# endif

   BSsfptseval(bsp_surf1[0],1,&center[0],center_pt,&rc);
     	if (rc!= BSSUCC)
             { 
               	printf("error  BSsfptseval\n");
               	err_flag = TRUE;
		goto wrapup;
             }


   BSprptonsf(&rc,par_surf,center_pt,&upar,&vpar,&onsurf);
   if(rc != BSSUCC )
       {printf("ERROR  BSprptonsf: %d\n",rc);err_flag = TRUE;goto wrapup;}
   

# ifdef DBG_CENTER
  printf("center on par_surf: %lf, %lf\n",upar,vpar);
  printf("transform curve param to pts\n");
  printf("nb_cvgp[0]: %d\n",nb_cvgp[0]);
# endif

 for(i=0;i<nb_cvgp[0];i=i+1)
 {
  if(array[i] != NULL)
   {
#	ifdef DBG_CENTER
	printf("array non null : %d\n",i);
#	endif

        eval_pts = NULL;
        param    = NULL;
	param 	 = (IGRdouble *) malloc(2*array[i]->num_poles*sizeof(double));
     	if( param == NULL){
              	UI_status("ERROR Bad dynamic allocation ");
     		err_flag = TRUE;
     		goto wrapup;
     	}
      	for(k=0;k<array[i]->num_poles ;k=k+1)
		{
		  param[2*k]   = array[i]->poles[3*k];
		  param[2*k+1] = array[i]->poles[3*k+1];
		}
#	ifdef DBG_CENTER
      	for(k=0;k<array[i]->num_poles ;k=k+1)
        printf("param: %lf, %lf\n",param[2*k] ,param[2*k+1]);
#	endif

	eval_pts = (IGRdouble *) malloc(3*array[i]->num_poles*sizeof(double));
     	if( eval_pts == NULL){              		
     		UI_status("ERROR Bad dynamic allocation ");
		err_flag = TRUE;
		goto wrapup;
	}

#	ifdef DBG_CENTER
	printf("BSsfptseval\n");
#	endif

     	BSsfptseval(bsp_surf1[0],array[i]->num_poles,param,
			eval_pts,&rc);
     	if (rc!= BSSUCC)
             { 
               	printf("error  BSsfptseval\n");
               	err_flag = TRUE;
		goto wrapup;
             }
        else
	     {

#		ifdef DBG_CENTER
		printf("array = eval_pts\n");
#		endif
      		for(k=0;k<3*array[i]->num_poles ;k=k+1)
		  array[i]->poles[k] = eval_pts[k];
		if (eval_pts != NULL){free(eval_pts);eval_pts = NULL;}
		if (param != NULL)   {free(param)   ;param    = NULL;}

#  		ifdef DBG_CENTER
                printf("curve %d ............\n",i);
      		for(k=0;k<array[i]->num_poles ;k=k+1)
      		printf("eval poles : %lf, %lf, %lf\n", array[i]->poles[3*k], array[i]->poles[3*k+1], array[i]->poles[3*k+2]);
#		endif                
             }

   }/*if(array[i] != NULL)*/
 }/* for(i=0 to nb_cvgp[0]) */

}/*if(elem_type[0] != PLAN) */


for(i=0;i<nb_cvgp[0];i=i+1)
{
 if(array[i] != NULL)
  {
#  ifdef DEBUG
   printf("construct the curve: %d\n",i);
#  endif

  GRid_cv[i].osnum = act_env.md_id.osnum;
  GRid_cv[i].objid = NULL_OBJID;

  init_cnst_list();
  get_symb();

  dis.color		= cnst_list.color;
  dis.weight		= cnst_list.weight;
  dis.style		= cnst_list.style;

  cst.msg		= &msg;
  cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
  cst.display		= &dis;
  cst.env_info		= &act_env;
  cst.newflag		= 0;
  cst.level		= cnst_list.level;
  cst.class_attr	= NULL;
  cst.name		= NULL;

    	
  cst.geometry	= (char *) array[i];


  stat = ci$send(msg = message GRbcsubbc.GRconstruct( &cst),
		    verbose = VERBOSE,
		    construct = 1,
        	    targetid  = GRid_cv[i].objid,
 	            targetos  = GRid_cv[i].osnum );
   as$status(sts=stat); 
#  ifdef DEBUG
   printf("GRconstruct stat = %ld, GRid_cv = %d, %d\n",stat, GRid_cv[i].objid,
                                              GRid_cv[i].osnum);
#  endif
   if (!(stat&1)){ 
        	printf("ERROR in GRbcsubbc.GRconstruct\n" ); 
		err_flag = TRUE;
		goto wrapup; 
   } 
  
  entries[i].located_obj = GRid_cv[i];
  entries[i].module_info = act_env;
  if (!(stat&1)) 
   {
    UI_status("ERROR: EMSsubbs.GRconstruct failed");
    GRid_cv[i].objid = NULL_OBJID;
    err_flag = TRUE;
    goto wrapup;
   }
 }/* array[i] != NULL */
}/* for(i=0 to nb_cvgp[0] */

for(i=0;i<nb_cvgp[0];i=i+1)
{
  if(p_curve[i]!=NULL) 
              {
                BSfreecv(&rc, p_curve[i]); 
                p_curve[i]= NULL;
	        if (rc !=BSSUCC && rc!=BSNULL) 
                 {
			printf("BSfreecv(curve) fail rc: %d\n",rc);
			err_flag = TRUE;
			goto wrapup;
		 }
              }
}

if(nb_cvgp[0] == 1)
  comp_id = GRid_cv[0];
else
{
#ifdef DEBUG
 printf("construct the composite curve\n");
#endif

 comp_id.osnum = act_env.md_id.osnum;
 comp_id.objid = NULL_OBJID;

 rotten_one = 0;
 stat = ci$send(msg = message GRcompcurve.EMmakecomp( &msg, &act_env,
			nb_cvgp[0],entries, &rotten_one),
		verbose = VERBOSE,
		construct = 1,
        	    targetid  = comp_id.objid,
 	            targetos  = comp_id.osnum );
 as$status(sts = stat);
 if (!(stat&1)) 
   {
    UI_status(" GRcompcurve.EMmakecomp failed");
    comp_id.objid = NULL_OBJID;
    err_flag = TRUE;
    goto wrapup;
   }

#ifdef DEBUG
 printf("GRconstruct stat = %ld, comp_id = %d, %d\n",stat, comp_id.objid,
                                              comp_id.osnum);
#endif
 }/* else de nb_cvgp[0] == 1*/


  /* CREATE THE GRAPHIC OBJECT */


  if(elem_type[0] == PLAN) 
   {

    init_cnst_list();
    get_symb();

    dis.color		= cnst_list.color;
    dis.weight		= cnst_list.weight;
    dis.style		= cnst_list.style;

    cst.msg		= &msg;
    cst.properties	= GRIS_LOCATABLE | GRIS_DISPLAYABLE;
    cst.display		= &dis;
    cst.env_info	= &MOD_ENV;
    cst.newflag		= 0;
    cst.level		= cnst_list.level;
    cst.class_attr	= NULL;
    cst.name		= NULL;

    cst.geometry	= NULL;

    /*|plan support construct*/
    for(i=0;i<3;i=i+1) q_pl[i] =  plane[0].point[i] + 10*plane[0].normal[i];


#   ifdef DEBUG 
    printf("\n");
    printf("vector: %lf, %lf, %lf\n",q_pl[0], q_pl[1], q_pl[2]);
#   endif 
    UI_status("Construct Plane on the composite curve");
    GRid_list.osnum = MOD_ENV.md_id.osnum;

    test_degeneracy   = TRUE;
    construct_loopset = TRUE;		
    final_curve.located_obj = comp_id;
    final_curve.module_info = act_env;
    
    stat = ci$send( msg       = message EMSplane.EMplane_of_curve(&msg, &cst,
				&final_curve, NULL, NULL, test_degeneracy,
						construct_loopset, q_pl, NULL),
		    verbose = VERBOSE,
        	    targetid  = GRid_list.objid,
 	            targetos  = GRid_list.osnum,
                    construct = 1 );
    as$status(sts = stat);
    if (!(msg&stat&1)){ 
        printf("ERROR EMSplane.EMplane_of_curve\n");
    	err_flag = TRUE;
    	goto wrapup; 
    } 
    bndpl.point = &bnd[0];
    bndpl.normal= &bnd[3];

    stat = ci$send (msg = message GRvg.GRdetplane(&msg,
                        &MOD_ENV.md_env.matrix_type,
                        MOD_ENV.md_env.matrix,
                        &bndpl),
                           targetid = GRid_list.objid,
                           targetos = GRid_list.osnum );
    as$status(sts = stat);
    if(!(stat & msg & 1)){
        printf("ERROR in GRvg.GRdetplane\n" );
    	err_flag = TRUE;
    	goto wrapup; 
    }
    
    dotp =    BSdotp(&rc,bndpl.normal,plane[0].normal);
    
    if( dotp < 0  ){
    	stat = ci$send(msg = message EMSsubbs.EMset_props(&msg,
                         (unsigned char) EMSIS_NRML_REVERSED, (char) EMS_O_TOGGLE),
                        targetid = GRid_list.objid,
                        targetos = GRid_list.osnum);
    	as$status(sts = stat);
    	if(!(msg&stat&1)){
        	printf("ERROR in EMSsubbs.EMset_props\n" );
    		err_flag = TRUE;
    		goto wrapup; 
        }
    	
    }
    goto wrapup;
   }
 else
   {
     /* line is the isocurve (v constant) from the center */

     line = NULL;
     opt = 2;
     value = center[1];
     BSalloccv(bsp_surf1[0]->u_order, bsp_surf1[0]->u_num_poles, 
		 bsp_surf1[0]->rational, 0,  &line, &rc);
     if(rc != BSSUCC && rc!=BSNULL) 
           { 
            UI_status("ERROR Bad dynamic allocation ");
            err_flag = TRUE;
	    goto wrapup;
           }
     BSconstprcv(&rc,bsp_surf1[0],&opt,&value,&tst_plan,line);
     if(rc != BSSUCC){printf("ERROR  BSconstprcv: %d\n",rc);err_flag = TRUE;goto wrapup;}
     part_line = NULL;
     order = line->order;
     BSalloccv(order, line->num_poles + 2 * order - 1, line->rational,
                line->num_boundaries, 
                &part_line, &rc);
     if(rc != BSSUCC && rc!=BSNULL) { 
            UI_status("ERROR Bad dynamic allocation ");
	    err_flag = TRUE;
	    goto wrapup;
     }
     parr1 = center[0];
     par = 1;
     d_par = (parr1 + par)/2.;
     BSpartofcv(&rc, line, parr1, d_par, par, part_line);
     if(rc != BSSUCC) { 
        printf("surf_int, Bad BSpartofcv\n");
	err_flag = TRUE;
	goto wrapup;
     }
     if(line      != NULL) {BSfreecv(&rc, line)     ;line       = NULL;}

#    ifdef   DBG_CENTER  
     printf("line result ----------\n");
     printf("nb_pole: %d\n",part_line->num_poles);
     for(i=0;i<part_line->num_poles;i=i+1)
	  printf("poles: %lf, %lf, %lf\n",	part_line->poles[3*i],
						part_line->poles[3*i+1],
						part_line->poles[3*i+2]);
#    endif 

/*   take geom of the composite to intersect with line in order to know if
     upar, vpar is inside area or not */


    stat = ci$send(msg = message GRvg.GRgetsize(&msg, 
    					&act_env.md_env.matrix_type, 
    					act_env.md_env.matrix, 
					&size ),
	  	   targetid = comp_id.objid,
	  	   targetos = comp_id.osnum );
    as$status(sts = stat);	                
    if (!(msg&stat&1)){ 
    	printf("ERROR GRvg.GRgetsize\n");
    	err_flag = TRUE;
    	goto wrapup; 
    } 
    comp_cv = NULL;
    comp_cv = (struct IGRbsp_curve *) malloc(size);
    if(comp_cv == NULL) 
     {
      UI_status("ERROR Bad dynamic allocation ");
      err_flag = TRUE;
      goto wrapup;
     }
     
    stat = ci$send(msg = message GRvg.GRgetgeom(&msg, 
    					&act_env.md_env.matrix_type, 
                                  	act_env.md_env.matrix, 
                                  	(char *) comp_cv),
	  	    targetid = comp_id.objid,
	  	    targetos = comp_id.osnum );
    as$status(sts = stat);
    if (!(msg&stat&1)){ 
		printf("ERROR  GRvg.GRgetfeom\n");
		err_flag = TRUE;
		goto wrapup;
    }
     	p_par10  = NULL;
     	p_par20  = NULL;
     	int_pts0 = NULL;
     	int_pts1 = NULL;
     	over0    = NULL;
     	over1    = NULL;
     	end_pts  = NULL;

     BSmdistcvcv(part_line,comp_cv, &n_int0, &p_par10, &p_par20 , &int_pts0,
		&int_pts1, &dist1, &rc);

     if(rc != BSSUCC ){
             printf(" ERROR in BSmdistcvcv\n");
	     err_flag = TRUE;
	     goto wrapup;
     }


#    ifdef   DBG_CENTER  
     printf("dist: %lf\n",dist1);
     printf("nb: %d\n",n_int0);
     for(k=0; k<n_int0;k=k+1) {
	printf("p_par10: %lf, p_par20: %lf\n",p_par10[k],p_par20[k]);
	printf("pts10: %lf, %lf, %lf\n",int_pts0[3*k],int_pts0[3*k+1],int_pts0[3*k+2]);
	printf("pts20: %lf, %lf, %lf\n",int_pts1[3*k],int_pts1[3*k+1],int_pts1[3*k+2]);

     }
#    endif

     if(dist1 > 2*cht_tol ) n_int0 = 0;
     if(n_int0 % 2 == 0) onsurf = FALSE; 
     else 		 onsurf = TRUE;  
     if(comp_cv != NULL) {free( comp_cv)        ;comp_cv = NULL;}
     if(line != NULL)    {BSfreecv(&rc, line)   ;line    = NULL;}
     if(part_line != NULL)    {BSfreecv(&rc, part_line)   ;part_line    = NULL;}

     area_pt[0] = upar;
     area_pt[1] = vpar;
     map_options = EMMapBnd_WantStatMsg | EMMapBnd_WantBadCurves |
               EMMapBnd_StrokeIfNeeded;

     imp_options = EMImpBnd_NoStateTree | EMImpBnd_WantStatMsg;
     number_of_points = 0;
     number_of_bad_curves = 0;
     points = NULL;
     final_curve.located_obj = comp_id;
     final_curve.module_info = act_env;


     UI_status("Impose the composite on the support surface");

#    ifdef DEBUG
     printf("VDbound final_curve: %d, %d\n",final_curve.located_obj.objid,
					final_curve.located_obj.osnum);
#    endif
     stat = ci$send(msg = message EMSsurface.EMimpose_boundaries(
                     &msg,
                     1,
                     NULL,                     
                     &final_curve,	
                     area_pt,           
                     onsurf,              
                     &MOD_ENV, 
                     &number_of_points,         
                     &points,
                     &number_of_bad_curves,
                     bad_curve_indices,
                     NULL,
                     NULL, 
                     NULL, 
                     NULL, 
                     map_options, 
                     imp_options),
/*		verbose = VERBOSE,*/
              targetid = GRid_list.objid,targetos=GRid_list.osnum);
     as$status (sts= stat);
     if (!(stat&1) || msg == EMS_I_NoMoreLoops)
	{ 
	  EFmsgReport(0,msg ,"return msg EMimpose_bnd");
          printf("delete GRid\n");
          ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
                targetid = GRid_list.objid, targetos = GRid_list.osnum );
  	  GRid_list.objid = NULL_OBJID;
          err_flag = TRUE;
	  goto wrapup;
	} 

   }

#    ifdef DEBUG
     printf("GRconstruct stat = %d, GRid_list = %d, %d\n",stat, GRid_list.objid,
                                              GRid_list.osnum);
     EFmsgReport(0,*(cst.msg),"return msg GRconstruct");
#    endif


  if(props & EMSIS_NRML_REVERSED)
   {
#   ifdef DEBUG
    printf("The support has a reversed normal\n");
#   endif

    stat = ci$send(msg = message EMSsubbs.EMset_props(&msg,
                         (unsigned char) EMSIS_NRML_REVERSED, (char) EMS_O_SET),
                        targetid = GRid_list.objid,
                        targetos = GRid_list.osnum);
    as$status(sts = stat);
    if(!(msg&stat&1))
     {
#     ifdef DEBUG
      printf("VDbound2: Error EMSsubbs.EMset_props\n");
#     endif
     }
   }


#ifdef DEBUG
printf("GRid_list: %d, %d\n",GRid_list.objid,GRid_list.osnum);
#endif

wrapup:

     if(nb_cvgp   != NULL) {free(nb_cvgp)           ;nb_cvgp    = NULL;}
     if(points    != NULL) {free(points)            ;points     = NULL;}  
     if(line      != NULL) {BSfreecv(&rc, line)     ;line       = NULL;}
     if(part_line != NULL) {BSfreecv(&rc, part_line);part_line  = NULL;}
     if(comp_cv   != NULL) {free(comp_cv)           ;comp_cv    = NULL;}
     if(bsp_curve != NULL) {free(bsp_curve)         ; bsp_curve = NULL;}
     if(bnd_curve != NULL) {BSfreecv(&rc, bnd_curve); bnd_curve = NULL;}
     if( length   != NULL) {free(length)	    ; length    = NULL;}

     VDSfree(nb_sf1,&bsp_surf1); 
     VDSfree(nb_sf2,&bsp_surf2); 
     for(k=0;k<num_ent-2;k=k+1)
      {
	  if(curve[k]   != NULL) {BSfreecv(&rc, curve[k])  ; curve[k]   = NULL;}
          if(p_curve[k] != NULL) {BSfreecv(&rc, p_curve[k]); p_curve[k] = NULL;}
    	  if(p_par2[k]  != NULL) {free(p_par2[k])          ; p_par2[k]  = NULL;}
   	  if(int_pts[k] != NULL) {free(int_pts[k])         ; int_pts[k] = NULL;}
    	  if(p_par1[k]  != NULL) {free(p_par1[k])          ; p_par1[k]  = NULL;}
      }
     if(int_pts0 != NULL) {free(int_pts0); int_pts0 = NULL;}
     if(int_pts1 != NULL) {free(int_pts1); int_pts1 = NULL;}
     if(p_par10  != NULL) {free(p_par10) ;  p_par10 = NULL;}
     if(p_par11  != NULL) {free(p_par11) ;  p_par11 = NULL;}
     if(p_par20  != NULL) {free(p_par20) ;  p_par20 = NULL;}
     if(p_par21  != NULL) {free(p_par21) ;  p_par21 = NULL;}
     if(array    != NULL) {free(array)   ;  array   = NULL;}

     if(par_surf    != NULL) { BSfreesf(&rc,par_surf); par_surf = NULL;}
     if(numpts      != NULL) {free(numpts)     ;numpts   = NULL;}
     if(over0       != NULL) {free(over0)      ;over0    = NULL;}
     if(over1       != NULL) {free(over1)      ;over1    = NULL;}
     if(end_pts     != NULL) {free(end_pts)    ;end_pts  = NULL;}
     if(eval_pts    != NULL) {free(eval_pts)   ;eval_pts = NULL;}
     if(param       != NULL) {free(param)      ;param    = NULL;}
     VDSfree(numgrps,&pts);
     VDSfree(numgrps,&par1);
     VDSfree(numgrps,&par2);
     for(k=0;k<MAX_TEMP; k=k+1){
	if(om$is_objid_valid(osnum = GRid_cv[k].osnum,
			     objid = GRid_cv[k].objid) & 1){
#     		ifdef DEBUG
		printf("delete GRid_cv[k]: %d\n",GRid_cv[k].objid);
#     		endif
		ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = GRid_cv[k].objid ,
		targetos = GRid_cv[k].osnum);
		GRid_cv[k].objid = NULL_OBJID;
	}
     }
     if(om$is_objid_valid(osnum = comp_id.osnum,objid = comp_id.objid) & 1){
#     	ifdef DEBUG
	printf("delete comp_id: %d\n",comp_id.objid);
#     	endif
	ci$send(	msg = message GRgraphics.GRdelete(&msg, &act_env),
		targetid = comp_id.objid ,
		targetos = comp_id.osnum);
	comp_id.objid = NULL_OBJID;
     }

     /*|restore file cht */
     
     nput = sizeof(file_cht);

     gr$put_chord_height_tolerance
                        (msg    = &msg,
                         sizbuf = &nput,
                         buffer = &file_cht);

     if(!(msg&1)) { 
        err_flag = TRUE;
    	printf("error gr$put_chord_height_tolerance\n"); 
     }

     if(err_flag) {
   	UI_status("Placement of bounded surface fail");
   	if( GRid_list.objid != NULL_OBJID){
          	ci$send(msg      = message GRgraphics.GRdelete(&msg,&MOD_ENV),
                	targetid = GRid_list.objid, 
			targetos = GRid_list.osnum );
  	  	GRid_list.objid = NULL_OBJID;
   	}
	return(0);
     }
    else {
   	UI_status("Placement of bounded surface success");
    	return(1);
    }

}




