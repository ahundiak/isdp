/* $Id: COTrmSurf.u,v 1.1.1.1 2001/01/04 21:07:36 cvs Exp $  */

/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:	vds/smppl / COTrmSurf.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *	$Log: COTrmSurf.u,v $
 *	Revision 1.1.1.1  2001/01/04 21:07:36  cvs
 *	Initial import to CVS
 *	
# Revision 1.1  1998/04/29  16:27:20  pinnacle
# VDS 2.5.1
#
# Revision 1.1  1997/05/08  13:20:44  pinnacle
# New project VDS 250
#
# Revision 1.1  1996/07/19  20:33:52  pinnacle
# Create VDS 241 project
#
# Revision 1.1  1994/11/14  22:42:32  pinnacle
# Create vds.240 from vds.232
#
# Revision 1.1  1994/11/08  16:07:00  pinnacle
# create vds.232
#
 *
 * History:
 *	MM/DD/YY	AUTHOR		DESCRIPTION
 *
 * -------------------------------------------------------------------*/

/*

   File name :		COTrmSurf.u
   Revision date :	92/11/04

   Description :		
	Command object to trim a composite surface by a closed curve (within 
	the scope of I/SMAN).  Note that the curve can be a composite one.
	The user should first locate a composite surface, then a curve (e.g.
	a composite one), and give a point to indicate the area side.

   History :

 92/10/21	alc	Creation date

 */

#include <stdio.h>
#include "msdef.h"
#include "cieveryone.h"
#include "cimacros.h"
#include "ci_mac_def.h"
#include "bserr.h"
#include "bsconic.h"
#include "nddef.h"
#include "AS_status.h"
#include "exmacros.h"
#include "grmacros.h"
#include "grdpbdef.h"
#include "grdpbmacros.h"

extern int 	init_cnst_list()     ;
extern long	SMTrSurfPassArg() ;

main()
{
char			loc_mes[81] ;
unsigned short		options, map_options, imp_options ;
long			stat, msg  ;

struct GRparms		track_parms ;
struct GRmd_env		mod_env ;
struct GRid		temp ;
struct GRvg_construct   cst  ;
struct IGRdisplay	dis  ;
struct GRlc_info	surface, curve ;
double			track_point[3], acc_point[3] ;
GRobjid			*trim_surf ;

/*
	Initialisation
 */

strcpy(loc_mes,"<Test> Trim composite surface by curve on surface") ;

ci$get_module_info(md_env = &mod_env) ;
init_cnst_list() ;
get_symb() ;

dis.color	= cnst_list.color  ;
dis.weight	= cnst_list.weight ;
dis.style	= cnst_list.style  ;

cst.msg		= &msg ;
cst.properties	= GRIS_LOCATABLE | GRIS_NEW | GRIS_DISPLAYABLE ;
cst.display	= &dis ;
cst.env_info	= &mod_env ;
cst.newflag	= 0 ;
cst.level	= cnst_list.level ;
cst.geometry	= NULL ;
cst.class_attr	= 0 ;
cst.name	= 0 ;

/*
	Get composite surface, boundary curve and area point
 */

while (1) {

   message(loc_mes);
   if(!ci$locate( 	prompt       = "Identify a surface",
			acc_prompt   = "Accept with curve to trim surface",
			relocate_prompt = "No surface found",
			accept_point    = acc_point,
                  	properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                  	owner_action = LC_RIGID_COMP  |
                                 LC_RIGID_OWNER | LC_FLEX_COMP |
                                 LC_FLEX_OWNER  | LC_REF_OBJECTS,
			classes	     = "EMSsurface",
                  	obj          = &temp.objid,
                  	osnum        = &temp.osnum,
                  	lc_info      = &surface	)) break ;
   ci$put(point = acc_point) ;

   while (1) {
      if(!ci$locate( 	prompt       = "Identify a curve on surface",
			acc_prompt   = "Accept with area point",
			relocate_prompt = "No curve found",
			accept_point    = acc_point,
                  	properties   = LC_LC_ONLY | LC_DP_ONLY | LC_RW,
                  	owner_action = LC_RIGID_COMP  |
                                 LC_RIGID_OWNER | LC_FLEX_COMP |
                                 LC_FLEX_OWNER  | LC_REF_OBJECTS,
 	          	classes      = "GRcurve",
	          	obj          = &temp.objid,
                  	osnum        = &temp.osnum,
                  	lc_info      = &curve	)) break ;

      /* Handle Track Point */

      stat = ci$send(msg   = message GRgraphics.GRptproject(
                                        &msg,
                                        &mod_env.md_env.matrix_type,
                                        mod_env.md_env.matrix,
                                        acc_point,	/* I */
                                        track_point,	/* O */
                                        &track_parms),	/* O */
                targetid = surface.located_obj.objid,
                targetos = surface.located_obj.osnum) ; 

      if (!(stat & msg & 1)) {
         stat = 0 ; as$status(sts = stat) ;
         status("Unable to project accept point on surface") ;
         break ;
         }

      /* Pass arguments to trim the surface */

      options = 0 ;
      map_options = 0 ;
      imp_options = 0 ;

      #ifdef DEBUG
      printf("Call to SMTrSurfPassArg() \n") ;
      #endif

      stat = SMTrSurfPassArg(	&msg,		/* O */
				&surface,	/* I */
				&curve,		/* I */
				track_point,	/* I */
                                &track_parms,	/* I */
				&cst,		/* I */
				options,	/* I */
				map_options,	/* I */
				imp_options,	/* I */
				&trim_surf	/* O */	) ;

      #ifdef DEBUG
      printf("Return from SMTrSurfPassArg() \n") ;
      #endif

      if (! (stat & msg & 1)) {
         stat = 0 ; as$status(sts = stat) ;
         status("Construction failed") ;
         continue ;
         }

      } /* while curve */

   } /* while surface */
    
return OM_S_SUCCESS ;
}     /* main() */

