/***************************************************************************
 * I/VDS
 *
 * File:        api/exec_ppl/README
 *
 * Description:
 *              Overview file for usage of ppl programs inside the parser
 *		processing, using the output routine:
 *
 *			exec-ppl-func("filename", "function", arg0, arg1 );
 *
 * Dependencies:
 *
 * History:
 *
 ***************************************************************************/

The VISUAL / STRUDL parser do have the ability to call PPL programs using the 
predefined layout (as explained in visual.doc). This routine permits to call
as PPL program and the name of the routine within the PPL program file. 
Default, the function name is "main".

The parser allows to work with input and output argunments.

INPUT ARGUMENTS:
================

Reviewing the syntax of the OUTPUT-ROUTINE, the user has the ability to define
a number of input arguments (after the definition of the filename and function
name).

	exec-ppl-func("filename", "function", arg0, arg1, ... );

The arguments types are flexible and controlled by the user during creation
of the support file. The following types will be expected by the PPL program:

	- VD_int	Integer Data Structure Type.
	- VD_double	Double Data Structure Type.
	- VD_string	Character String Data Structure Type
	- VD_object	Design file Data Object Data Structure Type
	- VD_bool	Boolean Data Structure Type

	All are defined in the file "v_slcdef.h" and there will be a limit
	of 10 input arguments.

The PPL program need to retrieved the input arguments from the parser process, 
using the following two routines ( defined in v_slcppl.h ): 

  o Find the number of input arguments:

	- vd$ppl_get_size(	which_info	= INPUT_INFO,
				size		= &size );
  o Find the contents of one of the arguments:

	- vd$ppl_getarg_at_index(	which_info	= INPUT_INFO,
					index		= 0,
					type		= &type0,
					value		= (void) &data0 );

	- vd$ppl_getarg_at_index(	which_info	= INPUT_INFO,
					index		= 1,
					type		= &type1,
					value		= (void) &data1 );

	In case the user predefines the input arguments, the 'type' checking
	will be optional. The datastructures can be used inside the routine.


OUTPUT ARGUMENTS:
================

Output-Routines from the parser do have the ability to return information 
back to the parser process. In general this can be one argument, but we have
allowed to return against an array of output routine values.

	$result := exec-ppl-func("filename", "function", arg0, arg1, ... );

The arguments types for 'result' are flexible and controlled by the user
within the PPL program.  The following types will be expected by the parser:

	- VD_int	Integer Data Structure Type.
	- VD_double	Double Data Structure Type.
	- VD_string	Character String Data Structure Type
	- VD_object	Design file Data Object Data Structure Type
	- VD_bool	Boolean Data Structure Type

	All are defined in the file "v_slcdef.h" and there will be a limit
	of 10 input arguments.

The PPL program need to create the output arguments for the parser process at
the end of his program. The number of output arguments and there values need
be defined by using the following two routines ( defined in v_slcppl.h ): 

  o Set the number of output arguments:

	- vd$ppl_set_size(	which_info	= OUTPUT_INFO,
				size		= size );
  o Set the contents of one of the arguments:

	- vd$ppl_setarg_at_index(	which_info	= OUTPUT_INFO,
					index		= 0,
					type		= type0,
					value		= (void) data0 );

	- vd$ppl_setarg_at_index(	which_info	= OUTPUT_INFO,
					index		= 1,
					type		= type1,
					value		= (void) data1 );

GLOBAL ARGUMENTS:
================

In general PPL programs do not have the ability to save values outside the
scope of execution of the PPL program. In general all data information is 
lost when leaving the PPL program. 
In case the user has a need to define global variables within the process
(in sitautions where the parser will be called for every object and within
the ppl program we need to have a global counter defined ), the following
three routines can be used to check, and set the information in this data
structure.

  o Set the number of global arguments:

	- vd$ppl_set_size(	which_info	= GLOBAL_INFO,
				size		= size );

  o Set the contents of one of the global arguments:

	- vd$ppl_setarg_at_index(	which_info	= GLOBAL_INFO,
					index		= 0,
					type		= type0,
					value		= (void) data0 );

  o Get the contents of one of the global arguments:

	- vd$ppl_getarg_at_index(	which_info	= GLOBAL_INFO,
					index		= 1,
					type		= &type1,
					value		= (void) &data1 );


