/* $Id: COpen.u,v 1.6 2001/10/16 13:51:42 ylong Exp $  */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:        vds/vdpen/ppl/COpen.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COpen.u,v $
 *      Revision 1.6  2001/10/16 13:51:42  ylong
 *      Replace built-in lists with vds/config/penetrations/DataList
 *
 *      Revision 1.5  2001/10/11 18:18:45  ylong
 *      TR4064
 *
 *      Revision 1.4  2001/05/12 22:10:38  ylong
 *      *** empty log message ***
 *
 *      Revision 1.3  2001/05/09 19:56:27  ylong
 *      *** empty log message ***
 *
 *      Revision 1.2  2001/01/19 22:31:01  jayadev
 *      *** empty log message ***
 *
# Revision 1.12  2000/10/31  14:08:44  pinnacle
# CR179901844
#
# Revision 1.11  2000/10/09  19:07:52  pinnacle
# ylong
#
# Revision 1.10  2000/09/05  22:09:46  pinnacle
# ylong
#
# Revision 1.9  2000/08/27  19:17:52  pinnacle
# ylong
#
# Revision 1.8  2000/08/25  22:22:28  pinnacle
# TR179901670
#
# Revision 1.7  2000/07/17  21:23:56  pinnacle
# misc fixes
#
# Revision 1.6  2000/06/23  18:16:24  pinnacle
# ylong
#
# Revision 1.2  2000/06/06  15:44:18  pinnacle
# ylong
#
# Revision 1.13  2000/03/01  23:02:30  pinnacle
# ylong
#
# Revision 1.12  1999/12/29  16:41:46  pinnacle
# added F as a prefix of coord
#
# Revision 1.11  1999/12/06  16:06:00  pinnacle
# ylong
#
# Revision 1.10  1999/12/01  16:14:40  pinnacle
# 'type truncate problem'
#
# Revision 1.8  1999/09/14  13:47:20  pinnacle
# ylong
#
# Revision 1.7  1999/05/31  20:21:00  pinnacle
# ylong
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/27/99        ylong           1. TR179900583 
 *					2. get default values from form
 *					3. prevent duplicate penMacro
 *      05/31/99        ylong           TR179900656 
 *      09/13/99        ylong           TR179900857
 *      11/30/99        ylong           CR179900966 and type truncate
 *      12/06/99        ylong           truncate "Struct to Cut" to 5 
 *      12/29/99        ylong           added F as one of allowed prefixes of 
 *					coord name 
 *      03/01/00        ylong		hide penMacro & pcgMacro in SHAPE field
 *	06/05/00	ylong		CR179901629
 * --------------------------------------------------------------------------*/
/************************************************************
 * FILE:  Pen.u
 * PURPOSE:  This PPL command will place a penetration macro 
 *		on a coordinate system
 *
 * DESCRIPTION: This command file controls a form that lets
 *    	the user select many options and places a macro on it
 *
 * NOTE:
 *
 ************************************************************/

#include "FI.h"       /* Forms Include File */

#include "VDppl.h"
#include "VDgeom.h"
#include "VDefp.h"
#include "VDmem_ppl.h"
#include "VDobj.h"
#include "VDSudp_mac.h"
#include "vdAPImacros.h"
#include "vdrefmacros.h"

#include "ci_mac_def.h"
#include "VDsa.h"
/*
#define  DEBUG	1
#define  vdsDEBUG	1
*/
#include "v_dbgmacros.h"

/************************************************************
  Constants for the form.
 ************************************************************/
#define FORM_LABEL 100  /* Arbitrary Number for Form */
#define FORM_NAME  "VDpen.frm"  /* Form File */
#define TITLE_STRING "Place Penetration"

#define NAME_BTN 	33
#define COMP_BTN	32
#define NAME_FIELD	12
#define COMP_FIELD	27
#define DESCRIPTION_FIELD 30
#define REV		13
#define TYPE		19
#define SHAPE		21
#define LA		20
#define STRUCT_CUT	28
#define DEFINE_DOC	11
#define CHECK		1
#define ACCEPT		1
#define RUN		2
#define RE_SET		3
#define CANCEL		4
#define FORM_TITLE	11
#define MAC_LIB 	15
#define EXPRESSIONS	14
#define MAX_TEMPS	100

/************************************************************
  External functions.
 ************************************************************/
extern VDSloadMacroLibrary();
extern ci_notification();  /* The forms system automatically calls    */
                           /* this function, which in turn calls your */
                           /* form_notification function              */

extern FIf_set_cmd_oid_os();  /* This function tells the forms system */
                              /* to notify this command file when the */
                              /* user manipulates the form */

extern FIf_new();        /* Creates the form              */
extern FIf_display();    /* Draws the form                */
extern FIf_erase();      /* Erases the form               */
extern FIf_delete();     /* Removes the form              */
extern FIg_get_value();  /* Retrieves values from gadgets */
extern FIf_reset();
extern int FIg_display ();
extern int FIg_erase ();
extern int FIfld_set_text ();
extern int FIfld_get_text ();
extern int FIg_set_text ();
extern int FIg_set_state_on();
extern int FIg_set_state_off();
extern int FIg_enable();
extern int FIg_disable();
extern int GRdpb_get();
extern int ASmake_source_from_env();
extern int FIfld_set_list_num_rows();
extern int FIfld_set_num_rows();
extern int FIfld_get_num_rows();
extern int FIfld_set_mode();
extern int FIfld_set_list_default_text();
extern int EX_filename1();
extern int toupper();
extern int FIfld_pos_cursor();
extern int FIfld_get_list_text();

extern int FIg_reset();

extern int VDGetGridsFromChan_of_Class();
extern VDpms_findall_ancestryobjects();
extern GRdisplay_object();
extern VDpenFormFillInCoordNames();
extern VDpenCheckForProperName();
extern VDpenFormSetList( );

extern GRclassid OPP_ACconst_class_id;
extern GRclassid OPP_ASsource_class_id;

/************************************************************
  Global variables.
 ************************************************************/
int test_wakeup;  /* The wakeup function uses this flag to
                     test if the main function has started yet. */

int form_exists,    /* The delete function uses this flag
                       to test if the form exists */
    form_displayed, /* The sleep function uses this flag
                       to test if the form is displayed */
    not_done;       /* This value is set to 0 when the user
                       selects the cancel or exit & save buttons */

Form form;  /* Use this variable for the forms functions. */

struct CIform_st form_st; /* This structure contains information on
                             which form and gadget was manipulated. */

struct ACrg_coll  collAttrs[50];
struct GRid	itemColGRid;
struct GRid	dataColGRid;
struct GRid	GRIDS[3];

IGRchar	anoString[80];
IGRchar	tmpString[80]; 
IGRchar	descriptionString[80]; 
IGRchar	commentString[80];
IGRint	num_exps;
IGRdouble exps[MAX_TEMPS];
IGRint	num_temps;
struct GRid Templates[MAX_TEMPS];

IGRchar	descString[1024];
IGRchar	revStr[80];
IGRchar	typeStr[80];
IGRchar	shapeStr[80];
IGRchar	laStr[80];
IGRchar	structStr[80];
IGRchar	macStr[128];
IGRchar	libStr[128];
IGRchar	compStr[128];
IGRchar	csName[128];
IGRchar	penName[128];
struct GRid	MACROID;


void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  status("");   /* Clear the status field  */
  message("");  /* Clear the message field */
  exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  int error;

 /*************************
   Create (load) the form.
  *************************/
#ifdef DEBUG
  printf("about to FIf_new Form name[%s]\n",FORM_NAME);
#endif
  error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &form );
  if ( form == NULL ) 
    {
      write( "Could not create the form.\n",
             "Error code = ",  error,  "\n"  );
      return_error();
    }

  form_exists = TRUE;  /* Flag for delete function */

 /**********************************************
   Tell the Forms System to notify this command
   file when the user manipulates the form.
  **********************************************/
  error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
  if ( error )
    {
      write( "Could not link to the Forms System.\n",
             "Error code = ",    error,         "\n"  );
      form_exists = FALSE;
      return_error();
    }

  /* Set the title on the form */
  FIg_set_text( form, FORM_TITLE, TITLE_STRING);

  /* Set form lists */

 /*******************
   Display the form.
  *******************/
  
  error = FIf_display( form );
  if ( error )
    {
      write( "Could not display the form.\n",
             "Error code = ",  error,   "\n"  );
      return_error();
    }

  form_displayed = TRUE;  /* Flag for sleep function */
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  char outString[80];
  
  ci$put( response = MOVE_ON );  /* Give control to the main function */
}


wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  /* Display the form unless the command file is just starting */
#ifdef DEBUG
  printf("I'm now waking up, test_wakeup=%d\n",test_wakeup);
#endif
  if ( test_wakeup == 1 && not_done )
    {
      FIf_display ( form );  /* Redisplay the form */
      form_displayed = TRUE; /* Set flag for sleep function */
    }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
  {
    FIf_erase ( form );
    form_displayed = FALSE;
  }
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE ) {
      FIf_erase ( form );
      form_displayed = FALSE;
  }

  /* Delete the form if it exists */
  if ( form_exists ) {
      FIf_delete( form );
  }
}


/**************************************************************************/
IGRlong GetObjByName( objName, className, objID )
IGRchar	*objName ;
IGRchar	*className ;
TGRid	*objID ;
{
IGRlong         ret ;
IGRlong         sts ;
IGRint          i, j, index, nb_obj;
GRspacenum      cur_osnum;
GRclassid       classid ;
GRobjid         *obj_list ;
TGRid           id ;
int		NbRefOs;
GRspacenum	main_os, *RefOsList;
char		name[128], pathName[128] ;


	ret = 0 ;
	main_os = 2 ;
	NbRefOs = 0 ;
	obj_list = NULL  ;
	RefOsList = NULL ;

	/* get obj from current active file */
	objID->objid = NULL_OBJID ;
	vds$translate (objname = objName, 
               	      p_objid = &(objID->objid),
                      p_osnum = &(objID->osnum) );

	if( objID->objid != NULL_OBJID ) {
                ret = 1;
                goto wrapup ;
        }

	/* if obj not in active file, try ref files */

        sts = om$get_classid (  classname = className ,
                                p_classid = &classid);
        if( !(sts&1) ) {
                printf("om$get_classid failed\n");
                goto wrapup ;
        }

	sts = vd$get_ref_os_list (	msg           =  &msg,
                               		main_os       =  &main_os,
                               		num_ref_os    =  &NbRefOs,
                               		ref_os_list   =  &RefOsList );
	__DBGpr_int("NbRefOs", NbRefOs);
for(i = 0; i < NbRefOs; i = i+1 ) {
	nb_obj = 0 ;
	__DBGpr_int("RefOsList", RefOsList[i]);
        sts = VDpms_findall_ancestryobjects (
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        NULL);
	__DBGpr_int("nb_obj", nb_obj);
        if( !(sts&1) || !nb_obj ) {
		__DBGpr_com("VDpms_findall_ancestryobjects failed 1");
		continue ;
	}

	obj_list = NULL ;
        obj_list = _CALLOC( nb_obj, GRobjid ) ;
        if( obj_list == NULL ) {
                printf("_CALLOC failed for obj_list\n") ;
                goto wrapup ;
        }

        sts = VDpms_findall_ancestryobjects(
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        obj_list);
        if( !(sts&1) || !nb_obj ) {
		__DBGpr_com("VDpms_findall_ancestryobjects failed 2");
		continue ;
	}

	id.osnum = RefOsList[i];
        for(j = 0; j < nb_obj; j = j + 1 ) {
		id.objid = obj_list[j] ;
		gr$get_name(	GRid_in = id, 
		 		name = name);
		if( !strcmp(objName, name) ) {
			*objID = id ;
			ret = 1;
			goto wrapup ;
		}

        }
        _FREE( obj_list ) ;
	obj_list = NULL ;
}

        ret = 1 ;
wrapup:
        _FREE( obj_list ) ;
	_FREE(RefOsList); 
        //printf(">> Exit VStransEdgeToEJ_Bevel <<\n");
        return ret ;
}

#ifdef DEBUG
#define TRACE(txt)	write("ci_mac_bib: ", txt, '\n');
#else
#define TRACE(txt)  ;
#endif

#define EXP_DOUBLE 0

/*======================================================================*/
/*      locate an object or a expression				*/
/* copied & modified from vds/cimacros/wireframe/macros/ci_mac_bib.u	*/
/*======================================================================*/

int loc_obj_exp( loc_suc, loc_message, loc_prompt, 
                 class_obj,EXP_GRid )

int		*loc_suc;       /* return status			    */
char		loc_prompt[80];	/* prompt to ask the name of the expression */
char		loc_message[80];/* prompt to set the message field          */
struct GRid	*EXP_GRid;	/* return objid & osnum of the expression   */
char		*class_obj;	/* classes filter for located object	    */


{

char		exp_name[80];
char		*exp_value, msg_string[128] ;
int		stat, mask, response, count;
short		sender_class;

struct GRmd_env	MOD_ENV;
struct GRevent	event;

extern ASmake_source_from_env();


        message(loc_message);

	ci$get_module_info(md_env = &MOD_ENV);

step0:

	EXP_GRid->objid = NULL_OBJID;

	mask = GRm_RJT_MOVEON | GRm_BACK_UP | GRm_STRING | GRm_DATA | GRm_OBJID;

        do
        {
        
           *loc_suc = ci$getevent( prompt = loc_prompt, response = &response,
	     			   data   = exp_value,  mask     = mask,
				   event = &event,
				   stackable = 1 );

           if( (response == EX_RJT_MOVEON) || (response == EX_BACK_UP ) )
           {
		*loc_suc = 0; 
                return(0);
           }
        }while( *loc_suc != 1 );

/* we got an object via the navigate graph */

	if( response == EX_OBJID )
        {
	  om$get_classid( osnum     = event.located_object[0].located_obj.osnum,
			  objid     = event.located_object[0].located_obj.objid,
			  p_classid = &sender_class );

	  stat = om$is_ancestry_valid( subclassid     = sender_class,
				       superclassname = "expression" );
	  if( stat  != 1 ) goto step0;
	  EXP_GRid->objid = event.located_object[0].located_obj.objid;
	  EXP_GRid->osnum = event.located_object[0].located_obj.osnum;
 	  *loc_suc = 2; 
	  return(1);
        }

/* we recieved a data point to locate an abject */

        if ( response == DATA )
        {
		ci$put( point = (double *)exp_value );
		if ( !ci$locate( prompt = loc_prompt,
                                 owner_action = LC_RIGID_COMP
                                              | LC_RIGID_OWNER | LC_FLEX_COMP
                                              | LC_FLEX_OWNER  | LC_REF_OBJECTS,
				 obj    = &(EXP_GRid->objid), 
				 osnum  = &(EXP_GRid->osnum),
				 md_env = &MOD_ENV,
				 classes= class_obj,
				 stackable = 1 ))
        	{
             		EXP_GRid->objid = NULL_OBJID;
             		*loc_suc = 0;
                        return(0);
        	}
		else
		{
			*loc_suc = 1;
                        return(1);
		}
        }

/* we recieved a data point to locate an abject */

	else if ( response == STRING )
        {
		strcpy(exp_name, exp_value);
		if(exp_name[0] == 0 ) goto step0;

		GetObjByName( exp_name, class_obj, EXP_GRid);
		__DBGpr_obj("EXP_GRid", *EXP_GRid);
          	if ( (EXP_GRid->objid) == NULL_OBJID )
          	{
			sprintf(msg_string, "Macro \"%s\" not found", exp_name);
			UI_status(msg_string);
			goto step0 ;
	  	} 

		gr$display_object(object_id = EXP_GRid, mode  = GRhd );
		*loc_suc = 2;
		return(1);
	} /* end of process string */

}

#if 0
IGRboolean checkForProperName( selObj, objName, check )
struct GRid selObj;
IGRchar	objName[80];
IGRint	check;
{
double pnt[3];
char	prefix[80];
char	preName[2];
char	fullName[128];
GRname	*list;
int	nbList;
int	i, ret;

	objName[0] = 0;
	prefix[0]  = 0;
	nbList     = 0;
	//list = NULL;

 	gr$get_name(	GRid_in = selObj, 
			full_name = fullName,	
		 	name = objName);

#ifdef DEBUG
	printf("Selected object name is %s, [%s]\n",objName, fullName);
#endif

	if(!strcmp(objName,"")) 
	{
		//status("This object is not named");
		strcpy(commentString, "This object is not named");
		return FALSE;
	}

	if ( check == 1 ){
	  if(!VDpenReadDataList( NULL, "name_prefix", &list, &nbList ))
	  {
		goto wrapup;
	  }
	  if( !nbList || list == NULL ) goto wrapup;

	  for( i = 0; i < nbList; i = i+1 ) {
		prefix[i] = preList[i][0];
	  }
	  prefix[i] = '\0';

	  if( strlen(objName) != 9 || objName[5] != '-' ){
		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  preName[0] = objName[0];
	  preName[1] = '\0';
	  if( !strpbrk( preName, prefix ) )
	  {
		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }
	}
	return TRUE;
}
#endif


/*
 * Enable every gadget in the form after RE_SET. 
 * added by ylong for TR179900857. 
 */
void enable_form()
{
        FIg_enable( form, CANCEL);
        FIg_enable( form, RE_SET);
        FIg_enable( form, RUN);
        FIg_enable( form, ACCEPT);
        FIg_enable( form, COMP_BTN);
        FIg_enable( form, NAME_FIELD);
        FIg_enable( form, COMP_FIELD);
        FIg_enable( form, DESCRIPTION_FIELD);
        FIg_enable( form, EXPRESSIONS);
        FIg_enable( form, REV);
        FIg_enable( form, TYPE);
        FIg_enable( form, SHAPE);
        FIg_enable( form, LA);
        FIg_enable( form, STRUCT_CUT);
        FIg_enable( form, MAC_LIB);
}

/*
 * Disable every gadget in the form after RE_SET. 
 * added by ylong for TR179900857. 
 */
void disable_form()
{
        //FIg_disable( form, CANCEL);
        FIg_disable( form, RE_SET);
        FIg_disable( form, RUN);
        FIg_disable( form, ACCEPT);
        FIg_disable( form, COMP_BTN);
        FIg_disable( form, NAME_FIELD);
        FIg_disable( form, COMP_FIELD);
        FIg_disable( form, DESCRIPTION_FIELD);
        FIg_disable( form, EXPRESSIONS);
        FIg_disable( form, REV);
        FIg_disable( form, TYPE);
        FIg_disable( form, SHAPE);
        FIg_disable( form, LA);
        FIg_disable( form, STRUCT_CUT);
        FIg_disable( form, MAC_LIB);
}

IGRstat	SetLongAxis(k)
	IGRint	k;
{
	IGRstat		retFlag;
	IGRlong		sts, msg;
	IGRint		m, sel, pos;
	IGRchar		text[128];
	IGRdouble	val[10];
	IGRdouble	cm[16], cosin, angle;
	IGRdouble	loc_vec[3], max, dot_prod;
	IGRint		orient, loc_orient;
	

	retFlag = 0;

	if(!strcmp(shapeStr,"rd")) {
		goto wrapup;
	}

	if( k < num_exps ) {
		goto wrapup;
	}

	for(m = 0; m < 3; m = m+1) {
		loc_vec[m] = 0.;
	}

	if(!strcmp(shapeStr,"rh")) {
		loc_vec[0] = 1.0;
		loc_orient = 0;
	}
	else {
		for(m = 0; m < num_exps; m = m+1) {
		  text[0] = '\0';
		  FIfld_get_text(form, EXPRESSIONS, m, 1, 80, text, &sel, &pos);
		  val[m] = atof(text); 
		  __DBGpr_dbl("val", val[m]);
		}

		if( val[1] > val[0] ) {
			loc_vec[1] = 1.0;
			loc_orient = 1;
		}
		else {
			loc_vec[0] = 1.0;
			loc_orient = 0;
		}
	}

	__DBGpr_obj("GRIDS[0]", GRIDS[0]);
	sts = ci$send(  msg      = message GRgencs.GRgetmatrix (&msg, cm),
                        targetid = GRIDS[0].objid,
                        targetos = GRIDS[0].osnum );
	if( !(sts&msg&1) ) {
		printf("GRgencs.GRgetmatrix failed");
		goto wrapup;
	}

	max = 0.;
	for( m = 0; m < 3; m = m+1 ) {
		dot_prod =	cm[m*4+0]*loc_vec[0] + 
				cm[m*4+1]*loc_vec[1] + 
				cm[m*4+2]*loc_vec[2];
		if( fabs(dot_prod) > max ) {
			max = fabs(dot_prod);
			orient = m;
		}
	}
	
	__DBGpr_int("orient" , orient);

	switch( orient ) {

	case 0:		/* X */
		cosin = fabs( cm[loc_orient+0] );
		break;
	case 1:		/* Y */
		cosin = fabs( cm[loc_orient+4] );
		break;
	case 2:		/* Z */
		cosin = fabs( cm[loc_orient+8] );
		break;
	default:	/* NA */
		cosin = 0.707;	/*  about 45 degree, doesn't matter */
		break;
	};

	if( cosin > 1.0 ) cosin = 1.0;
	angle = acos( cosin )*180/PI ;
	if( angle > 1.0 ) orient = 3;

	text[0] = '\0';
	FIfld_get_list_text(form, LA, orient, 0, 80, text, &sel);

	FIg_set_text(form, LA, text);

	retFlag = 1;
wrapup:
	return retFlag;
}

main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/


{

  int 	response;     
  int	iSwitch;
  int	i;
  int	m;
  int	msg;
  int	pos;
  int   selFlag;
  int	exitFlag;
  int	numAttrs;
  int	sts;
  int	k;
  int 	error;

  double dSwitch;
  double dDiameter;
  double dWidth;
  double dDepth;
  double dRadius_corner;

  GRobj	pplFileId;

  struct GRid	csObj;
  struct GRid	compObj;
  struct GRid	CollID;
  struct GRid	objID;

  char	objName[128];
  char	NameToGive[128];
  char	someString[80];
  char	tmp[80];
  char	chkval[80];
  char  expnam[80];
 
  int	default_S_CUT;  /* added by ylong as default flags */
  int	default_LA;
  int	default_TYPE;

 /***********************************************************
  Do a locate and check to see if the object is named properly
  before displaying the form.
  ***********************************************************/
  /* initialize some parameters before we start */
  dDiameter = 1.0;
  dWidth = 1.0;
  dDepth = 1.0;
  dRadius_corner = 0.4;

  test_wakeup = 1;        /* flag for wakeup function */
  form_exists = FALSE;    /* flag for delete function */
  form_displayed = FALSE; /* flag for sleep  function */

 mainTop:

  message(TITLE_STRING);
  exitFlag = 1;
  objID.objid = NULL_OBJID ; 
  if( !LocateObj( "GRgencs", "Identify Coordinate System", 
			&objID, csName, TRUE) ) {
        if( form_displayed ) {
	    do {
		ci$get( prompt = "Quit Form", response = &response );
		if( form_st.gadget_label != CANCEL ) continue ;
		not_done = 0;		/* Stop the loop  */
		exitFlag = 0;		/* exit the program */
		FIf_erase ( form );	/* Erase the form */
		goto wrapup;
	    } while( form_st.gadget_label != CANCEL ) ;
        }
        else goto mainTop ;
  }
  if( objID.objid != NULL_OBJID ) GRIDS[0] = objID ;

 /*
  * Added by ylong for TR179900857
  */
  if( form_exists && A_penMacro_exists(GRIDS[0]) ) {
	goto mainTop ;
  }

  if( A_penMacro_exists(GRIDS[0]) || GRIDS[0].objid == NULL_OBJID) {
	goto wrapup ;
  }

process_located_obj:

  not_done = TRUE;  /* Set this to FALSE when done with form */
  strcpy(revStr, "A1");
  strcpy(typeStr, "N/A");
  strcpy(laStr, "1");
  strcpy(structStr, "DECK");
  strcpy(descString, "");

  default_S_CUT = 1;  /* added by ylong as default flags */
  default_LA = 1;
  default_TYPE = 1;

  if( form_exists ) { 		/* modified for TR179900857 */
	enable_form() ;
  }
  else {
	form_init();      /* Set up the form */
  }

  get_current_file_name_and_mod_env();
  get_attached_macro_libraries();

  sprintf(penName, "PEN-%s", csName);
  VDpenFormFillInCoordNames( form, NAME_FIELD );
  VDpenFormSetList( form, TYPE,       "type_list", 1 );
  VDpenFormSetList( form, STRUCT_CUT, "structure_to_cut", 10 );
  VDpenFormSetList( form, LA,         "long_axis", 2 );
  FIfld_set_text( form, NAME_FIELD, 0,0,csName, FALSE); /*fillin the name*/
  FIfld_set_text( form, DESCRIPTION_FIELD, 0, 0, descriptionString, FALSE);

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/
  while (not_done )
    {
#ifdef DEBUG
	printf("case[%d]\n",form_st.gadget_label);
#endif
      objID.objid = NULL_OBJID ;

      /* Suspend the command file and wait for the form */
      ci$get( prompt = "Fill in the form",
              response = &response );
              
      status(""); /* clear the status field*/
	
      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){


        case CANCEL:
          /* Quit Button */
          not_done = 0;        /* Stop the loop  */
	  exitFlag = 0;		/* exit the program */
          FIf_erase ( form );  /* Erase the form */
          break;

        case NAME_FIELD:
	  FIg_get_text( form, NAME_FIELD, objName );
	  GetObjByName( objName, "GRgencs", &objID);
	  if( objID.objid == NULL_OBJID ){
		FIg_set_text( form, NAME_FIELD, csName ); // set old name back
		break ;
	  }
	  gr$display_object(object_id = &objID, mode  = GRhd );

	  if( A_penMacro_exists(objID) ) {
		FIg_set_text( form, NAME_FIELD, csName );
	  	disable_form();
	 	FIg_enable(form, NAME_BTN);
	  	FIg_enable(form, NAME_FIELD);
		break ;
	  }

	  strcpy( csName, objName );
	  sprintf(penName, "PEN-%s", csName);
	  GRIDS[0] = objID ;
	  FIg_set_text( form, NAME_FIELD, csName );
	  //goto process_located_obj;
	  enable_form() ;
	  
          break;

        case NAME_BTN:
          /* ID COORD Button */
 	  if( !LocateObj( "GRgencs", "Identify Coordinate System", 
			&objID, objName, TRUE) ) break ;
	  if( objID.objid == NULL_OBJID ) break ;
	  if( A_penMacro_exists(objID) ) {
	  	disable_form();
	 	FIg_enable(form, NAME_BTN);
	  	FIg_enable(form, NAME_FIELD);
		break ;
	  }
	  strcpy( csName, objName );
	  sprintf(penName, "PEN-%s", csName);
	  GRIDS[0] = objID ;
	  FIg_set_text( form, NAME_FIELD, csName );
	  //goto process_located_obj;
	  enable_form() ;
	  
          break;

        case COMP_BTN:
          /* ID COMPARTMENT Button */
 	  LocateObj( "SMcomp", "Identify Compartment", &objID, compStr, FALSE);
	  if( objID.objid != NULL_OBJID ) compObj = objID ;
	  /* Get comp_num to replace comp_name for CR179900966 */
          vdsa$GetStruct (      objID   = &compObj,
                                name    = "attr:comp_num" ,
                                txt     = compStr ) ;
          __DBGpr_str("compStr", compStr ) ;

  	  FIfld_set_text( form, COMP_FIELD, 0, 0, compStr, FALSE); /*fill in the name*/
          break;

        case COMP_FIELD:
          FIfld_get_text(form, COMP_FIELD, 0, 0, 76, compStr, &selFlag, &pos);
          break;

        case REV:
          FIfld_get_text(form, REV, 0, 0, 76, revStr, &selFlag, &pos);
	  for ( i=0;i< strlen(revStr);i=i+1){
		revStr[i] = toupper(revStr[i]);
	  }
#ifdef DEBUG
	  printf("finished changing the text to upper case\n");
#endif
          FIfld_set_text(form, REV, 0, 0, revStr, FALSE);
          if(!strcmp(revStr,""))
          { 
  	  	FIfld_set_text( form, REV, 0, 0, "---", TRUE);	
          	status("Fill in a Revision");
          	break;
          }
	  break;

        case TYPE:
          FIfld_get_text(form, TYPE, 0, 0, 6, typeStr, &selFlag, &pos);
	  __DBGpr_str("typeStr", typeStr);
	  default_TYPE = 0;
#ifdef DEBUG
	  printf("finished changing the text to upper case\n");
#endif
          if(!strcmp(typeStr,""))
          { 
  	  	FIfld_set_text( form, TYPE, 0, 0, "---", TRUE);	
          	status("Select a Type");
          	break;
          }
	  break;

        case MAC_LIB:
	  /* FILL IN THE SHAPE LIST */
          FIfld_get_text(form, MAC_LIB, 0, 0, 128, macStr, &selFlag, &pos);
          if(!strcmp(macStr,""))
          { 
  	  	FIfld_set_text( form, MAC_LIB, 0, 0, "---", TRUE);	
	        FIfld_set_list_num_rows( form, SHAPE, 0, 0); 
        	FIfld_set_text( form, SHAPE, 0,0, "",FALSE);
          	status("Select a Macro Library");
          	break;
          }
	  //printf("about to call set_macro_list(%s)\n",macStr);
	  set_macro_list(macStr);

	  break;

        case SHAPE:
          FIfld_get_text(form, SHAPE, 0, 0, 40, shapeStr, &selFlag, &pos);
	  //printf("shape string[%s]\n", shapeStr);
          if(!strcmp(shapeStr,""))
          { 
  	  	FIfld_set_text( form, SHAPE, 0, 0, "---", TRUE);	
          	status("Select a Shape");
          	break;
	  }
 	  set_argu_list(macStr, shapeStr);

	  /* TR179900656  ylong */
	  if(!strcmp(shapeStr,"rd")) {
		strcpy(laStr, "N/A");
  	  	FIfld_set_text( form, LA, 0, 0, laStr, TRUE);	
		FIg_disable(form, LA);
	  }
	  else {
		FIg_enable(form, LA);
		FIfld_set_text(form, LA, 0, 0, "", &selFlag, &pos);
	  }
		
	  break;

        case LA:
          FIfld_get_text(form, LA, 0, 0, 4, laStr, &selFlag, &pos);
	  default_LA = 0;
#ifdef DEBUG
	  printf(" laStr: >%s<\n", laStr);
#endif
          if(!strcmp(laStr,""))
          { 
  	  	FIfld_set_text( form, LA, 0, 0, "-", TRUE);	
          	status("Select a Long Axis Direction");
          	break;
          }
	  break;

	case EXPRESSIONS:
		FIfld_get_num_rows( form, EXPRESSIONS, &k);
		SetLongAxis(k);

	  break;

        case STRUCT_CUT:
          FIfld_get_text(form, STRUCT_CUT, 0, 0, 6, structStr, &selFlag, &pos);
	  default_S_CUT = 0;
          if(!strcmp(structStr,""))
          { 
  	  	FIfld_set_text( form, STRUCT_CUT, 0, 0, "---", TRUE);	
          	status("Select the type of Structure to cut");
          	break;
          }
	  break;

        case DESCRIPTION_FIELD:
          FIfld_get_text(form, DESCRIPTION_FIELD, 0, 0, 1023, descString, &selFlag, &pos);
          if(!strcmp(descString,""))
          { 
  	  	FIfld_set_text( form, DESCRIPTION_FIELD, 0, 0, "---", TRUE);	
          	status("Fill in a Description");
          	break;
          }
	  break;

        case RE_SET:	/* added by ylong for TR179900857 */
	  FIf_reset(form);
  	  VDpenFormSetList( form, TYPE,       "type_list", 1 );
	  VDpenFormSetList( form, STRUCT_CUT, "structure_to_cut", 10 );
	  VDpenFormSetList( form, LA,         "long_axis", 2 );
          disable_form();
          FIg_enable(form, NAME_BTN);
          FIg_enable(form, NAME_FIELD);
          VDpenFormFillInCoordNames( form, NAME_FIELD );

	  break ;

        case RUN:

	  if( !A_penMacro_exists(GRIDS[0]) ) {
		sts = checkAndPlace();
	  }
	  if(sts == 1) {
		UI_status(tmp);
		sprintf(tmp, "A penMacro Placed on %s", csName);
	  }
	  else if( sts == 2 ) {
		break;
	  }
	  else UI_status("Error placing penMacro");
	  disable_form();
	  FIg_enable(form, NAME_BTN);
	  FIg_enable(form, NAME_FIELD);
	  FIg_set_text( form, NAME_FIELD, "");

	  break;

        case ACCEPT:
          
	  if( !A_penMacro_exists(GRIDS[0]) ) {
		sts = checkAndPlace();
		if(sts == 1) UI_status("A penMacro Placed");
		if(sts == 2) break;
	  }
          not_done = 0;        /* Stop the loop  */
          FIf_erase ( form );  /* Erase the form */
          break;

        } /* END switch ( g_label ) */

	/* get default values from form. ylong */
	if( default_TYPE ) {
		FIfld_get_text(form, TYPE, 0, 0, 6, typeStr, &selFlag, &pos);
		default_TYPE = 0;
	}
	if( default_LA ) {
		FIfld_get_text(form, LA, 0, 0, 4, laStr, &selFlag, &pos);
		default_LA = 0;
	}
	if( default_S_CUT ) {
		FIfld_get_text(form, STRUCT_CUT, 0, 0, 6, structStr, &selFlag, &pos);
		default_S_CUT = 0;
	}

    } /* END while ( not done ) */

wrapup:
message("");
prompt("");
if ( exitFlag == 0 ) exit;

}

/**********************************************************/

int LocateObj( inType, inPrompt, selObj, objName, check)
IGRchar	*inType;
IGRchar	*inPrompt;
TGRid	*selObj;
IGRchar	*objName;
IGRint	check;
{
	IGRlong	loc_suc ;
	int	ret ;
 
	ret = 0 ;

	objName[0] = '\0' ;
	ret = loc_obj_exp( &loc_suc, TITLE_STRING, inPrompt, inType, selObj ) ;
	if(!ret ) goto wrapup;

	ret =  VDpenCheckForProperName( *selObj, objName, check ) ;
	if( !ret ) UI_status("Object not named correctly");

wrapup:
	return ret;
}

/********************************************************/

int CreateCollector( inName, outObj )
char	inName[512];
struct GRid *outObj;
{
int	sts;
int	msg;

	outObj[0].osnum = 2;

	sts = om$construct( 
		classname = "ACrg_collect",
		osnum = 2,
		p_objid = &outObj->objid);

	if( strcmp( inName, "") ){

		sts = ci$send( msg = message GRgraphics.GRputname (
			&msg,
			inName),
			targetid = outObj->objid,
			targetos = outObj->osnum );
	}

	return TRUE;
}

/*********************************************************/

IGRint	*list;
IGRint	*lines;
IGRchar	txt[1024];
struct GRid *grobjs;
IGRchar	txt1[40];
IGRint	ele_count;
IGRint	l;
IGRchar	filename[132];
IGRint 	var_size[3];
IGRint	bad_var;
struct EX_var_list	ex_var[4];
extern int EX_get_global();
extern int ACconstruct_path();

IGRint not_default_library ( tmpName )
IGRchar *tmpName;
{
#ifdef DEBUG
	printf("libraries : %s\n", tmpName );
#endif

	if( ! strcmp( tmpName, "SMPrivMac" )) return FALSE;
	if( ! strcmp( tmpName, "VDSmacro" )) return FALSE;
	if( ! strcmp( tmpName, "PPMmacro" )) return FALSE;
	if( ! strcmp( tmpName, "VDSdrw"   )) return FALSE;
	if( ! strcmp( tmpName, "VSfeatures.mc" )) return FALSE;
	if( ! strcmp( tmpName, "VSmacro" )) return FALSE;
	if( ! strcmp( tmpName, "VRfeatures.mc" )) return FALSE;
	if( ! strcmp( tmpName, "VRmacro" )) return FALSE;
	if( ! strcmp( tmpName, "HVmacro" )) return FALSE;
	if( ! strcmp( tmpName, "PidMetLib" )) return FALSE;
	if( ! strcmp( tmpName, "PidImpLib" )) return FALSE;

	return TRUE ;
}


get_attached_macro_libraries()
{
IGRint	i, len, k, m;
char	pathStr[1024];
char	tmpName[128];

#ifdef DEBUG
printf("entering get_attached_macro_libraries()\n");
#endif

// SEARCH THE CURRENT FILES CONSTRUCTS_LIB DIRECTORY FOR MACRO LIB ATTACHMENTS

msg = ac$construct_path(
		mode = AC_INQ,
		path = pathStr,
		path_size = 1023,
		path_len = &len);

FIfld_set_list_num_rows( form, MAC_LIB, 0, 50);
FIfld_set_text( form, MAC_LIB, 0,0, "",FALSE);

#ifdef DEBUG
printf("path[%s], len=%d\n",pathStr, len);
#endif
k=0;
m=0;
for( i=0;i<len;i=i+1){

	if( pathStr[i] == ',' ){
	  tmpName[k] = 0;
	  if( not_default_library ( tmpName ) == TRUE ){
	    FIfld_set_list_default_text( form, MAC_LIB, m,0, tmpName, FALSE);
	    m=m+1;
	  }
	  k=0;
	}else if( i == len -1){
	  tmpName[k] = pathStr[i];
	  tmpName[k+1] = 0;
	  if( not_default_library ( tmpName ) == TRUE ){
	    FIfld_set_list_default_text( form, MAC_LIB, m,0, tmpName, FALSE);
	    m=m+1;
	  }
	  k=0;
	}else{
	  tmpName[k] = pathStr[i];
	  k=k+1;
	}
}
FIfld_set_list_num_rows( form, MAC_LIB, 0, m);

#ifdef DEBUG
printf("exiting get_attached_macro_libraries()\n");
#endif
}

/***********************************************************/

int set_macro_list(macro_lib_name)
IGRchar *macro_lib_name;
{
struct sup 	*xdup;
IGRint		tot_up, prop;
IGRint		k,i;
IGRchar		txt2[128];
IGRint		skip;
IGRint		no_lines;
IGRint		msg;
struct GRid	MACID;

	strcpy(txt2,":");
	strcat(txt2,filename);
	strcat(txt2,":constructs_lib:");
	strcat(txt2,macro_lib_name);
	strcat(txt2,":constructs:");

#ifdef DEBUG
	printf("macro name path[%s]\n",macro_lib_name);
#endif
	
	di$find( start_dir = txt2, 
                 grids = &grobjs,
		 ptr=&ele_count,
                 max_level = 1,
		 lines=&list,
                 options = OPT_LEVEL);

	FIfld_get_num_rows( form, SHAPE, &k);
	for(i=0;i<k;i=i+1){
		FIfld_set_text( form, SHAPE, i,0, "",FALSE);
	}
	FIfld_set_list_num_rows( form, SHAPE, 0, ele_count);
	FIfld_set_text( form, SHAPE, 0,0, "",FALSE);

	k=0;

	for(i=0;i<ele_count;i=i+1)
	{
		di$split ( pathname = (char *)list[i],
			dirname = NULL,
			name = txt1 );

		/* get the macro$def files out */
		if( strchr(txt1,'$') != NULL ) continue;

		/* added by ylong to prevent them from displaying, 03-01-00 */
		if( !strcmp(txt1, "penMacro") || !strcmp(txt1, "pcgMacro") ) 
			continue;

		FIfld_set_list_num_rows( form, SHAPE, 0, k+1);
		FIfld_set_list_default_text( form, SHAPE, k,0, txt1,FALSE);
		k=k+1;
	}
	return(k);

#ifdef DEBUG
printf("exiting set_macro_list()\n");
#endif
}

/************************************************************/

int set_argu_list(macro_lib_name, macro_name)
IGRchar *macro_lib_name;
IGRchar *macro_name;
{
struct sup 	*xdup;
IGRint		tot_up, prop;
IGRint		k,i,m;
IGRchar		txt2[128];
IGRint		skip;
IGRint		no_lines;

	FIfld_set_list_num_rows( form, EXPRESSIONS, 0, 0);
	FIfld_set_text( form, EXPRESSIONS, 0,0, "",FALSE);
		
	FIfld_get_num_rows( form, EXPRESSIONS, &k);
	for(m=0;m<k;m=m+1){
		FIfld_set_text( form, EXPRESSIONS, m,0, "",FALSE);
		FIfld_set_text( form, EXPRESSIONS, m,1, "",FALSE);
	}

	for(i=0;i<ele_count;i=i+1)
	{
		strcpy(txt1,(char*)list[i]);

 		di$split ( pathname = (char *)list[i],
                	  dirname = NULL,
                  	  name = txt1 );

		/* get the macro$def files out */

           	if( strchr(txt1,'$') != NULL ) continue;

		#ifdef DEBUG
		printf("%s\n",txt1);
		#endif

		if( strcmp( macro_name, txt1) == 0){

			ci$send( msg = message ACmacro_defn.ACgive_upscan(
				&tot_up, &prop, &xdup),
				targetid = grobjs[i].objid,
				targetos = grobjs[i].osnum);

			//printf("%s has %d templates\n", txt1, tot_up);

			FIfld_set_list_num_rows( form, EXPRESSIONS, 0, tot_up);
			
			num_exps=0;

			for(l=0;l<tot_up;l=l+1){

				if( xdup[l].type == 65552 ||  xdup[l].type == 131088 ){
					FIfld_set_text( form, EXPRESSIONS, num_exps,0, 
								xdup[l].prompt,FALSE);
					FIfld_set_text( form, EXPRESSIONS, num_exps,1, 
									"",FALSE);
					num_exps=num_exps+1;
				}
			}
			break;
		}
	}
return(k);

#ifdef DEBUG
printf("exiting set_macro_list()\n");
#endif
}

/********************************************************/

get_current_file_name_and_mod_env()
{

#ifdef DEBUG
printf("entering get_current_file_name_and_mod_env()\n");
#endif
// GET THE CURRENT FILE NAME

	var_size[0] = sizeof(filename);
	ex_var[0].var = EX_CUR_FILENAME;
	ex_var[0].var_value = &filename[0];
	ex_var[0].num_bytes = &var_size[0];
	var_size[1] = NULL;

	msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

	#ifdef DEBUG
	printf("filename[%s]\n",filename);
	#endif

 	ci$get_module_info( md_env = &MOD_ENV);

#ifdef DEBUG
printf("exiting get_current_file_name_and_mod_env()\n");
#endif
}

/**************************************************************************/

int	checkExpValues( )
{
int	m, k, selFlag, pos, msg;
char	chkval[80], tmp[80];
struct GRid	EXP_GRid;

	for(m=0;m<num_exps;m=m+1){

		FIfld_get_text( form, EXPRESSIONS, m, 0, 80, tmp, &selFlag, &pos);
		FIfld_get_text( form, EXPRESSIONS, m, 1, 80, chkval, &selFlag, &pos);
		if ( strcmp( chkval, "") == 0 && strcmp( tmp, "") != 0 ){

			sprintf( chkval,"Key in a value for the %s field",tmp);
			status(chkval);
			//printf("%s\n",chkval);
			pos = 0;
 			FIfld_pos_cursor( form, EXPRESSIONS, m, 0, 1, 0, 0, 0 );
			return m+1;
		}
	}
	return 0;
}

/*****************************************************************/

int	placeMacro()
{

struct	GRid		NEW_MAC;
struct	GRmd_env	MOD_ENV;
char	cRep;
int	msg, sts;


	ci$get_module_info( md_env = &MOD_ENV);

	NEW_MAC.objid = NULL_OBJID;
	NEW_MAC.osnum = MOD_ENV.md_id.osnum;

	#ifdef DEBUG
	printf("mac: %d, %d\n", NEW_MAC.objid, NEW_MAC.osnum);
	printf("ids =%d, %d, %d\n", GRIDS[0].objid, GRIDS[1].objid, GRIDS[2].objid);
	printf("idos=%d, %d, %d\n", GRIDS[0].osnum, GRIDS[1].osnum, GRIDS[2].osnum);
	#endif

	VDSloadMacroLibrary( "avpencont.lib" );

	sts = ci$send(msg = message  nci_macro.init( 
		&msg, 
		0,
		"penMacro", 
		3,
		GRIDS,  
		0,
		&MOD_ENV),
		targetid = NEW_MAC.objid,
		targetos = NEW_MAC.osnum );

#ifdef DEBUG
	printf("nci_macro.init msg=%d, sts=%d, macroid[%d,%d]\n",
			msg, sts, NEW_MAC.objid, NEW_MAC.osnum);
#endif
		
	if(!(sts & msg & 1)) 
	{

		printf("Error placing macro %s\n",shapeStr);
		printf("sts: %d, msg: %d, objid: %d\n", sts, msg, NEW_MAC.objid);
		status("is the macro \"penMacro\" available?");
		printf("make sure the macro library with penMacro is loaded"); 
		return FALSE;

	}else{
		/* name it here */
		putName( &NEW_MAC , FALSE);

	}

	return TRUE;

}

/*********************************************************************/

#define EXP_DOUBLE 0
extern		UI_status();
/***********************************************************/

int	putName( InGrid , hide)
struct GRid	*InGrid;
int		hide;
{
char	tmpname[128];
int	msg;
int	stat;


	if ( hide == FALSE){

		//sprintf( tmpname,"M%d%d",InGrid->objid, InGrid->osnum);	

		stat = ci$send( msg = message GRvg.GRputname(
			&msg,
			penName),
			targetid = InGrid->objid,
			targetos = InGrid->osnum);

		if ( !(stat&msg&1) ) return FALSE;
	}
	return TRUE;
}



/*****************************************************************/

int checkAndPlace(){
  int	msg, m, i;
  int	pos;
  int   selFlag;
  int	exitFlag;
  int	numAttrs;
  int	sts;
  char	chkval[80];
  char  expnam[80];
  char  objname[80];

	sts = 0;

	FIg_get_text(form, DESCRIPTION_FIELD, descString);

	if ( checkExpValues() != 0) return 2;

	if(!strcmp(macStr,"")){ 
		status("Fill in macro library");
		return 2;
	}

	/* it is optional
	if(!strcmp(compStr,"")){ 
		status("Fill in compartment");
		return 2;
	}
	*/

	if(!strcmp(shapeStr,"")){ 
		status("Fill in shape");
		return 2;
	}

	if(!strcmp(revStr,"")){ 
		FIfld_pos_cursor(form, REV, 0, 0, 0, 0, 0, 0);
		status("Fill in revision");
		return 2;
	}

	if(!strcmp(descString,"")){ 
		FIfld_pos_cursor(form, DESCRIPTION_FIELD, 0, 0, 0, 0, 0, 0);
		status("Fill in a description");
		return 2;
	}

	CreateCollector( "", &GRIDS[2] );

	i=0;
	strcpy(collAttrs[i].name, "compartment");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, compStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "revision");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, revStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "macro_lib");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, macStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "shape"); 
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, shapeStr);
	
	i=i+1;
	strcpy(collAttrs[i].name, "type");
	collAttrs[i].desc.type = 1; 
	strcpy(collAttrs[i].desc.value.att_txt, typeStr);

	i=i+1;
	strcpy(collAttrs[i].name, "structure_to_cut");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, structStr);

	i=i+1;
	strcpy(collAttrs[i].name, "long_axis");
	collAttrs[i].desc.type = 1; 	
	SetLongAxis(num_exps);
	FIfld_get_text(form, LA, 0, 0, 4, laStr, &selFlag, &pos);
	strcpy(collAttrs[i].desc.value.att_txt, laStr);

	i=i+1;
	strcpy(collAttrs[i].name, "description");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, descString);

	i=i+1;

	sts = ci$send(	msg = message ACrg_collect.ACadd_list_attribute(
						&msg, i, collAttrs),
			targetid = GRIDS[2].objid,
			targetos = GRIDS[2].osnum);
		
	#ifdef DEBUG
	printf("add list sts=%d, msg=%d\n",sts,msg);
	#endif

	CreateCollector( "", &GRIDS[1] );

	strcpy(collAttrs[0].name, "macro_name");
	collAttrs[0].desc.type = 1; 	
	strcpy(collAttrs[0].desc.value.att_txt, shapeStr); 

	for(m=0;m<num_exps;m=m+1){

		strcpy(chkval, "");
		FIfld_get_text( form, EXPRESSIONS, m, 0, 80, expnam, &selFlag, &pos);
		FIfld_get_text( form, EXPRESSIONS, m, 1, 80, chkval, &selFlag, &pos);
		strcpy(collAttrs[m+1].name, expnam);
		collAttrs[m+1].desc.type = 2; 	
		collAttrs[m+1].desc.value.att_exp = atof(chkval); 
	}

	sts = ci$send(	msg = message ACrg_collect.ACadd_list_attribute(
					&msg, num_exps+1, collAttrs),
			targetid = GRIDS[1].objid,
			targetos = GRIDS[1].osnum);
		
	sts = placeMacro();

	return (sts&1);
}

/********************************************************************
 * It is used to test if a penMacro exsits, attached to ASsource cs.
 *  by ylong
 */
int A_penMacro_exists(objID) 
	TGRid	objID;
{

	IGRint			i ;
	GRclassid		classid;
	struct	GRid		*foundIds;
	struct	GRid		OldCoord;
	struct	GRobj_env	OBJ_ENV;
	OM_S_CHANSELECT		my_chansel;
	IGRchar			csName[80], tmpStr[128];

	IGRint	penFlag;
	IGRint	num_found;
	IGRlong	sts, msg;

	penFlag = 0;
	num_found = 0;
	foundIds = NULL ;

        sts = om$make_chanselect(channame     = "GRnotify.notification",
                                 p_chanselect = &my_chansel);

        if( !(sts & 1) ) goto wrapup;

        classid = OPP_ASsource_class_id ;
        sts = VDGetGridsFromChan_of_Class (
                                        &msg,
                                        objID,
                                        &my_chansel,
                                        classid,
                                        &num_found,
                                        &foundIds ) ;
        #ifdef DEBUG
        printf("VDGetGridsFromChan_of_Class: msg = %d, sts = %d\n",msg,sts);
        printf("Number of objs on channel: %d\n", num_found);
        for( i = 0; i < num_found; i = i + 1 ) {
                printf(" foundIds[%d] = [%d, %d]\n",
                         i, foundIds[i].objid, foundIds[i].osnum);
        }
        #endif

        if( !(sts & 1) || !(msg &1) || num_found <= 0) goto wrapup;

        sts = ci$send(  msg = message NDmacro.ACreturn_foot(
                        &msg,
                        "",
                        &OldCoord,
                        &OBJ_ENV.mod_env.md_env.matrix_type,
                        OBJ_ENV.mod_env.md_env.matrix),
                        targetid = foundIds[0].objid,
                        targetos = foundIds[0].osnum);

        if( !(sts & 1) || !(msg &1) ) {
                #ifdef DEBUG
                printf("NDmacro.ACreturn_foot: msg=%d, sts=%d\n", msg,sts);
                #endif
                goto wrapup;
        }

        /*
         * Check if a macro penMacro attached to ASsource cs. by ylong
         */
        OBJ_ENV.obj_id.objid = OldCoord.objid;
        OBJ_ENV.obj_id.osnum = OldCoord.osnum;
        penFlag = vdefp$GetAttachedMacro(       macName = "penMacro",
                                                tplOEs  = &OBJ_ENV) ;
wrapup:
        if( penFlag ) {
 	  gr$get_name(	GRid_in = OldCoord, name = csName);
	  sprintf(tmpStr,"A pen macro already exists on %s.",csName);
          status(tmpStr);
        }

	_FREE( foundIds );
	return penFlag ;
}

