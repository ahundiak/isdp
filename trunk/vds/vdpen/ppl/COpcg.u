/* $Id: COpcg.u,v 1.5 2001/10/16 13:51:37 ylong Exp $  */
/* --------------------------------------------------------------------
 * I/VDS
 *
 * File:        vds/vdpen/ppl/COpcg.u
 *
 * Description:
 *
 * Dependencies:
 *
 * Revision History:
 *      $Log: COpcg.u,v $
 *      Revision 1.5  2001/10/16 13:51:37  ylong
 *      Replace built-in lists with vds/config/penetrations/DataList
 *
 *      Revision 1.4  2001/10/11 15:36:21  ylong
 *      TR5493
 *
 *      Revision 1.3  2001/05/16 16:25:42  ylong
 *      CR5211
 *
 *      Revision 1.2  2001/01/19 22:30:56  jayadev
 *      *** empty log message ***
 *
# Revision 1.9  2000/07/17  22:07:56  pinnacle
# misc fixes
#
# Revision 1.7  2000/06/23  18:16:24  pinnacle
# ylong
#
# Revision 1.6  2000/06/15  17:16:26  pinnacle
# ylong
#
# Revision 1.2  2000/04/29  17:47:00  pinnacle
# Replaced: vds/vdpen/ppl/COpcg.u for:  by rchennup for Service Pack
#
# Revision 1.15  2000/04/01  15:32:36  pinnacle
# ylong
#
# Revision 1.14  2000/03/21  22:38:30  pinnacle
# ylong
#
# Revision 1.13  2000/03/16  14:15:30  pinnacle
# refined for CR179901115
#
# Revision 1.11  1999/12/29  16:18:20  pinnacle
# TR179900986
#
# Revision 1.10  1999/12/03  16:49:40  pinnacle
# revised for misc
#
# Revision 1.9  1999/08/12  21:34:08  pinnacle
# ylong
#
# Revision 1.8  1999/06/08  19:02:56  pinnacle
# ylong
#
 *
 * History:
 *      MM/DD/YY        AUTHOR          DESCRIPTION
 *      05/31/99        ylong           TR179900655
 *      06/01/99        ylong           TR179900657
 *      08/12/99        ylong           CR179900794
 *      12/03/99        ylong           TR179900968
 *      12/28/99        ylong           TR179900986
 *      03/15/00        ylong           CR179901115
 *      03/20/00        ylong           TR179901189
 *      04/01/00        ylong           Change "Identify Deck Plane" to
 *                                      "Identify Deck Surfce or Plane"
 *	06/05/00	ylong		TR179901626, TR170091625, TR179901614
 *					CR179901628, CR179901629
 * -------------------------------------------------------------------*/
/************************************************************
 * PENETRATION CONTROL GROUP pcg
 * FILE:  	pcg.u
 * PURPOSE:  This PPL command will place a pcg macro
 * on a penMacro occurance
 *
 * DESCRIPTION: This command file controls a form that lets
 *    	the user select many options and places a macro on it
 *
 * NOTE:
 *
 ************************************************************/

/*
#define  DEBUG
#define  vdsDEBUG
*/

#include "FI.h"
#include "VDppl.h"
#include "VDgeom.h"
#include "VDefp.h"
#include "v_geommacros.h" 
#include "VDmem_ppl.h"
#include "v_dbgmacros.h"
#include "VDSudp_mac.h"
#include "vdAPImacros.h"
#include "vdrefmacros.h"
#include "vdsmacros.h"
#include "ci_mac_def.h"


#include "msdef.h"
/************************************************************
  Constants for the form.
 ************************************************************/
#define FORM_LABEL 100  /* Arbitrary Number for Form */
#define FORM_NAME  "VDpcg.frm"  /* Form File */
#define TITLE_STRING "Penetration Control"


#define ACCEPT		1
#define RUN		2
#define CANCEL		4
#define FORM_TITLE	11
#define PEN_FIELD	12
#define EXPRESSIONS	14
#define PS_FIELD	15
#define ABL_FIELD	16
#define XY_FIELD	17
#define XY_BTN		24
#define CUT_FIELD	19
#define APPROV_FIELD	20
#define REF_DECK_FIELD	21
#define FA_DIST_FIELD	23
#define FA_FIELD	27
#define FA_LOC_BTN	32
#define PEN_LOC_BTN 	33
#define OBJ_FIT_BTN	25
#define EXPR_DATA_FIELD 26
#define RESET_EXP_BTN	28

#define MAX_TEMPS	100


/************************************************************
  External functions.
 ************************************************************/
extern VDpenFormFillInObjNames();
extern VDSloadMacroLibrary();
extern ci_notification();  /* The forms system automatically calls    */
                           /* this function, which in turn calls your */
                           /* form_notification function              */

extern FIf_set_cmd_oid_os();  /* This function tells the forms system */
                              /* to notify this command file when the */
                              /* user manipulates the form */

extern FIf_new();        /* Creates the form              */
extern FIf_display();    /* Draws the form                */
extern FIf_erase();      /* Erases the form               */
extern FIf_delete();     /* Removes the form              */
extern FIf_reset();
extern FIg_get_value();  /* Retrieves values from gadgets */
extern int FIg_display ();
extern int FIg_erase ();
extern int FIfld_set_text ();
extern int FIfld_get_text ();
extern int FIfld_set_list_text ();
extern int FIg_set_text ();
extern int FIg_set_state_on();
extern int FIg_set_state_off();
extern int FIg_enable();
extern int FIg_disable();
extern int GRdpb_get();
extern int ASmake_source_from_env();
extern int FIfld_set_list_num_rows();
extern int FIfld_set_num_rows();
extern int FIfld_get_num_rows();
extern int FIfld_set_mode();
extern int FIfld_set_list_default_text();
extern int EX_filename1();
extern int toupper();
extern int FIfld_pos_cursor();
extern int FImcf_get_select();

extern int VDGetGridsFromChan_of_Class();
extern GRclassid OPP_ACconst_class_id;
extern GRclassid OPP_nci_macro_class_id;
extern GRclassid OPP_ACpretendin_class_id;

extern int VD_findFileInDirOrProductPaths();
extern FILE* VD_openFile();
extern VD_drwGetACcpxInfo();
extern BSpj_pt_sf() ;
extern BSproj1() ;
extern GRdisplay_object();
extern VDpms_findall_ancestryobjects();
extern VDpenFormSetExpList();
extern VDpenFormSetList();
extern VDpenGetOrigAttr();

/************************************************************
  Global variables.
 ************************************************************/
int test_wakeup;  /* The wakeup function uses this flag to
                     test if the main function has started yet. */

int form_exists,    /* The delete function uses this flag
                       to test if the form exists */
    form_displayed, /* The sleep function uses this flag
                       to test if the form is displayed */
    not_done;       /* This value is set to 0 when the user
                       selects the cancel or exit & save buttons */

Form form;  /* Use this variable for the forms functions. */

struct CIform_st form_st; /* This structure contains information on
                             which form and gadget was manipulated. */


struct ACrg_coll  collAttrs[50];
struct GRid	 GRIDS[4];

IGRint	notlocal;
IGRint	num_exps;
IGRint  expRow;

IGRchar	formStr[40];
IGRchar	penStr[80];
IGRchar	cutTypStr[80];
IGRchar	approvStr[80];
IGRchar	refStr[128];
IGRchar	planeStr[128];
IGRchar	psStr[128];
IGRchar	commentString[80];
IGRchar xyStr[80];
IGRchar deckStr[80];
IGRchar pcgStr[80];
IGRchar coordname[128];
IGRchar structCut[80];
IGRchar expTypStr[80];

IGRdouble	ablDbl, xyDbl, psDbl, faDbl;
IGRdouble	cm[16];

struct GRid	NEW_MAC;
struct GRid	PENMAC;
struct GRid	PENPRET;
struct GRid	OldCoord,
		NewCoord,
		TEMPS[3],
		OldPret,
		NewPret,
		TEMPOBJ;

struct	GRid	deckSurf;

struct GRid	PENCOLL;

IGRdouble GetFALocation(plane)
struct GRid plane;
{
	IGRint	msg, sts,i;
	struct IGRplane plane_def;
	struct GRmd_env	plane_env;
	double	pnt[3];
	double  nrm[3];
	double  fa;

	ci$get_module_info( md_env = &plane_env);

	plane_def.point = pnt;
	plane_def.normal = nrm;

	sts = ci$send( msg = message GRvg.GRdetplane (
			&msg,
			&plane_env.md_env.matrix_type,
			plane_env.md_env.matrix,
			&plane_def),
			targetid = plane.objid,
			targetos = plane.osnum );
	#ifdef DEBUG
	printf("EMSplane.EMplaneDef msg=%d, sts=%d\n", msg, sts);
	printf("PLANE def\n");
	printf("pnt %.3fX, %.3fY, %.3fZ\nnrm %.3fX, %.3fY, %.3fZ\n", 
		plane_def.point[0],
		plane_def.point[1],
		plane_def.point[2],
		plane_def.normal[0],
		plane_def.normal[1],
		plane_def.normal[2]);
	#endif

	fa =cm[3] - plane_def.point[0];
	return (fa);
}

void return_error()
/************************************************************
 * FUNCTION:  return_error()
 *
 * DESCRIPTION: This function exits the PPL command file.
 ************************************************************/
{
  status("");   /* Clear the status field  */
  message("");  /* Clear the message field */
  exit;
}


void form_init()
/************************************************************
 * FUNCTION:  form_init()
 *
 * DESCRIPTION: This function initializes the form.
 ************************************************************/
{
  int error;

 /*************************
   Create (load) the form.
  *************************/
   error = FIf_new ( FORM_LABEL, FORM_NAME, ci_notification, &form );
  if ( form == NULL ) 
    {
      write( "Could not create the form.\n",
             "Error code = ",  error,  "\n"  );
      return_error();
    }

  form_exists = TRUE;  /* Flag for delete function */

 /**********************************************
   Tell the Forms System to notify this command
   file when the user manipulates the form.
  **********************************************/
  error = FIf_set_cmd_oid_os( form, MY_ID, OM_Gw_current_OS );
  if ( error )
    {
      write( "Could not link to the Forms System.\n",
             "Error code = ",    error,         "\n"  );
      form_exists = FALSE;
      return_error();
    }

  /* Set the title on the form */
  FIg_set_text( form, FORM_TITLE, formStr);

 /*******************
   Display the form.
  *******************/
  
  error = FIf_display( form );
  if ( error )
    {
      write( "Could not display the form.\n",
             "Error code = ",  error,   "\n"  );
      return_error();
    }

  form_displayed = TRUE;  /* Flag for sleep function */
}


int form_notification( )
/************************************************************
 * FUNCTION:  form_notification()
 *
 * DESCRIPTION: The forms system automatically calls this
 *   function when the user manipulates a gadget on the form.
 *
 * RETURNS: none
 ************************************************************/
{
  char outString[80];
  
  ci$put( response = MOVE_ON );  /* Give control to the main function */
}


wakeup ()
/************************************************************
 * FUNCTION:  wakeup()
 *
 * DESCRIPTION: This function is called when the command file
 *    is started and when it resumes after an interruption.
 ************************************************************/
{
  /* Display the form unless the command file is just starting */
  if ( test_wakeup == 1 && not_done )
    {
      FIf_display ( form );  /* Redisplay the form */
      form_displayed = TRUE; /* Set flag for sleep function */
    }
}

sleep ()
/************************************************************
 * FUNCTION:  sleep()
 *
 * DESCRIPTION: This function is called immediately before the
 *    command file is interrupted.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
  {
    FIf_erase ( form );
    form_displayed = FALSE;
  }
}


delete ()
/************************************************************
 * FUNCTION: delete()
 *
 * DESCRIPTION: This function is called when the command file
 *    ends or is terminated.
 ************************************************************/
{
  /* Erase the form if it is displayed */
  if ( form_displayed == TRUE )
    {
      FIf_erase ( form );
      form_displayed = FALSE;
    }

  /* Delete the form if it exists */
  if ( form_exists )
      FIf_delete( form );
}

IGRboolean checkForProperName( selObj, objName, check )
struct GRid selObj;
IGRchar	*objName;
IGRint	check;
{
	double pnt[3];
	char	junk[80], junk1[80];
	char	fullName[128];
	int	ret;

	objName[0] = 0;

 	gr$get_name(	GRid_in = selObj, 
			full_name = fullName,
		 	name = objName);

	#ifdef DEBUG
	printf("Selected object name is %s, [%s]\n",objName, fullName);
	#endif

	if(!strcmp(objName,"") && check == TRUE) 
	{
		strcpy(commentString, "This object is not named");
		return FALSE;
	}

	if ( check == TRUE ){

	  if( strlen(objName) != 9 ){
		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  if( objName[0] != 'P' && objName[0] != 'V' && 
	    objName[0] != 'E' && objName[0] != 'M' ){

		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }

	  if( objName[5] != '-' ){

		sprintf(commentString, "[%s] is not a proper name", objName);
		return FALSE;
	  }
	}
	return TRUE;
}


/**************************************************************************/
IGRlong GetObjByName( objName, className, objID )
IGRchar *objName ;
IGRchar *className ;
TGRid   *objID ;
{
IGRlong         ret ;
IGRlong         sts ;
IGRint          i, j, index, nb_obj;
GRspacenum      cur_osnum;
GRclassid       classid ;
GRobjid         *obj_list ;
TGRid           id ;
int             NbRefOs;
GRspacenum      main_os, *RefOsList;
char            name[128], pathName[128] ;

        ret = 0 ;
        main_os = 2 ;
        NbRefOs = 0 ;
        obj_list = NULL  ;
        RefOsList = NULL ;

	UI_status("Searching for object. Please wait ...");

	/* get obj from current active file */
	objID->objid = NULL_OBJID ;
	vds$translate(	objname = objName, 
			p_objid = &objID->objid,
			p_osnum = &objID->osnum );
	if( objID->objid != NULL_OBJID ) {
		ret = 1;
		goto wrapup ;
	}

	/* if obj not in active file, try ref files */

        sts = om$get_classid (  classname = className ,
                                p_classid = &classid);
        if( !(sts&1) ) {
                printf("om$get_classid failed\n");
                goto wrapup ;
        }

        sts = vd$get_ref_os_list (      msg           =  &msg,
                                        main_os       =  &main_os,
                                        num_ref_os    =  &NbRefOs,
                                        ref_os_list   =  &RefOsList );
        __DBGpr_int("NbRefOs", NbRefOs);
for(i = 0; i < NbRefOs; i = i+1 ) {
        nb_obj = 0 ;
        __DBGpr_int("RefOsList", RefOsList[i]);
        sts = VDpms_findall_ancestryobjects (
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        NULL);
        __DBGpr_int("nb_obj", nb_obj);
        if( !(sts&1) || !nb_obj ) {
                __DBGpr_com("VDpms_findall_ancestryobjects failed 1");
                continue;
        }

        obj_list = NULL ;
        obj_list = _CALLOC( nb_obj, GRobjid ) ;
        if( obj_list == NULL ) {
                printf("_CALLOC failed for obj_list\n") ;
                goto wrapup ;
        }

        sts = VDpms_findall_ancestryobjects(
                                        RefOsList[i],
                                        1,
                                        &classid,
                                        &nb_obj,
                                        obj_list);
        if( !(sts&1) || !nb_obj ) {
                __DBGpr_com("VDpms_findall_ancestryobjects failed 2");
                continue;
        }

        id.osnum = RefOsList[i];
        for(j = 0; j < nb_obj; j = j + 1 ) {
                id.objid = obj_list[j] ;
                name[0] =  '\0' ;
		gr$get_name(    GRid_in = id,
				name = name);
                if( !strcmp(objName, name) ) {
                        *objID = id ;
                        ret = 1;
                        goto wrapup ;
                }

        }
        _FREE( obj_list ) ;
        obj_list = NULL ;
}

        ret = 1 ;
wrapup:
        _FREE( obj_list ) ;
        _FREE(RefOsList);
        //printf(">> Exit VStransEdgeToEJ_Bevel <<\n");
	UI_status(" ");
        return ret ;
}


#ifdef DEBUG
#define TRACE(txt)	write("ci_mac_bib: ", txt, '\n');
#else
#define TRACE(txt)  ;
#endif

#define EXP_DOUBLE 0

/*======================================================================*/
/*      locate an object or a expression				*/
/* copied & modified from vds/cimacros/wireframe/macros/ci_mac_bib.u	*/
/*======================================================================*/

int loc_obj_exp( loc_suc, loc_message, loc_prompt, 
                 class_obj,EXP_GRid )

int		*loc_suc;       /* return status			    */
char		loc_prompt[80];	/* prompt to ask the name of the expression */
char		loc_message[80];/* prompt to set the message field          */
struct GRid	*EXP_GRid;	/* return objid & osnum of the expression   */
char		*class_obj;	/* classes filter for located object	    */


{

char		exp_name[80];
char		*exp_value, msg_string[128] ;
int		stat, mask, response, count;
short		sender_class;

struct GRmd_env	MOD_ENV;
struct GRevent	event;

extern ASmake_source_from_env();


        message(loc_message);

	ci$get_module_info(md_env = &MOD_ENV);

step0:

	EXP_GRid->objid = NULL_OBJID;

	mask = GRm_RJT_MOVEON | GRm_BACK_UP | GRm_STRING | GRm_DATA | GRm_OBJID;

        do
        {
        
           *loc_suc = ci$getevent( prompt = loc_prompt, response = &response,
	     			   data   = exp_value,  mask     = mask,
				   event = &event,
				   stackable = 1 );

           if( (response == EX_RJT_MOVEON) || (response == EX_BACK_UP ) )
           {
		*loc_suc = 0; 
                return(0);
           }
        }while( *loc_suc != 1 );

/* we got an object via the navigate graph */

	if( response == EX_OBJID )
        {
	  om$get_classid( osnum     = event.located_object[0].located_obj.osnum,
			  objid     = event.located_object[0].located_obj.objid,
			  p_classid = &sender_class );

	  stat = om$is_ancestry_valid( subclassid     = sender_class,
				       superclassname = "expression" );
	  if( stat  != 1 ) goto step0;
	  EXP_GRid->objid = event.located_object[0].located_obj.objid;
	  EXP_GRid->osnum = event.located_object[0].located_obj.osnum;
 	  *loc_suc = 2; 
	  return(1);
        }

/* we recieved a data point to locate an abject */

        if ( response == DATA )
        {
		ci$put( point = (double *)exp_value );
		if ( !ci$locate( prompt = loc_prompt,
                                 owner_action = LC_RIGID_COMP
                                              | LC_RIGID_OWNER | LC_FLEX_COMP
                                              | LC_FLEX_OWNER  | LC_REF_OBJECTS,
				 obj    = &(EXP_GRid->objid), 
				 osnum  = &(EXP_GRid->osnum),
				 md_env = &MOD_ENV,
				 classes= class_obj,
				 stackable = 1 ))
        	{
             		EXP_GRid->objid = NULL_OBJID;
             		*loc_suc = 0;
                        return(0);
        	}
		else
		{
			*loc_suc = 1;
                        return(1);
		}
        }

/* we recieved a data point to locate an abject */

	else if ( response == STRING )
        {
		strcpy(exp_name, exp_value);
		if(exp_name[0] == 0 ) goto step0;

		GetObjByName( exp_name, class_obj, EXP_GRid);
		__DBGpr_obj("EXP_GRid", *EXP_GRid);
          	if ( (EXP_GRid->objid) == NULL_OBJID )
          	{
			sprintf(msg_string, "Macro \"%s\" not found", exp_name);
			UI_status(msg_string);
			goto step0 ;
	  	} 

		gr$display_object(object_id = EXP_GRid, mode  = GRhd );
		*loc_suc = 2;
		return(1);
	} /* end of process string */

}


/************************************************************
 * Added for CR179901115 by ylong
 */
IGRstat	GetDeckDist( surfID, point, distStr ) 
TGRid		surfID;
IGRdouble	*point;
IGRchar		*distStr;
{
	IGRstat		retFlag ;
	IGRlong		sts, msg ;
	TGRmd_env	env;
	IGRdouble	dist ;
	IGRdouble	*u, *v ;
	IGRpoint	*proj_pts;	
	IGRdouble	vector[3] ;
	IGRint		num_pts ;
	TGRbsp_surface	*surf ;
	BSrc		rc ;
	GRrange		range ;
        IGRdouble       prj_pnt[3], pl_pnt[3], pl_nrm[3];
        struct IGRplane plane;

	retFlag = 0 ;
	surf	= NULL ;
	u	= NULL ;
	v	= NULL ;
	proj_pts[0]= NULL ; // proj_pts = NULL caused compile error

	ci$get_module_info( md_env = &env);

	vd_$get_geometry(msg	 = &msg,
			grobjId  = &surfID,
			grobjEnv = &env ,
			geometry = &surf ) ;

	if ( !(msg & 1) || surf == NULL) {
		printf("vs$get_geometry failed for surf\n");
		goto wrapup;
	}

	vd_$getSurfaceRange(	msg	= &msg ,
				surface	= &surfID,
				range	= range ) ;
	if( !(msg&1) ) range[2] = 0 ;

	__DBGpr_vec("point", point);
	__DBGpr_vec("range 1", &range[0] ) ;
	__DBGpr_vec("range 2", &range[3] ) ;

	vector[0] = 0 ;
	vector[1] = 0 ;
	if( point[2] <= range[2] )	vector[2] = 1 ;
	else				vector[2] = -1 ;

	BSpj_pt_sf(surf, point, vector, &num_pts, proj_pts, &u, &v, &rc);
	if( rc != BSSUCC || num_pts < 1 ) {
           plane.point  = (IGRdouble *)&pl_pnt[0];
           plane.normal = (IGRdouble *)&pl_nrm[0];

           pl_nrm[0] = pl_nrm[1] = pl_nrm[2] = 0.0;
           sts = ci$send( msg = message GRvg.GRdetplane(
                                        &msg,
                                        &env.md_env.matrix_type,
                                        env.md_env.matrix,
                                        &plane ),
                        targetid = surfID.objid,
                        targetos = surfID.osnum  );
           if( !(sts&1&msg) )
           {
                UI_status("Surface is not straight above pcg macro");
                strcpy( distStr, "") ;
                goto wrapup ;
           }
           BSproj1( &rc, point, pl_nrm, pl_pnt, prj_pnt );
           if( rc != BSSUCC )
           {
                UI_status("Surface is not straight above pcg macro");
                strcpy( distStr, "") ;
                goto wrapup ;
           }
           dist = prj_pnt[2] - point[2] ;
        }
        else    dist = proj_pts[0][2] - point[2] ;

	if( dist >= 0. ) {
		sprintf( distStr, "X = %0.2f", dist ) ;
	}
	else {
		sprintf( distStr, "Y = %0.2f", -dist ) ;
	}

	__DBGpr_str("distStr", distStr);

	retFlag = 1 ;
wrapup:
	_FREE( surf ) ;
	_FREE( proj_pts[0] ) ;
	_FREE( u ) ;
	_FREE( v ) ;
	return retFlag ;
}

void enable_form()
{
        FIg_enable( form, CANCEL);
        FIg_enable( form, ACCEPT);
        FIg_enable( form, RUN);
        FIg_enable( form, FORM_TITLE);
        FIg_enable( form, PEN_FIELD);
        FIg_enable( form, EXPRESSIONS);
        FIg_enable( form, PS_FIELD);
        FIg_enable( form, ABL_FIELD);
        FIg_enable( form, XY_FIELD);
        FIg_enable( form, XY_BTN);
        FIg_enable( form, CUT_FIELD);
        FIg_enable( form, APPROV_FIELD);
        FIg_enable( form, REF_DECK_FIELD);
        FIg_enable( form, FA_DIST_FIELD);
        FIg_enable( form, FA_FIELD);
        FIg_enable( form, FA_LOC_BTN);
        FIg_enable( form, PEN_LOC_BTN );
	FIg_enable( form, OBJ_FIT_BTN );
	FIg_disable( form, EXPR_DATA_FIELD );
}

void disable_form()
{
        //FIg_disable( form, CANCEL);
        FIg_disable( form, ACCEPT);
        FIg_disable( form, RUN);
        FIg_disable( form, FORM_TITLE);
        FIg_disable( form, PEN_FIELD);
        FIg_disable( form, EXPRESSIONS);
        FIg_disable( form, PS_FIELD);
        FIg_disable( form, ABL_FIELD);
        FIg_disable( form, XY_FIELD);
        FIg_disable( form, XY_BTN);
        FIg_disable( form, CUT_FIELD);
        FIg_disable( form, APPROV_FIELD);
        FIg_disable( form, REF_DECK_FIELD);
        FIg_disable( form, FA_DIST_FIELD);
        FIg_disable( form, FA_FIELD);
        FIg_disable( form, FA_LOC_BTN);
        FIg_disable( form, PEN_LOC_BTN );
	FIg_disable( form, OBJ_FIT_BTN );
	FIg_disable( form, EXPR_DATA_FIELD );
	FIg_disable( form, RESET_EXP_BTN );
}

main()
/************************************************************
 * FUNCTION: main()
 *
 * DESCRIPTION: This function is the startup function when the
 *      DocPre command is executed.
 ************************************************************/


{

  int 	response;     
  int	iSwitch;
  int	i;
  int	m;
  int	msg;
  int	pos;
  int   selFlag;
  int	exitFlag;
  int	numAttrs;
  int	sts;
  int	k;
  int 	error;
  int 	default_cut;

  double dSwitch;
  double dDiameter;
  double dWidth;
  double dDepth;
  double dRadius_corner;

  GRobj	pplFileId;

  struct GRid	csObj;
  struct GRid	planeObj;
  struct GRid	CollID, objID;
  struct GRid	winID ;

  char	NameToGive[128];
  char	someString[80];
  char	objName[128], tmp[80];
  char	chkval[80];
  char  expnam[80];
  char  expval[80];
  char  loc_msg[128], loc_prompt[128] ;
  double	deckPnt[3] ;
  struct GRevent event ;
 
 /***********************************************************
  Do a locate and check to see if the object is named properly
  before displaying the form.
  ***********************************************************/
  /* initialize some parameters before we start */
  strcpy(formStr, TITLE_STRING);
  ablDbl= 0.0;
  xyDbl = 0.0;
  psDbl = 0.0;
  faDbl = 0.0;
  xyStr[0]	= '\0';
  structCut[0]  = '\0';
  expTypStr[0]  = '\0';

  deckSurf.objid = NULL_OBJID ;

  notlocal=TRUE;
  message(TITLE_STRING);
  exitFlag = 1;
  default_cut = 1;
  form_st.gadget_label = -1 ;

again:

  GRIDS[1].objid = NULL_OBJID;
  GRIDS[1].osnum = 2;

  GRIDS[3].objid = NULL_OBJID;
  GRIDS[3].osnum = 2;

  penStr[0] = '\0' ;
  pcgStr[0] = '\0' ;

  objName[0] = '\0' ;
  objID.objid = NULL_OBJID ;
  strcpy( loc_msg, TITLE_STRING );
  strcpy( loc_prompt, "Identify Penetration by Name or Locate");
  if(!LocateObj( "nci_macro", loc_prompt, &objID, objName, FALSE ) ) {
	if( form_displayed ) {
            do {
                ci$get( prompt = "Quit Form", response = &response );
                if( form_st.gadget_label != CANCEL ) continue ;
                not_done = 0;           /* Stop the loop  */
                exitFlag = 0;           /* exit the program */
                FIf_erase ( form );     /* Erase the form */
                goto wrapup;
            } while( form_st.gadget_label != CANCEL ) ;
        }
        else goto again ;
  }

  if( objID.objid != NULL_OBJID ) {
	strcpy(penStr, objName);
	PENMAC = objID ;
  }

  if( ispenMacro(PENMAC) != TRUE ) {
	sprintf(tmp, "\"%s\" is not a Penetration Macro", penStr);
        UI_status(tmp);
        goto again;
  }
  else {
        UI_status("");
  }

  /*
   * check if a pcgMacro already exists on PENMAC. by ylong
   */
  if( A_pcgMacro_exists( PENMAC ) ) {
	goto wrapup;
  }

  test_wakeup = 1;        /* flag for wakeup function */
  form_exists = FALSE;    /* flag for delete function */
  form_displayed = FALSE; /* flag for sleep  function */

  not_done = TRUE;  /* Set this to FALSE when done with form */
  form_init();      /* Set up the form */

process_located_obj:

  /* make an object to connect to from the source */
  sts = ASmake_source_from_env( &PENMAC, &MOD_ENV, &PENPRET );

  get_current_file_name_and_mod_env();

  /* get the coordinate system and initialize the variables */
  getCurrentCoord();
  ablDbl = cm[11];
  FIfld_set_text(form, ABL_FIELD, 0, 0, ftoa(ablDbl), FALSE);

  FIfld_set_text( form, PEN_FIELD, 0, 0, penStr, FALSE);

  if( cm[7] >= 0.0 ) {
	sprintf(psStr,"P%.3f", fabs(cm[7]));
  }else {
	sprintf(psStr,"S%.3f", fabs(cm[7]));
  }
  psDbl = cm[7];
  FIfld_set_text(form, PS_FIELD, 0, 0, psStr, FALSE);


  NewCoord = OldCoord;
  NewPret = OldPret;
  fillInForm();
  enable_form();
  //loadDeckList();
  VDpenFormSetList ( form, REF_DECK_FIELD, "deck_list", -1 );
  VDpenFormSetList ( form, CUT_FIELD, "cut_type", 1 );
  VDpenFormSetList ( form, APPROV_FIELD, "approval", -1 );

 /************************************************************
   Loop until the user presses the cancel button.
  ************************************************************/
  while (not_done )
    {

      objID.objid = NULL_OBJID ;
      objName[0] = '\0' ;

      /* Suspend the command file and wait for the form */
      ci$get( prompt = "Fill in the form", response = &response );
              
      status(""); /* clear the status field*/
	
      /* Determine which gadget was manipulated */
      switch ( form_st.gadget_label ){

        case CANCEL:
          /* Quit Button */
          not_done = 0;         /* Stop the loop    */
	  exitFlag = 0;		/* exit the program */
          FIf_erase ( form );   /* Erase the form   */
          break;

        case PEN_FIELD:
	  FIg_get_text(form, PEN_FIELD, objName);
	  GetObjByName( objName, "nci_macro", &objID) ;
	  if( objID.objid == NULL_OBJID ){
		FIf_reset( form );
		FIg_set_text( form, PEN_FIELD, objName );
	  	VDpenFormFillInObjNames(form,PEN_FIELD, "penMacro");
		sprintf(tmp, "Cannot find Pen Macro %s", objName);
		status( tmp );
                break ;
          }
	  gr$display_object(object_id = &objID, mode  = GRhd );
	  
	  if( A_pcgMacro_exists(objID) ) {
                FIg_set_text( form, PEN_FIELD, penStr );
                break ;
          }

	  PENMAC  = objID ;
	  strcpy( penStr, objName );
          goto process_located_obj;

	  break;

        case PEN_LOC_BTN:
	  strcpy(loc_prompt, "Identify Penetration by Name or Locate");
  	  if(!LocateObj("nci_macro",loc_prompt, &objID, objName, FALSE)){
		break ;
	  }
	  if( !ispenMacro(objID) ) {
		sprintf(tmp, "\"%s\" is not a Penetration Macro", objName);
                UI_status(tmp);
		break;
	  }

	  if( A_pcgMacro_exists( objID ) )  break;

	  PENMAC  = objID;
	  strcpy(penStr, objName) ;
          goto process_located_obj;

          break;

        case FA_LOC_BTN:
          /* ID port forward or aft location plane */
 	  if( !LocateObj( "EMSplane","Identify Forward or Aft Reference Plane", 
					&objID, objName, FALSE) ) break ;
	  if( objID.objid == NULL_OBJID ) break ;

	  GRIDS[2] = objID ; strcpy( planeStr, objName ) ;

	  faDbl = GetFALocation( GRIDS[2]);
          FIfld_set_text(form, FA_DIST_FIELD, 0, 0, ftoa(faDbl), FALSE);

	  sts = ASmake_source_from_env(
		&GRIDS[2], &MOD_ENV, &GRIDS[2]);

	  if( strcmp(planeStr, "") == 0 ) strcpy( planeStr,"Unnamed Plane");
  	  FIfld_set_text( form, FA_FIELD, 0, 0, planeStr, FALSE); 

          break;

        case XY_BTN:
	  if( !LocateObj("EMSsubbs", "Identify Deck Surface or Plane:", 
			&objID, objName, FALSE) ) break ;

	  if( objID.objid == NULL_OBJID ) break ;
	  
	  deckSurf = objID ; strcpy( deckStr, objName ) ;

          /* make an object to connect to from the source */
          sts = ASmake_source_from_env(
                &deckSurf, &MOD_ENV, &GRIDS[3]);

	  deckPnt[0] = cm[3]; deckPnt[1] = cm[7]; deckPnt[2] = cm[11] ;
	  GetDeckDist( deckSurf, deckPnt, xyStr ) ;
	  FIfld_set_text(form, XY_FIELD, 0, 0, xyStr, FALSE);

          break;

        case REF_DECK_FIELD:
          FIfld_get_text(form, REF_DECK_FIELD, 0, 0, 76, refStr, &selFlag, &pos);
	  break;

        case CUT_FIELD:

          FIfld_get_text(form, CUT_FIELD, 0, 0, 76, cutTypStr, &selFlag, &pos);
	  default_cut = 0;
          if( !strcmp(cutTypStr,"") || !strcmp(cutTypStr,"---") )
          { 
  	  	FIfld_set_text( form, CUT_FIELD, 0, 0, "---", TRUE);	
          	status("Select a Cut type");
          	break;
          }
	  break;

        case APPROV_FIELD:
	  /* FILL IN THE SHAPE LIST */
          FIfld_get_text(form, APPROV_FIELD, 0, 0, 76, approvStr, &selFlag, &pos);
          if( !strcmp(approvStr,"") || !strcmp(approvStr,"---") )
          { 
  	  	FIfld_set_text( form, APPROV_FIELD, 0, 0, "---", TRUE);	
          	status("Select an approval type");
          	break;
          }
	  break;

        case EXPRESSIONS:
          FIfld_get_active_row(form, EXPRESSIONS, &expRow, &pos);
          FImcf_get_select(form, EXPRESSIONS, expRow, &selFlag);
          FIfld_get_text(form, EXPRESSIONS, expRow, 0, 40, expnam, &selFlag, &pos);
          FIfld_get_text(form, EXPRESSIONS, expRow, 1, 40, expval, &selFlag, &pos);
          VDpenFormSetExpList( form, EXPR_DATA_FIELD, RESET_EXP_BTN,
				expnam, expval, selFlag);
          break;

        case RESET_EXP_BTN:
          expTypStr[0] == '\0';
          structCut[0] == '\0';
          FIfld_get_text(form, EXPRESSIONS, expRow, 0, 40,
                                expnam, &selFlag, &pos);
          VDpenGetOrigAttr(PENMAC, expnam, expval);
          FIg_set_text(form, EXPR_DATA_FIELD, expval);
          FIfld_set_text(form, EXPRESSIONS, expRow, 1, expval, selFlag);

          break;

        case EXPR_DATA_FIELD:
          FIg_get_text(form, EXPR_DATA_FIELD, expval);
          FImcf_get_select(form, EXPRESSIONS, expRow, &selFlag);
          if( expval[0] != '\0' && selFlag ) {
            FIfld_set_text(form, EXPRESSIONS, expRow, 1, expval, selFlag);
            FIfld_get_text(form, EXPRESSIONS, expRow, 0, 40, expnam, &selFlag, &pos);
            if( !strcmp(expnam, "structure_to_cut") ) {
                strcpy(structCut, expval);
            }
            else if( !strcmp(expnam, "type") ) {
                strcpy(expTypStr, expval);
            }
          }
          break;

	case OBJ_FIT_BTN:
	  winID.objid = NULL_OBJID ;
	  ci$getevent( prompt   = "Identify Window or Moveon for all",
			response= &response,
			data    = tmp,
			event   = &event,
			mask    = GRm_DATA,
			window_id = &winID.objid,
			window_osnum = &winID.osnum,
			stackable = 1 );
	  if( winID.objid == NULL_OBJID ){
		sts = vd$vw_fit_object(
				factor   = 2.0,
				object   = &PENMAC,
				md_env   = &MOD_ENV );
	  }
	  else {
		sts = vd$vw_fit_object(
				factor   = 2.0,
				object   = &PENMAC,
				md_env   = &MOD_ENV,
				ggid     = &winID,
				num_ggid = 1 );
	  }
	  break;
	
        case RUN:
	  if( !A_pcgMacro_exists( PENMAC ) ) {
		if(checkAndPlace()) UI_status("A pcgMacro placed") ;
	  }
	  //computeTheMacro();
	  FIf_reset(form);
	  disable_form();
	  FIg_enable(form, PEN_LOC_BTN);
	  FIg_enable(form, PEN_FIELD);
	  UI_status("Searching for macros. Please wait ...");
	  VDpenFormFillInObjNames(form,PEN_FIELD, "penMacro");
	  UI_status(" ");
	  break;

        case ACCEPT:          
	  if( !A_pcgMacro_exists( PENMAC ) ) {
		checkAndPlace();
		//computeTheMacro();
	  }
          not_done = 0;        /* Stop the loop  */
          FIf_erase ( form );  /* Erase the form */
          break;

        } /* END switch ( g_label ) */

	/* if CUT_FIELD is default value, get it from form. ylong  */
	if(default_cut) {
          FIfld_get_text(form, CUT_FIELD, 0, 0, 76, cutTypStr, &selFlag, &pos);
	  default_cut = 0;
        }
    } /* END while ( not done ) */

wrapup:
	message("");
	prompt("");
	if ( exitFlag == 0 ) exit;

  /* The delete function will delete the form
     when the command file terminates */

}

/**********************************************************/

int LocateObj( inType, inPrompt, selObj, objName, check)
IGRchar	*inType;
IGRchar	*inPrompt;
TGRid	*selObj;
IGRchar	*objName;
IGRint	check;

{
        IGRlong loc_suc ;
        int     ret ;

        ret = 0 ;

        objName[0] = '\0' ;
        ret = loc_obj_exp( &loc_suc, TITLE_STRING, inPrompt, inType, selObj ) ;
        if( ret ){
                checkForProperName( *selObj, objName, check ) ;
        }

        return ret;
}

/***********************************************************/
IGRchar	filename[132];
IGRint 	var_size[3];
IGRint	bad_var;
struct EX_var_list	ex_var[4];
extern int EX_get_global();
extern int ACconstruct_path();

get_current_file_name_and_mod_env()
{

// GET THE CURRENT FILE NAME

	var_size[0] = sizeof(filename);
	ex_var[0].var = EX_CUR_FILENAME;
	ex_var[0].var_value = &filename[0];
	ex_var[0].num_bytes = &var_size[0];
	var_size[1] = NULL;

	msg = ex$global ( mode = 0, var = ex_var, which_error = &bad_var );

	__DBGpr_str("filename",filename);

 	ci$get_module_info( md_env = &MOD_ENV);

}


/*****************************************************************/

int	modifyMacro()
{

char	cRep;
int	msg, sts;
struct GRid	Locals[3];

    SetProc(modifyMacro); Begin

    if( OldCoord.objid != NewCoord.objid ||
	OldCoord.osnum != NewCoord.osnum){

	ci$get_module_info( md_env = &MOD_ENV);

	NewPret.objid = NULL_OBJID;
	NewPret.osnum = 2;

	sts = ASmake_source_from_env(
		&NewCoord, &MOD_ENV, &NewPret);

	__DBGpr_int("make_source_from_env NewPret sts", sts);
	__DBGpr_obj("NewPret from ASmake_source_from_env", NewPret);

	TEMPS[0] = NewPret;
	Locals[0] = OldPret;
	Locals[1] = TEMPS[1];
	Locals[2] = TEMPS[2];

	msg = 3; // number of parents to change
	sts = ci$send(msg = message  NDnode.NDchange_connect( 
		&msg,
		Locals,
		TEMPS),
		targetid = NEW_MAC.objid,
		targetos = NEW_MAC.osnum );

	
	__DBGpr_int("NDnode.NDchange_connect msg&sts", (msg&sts&1));
	
	OldPret = NewPret;
	OldCoord = NewCoord;
   }

   End
   return TRUE;

}

/*********************************************************************/

computeTheMacro(){
int	msg, sts;

   SetProc(computeTheMacro); Begin

   sts = ci$send(msg = message GRgraphics.GRxform( 
		&msg,
		&MOD_ENV,
		&MOD_ENV.md_env.matrix_type,
		MOD_ENV.md_env.matrix,
		&NEW_MAC.objid),
		targetid = NEW_MAC.objid,
		targetos = NEW_MAC.osnum );

   __DBGpr_int("NDmacro.ACreturn_foot msg&sts", (msg&sts&1));

   End
   return ;
}

/*****************************************************************/

int	putName( InGrid , hide)
struct GRid	*InGrid;
int		hide;
{
int	msg;
int	stat;

	if ( hide == FALSE){
		/*sprintf( tmpname,"M%d%d",InGrid->objid, InGrid->osnum);*/
		stat = ci$send( msg = message GRvg.GRputname(
			&msg,
			pcgStr),
			targetid = InGrid->objid,
			targetos = InGrid->osnum);
	
		if ( !(stat&msg&1) ) {
			__DBGpr_com("GRvg.GRputname failed");
			return FALSE;
		}
	}
	return TRUE;
}



/*****************************************************************/

int checkAndPlace(){
  int	msg, m, i;
  int	sts;
  int	numReturned;
  char	txt[80];

	SetProc(checkAndPlace); Begin

	/* This if block is for TR179900655. by ylong */
	if( strcmp(planeStr, "") == 0 ) {
	  status("Select Forward or Aft Reference Plane");
          /* ID port forward or aft location plane */
 	  LocateObj( "EMSplane", "Fill in the form", 
					&GRIDS[2], planeStr, FALSE);
	  faDbl = GetFALocation( GRIDS[2]);
	  
          FIfld_set_text(form, FA_DIST_FIELD, 0, 0, ftoa(faDbl), FALSE);

	  /* make an object to connect to from the source */
	  sts = ASmake_source_from_env(
		&GRIDS[2], &MOD_ENV, &GRIDS[2]);

	  if( strcmp(planeStr, "") == 0 ) strcpy( planeStr,"Unnamed Plane");
  	  FIfld_set_text( form, FA_FIELD, 0, 0, planeStr, FALSE);
	}


	CreateCollector( "", &GRIDS[1] );

	/* create all the items for the input collector off of the form*/

	i=0;
	strcpy(collAttrs[i].name, "Approval");
	collAttrs[i].desc.type = 1; 
	strcpy(collAttrs[i].desc.value.att_txt, approvStr);

	i=i+1;
	strcpy(collAttrs[i].name, "PenetrationName");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, penStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "FwdAftPlane");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, planeStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "FwdAftValue");
	collAttrs[i].desc.type = 2; 	
	collAttrs[i].desc.value.att_exp = faDbl; 

	i=i+1;
	strcpy(collAttrs[i].name, "ReferenceDeck");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, refStr); 

	i=i+1;
	strcpy(collAttrs[i].name, "CutType"); 
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, cutTypStr);

	i=i+1;
	strcpy(collAttrs[i].name, "Port_Starboard_pos");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, psStr);

	i=i+1;
	strcpy(collAttrs[i].name, "Vertical_ABL");
	collAttrs[i].desc.type = 2; 	
	collAttrs[i].desc.value.att_exp= ablDbl;

	i=i+1;
	strcpy(collAttrs[i].name, "Vertical_XorY");
	collAttrs[i].desc.type = 1; 	
	strcpy(collAttrs[i].desc.value.att_txt, xyStr); 

        if( expTypStr[0] != '\0' ) {
	   txt[0] = '\0';
	   VDpenGetOrigAttr(PENMAC, "type", txt);
	   if( strcmp( expTypStr, txt) ) {
		i=i+1;
		strcpy(collAttrs[i].name, "type");
		collAttrs[i].desc.type = 1;
		strcpy(collAttrs[i].desc.value.att_txt, expTypStr);
	   }
        }

        if( structCut[0] != '\0' ) {
	   txt[0] = '\0';
	   VDpenGetOrigAttr(PENMAC, "structure_to_cut", txt);
	   if( strcmp( structCut, txt) ) {
		i=i+1;
		strcpy(collAttrs[i].name, "structure_to_cut");
		collAttrs[i].desc.type = 1;
		strcpy(collAttrs[i].desc.value.att_txt, structCut);
	   }
        }

	i=i+1;

#ifdef DEBUG
	printf("number of atts in coll 1=%d\n", i);
	for( numReturned = 0; numReturned< i; numReturned=numReturned+1){
		printf("\t%s is ",collAttrs[numReturned].name);
		if (collAttrs[numReturned].desc.type == 1){
			printf("txt: att[%d]=[%s]\n",numReturned, 
				collAttrs[numReturned].desc.value.att_txt);
		}else{
			printf("exp: att[%d]=[%.3f]\n",numReturned, 
				collAttrs[numReturned].desc.value.att_exp);
		}
	}
#endif

	sts = ci$send( msg = message ACrg_collect.ACset_list_attribute(
		&msg,
		i,
		collAttrs),
		targetid = GRIDS[1].objid,
		targetos = GRIDS[1].osnum);
	
	__DBGpr_int("add list sts&msg", (sts&msg&1) );

	sts = placeMacro();

	return (sts&1);
}

/****************************************************************/

getCurrentCoord( )
{
	int	msg, sts, i;

	sts = ci$send(	msg = message ACcpx.ACfind_exp_temp_obj(
				&msg, 0, &OldPret),
			targetid = PENMAC.objid,
			targetos = PENMAC.osnum);

	if (!(msg&sts&1)) {
		__DBGpr_com("ACcpx.ACfind_exp_temp_obj failed");
		return;
	}
	__DBGpr_obj("PENMAC", PENMAC);
	__DBGpr_obj("OldPret, parent of PENMAC", OldPret);

	sts = ci$send(	msg = message NDmacro.ACreturn_foot(
					&msg,
					"", 
					&OldCoord, 
					&MOD_ENV.md_env.matrix_type,
					MOD_ENV.md_env.matrix),
			targetid = OldPret.objid,
			targetos = OldPret.osnum);

	if (!(msg&sts&1)) {
		__DBGpr_com("NDmacro.ACreturn_foot failed");
		return;
	}
	__DBGpr_obj("OldCoord, foot of OldPret", OldCoord);

	/* get coord name */
 	gr$get_name(	GRid_in	= OldCoord, 
			name	= coordname);
	sprintf(pcgStr, "PCG-%s", coordname);

	/* get the coordinate system info */
	sts = ci$send(	msg	 = message GRgencs.GRgetmatrix (&msg, cm),
			targetid = OldCoord.objid,
			targetos = OldCoord.osnum );
#ifdef DEBUG
	printf("cs matrix:\n");
	for(i=0;i<4;i=i+1)
	{
		printf("%.3f, %.3f, %.3f, %.3f\n", 
			cm[i*4+0], cm[i*4+1], cm[i*4+2], cm[i*4+3]);
	}
#endif

	if (!(msg&sts&1)) {
		__DBGpr_com("GRgencs.GRgetmatrix failed");
	}
 
	return;
}


/*****************************************************/
extern int	ACfind_macro_defn();

int ispenMacro( penmac )
struct	GRid	penmac ;
{
/* get the macro's definition name */
struct GRid 	TEMP;
int	stat;
char	macname[132];
char	stripname[132];
char	msgStr[132];
struct GRid	defID;

msg = ci$send( msg = message ci_macro.find_macro(
		&TEMP),
		targetid = penmac.objid,
		targetos = penmac.osnum);

msg = ci$send( msg = message GRvg.GRgetname(
		&stat,
		macname),
		targetid = TEMP.objid,
		targetos = TEMP.osnum);

__DBGpr_str("macroname",macname);

di$split ( pathname = macname,
	   dirname = NULL,
	   name = stripname );

msg = ac$find_macro_defn( action = ACfind_load,
			  macro_name = stripname,
			  p_macro_defn_id = &defID);

if( strcmp( stripname, "penMacro") != 0){

	sprintf(msgStr, "%s is NOT a penMacro.\n", stripname);
	status(msgStr);
	return FALSE;

}else {
	__DBGpr_str("IS penMacro", stripname);
	return TRUE;
}

}

/**********************************************/

int fillInForm()
{
int	msg, stat, i;
int	numReturned;

	msg = ci$send( msg = message NDmacro.ACreturn_foot(
			&stat,
			"Attributes", 
			&PENCOLL, 
			&MOD_ENV.md_env.matrix_type,
			MOD_ENV.md_env.matrix),
			targetid = PENMAC.objid,
			targetos = PENMAC.osnum);

	if (!(msg&stat&1)) {
		__DBGpr_com("NDmacro.ACreturn_foot failed");
		return;
	}
	__DBGpr_obj("PENCOLL, foot of PENMAC", PENCOLL);


	/* get all the data out of the input collector for macro placement */

	msg = ci$send( msg = message  ACrg_collect.AClist_attribute(
			&stat,
			50,
			collAttrs,
			&numReturned),
        		targetid = PENCOLL.objid,
        		targetos = PENCOLL.osnum );

	if( !(msg&stat&1)) {
		__DBGpr_com("ACrg_collect.AClist_attribute failed");
		return FALSE;
	}
	__DBGpr_int("number of atts in penColl",numReturned);


	for (i=0; i<numReturned-1; i=i+1){

	    #ifdef DEBUG
	    printf("[%d] %s\n", i,
			collAttrs[i+1].name);
	    #endif

	    FIfld_set_text( form, EXPRESSIONS, i,0, collAttrs[i+1].name,FALSE);
	    //printf("datatype=%d\n",
	    if( collAttrs[i+1].desc.type == 1){

		#ifdef DEBUG
		printf("[%d] %s=%s\n", i,
			collAttrs[i+1].name,
			collAttrs[i+1].desc.value.att_txt);
		#endif
		FIfld_set_text( form, EXPRESSIONS, i, 1, 
				collAttrs[i+1].desc.value.att_txt,FALSE);

	    }else{

		#ifdef DEBUG
		printf("[%d] %s=%.3f\n", i,
			collAttrs[i+1].name,
			collAttrs[i+1].desc.value.att_exp);
		#endif
		FIfld_set_text( form, EXPRESSIONS, i,1, 
				ftoa(collAttrs[i+1].desc.value.att_exp),FALSE);

	    }
	}

	FIg_display( form, OBJ_FIT_BTN );
	VDpenFormFillInObjNames(form, PEN_FIELD, "penMacro");
}

/*****************************************************************/

int	placeMacro()
{

struct GRmd_env	MOD_ENV;
char	cRep;
int	msg, sts;

	ci$get_module_info( md_env = &MOD_ENV);

	NEW_MAC.objid = NULL_OBJID;
	NEW_MAC.osnum = MOD_ENV.md_id.osnum;

	GRIDS[0] = PENPRET;

	__DBGpr_obj("GRIDS[0]", GRIDS[0] ) ;
	__DBGpr_obj("GRIDS[1]", GRIDS[1] ) ;
	__DBGpr_obj("GRIDS[2]", GRIDS[2] ) ;
	__DBGpr_obj("GRIDS[3]", GRIDS[2] ) ;

	VDSloadMacroLibrary( "avpencont.lib" );

	sts = ci$send(msg = message  nci_macro.init( 
		&msg, 
		0,
		"pcgMacro", 
		4,
		GRIDS,  
		0,
		&MOD_ENV),
		targetid = NEW_MAC.objid,
		targetos = NEW_MAC.osnum );

	__DBGpr_obj("NEW_MAC", NEW_MAC);
		
	if(!(sts & msg & 1)) 
	{

		printf("Error placing macro pcgMacro\n");
		printf("sts: %d, msg: %d, objid: %d\n", 
				sts, msg, NEW_MAC.objid);
		printf("check to see if you have the Macro library loaded with the pcgMacro macro in it\n");
		status("check to see if pcgMacro is available in libs");
		return FALSE;

	}else{
		/* name it here */
		putName( &NEW_MAC , FALSE);

	}

	return TRUE;

}

/********************************************************/

int loadDeckList()
{
FILE *checkFile;
IGRchar	filename[80];
IGRchar	deckname[80];
IGRint	Done;
IGRint	len;

long    msg ;
char	firstDir[100] ;
char	fileToFind[100] ;
char	dirInProdPathToSearchThen[100] ;

	/* check to see if file exists */
	checkFile = NULL ;
	strcpy(fileToFind, "DeckList");

	msg = MSFAIL ;
        strcpy(firstDir, ".");
	strcpy(dirInProdPathToSearchThen, "config/penetrations") ;
	VD_findFileInDirOrProductPaths(     &msg,
                                        fileToFind,
                                        firstDir,
                                        dirInProdPathToSearchThen,
                                        filename ) ;

	__DBGpr_str("filename", filename);

	if( !( msg & 1 ) ){
		msg = FALSE ;
		printf("Deck list file %s was not found.\n",filename);
	
	}

        checkFile = VD_openFile( &msg, filename, "r" );
        //checkFile = ( FILE *) fopen ( filename, "r" );

	if( checkFile == NULL ){
		msg = FALSE ;
		printf("Deck list file %s was not found.\n",filename);
		goto wrapup;
	}

	Done = 0;
	while(1)  
	{
		fgets( deckname, 80, checkFile);
		if ( deckname[0] == 0 ) break;

		__DBGpr_str("  ",deckname);

		len = strlen( deckname);
		deckname[ len - 1] = 0;
		FIfld_set_list_text( form, REF_DECK_FIELD, Done, 0,
				deckname, FALSE);

		Done = Done + 1;
		deckname[0] = 0;
 	}

wrapup:
	fclose ( checkFile );
}

/********************************************************/

int CreateCollector( inName, outObj )
char	inName[512];
struct GRid *outObj;
{
int	sts;
int	msg;

	outObj->osnum = 2;

	sts = om$construct( 
		classname = "ACrg_collect",
		osnum = 2,
		p_objid = &outObj->objid);

	__DBGpr_obj("created collector id", *outObj);

	if( strcmp( inName, "") ){

		sts = ci$send( msg = message GRgraphics.GRputname (
			&msg,
			inName),
			targetid = outObj->objid,
			targetos = outObj->osnum );
	}

	return TRUE;
}

/********************************************************************
 * It is used to check if a pcgMacro exsits as a child of penMacro.
 *  by ylong
 */
int A_pcgMacro_exists( penmac ) 
	struct	GRid	penmac ;
{

	GRclassid	classid;
	struct	GRid	*foundIds, *tmpIds;
	struct	GRid	model_def;
	OM_S_CHANSELECT	children_chn, notify_chn;

	IGRchar fullName[256];
	IGRchar *objName;
	IGRint	pcgFlag, i, j, cnt;
	IGRint	num_found, num_tmp;
	IGRlong	sts, msg;

	foundIds = NULL ;
	num_found = 0 ;
	tmpIds = NULL ;
	num_tmp = 0 ;

	objName = NULL;
	pcgFlag = 0;

	/* first, check children of penMacro */
        sts = om$make_chanselect(channame     = "NDchildren.children",
                                 p_chanselect = &children_chn);
        if( !(sts & 1) ) {
		__DBGpr_com("om$make_chanselect failed") ;
		goto wrapup;
	}

        classid = OPP_nci_macro_class_id ;
        sts = VDGetGridsFromChan_of_Class (
                                        &msg,
                                        penmac,
                                        &children_chn,
                                        classid,
                                        &num_found,
                                        &foundIds ) ;

	/* second, check pretends for TR179900986 */
        if( !(sts&msg&1) || num_found <= 0 ) {
        	sts = om$make_chanselect(channame    = "GRnotify.notification",
					p_chanselect = &notify_chn);
        	if( !(sts & 1) ) {
			__DBGpr_com("om$make_chanselect failed") ;
			goto wrapup;
		}
		classid = OPP_ACpretendin_class_id ;
        	sts = VDGetGridsFromChan_of_Class (
					&msg,
					penmac,
					&notify_chn,
					classid,
					&num_tmp,
					&tmpIds ) ;
        	__DBGpr_int("Number of objs on channel notify",num_tmp);
        	if( !(sts&msg&1) || num_tmp <=0 ) {
			__DBGpr_com("Nothing found on penMacro");
			goto wrapup;
		}
	}

	if( num_tmp > 0 && num_found <= 0 ) {
		cnt = num_tmp ;
	}
	else {
		cnt = 1 ;
	}

	/* check if found objects are pcgMacro */
	for( i = 0; i < cnt; i = i+1 ) {
	    if( num_tmp > 0 ) {
        	classid = OPP_nci_macro_class_id ;
		sts = VDGetGridsFromChan_of_Class (
                                        &msg,
                                        tmpIds[i],
                                        &children_chn,
                                        classid,
                                        &num_found,
                                        &foundIds ) ;
		if( !(sts&msg& 1) ) {
			__DBGpr_com("VDGetGridsFromChan_of_Class failed");
			continue ;
		}
	    }

	    for( j = 0; j < num_found; j = j+1 ) {
		sts = ci$send(	msg      = message ACcpx.find_macro(&model_def),
				targetid = foundIds[j].objid,
				targetos = foundIds[j].osnum);
		if( !(sts & 1) ) {
			__DBGpr_com("ACcpx.find_macro failed");
			continue ;
		}

		objName = NULL ;
		sts = ci$send(	msg  = message ACcpx_defn.ACgive_name(&objName),
				targetid = model_def.objid,
				targetos = model_def.osnum);
		if( !(sts & 1) ) {
			__DBGpr_com("ACcpx_defn.ACgive_name failed");
			continue ;
		}

		pcgFlag = !strcmp( objName, "pcgMacro" );
		if( pcgFlag ) {
			_FREE( foundIds );
			goto wrapup ;
		}
	    }
	    _FREE( foundIds );
	    foundIds = NULL ;
	}

wrapup:
        if( pcgFlag ) {
           status("A pcg macro already exists. Macro not placed.");
        }

	_FREE( tmpIds );
	return pcgFlag ;
}

