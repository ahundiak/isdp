#include "cieveryone.h"
#include "cilocate.h"
#include "cimacros.h"
#include "cisend.h"
#include "stdio.h"
#include "grgsdef.h"
#include "grgsmacros.h"
#include "bserr.h"
#include "bsparameters.h"
#include "lc.h"
#include "bs.h"
#include "bsvalues.h"
#include "grdpbdef.h"
#include "grdpb.h"
#include "grdpbmacros.h"

extern int EFprintcode();

extern int ASget_active_symb(),
           GRdpb_get(),
           ECdisplayPointSetByBuffer_passing_by_addr(),
           UI_status();

extern  void               BStst_plan();
extern  IGRdouble          BSdotp();
extern  IGRboolean         BSnorvec(); 
extern  IGRboolean         BScrossp();
extern  IGRdouble          acos();
extern  IGRdouble          cos();
extern  IGRdouble          tan();
extern  IGRdouble          sqrt();
extern  IGRdouble           fabs();

extern int free();

extern char *strcpy(), *strcat();
extern char *malloc();

#define DEBUG 0

/* function to initialize construct list */

int cnst_lis_msg;
struct IGRdisplay      Active_display;
IGRshort               Active_level;
struct GRmd_env ModuleInfo;
short cur_os;
long msg,NumberOfBytes,BytesReceived;

init_cnst_list(cnst_list)
struct GRvg_construct *cnst_list;
{

 NumberOfBytes = sizeof(ModuleInfo);
 gr$get_module_env(
                msg = &msg,
                sizbuf = &NumberOfBytes,
                buffer = &ModuleInfo,
                nret = &BytesReceived);
 cur_os = ModuleInfo.md_id.osnum;

 ASget_active_symb(&Active_level,&Active_display);
 cnst_list->msg = &cnst_lis_msg;        
 cnst_list->env_info = &ModuleInfo;
 cnst_list->display = &Active_display;
 cnst_list->geometry = 0; 
 cnst_list->newflag = FALSE;
 cnst_list->level = Active_level;
 cnst_list->properties = GRIS_LOCATABLE | GRIS_DISPLAYABLE;
 cnst_list->class_attr = NULL;
 cnst_list->name = 0;
}

/*

Name
    BSrndlincrn

Abstract
    This routine creates the rounding surface at a corner
    where three fillet surfaces with given radii between
    three planar faces with linear edges are meeting.

Synopsis
    void BSrndlincrn(corn_pt,pt1,pt2,pt3,rad1,rad2,rad3,type,
                     corn_sf,cv1,cv2,cv3,cv4,rc);

    IGRpoint              corn_pt;
    IGRpoint              pt1,pt2,pt3;
    IGRdouble             rad1,rad2,rad3;
    IGRshort              type;
    IGRbsp_surface        **corn_sf;
    IGRbsp_curve          **cv1,**cv2,**cv3,**cv4;
    BSrc                  *rc

Description
    Given the corner point (corn_pt), 3 points (pt1,pt2,pt3) 
    defining 3 edges, 3 different radii (rad1,rad2,rad3), a type
    value (type) indicating the shape of the corner surface, where
    type = 1 stands for a convex corner surface with three boundary
    curves (cv4 = NULL between edge1 and edge2, type = 2 stands for
    a convex corner surface with four boundary curves (blend also
    between edge1 and edge2, type = 3 stands for a surface being
    convex/concave along edge3 and changing to concave/convex onto
    the plane defined by edge 1 and edge2.  This routine returns
    the rounded corner surface (corn_sf) and its boundary curves
    (cv1,cv2,cv3,(cv4 if type is not 1)).

Return Values
    BSSUCC, if successful.

Notes
    The caller has to provide memory for the output surface and
    curves. The surface will be order 3x3 with 4x4 poles, rational,
    the curves will be order 3, 4 poles, rational.

    It is recommended to use type 1 if all three radius have
    similar values, type 2 if one radius (rad3) is relativly
    large compared to rad1 and to rad2. 

    In case of type 2, rad3 has to be larger than rad1 and larger
    than rad2.

History
    Vivian W.Ye        02/26/1990  : Creation date.
*/


BSrndlincrn(corn_pt,pt1,pt2,pt3,rad1,rad2,rad3,type,corn_sf,
            cv1,cv2,cv3,cv4,rc)


IGRpoint                     corn_pt,pt1,pt2,pt3;
IGRdouble                    rad1,rad2,rad3;
IGRshort                     type;
struct IGRbsp_surface        *corn_sf;
struct IGRbsp_curve          *cv1,*cv2,*cv3,*cv4;
BSrc                         *rc;         


{
  IGRvector                  vec1,vec2,vec3,nvec;
  IGRdouble                  len1,len2,len3;
  IGRdouble                  cos_b1,cos_b2,cos_b3;
  IGRdouble                  a1,a2,a3;
  IGRint                     i,j,k;
  IGRboolean                 status;
  IGRdouble                  dist1,dist2,dist3;
  IGRdouble                  dot,ang_tol;
  IGRdouble                  d12,d13,d21,d23,d31,d32;
  IGRdouble                  l12,l13,l21,l23,l31,l32;
  IGRvector                  v12,v13,v21,v23,v31,v32,nor;
  IGRdouble                  sqrt2_1,sqrt2_2;

  *rc = BSSUCC;

  ang_tol = 1.0e-10;
  sqrt2_1 = sqrt(2.0) - 1;    
  sqrt2_2 = sqrt(2.0) / 2;    
 
  for (i = 0; i < 3; i=i+1)
  {
    vec1[i] = pt1[i] - corn_pt[i];
    vec2[i] = pt2[i] - corn_pt[i];
    vec3[i] = pt3[i] - corn_pt[i];
  }

  status = BSnorvec(rc,vec1);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,vec2);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,vec3);
  if (!status)
    goto wrapup;

  /* compute the angle */

  status = BScrossp(rc,vec1,vec2,nor);
  if (!status)
    goto wrapup;
   
  status = BScrossp(rc,nor,vec1,v12);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,v12);
  if (!status)
    goto wrapup;

  status = BScrossp(rc,vec2,nor,v21);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,v21);
  if (!status)
    goto wrapup;

  status = BScrossp(rc,vec3,vec1,nor);
  if (!status)
    goto wrapup;
   
  status = BScrossp(rc,vec1,nor,v13);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,v13);
  if (!status)
    goto wrapup;

  status = BScrossp(rc,nor,vec3,v31);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,v31);
  if (!status)
    goto wrapup;

  status = BScrossp(rc,vec2,vec3,nor);
  if (!status)
    goto wrapup;
   
  status = BScrossp(rc,vec3,nor,v32);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,v32);
  if (!status)
    goto wrapup;

  status = BScrossp(rc,nor,vec2,v23);
  if (!status)
    goto wrapup;

  status = BSnorvec(rc,v23);
  if (!status)
    goto wrapup;

  cos_b1 = BSdotp(rc,v12,v13);
  cos_b2 = BSdotp(rc,v21,v23);
  cos_b3 = BSdotp(rc,v31,v32);

  if (fabs(cos_b1 - 1.0) < ang_tol)
  {
    d12 = rad1;
    d13 = rad1;
    l12 = sqrt2_1 * rad1;
    l13 = l12;

    cv1->weights[1] = (1.0 + sqrt2_2) / 2;
  }
  else
  {
    a1 = M_PI - acos(cos_b1);
    len1 = tan(a1 / 4) * rad1;        
    dist1 = tan(a1 / 2) * rad1;
    dot = BSdotp(rc,vec2,v12);
    d12 = dist1 / dot;
    l12 = len1 / dot;

    dot = BSdotp(rc,vec3,v13);
    d13 = dist1 / dot;
    l13 = len1 / dot;
   
    cv1->weights[1] = (1.0 + cos(a1 / 2)) / 2;
  }

  if (fabs(cos_b2 - 1.0) < ang_tol)
  {
    d21 = rad2;
    d23 = rad2;
    l21 = sqrt2_1 * rad2;
    l23 = l21;
    cv2->weights[1] = (1.0 + sqrt2_2) / 2;
  }
  else
  {
    a2 = M_PI - acos(cos_b2);
    len2 = tan(a2 / 4) * rad2;        
    dist2 = tan(a2 / 2) * rad2;

    dot = BSdotp(rc,vec1,v21);
    d21 = dist2 / dot;
    l21 = len2 / dot;

    dot = BSdotp(rc,vec3,v23);
    d23 = dist2 / dot;
    l23 = len2 / dot;

    cv2->weights[1] = (1.0 + cos(a2 / 2)) / 2;   
  }

  if (fabs(cos_b3 - 1.0) < ang_tol)
  {
    d31 = rad3;
    d32 = rad3;
    l31 = sqrt2_1 * rad3;
    l32 = l31;
    cv3->weights[1] = (1.0 + sqrt2_2) / 2;   
  }
  else
  {
    a3 = M_PI - acos(cos_b3);
    len3 = tan(a3 / 4) * rad3;        
    dist3 = tan(a3 / 2) * rad3;

    dot = BSdotp(rc,vec1,v31);
    d31 = dist3 / dot;
    l31 = len3 / dot;

    dot = BSdotp(rc,vec2,v32);
    d32 = dist3 / dot;
    l32 = len3 / dot;

    cv3->weights[1] = (1.0 + cos(a3 / 2)) / 2;   
      
  }
    
  /* assign curve characteristic to the structure */

  cv1->order = 3;
  cv1->periodic = FALSE;
  cv1->non_uniform = FALSE;
  cv1->num_poles = 4;
  cv1->rational = TRUE;
  cv1->num_knots = 7;
  for (i = 0; i < 3; i=i+1)
  {
    cv1->knots[i] = 0.0;
    cv1->knots[4 + i] = 1.0;
  }
  cv1->knots[3] = 0.5;
  cv1->phy_closed = FALSE;
  cv1->num_boundaries = 0;

  cv2->order = 3;
  cv2->periodic = FALSE;
  cv2->non_uniform = FALSE;
  cv2->num_poles = 4;
  cv2->rational = TRUE;
  cv2->num_knots = 7;
  for (i = 0; i < 3; i=i+1)
  {
    cv2->knots[i] = 0.0;
    cv2->knots[4 + i] = 1.0;
  }
  cv2->knots[3] = 0.5;
  cv2->phy_closed = FALSE;
  cv2->num_boundaries = 0;

  cv3->order = 3;
  cv3->periodic = FALSE;
  cv3->non_uniform = FALSE;
  cv3->num_poles = 4;
  cv3->rational = TRUE;
  cv3->num_knots = 7;
  for (i = 0; i < 3; i=i+1)
  {
    cv3->knots[i] = 0.0;
    cv3->knots[4 + i] = 1.0;
  }
  cv3->knots[3] = 0.5;
  cv3->phy_closed = FALSE;
  cv3->num_boundaries = 0;

  /* assign weights to the cv1,cv2,cv3 */

  cv1->weights[0] = 1.0;
  cv1->weights[3] = 1.0;
  cv2->weights[0] = 1.0;
  cv2->weights[3] = 1.0;
  cv3->weights[0] = 1.0;
  cv3->weights[3] = 1.0;
  cv1->weights[2] = cv1->weights[1];
  cv2->weights[2] = cv2->weights[1];
  cv3->weights[2] = cv3->weights[1];

  /* assign all characteristics to the surface structure */

  corn_sf->u_order = 3;
  corn_sf->v_order = 3;
  corn_sf->u_periodic = FALSE;
  corn_sf->v_periodic = FALSE;
  corn_sf->u_non_uniform = FALSE;
  corn_sf->v_non_uniform = FALSE;
  corn_sf->u_num_poles = 4;
  corn_sf->v_num_poles = 4;
  corn_sf->rational = TRUE;
  corn_sf->u_num_knots = 7;
  corn_sf->v_num_knots = 7;
  for (i = 0; i < 3; i=i+1)
  {
    corn_sf->u_knots[i] = 0.0;
    corn_sf->u_knots[4 + i] = 1.0;
    corn_sf->v_knots[i] = 0.0;
    corn_sf->v_knots[4 + i] = 1.0;
  }

  corn_sf->u_knots[3] = 0.5;
  corn_sf->u_knots[3] = 0.5;
    
  corn_sf->u_phy_closed = FALSE;
  corn_sf->v_phy_closed = FALSE;
  corn_sf->planar = FALSE;
  corn_sf->pos_orient = 1;
  corn_sf->on_off = 1;
  corn_sf->num_boundaries = 0;    

  switch (type)
  {
  case 1:

    /* assign poles to the cv1,cv2,cv3 */

    for (i = 0; i < 3; i=i+1)
    {
      cv1->poles[i] = corn_pt[i] + d13 * vec3[i] + d31 * vec1[i];
      cv3->poles[i] = cv1->poles[i];
      cv1->poles[9 + i] = corn_pt[i] + d21 * vec1[i] + d12 * vec2[i];
      cv2->poles[9 + i] = cv1->poles[9 + i];
      cv2->poles[i] = corn_pt[i] + d23 * vec3[i] + d32 * vec2[i];
      cv3->poles[9 + i] = cv2->poles[i];
    }

    for (i = 0; i < 3; i=i+1)
    {
      cv1->poles[3 + i] = cv1->poles[i] - l13 * vec3[i];
      cv1->poles[6 + i] = cv1->poles[9 + i] - l12 * vec2[i];
      cv2->poles[3 + i] = cv2->poles[i] - l23 * vec3[i];
      cv2->poles[6 + i] = cv2->poles[9 + i] - l21 * vec1[i];
      cv3->poles[3 + i] = cv3->poles[i] - l31 * vec1[i];
      cv3->poles[6 + i] = cv3->poles[9 + i] - l32 * vec2[i];
    }

    for (i = 0; i < 4; i=i+1)
    {
      for (j = 0; j < 3; j=j+1)
      {
        corn_sf->poles[3 * i + j] = cv3->poles[3 * i + j];
        corn_sf->poles[3 * (12 + i) + j] = cv1->poles[9 + j];
      }
    }

    for (i = 0; i < 3; i=i+1)
    {
      corn_sf->poles[3 * 4 + i] = cv1->poles[3 + i];
      corn_sf->poles[3 * 5 + i] = cv3->poles[3 + i] - l13 * vec3[i];
      corn_sf->poles[3 * 6 + i] = cv3->poles[6 + i] - l23 * vec3[i];
      corn_sf->poles[3 * 7 + i] = cv2->poles[3 + i];
      corn_sf->poles[3 * 8 + i] = cv1->poles[6 + i];
      corn_sf->poles[3 * 9 + i] = cv1->poles[6 + i] - 
                                   l31 * l21 * vec1[i] / d31;
      corn_sf->poles[3 * 10 + i] = cv2->poles[6 + i] - 
                                  l12 * l32 * vec2[i] / d32;
      corn_sf->poles[3 * 11 + i] = cv2->poles[6 + i];
    }

    /* assign the weights to the corn_sf structure */
 
    for (i = 0; i < 4; i=i+1)
    {
      corn_sf->weights[i] = cv3->weights[i];
      corn_sf->weights[12 + i] = cv3->weights[i];
    }

    corn_sf->weights[4] = cv1->weights[1];
    corn_sf->weights[5] = cv1->weights[1] * cv3->weights[1];
    corn_sf->weights[6] = cv2->weights[1] * cv3->weights[2];
    corn_sf->weights[7] = cv2->weights[1];
    corn_sf->weights[8] = cv1->weights[2];
    corn_sf->weights[9] = cv1->weights[2] * cv3->weights[1];
    corn_sf->weights[10] = cv2->weights[2] * cv3->weights[2];
    corn_sf->weights[11] = cv2->weights[2];
    break;
  case 2:
    if (rad3 < rad1 || rad3 < rad2)
    {
      *rc = BSINARG;
      goto wrapup;
    }

    cv4->order = 3;
    cv4->periodic = FALSE;
    cv4->non_uniform = FALSE;
    cv4->num_poles = 4;
    cv4->rational = TRUE;
    cv4->num_knots = 7;
    for (i = 0; i < 3; i=i+1)
    {
      cv4->knots[i] = 0.0;
      cv4->knots[4 + i] = 1.0;
    }
    cv4->knots[3] = 0.5;
    cv4->phy_closed = FALSE;
    cv4->num_boundaries = 0;

    /* assign poles to the cv1,cv2,cv3,cv4 */

    for (i = 0; i < 3; i=i+1)
    {
      cv1->poles[i] = corn_pt[i] + d13 * vec3[i] + d31 * vec1[i];
      cv3->poles[i] = cv1->poles[i];
      cv1->poles[9 + i] = corn_pt[i] + d31 * vec1[i] + d12 * vec2[i];
      cv4->poles[i] = cv1->poles[9 + i];
      cv2->poles[9 + i] = corn_pt[i] + d32 * vec2[i] + d21 * vec1[i];
      cv4->poles[9 + i] = cv2->poles[9 + i];
      cv2->poles[i] = corn_pt[i] + d23 * vec3[i] + d32 * vec2[i];
      cv3->poles[9 + i] = cv2->poles[i];
    }

    for (i = 0; i < 3; i=i+1)
    {
      cv1->poles[3 + i] = cv1->poles[i] - l13 * vec3[i];
      cv1->poles[6 + i] = cv1->poles[9 + i] - l12 * vec2[i];
      cv2->poles[3 + i] = cv2->poles[i] - l23 * vec3[i];
      cv2->poles[6 + i] = cv2->poles[9 + i] - l21 * vec1[i];
      cv3->poles[3 + i] = cv3->poles[i] - l31 * vec1[i];
      cv3->poles[6 + i] = cv3->poles[9 + i] - l32 * vec2[i];
      cv4->poles[3 + i] = cv4->poles[i] - (d31 - d21) * l31 * 
                          vec1[i] / d31; 
      cv4->poles[6 + i] = cv4->poles[9 + i] - (d32 - d12) * l32 * 
                          vec2[i] / d32;
    }

    cv4->weights[0] = 1.0;
    cv4->weights[1] = cv3->weights[1];
    cv4->weights[2] = cv3->weights[2];
    cv4->weights[3] = 1.0;

    for (i = 0; i < 4; i=i+1)
    {
      for (j = 0; j < 3; j=j+1)
      {
        corn_sf->poles[3 * i + j] = cv3->poles[3 * i + j];
        corn_sf->poles[3 * (12 + i) + j] = cv4->poles[3 * i + j];
      }
    }

    for (i = 0; i < 3; i=i+1)
    {
      corn_sf->poles[3 * 4 + i] = cv1->poles[3 + i];
      corn_sf->poles[3 * 5 + i] = cv3->poles[3 + i] - l13 * vec3[i];
      corn_sf->poles[3 * 6 + i] = cv3->poles[6 + i] - l23 * vec3[i];
      corn_sf->poles[3 * 7 + i] = cv2->poles[3 + i];
      corn_sf->poles[3 * 8 + i] = cv1->poles[6 + i];
      corn_sf->poles[3 * 9 + i] = cv1->poles[6 + i] - 
                               l31 * (d31 - d21 + l21) * vec1[i] / d31;
      corn_sf->poles[3 * 10 + i] = cv2->poles[6 + i] - 
                               l32 * (d32 - d12 + l12) * vec2[i] / d32;
      corn_sf->poles[3 * 11 + i] = cv2->poles[6 + i];
    }

    /* assign the weights to the corn_sf structure */
 
    for (i = 0; i < 4; i=i+1)
    {
      corn_sf->weights[i] = cv3->weights[i];
      corn_sf->weights[12 + i] = cv4->weights[i];
    }

    corn_sf->weights[4] = cv1->weights[1];
    corn_sf->weights[5] = cv1->weights[1] * cv3->weights[1];
    corn_sf->weights[6] = cv2->weights[1] * cv3->weights[2];
    corn_sf->weights[7] = cv2->weights[1];
    corn_sf->weights[8] = cv1->weights[2];
    corn_sf->weights[9] = cv1->weights[2] * cv4->weights[1];
    corn_sf->weights[10] = cv2->weights[2] * cv4->weights[2];
    corn_sf->weights[11] = cv2->weights[2];
    break;
  case 3:
    cv4->order = 3;
    cv4->periodic = FALSE;
    cv4->non_uniform = FALSE;
    cv4->num_poles = 4;
    cv4->rational = TRUE;
    cv4->num_knots = 7;
    for (i = 0; i < 3; i=i+1)
    {
      cv4->knots[i] = 0.0;
      cv4->knots[4 + i] = 1.0;
    }
    cv4->knots[3] = 0.5;
    cv4->phy_closed = FALSE;
    cv4->num_boundaries = 0;

    /* assign poles to the cv1,cv2,cv3,cv4 */

    for (i = 0; i < 3; i=i+1)
    {
      cv1->poles[i] = corn_pt[i] + d13 * vec3[i] + d31 * vec1[i];
      cv3->poles[i] = cv1->poles[i];
      cv1->poles[9 + i] = corn_pt[i] + d31 * vec1[i] - d12 * vec2[i];
      cv4->poles[i] = cv1->poles[9 + i];
      cv2->poles[9 + i] = corn_pt[i] + d32 * vec2[i] - d21 * vec1[i];
      cv4->poles[9 + i] = cv2->poles[9 + i];
      cv2->poles[i] = corn_pt[i] + d23 * vec3[i] + d32 * vec2[i];
      cv3->poles[9 + i] = cv2->poles[i];
    }

    for (i = 0; i < 3; i=i+1)
    {
      cv1->poles[3 + i] = cv1->poles[i] - l13 * vec3[i];
      cv1->poles[6 + i] = cv1->poles[9 + i] + l12 * vec2[i];
      cv2->poles[3 + i] = cv2->poles[i] - l23 * vec3[i];
      cv2->poles[6 + i] = cv2->poles[9 + i] + l21 * vec1[i];
      cv3->poles[3 + i] = cv3->poles[i] - l31 * vec1[i];
      cv3->poles[6 + i] = cv3->poles[9 + i] - l32 * vec2[i];
      cv4->poles[3 + i] = cv4->poles[i] - (d31 + d21) * l31 * 
                          vec1[i] / d31; 
      cv4->poles[6 + i] = cv4->poles[9 + i] - (d32 + d12) * l32 * 
                          vec2[i] / d32;
    }

    cv4->weights[0] = 1.0;
    cv4->weights[1] = cv3->weights[1];
    cv4->weights[2] = cv3->weights[2];
    cv4->weights[3] = 1.0;

    for (i = 0; i < 4; i=i+1)
    {
      for (j = 0; j < 3; j=j+1)
      {
        corn_sf->poles[3 * i + j] = cv3->poles[3 * i + j];
        corn_sf->poles[3 * (12 + i) + j] = cv4->poles[3 * i + j];
      }
    }

    for (i = 0; i < 3; i=i+1)
    {
      corn_sf->poles[3 * 4 + i] = cv1->poles[3 + i];
      corn_sf->poles[3 * 5 + i] = cv3->poles[3 + i] - l13 * vec3[i];
      corn_sf->poles[3 * 6 + i] = cv3->poles[6 + i] - l23 * vec3[i];
      corn_sf->poles[3 * 7 + i] = cv2->poles[3 + i];
      corn_sf->poles[3 * 8 + i] = cv1->poles[6 + i];
      corn_sf->poles[3 * 9 + i] = cv1->poles[6 + i] - 
                               l31 * (d31 + d21 - l21) * vec1[i] / d31;
      corn_sf->poles[3 * 10 + i] = cv2->poles[6 + i] - 
                               l32 * (d32 + d12 - l12) * vec2[i] / d32;
      corn_sf->poles[3 * 11 + i] = cv2->poles[6 + i];
    }

    /* assign the weights to the corn_sf structure */
 
    for (i = 0; i < 4; i=i+1)
    {
      corn_sf->weights[i] = cv3->weights[i];
      corn_sf->weights[12 + i] = cv4->weights[i];
    }

    corn_sf->weights[4] = cv1->weights[1];
    corn_sf->weights[5] = cv1->weights[1] * cv3->weights[1];
    corn_sf->weights[6] = cv2->weights[1] * cv3->weights[2];
    corn_sf->weights[7] = cv2->weights[1];
    corn_sf->weights[8] = cv1->weights[2];
    corn_sf->weights[9] = cv1->weights[2] * cv4->weights[1];
    corn_sf->weights[10] = cv2->weights[2] * cv4->weights[2];
    corn_sf->weights[11] = cv2->weights[2];
    break;
  }

  /* get weighted poles for curves and surface */

  for (i = 0; i < 4; i=i+1)
  {
    for (j = 0; j < 3; j=j+1)
    {
      cv1->poles[3 * i + j] = cv1->poles[3 * i + j] * cv1->weights[i];
      cv2->poles[3 * i + j] = cv2->poles[3 * i + j] * cv2->weights[i];
      cv3->poles[3 * i + j] = cv3->poles[3 * i + j] * cv3->weights[i];
    }
  }

  for (i = 0; i < 4; i=i+1)
    for (j = 0; j < 4; j=j+1)
      for (k = 0; k < 3; k=k+1)
        corn_sf->poles[3 * (i * 4 + j) + k] = 
                          corn_sf->poles[3 * (i * 4 + j) + k] * 
                          corn_sf->weights[i * 4 + j];

  BStst_plan(4,cv1->poles,cv1->weights,&cv1->planar,nvec,rc);
  if (BSERROR(*rc))
    goto wrapup;

  BStst_plan(4,cv2->poles,cv2->weights,&cv2->planar,nvec,rc);
  if (BSERROR(*rc))
    goto wrapup;

  BStst_plan(4,cv3->poles,cv3->weights,&cv3->planar,nvec,rc);
  if (BSERROR(*rc))
    goto wrapup;

  if (type != 1)
  {
    for (i = 0; i < 4; i=i+1)
      for (j = 0; j < 3; j=j+1)
        cv4->poles[3 * i + j] = cv4->poles[3 * i + j] *  cv4->weights[i];
    BStst_plan(4,cv3->poles,cv3->weights,&cv3->planar,nvec,rc);
    if (BSERROR(*rc))
      goto wrapup;
  }

wrapup:
return;
}

main()
{
 IGRdouble first_rad, second_rad, third_rad;
 IGRpoint first_pt, second_pt, third_pt, corner_pt;
 IGRint type;
 IGRshort round_type;
 struct IGRbsp_curve cv1, cv2, cv3, cv4;
 struct IGRbsp_surface sf, *surf_ptr;
 IGRint msg, sts;
 GRobj surf_objid;
 IGRdouble curve1_poles_buff[12],curve1_knots_buff[7],curve1_weights_buff[4];
 IGRdouble curve2_poles_buff[12],curve2_knots_buff[7],curve2_weights_buff[4];
 IGRdouble curve3_poles_buff[12],curve3_knots_buff[7],curve3_weights_buff[4];
 IGRdouble curve4_poles_buff[12],curve4_knots_buff[7],curve4_weights_buff[4];
 enum GRdpmode		display_mode;
 IGRdouble surf_poles_buff[48], surf_u_knots_buff[7],
           surf_v_knots_buff[7], surf_weights_buff[16];
 struct GRvg_construct construct_list;
 IGRboolean draw_background;
 IGRdouble pts[6];
 IGRint i;

 msg = 1;
 sts = 1;
 surf_objid = NULL_OBJID;

while(TRUE)
{
 init_cnst_list(&construct_list);
 message("Place rounded corner");

 prompt("Input round type [1-3]");
 ci$get(value = type);
 round_type = type;

 prompt("Input corner point");

 ci$get(point = corner_pt);

 draw_background = TRUE;

 for (i=0;i<3;i=i+1)
  pts[i] = corner_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     1,pts,draw_background);

 prompt("Input point on first linear edge");
 
 ci$get(point = first_pt);

 for (i=0;i<3;i=i+1)
  pts[3+i] = first_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     2,pts,draw_background);

 prompt("Input radius value for the edge");

 ci$get(value = first_rad);

 prompt("Input point on second linear edge");

 ci$get(point = second_pt);

 for (i=0;i<3;i=i+1)
  pts[3+i] = second_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     2,pts,draw_background);

 prompt("Input radius value for the edge");

 ci$get(value = second_rad);

 prompt("Input point on third linear edge");

 ci$get(point = third_pt);

 for (i=0;i<3;i=i+1)
  pts[3+i] = third_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     2,pts,draw_background);

 while (TRUE)
 {
  prompt("Input radius value for the edge");
  ci$get(value = third_rad);
  if (round_type == 2)
  {
    if ((third_rad >= second_rad) && (third_rad >= first_rad))
    {
      break;
    }
    else
    {
      UI_status("Radius value must be > first and second radii");
    }
  }
  else break;
 }

 cv1.poles = curve1_poles_buff;
 cv1.knots = curve1_knots_buff;
 cv1.weights = curve1_weights_buff;
 cv1.bdrys = NULL;

 cv2.poles = curve2_poles_buff;
 cv2.knots = curve2_knots_buff;
 cv2.weights = curve2_weights_buff;
 cv2.bdrys = NULL;

 cv3.poles = curve3_poles_buff;
 cv3.knots = curve3_knots_buff;
 cv3.weights = curve3_weights_buff;
 cv3.bdrys = NULL;

 cv4.poles = curve4_poles_buff;
 cv4.knots = curve4_knots_buff;
 cv4.weights = curve4_weights_buff;
 cv4.bdrys = NULL;

 sf.poles = surf_poles_buff;
 sf.u_knots = surf_u_knots_buff;
 sf.v_knots = surf_v_knots_buff;
 sf.weights = surf_weights_buff;
 sf.bdrys = NULL;

 BSrndlincrn(corner_pt, first_pt, second_pt, third_pt, first_rad,
             second_rad, third_rad, round_type,&sf, &cv1, &cv2,
             &cv3, &cv4,&msg);
#if DEBUG
 fprintf(stderr,"sts, msg %d %d \n",sts,msg);
#endif

 if (msg != 0)
 {
  UI_status("Error in construction");
  msg = 0;
  goto wrapup;
 }
 else msg = 1;

 surf_objid = NULL_OBJID;


 construct_list.geometry = (IGRchar *)&sf;

 sts = ci$send (msg = message EMSgenbs.GRconstruct(&construct_list),
                targetid = surf_objid,
                targetos = cur_os);
#if DEBUG
 EFprintcode(0,sts);
 fprintf(stderr,"sts, msg %d %d \n",sts,msg);
#endif
 if (!(1&sts))
 {
  msg = 0;
  UI_status("Error in constructing object");
  goto wrapup;
 }

 display_mode = GRbd;

 sts = ci$send (msg = message GRgraphics.GRdisplay(&msg,
                 &ModuleInfo.md_env.matrix_type,
                 ModuleInfo.md_env.matrix,
                 &display_mode,
                 &ModuleInfo.md_id),
             targetid = surf_objid,
             targetos = cur_os);
#if DEBUG
 fprintf(stderr,"sts, msg %d %d \n",sts,msg);
#endif
 if (!(1&sts&msg)) goto wrapup;
 
 draw_background = FALSE;

 for (i=0;i<3;i=i+1)
  pts[i] = corner_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     1,pts,draw_background);

 for (i=0;i<3;i=i+1)
  pts[3+i] = first_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     2,pts,draw_background);

 for (i=0;i<3;i=i+1)
  pts[3+i] = second_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     2,pts,draw_background);

 for (i=0;i<3;i=i+1)
  pts[3+i] = third_pt[i];

 ECdisplayPointSetByBuffer_passing_by_addr(&msg,&Active_display,&ModuleInfo,
     NULL_OBJID,
     2,pts,draw_background);
}
 

wrapup:

 if (!(1&sts&msg))
 {
  if (surf_objid != NULL_OBJID)
  {
   ci$send (msg = message GRgraphics.GRdelete(&msg,&ModuleInfo),
                  targetid = surf_objid,
                  targetos = cur_os);
  }
  fprintf(stderr,"Error in command execution");
 }
 return;
}

