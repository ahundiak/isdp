class implementation EMSsfrndbool;

/*include files */

#include <math.h>
#include "bsparameters.h"
#include "bserr.h"
#include "bstypes.h"
#include "bsgeom_cvsf.h"
#include "bsconic.h"
#include "OMmacros.h"
#include "emsedgedef.h"
#include "EMSlmdef.h"
#include "EMSrnd.h"
#include "emssfintdef.h"
#include "emsinter.h"
#include "emserr.h"
#include "prototypes/bssfeval.h"
#include "prototypes/bssfkttol2.h"
#include "prototypes/bsreffilsrf.h"
#include "bstst_plan.h"
#include "bstrpofsfit.h"
#include "bssfkttol2.h"
#include "bssfeval.h"
#include "bssfarrevn.h"
#include "bssf3o4pts.h"
#include "bsrev_cv.h"
#include "bsreffilsrf.h"
#include "bspsph3pts.h"
#include "bsparameters.h"
#include "bsmdstptcv.h"
#include "bsmdistptsf.h"
#include "bsfreesf.h"
#include "bsdotp.h"
#include "bscvarrev0.h"
#include "bsallocsf.h"
#include "bsalloccv.h"

#define WBC_USE_NEW_MATH 1

/*imports       */
from EMSlinedge  import  EMleinit;
from EMSedge     import  EMreplace_edge,
			 EMset_props, EMset_type;
from EMSloopset  import  EMset_props;
from EMSloop     import  EMmakeFRT,
                         EMset_props;
from EMSsubbs	 import	 EMget_int_data;

/*
 * Since it is known that the round solution provided within this file
 * is applicable only to 3-vertices, the following is o.k.
 */

#define	NUMBER_OF_VTX_EDGES	3

#define U0	0
#define U1	1
#define UV_DIM	2
#define XYZ_DIM	3
#define u	0
#define v	1
#define FIRST	0
#define SECOND	1
#define THIRD   2
#define START	0
#define STOP	1
#define X 0
#define Y 1
#define Z 2


/*
 * A structure to contain information on each of the solid's surfaces
 * at this round vertex.
 */
    struct  EMSsolid_srf_info {
		GRobjid			objid;
		struct IGRbsp_surface	*geometry;
		IGRdouble		knot_tole;

		/*
		 * On each surface, there would be a point corresponding to
		 * the intersection point generated by intersecting the two
		 * fillets on a surface.  The following record its coordinates
		 * in the UV and XYZ spaces.
		 */
		    IGRdouble	    UV[ 2 ]; /* 0 is U, 1 is V */

		    IGRpoint	    XYZ;
    };

/*
 * A structure to contain information on each of the 
 */
    struct  EMSfillet_srf_info {

		/*
		 * Each fillet will have two intersection points, one on U0
		 * and the other on U1 (these need NOT be identical to their
		 * counterparts on the solid's surfaces since the latter may
		 * undergo modification to fit a partial sphere, in case of
		 * rounding).
		 * The following records these two points on each fillet in UV
		 * and XYZ spaces.
		 */
		    IGRdouble	UV[ 2 ][ 2 ];	/* point on U=0 in 0
						 * (0,0 is u and 0,1 is v)
						 * point on U=1 in 1.
						 * (1,0 is u and 1,1 is v)
						 */

		    IGRpoint	XYZ[ 2 ]; 	/* point on U=0 in 0.
						 * point on U=1 in 1.
						 */
		    IGRboolean
				/*
		 		 * If TRUE, then U0 iso curve of this fillet
				 * is on the surface that is bounded by this
				 * fillet's edge, and that edge's next edge.
		 		 * else, U1 iso curve of this fillet .....
		 		 */
				    U0_on_srf,

				/* if TRUE, then the UV orientation of this
				 * fillet's intersection curve (relative to
				 * the UV space of the vertex patch) is the
				 * same as its counterpart on the vertex
				 * patch.
				 */
				    relative_orientation;
    };

/*
 * A structure to contain information on the vertex patch.
 */
    struct  EMSpatch_info {
		GRobjid		objid, /* Of the patch */

				/*
		 		 * The initial edges of the patch.
		 		 */
				    natural_edges[ 4 ];

		struct IGRbsp_surface	geometry;
		IGRdouble		knot_tole;

		/*
		 * The geometry of the edges of the patch in XYZ space.
		 * (U=0 is degenerate).
		 */
		    struct IGRbsp_curve		*arcs[ 3 ];

		/*
		 * If the surface expected has a center (example: a spherical
		 * patch), then the following will conatin that center.
		 */
		    IGRpoint	center;
    };

%safe
static void get_surface_by_3pts(),
            get_sph_patch();
%endsafe


/*
 * Descriptions :-
  
   3-edge-homog vertex, uniform rounding/uniform chamfering, all edges
   are to be rounded.
   if rounding, produce a spherical vertex patch.
   if chamfering, produce a planar vertex surface.

 * Inputs :-

   options         - EMS_RND_CHAMFER
			If set. then do chamfering.
   construct_list  - instance of GRvg_construct consisting of design
		     file information.  Typically, information such as
		     the osnum for new objects is extracted from here.
   vertex_info     - vertex information ( see EMSrnd.h ).

 * Input/Outputs

   EMmsg           - return code.
   compsf_GRid     - id of the surface to which the belnd should be connected.
   inters1         - intersection information structure of the fillets/blends
                     and pactches.

 * History :-
      
        KNAP    : March'9, 95  : Removed EFget_inf_plane_srf_int, and replaced 
                                 it with EMget_fillet_intpln_data().

        Janaka  : 06-30-93     : Added an argument to EFget_inf_plane_srf_int
                                 to return the infinite plane normal.
        Sudha     06/23/93       Modified for BSprototype ansification
        Jack    : 06/18/93     : Modified to create an EMSplane rather than an EMSgenbs
                                 for the vertex patch when the option is EMS_RND_CHAMFER.
                                 Did this conditionally if WANT_POST220_BEHAVIOR.
        NP      : 05/27/93     : Function "EMmkintlist" is now re-named as
                                 "EMmakeintlist" due to addition of two new 
                                 parameters.
                                 NOTE: TRY TO SET THE NEW CURVE TYPE PARAMETERS
                                       MEANINGFULLY.
        Janaka  : 02/22/93     : Added fillet refinement code.  This
                                 modification removed the function which had
                                 WBC's modification.
        WBC     : 01/08/93     : Replace the call to BSmdistptsf with a call
                                 to BSprptarrsf.
	Janaka	: May 01, 1992 : re-wrote most of the function
	DLB	: 02/11/92     : comment out setting of construct_list->msg
	Inasu	: ??? ??, 91   : Creation

 */

#argsused

IGRlong EMspherical_blend( EMmsg, options, construct_list,
  			   vertex_info, compsf_GRid,
			   inters1 )

IGRlong			*EMmsg;
IGRushort		options;
struct GRvg_construct	*construct_list;
struct EMSvtx_rnd_info	*vertex_info;
struct GRid		*compsf_GRid;
struct EMSinters	**inters1;
{
  IGRboolean			can_do_blend=TRUE;
  IGRlong			om_stat, msg;
  OMuint                        index;
  IGRint			i, num, inx1, inx2;
  IGRpoint			inter_pt_xyz;
  GRobjid			fillet_common_edge[3];
  IGRdouble			cht_tole, fillet_param[2][2], basis_tole,
				*ptr;
  IGRchar			*old_geometry;
  IGRuchar			curve_type;

  extern IGRboolean             WANT_POST220_BEHAVIOR;
  struct EMSpartolbasis         tol_basis;


  /*
   * Due to the method of construction of the spherical patch, it is possible
   * for the third arc to be not between points 2 and 3.  In such cases, an
   * edge between these two points must be imposed (arc3_tobe_imposed
   * == TRUE).
   */
      IGRboolean		arc3_tobe_imposed;

  IGRboolean			geometry_changed,	reverse_b;
  GRclassid			blend_classid;
  GRspacenum			current_os;

  struct EMSedge_rnd_info	*ith_ed_rnd_info, *i_plus_1_ed_rnd_info;
  struct EMSsolid_srf_info	solid_srf_info[ NUMBER_OF_VTX_EDGES ];
  struct EMSfillet_srf_info	fillet_srf_info[ NUMBER_OF_VTX_EDGES ];
  struct EMSpatch_info		vertex_patch_info;
  struct EMSdataselect		fillet_inter_UV_data,
				inter_XYZ_data,
				object_a_UV_data,
				xyz_data,
				uvdata,
				new_uvdata;

  struct GRid			*vertex_edge;
  extern GRclassid 		OPP_EMSgenbs_class_id,
				OPP_EMSrevol_class_id,
				OPP_EMSplane_class_id;

  extern IGRuchar		EMcurve_typing();
  extern struct EMSintobj	*EMmakeintlist();

  extern IGRdouble		EMget_fillet_intpln_data();
  extern void			EMget_included_data();


 /*
  * Note the following element relationships.
  *
  * solid_srf_info[ 0 ] surface bounded by edges vertex_info->edge_infos[ 0 ]
  *			   and vertex_info->edge_info[ 1 ].
  *
  * solid_srf_info[ 1 ] surface bounded by edges vertex_info->edge_infos[ 1 ]
  *			   and vertex_info->edge_info[ 2 ].
  *
  * solid_srf_info[ 2 ] surface bounded by edges vertex_info->edge_infos[ 2 ]
  *			   and vertex_info->edge_info[ 0 ].
  *
  * There is a one-to-one correspondence between elements in vertex_info->
  * edge_infos array and fillet_srf_info array (i.e. fillet_srf_info[ 0 ] is
  * the fillet on the 0th edge, etc.)
  */

    /*
     * Initialization.
     */
        *EMmsg = EMS_S_Success;
        om_stat= OM_S_SUCCESS;
	current_os = construct_list->env_info->md_id.osnum;
	ptr = NULL;
        old_geometry = NULL;
	geometry_changed = FALSE;
        vertex_patch_info.objid = NULL_OBJID;

	BSEXTRACTPAR( &msg, BSTOLCHRDHT, cht_tole );
	BSEXTRACTPAR( &msg, BSTOLBASIS, basis_tole );

    /* Taken each pair of fillets (in the cyclic ordering of edges at the
     * round vertex) gather the following information.  Note that there
     * will be a common defining surface (for each such pair of fillets). Let
     * this surface be sf1.
     * . Determine sf1 object, its geometry, and its parametric tolerance.
     * . Determine the intersection of the two fillets on sf1.  Due to the
     *   method of fillet creation this intersection is guaranteed to be
     *   only within twice chord height tolerance.  Subsequent fillet
     *   refinement would provide increased accuracy.
     */
      for( i = 0; i < NUMBER_OF_VTX_EDGES; i++ )
      {
         ith_ed_rnd_info = vertex_info->edge_infos[ i ];
         i_plus_1_ed_rnd_info = ( i == NUMBER_OF_VTX_EDGES - 1 )
					 ? vertex_info->edge_infos[ 0 ]
					 : vertex_info->edge_infos[ i + 1 ];

         EMget_rnd_included_data( &msg, ith_ed_rnd_info, i_plus_1_ed_rnd_info,
             vertex_info->vtx_pt, &solid_srf_info[i].objid,
             &solid_srf_info[i].geometry, solid_srf_info[i].UV,
             fillet_param, NULL, inter_pt_xyz /* on the ith edge fillet */
             );
         EMerr_hndlr( !( 1 & msg ), *EMmsg, EMS_E_Fail, wrapup );
 
         BSsfkttol2( solid_srf_info[i].geometry->u_order,
 		     solid_srf_info[i].geometry->v_order,
                     solid_srf_info[i].geometry->u_knots,
		     solid_srf_info[i].geometry->v_knots,
                     solid_srf_info[i].geometry->u_num_poles,
		     solid_srf_info[i].geometry->v_num_poles,
                     solid_srf_info[i].geometry->poles,
		     solid_srf_info[i].geometry->weights,
                     &solid_srf_info[i].knot_tole,
		     &msg );

         EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup);

         BSsfeval( solid_srf_info[i].geometry, solid_srf_info[i].UV[ u ],
                   solid_srf_info[i].UV[ v ], 0, &solid_srf_info[i].XYZ,
                   &msg );
         EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );

         inx1 = IF_EQ_OBJID( solid_srf_info[i].objid,
                             ith_ed_rnd_info->surf_id ) ? U0 : U1;
         fillet_srf_info[i].U0_on_srf = inx1 == U0 ? TRUE : FALSE;
         OM_BLOCK_MOVE( fillet_param[ FIRST ],
                        fillet_srf_info[i].UV[ inx1 ],
                        UV_DIM * sizeof( IGRdouble ) );

         OM_BLOCK_MOVE( inter_pt_xyz, fillet_srf_info[i].XYZ[ inx1 ],
                        XYZ_DIM * sizeof( IGRdouble ) );

         inx1 = i == NUMBER_OF_VTX_EDGES - 1 ? 0 : i+1;
         inx2 = IF_EQ_OBJID( solid_srf_info[i].objid,
                             i_plus_1_ed_rnd_info->surf_id ) ? U0 : U1;
         OM_BLOCK_MOVE( fillet_param[ SECOND ],
                        fillet_srf_info[ inx1 ].UV[ inx2 ],
                        UV_DIM * sizeof( IGRdouble ) );

         BSsfeval( i_plus_1_ed_rnd_info->fill_surf,
                   fillet_srf_info[ inx1 ].UV[ inx2 ][ u ],
                   fillet_srf_info[ inx1 ].UV[ inx2 ][ v ],
                   0, &fillet_srf_info[ inx1 ].XYZ[ inx2 ], &msg );
         EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );
      }

    /* If needed, refine the three fillets at the round vertex.  This will
     * redefine the intersection information generated during the preceeding
     * step.
     */
        /* First, determine whether any fillet refinement is required.
         * Although this decision is based on at least one fillet being
         * inaccurate, the actual refinement occurs only on those fillets
         * that are inaccurate (i.e. BSGEN_BSP_SF).
         */
/*
   SKIP REFINEMENT (SCREWS UP FILLETS) - SS (09/02/93)

           for( i = 0; i < NUMBER_OF_VTX_EDGES; i++ )

              if( vertex_info->edge_stops[i] == TRUE
                    ? ( vertex_info->edge_infos[i]->props
                         & EMSfillet_inaccurate_atstop ? TRUE : FALSE )
                    : ( vertex_info->edge_infos[i]->props
                         & EMSfillet_inaccurate_atstart ? TRUE : FALSE )
                   == TRUE )
              {
                  om_stat = refine_fillets( &msg, construct_list->env_info,
                             vertex_info, solid_srf_info, fillet_srf_info );
                  if( 1 & om_stat & msg )

                     for( j = 0; j < NUMBER_OF_VTX_EDGES; j++ )
                        vertex_info->edge_infos[j]->props &=
                            vertex_info->edge_stops[j] == TRUE
                               ? ~EMSfillet_inaccurate_atstop
                               : ~EMSfillet_inaccurate_atstart;
                  break;
              }
*/
    /*
     * Construct the vertex patch geometry [spherical patch (rounding) or the
     * planar patch (chamfering)].
     */
        vertex_patch_info.geometry.poles = NULL;
	vertex_patch_info.geometry.u_knots = NULL;
	vertex_patch_info.geometry.v_knots = NULL;
	vertex_patch_info.geometry.bdrys   = NULL;
	vertex_patch_info.geometry.weights = NULL;

        arc3_tobe_imposed = FALSE;
       
        if( options & EMS_RND_CHAMFER )
        {
	     /*
	      * The three points to the following function are passed in
	      * an order such that the first arc will be across vertex_infos->
	      * edge_info[ 0 ], the second arc will be across vertex_infos->
	      * edge_info[ 1 ], and the third arc will be across vertex_infos->
	      * edge_info[ 2 ].
	      */
                 get_surface_by_3pts( &msg,
			              ( IGRushort ) 0,
				      solid_srf_info[ 0 ].XYZ,
                                      solid_srf_info[ 2 ].XYZ,
				      solid_srf_info[ 1 ].XYZ,
                                      vertex_info->edge_infos[FIRST]->radius,
				      &vertex_patch_info
				    );

		 EMerr_hndlr( !( 1 & msg ), *EMmsg, msg, wrapup );

                 blend_classid = OPP_EMSgenbs_class_id;
        }
        else 
        {
           get_sph_patch( &msg,
			  ( IGRushort ) 0,
                          vertex_info,
		          solid_srf_info,
		          &vertex_patch_info,
			  &arc3_tobe_imposed
			);

	   EMerr_hndlr( !( 1 & msg ), *EMmsg, msg, wrapup );

           blend_classid = OPP_EMSrevol_class_id;
        }

    /*
     * Orient the vertex patch normal with respect to the solid.
     */
        {
           IGRvector	vector1,
			vector2;
	   IGRpoint	pt_on_srf;
           IGRdouble	temp1,
			temp2;

	   /*
	    * Obtain the vertex patch normal at (0,0)
	    */
	       temp1 = temp2 = 0.0;
               BSsfarrevn( &msg,
		           &vertex_patch_info.geometry,
		           ( IGRint ) 1,
		           &temp1,
		           ( IGRint ) 1,
		           &temp2,
		           pt_on_srf,
		           vector1 );

               EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );

           /*
	    * Obtain the normal at the intersection point on the first
	    * surface.
	    */
               BSsfarrevn( &msg,
	       		   solid_srf_info[ 0 ].geometry,
	       		   ( IGRint ) 1,
	       		   &solid_srf_info[ 0 ].UV[0],
	       		   ( IGRint ) 1,
	       		   &solid_srf_info[ 0 ].UV[1],
	       		   pt_on_srf,
	       		   vector2 );

               EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );

           /*
	    * if the pos orient is false reverse the normal vector.
	    */
               if( solid_srf_info[ 0 ].geometry->pos_orient == FALSE )
                  for( i = 0; i < 3; i++ )
			vector2[ i ] = -vector2[ i ];

	   /*
	    * Orient the vertex patch normal.
	    */
	        temp1 = BSdotp( &msg, vector1, vector2 );

	        EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );

                vertex_patch_info.geometry.pos_orient = 
				temp1 > 0.0 ? TRUE : FALSE;
	}

    /*
     * Determine the knot tolerance for the vertex patch.
     */
        BSsfkttol2( vertex_patch_info.geometry.u_order,
		    vertex_patch_info.geometry.v_order,
                    vertex_patch_info.geometry.u_knots,
		    vertex_patch_info.geometry.v_knots,
                    vertex_patch_info.geometry.u_num_poles,
		    vertex_patch_info.geometry.v_num_poles,
                    vertex_patch_info.geometry.poles,
		    vertex_patch_info.geometry.weights,
                    &vertex_patch_info.knot_tole,
		    &msg );

        EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup);

    /*
     * construct a graphic object out of the 'vertex_patch_info'.
     */
	/*
	 * To be on the conservative side, save the existing value of
	 * geometry, and restore it in wrapup.
	 */
	    old_geometry = construct_list->geometry;
	    geometry_changed = TRUE;
	    construct_list->geometry = ( IGRchar * ) &vertex_patch_info.
							geometry;

	    om_stat = om$construct( classid   = blend_classid,
                                    p_objid   = &vertex_patch_info.objid,
                                    msg       = message GRgraphics.GRconstruct
						( construct_list )
				  );
	    EMerr_hndlr( !( 1 & om_stat ), *EMmsg, EMS_E_OMerror, wrapup );

    /*
     * Connect this blend to the composite surface.
     */
        {
           OM_S_CHANSELECT	to_components;
       
           EMmake_chanselect( GRcmpowner_to_components,
			      &to_components );

           om_stat = om$get_channel_count( osnum = compsf_GRid->osnum,
                                           objid = compsf_GRid->objid,
                                           p_chanselect = &to_components,
                                           count        = &index);

           EMerr_hndlr( !(1 & om_stat), *EMmsg, EMS_E_OMerror, wrapup );

           om_stat = om$send( msg = message GRconnector.GRrigidconn(
					&msg,
                                        compsf_GRid,
					(IGRlong *)&index ),
                              senderid = NULL_OBJID,
                              targetid = vertex_patch_info.objid );

           EMerr_hndlr( !(1 & om_stat & msg ), *EMmsg, msg, wrapup );
       }


    /*
     * Make natural boundaries for the vertex patch.
     */
        om_stat = om$send( msg = message EMSsurface.EMmk_nat_bdry(
				&msg,
			        &construct_list->env_info->md_env,
				vertex_patch_info.natural_edges ),
			   senderid = NULL_OBJID,
			   targetid = vertex_patch_info.objid );	

        EMerr_hndlr( !(1 & om_stat & msg), *EMmsg, msg, wrapup );

     if( (options & EMS_RND_CHAMFER) && WANT_POST220_BEHAVIOR )
     {
       curve_type = EMpoint;
       om_stat = om$send( msg = message EMSedge.EMset_type(&msg,
					curve_type),
			senderid = NULL_OBJID,
                        targetid = vertex_patch_info.natural_edges[0]);
       EMerr_hndlr( !(1 & om_stat & msg), *EMmsg, msg, wrapup );

       om_stat = om$send( msg = message EMSedge.EMset_props(&msg,
						EMED_DEGENERATE,
					        EMS_O_ON),
			senderid = NULL_OBJID,
                        targetid = vertex_patch_info.natural_edges[0]);
       EMerr_hndlr( !(1 & om_stat & msg), *EMmsg, msg, wrapup );
      }


    /*
     * At this point, the geometry and the topology of the vertex patch is
     * established.  The remaining work is as follows.
     *
     * 1 If the vertex patch is a partial sphere, it is possible that arc3
     *   does not form a natural boundary of the vertex patch (i.e. the
     *   patch extends beyond arc3, which is between points 2 and 3).  If so,
     *   impose that arc as the boundary of the spherical patch between
     *   points 2 and 3 [also see comments in 'get_sph_patch()'].
     *
     *   NOTE:
     *   The correspondence between, the array of arcs of the vertex patch,
     *   and the array of natural edges of that patch is as follows.
     *
     *   vertex_patch_info.arcs[ 0 ] -> vertex_patch_info.natural_edges[ 3 ],
     *					V=0
     *   vertex_patch_info.arcs[ 1 ] -> vertex_patch_info.natural_edges[ 1 ],
     *					V=1
     *   vertex_patch_info.arcs[ 2 ] -> vertex_patch_info.natural_edges[ 2 ],
     *					U=1
     *   Note that U=0 edge on the vertex patch is degenerate in XYZ space.
     *
     *   Since arc three is parameterized from second point to the third on
     *   the spherical patch, its direction needs to be reversed prior to
     *   imposing it, so that when it is mapped onto the UV space of the patch,
     *   its orientation will be correct with respect to the other edges in
     *   that space.
     *
     * 2 On imposing arc3, it is possible that the corresponding ends on arcs
     *   one and two are not coincident with those of arc3.  Make necessary
     *   corrections to the appropriate ends of arcs 1 and 2.
     *
     * 3 Generate the intersections on the fillets.
     *
     * 4 Add the vertex patch, its edges, fillet surfaces and their intersec-
     *   tions to the inters lists.
     */

     {
	   /*
	    * Do 1 and 2.
	    */

           IGRboolean			all_pts_onSurf;
           IGRdouble			endpts[4];
           struct IGRpolyline		poly;
           GRobjid			new_edge;

           /*
	    * Re-orient arcs 3, so that it matches the orientation
	    * of the natural edges in UV space.
            */
	       /*
		* The arcs at this stage are guaranteed to be bsp curves.
		*/
		   if( !( options & EMS_RND_CHAMFER ) )
		   {
                      BSrev_cv(&msg, vertex_patch_info.arcs[ 2 ] );
                      EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror,
				   wrapup );
                      BSrev_cv(&msg, vertex_patch_info.arcs[ 0 ] );
                      EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror,
				   wrapup );
		   }

	   /*
	    * Obtain the correspondence between vertex patch edges, and the
            * corresponding solid edges.  ex: the objid of arc0 (which is
            * across the 0th edge), will be in fillet_common_edge[0], and so
            * on for others, in the cyclic ordering of the edges, at the
            * vertex.
	    */
               fillet_common_edge[0] = vertex_patch_info.natural_edges[3];
               fillet_common_edge[1] = vertex_patch_info.natural_edges[1];
               fillet_common_edge[2] = vertex_patch_info.natural_edges[2];
         
	   /*
	    * If required, impose arc3 on the vertex patch (and correct
	    * the edge in 'fillet_common_edge[ 2 ]').
	    */
	       if( arc3_tobe_imposed == TRUE )
               {
                  OM_S_CHANSELECT	to_owner,
					to_loopset;
		  IGRushort		srf_is_planar = EMS_O_NonPlanar;
      
                  xyz_data.datatype = EMSdata_curve3d;
                  xyz_data.data.curve = vertex_patch_info.arcs[ 2 ];

                  EMmapcvxyz_to_uv( &msg,
                                    EMS_RMED_ALNG_NATBDRY |
                                    EMS_TRIM_AGAINST_NATBDRY,
                                    &vertex_patch_info.geometry,
                                    &xyz_data,
                                    cht_tole,
                                    vertex_patch_info.knot_tole,
                                    &srf_is_planar,
                                    &uvdata,
                                    &all_pts_onSurf );

                  EMerr_hndlr(! (1 & msg), *EMmsg, msg, wrapup );

                  /* Due to the specification of 'EMS_O_NonPlanar' in the
		   * preceding call, 'uvdata' will be of type EMSdata_poly2d.
                   * It is possible for the curve in UV space obtained here to
		   * fall short of either of the natural boundaries of the
		   * spherical patch.  If this occurs, correct it.
                   */
		      if( uvdata.datatype == EMSdata_poly2d )
		      {
                         uvdata.data.poly->points[ 1 ] = 1.0;
                         num = uvdata.data.poly->num_points;
                         uvdata.data.poly->points[ 2 * num - 1] = 0.0;
		      }
		      else
		      {
		         *EMmsg = EMS_E_Fail;
			 goto wrapup;
		      }

	          /*
	           * Create a line edge with the mapped UV data (this
		   * line edge will repplace the existing U=1 edge
		   * on the sperical vertex patch).
	           */
                      tol_basis.is_valid = TRUE;
                      tol_basis.in_world = FALSE;
                      tol_basis.tol      = vertex_patch_info.knot_tole;
                      tol_basis.mattyp   = &construct_list->env_info->
							md_env.matrix_type;
                      tol_basis.mat      = construct_list->env_info->
							      md_env.matrix;

                      om_stat = om$construct(
					 classid = OPP_EMSlinedge_class_id,
				         p_objid = &new_edge,
                                         msg     = message EMSlinedge.EMleinit
						  ( &msg,
						    EMED_OPEN,
				                    EMlinestring,
				                    uvdata.data.poly,
						    &tol_basis,
				                    ( IGRushort ) 0,
						    vertex_patch_info.objid
					          )
					    );

                      EMerr_hndlr( !( 1 & om_stat & msg ), *EMmsg, msg,
				   wrapup );

		  /* replace the index 2 edge in the natural loop with the
                   * above edge
                   */
                      om_stat = om$send( msg = message EMSedge.EMreplace_edge
						( &msg,
						  new_edge,
						  TRUE
						),
				   senderid = NULL_OBJID,
				   targetid = vertex_patch_info.
							natural_edges[ 2 ]
				       );

                      EMerr_hndlr( !(1 & om_stat & msg), *EMmsg, msg , wrapup );

                      fillet_common_edge[ 2 ] = new_edge;

                  /*
	           * On imposing arc3, the end points of arcs 1 and 2 that
	           * corresponds to the ends of arc3 might need to be adjusted
	           * in UV space.  Recall that the ends of arc3 has already
		   * been forced to lie on edges V=1 and V=0.  So, the
		   * following correction will result in moving the effected
		   * end of arc1 along V=0 (such that it is coincident with
		   * arc3 end), and moving the effected end of arc2 along V=1
		   * (such that it will be coincident with arc3 end).  The
		   * index for the for loop is chosen to match the index into
		   * the array that contains the natural edges.
	           */
                      for( i = 1; i <= 3; i += 2 )
                      {
                         if( i == 1 )
                         {
		            /*
			     * Get the new end points for arc2.  Both ends are
			     * obtained since the natural edge is replaced by
			     * a circular arc.  However, only the effected end
			     * is corrected.  Observe that the end points are
			     * ordered such that they will not violate the
			     * orientation of edges in the UV space.
			     */
                                endpts[0] = 0;
                                endpts[1] = 1.0;
                                endpts[2] = uvdata.data.poly->points[0];
                                endpts[3] = uvdata.data.poly->points[1];
                         }
                         else
                         {
		            /*
		             * Get the new end points for arc1.  Both ends are
			     * obtained since the natural edge is replaced by
			     * a circular arc.  However, only the effected end
			     * is corrected.  Observe that the end points are
			     * ordered such that they will not violate the
			     * orientation of edges in the UV space.
			     */
                                num = uvdata.data.poly->num_points;

                                endpts[0] = uvdata.data.poly->points[ 2*num-2 ];
                                endpts[1] = uvdata.data.poly->points[ 2*num-1 ];
                                endpts[2] = 0.0;
                                endpts[3] = 0.0;
                         }

		         /*
		          * Make a line edge (with a circular arc curve type)
		          * for the new edge.
		          */
                             poly.num_points = 2;
                             poly.points     = endpts;

                             om_stat = om$construct(
				      classid = OPP_EMSlinedge_class_id,
				      p_objid = &new_edge,
                                      msg     = message EMSlinedge.EMleinit(
						  &msg,
						  EMED_OPEN | EMED_ISO,
				                  EMcircular_arc,
				                  &poly,
						  &tol_basis,
						  NULL,
						  vertex_patch_info.objid )
					     );

                             EMerr_hndlr( !(1 & om_stat & msg ), *EMmsg, msg,
				       wrapup );

                         /*
		          * Replace either V=0 edge (i = 3), or V=1 edge
		          * (i = 1 ).
		          */
                             om_stat = om$send( msg = message 
						EMSedge.EMreplace_edge
							( &msg,
						          new_edge,
							  TRUE
							),
				           senderid = NULL_OBJID,
				           targetid = vertex_patch_info.
						       natural_edges[ i ]
					 );
                             EMerr_hndlr( !(1 & om_stat & msg), *EMmsg,
				          msg, wrapup );

		         /*
		          * Reflect the changes in the following array.
		          */
                             fillet_common_edge[ ( i == 1 )?1:0 ] =  new_edge;
                      }

                  /* Since the edges of the vertex patch are no longer natural
		   * edges (except U=0 which is degenerate in XYZ space), its
		   * loop and the loop set are also not natural.
		   * The replace edge message does not implicitly modify the
		   * loop and loopset properties. So set the property on the
		   * loop and the loopset, to indicate that they are no longer
		   * natural.
                   */
                      EMmake_chanselect( EMSsubbs_to_loopset, &to_loopset );

                      om_stat = om$send( msg = message EMSloopset.EMset_props
						(
						  &msg, 
                                                  EMLS_NATURAL,
						  EMS_O_OFF
						),
                                         senderid = vertex_patch_info.objid,
                                         p_chanselect = &to_loopset
				       );
                      EMerr_hndlr( !( 1 & om_stat & msg ), *EMmsg, msg,
				   wrapup );
             
		      /*
		       * Pick any edge of the vertex patch, and send to its
		       * owner loop.
		       */
                          EMmake_chanselect( EMSedge_to_owner, &to_owner );
                          om_stat = om$send( msg = message EMSloop.EMset_props
					      (
						&msg, 
                                                EMLP_NATURAL,
						EMS_O_OFF
					      ),
                                             senderid = fillet_common_edge[ 2 ],
                                             p_chanselect = &to_owner
				           );

                          EMerr_hndlr( !( 1 & om_stat & msg), *EMmsg, msg,
			               wrapup );

		      /*
		       * Since the loop got changed (from natural to non-
		       * natural) need to construct the appropriate
		       * graphics object.
		       */
                          om_stat = om$send( msg = message EMSloop.EMmakeFRT
				            (
					       &msg,
				               vertex_patch_info.objid
					    ),
                                      senderid = fillet_common_edge[ 2 ],
                                      p_chanselect = &to_owner
				    );

                          EMerr_hndlr( !( 1 & om_stat & msg ), *EMmsg, msg,
				       wrapup );
               }
          }

          /*
           * Set the tangent property, on the patch edges.
           */
              if( !( options & EMS_RND_CHAMFER ) )
              {
                 for( i = 0; i < 3; i++ )
                 {
                    om_stat = om$send( msg = message EMSedge.EMset_props
					  ( &msg,
					    EMED_TANGENT,
					    EMS_O_ON
					  ),
				       targetid = fillet_common_edge[i],
				       senderid = NULL_OBJID );
		    EMerr_hndlr( !( 1 & msg &om_stat ), *EMmsg, msg,
			         wrapup );
                 }

                 /*
	          * XYZ degeneracy of natural edge U0 is already set
                  * (in make nat edges).
                  */
              }

	  /*
	   * Do 3 and 4.
	   */
		 for( i = 0; i < 3 /* do for three fillets */ ; i++ )
		 {
                   IGRboolean 		lo_to_hi, reverse_uv, opp_flow;
                   IGRdouble		uv_endpts[2][2];
                           
                    reverse_b = FALSE;
		    /*
		     * Generate the intersection curve on the fillet.
                     *   . Form an infinite plane passing through the
                     *     center of the spherical patch, and the two
	             *     intersect points on the fillet.
		     *   . Intersect that plane with the fillet surface.
	             *     The resulting curve is the intersection on the
	             *     fillet.
		     */
                           ith_ed_rnd_info = vertex_info->edge_infos[i];
	                   EMget_fillet_intpln_data (&msg, NULL,
                                ith_ed_rnd_info,
				fillet_srf_info[i].XYZ[0],
				fillet_srf_info[i].XYZ[1],
				vertex_patch_info.center,
				fillet_srf_info[i].XYZ[0],
                                current_os, vertex_info->edge_stops[i],
				&fillet_inter_UV_data,
				&inter_XYZ_data, NULL);
	                   EMerr_hndlr( !( 1 & msg ), *EMmsg, msg, wrapup );

                          curve_type = EMcurve_typing (&fillet_inter_UV_data,
                                        &inter_XYZ_data);

             /*
              * Orient the intersection on the fillet such that it encloses
              * area on the side of the fillet that is away from this
              * vertex.
              */

             EMgetendpts_uv (&msg, &fillet_inter_UV_data, FALSE, 1,
              uv_endpts[START], uv_endpts[STOP]);
             EMerr_hndlr (EMSerror (msg), *EMmsg, EMS_E_Fail, wrapup);

             if (uv_endpts[START][U] < uv_endpts[STOP][U])
               lo_to_hi = TRUE;
             else
               lo_to_hi = FALSE;

             if ((ith_ed_rnd_info->props & EMSfillet_v0_closeto_start_end ?
                  0x1 : 0x0) ^
                 (vertex_info->edge_stops[i] ?
                  0x1 : 0x0))
               {
               /*
                * The correct orientation will have the uv-data going from
                * U1 to U0, that is, high u-value to low u-value. If this
                * is not the case a reversal has to be effected.
                */

               if (lo_to_hi)
                 reverse_uv = TRUE;
               else
                 reverse_uv = FALSE;
               }
             else
               {
               /*
                * The correct orientation will have the uv-data going from
                * U0 to U1, that is, low u-value to high u-value. If this
                * is not the case a reversal has to be effected.
                */

               if (lo_to_hi)
                 reverse_uv = FALSE;
               else
                 reverse_uv = TRUE;
               }

             /*
              * We know that the corresponding uv-data on the spherical
              * patch is correctly oriented (after applying the reverse_uv
              * flag on the fillet-uv). So, if the two surfaces
              * are common connected at this edge, we know how the edges
              * must flow (a la winged-edged topology). If the both the
              * surfaces (sph patch and the fillet, resp) are oriented
              * consistently the edges must be flowing in opposite directions.
              * In this latter case, to make the xyz data consistent for both
              * the uvs we have reverse the fillet-data and note that
              * the intobj generated will have the reverse property.
              */

             if ((ith_ed_rnd_info->fill_surf->pos_orient ?
                  0x1 : 0x0) ^
                 (vertex_patch_info.geometry.pos_orient ?
                  0x1 : 0x0))
               opp_flow = FALSE;
             else
               opp_flow = TRUE;

             if (reverse_uv ^ opp_flow)
               {
               EMdata_reverse (&fillet_inter_UV_data);
               EMdata_reverse (&inter_XYZ_data);
               }
       
             if (opp_flow)
               reverse_b = TRUE;
             else
               reverse_b = FALSE;

             /*
              * Convert the intersection into an edge object.  Tangency
              * is recorded in the intersections 'props' field.
              */

           EMmkintdata( &msg,
			&fillet_inter_UV_data,
			curve_type,
			( IGRushort ) 0,
			FALSE,
			NULL,
			construct_list,
			TRUE,
			NULL,
			NULL,
			&new_uvdata );

  	   EMerr_hndlr( !( 1 & msg ), *EMmsg, msg,
			wrapup );
           fillet_inter_UV_data = new_uvdata;

  		    /*
		     * Now, place the intersection in the inters lists.
		     */
		        {
			   struct GRid	object_a, object_b;

			   object_a.objid = vertex_patch_info.objid;
			   object_b.objid = vertex_info->edge_infos[ i ]->
								   fill_id;
			   object_a.osnum = object_b.osnum = current_os;

                           vertex_edge = ( struct GRid * ) om$malloc
					( size = sizeof( struct GRid ) );
                           EMerr_hndlr( !vertex_edge, *EMmsg,
					EMS_E_NoDynamicMemory, wrapup );

                           vertex_edge->objid = fillet_common_edge[i];
                           vertex_edge->osnum = current_os;

                           object_a_UV_data.datatype = EMSdata_object;
                           object_a_UV_data.data.object = vertex_edge;

                           inter_XYZ_data.datatype = EMSdata_curve3d;
			   inter_XYZ_data.data.curve =
						vertex_patch_info.arcs[i];
           
                           EMmakeintlist( &msg,
					inters1,
					inters1,
					&object_a,
					&object_b,
                        		NULL,
					NULL,
					/* inters_a props.  The following
					 * prevents the spherical patch from
					 * being processed through STEP 6 in
					 * EMround() (since it already has its
					 * final loop in place).
					 */
					   EMSinters_loopcreated,
					NULL,
                                        &inter_XYZ_data,
					&object_a_UV_data,
					&fillet_inter_UV_data,
					FALSE,
                                        reverse_b,
					NULL, NULL,
					EMSintobj_marked | EMSintobj_tangent,
					EMSintobj_marked | EMSintobj_tangent,
                                        NULL,
                                        NULL,
					TRUE,
					FALSE
				     );

			   EMerr_hndlr( !( 1 & msg ), *EMmsg, msg, wrapup );
			   can_do_blend = FALSE;
		        }
		 }

wrapup:

 /* fix for mlk */
   if(vertex_patch_info.geometry.poles)
     {
     om$dealloc(ptr = vertex_patch_info.geometry.poles);
     vertex_patch_info.geometry.poles = NULL;
     }
   if( geometry_changed == TRUE )
      construct_list->geometry = old_geometry;

   if (EMSerror (om_stat & *EMmsg) && can_do_blend)
     {
     if (!IF_NULL_OBJID (vertex_patch_info.objid))
       om$send (msg = message GRgraphics.GRdelete (&msg, 
        construct_list->env_info), targetid = vertex_patch_info.objid,
        targetos = construct_list->env_info->md_id.osnum,
        senderid = NULL_OBJID);

     om_stat = EMget_n_sided_blend (EMmsg, options, construct_list,
                vertex_info, compsf_GRid, inters1, NULL);
     }
   EMWRAPUP( *EMmsg, om_stat, "EMspherical_blend" );
   return( om_stat );
}



/*

 *  DESCRIPTION:

	Given three xyz points potentially lying on a sphere, this function
	yeilds a spherical patch with the following characteristics (note
	that only the geometry of the patch is generated by this function.
	The caller must impose topology).

	Some terminology:

          Let first, second and third points on the spherical patch refer to
          those xyz points in the order they are specified to 'bspsph3pts'
          arc1 is the xyz curve from the first to the second point (thus the
	  parameterization of this curve is such that U=0 on the curve is the
	  first point)
  	  arc2 is the xyz curve from the first to the third point.
	  arc3 is the xyz curve from the second to the third point.

	Patch characteristics:

	. The patch is large enough to contain the three points.  Its
	  parameterization is as follows.

          The origin of the parametric space of the patch will be the
	  first point.
          U direction will lie along arc1.
	  V direction will lie along arc3.

          U=0 is the degenerate edge at the first point.
          U=1 is the third arc.
          V=0 is the first arc.
          V=1 is the second arc.

        . The patch is generated by sweeping arc1 by an angle determined by
	  the three points (i.e. it is swept until the third point lies on
	  the surface). Since it is possible for the arc length of arc2 to be
	  greater than that of arc1 (in which case, the sweep of arc1 would
	  miss point three), first, if neccessary, arc1 is extended such that
	  the patch generated by sweeping arc1 is guaranteed to contain the
	  third point.  However, this can result in a patch that is NOT
	  bounded by the three natural edges corresponding to the three arcs.
	  arc1 and arc2 always bound the patch, but arc3 may have to be
	  imposed (see output variable 'arc3_tobe_imposed').

 *  Input:

	options		Currently unused.
	vertex_info	Instance of EMSvtx_rnd_info containing information
			concerning the current edge vertex being processed.
 *  Input/Output:

	solid_srf_info	Information concerning each of the surfaces at the
			vertex.
			The points on each of the surfaces, originally
			generated by intersecting the two fillets on the
			surface (consiquently candidate points for being
			on the sphere) are updated within this function
			(the original points are NOT guaranteed to be on
			a sphere).

 *   Output:

	EMmsg			Return code.
	spherical_patch_info	Information concerning the soherical patch
				generated within this function.
				 . geometry
				 . the three arcs in xyz.
				 . patch tolerance.
				 . patch center.
	arc3_tobe_imposed	If arc3 is not a natural boundary, then
				this boolean is set to true, indicating
				that arc3 need to be imposed as a boundary
				of the spherical patch.

 *   HISTORY:

	Janaka	Apr 15, 1992	Added this function description, and made
				numerous changes to the function.

	Inasu	?, 1991		Genesis.
*/
	
#argsused

static void get_sph_patch( EMmsg, options, vertex_info,
			   solid_srf_info,
			   spherical_patch_info,
			   arc3_tobe_imposed )

IGRlong				*EMmsg;
IGRushort			options;
struct EMSvtx_rnd_info		*vertex_info;
struct EMSsolid_srf_info	*solid_srf_info;
struct EMSpatch_info		*spherical_patch_info;
IGRboolean			*arc3_tobe_imposed;

{
 IGRlong		msg;

 IGRint			i,
			index,
			num;

 IGRdouble		offset_dist[3],
			urange[3][2],
			vrange[3][2],
                        delta,
                        knot_tol[3],
			*buffer;

 IGRboolean		is_success;

 IGRushort		oriented,
			is_convex;

    /*
     * Initialization.
     */
        *EMmsg = EMS_S_Success;
	buffer = NULL;
 
    /*
     * Get the center point of the partial sphere, by intersecting three
     * offset surfaces derived from the three solid's surfaces at the
     * current round vertex.
     */
        /*
         * The following required to determine the direction of offset.
	 * Recall that the round vertex is 3-edge-homog, and all edges are
	 * being rounded.  So, the following classification is applicable to
	 * all edges at this three vertex.
         */
            is_convex = ( vertex_info->edge_configs[0] == EMSedge_convex )
								? 0x01 : 0x00;
	for( i = 0; i < NUMBER_OF_VTX_EDGES; i++ )
	{
           /*
            * get the directed offset distances for the surfaces.
	    */
               oriented = solid_srf_info[ i ].geometry->pos_orient == TRUE
				? 0x01 : 0x00;

	       offset_dist[i] = ( oriented ^ is_convex )
                         ? - ( vertex_info->edge_infos[i]->radius )
                         : vertex_info->edge_infos[i]->radius;
	}

       /*
        * Using the known u,v parameters for the points on a sphere, generate
        * a lower and a upper bound for the known u and v parameters.
        */
           delta = 0.1;
           for( i = 0; i < 3; i++)
           {
              urange[i][0] = ( solid_srf_info[i].UV[0] - delta ) < 0.0
                                ? 0.0 : ( solid_srf_info[i].UV[0] - delta );
              urange[i][1] = ( solid_srf_info[i].UV[0] + delta ) > 1.0
                                ? 1.0 : ( solid_srf_info[i].UV[0] + delta );

              vrange[i][0] = ( solid_srf_info[i].UV[1] - delta ) < 0.0
                                ? 0.0 : ( solid_srf_info[i].UV[1] - delta );
              vrange[i][1] = ( solid_srf_info[i].UV[1] + delta ) > 1.0
                                ? 1.0 : ( solid_srf_info[i].UV[1] + delta );


        BSsfkttol2(solid_srf_info[i].geometry->u_order,
                   solid_srf_info[i].geometry->v_order,
                   solid_srf_info[i].geometry->u_knots,
                   solid_srf_info[i].geometry->v_knots,
                   solid_srf_info[i].geometry->u_num_poles,
                   solid_srf_info[i].geometry->v_num_poles,
                   solid_srf_info[i].geometry->poles,
                   solid_srf_info[i].geometry->weights,
                   &knot_tol[i],&msg);

        EMerr_hndlr( (msg != BSSUCC), *EMmsg, EMS_E_BSerror, wrapup);

           }

	BStrpofsfit( solid_srf_info[ 0 ].geometry,
		     solid_srf_info[ 1 ].geometry,
		     solid_srf_info[ 2 ].geometry,
	
                     urange[0], vrange[0],
                     urange[1], vrange[1],
                     urange[2], vrange[2],

                     offset_dist[ 0 ],
		     offset_dist[ 1 ],
		     offset_dist[ 2 ],

		     solid_srf_info[ 0 ].knot_tole,
		     solid_srf_info[ 1 ].knot_tole,
		     solid_srf_info[ 2 ].knot_tole,

		     spherical_patch_info->center,

                     &solid_srf_info[0].UV[0], &solid_srf_info[0].UV[1],
                     &solid_srf_info[1].UV[0], &solid_srf_info[1].UV[1],
                     &solid_srf_info[2].UV[0], &solid_srf_info[2].UV[1],

		     &is_success,
		     &msg);

       EMerr_hndlr( (msg != BSSUCC || is_success == FALSE ), *EMmsg,
                    EMS_E_BSerror, wrapup );

    /*
     * Reevaluate the points on the three faces.
     */
        for( i = 0; i < NUMBER_OF_VTX_EDGES; i++ )
	{
	   IGRvector	normal;

	   BSsfarrevn( &msg,
		       solid_srf_info[ i ].geometry,
		       ( IGRint ) 1, &solid_srf_info[i].UV[0],
		       ( IGRint ) 1, &solid_srf_info[i].UV[1],
		       solid_srf_info[ i ].XYZ,
		       normal );

	   EMerr_hndlr( !( msg == BSSUCC ), *EMmsg, EMS_E_BSerror, wrapup );
	}

    /*
     * Allocate memory for the arcs.
     */
        for( i = 0; i < NUMBER_OF_VTX_EDGES; i++ )
        {
           spherical_patch_info->arcs[ i ] = NULL;

           BSalloccv( ( IGRshort ) 3,
		      BSCIRCLE_NUM_POLES_MAX,
		      TRUE,
		      ( IGRshort ) 0,
                      &spherical_patch_info->arcs[ i ],
		      &msg);

           EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_NoDynamicMemory,
			wrapup );
        }

    /*
     * Obtain memory for the poles, knots and weights of the spherical
     * patch.
     */
        num = /* Space for the partial sphere's poles */

	          ( BSCIRCLE_NUM_POLES_MAX * BSCIRCLE_NUM_POLES_MAX * 3 +

              /* space for the partial sphere's weights */

                    BSCIRCLE_NUM_POLES_MAX * BSCIRCLE_NUM_POLES_MAX +

              /* space for u_knots and v_knots */

                    ( BSCIRCLE_NUM_POLES_MAX + 3 ) * 2 );

        buffer = ( IGRdouble * ) om$malloc( size = num * sizeof( IGRdouble ) );

        EMerr_hndlr( ! buffer , *EMmsg, EMS_E_NoDynamicMemory, wrapup );

        index = 0;

        spherical_patch_info->geometry.poles = &buffer[ index ];
        index += BSCIRCLE_NUM_POLES_MAX * BSCIRCLE_NUM_POLES_MAX * 3;

        spherical_patch_info->geometry.weights = &buffer[ index ];
        index += BSCIRCLE_NUM_POLES_MAX * BSCIRCLE_NUM_POLES_MAX;

        spherical_patch_info->geometry.u_knots = &buffer[ index ];
        index += BSCIRCLE_NUM_POLES_MAX + 3;

        spherical_patch_info->geometry.v_knots = &buffer[ index ];


    /* Make the partial spherical patch. Notice that the points are passed
     * such that arc[i] will match with vertex_info->edge_infos[i]
     */
        BSpsph3pts( spherical_patch_info->center,
		    solid_srf_info[ 0 ].XYZ,
		    solid_srf_info[ 2 ].XYZ,
		    solid_srf_info[ 1 ].XYZ,
		    &spherical_patch_info->geometry,
 		    spherical_patch_info->arcs,
                    arc3_tobe_imposed,
		    &msg );

        EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );

wrapup:

   return;
}




/*

 * DESCRIPTION:

	Given three points, construct a ruled surface through those.
	Only the geometry of the surface is constructed.  If required, the
	user must impose topology.

 * Input:

	options			unused
	point1
	point2
	point3			The three points on the surface.

 * Output:

	patch_info		EMSpatch_info instance for the new surface.

*/

#argsused	

static void get_surface_by_3pts( EMmsg, options, 
	                         point1, point2, point3, setback,
		                 patch_info  )

IGRlong			*EMmsg;
IGRushort		options; 
IGRpoint		point1,
			point2,
			point3;
IGRdouble		setback;
struct EMSpatch_info	*patch_info;
{
  IGRlong	msg, three=3;
  IGRdouble	*buffer, *pt;
  IGRint	i, j;
  IGRpoint      pts[3];
  IGRvector     vec1, vec2, vec;
    /*
     * Intialization.
     */
        *EMmsg  = EMS_S_Success;
	buffer = NULL;

    /*
     * Obtain memory for the boundary curves geometry.
     */
        for( i = 0; i < 3; i++ )
	{
	   patch_info->arcs[i] = NULL;
	   BSalloccv( ( IGRshort ) 2,
		      2,
		      FALSE,
		      ( IGRshort ) 0,
                      &patch_info->arcs[i],
		      &msg );

	   EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );
	}

    /*
     * Since we know that the boundaries of the patch are straight lines,
     * it is possible to define the poles of the linear arcs (generated as
     * bsp curves of degree 2).  The arcs are generated as follows.
     *
     *    arc1: from point2 -> point1
     *    arc2: from point1 -> point3
     *    arc3:	from point3 -> point2
     */
        for( i = 0; i < 3; i++ )
        {
            patch_info->arcs[ 0 ]->poles[ i ] = 
		patch_info->arcs[ 2 ]->poles[ 3 + i ] = point2[ i ];

            patch_info->arcs[ 0 ]->poles[ 3 + i ] =
		patch_info->arcs[ 1 ]->poles[ i ] = point1[ i ];

            patch_info->arcs[ 1 ]->poles[ 3 + i ] =
		patch_info->arcs[ 2 ]->poles[ i ] = point3[ i ];
	}

    /*
     * Initialize other bspline data for each boundary arc.
     */
        for( i = 0; i < 3; i++ )
	{
	   patch_info->arcs[ i ]->order      = 2;
           patch_info->arcs[ i ]->num_poles  = 2;
           patch_info->arcs[ i ]->num_knots  = 4;
           patch_info->arcs[ i ]->planar     = TRUE;
           patch_info->arcs[ i ]->rational   = FALSE;
           patch_info->arcs[ i ]->weights    = NULL;
           patch_info->arcs[ i ]->phy_closed = FALSE;
	   patch_info->arcs[ i ]->periodic   = FALSE;
	   patch_info->arcs[ i ]->non_uniform = FALSE;
	   patch_info->arcs[ i ]->num_boundaries = 0;
	   patch_info->arcs[ i ]->bdrys = 0;

	   for( j = 0; j < 2; j++)
           {
              patch_info->arcs[ i ]->knots[ j ] = 0.0;
              patch_info->arcs[ i ]->knots[ 2 + j ] = 1.0;
           }
        }

    /*
     * Allocate memory for poles, u_knots and v_knots of the surfaces
     * and obtain the plane surface patch.
     */
        buffer = (IGRdouble *)om$malloc( size = 20 * sizeof(IGRdouble));
        EMerr_hndlr( !buffer , *EMmsg, EMS_E_NoDynamicMemory, wrapup);

        patch_info->geometry.poles   = buffer;
        patch_info->geometry.u_knots = &buffer[ 3 * 4];
        patch_info->geometry.v_knots = &buffer[ 3 * 4 + 4];

	BSsf3o4pts( point1, point2, point3,
		    NULL, 
		    &patch_info->geometry,
		    &msg );

	EMerr_hndlr( msg != BSSUCC, *EMmsg, EMS_E_BSerror, wrapup );

    /*
     * Determine the center as the centroid of the three input points
     * displaced along the plane normal vector by the setback distance.
     */
   
    OM_BLOCK_MOVE (point1, pts[FIRST], sizeof (IGRpoint));
    OM_BLOCK_MOVE (point2, pts[SECOND], sizeof (IGRpoint));
    OM_BLOCK_MOVE (point3, pts[THIRD], sizeof (IGRpoint));
    pt = (IGRdouble *) patch_info->center;
    MAptscentroid (&msg, pts, &three, pt);
    EMerr_hndlr (EMSerror (msg), *EMmsg, EMS_E_MAerror, wrapup);

    BSmkvec (&msg, vec1, pts[FIRST], pts[SECOND]);
    BSmkvec (&msg, vec2, pts[SECOND], pts[THIRD]);
    BScrossp (&msg, vec1, vec2, vec);
    BSnorvec (&msg, vec);

    for (i=X; i<=Z; i++)
      pt[i] += setback * vec[i];

wrapup:
    return;
}

end implementation EMSsfrndbool;

